rs/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdir.h ===
/*****************************************************************************
 *	ftpdir.h
 *****************************************************************************/

#ifndef _FTPDIR_H
#define _FTPDIR_H

#include "ftpsite.h"
#include "ftpfoldr.h"
#include "ftplist.h"
#include "ftpglob.h"
#include "ftppl.h"


typedef struct tagSETNAMEOFINFO
{
    LPCITEMIDLIST pidlOld;
    LPCITEMIDLIST pidlNew;
} SETNAMEOFINFO, * LPSETNAMEOFINFO;

int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvFtpDir, LPARAM lParam);

/*****************************************************************************\
    CLASS: CFtpDir

    DESCRIPTION:
        This class is the cache of a directory on some server.  m_pfs identifies
    the server.

    PERF - PERF - PERF - PERF
        This directory contains the folder contents in the form of a list of
    pidls (m_pflHfpl).  We need to keep them in order based on name so that
    way looking up and changing is fast because of all the work we need to do
    with change notify.  Also, when we go to parse a display name, we look here
    first, so that needs to be fast.
\*****************************************************************************/

class CFtpDir           : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);


public:
    CFtpDir();
    ~CFtpDir(void);

    // Public Member Functions
    void CollectMotd(HINTERNET hint);
    void SetCache(CFtpPidlList * pflHfpl);
    CFtpPidlList * GetHfpl(void);
    HRESULT GetHint(HWND hwnd, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CFtpFolder * pff);
    void ReleaseHint(HINTERNET hint);
    STDMETHODIMP WithHint(CStatusBar * psb, HWND hwnd, HINTPROC hp, LPCVOID pv, IUnknown * punkSite, CFtpFolder * pff);
    HRESULT SetNameOf(CFtpFolder * pff, HWND hwndOwner, LPCITEMIDLIST pidl, LPCTSTR pszName, DWORD dwReserved, LPITEMIDLIST *ppidlOut);
    BOOL IsRoot(void);
    BOOL IsCHMODSupported(void) {return m_pfs->IsCHMODSupported();};
    BOOL IsUTF8Supported(void) {return m_pfs->IsUTF8Supported();};
    HRESULT GetFindDataForDisplayPath(HWND hwnd, LPCWSTR pwzDisplayPath, LPFTP_FIND_DATA pwfd, CFtpFolder * pff);
    HRESULT GetFindData(HWND hwnd, LPCWIRESTR pwWireName, LPFTP_FIND_DATA pwfd, CFtpFolder * pff);
    HRESULT GetNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pstr);
//    HRESULT DisambiguatePidl(LPCITEMIDLIST pidl);
    CFtpSite * GetFtpSite(void);
    CFtpDir * GetSubFtpDir(CFtpFolder * pff, LPCITEMIDLIST pidl, BOOL fPublic);
    HRESULT GetDisplayPath(LPTSTR pszUrlPath, DWORD cchSize);

    LPCITEMIDLIST GetPathPidlReference(void) { return m_pidlFtpDir;};
    LPCITEMIDLIST GetPidlReference(void) { return m_pidl;};
    LPCITEMIDLIST GetPidlFromWireName(LPCWIRESTR pwWireName);
    LPCITEMIDLIST GetPidlFromDisplayName(LPCWSTR pwzDisplayName);
    LPITEMIDLIST GetSubPidl(CFtpFolder * pff, LPCITEMIDLIST pidlRelative, BOOL fPublic);
    HRESULT AddItem(LPCITEMIDLIST pidl);
    HRESULT ChangeFolderName(LPCITEMIDLIST pidlFtpPath);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest) { if (!m_pflHfpl) return S_OK; return m_pflHfpl->ReplacePidl(pidlSrc, pidlDest); };
    HRESULT DeletePidl(LPCITEMIDLIST pidl) { if (!m_pflHfpl) return S_OK; return m_pflHfpl->CompareAndDeletePidl(pidl); };

    static HRESULT _SetNameOfCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);
    static HRESULT _GetFindData(HINTERNET hint0, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);


    // Friend Functions
    friend HRESULT CFtpDir_Create(CFtpSite * pfs, LPCITEMIDLIST pidl, CFtpDir ** ppfd);

    friend int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvFtpDir, LPARAM lParam);


protected:
    int                     m_cRef;

    CFtpSite *              m_pfs;          // The FTP site I belong to. (WARNING: No Ref Held)
    CFtpPidlList *          m_pflHfpl;      // The items inside this directory
    CFtpGlob *              m_pfgMotd;      // The message of the day
    LPITEMIDLIST            m_pidlFtpDir;   // Name of subdirectory w/o Virtual Root and decoded. Doesn't include Server ID
    LPITEMIDLIST            m_pidl;         // Where we live.  May include the virtual root

    BOOL _DoesItemExist(HWND hwnd, CFtpFolder * pff, LPCITEMIDLIST pidl);
    BOOL _ConfirmReplaceWithRename(HWND hwnd);
    HRESULT _SetFtpDir(CFtpSite * pfs, CFtpDir * pfd, LPCITEMIDLIST pidl);
};

#endif // _FTPDIR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdlg.cpp ===
/*****************************************************************************\
     ftpdlg.cpp - Confirm Dialog box stuff
\*****************************************************************************/

#include "priv.h"
#include "ftpdhlp.h"

/*****************************************************************************\
      PFDI

      The fields in the fdi are as follows:

      pfdd -> dialog descriptor
      pszLocal -> ASCIIZ: Name of local file being replaced.
      pwfdRemote -> Description of remote file.
      cobj = number of objects affected

      The dialog template should have the following controls:

      IDC_REPLACE_YES        - The "Yes" button
      IDC_REPLACE_YESTOALL    - The "Yes to all" button
      IDC_REPLACE_NO        - The "No" button
      IDC_REPLACE_CANCEL    - The "Cancel" button

      Of these buttons, IDC_REPLACE_YES and IDC_REPLACE_NO are mandatory.
      If the "Yes to all" and "Cancel" buttons are available, the caller
      should set the fCanMulti flag in the fdd, in which case the extra
      buttons will be removed if cobj = 1.

      IDC_FILENAME        - A string with a '%hs' replacement field.

      The '%hs' will be replaced by the name passed in the pwfdRemote.

      IDC_REPLACE_OLDFILE    - A string which will be rewritten
      IDC_REPLACE_OLDICON    - An icon placeholder

      The string will be replaced by a description taken from pwfdRemote.
      The icon will be an icon for the file.

      IDC_REPLACE_NEWFILE    - A string which will be rewritten
      IDC_REPLACE_NEWICON    - An icon placeholder

      The string will be replaced by a description taken from pszLocal.
      The icon will be an icon for the file.
\*****************************************************************************/

class CFtpConfirmDialog
{
public:
    CFtpConfirmDialog(CFtpFolder * pff);
    ~CFtpConfirmDialog();

    UINT Display(HWND hwnd, LPCVOID pvLocal, LPCWIRESTR pwLocalWirePath, LPCWSTR pwzLocalDisplayPath, UINT fdiiLocal,
                LPCVOID pvRemote, LPCWIRESTR pwRemoteWirePath, LPCWSTR pwzRemoteDisplayPath, UINT fdiiRemote, int cobj, BOOL fAllowCancel, DWORD dwItem);
    static INT_PTR CALLBACK _FtpConfirmDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
    static BOOL _OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam);

private:
    LPCVOID             m_pvLocal;      // The local file in question
    UINT                m_fdiiLocal;
    LPCVOID             m_pvRemote;     // The remote file in question
    UINT                m_fdiiRemote;
    int                 m_cobj;         // Number of objects affected
    BOOL                m_fAllowCancel : 1;
    CFtpFolder *        m_pff;
    DWORD               m_dwItem;
    LPWIRESTR           m_pwLocalWirePath;
    LPWSTR              m_pwzLocalDisplayPath;
    LPWIRESTR           m_pwRemoteWirePath;
    LPWSTR              m_pwzRemoteDisplayPath;

    BOOL _OnInitDialog(HWND hDlg);
};


CFtpConfirmDialog::CFtpConfirmDialog(CFtpFolder * pff)
{
    m_pff = pff;
    m_pwLocalWirePath = NULL;
    m_pwzLocalDisplayPath = NULL;
    m_pwRemoteWirePath = NULL;
    m_pwzRemoteDisplayPath = NULL;
}


CFtpConfirmDialog::~CFtpConfirmDialog()
{
    Str_SetPtrA(&m_pwLocalWirePath, NULL);
    Str_SetPtrW(&m_pwzLocalDisplayPath, NULL);
    Str_SetPtrA(&m_pwRemoteWirePath, NULL);
    Str_SetPtrW(&m_pwzRemoteDisplayPath, NULL);
}


/*****************************************************************************\
    _FtpDlg_OnInitDialog
\*****************************************************************************/
BOOL CFtpConfirmDialog::_OnInitDialog(HWND hDlg)
{
    CFtpDialogTemplate ftpDialogTemplate;
    if (m_fdiiLocal == FDII_WFDA)
        EVAL(SUCCEEDED(ftpDialogTemplate.InitDialogWithFindData(hDlg, IDC_ITEM, m_pff, (const FTP_FIND_DATA *) m_pvLocal, m_pwLocalWirePath, m_pwzLocalDisplayPath)));
    else
        EVAL(SUCCEEDED(ftpDialogTemplate.InitDialog(hDlg, FALSE, IDC_ITEM , m_pff, (CFtpPidlList *) m_pvLocal)));

    if (m_fdiiLocal == FDII_WFDA)
        EVAL(SUCCEEDED(ftpDialogTemplate.InitDialogWithFindData(hDlg, IDC_ITEM2, m_pff, (const FTP_FIND_DATA *) m_pvRemote, m_pwRemoteWirePath, m_pwzRemoteDisplayPath)));
    else
        EVAL(SUCCEEDED(ftpDialogTemplate.InitDialog(hDlg, FALSE, IDC_ITEM2 , m_pff, (CFtpPidlList *) m_pvRemote)));

    return 1;
}

/*****************************************************************************\
    _FtpDlg_OnCommand
\*****************************************************************************/
BOOL CFtpConfirmDialog::_OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDC_REPLACE_YES:
    case IDC_REPLACE_YESTOALL:
        EndDialog(hdlg, idc);
        return 1;

    case IDC_REPLACE_NOTOALL:
        EndDialog(hdlg, IDC_REPLACE_NOTOALL);
        return 1;

    case IDC_REPLACE_CANCEL:
        EndDialog(hdlg, IDC_REPLACE_CANCEL);
        return 1;

        //    _UNOBVIOUS_:  Shift+No means "No to all", just like the shell.
    case IDC_REPLACE_NO:
        EndDialog(hdlg, GetKeyState(VK_SHIFT) < 0 ? IDC_REPLACE_NOTOALL : IDC_REPLACE_NO);
        return 1;
    }
    return 0;                // Not handled
}


/*****************************************************************************\
    _FtpDlg_DlgProc
\*****************************************************************************/
INT_PTR CFtpConfirmDialog::_FtpConfirmDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_INITDIALOG:
        return ((CFtpConfirmDialog *)lParam)->_OnInitDialog(hdlg);

    case WM_COMMAND:
        return CFtpConfirmDialog::_OnCommand(hdlg, wParam, lParam);
    }

    return 0;
}


UINT CFtpConfirmDialog::Display(HWND hwnd, LPCVOID pvLocal, LPCWIRESTR pwLocalWirePath, LPCWSTR pwzLocalDisplayPath, UINT fdiiLocal,
                LPCVOID pvRemote, LPCWIRESTR pwRemoteWirePath, LPCWSTR pwzRemoteDisplayPath, UINT fdiiRemote, int cobj, BOOL fAllowCancel, DWORD dwItem)
{
    m_pvLocal = pvLocal;
    m_fdiiLocal = fdiiLocal;
    m_pvRemote = pvRemote;
    m_fdiiRemote = fdiiRemote;
    m_cobj = cobj;
    m_fAllowCancel = fAllowCancel;
    m_dwItem = dwItem;

    Str_SetPtrA(&m_pwLocalWirePath, pwLocalWirePath);
    Str_SetPtrW(&m_pwzLocalDisplayPath, pwzLocalDisplayPath);
    Str_SetPtrA(&m_pwRemoteWirePath, pwRemoteWirePath);
    Str_SetPtrW(&m_pwzRemoteDisplayPath, pwzRemoteDisplayPath);

    return (UINT) DialogBoxParam(g_hinst, MAKEINTRESOURCE(dwItem), hwnd, CFtpConfirmDialog::_FtpConfirmDialogProc, (LPARAM)this);
}




/*****************************************************************************\
     FtpDlg_ConfirmReplace
\*****************************************************************************/
UINT FtpConfirmReplaceDialog(HWND hwnd, LPFTP_FIND_DATA pwfdLocal, LPWIN32_FIND_DATA pwfdRemote,
                           int cobj, CFtpFolder * pff)
{
    CFtpConfirmDialog confirmDialog(pff);
    BOOL fAllowCancel = ((cobj > 1) ? 1 : 0);
    WCHAR wzLocalDisplayPath[MAX_PATH];
    WIRECHAR wRemoteWirePath[MAX_PATH];
    CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

    EVAL(SUCCEEDED(pWireEncoding->WireBytesToUnicode(NULL, pwfdLocal->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wzLocalDisplayPath, ARRAYSIZE(wzLocalDisplayPath))));
    EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, pwfdRemote->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wRemoteWirePath, ARRAYSIZE(wRemoteWirePath))));

    return confirmDialog.Display(hwnd, (LPCVOID) pwfdLocal, pwfdLocal->cFileName, wzLocalDisplayPath, FDII_WFDA,
            pwfdRemote, wRemoteWirePath, pwfdRemote->cFileName, FDII_WFDA, cobj, fAllowCancel, IDD_REPLACE);
}


/*****************************************************************************\
     FtpDlg_ConfirmReplace
\*****************************************************************************/
UINT FtpConfirmReplaceDialog(HWND hwnd, LPWIN32_FIND_DATA pwfdLocal, LPFTP_FIND_DATA pwfdRemote,
                           int cobj, CFtpFolder * pff)
{
    CFtpConfirmDialog confirmDialog(pff);
    BOOL fAllowCancel = ((cobj > 1) ? 1 : 0);
    WIRECHAR wzLocalWirePath[MAX_PATH];
    WCHAR wRemoteDisplayPath[MAX_PATH];
    CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

    EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, pwfdLocal->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wzLocalWirePath, ARRAYSIZE(wzLocalWirePath))));
    EVAL(SUCCEEDED(pWireEncoding->WireBytesToUnicode(NULL, pwfdRemote->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wRemoteDisplayPath, ARRAYSIZE(wRemoteDisplayPath))));

    return confirmDialog.Display(hwnd, (LPCVOID) pwfdLocal, wzLocalWirePath, pwfdLocal->cFileName, FDII_WFDA,
            pwfdRemote, pwfdRemote->cFileName, wRemoteDisplayPath, FDII_WFDA, cobj, fAllowCancel, IDD_REPLACE);
}


/*****************************************************************************\
      FtpDlg_ConfirmDelete
\*****************************************************************************/
UINT FtpConfirmDeleteDialog(HWND hwnd, CFtpPidlList * pflHfpl, CFtpFolder * pff)
{
    CFtpConfirmDialog confirmDialog(pff);
    UINT id;

    if (pflHfpl->GetCount() > 1)
        id = IDD_DELETEMULTI;
    else
    {
        if (FtpPidl_IsDirectory(pflHfpl->GetPidl(0), TRUE))
            id = IDD_DELETEFOLDER;
        else
            id = IDD_DELETEFILE;
    }

    return confirmDialog.Display(hwnd, (LPCVOID) pflHfpl, NULL, NULL, FDII_HFPL, 0, 0, NULL, NULL, NULL, FALSE, id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdrop.cpp ===
/*****************************************************************************\
    FILE: ftpdrop.cpp - IDropTarget interface

    Remarks:

    Note that you cannot create a shortcut on an FTP site.  Although
    there's nothing technically preventing it, it's not done because
    the shortcut won't be of much use on an FTP site.  (It points to
    your local machine, which doesn't help much for people not on the
    same network!)

    If you really want to put a shortcut file on an FTP site, create
    it on the desktop, then drag the shortcut onto the FTP site.

    The default verb for FTP sites is always "Copy".  This is true
    even if an intra-site drag-drop is being done.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CFtpDrop) for a shell extension.
    When it calls CFtpDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Ftp Window, CFtpDrop::Drop() will be called again.
    For this reasons, CFtpDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CFtpDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CFtpDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CFtpDrop remains stateless.
\*****************************************************************************/

#include "priv.h"
#include "ftpdrop.h"
#include "ftpurl.h"
#include "statusbr.h"
#include "newmenu.h"

class CDropOperation;
HRESULT CDropOperation_Create(CFtpFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzFtpDest, CDropOperation ** ppfdt, DROPEFFECT de, OPS ops, int cobj);
HRESULT ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszFtpName, OPS * pOps, HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, DROPEFFECT * pde, int nObjs, BOOL * pfFireChangeNotify);


// Declared because of recusion
HRESULT FtpCopyDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi);
HRESULT FtpCopyFile(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi);


HRESULT UpdateCopyFileName(LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    static WCHAR wzCopyTemplate[MAX_PATH] = L"";
    WCHAR wzLine1[MAX_PATH];

    if (!wzCopyTemplate[0])
        LoadStringW(HINST_THISDLL, IDS_COPYING, wzCopyTemplate, ARRAYSIZE(wzCopyTemplate));

    wnsprintfW(wzLine1, ARRAYSIZE(wzLine1), wzCopyTemplate, pcohi->pszFtpDest);

    EVAL(SUCCEEDED(pcohi->progInfo.ppd->SetLine(1, wzLine1, FALSE, NULL)));

    return hr;
}


HRESULT UpdateSrcDestDirs(LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    WCHAR wzFrom[MAX_PATH];
    WCHAR wzStatusStr[MAX_PATH];

    StrCpyN(wzFrom, pcohi->pszFSSource, ARRAYSIZE(wzFrom));
    PathRemoveFileSpecW(wzFrom);

    if (EVAL(SUCCEEDED(hr = CreateFromToStr(wzStatusStr, ARRAYSIZE(wzStatusStr), wzFrom, pcohi->pszDir))))
        EVAL(SUCCEEDED(hr = pcohi->progInfo.ppd->SetLine(2, wzStatusStr, FALSE, NULL)));    // Line one is the file being copied.

    return hr;
}


HRESULT DeleteOneFileCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPCOPYONEHDROPINFO pcohi = (LPCOPYONEHDROPINFO) pv;
    WIRECHAR wFtpPath[MAX_PATH];

    phpi->pfd->GetFtpSite()->GetCWireEncoding()->UnicodeToWireBytes(pcohi->pmlc, pcohi->pszFtpDest, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wFtpPath, ARRAYSIZE(wFtpPath));
    return FtpDeleteFileWrap(hint, TRUE, wFtpPath);
}


HRESULT UpdateProgressDialogStr(LPCOPYONEHDROPINFO pcohi)
{
    EVAL(SUCCEEDED(UpdateCopyFileName(pcohi)));
    EVAL(SUCCEEDED(UpdateSrcDestDirs(pcohi)));
    return S_OK;
}


/*****************************************************************************\
    CopyFileSysItem

    This function may cause recursion.
\*****************************************************************************/
HRESULT CopyFileSysItem(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    // Check if the user canceled.
    if (pcohi->progInfo.ppd)
    {
        if (pcohi->progInfo.ppd->HasUserCancelled())
            return HRESULT_FROM_WIN32(ERROR_CANCELLED);

        if (pcohi->dwOperation != COHDI_FILESIZE_COUNT)
            UpdateProgressDialogStr(pcohi);
    }

    if (PathIsDirectory(pcohi->pszFSSource))
    {
        hr = FtpCopyDirectory(hint, phpi, pcohi);

        if (SUCCEEDED(hr) && (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
        {
            /*
            WIN32_FIND_DATA wfd;
            HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

            // NOTE:   The date is wrong doing it this way, but it's faster.  We should
            //         find out if FtpCreateDirectory always stamps the directory with
            //         the current date, and then update wfd with the current time/date.
            //         This will simulate the server entry w/o the perf hit.
            if (handle != INVALID_HANDLE_VALUE)
            {
                // If we are the root, then we need to notify the shell that
                // a folder was created so the view needs to be updated.
                // We fire the FtpChangeNotify() call for SHCNE_MKDIR in FtpCreateDirectoryWithCN().
                // FtpChangeNotify(SHCNE_MKDIR) is fired in FtpCreateDirectoryWithCN
                FindClose(handle);
            }
            */
        }
    }
    else
        hr = FtpCopyFile(hint, phpi, pcohi);

    return hr;
}


HRESULT FtpCopyItem(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi, LPWIN32_FIND_DATA pwfd, LPCWIRESTR pwCurrentDir)
{
    HRESULT hr = S_OK;
    TCHAR szFrom[MAX_PATH];
    WCHAR wzDestDir[MAX_PATH];
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    COPYONEHDROPINFO cohi = {pcohi->pff, szFrom, pwfd->cFileName, wzDestDir, pcohi->dwOperation, pcohi->ops, FALSE, pcohi->pmlc, pcohi->pidlServer, pcohi->fFireChangeNotify, NULL};
    CFtpDir * pfd = phpi->pfd;
    BOOL fSkipCurrentFile = FALSE;
    CWireEncoding * pwe = phpi->pfd->GetFtpSite()->GetCWireEncoding();

    cohi.progInfo.ppd = pcohi->progInfo.ppd;
    cohi.progInfo.hint = pcohi->progInfo.hint;
    cohi.progInfo.uliBytesCompleted.QuadPart = pcohi->progInfo.uliBytesCompleted.QuadPart;
    cohi.progInfo.uliBytesTotal.QuadPart = pcohi->progInfo.uliBytesTotal.QuadPart;

    phpi->pfd->GetDisplayPath(wzDestDir, ARRAYSIZE(wzDestDir));
    DisplayPathAppend(wzDestDir, ARRAYSIZE(wzDestDir), pcohi->pszFtpDest);

    if (EVAL(SUCCEEDED(pfd->GetFtpSite()->GetServer(szServer, ARRAYSIZE(szServer)))) &&
        SUCCEEDED(pfd->GetFtpSite()->GetFtpDir(szServer, wzDestDir, &(phpi->pfd))))
    {
        ASSERT(phpi->hwnd);
        // Make sure the user thinks it's ok to replace.  We don't care about replacing directories
        if ((pcohi->dwOperation != COHDI_FILESIZE_COUNT) &&
            !(FILE_ATTRIBUTE_DIRECTORY & pwfd->dwFileAttributes))
        {
            TCHAR szSourceFile[MAX_PATH];

            StrCpyN(szSourceFile, pcohi->pszFSSource, ARRAYSIZE(szSourceFile));
            if (PathAppend(szSourceFile, pwfd->cFileName))
            {
                // PERF: We should do the Confirm copy only if the upload fails because it's
                //       so costly.
                hr = ConfirmCopy(szSourceFile, pwfd->cFileName, &(cohi.ops), phpi->hwnd, pcohi->pff, phpi->pfd, NULL, 1, &cohi.fFireChangeNotify);
                if (S_FALSE == hr)
                {
                    // S_FALSE from ConfirmCopy() means doen't replace this specific file, but continue
                    // copying.  We need to return S_OK or we will cancel copying all the files.
                    fSkipCurrentFile = TRUE;
                    hr = S_OK;
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
        }

        if (!fSkipCurrentFile && (S_OK == hr) && IS_VALID_FILE(pwfd->cFileName))
        {
            StrCpyN(szFrom, pcohi->pszFSSource, ARRAYSIZE(szFrom));     // Set the source directory.
            // Specify the file/dir in that directory to copy.
            if (PathAppend(szFrom, pwfd->cFileName))
            {
                // 5. Call CopyFileSysItem() to get it copied (maybe recursively)
                //TraceMsg(TF_FTPOPERATION, "FtpCopyDirectory() calling CopyFileSysItem(From=%s. To=%s)", szFrom, pwfd->cFileName);
                hr = CopyFileSysItem(hint, phpi, &cohi);
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) &&
                    (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
                {
                    int nResult = DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FILECOPY, IDS_FTPERR_WININET, MB_OK, pcohi->progInfo.ppd);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
        }


        pcohi->progInfo.hint = cohi.progInfo.hint;    // Maybe the user cancelled.
        pcohi->progInfo.uliBytesCompleted.QuadPart = cohi.progInfo.uliBytesCompleted.QuadPart;
        pcohi->progInfo.uliBytesTotal.QuadPart = cohi.progInfo.uliBytesTotal.QuadPart;
        pcohi->ops = cohi.ops;
        phpi->pfd->Release();
    }

    phpi->pfd = pfd;
    return hr;
}

HRESULT _FtpSetCurrentDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCWSTR pwzFtpPath)
{
    HRESULT hr;
    WIRECHAR wFtpPath[MAX_PATH];
    CWireEncoding * pwe = phpi->pfd->GetFtpSite()->GetCWireEncoding();

    hr = pwe->UnicodeToWireBytes(NULL, pwzFtpPath, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wFtpPath, ARRAYSIZE(wFtpPath));
    if (SUCCEEDED(hr))
        hr = FtpSetCurrentDirectoryWrap(hint, TRUE, wFtpPath);

    return hr;
}

/*****************************************************************************\
     FtpCopyDirectory
 
    DESCRIPTION:
        This function will need to copy all the items in the directory to the
    FTP server if the item is a folder, it will need to recurse.

    Recursion algorithm:
    // 1. Create Directory
    // 2. Get Current Directory (To save for later).
    // 3. Change Directory Into new Directory.
    // 4. Find Next item (file/dir) in file system
    // 5. Call CopyFileSysItem() to get it copied (maybe recursively)
    // 6. Go to Step 4 if there are any left.
    // 7. Go back to original directory (Step 2)
\*****************************************************************************/
HRESULT FtpCopyDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    if (phpi->psb && (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
        phpi->psb->SetStatusMessage(IDS_COPYING, pcohi->pszFSSource);

    //TraceMsg(TF_FTPOPERATION, "FtpCopyDirectory() calling FtpCreateDirectoryA(%s)", pcohi->pszFSSource);

    // Create the directories on the first pass when we calculate file sizes.
    // We then skip creating them on the copy pass.
    if (pcohi->dwOperation == COHDI_FILESIZE_COUNT)
    {
        hr = FtpSafeCreateDirectory(phpi->hwnd, hint, pcohi->pmlc, pcohi->pff, phpi->pfd, pcohi->progInfo.ppd, pcohi->pszFtpDest, pcohi->fIsRoot);
    }

    // 1. Create Directory
    if (SUCCEEDED(hr))
    {
        WIRECHAR wCurrentDir[MAX_PATH];

        hr = FtpGetCurrentDirectoryWrap(hint, TRUE, wCurrentDir, ARRAYSIZE(wCurrentDir));
        if (EVAL(SUCCEEDED(hr)))
        {
            // NOTE: At this point, pcohi->pszFSSource is the DIRECTORY on the local
            //       file system that is being copied.
            hr = _FtpSetCurrentDirectory(hint, phpi, pcohi->pszFtpDest);
            if (SUCCEEDED(hr))
            {
                WCHAR szSearchStr[MAX_PATH*2];
                WIN32_FIND_DATA wfd;
                HANDLE handle = NULL;

                StrCpyN(szSearchStr, pcohi->pszFSSource, ARRAYSIZE(szSearchStr));
                // We need to copy the entire directory.
                if (PathAppend(szSearchStr, SZ_ALL_FILES))
                {
                    // 4. Find Next item (file/dir) in file system
                    handle = FindFirstFile(szSearchStr, &wfd);
                    if (handle != INVALID_HANDLE_VALUE)
                    {
                        do
                        {
                            //TraceMsg(TF_WININET_DEBUG, "FindFirstFileNext() returned %s", wfd.cFileName);
                            hr = FtpCopyItem(hint, phpi, pcohi, &wfd, wCurrentDir);

                            // 6. Check if the user canceled.
                            if ((pcohi->progInfo.ppd) && (pcohi->progInfo.ppd->HasUserCancelled()))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                                break;
                            }

                            // 7. Repeat if there are any left and it wasn't cancelled (S_FALSE)
                        }
                        while ((S_OK == hr) && FindNextFile(handle, &wfd));

                        FindClose(handle);
                    }
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
            }

            // 7. Go back to original directory (from Step 2)
            // The only time we don't want to return to the original directory is if
            // the hinst was freed in an wininet callback function.  We may cache the hinst
            // so we need the directory to be valid later.
            if (pcohi->progInfo.hint)
            {
                EVAL(SUCCEEDED(FtpSetCurrentDirectoryWrap(hint, TRUE, wCurrentDir)));
            }
        }
    }
    else
    {
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DIRCOPY, IDS_FTPERR_WININET, MB_OK, pcohi->progInfo.ppd);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}


HRESULT UpdateCopyProgressInfo(IProgressDialog * ppd, LPCTSTR pszFileName)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemplate[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, IDS_COPYING, szTemplate, ARRAYSIZE(szTemplate))))
    {
        TCHAR szStatusStr[MAX_PATH];
        WCHAR wzStatusStr[MAX_PATH];

        wnsprintf(szStatusStr, ARRAYSIZE(szStatusStr), szTemplate, pszFileName);
        SHTCharToUnicode(szStatusStr, wzStatusStr, ARRAYSIZE(wzStatusStr));
        EVAL(SUCCEEDED(hr = ppd->SetLine(1, wzStatusStr, FALSE, NULL)));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _FireChangeNotify

    DESCRIPTION:
        asd
\*****************************************************************************/
HRESULT _FireChangeNotify(HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA wfd;
    HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

    TraceMsg(TF_WININET_DEBUG, "_FireChangeNotify() FtpPutFileEx(%s -> %s) succeeded", pcohi->pszFSSource, pcohi->pszFtpDest);
    if (handle != INVALID_HANDLE_VALUE)
    {
        ULARGE_INTEGER uliFileSize;
        FTP_FIND_DATA ffd;
        CWireEncoding * pwe = pcohi->pff->GetCWireEncoding();

        uliFileSize.LowPart = wfd.nFileSizeLow;
        uliFileSize.HighPart = wfd.nFileSizeHigh;
        pcohi->progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;

        hr = pwe->UnicodeToWireBytes(pcohi->pmlc, wfd.cFileName, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), ffd.cFileName, ARRAYSIZE(ffd.cFileName));
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidlFtpFile;
            SYSTEMTIME st;
            FILETIME ftUTC;

            if (0 == wfd.dwFileAttributes)
            {
                // Bug in Millennium's FindFirstFile().  It will sometimes return
                // 0 instead of FILE_ATTRIBUTE_NORMAL (0x80) or
                // FILE_ATTRIBUTE_DIRECTORY (0x10), so we patch it now.
                wfd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
            }

            ffd.dwFileAttributes = wfd.dwFileAttributes;
            ffd.dwReserved0 = wfd.dwReserved0;
            ffd.dwReserved1 = wfd.dwReserved1;
            ffd.nFileSizeHigh = wfd.nFileSizeHigh;
            ffd.nFileSizeLow = wfd.nFileSizeLow;

            // wfd.ft*Time is in UTF and FtpItemID_CreateReal wants
            // it in LocalTime, so we need to convert here.
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ftUTC);
            FileTimeToLocalFileTime(&ftUTC, &ffd.ftLastWriteTime);   // UTC->LocalTime
            ffd.ftCreationTime = ffd.ftLastWriteTime;
            ffd.ftLastAccessTime = ffd.ftLastWriteTime;

            hr = FtpItemID_CreateReal(&ffd, pcohi->pszFtpDest, &pidlFtpFile);
            if (SUCCEEDED(hr))
            {
                // Note that we created the mapped name
                // PERF: Note that we give the time/date stamp to SHChangeNotify that comes from the source
                //       file, not from the FTP server, so it may be inforrect.  However, it's perf prohibitive
                //       to do the right thing.
                FtpChangeNotify(phpi->hwnd, SHCNE_CREATE, pcohi->pff, phpi->pfd, pidlFtpFile, NULL, pcohi->fIsRoot);
                ILFree(pidlFtpFile);
            }
        }

        FindClose(handle);
    }

    return hr;
}


#define CCH_SIZE_ERROR_MESSAGE  6*1024

/*****************************************************************************\
    FtpCopyFile

    Callback procedure that copies a single hdrop / map.
    Should I try to make the name unique in case of collision?
    Naah, just prompt, but! no way to tell if destination is case-sensitive...
\*****************************************************************************/
HRESULT FtpCopyFile(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    if (pcohi->dwOperation != COHDI_FILESIZE_COUNT)
    {
        WIRECHAR wWireName[MAX_PATH];

        EVAL(SUCCEEDED(pcohi->pff->GetCWireEncoding()->UnicodeToWireBytes(pcohi->pmlc, pcohi->pszFtpDest, (pcohi->pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName))));

        if (phpi->psb)
            phpi->psb->SetStatusMessage(IDS_COPYING, pcohi->pszFSSource);

        if (pcohi->progInfo.ppd)
        {
            EVAL(SUCCEEDED(UpdateCopyProgressInfo(pcohi->progInfo.ppd, pcohi->pszFtpDest)));
            EVAL(SUCCEEDED(pcohi->progInfo.ppd->SetProgress64(pcohi->progInfo.uliBytesCompleted.QuadPart, pcohi->progInfo.uliBytesTotal.QuadPart)));
        }

        pcohi->progInfo.dwCompletedInCurFile = 0;
        pcohi->progInfo.dwLastDisplayed = 0;

        // We need to pass the FTP_TRANSFER_TYPE (_ASCII vs. _BINARY) if we ever want to add the
        // feature to allow users to force one type vs. the other.
        hr = FtpPutFileExWrap(hint, TRUE, pcohi->pszFSSource, wWireName, FTP_TRANSFER_TYPE_UNKNOWN, (DWORD_PTR)&(pcohi->progInfo));
        if (SUCCEEDED(hr))
        {
            // We don't fire change notify on browser only if we
            // are replacing a file because ChangeNotify really
            // just hacks ListView and doen't know how to handle
            // duplicates (file replace).
            if (pcohi->fFireChangeNotify)
                hr = _FireChangeNotify(phpi, pcohi);
        }
        else
        {
            if (HRESULT_FROM_WIN32(ERROR_INTERNET_OPERATION_CANCELLED) == hr)
            {
                // Clean up the file.
                EVAL(SUCCEEDED(phpi->pfd->WithHint(NULL, phpi->hwnd, DeleteOneFileCB, pcohi, NULL, pcohi->pff)));
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            else
            {
                // We still want to delete the file, but we need to save the error message
                // so the dialog is correct.
                CHAR szErrorMsg[CCH_SIZE_ERROR_MESSAGE];
                WCHAR wzErrorMsg[CCH_SIZE_ERROR_MESSAGE];
                DWORD cchSize = ARRAYSIZE(szErrorMsg);
                InternetGetLastResponseInfoWrap(TRUE, NULL, szErrorMsg, &cchSize);
                HRESULT hrOrig = hr;
                CWireEncoding * pwe = phpi->pfd->GetFtpSite()->GetCWireEncoding();

                pwe->WireBytesToUnicode(NULL, szErrorMsg, WIREENC_NONE, wzErrorMsg, ARRAYSIZE(wzErrorMsg));
                // Does it already exist?  This may fail.
                SUCCEEDED(phpi->pfd->WithHint(NULL, phpi->hwnd, DeleteOneFileCB, pcohi, NULL, pcohi->pff));

                // No, so it was a real error, now display the error message with the original
                // server response.
                DisplayWininetErrorEx(phpi->hwnd, TRUE, HRESULT_CODE(hrOrig), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FILECOPY, IDS_FTPERR_WININET, MB_OK, pcohi->progInfo.ppd, wzErrorMsg);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }
    }
    else
    {
        // Just get the file size.   
        WIN32_FIND_DATA wfd;
        HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

        if (handle && (handle != INVALID_HANDLE_VALUE))
        {
            ULARGE_INTEGER uliFileSize;
            uliFileSize.LowPart = wfd.nFileSizeLow;
            uliFileSize.HighPart = wfd.nFileSizeHigh;
            pcohi->progInfo.uliBytesTotal.QuadPart += uliFileSize.QuadPart;
            FindClose(handle);
        }
    }

    //TraceMsg(TF_FTPOPERATION, "FtpPutFileA(From=%ls, To=%s) hr=%#08lX", pcohi->pszFSSource, pcohi->pszFtpDest, hr);
    return hr;
}


/*****************************************************************************\
    _EnumOneHdropW

    Handle one hdrop and corresponding filemap.

    This is annoying because we need to convert from UNICODE to ANSI.
\*****************************************************************************/
#define OleStrToStrA(a, b) OleStrToStrN(a, ARRAYSIZE(a), b, -1)

HRESULT _EnumOneHdropW(LPCWSTR * ppwzzFSSources, LPCWSTR * ppwzzFtpDest, LPTSTR pszFSSourceOut, DWORD cchFSSourceOut, LPTSTR pszFtpDestOut, DWORD cchFtpDestOut)
{
    HRESULT hres;
    int cwch;

    if (*ppwzzFSSources && (*ppwzzFSSources)[0])
    {
        cwch = SHUnicodeToTChar(*ppwzzFSSources, pszFSSourceOut, cchFSSourceOut);
        if (EVAL(cwch))
        {
            *ppwzzFSSources += cwch;
            if (EVAL((*ppwzzFtpDest)[0]))
            {
                cwch = SHUnicodeToTChar(*ppwzzFtpDest, pszFtpDestOut, cchFtpDestOut);
                if (EVAL(cwch))
                {
                    *ppwzzFtpDest += cwch;
                    hres = S_OK;    // Both strings converted okay
                }
                else
                    hres = E_UNEXPECTED; // File name too long
            }
            else
                hres = E_UNEXPECTED;    // Premature EOF in map
        }
        else
            hres = E_UNEXPECTED;    // File name too long
    }
    else
        hres = S_FALSE;            // End of buffer

    return hres;
}


/*****************************************************************************\
    _EnumOneHdropA

    Handle one hdrop and corresponding filemap.
\*****************************************************************************/
HRESULT _EnumOneHdropA(LPCSTR * ppszzFSSource, LPCSTR * ppszzFtpDest, LPTSTR pszFSSourceOut, DWORD cchFSSourceOut, LPTSTR pszFtpDestOut, DWORD cchFtpDestOut)
{
    HRESULT hres;

    if ((*ppszzFSSource)[0])
    {
        SHAnsiToTChar(*ppszzFSSource, pszFSSourceOut, cchFSSourceOut);
        *ppszzFSSource += lstrlenA(*ppszzFSSource) + 1;
        if (EVAL((*ppszzFtpDest)[0]))
        {
            SHAnsiToTChar(*ppszzFtpDest, pszFtpDestOut, cchFtpDestOut);
            *ppszzFtpDest += lstrlenA(*ppszzFtpDest) + 1;
            hres = S_OK;        // No problemo
        }
        else
            hres = E_UNEXPECTED;    // Premature EOF in map
    }
    else
        hres = S_FALSE;            // No more files

    return hres;
}


/*****************************************************************************\
    ConfirmCopy

    Callback procedure that checks if this file really ought to be
    copied.

    Returns S_OK if the file should be copied.
    Returns S_FALSE if the file should not be copied.

    - If the user cancelled, then say S_FALSE from now on.
    - If the user said Yes to All, then say S_OK.
    - If there is no conflict, then say S_OK.
    - If the user said No to All, then say S_FALSE.
    - Else, ask the user what to do.

    Note that the order of the tests above means that if you say
    "Yes to All", then we don't waste our time doing overwrite checks.

    _GROSS_:  NOTE! that we don't try to uniquify the name, because
    WinINet doesn't support the STOU (store unique) command, and
    there is no way to know what filenames are valid on the server.
\*****************************************************************************/
HRESULT ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszFtpName, OPS * pOps, HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, DROPEFFECT * pde, int nObjs, BOOL * pfFireChangeNotify)
{
    HRESULT hr = S_OK;

    *pfFireChangeNotify = TRUE;
    if (*pOps == opsCancel)
        hr = S_FALSE;
    else 
    {
        HANDLE hfind;
        WIN32_FIND_DATA wfdSrc;
        hfind = FindFirstFile(pszLocal, &wfdSrc);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            FindClose(hfind);

            // Is it a file?  We don't care about confirming the replacement
            // of directories.
            if (!(FILE_ATTRIBUTE_DIRECTORY & wfdSrc.dwFileAttributes))
            {
                FTP_FIND_DATA wfd;
                hr = pfd->GetFindDataForDisplayPath(hwnd, pszFtpName, &wfd, pff);
                if (*pOps == opsYesToAll)
                {
                    // If the file exists (S_OK) and it's browser only, 
                    // then don't fire the change notify.
                    if ((S_OK == hr) && (SHELL_VERSION_NT5 != GetShellVersion()))
                        *pfFireChangeNotify = FALSE;

                    hr = S_OK;
                }
                else
                {
                    switch (hr)
                    {
                    case S_OK:            // File exists; worry
                        if (*pOps == opsNoToAll)
                            hr = S_FALSE;
                        else
                        {
                            FILETIME ftUTC = wfdSrc.ftLastWriteTime;
    
                            FileTimeToLocalFileTime(&ftUTC, &wfdSrc.ftLastWriteTime);   // UTC->LocalTime
                            // If we needed to set the browser model, we would do it here.
                            // However, we don't because we are asynch.
                            switch (FtpConfirmReplaceDialog(hwnd, &wfdSrc, &wfd, nObjs, pff))
                            {
                            case IDC_REPLACE_YESTOALL:
                                *pOps = opsYesToAll;
                                // FALLTHROUGH

                            case IDC_REPLACE_YES:
                                // pre-NT5 doesn't work 
                                if (SHELL_VERSION_NT5 != GetShellVersion())
                                    *pfFireChangeNotify = FALSE;

                                hr = S_OK;
                                break;

                            case IDC_REPLACE_NOTOALL:
                                *pOps = opsNoToAll;
                                // FALLTHROUGH

                            case IDC_REPLACE_NO:
                                hr = S_FALSE;
                                break;

                            default:
                                ASSERT(0);        // Huh?
                                // FALLTHROUGH

                            case IDC_REPLACE_CANCEL:
                                if (pde)
                                    *pde = 0;

                                *pOps = opsCancel;
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                                break;
                            }
                        }
                        break;

                    case S_FALSE:
                    default:
                        // Assume the file doesn't exist; no problemo
                        hr = S_OK;
                        break;
                    }
                }
            }
        }
        else
        {                   // File doesn't exist
            hr = S_OK;    // The open will raise the error
        }

    }

    //TraceMsg(TF_FTPDRAGDROP, "ConfirmCopy(%s) -> %08x", pszFtpName, hr);
    return hr;
}




/*****************************************************************************\
    CLASS: CDropOperation

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CFtpDrop) for a shell extension.
    When it calls CFtpDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Ftp Window, CFtpDrop::Drop() will be called again.
    For this reasons, CFtpDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CFtpDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CFtpDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CFtpDrop remains stateless.
\*****************************************************************************/
class CDropOperation          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CDropOperation();
    ~CDropOperation(void);

    // Public Member Functions
    HRESULT DoOperation(BOOL fAsync);

    static HRESULT CopyCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);

    // Friend Functions
    friend HRESULT CDropOperation_Create(CFtpFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzFtpDest, CDropOperation ** ppfdt, DROPEFFECT de, OPS ops, int cobj);

protected:
    // Protected Member Variables
    int                     m_cRef;

    CFtpFolder *            m_pff;          // The owner
    CFtpDir *               m_pfd;          // The FtpDir of the owner
    HWND                    m_hwnd;         // The window being drug over

    DROPEFFECT              m_de;           // Effect being performed
    OPS                     m_ops;          // Overwrite prompting state
    int                     m_cobj;         // Number of objects being dropped
    ULARGE_INTEGER          m_uliBytesCompleted;
    ULARGE_INTEGER          m_uliBytesTotal;


    // Private Member Functions
    HRESULT _ConfirmCopy(LPCWSTR pszLocal, LPCWSTR psz, BOOL * pfFireChangeNotify);
    HRESULT _CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszFtpDest, IProgressDialog * ppd);
    HRESULT _ThreadProcCB(void);
    HRESULT _CopyOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszFtpDest);

    HRESULT _StartBackgroundInteration(void);
    HRESULT _DoCopyIteration(void);
    HRESULT _CalcUploadProgress(void);

private:
    // Private Member Variables
    IProgressDialog *       m_ppd;
    LPCWSTR                 m_pszzFSSource;            // Paths
    LPCWSTR                 m_pszzFtpDest;              // Map
    CMultiLanguageCache     m_mlc;          // Cache for fast str thunking.

    static DWORD CALLBACK _ThreadProc(LPVOID pThis) {return ((CDropOperation *)pThis)->_ThreadProcCB();};
};


HRESULT CDropOperation_Create(CFtpFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzFtpDest, CDropOperation ** ppfdt, 
                              DROPEFFECT de, OPS ops, int cobj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDropOperation * pfdt = new CDropOperation();
    *ppfdt = pfdt;

    if (pfdt)
    {
        pfdt->m_hwnd = hwnd;

        // Copy the CFtpFolder * value
        pfdt->m_pff = pff;
        if (pff)
            pff->AddRef();

        // Copy the CFtpDir * value
        ASSERT(!pfdt->m_pfd);
        pfdt->m_pfd = pff->GetFtpDir();
        ASSERT(pfdt->m_pfd);

        ASSERT(!pfdt->m_pszzFSSource);
        pfdt->m_pszzFSSource = pszzFSSource;

        ASSERT(!pfdt->m_pszzFtpDest);
        pfdt->m_pszzFtpDest = pszzFtpDest;

        pfdt->m_de = de;           // Effect being performed
        pfdt->m_ops = ops;          // Overwrite prompting state
        pfdt->m_cobj = cobj;         // Number of objects being dropped

        hr = S_OK;
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfdt, hr);
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CDropOperation::CDropOperation() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_hwnd);
    ASSERT(!m_cobj);

    LEAK_ADDREF(LEAK_CDropOperation);
}


/****************************************************\
    Destructor
\****************************************************/
CDropOperation::~CDropOperation()
{
    // use ATOMICRELEASE
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set((IUnknown **)&m_ppd, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzFSSource, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzFtpDest, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CDropOperation);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CDropOperation::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CDropOperation::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CDropOperation::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CDropOperation::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}




/****************************************************\
    FUNCTION: _ThreadProcCB

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_ThreadProcCB(void)
{
    HRESULT hr;
    HRESULT hrOleInit = SHCoInitialize();
    
    // WARNING: Init OLE if you plan to do COM.
    m_ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_FTPUPLOAD);
    if (m_ppd)
    {
        ASSERT(m_hwnd);
        // We give a NULL punkEnableModless because we don't want to go modal.
        EVAL(SUCCEEDED(m_ppd->StartProgressDialog(m_hwnd, NULL, PROGDLG_AUTOTIME, NULL)));
    }

    hr = _CalcUploadProgress();
    // Did we succeed creating the directories and counting the
    // size we need to copy?
    if (SUCCEEDED(hr))
    {
        if (m_ppd)
        {
            EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliBytesCompleted.QuadPart, m_uliBytesTotal.QuadPart)));

            // Reset because _CalcUploadProgress() can take a long time and the estimated time
            // is based on the time between ::StartProgressDialog() and the first
            // ::SetProgress() call.
            EVAL(SUCCEEDED(m_ppd->Timer(PDTIMER_RESET, NULL)));
        }

        hr = _DoCopyIteration();
    }

    if (m_ppd)
    {
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
        ATOMICRELEASE(m_ppd);
    }

    SHCoUninitialize(hrOleInit);
    Release();
    return hr;
}


HRESULT CDropOperation::DoOperation(BOOL fAsync)
{
    HRESULT hr = S_OK;

    AddRef();
    if (fAsync)
    {
        HANDLE hThread;
        DWORD dwThreadId;

        hThread = CreateThread(NULL, 0, CDropOperation::_ThreadProc, this, 0, &dwThreadId);
        if (hThread)
            CloseHandle(hThread);
        else
        {
            TraceMsg(TF_ERROR, "CDropOperation::DoOperation() CreateThread() failed and GetLastError()=%lu.", GetLastError());
            Release();
        }
    }
    else
        hr = _ThreadProcCB();

    return hr;
}



/****************************************************\
    FUNCTION: _CalcUploadProgress

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_CalcUploadProgress(void)
{
    HRESULT hr = S_OK;
    LPCWSTR pszzFSSource = m_pszzFSSource;
    LPCWSTR pszzFtpDest = m_pszzFtpDest;
    WCHAR wzProgressDialogStr[MAX_PATH];

    m_uliBytesCompleted.QuadPart = 0;
    m_uliBytesTotal.QuadPart = 0;
    
    // Tell the user we are calculating how long it will take.
    if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_UPLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
        EVAL(SUCCEEDED(m_ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));

    while (S_OK == hr)
    {
        WCHAR szFSSource[MAX_PATH];
        WCHAR szFtpDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzFtpDest, szFSSource, ARRAYSIZE(szFSSource), szFtpDest, ARRAYSIZE(szFtpDest));
        if (S_OK == hr)
            hr = _CalcSizeOneHdrop(szFSSource, szFtpDest, m_ppd);
    }

    if (FAILED(hr))
        TraceMsg(TF_ALWAYS, "CDropOperation::_CalcUploadProgress() Calculating the upload time failed, but oh well.");

    return hr;
}


HRESULT CDropOperation::_CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszFtpDest, IProgressDialog * ppd)
{
    HRESULT hr;
    WCHAR wzTo[MAX_PATH];

    EVAL(SUCCEEDED(m_pfd->GetDisplayPath(wzTo, ARRAYSIZE(wzTo))));
    pszFtpDest = PathFindFileName(pszFtpDest);

    COPYONEHDROPINFO cohi = {0};

    cohi.pff = m_pff;
    cohi.pszFSSource = pszFSSource;
    cohi.pszFtpDest = pszFtpDest;
    cohi.pszDir = wzTo;
    cohi.dwOperation = COHDI_FILESIZE_COUNT;
    cohi.ops = opsPrompt;
    cohi.fIsRoot = TRUE;
    cohi.pmlc = &m_mlc;
    cohi.pidlServer = FtpCloneServerID(m_pff->GetPrivatePidlReference());
    cohi.progInfo.ppd = ppd;
    cohi.fFireChangeNotify = TRUE;

    cohi.progInfo.uliBytesCompleted.QuadPart = m_uliBytesCompleted.QuadPart;
    cohi.progInfo.uliBytesTotal.QuadPart = m_uliBytesTotal.QuadPart;

    hr = m_pfd->WithHint(NULL, m_hwnd, CopyCB, &cohi, NULL, m_pff);
    if (SUCCEEDED(hr))
    {
        m_uliBytesCompleted = cohi.progInfo.uliBytesCompleted;
        m_uliBytesTotal = cohi.progInfo.uliBytesTotal;
    }

    ILFree(cohi.pidlServer);
    return hr;
}


/****************************************************\
    FUNCTION: CDropOperation

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_DoCopyIteration()
{
    HRESULT hr = S_OK;
    LPCTSTR pszzFSSource = m_pszzFSSource;
    LPCTSTR pszzFtpDest = m_pszzFtpDest;

    m_ops = opsPrompt;
    while (S_OK == hr)
    {
        WCHAR szFSSource[MAX_PATH];
        WCHAR szFtpDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzFtpDest, szFSSource, ARRAYSIZE(szFSSource), szFtpDest, ARRAYSIZE(szFtpDest));
        if (S_OK == hr)
        {
            szFSSource[lstrlenW(szFSSource)+1] = 0;   // Double terminate for SHFileOperation(Delete) in move case
            hr = _CopyOneHdrop(szFSSource, szFtpDest);
            if (EVAL(m_ppd))
                EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliBytesCompleted.QuadPart, m_uliBytesTotal.QuadPart)));

            // Did we fail to copy the file?
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                if (!IsValidFtpAnsiFileName(szFSSource) || !IsValidFtpAnsiFileName(szFtpDest))
                    int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_INVALIDFTPNAME, IDS_FTPERR_WININET, MB_OK, m_ppd);
                else
                    int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FILECOPY, IDS_FTPERR_WININET, MB_OK, m_ppd);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            if (S_FALSE == hr)
            {
                // _CopyOneHdrop() returning S_FALSE means we hit the end of the iteration,
                // in this case, _ConfirmCopy() only meant to skip this one file, so
                // change to S_OK to continue with the rest of the files.
                hr = S_OK;
            }
        }
    }

    Str_SetPtr((LPTSTR *) &m_pszzFSSource, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzFtpDest, NULL);

    return hr;
}


HRESULT CDropOperation::_ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszFtpName, BOOL * pfFireChangeNotify)
{
    return ConfirmCopy(pszLocal, pszFtpName, &m_ops, m_hwnd, m_pff, m_pfd, NULL, m_cobj, pfFireChangeNotify);
}


/*****************************************************************************\
    CopyCB

    Callback procedure that copies a single hdrop / map.
\*****************************************************************************/
HRESULT CDropOperation::CopyCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPCOPYONEHDROPINFO pcohi = (LPCOPYONEHDROPINFO) pv;
    pcohi->progInfo.hint = hint;
    HRESULT hr;

    InternetSetStatusCallbackWrap(hint, TRUE, FtpProgressInternetStatusCB);
    hr = CopyFileSysItem(hint, phpi, pcohi);
    if (!pcohi->progInfo.hint)
        *pfReleaseHint = FALSE;     // We had to close hint to get the cancel.

    return hr;
}


HRESULT CDropOperation::_CopyOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszFtpDest)
{
    HRESULT hr;
    BOOL fFireChangeNotify = TRUE;

    pszFtpDest = PathFindFileName(pszFtpDest);

    hr = _ConfirmCopy(pszFSSource, pszFtpDest, &fFireChangeNotify);
    if (S_OK == hr)
    {
        WCHAR wzTo[MAX_PATH];
        COPYONEHDROPINFO cohi = {0};

        cohi.pff = m_pff;
        cohi.pszFSSource = pszFSSource;
        cohi.pszFtpDest = pszFtpDest;
        cohi.pszDir = wzTo;
        cohi.dwOperation = COHDI_COPY_FILES;
        cohi.ops = m_ops;
        cohi.fIsRoot = TRUE;
        cohi.pmlc = &m_mlc;
        cohi.pidlServer = FtpCloneServerID(m_pff->GetPrivatePidlReference());
        cohi.fFireChangeNotify = fFireChangeNotify;
        cohi.progInfo.ppd = m_ppd;

        cohi.progInfo.uliBytesCompleted.QuadPart = m_uliBytesCompleted.QuadPart;
        cohi.progInfo.uliBytesTotal.QuadPart = m_uliBytesTotal.QuadPart;
        EVAL(SUCCEEDED(m_pfd->GetDisplayPath(wzTo, ARRAYSIZE(wzTo))));

        // TODO: have CopyCB also update the dialog.
        hr = m_pfd->WithHint(NULL, m_hwnd, CopyCB, &cohi, NULL, m_pff);

        if (SUCCEEDED(hr) && (m_de == DROPEFFECT_MOVE))
        {
            //  We delete the file with SHFileOperation to keep the
            //  disk free space statistics up to date.
            //
            //  NOTE: If coming from a file name map, maybe it's
            //  being dragged from the recycle bin, in which case, doing
            //  an FO_DELETE will put it back in!
            SHFILEOPSTRUCT sfo = {0};
            
            sfo.hwnd = NULL,                // No HWND so NO UI.
            sfo.wFunc  = FO_DELETE;
            sfo.pFrom  = pszFSSource;       // Multiple files in list.
            sfo.fFlags = (FOF_SILENT | FOF_NOCONFIRMATION /*| FOF_MULTIDESTFILES*/);  // No HWND so NO UI.

            int nResult = SHFileOperation(&sfo);
            if (0 != nResult)
                TraceMsg(TF_ALWAYS, "In CDropOperation::_CopyOneHdrop() and caller wanted MOVE but we couldn't delete the files after the copy.");
        }
        m_uliBytesCompleted = cohi.progInfo.uliBytesCompleted;
        m_uliBytesTotal = cohi.progInfo.uliBytesTotal;
        m_ops = cohi.ops;
    }
    else
    {
        if (S_FALSE == hr)
        {
            // _CopyOneHdrop() returning S_FALSE means we hit the end of the iteration,
            // in this case, _ConfirmCopy() only meant to skip this one file, so
            // change to S_OK to continue with the rest of the files.
            hr = S_OK;
        }
    }

    return hr;
}


/*****************************************************************************
    FUNCTION: SetEffect

    DESCRIPTION:
        Set the appropriate drop effect feedback.

    In the absence of keyboard modifiers, use CTRL (copy), unless
    DROPEFFECT_COPY is not available, in which case we use SHIFT (move).

    If anything else is set, then panic out to DROPEFFECT_NONE.

    Note that we do *not* use g_cfPreferredDe.  The only things
    we support are DROPEFFECT_COPY and DROPEFFECT_MOVE, and we always prefer DROPEFFECT_COPY.

    NOTE: Ignoring g_cfPreferredDe messes up cut/paste, though.
\*****************************************************************************/

HRESULT CFtpDrop::SetEffect(DROPEFFECT * pde)
{
    DWORD de;            // Preferred drop effect

    // Don't even think about effects that we don't support
    *pde &= m_grfksAvail;

    switch (m_grfks & (MK_SHIFT | MK_CONTROL))
    {
    case 0:            // No modifier, use COPY if possible
        if (*pde & DROPEFFECT_COPY)
        {
    case MK_CONTROL:
            de = DROPEFFECT_COPY;
        }
        else
        {
    case MK_SHIFT:
            de = DROPEFFECT_MOVE;
        }
        break;

    default:
        de = 0;
        break;        // Cannot link
    }
    *pde &= de;

    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::SetEffect(DROPEFFECT=%08x) m_grfksAvail=%08x", *pde, m_grfksAvail);
    return S_OK;
}


BOOL CFtpDrop::_IsFTPOperationAllowed(IDataObject * pdto)
{
#ifdef FEATURE_FTP_TO_FTP_COPY
    BOOL fIsFTPOperationAllowed = TRUE;

    // There are a few things we don't allow.
    // Is the Drop FTP Location the same
    // folder that the dragged items are already in?
    if (0)
    {
        // TODO:
    }
    
    return fIsFTPOperationAllowed;
#else // FEATURE_FTP_TO_FTP_COPY

    // Disallow all FTP Operations
    return !_HasData(pdto, &g_dropTypes[DROP_FTP_PRIVATE]);
#endif // FEATURE_FTP_TO_FTP_COPY
}


/*****************************************************************************\
    GetEffectsAvail

    Look at the object to see what drop effects are available.

    If we have a file group descriptor or an HDROP,
    then file contents are available.  (We assume that if you have
    a FGD, then a Contents isn't far behind.)

    In a perfect world, we would also validate the contents of
    each file in the group descriptor, to ensure that the contents
    are droppable.  We skimp on that because it's too expensive.
\*****************************************************************************/
DWORD CFtpDrop::GetEffectsAvail(IDataObject * pdto)
{
    DWORD grfksAvail = 0;

    // Is this from an Ftp Shell Extension?
    if (_IsFTPOperationAllowed(pdto))
    {
        // No or it's allowed, then we will accept it.  We reject everything
        // else because we can't do Ftp1->Ftp2 copying without
        // using the local machine as a temp location. (Ftp1->Local->Ftp2)

        if (_HasData(pdto, &g_dropTypes[DROP_Hdrop]) ||
            _HasData(pdto, &g_dropTypes[DROP_FGDW]) ||
            _HasData(pdto, &g_dropTypes[DROP_FGDA]))
        {
            TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffectsAvail() SUCCEEDED");
            grfksAvail = DROPEFFECT_COPY + DROPEFFECT_MOVE;
        }
        else
        {
            TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffectsAvail() FAILED");
#ifdef DEBUG
            STGMEDIUM sm;
            HRESULT hres = pdto->GetData(&g_dropTypes[DROP_URL], &sm);
            if (SUCCEEDED(hres))
            {
                TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffectsAvail(%08x) URL: %hs", pdto, GlobalLock(sm.hGlobal));
                GlobalUnlock(sm.hGlobal);
                ReleaseStgMedium(&sm);
            }
            else
            {
                TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffectsAvail(%08x) No URL", pdto);
            }
#endif // DEBUG
        }
    }

    return grfksAvail;
}


/*****************************************************************************\
    GetEffect

    Return the drop effect to use.

    If this is a nondefault drag/drop, then put up a menu.  Else,
    just go with the default.

    m_de = default effect
    m_pde -> possible effects (and receives result)
\*****************************************************************************/
DROPEFFECT CFtpDrop::GetEffect(POINTL pt)
{
    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffect() m_de=%08x. m_grfks=%08x", m_de, m_grfks);

    if (m_de && (m_grfks & MK_RBUTTON))
    {
        HMENU hmenuMain = LoadMenu(g_hinst, MAKEINTRESOURCE(IDM_DROPCONTEXT));
        HMENU hmenu = GetSubMenu(hmenuMain, 0);
        DROPEFFECT de;

        ASSERT(*m_pde & m_de);
        SetMenuDefaultItem(hmenu, m_de, 0);
        if (!(*m_pde & DROPEFFECT_COPY))
            DeleteMenu(hmenu, DROPEFFECT_COPY, MF_BYCOMMAND);

        if (!(*m_pde & DROPEFFECT_MOVE))
            DeleteMenu(hmenu, DROPEFFECT_MOVE, MF_BYCOMMAND);

        // _UNOBVIOUS_:  Defview knows special things about itself.
        // If the drop target originated from Shell32.dll, then
        // it leaves the image of the dropped object on the screen
        // while the menu is up, which is nice.  Otherwise, it removes
        // the image of the dropped object before the drop target
        // receives its IDropTarget::Drop.
        // Which means that outside shell extensions can't take
        // advantage of the "pretty drop UI" feature.

        // _UNOBVIOUS_:  Have to force foregroundness, else the input
        // gets messed up.
        if (m_hwnd)
            SetForegroundWindow(m_hwnd);

        de = TrackPopupMenuEx(hmenu,
                      TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_VERTICAL |
                      TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y,
                      m_hwnd, 0);

        DestroyMenu(hmenuMain);
        m_de = de;
    }
    *m_pde = m_de;

    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::GetEffect(%08x) -> %08x", this, m_de);
    return m_de;
}


/****************************************************\
    FUNCTION: _StartBackgroundInteration

    DESCRIPTION:
\****************************************************/
HRESULT CFtpDrop::_StartBackgroundInteration(void)
{
    CDropOperation * pDropOperation;
    HRESULT hr = CDropOperation_Create(m_pff, m_hwnd, m_pszzFSSource, m_pszzFtpDest, &pDropOperation, m_de, m_ops, m_cobj);
    
    // Did it succeed?
    if (SUCCEEDED(hr))
    {
        // Yes, so NULL out m_pszzFSSource, m_pszzFtpDest because we gave them our copies.
        //  Ugly but allocation is uglier.
        m_pszzFSSource = NULL;
        m_pszzFtpDest = NULL;

        EVAL(SUCCEEDED(hr = pDropOperation->DoOperation(TRUE)));
        pDropOperation->Release();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _DoCountIteration

    DESCRIPTION:
\****************************************************/
HRESULT CFtpDrop::_DoCountIteration(void)
{
    HRESULT hr = S_OK;
    LPCTSTR pszzFSSource = m_pszzFSSource;
    LPCTSTR pszzFtpDest = m_pszzFtpDest;

    while (S_OK == hr)
    {
        TCHAR szFSSource[MAX_PATH];
        TCHAR szFtpDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzFtpDest, szFSSource, ARRAYSIZE(szFSSource), szFtpDest, ARRAYSIZE(szFtpDest));
        if (S_OK == hr)
            m_cobj++;
    }

    if (hr == S_FALSE)
        hr = S_OK;        // Enumerated to completion

    return hr;
}


/****************************************************\
    FUNCTION: _GetFSSourcePaths

    DESCRIPTION:
\****************************************************/
HRESULT CFtpDrop::_GetFSSourcePaths(HGLOBAL hdrop, BOOL * pfAnsi)
{
    LPDROPFILES pdrop = (LPDROPFILES) GlobalLock(hdrop);
    HRESULT hr = E_INVALIDARG;

    *pfAnsi = TRUE;
    if (EVAL(pdrop))
    {
        //  Now to decide whether it is an old-style drop or a new-style
        // drop.  And if it's a new-style drop, to get the character set.
        if (LOWORD(pdrop->pFiles) == sizeof(DROPFILES16))
        {
            // Old style
            Str_StrAndThunkA((LPTSTR *) &m_pszzFSSource, (LPCSTR) pvByteIndexCb(pdrop, LOWORD(pdrop->pFiles)), TRUE);
        }
        else
        {
            if (pdrop->fWide)
            {
                Str_StrAndThunkW((LPTSTR *) &m_pszzFSSource, (LPCWSTR) pvByteIndexCb(pdrop, pdrop->pFiles), TRUE);
                *pfAnsi = FALSE;
            }
            else
                Str_StrAndThunkA((LPTSTR *) &m_pszzFSSource, (LPCSTR) pvByteIndexCb(pdrop, pdrop->pFiles), TRUE);
        }
        GlobalUnlock(pdrop);
        hr = S_OK;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _GetFtpDestPaths

    DESCRIPTION:
\****************************************************/
HRESULT CFtpDrop::_GetFtpDestPaths(HGLOBAL hmap, BOOL fAnsi)
{
    HRESULT hr = E_INVALIDARG;
    LPVOID pmap = NULL;

    //  If we can't get a map, then just use the source file names.
    ASSERT(!m_pszzFtpDest);
    if (hmap)
    {
        pmap = GlobalLock(hmap);

        if (pmap)
        {
            if (fAnsi)
                Str_StrAndThunkA((LPTSTR *) &m_pszzFtpDest, (LPCSTR) pmap, TRUE);
            else
                Str_StrAndThunkW((LPTSTR *) &m_pszzFtpDest, (LPCWSTR) pmap, TRUE);

            GlobalUnlock(pmap);
        }
    }

    if (!m_pszzFtpDest)
    {
        // Just copy the Paths
        Str_StrAndThunk((LPTSTR *) &m_pszzFtpDest, m_pszzFSSource, TRUE);
    }

    if (m_pszzFtpDest)
        hr = S_OK;

    return hr;
}



/*****************************************************************************\
    CopyHdrop

    Copy an HDROP data object.

    Note also that when we use HDROP, we must also consult the
    FileNameMap otherwise dragging out of the recycle bin directly
    into an FTP folder will create files with the wrong name!

    Note further that the returned effect of an HDROP is always
    DROPEFFECT_COPY, because we will do the work of deleting the
    source files when finished.
\*****************************************************************************/
HRESULT CFtpDrop::CopyHdrop(IDataObject * pdto, STGMEDIUM *psm)
{
    BOOL fAnsi;
    HRESULT hr = _GetFSSourcePaths(psm->hGlobal, &fAnsi);

    if (EVAL(SUCCEEDED(hr)))
    {
        STGMEDIUM sm;

        // ZIP fails this.
        // Get the File name map, too, if one exists
        if (fAnsi)
            hr = pdto->GetData(&g_dropTypes[DROP_FNMA], &sm);
        else
            hr = pdto->GetData(&g_dropTypes[DROP_FNMW], &sm);

        if (FAILED(hr))       // Failure is ok
            sm.hGlobal = 0;

        hr = _GetFtpDestPaths(sm.hGlobal, fAnsi);
        if (EVAL(SUCCEEDED(hr)))
        {
            *m_pde = DROPEFFECT_COPY;
            // Count up how many things there are in the hdrop,
            // so that our confirmation dialog knows what the deal is.
            // We can ignore the error; it'll show up again when we copy.
            m_cobj = 0;
            hr = _DoCountIteration();
            ASSERT(SUCCEEDED(hr));
            TraceMsg(TF_FTPDRAGDROP, "CFtpDrop_CopyHdrop: %d file(s)", m_cobj);

            //  Now walk the lists with the appropriate enumerator.
            hr = _StartBackgroundInteration();
            ASSERT(SUCCEEDED(hr));
        }
        if (sm.hGlobal)
            ReleaseStgMedium(&sm);
    }

    return hr;
}


/*****************************************************************************\
    _CopyHglobal

    Copy a file contents received as an hglobal.

    If a FD_FILESIZE is provided, use it.  Otherwise, just use the size
    of the hglobal.
\*****************************************************************************/
HRESULT CFtpDrop::_CopyHglobal(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw)
{
    LPVOID pv;
    HGLOBAL hglob = pvSrc;
    HRESULT hres;

    pqw->HighPart = 0;
    pv = GlobalLock(hglob);
    if (EVAL(pv))
    {
        UINT cb = (UINT) GlobalSize(hglob);
        if (dwFlags & FD_FILESIZE)
        {
            if (cb > dwFileSizeLow)
                cb = dwFileSizeHigh;
        }
        hres = pstm->Write(pv, cb, &pqw->LowPart);
        if (SUCCEEDED(hres))
        {
            if (pqw->LowPart != cb)
                hres = STG_E_MEDIUMFULL;
        }
        GlobalUnlock(pv);
    }
    else
        hres = E_INVALIDARG;

    return hres;
}


/*****************************************************************************
    FUNCTION: _GetRelativePidl

    DESCRIPTION:
        pszFullPath may come in this format: "dir1\dir2\dir3\file.txt".  We
    need to create *ppidl such that it will contain 4 itemIDs in this case and
    the last one (file.txt) will have the correct attributes and file size.
\*****************************************************************************/
CFtpDir * CFtpDrop::_GetRelativePidl(LPCWSTR pszFullPath, DWORD dwFileAttributes, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    WCHAR szFullPath[MAX_PATH];
    LPWSTR pszFileName;
    LPITEMIDLIST pidlFull;
    CFtpDir * pfd = m_pfd;  // Assume the Dir to create isn't in a subdir.

    // Find the File Name
    StrCpyNW(szFullPath, pszFullPath, ARRAYSIZE(szFullPath));   // Make a copy because the caller's is read only.
    pszFileName = PathFindFileName(szFullPath);                 // Find where the file begins.
    FilePathToUrlPathW(szFullPath);                             // Convert from "dir1\dir2\file.txt" to "dir1/dir2/file.txt"

    *ppidl = NULL;
    hr = CreateFtpPidlFromDisplayPath(szFullPath, m_pff->GetCWireEncoding(), NULL, &pidlFull, TRUE, FALSE);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFile = ILFindLastID(pidlFull);
        SYSTEMTIME st;
        FILETIME ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        FtpPidl_SetAttributes(pidlFile, dwFileAttributes);
        FtpPidl_SetFileSize(pidlFile, dwFileSizeHigh, dwFileSizeLow);
        FtpItemID_SetFileTime(pidlFile, ft);

        // Is the file in a subdir?
        if (!ILIsEmpty(pidlFull) && !ILIsEmpty(_ILNext(pidlFull)))
        {
            // Yes, so generate a CFtpDir to the subdir.
            LPITEMIDLIST pidlPath = ILClone(pidlFull);

            if (pidlPath)
            {
                ILRemoveLastID(pidlPath);
                pfd = m_pfd->GetSubFtpDir(m_pff, pidlPath, FALSE);
                ILFree(pidlPath);
            }
        }

        if (pfd)
            *ppidl = ILClone(pidlFile);
        ILFree(pidlFull);
    }

    return pfd;
}


/*****************************************************************************
    FUNCTION: CopyAsStream

    DESCRIPTION:
        Copy a file contents received as a <mumble> to a stream.
\*****************************************************************************/
HRESULT CFtpDrop::CopyAsStream(LPCWSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STREAMCOPYPROC pfn, LPVOID pv)
{
    BOOL fFireChangeNotify;
    HRESULT hr = ConfirmCopy(pszName, pszName, &m_ops, m_hwnd, m_pff, m_pfd, m_pde, m_cobj, &fFireChangeNotify);

    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlRelative;
        CFtpDir * pfd = _GetRelativePidl(pszName, dwFileAttributes, dwFileSizeHigh, dwFileSizeLow, &pidlRelative);

        if (pfd)
        {
            LPITEMIDLIST pidlFull = ILCombine(pfd->GetPidlReference(), pidlRelative);

            if (pidlFull)
            {
                IStream * pstm;
                ULARGE_INTEGER uliTemp = {0};

                hr = CFtpStm_Create(pfd, pidlFull, GENERIC_WRITE, &pstm, uliTemp, uliTemp, NULL, FALSE);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER uli = {dwFileSizeLow, dwFileSizeHigh};

                    hr = pfn(pstm, dwFlags, dwFileSizeHigh, dwFileSizeLow, pv, &uli);
                    if (SUCCEEDED(hr))
                    {
                        // Only fire change notify if we didn't replace a file on 
                        // browser only. (Because we hack the defview and it doesn't
                        // check for duplicates)
                        if (fFireChangeNotify)
                        {
                            FtpPidl_SetFileSize(pidlRelative, uli.HighPart, uli.LowPart);

                            // This time date stamp may be incorrect.
                            FtpChangeNotify(m_hwnd, SHCNE_CREATE, m_pff, pfd, pidlRelative, NULL, TRUE);
                        }
                    }
                    else
                    {
                        ASSERT(0);      // Is there an orphaned file we need to delete?
                        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }

                    pstm->Release();
                }
                else
                {
                    DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                ILFree(pidlFull);
            }
            else
                hr = E_OUTOFMEMORY;

            if (pfd != m_pfd)
                pfd->Release();

            ILFree(pidlRelative);
        }
        else
            hr = E_FAIL;
    }

    return hr;
}


/*****************************************************************************\
    CopyStream

    Copy a file contents received as a stream.
    We ignore the file size in the fgd.
\*****************************************************************************/
HRESULT CFtpDrop::CopyStream(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw)
{
    IStream * pstmSrc = (IStream *) pvSrc;
    ULARGE_INTEGER qwMax = {0xFFFFFFFF, 0xFFFFFFFF};
    HRESULT hres;

    hres = pstmSrc->CopyTo(pstm, qwMax, 0, pqw);
    ASSERT(SUCCEEDED(hres));

    return hres;
}


/*****************************************************************************\
    FUNCTION: CFtpDrop::CopyStorage

    DESCRIPTION:
        Copy a file contents provided as an IStorage.  Gack.
    We have to do this only because of Exchange.

    Since there is no way to tell OLE to create a .doc file
    into an existing stream, we need to create the .doc file
    on disk, and then copy the file into the stream, then delete
    the .doc file.

    Note that CDropOperation::DoOperation() (_CopyOneHdrop) will do the ConfirmCopy
    and the FtpDropNotifyCreate(), too!  However, we want to fake
    it out and fool it into thinking we are doing a DROPEFFECT_COPY,
    so that it doesn't delete the "source" file.  *We* will delete
    the source file, because we created it.  (No need to tell the
    shell about disk size changes that don't affect it.)
\*****************************************************************************/
HRESULT CFtpDrop::CopyStorage(LPCWSTR pszFile, IStorage * pstgIn)
{
    IStorage * pstgOut;
    HRESULT hr = StgCreateDocfile(0, (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_CREATE), 0, &pstgOut);

    if (SUCCEEDED(hr))
    {
        STATSTG stat;
        hr = pstgOut->Stat(&stat, STATFLAG_DEFAULT);
        if (EVAL(SUCCEEDED(hr)))
        {
            TCHAR szFSSource[MAX_PATH+3];
            TCHAR szFtpDest[MAX_PATH+3];

            SHUnicodeToTChar(stat.pwcsName, szFSSource, ARRAYSIZE(szFSSource));
            StrCpyN(szFtpDest, pszFile, ARRAYSIZE(szFtpDest));
            szFSSource[lstrlen(szFSSource)+1] = 0;    // Add the termination of the list of strings.
            szFtpDest[lstrlen(szFtpDest)+1] = 0;    // Add the termination of the list of strings.

            hr = pstgIn->CopyTo(0, 0, 0, pstgOut);
            pstgOut->Commit(STGC_OVERWRITE);
            pstgOut->Release();     // Must release before copying
            pstgOut = NULL;
            if (SUCCEEDED(hr))
            {
                DROPEFFECT deTrue = m_de;
                m_de = DROPEFFECT_COPY;
                CDropOperation * pDropOperation;
                hr = CDropOperation_Create(m_pff, m_hwnd, szFSSource, szFtpDest, &pDropOperation, m_de, m_ops, m_ops);
    
                // Did it succeed?
                if (SUCCEEDED(hr))
                {
                    // Do the operation asynchroniously because the caller may call
                    // this over an over.
                    EVAL(SUCCEEDED(hr = pDropOperation->DoOperation(FALSE)));
                    pDropOperation->Release();
                }

                // Did an error occure and no UI has been displayed yet?
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                {
                    DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FILECOPY, IDS_FTPERR_WININET, MB_OK, NULL);
                }

                m_de = deTrue;

                DeleteFile(szFSSource);
            }
            else
                DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL);

            SHFree(stat.pwcsName);
        }
        else
            DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL);
    }
    else
        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL);

    return hr;
}


/*****************************************************************************\
    CopyFCont

    Copy a file contents.
\*****************************************************************************/
HRESULT CFtpDrop::CopyFCont(LPCWSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STGMEDIUM *psm)
{
    HRESULT hres;

    switch (psm->tymed)
    {
    case TYMED_HGLOBAL:
        hres = CopyAsStream(pszName, dwFileAttributes, dwFlags, dwFileSizeHigh, dwFileSizeLow, _CopyHglobal, psm->hGlobal);
        break;

    case TYMED_ISTREAM:
        hres = CopyAsStream(pszName, dwFileAttributes, dwFlags, dwFileSizeHigh, dwFileSizeLow, CopyStream, psm->pstm);
        break;

    case TYMED_ISTORAGE:        // Exchange
        hres = CopyStorage(pszName, psm->pstg);
        break;

    default:
        ASSERT(0);
        // Shouldn't have gotten this.
        hres = E_INVALIDARG;
        break;
    }

    return hres;
}


HRESULT CFtpDrop::_GetFileDescriptor(LONG nIndex, LPFILEGROUPDESCRIPTORW pfgdW, LPFILEGROUPDESCRIPTORA pfgdA, BOOL fUnicode, LPFILEDESCRIPTOR pfd)
{
    if (fUnicode)
    {
        LPFILEDESCRIPTORW pfdW = &pfgdW->fgd[nIndex];
    
        CopyMemory(pfd, pfdW, (sizeof(*pfdW) - sizeof(pfdW->cFileName)));   // Copy Everything except the name.
        SHUnicodeToTChar(pfdW->cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
    }
    else
    {
        LPFILEDESCRIPTORA pfdA = &pfgdA->fgd[nIndex];
        
        CopyMemory(pfd, pfdA, (sizeof(*pfdA) - sizeof(pfdA->cFileName)));   // Copy Everything except the name.
        SHAnsiToTChar(pfdA->cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
    }

    return S_OK;
}


HRESULT CFtpDrop::_CreateFGDDirectory(LPFILEDESCRIPTOR pFileDesc)
{
    HRESULT hr = S_OK;
    WCHAR szDirName[MAX_PATH];
    LPTSTR pszDirToCreate = PathFindFileName(pFileDesc->cFileName);
    FTPCREATEFOLDERSTRUCT fcfs = {szDirName, m_pff};
    CFtpDir * pfd = m_pfd;  // Assume the Dir to create isn't in a subdir.

    SHTCharToUnicode(pszDirToCreate, szDirName, ARRAYSIZE(szDirName));
    pszDirToCreate[0] = 0;  // Separate Dir to create from SubDir where to create it.

    // Is the dir to create in subdir?
    if (pFileDesc->cFileName[0])
    {
        // Yes, so let's get that CFtpDir pointer so WithHint below will get us there.
        LPITEMIDLIST pidlPath;
        
        FilePathToUrlPathW(pFileDesc->cFileName);
        hr = CreateFtpPidlFromDisplayPath(pFileDesc->cFileName, m_pff->GetCWireEncoding(), NULL, &pidlPath, TRUE, TRUE);
        if (SUCCEEDED(hr))
        {
            pfd = m_pfd->GetSubFtpDir(m_pff, pidlPath, FALSE);
            if (!pfd)
            {
                hr = E_OUTOFMEMORY;
            }

            ILFree(pidlPath);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = pfd->WithHint(NULL, m_hwnd, CreateNewFolderCB, (LPVOID) &fcfs, NULL, m_pff);
        if (SUCCEEDED(hr))
        {
        }
        else
        {
            // TODO: Display error UI?
        }
    }

    if (m_pfd != pfd)
    {
        // We allocated pfd, so now let's free it.
        pfd->Release();
    }

    return hr;
}


/*****************************************************************************\
    CopyFGD

    Copy a file group descriptor.

    File group descriptors are used to source gizmos that are file-like
    but aren't stored on disk as such.  E.g., an embedded file in a
    mail message, a GIF image in a web page, an OLE scrap, or a file
    on a remote FTP site.

    _UNOBVIOUS_:  If you do a GetData on TYMED_HGLOBAL | TYMED_ISTREAM,
    Exchange will nonetheless give you a TYMED_ISTORAGE even though
    you didn't ask for it.  So we need to support IStorage in order
    to make Exchange look less broken.  (Maybe I shouldn't cover for
    them.  Or maybe I should send them a bill.)
\*****************************************************************************/
HRESULT CFtpDrop::CopyFGD(IDataObject * pdto, STGMEDIUM *psm, BOOL fUnicode)
{
    LPFILEGROUPDESCRIPTORA pfgdA = NULL;
    LPFILEGROUPDESCRIPTORW pfgdW = NULL;
    HRESULT hr = E_INVALIDARG;

    // WARNING:
    //      shell32.dll from Win95, WinNT 4, IE 3, IE 4, and IE 4.01 have
    //      a bug that cause recursive file download not to work for
    //      subdirectories on WinNT unless we implement FILEGROUPDESCRIPTORW.

    if (fUnicode)
        pfgdW = (LPFILEGROUPDESCRIPTORW) GlobalLock((LPFILEGROUPDESCRIPTORW *) psm->hGlobal);
    else
        pfgdA = (LPFILEGROUPDESCRIPTORA) GlobalLock((FILEGROUPDESCRIPTORA *) psm->hGlobal);

    if (EVAL(pfgdA || pfgdW))
    {
        FORMATETC fe = {g_dropTypes[DROP_FCont].cfFormat, 0, DVASPECT_CONTENT, 0, (TYMED_ISTREAM | TYMED_HGLOBAL | TYMED_ISTORAGE)};
        
        // Exchange
        DWORD dwSize = m_cobj = (pfgdW ? pfgdW->cItems : pfgdA->cItems);

        TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::CopyFGD: %d files", m_cobj);
        hr = S_OK;        // Watch out for vacuous null case

        for (; ((UINT)fe.lindex < dwSize); fe.lindex++)
        {
            FILEDESCRIPTOR fileDescriptor = {0};

            if (EVAL(SUCCEEDED(_GetFileDescriptor(fe.lindex, pfgdW, pfgdA, fUnicode, &fileDescriptor))))
            {
                // Is this a folder?
                if ((FD_ATTRIBUTES & fileDescriptor.dwFlags) &&
                    FILE_ATTRIBUTE_DIRECTORY & fileDescriptor.dwFileAttributes)
                {
                    // Yes, so let's create it.  We currently don't copy folder
                    // info. (ACLs or other attributes)
                    hr = _CreateFGDDirectory(&fileDescriptor);
                }
                else
                {
                    // No, so it's a file.  Let's get the stream and then upload that to the FTP server.
                    STGMEDIUM sm;
                    
                    hr = pdto->GetData(&fe, &sm);
                    if (SUCCEEDED(hr))
                    {

                        hr = CopyFCont(fileDescriptor.cFileName, fileDescriptor.dwFileAttributes, fileDescriptor.dwFlags, fileDescriptor.nFileSizeHigh, fileDescriptor.nFileSizeLow, &sm);
                        ReleaseStgMedium(&sm);
                        if (FAILED(hr))
                        {
                            break;
                        }
                    }
                    else
                    {
                        ASSERT(0);
                        break;
                    }
                }
            }
        }

        if (pfgdW)
            GlobalUnlock(pfgdW);
        if (pfgdA)
            GlobalUnlock(pfgdA);
    }

    return hr;
}


/*****************************************************************************\
    _Copy

    Copy the data object into the shell folder.

    HDROPs are preferred, because we can use FtpPutFile to shove
    them onto the FTP site without getting our hands dirty.

    Failing that, we use FileGroupDescriptor, which lets us
    get at pseudo-files.

    Note also that if you use HDROP, you need to support FileNameMap
    otherwise dragging out of the recycle bin directly into an FTP
    folder will create files with the wrong name!

    If a single file is cancelled, should I return DROPEFFECT_NONE?
\*****************************************************************************/
HRESULT CFtpDrop::_Copy(IDataObject * pdto)
{
    STGMEDIUM sm;
    HRESULT hr;

    if (SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_Hdrop], &sm)))
    {
        hr = CopyHdrop(pdto, &sm);
        ReleaseStgMedium(&sm);
    }
    else
    {
        BOOL fSupportsUnicode = SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_FGDW], &sm));

        if (fSupportsUnicode || EVAL(SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_FGDA], &sm))))
        {
            hr = CopyFGD(pdto, &sm, fSupportsUnicode);
            ReleaseStgMedium(&sm);
        }
    }

    // Normally we would set the PASTESUCCEEDED info back into 
    // the IDataObject but we don't because we do an optimized
    // MOVE by doing a DELETE after the COPY operation.
    // We do this because we do the operation on a background thread
    // in order to be asynch and we don't want to extend the lifetime
    // of the IDataObject that long.  Therefore we push
    // DROPEFFECT_COPY back into the caller to tell them that
    // we did an optimized move and to not delete the items.
    //
    // TODO: We need to test the CopyFGD() code above and
    //       maybe use PasteSucceeded(DROPEFFECT_MOVE) in
    //       that case.
    if (SUCCEEDED(hr) && (m_de == DROPEFFECT_MOVE))
    {
        // Always set "Copy" because we did an optimized move
        // because we deleted the files our selfs.
        DataObj_SetPasteSucceeded(pdto, DROPEFFECT_COPY);
    }

    return hr;
}

//===========================
// *** IDropTarget Interface ***
//===========================

/*****************************************************************************

    IDropTarget::DragEnter

 *****************************************************************************/
HRESULT CFtpDrop::DragEnter(IDataObject * pdto, DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_grfks = grfKeyState;    // Remember last key state
    m_grfksAvail = GetEffectsAvail(pdto);

    hr = SetEffect(pde);
    ASSERT(SUCCEEDED(hr));

    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::DragEnter(grfKeyState=%08x, DROPEFFECT=%08x) m_grfks=%08x. m_grfksAvail=%08x hres=%#08lx", grfKeyState, *pde, m_grfks, m_grfksAvail, hr);

    return hr;
}

/*****************************************************************************

    IDropTarget::DragOver

 *****************************************************************************/

HRESULT CFtpDrop::DragOver(DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_grfks = grfKeyState;    // Remember last key state
    hr = SetEffect(pde);
    ASSERT(SUCCEEDED(hr));

    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::DragOver(grfKeyState=%08x, DROPEFFECT=%08x) m_grfks=%08x. SetEffect() returned hres=%#08lx", grfKeyState, *pde, m_grfks, hr);

    return hr;
}


/*****************************************************************************

    IDropTarget::DragLeave

 *****************************************************************************/

HRESULT CFtpDrop::DragLeave(void)
{
    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::DragLeave() ");

    return S_OK;
}


/*****************************************************************************\
    IDropTarget::Drop 

    Note that the incoming pdto is not necessarily the same as the
    one we saw on DragEnter.  OLE will first give us a "preliminary"
    data object to play with, but on the drop, it will give us a
    fully marshalled object.

    Fortunately, we don't care, because we didn't cache the object.

    Note that we don't pass the real pde to SetEffect, because
    we don't want to lose the list of all possible effects before
    GetEffect uses it.
\*****************************************************************************/
HRESULT CFtpDrop::Drop(IDataObject * pdo, DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_ops = opsPrompt;        // Start out in prompt mode
    m_grfksAvail = GetEffectsAvail(pdo);
    
    m_pde = pde;
    m_de = *pde;

    hr = SetEffect(&m_de);
    TraceMsg(TF_FTPDRAGDROP, "CFtpDrop::Drop(grfKeyState=%08x, DROPEFFECT=%08x) m_grfksAvail=%08x. m_de=%08x. SetEffect() returned hres=%#08lx", grfKeyState, *pde, m_grfksAvail, m_de, hr);

    if (EVAL(SUCCEEDED(hr)))
    {
        if (GetEffect(pt))
        {
            hr = _Copy(pdo);
        }
        else
            hr = S_FALSE;   // Indicate cancel.
    }

    if (!(SUCCEEDED(hr)))
    {
        // Error message already has been displayed.
        *pde = 0;
    }

    return hr;
}


/*****************************************************************************\
    CFtpDrop_Create
\*****************************************************************************/
HRESULT CFtpDrop_Create(CFtpFolder * pff, HWND hwnd, CFtpDrop ** ppfdt)
{
    HRESULT hres = E_OUTOFMEMORY;
    CFtpDrop * pfdt = new CFtpDrop();
    *ppfdt = pfdt;

    if (pfdt)
    {
        pfdt->m_hwnd = hwnd;

        // Copy the CFtpFolder * value
        pfdt->m_pff = pff;
        if (pff)
            pff->AddRef();

        // Copy the CFtpDir * value
        ASSERT(!pfdt->m_pfd);
        pfdt->m_pfd = pff->GetFtpDir();
        hres = pfdt->m_pfd ? S_OK : E_FAIL;
        if (FAILED(hres))   // Will fail if the caller is CFtpMenu::_RemoveContextMenuItems() and it's OK.
            ATOMICRELEASE(*ppfdt);
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfdt, hres);
    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpDrop::CFtpDrop() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_hwnd);
    ASSERT(!m_grfks);
    ASSERT(!m_grfksAvail);
    ASSERT(!m_pde);
    ASSERT(!m_cobj);

    LEAK_ADDREF(LEAK_CFtpDrop);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpDrop::~CFtpDrop()
{
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpDrop);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpDrop::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpDrop::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpDrop::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppvObj = SAFECAST(this, IDropTarget*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpDrop::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdhlp.h ===
/*****************************************************************************\
    FILE: ftpdhlp.h

    DESCRIPTION:
        Dialog box helper.  This class will fill in the parts of the dialog
    that pertain to the FTP information
\*****************************************************************************/

#ifndef _FTPDIALOGTEMPLATE_H
#define _FTPDIALOGTEMPLATE_H


/*****************************************************************************\
    CLASS: CFtpDialogTemplate

    DESCRIPTION:
        Dialog box helper.  This class will fill in the parts of the dialog
    that pertain to the FTP information
\*****************************************************************************/
class CFtpDialogTemplate
{
public:
    HRESULT InitDialog(HWND hdlg, BOOL fEditable, UINT id, CFtpFolder * pff, CFtpPidlList * pfpl);
    HRESULT InitDialogWithFindData(HWND hDlg, UINT id, CFtpFolder * pff, const FTP_FIND_DATA * pwfd, LPCWIRESTR pwWirePath, LPCWSTR pwzDisplayPath);
    BOOL OnClose(HWND hdlg, HWND hwndBrowser, CFtpFolder * pff, CFtpPidlList * pfpl);
    BOOL OnDestroy(HWND hdlg, BOOL fEditable, UINT id, CFtpFolder* pff, CFtpPidlList* pPidlList);
    BOOL HasNameChanged(HWND hdlg, CFtpFolder * pff, CFtpPidlList * pPidlList);

    static int _InitSizeTally(LPVOID pvPidl, LPVOID pvSizeHolder);

private:
    HRESULT _ReinsertDlgText(HWND hwnd, LPCVOID pv, LPCTSTR ptszFormat);
    HRESULT _ReplaceIcon(HWND hwnd, HICON hicon);
    HRESULT _InitIcon(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitNameEditable(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitName(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitType(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitLocation(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitSize(HWND hwnd, HWND hwndLabel, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitTime(HWND hwnd, HWND hwndLabel, CFtpFolder * pff, CFtpPidlList * pflHfpl);
    HRESULT _InitCount(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl);

    BOOL m_fEditable;
};



#endif // _FTPDIALOGTEMPLATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdrop.h ===
/*****************************************************************************\
    FILE: ftpdrop.h - IDropTarget interface

    Remarks:

    Note that you cannot create a shortcut on an FTP site.  Although
    there's nothing technically preventing it, it's not done because
    the shortcut won't be of much use on an FTP site.  (It points to
    your local machine, which doesn't help much for people not on the
    same network!)

    If you really want to put a shortcut file on an FTP site, create
    it on the desktop, then drag the shortcut onto the FTP site.

    The default verb for FTP sites is always "Copy".  This is true
    even if an intra-site drag-drop is being done.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CFtpDrop) for a shell extension.
    When it calls CFtpDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Ftp Window, CFtpDrop::Drop() will be called again.
    For this reasons, CFtpDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CFtpDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CFtpDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CFtpDrop remains stateless.
\*****************************************************************************/

#ifndef _FTPDROP_H
#define _FTPDROP_H

#include "util.h"

typedef enum OPS
{                           // Overwrite prompt status
    opsPrompt,              // Prompt each collision
    opsYesToAll,            // Overwrite unconditionally
    opsNoToAll,             // Never overwrite
    opsCancel,              // Stop the operation
} OPS;

#define COHDI_FILESIZE_COUNT            5
#define COHDI_COPY_FILES                6

typedef struct tagCOPYONEHDROPINFO
{
    CFtpFolder * pff;
    LPCWSTR pszFSSource;
    LPCWSTR pszFtpDest;
    LPCWSTR pszDir;
    DWORD dwOperation;                  // COHDI_FILESIZE_COUNT, COHDI_COPY_FILES, etc.
    OPS ops;
    BOOL fIsRoot;
    CMultiLanguageCache * pmlc;
    LPITEMIDLIST pidlServer;
    BOOL fFireChangeNotify;     // Don't fire change notify on BrowserOnly when replacing a file.
    PROGRESSINFO progInfo;
} COPYONEHDROPINFO, * LPCOPYONEHDROPINFO;

typedef HRESULT (*STREAMCOPYPROC)(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pv, ULARGE_INTEGER *pqw);

#ifdef UNICODE
#define _EnumOneHdrop          _EnumOneHdropW
#else // UNICODE
#define _EnumOneHdrop          _EnumOneHdropA
#endif // UNICODE


/*****************************************************************************\

    CFtpDrop

    de and pde are rather gnarly.

    pde is where the output drop effect is kept.  A drop handler
    can force the effect to be DROPEFFECT_COPY if it encounters a
    situation that indicates that the source shouldn't be deleted.
    (E.g., if a file is not copied due to an illegal file name.)

    de is where the current effect is kept.  A drop handler
    should consult de to decide whether or not the source
    should be deleted.  (Used by the HDROP handler, because it is
    the drop target's responsibility to delete the source of an
    HDROP if applicable.)

    You should read from de and write to *pde.  Don't
    write to de or read from *pde.

    The overwrite prompting state tells us how to handle
    the case where an incoming file collides with an existing file.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CFtpDrop) for a shell extension.
    When it calls CFtpDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Ftp Window, CFtpDrop::Drop() will be called again.
    For this reasons, CFtpDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CFtpDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CFtpDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CFtpDrop remains stateless.
\*****************************************************************************/
class CFtpDrop          : public IDropTarget
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IDropTarget ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

public:
    CFtpDrop();
    ~CFtpDrop(void);

    // Public Member Functions
    DWORD GetEffectsAvail(IDataObject * pdto);
    STDMETHODIMP EnumHdrop(HGLOBAL hdrop, HGLOBAL hmap, BOOL fCopy);

    static HRESULT _CopyHglobal(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw);
    static HRESULT CopyStream(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw);
    

    // Friend Functions
    friend HRESULT CFtpDrop_Create(CFtpFolder * pff, HWND hwnd, CFtpDrop ** ppfm);

protected:
    // Protected Member Variables
    int                     m_cRef;

    CFtpFolder *            m_pff;          // The owner
    CFtpDir *               m_pfd;          // The FtpDir of the owner
    HWND                    m_hwnd;         // The window being drug over

    DWORD                   m_grfks;        // Last grfKeyState seen
    DWORD                   m_grfksAvail;   // Effects available
    DROPEFFECT              m_de;           // Effect being performed
    DROPEFFECT *            m_pde;          // Output effect
    OPS                     m_ops;          // Overwrite prompting state
    int                     m_cobj;         // Number of objects being dropped

    // Private Member Functions
    HRESULT SetEffect(DROPEFFECT * pde);
    HRESULT _InvokePaste(LPCMINVOKECOMMANDINFO pici);
    BOOL _HasData(IDataObject * pdto, FORMATETC * pformatetc) { return (S_OK == pdto->QueryGetData(pformatetc)); };
    DROPEFFECT GetEffect(POINTL pt);
    HRESULT CopyStorage(LPCTSTR pszFile, IStorage * pstgIn);
    HRESULT CopyHdrop(IDataObject * pdto, STGMEDIUM *psm);
    HRESULT CopyAsStream(LPCTSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STREAMCOPYPROC pfn, LPVOID pv);
    HRESULT CopyFCont(LPCTSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STGMEDIUM *psm);
    HRESULT CopyFGD(IDataObject * pdto, STGMEDIUM *psm, BOOL fUnicode);
    HRESULT _Copy(IDataObject * pdto);
    HRESULT _CopyOneHdrop(LPCTSTR pszFSSource, LPCTSTR pszFtpDest, IProgressDialog * ppd);

    HRESULT _StartBackgroundInteration(void);
    HRESULT _DoCountIteration(void);
    HRESULT _GetFSSourcePaths(HGLOBAL hdrop, BOOL * pfAnsi);
    HRESULT _GetFtpDestPaths(HGLOBAL hmap, BOOL fAnsi);

private:
    // Private Member Variables
    LPCTSTR                 m_pszzFSSource;         // Paths
    LPCTSTR                 m_pszzFtpDest;              // Map


    HRESULT _CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszFtpDest, IProgressDialog * ppd);
    HRESULT _GetFileDescriptor(LONG nIndex, LPFILEGROUPDESCRIPTORW pfgdW, LPFILEGROUPDESCRIPTORA pfgdA, BOOL fUnicode, LPFILEDESCRIPTOR pfd);
    HRESULT _CreateFGDDirectory(LPFILEDESCRIPTOR pfd);
    BOOL _IsFTPOperationAllowed(IDataObject * pdto);
    CFtpDir * _GetRelativePidl(LPCWSTR pszFullPath, DWORD dwFileAttributes, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPITEMIDLIST * ppidl);
};

#endif // _FTPDROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdir.cpp ===
/*****************************************************************************\
    FILE: ftpdir.cpp

    DESCRIPTION:
        Internal object that manages a single FTP directory

    The idea is that each FtpSite maintains a linked list of the
    FtpDir's that it owns.  Gets and Releases are done through the
    FtpSite.  Each FtpDir retains a non-refcounted pointer back
    to the FtpSite that owns it.

    The reason this is necessary is that there might be multiple
    IShellFolder's all looking at the same physical directory.  Since
    enumerations are expensive, we cache the enumeration information
    here, so that each IShellFolder client can use the information.

    This also lets us hold the motd, so that multiple clients can
    query for the motd without constantly pinging the site.
\*****************************************************************************/


#include "priv.h"
#include "ftpdir.h"
#include "ftpsite.h"
#include "ftppidl.h"
#include "ftpurl.h"
#include "ftppidl.h"
#include "statusbr.h"


/*****************************************************************************\
    FUNCTION: GetDisplayPath

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDir::GetDisplayPath(LPWSTR pwzDisplayPath, DWORD cchSize)
{
    return GetDisplayPathFromPidl(m_pidlFtpDir, pwzDisplayPath, cchSize, FALSE);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        An InternetConnect has just completed.  Get the motd and cache it.

    hint - the connected handle, possibly 0 if error
\*****************************************************************************/
void CFtpDir::CollectMotd(HINTERNET hint)
{
    CFtpGlob * pfg = GetFtpResponse(GetFtpSite()->GetCWireEncoding());

    if (m_pfgMotd)
        m_pfgMotd->Release();

    m_pfgMotd = pfg;  // m_pfgMotd will take pfg's ref.
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Shove a value into the cached list.
\*****************************************************************************/
void CFtpDir::SetCache(CFtpPidlList * pflHfpl)
{
    IUnknown_Set(&m_pflHfpl, pflHfpl);

    // If we are flushing the cache, then flush the Ratings info also.
    // This way the user can reenter the parent password if wanted.
    if (!pflHfpl && m_pfs)
        m_pfs->FlushRatingsInfo();
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get the value out of the cache.
\*****************************************************************************/
CFtpPidlList * CFtpDir::GetHfpl(void)
{
    CFtpPidlList * pfl;
    
    pfl = m_pflHfpl;
    if (pfl)
        pfl->AddRef();

    return pfl;
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get the FTP site associated with a directory.
    This doesn't AddRef the return value.
\*****************************************************************************/
CFtpSite * CFtpDir::GetFtpSite(void)
{
    return m_pfs;
}


CFtpDir * CFtpDir::GetSubFtpDir(CFtpFolder * pff, LPCITEMIDLIST pidl, BOOL fPublic)
{
    CFtpDir * pfd = NULL;

    if (EVAL(pidl))
    {
        LPITEMIDLIST pidlChild = GetSubPidl(pff, pidl, fPublic);
        
        if (EVAL(pidlChild))
        {
            m_pfs->GetFtpDir(pidlChild, &pfd);
            ILFree(pidlChild);
        }
    }

    return pfd;
}


LPITEMIDLIST CFtpDir::GetSubPidl(CFtpFolder * pff, LPCITEMIDLIST pidlRelative, BOOL fPublic)
{
    LPITEMIDLIST pidlRoot = ((fPublic && pff) ? pff->GetPublicPidlRootIDClone() : NULL);
    LPITEMIDLIST pidlPublic = ILCombine(pidlRoot, m_pidl);
    LPITEMIDLIST pidlFull = NULL;

    if (pidlPublic)
    {
        pidlFull = ILCombine(pidlPublic, pidlRelative);
        ILFree(pidlPublic);
    }

    ILFree(pidlRoot);
    return pidlFull;
}


HRESULT CFtpDir::AddItem(LPCITEMIDLIST pidl)
{
    if (!m_pflHfpl)
        return S_OK;

    return m_pflHfpl->InsertSorted(pidl);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get a HINTERNET for this directory.
\*****************************************************************************/
HRESULT CFtpDir::GetHint(HWND hwnd, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CFtpFolder * pff)
{
    HRESULT hr = m_pfs->GetHint(hwnd, m_pidlFtpDir, psb, phint, punkSite, pff);

    return hr;
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Give a HINTERNET back to the FtpSite.
\*****************************************************************************/
void CFtpDir::ReleaseHint(HINTERNET hint)
{
    ASSERT(!hint || m_pfs); // If we have a hint to release, we need to call ::ReleaseHint()
    if (m_pfs)
        m_pfs->ReleaseHint(m_pidlFtpDir, hint);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Perform an operation with a temporary internet handle which is
    already connected to the site and resides in the correct directory.
\*****************************************************************************/
STDMETHODIMP CFtpDir::WithHint(CStatusBar * psb, HWND hwnd, HINTPROC hp, LPCVOID pv, IUnknown * punkSite, CFtpFolder * pff)
{
    HRESULT hr = E_FAIL;

    // Did the user turn off FTP Folders?
    // If so, don't connect.  This will fix NT #406423 where the user turned
    // of FTP Folders because they have a firewall (CISCO filtering Router)
    // that will kill packets in such a way the caller (WinSock/Wininet) needs
    // to wait for a timeout.  During this timeout, the browser will hang causing
    // the user to think it crashed.
    if (!SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER, SZ_REGKEY_USE_OLD_UI, FALSE, FALSE))
    {
        HINTERNET hint;
        HINTPROCINFO hpi;

        ASSERTNONCRITICAL;        // Cannot do psb (CStatusBar *) with the crst
        ASSERT(m_pfs);
        hpi.pfd = this;
        hpi.hwnd = hwnd;
        hpi.psb = psb;

        hr = GetHint(hwnd, psb, &hint, punkSite, pff);
        if (SUCCEEDED(hr)) // Ok if fails
        {
            BOOL fReleaseHint = TRUE;

            if (hp)
                hr = hp(hint, &hpi, (LPVOID)pv, &fReleaseHint);

            if (fReleaseHint)
                ReleaseHint(hint);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetNameOfCB

    DESCRIPTION:
        If we were able to rename the file, return the output pidl.
    Also tell anybody who cares that this LPITEMIDLIST needs to be refreshed.

    The "A" emphasizes that the filename is received in ANSI.

    _UNDOCUMENTED_: The documentation on SetNameOf's treatment of
    the source pidl is random.  It seems to suggest that the source
    pidl is ILFree'd by SetNameOf, but it isn't.
\*****************************************************************************/
HRESULT CFtpDir::_SetNameOfCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPSETNAMEOFINFO psnoi = (LPSETNAMEOFINFO) pv;

    if (phpi->psb)
    {
        TCHAR szStatus[MAX_PATH];
        
        FtpPidl_GetLastItemDisplayName(psnoi->pidlOld, szStatus, ARRAYSIZE(szStatus));
        phpi->psb->SetStatusMessage(IDS_RENAMING, szStatus);
    }

    // Remember, FTP filenames are always in the ANSI character set
    return FtpRenameFilePidlWrap(hint, TRUE, psnoi->pidlOld, psnoi->pidlNew);
}


BOOL CFtpDir::_DoesItemExist(HWND hwnd, CFtpFolder * pff, LPCITEMIDLIST pidl)
{
    FTP_FIND_DATA wfd;
    HRESULT hr = GetFindData(hwnd, FtpPidl_GetLastItemWireName(pidl), &wfd, pff);

    return ((S_OK == hr) ? TRUE : FALSE);
}


BOOL CFtpDir::_ConfirmReplaceWithRename(HWND hwnd)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];

    EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_TITLE, szTitle, ARRAYSIZE(szTitle)));
    EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_RENAME_REPLACE, szMessage, ARRAYSIZE(szMessage)));

    return ((IDYES == MessageBox(hwnd, szMessage, szTitle, (MB_ICONQUESTION | MB_YESNO))) ? TRUE : FALSE);
}


HRESULT CFtpDir::SetNameOf(CFtpFolder * pff, HWND hwndOwner, LPCITEMIDLIST pidl,
           LPCWSTR pwzName, DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = S_OK;
    SETNAMEOFINFO snoi;
    CWireEncoding cWireEncoding;

    ASSERT(pff);

    if (!pwzName)
        return E_FAIL;

    snoi.pidlOld = pidl;
    cWireEncoding.ChangeFtpItemIDName(NULL, pidl, pwzName, IsUTF8Supported(), (LPITEMIDLIST *) &snoi.pidlNew);

    if (snoi.pidlNew)
    {
#ifdef FEATURE_REPLACE_IN_RENAME
// FEATURE: Currently, if the user renames file <a> to file <b> and a file <b>
//    already exists, we fail with the error message, "file already exists...".
//    If we had an excess of time, I would turn on this feature.  It would
//    ask the user if they want to replace the file.  I would then need to add the
//    code that deletes that file and checks for delete errors.

        // Does it already exist?  We don't care if we don't have an hwnd because
        // we can't ask the user to replace so we will just go ahead.
        if (hwndOwner && _DoesItemExist(hwndOwner, pff, snoi.pidlNew))
        {
            // Yes, so let's make sure it's OK with the user to replace it.
            hr = (_ConfirmReplaceWithRename(hwndOwner) ? S_OK : HRESULT_FROM_WIN32(ERROR_CANCELLED));
            todo; // Add the delete call here.
        }
#endif FEATURE_REPLACE_IN_RENAME

        if (S_OK == hr)
        {
            hr = WithHint(NULL, hwndOwner, _SetNameOfCB, (LPVOID) &snoi, NULL, pff);
            if (SUCCEEDED(hr))  // Will fail if use didn't have permission to rename
            {
                // WARNING: The date/time stamp on the server may be different than what we give to SHChangeNotify()
                //          but this is probably reasonable for perf reasons.
                FtpChangeNotify(hwndOwner, FtpPidl_DirChoose(pidl, SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM), pff, this, pidl, snoi.pidlNew, TRUE);

                if (ppidlOut)
                    *ppidlOut = ILClone(snoi.pidlNew);
            }
        }

        ILFree((LPITEMIDLIST) snoi.pidlNew);
    }

    return hr;
}


LPCITEMIDLIST CFtpDir::GetPidlFromWireName(LPCWIRESTR pwWireName)
{
    LPITEMIDLIST pidlToFind = NULL;
    LPITEMIDLIST pidlTemp;
    WCHAR wzDisplayName[MAX_PATH];
    
    // This isn't valid because the code page could be wrong, but we don't care
    // because it's not used in the search for the pidl, the pwWireName is.
    SHAnsiToUnicode(pwWireName, wzDisplayName, ARRAYSIZE(wzDisplayName));
    if (m_pflHfpl && SUCCEEDED(FtpItemID_CreateFake(wzDisplayName, pwWireName, FALSE, FALSE, FALSE, &pidlTemp)))
    {
        // PERF: log 2 (sizeof(m_pflHfpl))
        pidlToFind = m_pflHfpl->FindPidl(pidlTemp, FALSE);
        // We will try again and this time allow for the case to not match
        if (!pidlToFind)
            pidlToFind = m_pflHfpl->FindPidl(pidlTemp, TRUE);
        ILFree(pidlTemp);
    }

    return pidlToFind;
}


LPCITEMIDLIST CFtpDir::GetPidlFromDisplayName(LPCWSTR pwzDisplayName)
{
    WIRECHAR wWireName[MAX_PATH];
    CWireEncoding * pwe = GetFtpSite()->GetCWireEncoding();

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzDisplayName, (IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName))));
    return GetPidlFromWireName(wWireName);
}


/*****************************************************************************\
    FUNCTION: IsRoot

    DESCRIPTION:
        Returns FALSE if we are at the "FTP Folder" root level, not
    inside an actual FTP site.y
\*****************************************************************************/
BOOL CFtpDir::IsRoot(void)
{
    return ILIsEmpty(m_pidl);
}


typedef struct tagGETFINDDATAINFO
{
    LPCWIRESTR pwWireName;
    LPFTP_FIND_DATA pwfd;
} GETFINDDATAINFO, * LPGETFINDDATAINFO;

HRESULT CFtpDir::_GetFindData(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPGETFINDDATAINFO pgfdi = (LPGETFINDDATAINFO) pv;
    HRESULT hr = S_FALSE;

    // Remember, FTP filenames are always in the ANSI character set
    // PERF: Status
    hr = FtpDoesFileExist(hint, TRUE, pgfdi->pwWireName, pgfdi->pwfd, INTERNET_NO_CALLBACK);
    if (SUCCEEDED(hr))
    {
        if (!StrCmpIA(pgfdi->pwfd->cFileName, pgfdi->pwWireName))
            hr = S_OK;        // The are equal.
        else if (!StrCmpA(pgfdi->pwfd->cFileName, SZ_DOTA))
        {
            //    Coincidence of coincidences:  If we found a ".",
            //  then the wfd already contains the description of
            //  the directory!  In other words, the wfd contains
            //  the correct information after all, save for the name.
            //  Aren't we lucky.
            //
            //  And if it isn't dot, then it's some directory with
            //  unknown attributes (so we'll use whatever's lying around).
            //  Just make sure it's a directory.
            pgfdi->pwfd->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            StrCpyNA(pgfdi->pwfd->cFileName, pgfdi->pwWireName, ARRAYSIZE(pgfdi->pwfd->cFileName));
            hr = S_OK;
        }
    }
    else
    {
#ifndef DEBUG
        // Don't display an error msg because some callers will call when they
        // know the file may not exist.  This is the case for ConfirmCopy().
        hr = S_FALSE;
#endif // DEBUG
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFindData

    DESCRIPTION:
        Get the WIN32_FIND_DATA for a file, given by name.

    This is done as part of drag/drop to allow for an overwrite prompt.

    This is all a gross hack because the STAT command
    isn't supported by WinINet (as FtpGetFileAttributes).

    Not that it'd help, because ftp.microsoft.com is OUT OF SPEC
    with regard to the STAT command.  (The first line of the output
    isn't terminated correctly, causing the client to hang.)

    Furthermore, UNIX ftp servers implement STAT incorrectly, too,
    rendering STAT no more useful than LIST.

    HACKHACK -- There is a bug in WinINet where doing a FindFirst
    on a name which happens to be a directory returns the contents
    of the directory instead of the attributes of the directory itself.
    (This is actually a failing of most FTP implementation, because
    they just use /bin/ls for directory listings.)

    So we compare the name that comes back against the name we ask
    for.  If they are different, then it's a folder.  We'll compare
    in a case-insensitive manner because we don't know whether the
    server is case-sensitive or not.

    Note that we can get faked out if a directory contains a file
    which has the same name as the directory.  There is nothing we
    can do about that.  Fortunately, UNIX servers always return "."
    as the first file in a subdirectory, so 99% of the time, we'll
    do the right thing.
\*****************************************************************************/
HRESULT CFtpDir::GetFindData(HWND hwnd, LPCWIRESTR pwWireName, LPFTP_FIND_DATA pwfd, CFtpFolder * pff)
{
    GETFINDDATAINFO gfdi = {pwWireName, pwfd};
    HRESULT hr = WithHint(NULL, hwnd, _GetFindData, &gfdi, NULL, pff);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFindDataForDisplayPath

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDir::GetFindDataForDisplayPath(HWND hwnd, LPCWSTR pwzDisplayPath, LPFTP_FIND_DATA pwfd, CFtpFolder * pff)
{
    CWireEncoding * pwe = GetFtpSite()->GetCWireEncoding();
    WIRECHAR wWirePath[MAX_PATH];

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzDisplayPath, (IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWirePath, ARRAYSIZE(wWirePath))));
    return GetFindData(hwnd, wWirePath, pwfd, pff);
}


/*****************************************************************************\
    FUNCTION: GetNameOf

    DESCRIPTION:
        Common worker that handles SHGDN_FORPARSING style GetDisplayNameOf's.

    Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    _CHARSET_:  Since FTP filenames are always in the ANSI character
    set, by RFC 1738, we can return ANSI display names without loss
    of fidelity.  In a general folder implementation, we should be
    using cStr to return display names, so that the UNICODE
    version of the shell extension can handle UNICODE names.
\*****************************************************************************/
HRESULT CFtpDir::GetNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pstr)
{
    LPITEMIDLIST pidlFull = ILCombine(m_pidl, pidl);
    HRESULT hr = E_FAIL;

    if (pidlFull)
    {
        hr = StrRetFromFtpPidl(pstr, shgno, pidlFull);
        ILFree(pidlFull);
    }

    return hr;
}

/*****************************************************************************\
      FUNCTION: ChangeFolderName

      DESCRIPTION:
        A rename happened on this folder so update the szDir and m_pidl

      PARAMETERS:
        pidlFtpPath
\*****************************************************************************/
HRESULT CFtpDir::ChangeFolderName(LPCITEMIDLIST pidlFtpPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNewFtpPath = NULL;

    EVAL(SUCCEEDED(m_pfs->FlushSubDirs(m_pidlFtpDir)));
    hr = FtpPidl_ReplacePath(m_pidl, pidlFtpPath, &pidlNewFtpPath);
    _SetFtpDir(m_pfs, this, pidlFtpPath);
    if (SUCCEEDED(hr))
    {
        Pidl_Set(&m_pidl, pidlNewFtpPath);
        ILFree(pidlNewFtpPath);
    }

    return hr;
}


/*****************************************************************************\
      FUNCTION: _CompareDirs

      DESCRIPTION:
        Check if the indicated pfd is already rooted at the indicated pidl.
\*****************************************************************************/
int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvFtpDir, LPARAM lParam)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    CFtpDir * pfd = (CFtpDir *) pvFtpDir;

    return FtpItemID_CompareIDsInt(COL_NAME, pfd->m_pidl, pidl, FCMP_NORMAL);
}


HRESULT CFtpDir::_SetFtpDir(CFtpSite * pfs, CFtpDir * pfd, LPCITEMIDLIST pidl)
{
    if (FtpID_IsServerItemID(pidl))
        pidl = _ILNext(pidl);

    // We don't want pfd->m_pidlFtpDir to include the virtual root.
    if (pfd->GetFtpSite()->HasVirtualRoot())
    {
        LPITEMIDLIST pidlIterate = (LPITEMIDLIST) pidl;
        LPITEMIDLIST pidlVRootIterate = (LPITEMIDLIST) pfd->GetFtpSite()->GetVirtualRootReference();

        ASSERT(!FtpID_IsServerItemID(pidl) && !FtpID_IsServerItemID(pidlVRootIterate));
        // Let's see if pidl starts off with 
        while (!ILIsEmpty(pidlVRootIterate) && !ILIsEmpty(pidlIterate) && 
                FtpItemID_IsEqual(pidlVRootIterate, pidlIterate))
        {
            pidlVRootIterate = _ILNext(pidlVRootIterate);
            pidlIterate = _ILNext(pidlIterate);
        }

        if (ILIsEmpty(pidlVRootIterate))
            pidl = (LPCITEMIDLIST)pidlIterate;

    }

    Pidl_Set(&pfd->m_pidlFtpDir, pidl);
    return S_OK;
}


/*****************************************************************************\
      FUNCTION: CFtpDir_Create

      DESCRIPTION:
        Create a brand new FtpDir structure.
\*****************************************************************************/
HRESULT CFtpDir_Create(CFtpSite * pfs, LPCITEMIDLIST pidl, CFtpDir ** ppfd)
{
    CFtpDir * pfd = new CFtpDir();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pfs);
    if (pfd)
    {
        // WARNING: No ref held because it's a back pointer.
        //          This requires that the parent (CFtpSite) always
        //          out live this object.
        pfd->m_pfs = pfs;

        Pidl_Set(&pfd->m_pidl, pidl);
        if (pfd->m_pidl)
            hr = pfd->_SetFtpDir(pfs, pfd, pidl);
        else
            IUnknown_Set(&pfd, NULL);
    }

    *ppfd = pfd;
    ASSERT(*ppfd ? SUCCEEDED(hr) : FAILED(hr));

    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpDir::CFtpDir() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfs);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pfgMotd);
    ASSERT(!m_pidl);

    LEAK_ADDREF(LEAK_CFtpDir);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpDir::~CFtpDir()
{
    // WARNING: m_pfs is a back pointer that doesn't have a ref.
    // m_pfs)

    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pfgMotd, NULL);
    
    if (m_pidl)         // Win95's Shell32.dll crashes with ILFree(NULL)
        ILFree(m_pidl);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpDir);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpDir::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpDir::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpDir::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpDir::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpefe.cpp ===
/*****************************************************************************
 *
 *    ftpefe.cpp - IEnumFORMATETC interface
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpefe.h"
#include "ftpobj.h"


/*****************************************************************************
 *    CFtpEfe::_NextOne
 *****************************************************************************/

HRESULT CFtpEfe::_NextOne(FORMATETC * pfetc)
{
    HRESULT hr = S_FALSE;

    while (ShouldSkipDropFormat(m_dwIndex))
        m_dwIndex++;

    ASSERT(m_hdsaFormatEtc);
    if (m_dwIndex < (DWORD) DSA_GetItemCount(m_hdsaFormatEtc))
    {
        DSA_GetItem(m_hdsaFormatEtc, m_dwIndex, (LPVOID) pfetc);
        m_dwIndex++;         // We are off to the next one
        hr = S_OK;
    }

    if ((S_OK != hr) && m_pfo)
    {
        // We finished looking thru the types supported by the IDataObject.
        // Now look for other items inserted by IDataObject::SetData()
        if (m_dwExtraIndex < (DWORD) DSA_GetItemCount(m_pfo->m_hdsaSetData))
        {
            FORMATETC_STGMEDIUM fs;

            DSA_GetItem(m_pfo->m_hdsaSetData, m_dwExtraIndex, (LPVOID) &fs);
            *pfetc = fs.formatEtc;
            m_dwExtraIndex++;         // We are off to the next one
            hr = S_OK;
        }
    }
    return hr;
}


//===========================
// *** IEnumFORMATETC Interface ***
//===========================

/*****************************************************************************
 *
 *    IEnumFORMATETC::Next
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *
 *    OLE random documentation of the day:  IEnumXXX::Next.
 *
 *    rgelt - Receives an array of size celt (or larger).
 *
 *    "Receives an array"?  No, it doesn't receive an array.
 *    It *is* an array.  The array receives *elements*.
 *
 *    "Or larger"?  Does this mean I can return more than the caller
 *    asked for?  No, of course not, because the caller didn't allocate
 *    enough memory to hold that many return values.
 *
 *    No semantics are assigned to the possibility of celt = 0.
 *    Since I am a mathematician, I treat it as vacuous success.
 *
 *    pcelt is documented as an INOUT parameter, but no semantics
 *    are assigned to its input value.
 *
 *    The dox don't say that you are allowed to return *pcelt < celt
 *    for reasons other than "no more elements", but the shell does
 *    it everywhere, so maybe it's legal...
 *
 *****************************************************************************/

HRESULT CFtpEfe::Next(ULONG celt, FORMATETC * rgelt, ULONG *pceltFetched)
{
    HRESULT hres = S_FALSE;
    DWORD dwIndex;

    // Do they want more and do we have more to give?
    for (dwIndex = 0; dwIndex < celt; dwIndex++)
    {
        if (S_FALSE == _NextOne(&rgelt[dwIndex]))        // Yes, so give away...
            break;

        ASSERT(NULL == rgelt[dwIndex].ptd); // We don't do this correctly.
#ifdef DEBUG
        char szName[MAX_PATH];
        GetCfBufA(rgelt[dwIndex].cfFormat, szName, ARRAYSIZE(szName));
        //TraceMsg(TF_FTP_IDENUM, "CFtpEfe::Next() - Returning %hs", szName);
#endif // DEBUG
    }

    if (pceltFetched)
        *pceltFetched = dwIndex;

    // Were we able to give any?
    if ((0 != dwIndex) || (0 == celt))
        hres = S_OK;

    return hres;
}


/*****************************************************************************
 *    IEnumFORMATETC::Skip
 *****************************************************************************/

HRESULT CFtpEfe::Skip(ULONG celt)
{
    m_dwIndex += celt;

    return S_OK;
}


/*****************************************************************************
 *    IEnumFORMATETC::Reset
 *****************************************************************************/

HRESULT CFtpEfe::Reset(void)
{
    m_dwIndex = 0;
    return S_OK;
}


/*****************************************************************************
 *
 *    IEnumFORMATETC::Clone
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *****************************************************************************/

HRESULT CFtpEfe::Clone(IEnumFORMATETC **ppenum)
{
    return CFtpEfe_Create((DWORD) DSA_GetItemCount(m_hdsaFormatEtc), m_hdsaFormatEtc, m_dwIndex, m_pfo, ppenum);
}


/*****************************************************************************
 *
 *    CFtpEfe_Create
 *
 *    Creates a brand new enumerator based on a list of possibilities.
 *
 *    Note that we are EVIL and know about CFSTR_FILECONTENTS here:
 *    A FORMATETC of FileContents is always valid.  This is important,
 *    because CFtpObj doesn't actually have a STGMEDIUM for file contents.
 *    (Due to lindex weirdness.)
 *
 *****************************************************************************/

HRESULT CFtpEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo, CFtpEfe ** ppfefe)
{
    CFtpEfe * pfefe;
    HRESULT hres = E_OUTOFMEMORY;

    pfefe = *ppfefe = new CFtpEfe(dwSize, rgfe, rgstg, pfo);
    if (pfefe)
    {
        if (!pfefe->m_hdsaFormatEtc)
            pfefe->Release();
        else
            hres = S_OK;
    }

    if (FAILED(hres) && pfefe)
        IUnknown_Set(ppfefe, NULL);

    return hres;
}


/*****************************************************************************
 *
 *    CFtpEfe_Create
 *
 *    Creates a brand new enumerator based on a list of possibilities.
 *
 *    Note that we are EVIL and know about CFSTR_FILECONTENTS here:
 *    A FORMATETC of FileContents is always valid.  This is important,
 *    because CFtpObj doesn't actually have a STGMEDIUM for file contents.
 *    (Due to lindex weirdness.)
 *
 *****************************************************************************/

HRESULT CFtpEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo, IEnumFORMATETC ** ppenum)
{
    CFtpEfe * pfefe;
    HRESULT hres = CFtpEfe_Create(dwSize, rgfe, rgstg, pfo, &pfefe);

    if (pfefe)
    {
        hres = pfefe->QueryInterface(IID_IEnumFORMATETC, (LPVOID *) ppenum);
        pfefe->Release();
    }

    return hres;
}


/*****************************************************************************
 *
 *    CFtpEfe_Create
 *****************************************************************************/

HRESULT CFtpEfe_Create(DWORD dwSize, HDSA m_hdsaFormatEtc, DWORD dwIndex, CFtpObj * pfo, IEnumFORMATETC ** ppenum)
{
    CFtpEfe * pfefe;
    HRESULT hres = E_OUTOFMEMORY;

    pfefe = new CFtpEfe(dwSize, m_hdsaFormatEtc, pfo, dwIndex);
    if (pfefe)
    {
        hres = pfefe->QueryInterface(IID_IEnumFORMATETC, (LPVOID *) ppenum);
        pfefe->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpEfe::CFtpEfe(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_dwIndex);
    ASSERT(!m_hdsaFormatEtc);
    ASSERT(!m_pfo);

    m_hdsaFormatEtc = DSA_Create(sizeof(rgfe[0]), 10);
    if (m_hdsaFormatEtc)
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < dwSize; dwIndex++)
        {
#ifdef    DEBUG
            char szNameDebug[MAX_PATH];
            GetCfBufA(rgfe[dwIndex].cfFormat, szNameDebug, ARRAYSIZE(szNameDebug));
#endif // DEBUG
    
            if (rgfe[dwIndex].tymed == TYMED_ISTREAM ||
                (rgstg && rgfe[dwIndex].tymed == rgstg[dwIndex].tymed))
            {
#ifdef DEBUG
                //TraceMsg(TF_FTP_IDENUM, "CFtpEfe() Keeping %hs", szNameDebug);
#endif // DEBUG
                DSA_SetItem(m_hdsaFormatEtc, dwIndex, &rgfe[dwIndex]);
            }
            else
            {
#ifdef DEBUG
                //TraceMsg(TF_FTP_IDENUM, "CFtpEfe() Ignoring %hs", szNameDebug);
#endif // DEBUG
            }
        }
    }

    if (pfo)
    {
        m_pfo = pfo;
        m_pfo->AddRef();
    }

    LEAK_ADDREF(LEAK_CFtpEfe);
}


/****************************************************\
    Constructor
\****************************************************/
CFtpEfe::CFtpEfe(DWORD dwSize, HDSA hdsaFormatEtc, CFtpObj * pfo, DWORD dwIndex) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_dwIndex);
    ASSERT(!m_hdsaFormatEtc);
    ASSERT(!m_pfo);

    ASSERT(hdsaFormatEtc);
    m_hdsaFormatEtc = DSA_Create(sizeof(FORMATETC), 10);
    if (m_hdsaFormatEtc)
    {
        for (dwIndex = 0; dwIndex < (DWORD) DSA_GetItemCount(hdsaFormatEtc); dwIndex++)
        {
            DSA_SetItem(m_hdsaFormatEtc, dwIndex, DSA_GetItemPtr(hdsaFormatEtc, dwIndex));
        }
    }

    if (pfo)
    {
        m_pfo = pfo;
        m_pfo->AddRef();
    }


    LEAK_ADDREF(LEAK_CFtpEfe);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpEfe::~CFtpEfe()
{
    DSA_Destroy(m_hdsaFormatEtc);

    if (m_pfo)
        m_pfo->Release();

    DllRelease();
    LEAK_DELREF(LEAK_CFtpEfe);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpEfe::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpEfe::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpEfe::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumFORMATETC))
    {
        *ppvObj = SAFECAST(this, IEnumFORMATETC*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpEfe::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpefe.h ===
/*****************************************************************************\
    FILE: ftpefe.h
\*****************************************************************************/

#ifndef _FTPEFE_H
#define _FTPEFE_H


/*****************************************************************************\
    CLASS: CFtpEfe

    DESCRIPTION:
        The stuff that tracks the state of an enumeration.
\*****************************************************************************/

class CFtpEfe           : public IEnumFORMATETC
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IEnumFORMATETC ***
    virtual STDMETHODIMP Next(ULONG celt, FORMATETC * rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumFORMATETC **ppenum);

public:
    // Friend Functions
    friend HRESULT CFtpEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo, IEnumFORMATETC ** ppenum);

protected:
    // Private Member Variables
    int                     m_cRef;

    DWORD                   m_dwIndex;           // Current Item in the m_hdsaFormatEtc list
    DWORD                   m_dwExtraIndex;      // Current Item in the m_pfo->m_hdsaSetData list
    HDSA                    m_hdsaFormatEtc;     // pointer to the array 
    CFtpObj *               m_pfo;               // pointer to the parent IDataObject impl that has the list of extra data from ::SetData.


    CFtpEfe(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo);
    CFtpEfe(DWORD dwSize, HDSA hdsaFormatEtc, CFtpObj * pfo, DWORD dwIndex);
    ~CFtpEfe(void);

    // Public Member Functions
    HRESULT _NextOne(FORMATETC * pfetc);

    
    // Friend Functions
    friend HRESULT CFtpEfe_Create(DWORD dwSize, HDSA m_hdsaFormatEtc, DWORD dwIndex, CFtpObj * pfo, IEnumFORMATETC ** ppenum);
    friend HRESULT CFtpEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo, CFtpEfe ** ppfefe);
};

#endif // _FTPEFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpglob.cpp ===
/**************************************************************\
    FILE: ftpglob.cpp

    DESCRIPTION:
        Refcounted HGLOBAL.
\**************************************************************/

#include "priv.h"
#include "ftpglob.h"


/****************************************************\
    Constructor
\****************************************************/
CFtpGlob::CFtpGlob() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hglob);

    LEAK_ADDREF(LEAK_CFtpGlob);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpGlob::~CFtpGlob()
{
    if (m_hglob)
        GlobalFree(m_hglob);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpGlob);
}


//===========================
// *** IUnknown Interface ***
ULONG CFtpGlob::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpGlob::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpGlob::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpGlob::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



/****************************************************\
    FUNCTION: CFtpGlob_Create
  
    DESCRIPTION:
        This function will create an instance of the
    CFtpGlob object.
\****************************************************/
IUnknown * CFtpGlob_Create(HGLOBAL hglob)
{
    IUnknown * punk = NULL;
    CFtpGlob * pfg = new CFtpGlob();

    if (pfg)
    {
        pfg->m_hglob = hglob;
        pfg->QueryInterface(IID_IUnknown, (LPVOID *)&punk);
        pfg->Release();
    }

    return punk;
}



/****************************************************\
    FUNCTION: CFtpGlob_CreateStr
  
    DESCRIPTION:
        This function will create an instance of the
    CFtpGlob object.
\****************************************************/
CFtpGlob * CFtpGlob_CreateStr(LPCTSTR pszStr)
{
    CFtpGlob * pfg = new CFtpGlob();

    if (EVAL(pfg))
        pfg->m_hglob = (HGLOBAL) pszStr;

    return pfg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpfoldr.h ===
/*****************************************************************************\
    FILE: ftpfoldr.h

    DESCRIPTION:
        This class inherits from CBaseFolder for a base ShellFolder implementation
    of IShellFolder and overrides methods to give Ftp Specific features.
\*****************************************************************************/

#ifndef _FTPFOLDER_H
#define _FTPFOLDER_H

#include "isf.h"
#include "ftpdir.h"
#include "ftpsite.h"
#include "ftplist.h"
#include "ftpglob.h"
#include "ftppidl.h"
#include "cowsite.h"
#include "util.h"

class CFtpDir;
class CFtpSite;


/*****************************************************************************\
     CFtpFolder
 
     The stuff that tracks the state of a folder.
 
     The cBusy field tracks how many sub-objects have been created
     (e.g., IEnumIDList) which still contain references to this
     folder's identity.  You cannot change the folder's identity
     (via IPersistFolder::Initialize) while there are outstanding
     subobjects.
 
     The number of cBusy's never exceeds the number of cRef's, because
     each subobject that requires the folder identity must retain a
     reference to the folder itself.  That way, the folder won't be
     Release()d while the identity is still needed.
\*****************************************************************************/

class CFtpFolder        : public CBaseFolder
                        , public IShellIcon
                        , public IShellIconOverlay
                        , public IDelegateFolder
                        , public IShellPropSheetExt
                        , public IBrowserFrameOptions
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CBaseFolder::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {return CBaseFolder::Release();};
    
    // *** IShellFolder ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                            ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    virtual STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);
    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);
    
    // *** IShellFolder2 ***
    virtual STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);        // Override default behavior

    // *** IShellIcon ***
    virtual STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // *** IShellIconOverlay ***
    virtual STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex) {return GetOverlayIndexHelper(pidl, pIndex, SIOM_OVERLAYINDEX);};
    virtual STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIconIndex) {return GetOverlayIndexHelper(pidl, pIconIndex, SIOM_ICONINDEX);};

    // *** IDelegateFolder ***
    virtual STDMETHODIMP SetItemAlloc(IMalloc *pm);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam) {return AddFTPPropertyPages(pfnAddPage, lParam, &m_hinstInetCpl, _punkSite);};
    virtual STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam) {return E_NOTIMPL;};

    // *** IBrowserFrameOptions ***
    virtual STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);


public:
    CFtpFolder();
    ~CFtpFolder(void);

    // Public Member Functions
    void InvalidateCache(void);
    CFtpDir * GetFtpDir(void);
    CFtpDir * GetFtpDirFromPidl(LPCITEMIDLIST pidl);

    BOOL IsRoot(void) { return ILIsEmpty(GetPrivatePidlReference()); };
    BOOL IsUTF8Supported(void);
    BOOL _IsValidPidlParameter(LPCITEMIDLIST pidl);
    HRESULT GetItemAllocator(IMalloc **ppm);
    IMalloc * GetItemAllocatorDirect(void) {ASSERT(m_pm); return m_pm;};
    HRESULT GetUIObjectOfHfpl(HWND hwndOwner, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject);
    HRESULT CreateSubViewObject(HWND hwndOwner, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
    HRESULT _PidlToMoniker(LPCITEMIDLIST pidl, IMoniker ** ppmk);
    HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj);
    CFtpGlob * GetSiteMotd(void);
    CWireEncoding * GetCWireEncoding(void);
    HRESULT _InitFtpSite(void);
    IMalloc * GetIMalloc(void);
    HRESULT _Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate);
    HRESULT _BindToObject_OriginalFtpSupport(LPCITEMIDLIST pidl, REFIID riid, LPVOID * ppvObj);
    HRESULT _FilterBadInput(LPCTSTR pszUrl, LPITEMIDLIST * ppidl);
    HRESULT _BindToObject(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlFull, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj);
//    HRESULT AddToUrlHistory(LPCTSTR pszUrl);
    HRESULT AddToUrlHistory(LPCITEMIDLIST pidl);
    HRESULT AddToUrlHistory(void) {return AddToUrlHistory(this->GetPrivatePidlReference());};
    HRESULT GetOverlayIndexHelper(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);
    HRESULT _GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject);

    static HRESULT FolderCompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
    {
        return FtpItemID_CompareIDs(lParam, pidl1, pidl2, FCMP_GROUPDIRS);
    };

    // Public Member Variables
    CFtpSite *              m_pfs;
    IMalloc *               m_pm;           // today's itemid allocator
    IUrlHistoryStg *        m_puhs;         // Used to add to the history list.
    HINSTANCE               m_hinstInetCpl; // HANDLE to Internet Control panel for View.Options.
    IShellIconOverlayManager * m_psiom;     // Used to get default icon overlays like shortcut cue.

    // Friend Functions
    friend HRESULT CFtpFolder_Create(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, int ib, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CFtpFolder_Create(REFIID riid, LPVOID * ppvObj);

protected:
    HRESULT _FixQuestionablePidl(LPCITEMIDLIST pidl);
    BOOL _IsProxyBlockingSite(LPCITEMIDLIST pidl);
    BOOL _IsServerVMS(LPCITEMIDLIST pidl);
    BOOL _NeedToFallBack(LPCITEMIDLIST pidl, BOOL * pfDisplayProxyFallBackDlg);
    BOOL _NeedToFallBackRelative(LPCITEMIDLIST pidl, BOOL * pfDisplayProxyFallBackDlg);
    HRESULT _CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj);
    HRESULT _AddToUrlHistory(LPCWSTR pwzUrl);
    HRESULT _GetCachedPidlFromDisplayName(LPCTSTR pszDisplayName, LPITEMIDLIST * ppidl);
    HRESULT _ForPopulateAndEnum(CFtpDir * pfd, LPCITEMIDLIST pidlBaseDir, LPCTSTR pszUrl, LPCWIRESTR pwLastDir, LPITEMIDLIST * ppidl);
    HRESULT _GetLegacyURL(LPCITEMIDLIST pidl, IBindCtx * pbc, LPTSTR pszUrl, DWORD cchSize);
    HRESULT _GetLegacyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlLegacy);
    HRESULT _INetBindToObject(LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj);
    HRESULT _InitLegacyShellFolder(IShellFolder * psfLegacy, LPCITEMIDLIST pidlInit);
    HRESULT _ConvertPidlForRootedFix(LPCITEMIDLIST pidlBefore, LPITEMIDLIST * ppidlWithVRoot);
	HRESULT _GetBindCtx(IBindCtx ** ppbc);
    IShellFolder * _GetLegacyShellFolder(void);
};

#endif // _FTPFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpeidl.h ===
/*****************************************************************************
 *	ftpeidl.h
 *****************************************************************************/

#ifndef _FTPEIDL_H
#define _FTPEIDL_H

#include "cowsite.h"


/*****************************************************************************
 *
 *	CFtpEidl
 *
 *	The stuff that tracks the state of an enumeration.
 *
 *****************************************************************************/

class CFtpEidl          : public IEnumIDList
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IEnumIDList ***
    virtual STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumIDList **ppenum);

public:
    CFtpEidl();
    ~CFtpEidl(void);

    // Friend Functions
    friend HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum);

protected:
    // Private Member Variables

    int                     m_cRef;
    BITBOOL                 m_fInited : 1;      // Have we been inited?
    BITBOOL                 m_fDead : 1;        // Is this enumerator dead because we had to do a redirect (because password was needed or was invalid).
    BITBOOL                 m_fErrorDisplayed : 1; // Only show one error per enum.  This is how we keep track.
    DWORD                   m_nIndex;           // Current Item in the list
    DWORD                   m_shcontf;          // Filter flags
    CFtpPidlList *          m_pflHfpl;          // Where the cache lives
    CFtpDir *               m_pfd;              // My FtpDir
    CFtpFolder *            m_pff;              // My FtpDir
    IMalloc *               m_pm;               // Today's itemid allocator
    HWND                    m_hwndOwner;        // My UI window
// CAN DO: Someday we could implement hiden files:  int m_cHiddenFiles;


    // Public Member Functions
    BOOL _fFilter(DWORD shcontf, DWORD dwFAFLFlags);
    HRESULT _Init(void);
    LPITEMIDLIST _NextOne(DWORD * pdwIndex);
    HRESULT _PopulateItem(HINTERNET hint0, HINTPROCINFO * phpi);
    HRESULT _AddFindDataToPidlList(LPCITEMIDLIST pidl);
    HRESULT _HandleSoftLinks(HINTERNET hint, LPITEMIDLIST pidl, LPWIRESTR pwCurrentDir, DWORD cchSize);
    BOOL _IsNavigationItem(LPWIN32_FIND_DATA pwfd);
    static HRESULT _PopulateItemCB(HINTERNET hint0, HINTPROCINFO * phpi, LPVOID pvCFtpEidl, BOOL * pfReleaseHint) {return ((CFtpEidl *)pvCFtpEidl)->_PopulateItem(hint0, phpi);};

    
    // Friend Functions
    friend HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, CFtpEidl ** ppfe);
    friend HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, DWORD dwIndex, IEnumIDList ** ppenum);
};

#endif // _FTPEIDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpglob.h ===
/*****************************************************************************
 *
 *	ftpglob.h - HGLOBAL babysitting
 *
 *	Included from ftpview.h
 *
 *****************************************************************************/

#ifndef _FTPGLOB_H
#define _FTPGLOB_H

/*****************************************************************************
 *
 *	This is the generic IUnknown wrapper that GlobalFree's its
 *	charge when released.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CFtpGlob
 *
 *	CFtpGlob is used as the punkForRelease when we hand a shared HGLOBAL
 *	out to somebody else.  We can't simply use the DataObject itself,
 *	because that would result in havoc if the DataObject itself decided
 *	to free the HGLOBAL while there were still outstanding references to it.
 *
 *	It's also used when we need a refcounted string.  Just put the
 *	string into the hglob and have fun.
 *
 *****************************************************************************/

class CFtpGlob          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CFtpGlob();
    ~CFtpGlob(void);


    // Public Member Functions
    HRESULT SetHGlob(HGLOBAL hglob) {m_hglob = hglob; return S_OK;};
    HGLOBAL GetHGlob(void) {return m_hglob;};
    LPCTSTR GetHGlobAsTCHAR(void) {return (LPCTSTR) m_hglob;};


    // Friend Functions
    friend IUnknown * CFtpGlob_Create(HGLOBAL hglob);
    friend CFtpGlob * CFtpGlob_CreateStr(LPCTSTR pszStr);

protected:
    // Private Member Variables
    int m_cRef;

    HGLOBAL                 m_hglob;		// The HGLOBAL we are babysitting
};

#endif // _FTPGLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpeidl.cpp ===
/*****************************************************************************
 *
 *    ftpeidl.cpp - IEnumIDList interface
 *
 *    FtpNameCache
 *
 *    Enumerating an FTP site is an expensive operation, because
 *    it can entail dialing the phone, connecting to an ISP, then
 *    connecting to the site, logging in, cd'ing to the appropriate
 *    location, pumping over an "ls" command, parsing the result,
 *    then closing the connection.
 *
 *    So we cache the results of an enumeration inside a pidl list.
 *    If the user does a REFRESH, then we toss the list and create
 *    a new one.
 *
 *    NOTE! that the WinINet API does not allow a FindFirst to be
 *    interrupted.  In other words, once you do an FtpFindFirst,
 *    you must read the directory to completion and close the
 *    handle before you can do anything else to the site.
 *
 *    As a result, we cannot use lazy evaluation on the enumerated
 *    contents.  (Not that it helps any, because WinINet will just
 *    do an "ls", parse the output, and then hand the items back
 *    one element at a time via FtpFindNext.  You may as well retrieve
 *    them all the moment they're ready.)
 *
\*****************************************************************************/

#include "priv.h"
#include "ftpeidl.h"
#include "view.h"
#include "util.h"


/*****************************************************************************
 *
 *    We actually cache the result of the enumeration in the parent
 *    FtpDir, because FTP enumeration is very expensive.
 *
 *    Since DVM_REFRESH forces us to re-enumerate, but we might have
 *    outstanding IEnumIDList's, we need to treat the object cache
 *    as yet another object that needs to be refcounted.
 *
 *****************************************************************************/


/*****************************************************************************
 *    _fFilter
 *
 *    Decides whether the file attributes agree with the filter criteria.
 *
 *    If hiddens are excluded, then exclude hiddens.  (Duh.)
 *
 *    Else, include or exclude based on folder/nonfolder-ness.
 *
 *    Let's look at that expression in slow motion.
 *
 *    "The attributes pass the filter if both...
 *        (1) it passes the INCLUDEHIDDEN criterion, and
 *        (2) it passes the FOLDERS/NONFOLDERS criterion.
 *
 *    The INCLUDEHIDDEN criterion is passed if FILE_ATTRIBUTE_HIDDEN
 *    implies SHCONTF_INCLUDEHIDDEN.
 *
 *    The FOLDERS/NONFOLDERS criterion is passed if the appropriate bit
 *    is set in the shcontf, based on the actual type of the file."
 *****************************************************************************/
BOOL CFtpEidl::_fFilter(DWORD shcontf, DWORD dwFAFLFlags)
{
    BOOL fResult = FALSE;

    if (shcontf & SHCONTF_FOLDERS)
        fResult |= dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY;

    if (shcontf & SHCONTF_NONFOLDERS)
        fResult |= !(dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY);

    if ((dwFAFLFlags & FILE_ATTRIBUTE_HIDDEN) && !(shcontf & SHCONTF_INCLUDEHIDDEN))
        fResult = FALSE;

    return fResult;
}


/*****************************************************************************\
 *    _AddFindDataToPidlList
 *
 *    Add information in a WIN32_FIND_DATA to the cache.
 *    Except that dot and dotdot don't go in.
\*****************************************************************************/
HRESULT CFtpEidl::_AddFindDataToPidlList(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    if (EVAL(m_pflHfpl))
    {
        ASSERT(IsValidPIDL(pidl));
        hr = m_pflHfpl->InsertSorted(pidl);
    }
    
    return hr;
}


/*****************************************************************************\
    FUNCTION: _HandleSoftLinks

    DESCRIPTION:
        A softlink is a file on an UNIX server that reference another file or
    directory.  We can detect these by the fact that (pwfd->dwFileAttribes == 0).
    If that is true, we have some work to do.  First we find out if it's a file
    or a directory by trying to ChangeCurrentWorking directories into it.  If we
    can we turn the dwFileAttributes from 0 to (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT).
    If it's just a softlink to a file, then we change it to
    (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_REPARSE_POINT).  We later use the
    FILE_ATTRIBUTE_REPARSE_POINT attribute to put the shortcut overlay on it to
    que the user.

    RETURN VALUE:
        HRESULT - If FAILED() is returned, the item will not be added to the
                  list view.
\*****************************************************************************/
HRESULT CFtpEidl::_HandleSoftLinks(HINTERNET hint, LPITEMIDLIST pidl, LPWIRESTR pwCurrentDir, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // Is it a softlink? It just came in off the wire and wininet returns 0 (zero)
    // for softlinks.  This function will determine if it's a SoftLink to a file
    // or a directory and then set FILE_ATTRIBUTE_REPARSE_POINT or
    // (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT) respectively.
    if (0 == FtpPidl_GetAttributes(pidl))
    {
        LPCWIRESTR pwWireFileName = FtpPidl_GetFileWireName(pidl);

        // Yes, so I will need to attempt to CD into that directory to test if it's a directory.
        // I need to get back because ".." won't work.  I will cache the return so I don't keep
        // getting it if there is a directory full of them.

        // Did we get the current directory yet?  This is the bread crums so I can
        // find my way back.
        if (!pwCurrentDir[0])
            EVAL(SUCCEEDED(FtpGetCurrentDirectoryWrap(hint, TRUE, pwCurrentDir, cchSize)));

        // Yes, so is it a directory?
        if (SUCCEEDED(FtpSetCurrentDirectoryPidlWrap(hint, TRUE, pidl, FALSE, FALSE)))  // Relative CD
        {
            // Does it have a virtual root?
            if (m_pfd->GetFtpSite()->HasVirtualRoot())
            {
                LPCITEMIDLIST pidlVirtualRoot = m_pfd->GetFtpSite()->GetVirtualRootReference();
                LPITEMIDLIST pidlSoftLinkDest = NULL;
                CWireEncoding * pwe = m_pfd->GetFtpSite()->GetCWireEncoding();

                // Yes, so we need to make sure this dir softlink doesn't point
                // outside of the virtual root, or it would cause invalid FTP URLs.
                // File SoftLinks are fine because the old FTP Code abuses FTP URLs.
                // I'm just not ready to drop my morals just yet.
                if (SUCCEEDED(FtpGetCurrentDirectoryPidlWrap(hint, TRUE, pwe, &pidlSoftLinkDest)))
                {
                    if (!FtpItemID_IsParent(pidlVirtualRoot, pidlSoftLinkDest))
                    {
                        // This is a Softlink or HardLink to a directory outside of the virtual root.
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Skip this one.
                    }

                    ILFree(pidlSoftLinkDest);
                }
            }

            // Return to where we came from.
            //TraceMsg(TF_WININET_DEBUG, "_HandleSoftLinks FtpSetCurrentDirectory(%hs) worked", pwWireFileName);
            EVAL(SUCCEEDED(FtpSetCurrentDirectoryWrap(hint, TRUE, pwCurrentDir)));  // Absolute CD
            FtpPidl_SetAttributes(pidl, (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT));
            FtpPidl_SetFileItemType(pidl, TRUE);
        }
        else    // No, it's one of those files w/o extensions.
        {
            TraceMsg(TF_WININET_DEBUG, "_HandleSoftLinks FtpSetCurrentDirectory(%s) failed", pwWireFileName);
            FtpPidl_SetAttributes(pidl, (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_REPARSE_POINT));
            FtpPidl_SetFileItemType(pidl, FALSE);
        }
    }

    return hr;
}


/*****************************************************************************\
 *    CFtpEidl::_PopulateItem
 *
 *    Fill a cache with stuff.
 *
 *    EEK!  Some ftp servers (e.g., ftp.funet.fi) run with ls -F!
 *    This means that things get "*" appended to them if they are executable.
\*****************************************************************************/
HRESULT CFtpEidl::_PopulateItem(HINTERNET hint0, HINTPROCINFO * phpi)
{
    HRESULT hr = S_OK;
    HINTERNET hint;
    LPITEMIDLIST pidl;
    CMultiLanguageCache cmlc;
    CWireEncoding * pwe = m_pfd->GetFtpSite()->GetCWireEncoding();

    if (phpi->psb)
    {
        phpi->psb->SetStatusMessage(IDS_LS, NULL);
        EVAL(SUCCEEDED(_SetStatusBarZone(phpi->psb, phpi->pfd->GetFtpSite())));
    }

    hr = FtpFindFirstFilePidlWrap(hint0, TRUE, &cmlc, pwe, NULL, &pidl, 
                (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD), NULL, &hint);
    if (hint)
    {
        WIRECHAR wCurrentDir[MAX_PATH];   // Used for _HandleSoftLinks().

        wCurrentDir[0] = 0;
        if (EVAL(m_pff))
        {
            m_pff->AddToUrlHistory(m_pfd->GetPidlReference());
        }

        //TraceMsg(TF_FTP_OTHER, "CFtpEidl::_PopulateItem() adding Name=%s", wCurrentDir);
        if (pidl && SUCCEEDED(_HandleSoftLinks(hint0, pidl, wCurrentDir, ARRAYSIZE(wCurrentDir))))
            hr = _AddFindDataToPidlList(pidl);

        ILFree(pidl);
        while (SUCCEEDED(hr))
        {
            hr = InternetFindNextFilePidlWrap(hint, TRUE, &cmlc, pwe, &pidl);
            if (SUCCEEDED(hr))
            {
                //TraceMsg(TF_FTP_OTHER, "CFtpEidl::_PopulateItem() adding Name=%hs", FtpPidl_GetLastItemWireName(pidl));
                // We may decide to not add it for some reasons.
                if (SUCCEEDED(_HandleSoftLinks(hint0, pidl, wCurrentDir, ARRAYSIZE(wCurrentDir))))
                    hr = _AddFindDataToPidlList(pidl);

                ILFree(pidl);
            }
            else
            {
                // We failed to get the next file.
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
                {
                    DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FOLDERENUM, IDS_FTPERR_WININET, MB_OK, NULL);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Clean error to indicate we already displayed the error and don't need to do it later.
                }
                else
                    hr = S_OK;        // That's fine if there aren't any more files to get

                break;    // We are done here.
            }
        }

        EVAL(SUCCEEDED(pwe->ReSetCodePages(&cmlc, m_pflHfpl)));
        InternetCloseHandle(hint);
    }
    else
    {
        // This will happen in two cases.
        // 1. The folder is empty. (GetLastError() == ERROR_NO_MORE_FILES)
        // 2. The user doesn't have enough access to view the folder. (GetLastError() == ERROR_INTERNET_EXTENDED_ERROR)
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
        {
            DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_OPENFOLDER, IDS_FTPERR_WININET, MB_OK, NULL);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Clean error to indicate we already displayed the error and don't need to do it later.
            WININET_ASSERT(SUCCEEDED(hr));
        }
        else
            hr = S_OK;

        TraceMsg(TF_FTP_IDENUM, "CFtpEnum_New() - Can't opendir. hres=%#08lx.", hr);
    }

    if (phpi->psb)
        phpi->psb->SetStatusMessage(IDS_EMPTY, NULL);

    return hr;
}


/*****************************************************************************\
 *    CFtpEidl::_Init
\*****************************************************************************/
HRESULT CFtpEidl::_Init(void)
{
    HRESULT hr = S_FALSE;
    
    ASSERT(m_pfd);
    IUnknown_Set(&m_pflHfpl, NULL);
    m_pflHfpl = m_pfd->GetHfpl();       // Use cached copy if it exists.

    if (m_pflHfpl)
    {
        // We will just use the previous copy because we already have the contents.
        // TODO: Maybe we want to purge the results if a certain amount of time as ellapsed.
        m_fInited = TRUE;
        hr = S_OK;
    }
    else if (!m_pfd->GetFtpSite()->IsSiteBlockedByRatings(m_hwndOwner))
    {
        CFtpPidlList_Create(0, NULL, &m_pflHfpl);
        if (m_pflHfpl)
        {
            CStatusBar * psb = GetCStatusBarFromDefViewSite(_punkSite);

            ASSERT(!m_pfd->IsRoot());
            //TraceMsg(TF_ALWAYS, "CFtpEidl::_Init() and enumerating");
            hr = m_pfd->WithHint(psb, m_hwndOwner, CFtpEidl::_PopulateItemCB, this, _punkSite, m_pff);
            if (SUCCEEDED(hr))
            {
                m_pfd->SetCache(m_pflHfpl);
                m_fInited = TRUE;
                hr = S_OK;
            }
            else
                IUnknown_Set(&m_pflHfpl, NULL);
        }
    }

    return hr;
}


/*****************************************************************************
 *    CFtpEidl::_NextOne
 *****************************************************************************/
LPITEMIDLIST CFtpEidl::_NextOne(DWORD * pdwIndex)
{
    LPITEMIDLIST pidl = NULL;
    LPITEMIDLIST pidlResult = NULL;

    if (m_pflHfpl)
    {
        while ((*pdwIndex < (DWORD) m_pflHfpl->GetCount()) && (pidl = m_pflHfpl->GetPidl(*pdwIndex)))
        {
            ASSERT(IsValidPIDL(pidl));
            (*pdwIndex)++;

            if (_fFilter(m_shcontf, FtpPidl_GetAttributes(pidl)))
            {
                pidlResult = ILClone(pidl);
                break;  // We don't need to search any more.
            }
        }
    }

    return pidlResult;
}


//===========================
// *** IEnumIDList Interface ***
//===========================

/*****************************************************************************
 *
 *    IEnumIDList::Next
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *
 *    OLE random documentation of the day:  IEnumXXX::Next.
 *
 *    rgelt - Receives an array of size celt (or larger).
 *
 *    "Receives an array"?  No, it doesn't receive an array.
 *    It *is* an array.  The array receives *elements*.
 *
 *    "Or larger"?  Does this mean I can return more than the caller
 *    asked for?  No, of course not, because the caller didn't allocate
 *    enough memory to hold that many return values.
 *
 *    No semantics are assigned to the possibility of celt = 0.
 *    Since I am a mathematician, I treat it as vacuous success.
 *
 *    pcelt is documented as an INOUT parameter, but no semantics
 *    are assigned to its input value.
 *
 *    The dox don't say that you are allowed to return *pcelt < celt
 *    for reasons other than "no more elements", but the shell does
 *    it everywhere, so maybe it's legal...
 *
 *****************************************************************************/
HRESULT CFtpEidl::Next(ULONG celt, LPITEMIDLIST * rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl = NULL;
    DWORD dwIndex;
    // The shell on pre-NT5 enums us w/o ole initialized which causes problems
    // when we call CoCreateInstance().  This happens in the thunking code
    // of encode.cpp when thunking strings.
    HRESULT hrOleInit = SHOleInitialize(0);

    if (pceltFetched)   // In case of failure.
    {
        *pceltFetched = 0;
    }

    if (m_fDead)
        return E_FAIL;

    if (!m_fInited)
    {
        hr = _Init();
        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            // Did we need to redirect because of a new password or username?
            if (HRESULT_FROM_WIN32(ERROR_NETWORK_ACCESS_DENIED) == hr)
            {
                m_fDead = TRUE;
                hr = E_FAIL;
            }
            else if (!m_fErrorDisplayed)
            {
                DisplayWininetError(m_hwndOwner, FALSE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_GETDIRLISTING, IDS_FTPERR_WININET, MB_OK, NULL);
                m_fErrorDisplayed = TRUE;
            }
        }
    }

    if (S_OK == hr)
    {
        // Do they want more and do we have more to give?
        for (dwIndex = 0; (dwIndex < celt) && (pidl = _NextOne(&m_nIndex)); dwIndex++)
            rgelt[dwIndex] = pidl;  // Yes, so give away...

        if (pceltFetched)
            *pceltFetched = dwIndex;

        // Were we able to give any?
        if (0 == dwIndex)
            hr = S_FALSE;
    }

    SHOleUninitialize(hrOleInit);
    return hr;
}


/*****************************************************************************
 *    IEnumIDList::Skip
 *****************************************************************************/

HRESULT CFtpEidl::Skip(ULONG celt)
{
    m_nIndex += celt;

    return S_OK;
}


/*****************************************************************************
 *    IEnumIDList::Reset
 *****************************************************************************/

HRESULT CFtpEidl::Reset(void)
{
    m_fErrorDisplayed = FALSE;
    if (!m_fInited)
        _Init();

    m_nIndex = 0;
    return S_OK;
}


/*****************************************************************************\
 *    IEnumIDList::Clone
 *
 *    Creates a brand new enumerator based on an existing one.
\*****************************************************************************/
HRESULT CFtpEidl::Clone(IEnumIDList **ppenum)
{
    return CFtpEidl_Create(m_pfd, m_pff, m_hwndOwner, m_shcontf, m_nIndex, ppenum);
}


/*****************************************************************************\
 *    CFtpEidl_Create
 *
 *    Creates a brand new enumerator based on an ftp site.
\*****************************************************************************/
HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum)
{
    CFtpEidl * pfe;
    HRESULT hres = CFtpEidl_Create(pfd, pff, hwndOwner, shcontf, &pfe);

    *ppenum = NULL;
    if (pfe)
    {
        hres = pfe->QueryInterface(IID_IEnumIDList, (LPVOID *) ppenum);
        pfe->Release();
    }

    return hres;
}


/*****************************************************************************
 *
 *    CFtpEidl_Create
 *
 *    Creates a brand new enumerator based on an ftp site.
 *
 *****************************************************************************/

HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, CFtpEidl ** ppfe)
{
    CFtpEidl * pfe = new CFtpEidl();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pfd && pff && ppfe);
    *ppfe = pfe;
    if (pfe)
    {
        ATOMICRELEASE(pfe->m_pm);
        pfe->m_pm = pff->GetIMalloc();

        IUnknown_Set(&pfe->m_pff, pff);
        IUnknown_Set(&pfe->m_pfd, pfd);
        pfe->m_pflHfpl = pfd->GetHfpl();

        pfe->m_shcontf = shcontf;
        pfe->m_hwndOwner = hwndOwner;

    }

    return hr;
}


/*****************************************************************************\
 *    CFtpEidl_Create
 *
 *    Creates a brand new enumerator based on an ftp site.
\*****************************************************************************/
HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, DWORD dwIndex, IEnumIDList ** ppenum)
{
    CFtpEidl * pfe;
    HRESULT hres = CFtpEidl_Create(pfd, pff, hwndOwner, shcontf, &pfe);

    if (SUCCEEDED(hres))
    {
        pfe->m_nIndex = dwIndex;

        hres = pfe->QueryInterface(IID_IEnumIDList, (LPVOID *) ppenum);
        ASSERT(SUCCEEDED(hres));

        pfe->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpEidl::CFtpEidl() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_fInited);
    ASSERT(!m_nIndex);
    ASSERT(!m_shcontf);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pfd);
    ASSERT(!m_pm);
    ASSERT(!m_hwndOwner);
    ASSERT(!m_fInited);
    ASSERT(!m_fDead);

    LEAK_ADDREF(LEAK_CFtpEidl);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpEidl::~CFtpEidl()
{
    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pm, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&m_pff, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpEidl);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpEidl::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpEidl::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpEidl::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumIDList))
    {
        *ppvObj = SAFECAST(this, IEnumIDList*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpEidl::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpgto.cpp ===
/*****************************************************************************
 *
 *    ftpgto.cpp - Global timeouts
 *
 *    Global timeouts are managed by a separate worker thread, whose job
 *    it is to hang around and perform delayed actions on request.
 *
 *    All requests are for FTP_SESSION_TIME_OUT milliseconds.  If nothing happens
 *    for an additional FTP_SESSION_TIME_OUT milliseconds, the worker thread is
 *    terminated.
 *
 *****************************************************************************/

#include "priv.h"
#include "util.h"

#define MS_PER_SECOND               1000
#define SECONDS_PER_MINUTE          60
#define FTP_SESSION_TIME_OUT        (10 * SECONDS_PER_MINUTE * MS_PER_SECOND)    // Survive 10 minutes in cache


BOOL g_fBackgroundThreadStarted; // Has the background thread started?
HANDLE g_hthWorker;             // Background worker thread
HANDLE g_hFlushDelayedActionsEvent = NULL; // Do we want to flush the delayed actions?

/*****************************************************************************
 *
 *    Global Timeout Info
 *
 *    We must allocate separate information to track timeouts.  Stashing
 *    the information into a buffer provided by the caller opens race
 *    conditions, if the caller frees the memory before we are ready.
 *
 *    dwTrigger is 0 if the timeout is being dispatched.  This avoids
 *    race conditions where one thread triggers a timeout manually
 *    while it is in progress.
 *
 *****************************************************************************/

struct GLOBALTIMEOUTINFO g_gti = { // Anchor of global timeout info list
    &g_gti,
    &g_gti,
    0, 0, 0
};



/*****************************************************************************
 *    TriggerDelayedAction
 *
 *    Unlink the node and dispatch the timeout procedure.
 *****************************************************************************/
void TriggerDelayedAction(LPGLOBALTIMEOUTINFO * phgti)
{
    LPGLOBALTIMEOUTINFO hgti = *phgti;

    *phgti = NULL;
    if (hgti)
    {
        ENTERCRITICAL;
        if (hgti->dwTrigger)
        {
            // Unlink the node
            hgti->hgtiPrev->hgtiNext = hgti->hgtiNext;
            hgti->hgtiNext->hgtiPrev = hgti->hgtiPrev;

            hgti->dwTrigger = 0;

            // Do the callback
            if (hgti->pfn)
                hgti->pfn(hgti->pvRef);
            LEAVECRITICAL;

            TraceMsg(TF_BKGD_THREAD, "TriggerDelayedAction(%#08lx) Freeing=%#08lx", phgti, hgti);
            DEBUG_CODE(memset(hgti, 0xFE, (UINT) LocalSize((HLOCAL)hgti)));

            LocalFree((LPVOID) hgti);
        }
        else
        {
            LEAVECRITICAL;
        }
    }
}


/*****************************************************************************
 *    FtpDelayedActionWorkerThread
 *
 *    This is the procedure that runs on the worker thread.  It waits
 *    for something to do, and if enough time elapses with nothing
 *    to do, it terminates.
 *
 *    Be extremely mindful of race conditions.  They are oft subtle
 *    and quick to anger.
 *****************************************************************************/
DWORD FtpDelayedActionWorkerThread(LPVOID pv)
{
    // Tell the caller we started so they can continue.
    g_fBackgroundThreadStarted = TRUE;
    for (;;) 
    {
        DWORD msWait;

        // Determine how long we need to wait.  The critical section
        // is necessary to ensure we don't collide with SetDelayedAction.
        ENTERCRITICAL;
        if (g_gti.hgtiNext == &g_gti)
        {
            // Queue is empty
            msWait = FTP_SESSION_TIME_OUT;
        }
        else
        {
            msWait = g_gti.hgtiNext->dwTrigger - GetTickCount();
        }
        LEAVECRITICAL;

        //  If a new delayed action gets added, no matter, because
        //  we will wake up from the sleep before the delayed action
        //  is due.
        ASSERTNONCRITICAL;
        if ((int)msWait > 0)
        {
            TraceMsg(TF_BKGD_THREAD, "FtpDelayedActionWorkerThread: Sleep(%d)", msWait);
            WaitForMultipleObjects(1, &g_hFlushDelayedActionsEvent, FALSE, msWait);
            TraceMsg(TF_BKGD_THREAD, "FtpDelayedActionWorkerThread: Sleep finished");
        }
        ENTERCRITICALNOASSERT;
        if ((g_gti.hgtiNext != &g_gti) && g_gti.hgtiNext && (g_gti.hgtiNext->phgtiOwner))
        {
            // Queue has work

            // RaymondC made a comment here that there is a race condition but I have never
            // been able to see it.  He made this comment years ago when he owned the code
            // and I've re-writen parts and ensured it's thread safe.  We never found any
            // stress problems so this is just a reminder that this code is very thread
            // sensitive.

            LEAVECRITICAL;
            TraceMsg(TF_BKGD_THREAD, "FtpDelayedActionWorkerThread: Dispatching");
            TriggerDelayedAction(g_gti.hgtiNext->phgtiOwner);
        }
        else
        {
            CloseHandle(InterlockedExchangePointer(&g_hthWorker, NULL));
            CloseHandle(InterlockedExchangePointer(&g_hFlushDelayedActionsEvent, NULL));
            LEAVECRITICALNOASSERT;
            TraceMsg(TF_BKGD_THREAD, "FtpDelayedActionWorkerThread: ExitThread");
            ExitThread(0);
        }
    }

    AssertMsg(0, TEXT("FtpDelayedActionWorkerThread() We should never get here or we are exiting the for loop incorrectly."));
    return 0;
}


/*****************************************************************************
 *    SetDelayedAction
 *
 *    If there is a previous action, it is triggered.  (Not cancelled.)
 *
 *    In principle, we could've allocated into a private pointer, then
 *    stuffed the pointer in at the last minute, avoiding the need to
 *    take the critical section so aggressively.  But that would tend
 *    to open race conditions in the callers.  So?  I should
 *    fix the bugs instead of hacking around them like this.
 *****************************************************************************/
STDMETHODIMP SetDelayedAction(DELAYEDACTIONPROC pfn, LPVOID pvRef, LPGLOBALTIMEOUTINFO * phgti)
{
    TriggerDelayedAction(phgti);
    ENTERCRITICAL;
    if (!g_hthWorker)
    {
        DWORD dwThid;

        g_hFlushDelayedActionsEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hFlushDelayedActionsEvent)
        {
            g_fBackgroundThreadStarted = FALSE;
            g_hthWorker = CreateThread(0, 0, FtpDelayedActionWorkerThread, 0, 0, &dwThid);
            if (g_hthWorker)
            {
                // We need to wait until the thread starts up
                // before we return. Otherwise, we may return to the
                // caller and they may free our COM object
                // which will unload our DLL.  The thread won't
                // start if we are in PROCESS_DLL_DETACH and we
                // spin waiting for them to start and stop.
                TraceMsg(TF_BKGD_THREAD, "SetDelayedAction: Thread created, waiting for it to start.");
                while (FALSE == g_fBackgroundThreadStarted)
                    Sleep(0);
                TraceMsg(TF_BKGD_THREAD, "SetDelayedAction: Thread started.");
            }
            else
            {
                CloseHandle(g_hFlushDelayedActionsEvent);
                g_hFlushDelayedActionsEvent = NULL;
            }
        }
    }

    if (g_hthWorker && EVAL(*phgti = (LPGLOBALTIMEOUTINFO) LocalAlloc(LPTR, sizeof(GLOBALTIMEOUTINFO))))
    {
        LPGLOBALTIMEOUTINFO hgti = *phgti;

        // Insert the node at the end (i.e., before the head)
        hgti->hgtiPrev = g_gti.hgtiPrev;
        g_gti.hgtiPrev->hgtiNext = hgti;

        g_gti.hgtiPrev = hgti;
        hgti->hgtiNext = &g_gti;

        // The "|1" ensures that dwTrigger is not zero
        hgti->dwTrigger = (GetTickCount() + FTP_SESSION_TIME_OUT) | 1;

        hgti->pfn = pfn;
        hgti->pvRef = pvRef;
        hgti->phgtiOwner = phgti;

        //  Note that there is no need to signal the worker thread that
        //  there is new work to do, because he will always wake up on
        //  his own before the requisite time has elapsed.
        //
        //  This optimization relies on the fact that the worker thread
        //  idle time is less than or equal to our delayed action time.
        LEAVECRITICAL;
    }
    else
    {
        // Unable to create worker thread or alloc memory
        LEAVECRITICAL;
    }
    return S_OK;
}


HRESULT PurgeDelayedActions(void)
{
    HRESULT hr = E_FAIL;

    if (g_hFlushDelayedActionsEvent)
    {
        LPGLOBALTIMEOUTINFO hgti = g_gti.hgtiNext;

        // We need to set all the times to zero so all waiting
        // items will not be delayed.
        ENTERCRITICAL;
        while (hgti != &g_gti)
        {
            hgti->dwTrigger = (GetTickCount() - 3);    // Don't Delay...
            hgti = hgti->hgtiNext;  // Next...
        }
        LEAVECRITICAL;

        if (SetEvent(g_hFlushDelayedActionsEvent))
        {
            // We can't be in a critical section or our background
            // thread can't come alive.
            ASSERTNONCRITICAL;

            TraceMsg(TF_BKGD_THREAD, "PurgeDelayedActions: Waiting for thread to stop.");
            // Now just wait for the thread to finish.  Someone may kill
            // the thread so let's make sure we don't keep sleeping
            // if the thread died.
            while (g_hthWorker && (WAIT_TIMEOUT == WaitForSingleObject(g_hthWorker, 0)))
                Sleep(0);

            TraceMsg(TF_BKGD_THREAD, "PurgeDelayedActions: Thread stopped.");
            // Sleep 0.1 seconds in order to give enough time for caller
            // to call CloseHandle(), LEAVECRITICAL, ExitThread(0).
            // I would much prefer to call WaitForSingleObject() on
            // the thread handle but I can't do that in PROCESS_DLL_DETACH.
            Sleep(100);
            hr = S_OK;
        }
    }

    return hr;
}


BOOL AreOutstandingDelayedActions(void)
{
    return (g_gti.hgtiNext != &g_gti);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpfoldr.cpp ===
/*****************************************************************************\
    FILE: ftpfoldr.h

    DESCRIPTION:
        This class inherits from CBaseFolder for a base ShellFolder implementation
    of IShellFolder and overrides methods to give Ftp Specific features.

     _UNDOCUMENTED_:  The shell violates Apartment model threading
     when doing background enumeration, so even though this DLL is
     marked as Apartment model, IShellFolder and IEnumIDList must
     be written with the free threading model with respect to anything
     that IEnumIDList can do in the background.
 
     This means that you'll see lots of ENTER_CRITICAL() and
     LEAVE_CRITICAL() calls when your brain would say, "I don't
     need to do that because I'm Apartment-model."  I'll try to
     point them out as they occur; look for the marker _MT_.
 
     CAUTION!  Internally, our property sheet handler also invokes
     methods on CFtpFolder on the wrong thread, so it's not just the
     shell that is weird.
\*****************************************************************************/

#include "priv.h"
#include "ftpfoldr.h"
#include "ftpurl.h"
#include "ftppidl.h"
#include "ftpicon.h"
#include "view.h"
#include "proxycache.h"
#include <idhidden.h>

#define FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY

// {A11501B3-6EA4-11d2-B679-006097DF5BD4}   Private to msieftp.dll
const GUID IID_CFtpFolder = { 0xa11501b3, 0x6ea4, 0x11d2, { 0xb6, 0x79, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };


/*****************************************************************************
 *
 *    More const statics.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

WORD c_wZero = 0;        /* As promised in ftpview.h */

/*
 *  String separator used when building relative names.
 */
char c_szSlash[] = "/";


#pragma END_CONST_DATA


HRESULT CFtpFolder::_AddToUrlHistory(LPCWSTR pwzUrl)
{
    HRESULT hr = S_OK;

    if (!m_puhs)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryStg, (void **)&m_puhs);
    }

    if (m_puhs)
    {
        hr = m_puhs->AddUrl(pwzUrl, pwzUrl, 0);
    }

    return hr;
}

/* Not yet needed
HRESULT CFtpFolder::AddToUrlHistory(LPCTSTR pszUrl)
{
    return _AddToUrlHistory(wzUrl);
}
*/

HRESULT CFtpFolder::AddToUrlHistory(LPCITEMIDLIST pidl)
{
    WCHAR wzUrl[MAX_URL_STRING];
    HRESULT hr = UrlCreateFromPidlW(pidl, SHGDN_FORPARSING, wzUrl, ARRAYSIZE(wzUrl), (ICU_ESCAPE | ICU_USERNAME), TRUE);

    if (EVAL(SUCCEEDED(hr)))
    {
        hr = _AddToUrlHistory(wzUrl);
    }

    return hr;
}


CWireEncoding * CFtpFolder::GetCWireEncoding(void)
{
    // GetFtpDir() may return NULL when we aren't rooted in an FTP server.
    CFtpDir * pfd = GetFtpDir();
    CWireEncoding * pwe = NULL;

    if (pfd)
    {
        pwe = pfd->GetFtpSite()->GetCWireEncoding();
        pfd->Release();
    }

    return pwe;
}

HRESULT CFtpFolder::_FixQuestionablePidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    // NOTE: In the future, we may want to hit the server to
    //   disambiguate this.
/*
    BOOL fIsDir = TRUE;
    LPCSTR pszName = FtpPidl_GetLastItemName(pidl);

    // Can we get the name?
    if (EVAL(pszName))
    {
        // Is the file extension non-NULL? (Meaning it exists)
        if ('\0' != *PathFindExtensionA(pszName))
            fIsDir = FALSE;     // Yes, so asume it's a file.
    }

    hr = FtpPidl_SetFileItemType((LPITEMIDLIST) pidl, fIsDir);
*/
    return hr;
}


BOOL CFtpFolder::_IsServerVMS(LPCITEMIDLIST pidl)
{
    BOOL fIsServerVMS = FALSE;    // Assume TRUE
    CFtpSite * pfs;

    // Some caller's don't pass the Server ID so let's assume
    // that they already made it past that point.
    if (FtpID_IsServerItemID(pidl) &&
        EVAL(SUCCEEDED(SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfs))))
    {
        fIsServerVMS = pfs->IsServerVMS();
        pfs->Release();
    }

    return fIsServerVMS;
}


/****************************************************\
    FUNCTION: _IsProxyBlockingSite

    DESCRIPTION:
        We need to detect if we cannot connect to the
    site because the proxy is a CERN or CERN type proxy
    that blocks ALL ftp access.  If this is true, we
    need to inform the user can fall all
    IShellFolder::BindToObject() calls.

        We will detect this case by doing the normal
    WININET FTP InternetConnect().  If that returns
    hr=0x80002EE7 (ERROR_INTERNET_NAME_NOT_RESOLVED)
    then it could either be that the name doesn't exist,
    or there is a CERN proxy blocking the call.  We will
    then try connect the CERN method which will tell us
    if it's the proxy that is blocking us.
\****************************************************/
BOOL CFtpFolder::_IsProxyBlockingSite(LPCITEMIDLIST pidl)
{
    BOOL fCacheResult;
    BOOL fResult = TRUE;    // Assume TRUE
    CFtpDir * pfd;

    if (ProxyCache_IsProxyBlocking(pidl, &fCacheResult))
        return fCacheResult;

    if (EVAL(pfd = GetFtpDirFromPidl(pidl)))
    {
        HRESULT hr = pfd->WithHint(NULL, NULL, NULL, NULL, NULL, this);

        // WithHint() often fails if a CERN style proxy blocks REAL wininet
        // access to the server.  If the server name is a DNS name, the error
        // returned will be ERROR_INTERNET_NAME_NOT_RESOLVED because that is
        // what is returned by the CERN proxy.  If the server name is an IP
        // Address, wininet will skip the CERN proxy and try to find it on the
        // intranet.  If not found (because it's past the firewall), then,
        // the attempt will timeout with ERROR_INTERNET_TIMEOUT.  We need
        // to treat this as a proxy block if and ONLY if the server name is an
        // IP address because DNS names can timeout for other reasons.  Us
        // treating IP server name timeouts as proxy blocks is going to have
        // to be tolerated because wininet won't handle this case.  It happens
        // very infrequently so I don't care that much.
        //
        // Some authentication proxies fail with: ERROR_INTERNET_CANNOT_CONNECT
        // We would like to fall back in that case, however, that may include
        // other cases like the server refusing to allow us in.
        // (password or too many logged in users?)
        // It would be great if ERROR_INTERNET_INVALID_PROXY_REQUEST or
        // ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP could be used.
        //
        if ((HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_CANNOT_CONNECT) == hr) ||
            ((HRESULT_FROM_WIN32(ERROR_INTERNET_TIMEOUT) == hr) && !FtpPidl_IsDNSServerName(pidl)))
        {
            TCHAR szUrl[MAX_URL_STRING];

            if (EVAL(SUCCEEDED(UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE | ICU_USERNAME, FALSE))))
            {
                HINTERNET hintTemp;
                ASSERT(GetWininetSessionHandle());

                // For Web Proxies, InternetOpenUrl should work.  The problem is that
                // some (Netscape's) don't work.
                if (SUCCEEDED(InternetOpenUrlWrap(GetWininetSessionHandle(), TRUE, szUrl, NULL, 0, INTERNET_FLAG_NO_UI, NULL, &hintTemp)))
                {
                    InternetCloseHandle(hintTemp);  // This did work, so we must have a CERN proxy.
                }
                else
                    fResult = FALSE;    // We aren't blocked by the proxy. (Wrong IP Addr or Name?)
            }
        }
        else
            fResult = FALSE;    // We aren't blocked by the proxy.

        // Cache the result since finding out is so expensive.
        ProxyCache_SetProxyBlocking(pidl, fResult);
        pfd->Release();
    }

    return fResult;
}


/*****************************************************************************
 *
 *    InvalidateCache
 *
 *    Invalidate the pflHfpl cache in the corresponding FtpDir.
 *
 *    _MT_:  Note that the background enumerator calls this, so it must be
 *    multithread-safe.
 *
 *****************************************************************************/

void CFtpFolder::InvalidateCache(void)
{
    CFtpDir * pfd = GetFtpDir();

    if (pfd)
    {
        // Should have created one on the GetHint()
        pfd->SetCache(0);
        pfd->Release();
    }
}


HRESULT CFtpFolder::_InitFtpSite(void)
{
    HRESULT hr = S_OK;

    if (!m_pfs)         // If we don't already got one...
    {
        ENTERCRITICAL;
        if (!m_pfs)            // Did it get created while we were waiting
        {
            if (EVAL(GetPrivatePidlReference()))
                hr = SiteCache_PidlLookup(GetPrivatePidlReference(), TRUE, m_pm, &m_pfs);
            else
            {
                // Not initialized
                TraceMsg(TF_FTPISF, "CFtpFolder_GetFtpDir(%08x) NOT INITED", this);
                hr = E_FAIL;
            }
        }

        LEAVECRITICAL;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFtpDir

    DESCRIPTION:
        Say where our dir info is.

    We allocate the pfd only if somebody actually needs it, because
    Explorer does a lot of ILCompare's when you open a new folder,
    each of which creates a new IShellFolder for the sole purpose
    of calling CompareIDs.  We don't want to go through all the
    hubbub of creating an FtpDir and FtpSite when we don't need one.

    _MT_:  Note that the background enumerator calls this, so it must be
    multithread-safe.  In such case, however, the IShellFolder is
    marked cBusy, so we don't have to worry about the this->pfd
    getting wiped out behind our back by a change of identity.
\*****************************************************************************/
CFtpDir * CFtpFolder::GetFtpDir(void)
{
    HRESULT hres = S_OK;
    CFtpDir * pfd = NULL;

    _InitFtpSite(); // Okay if it fails.
    if (m_pfs)
        hres = m_pfs->GetFtpDir(GetPrivatePidlReference(), &pfd);       // GetFtpDir can fail in out of memory

    return pfd;
}



CFtpDir * CFtpFolder::GetFtpDirFromPidl(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;
    CFtpDir * pfd = NULL;
    CFtpSite * pfs = NULL;

    hres = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfs);
    if (pfs)
    {
        hres = pfs->GetFtpDir(pidl, &pfd);
        pfs->Release();
    }

    return pfd;
}


/*****************************************************************************\
 *    GetItemAllocator
 *
 *    Return today's pidl allocator.
\*****************************************************************************/
HRESULT CFtpFolder::GetItemAllocator(IMalloc **ppm)
{
    HRESULT hr = E_FAIL;

    *ppm = NULL;
    if (EVAL(m_pm))
    {
        IUnknown_Set(ppm, m_pm);
        hr = S_OK;
    }
    else
        TraceMsg(TF_FTPISF, "CFtpFolder_GetItemAllocator(%08x) NOT INITED", this);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetUIObjectOfHfpl

    DESCRIPTION:
        _UNDOCUMENTED_:  Nowhere is there a list of interfaces
    that "should be" supported.  You just have to add lots of
    squirties and see what interfaces are asked for.

      _UNDOCUMENTED_:  Nowhere is it mentioned that passing
    cidl = 0 (or the various other weird variants) means to
    get a UI object on the folder itself.

    _UNDOCUMENTED_:  It is not mentioned whether the folder should
    be expected to handle cidl != 1 when asked for an IExtractIcon.
    I code defensively and handle the situation properly.

    IExtractIcon(0) extracts the icon for the folder itself.
    IExtractIcon(1) extracts the icon for the indicated pidl.
    IExtractIcon(n) extracts a generic "multi-document" icon.

    IContextMenu(0) produces a context menu for the folder itself.
        (Not used by the shell, but used by ourselves internally.)
    IContextMenu(n) produces a context menu for the multi-selection.

    IDataObject(0) ?? doesn't do anything
    IDataObject(n) produces a data object for the multi-selection.

    IDropTarget(0) produces a droptarget for the folder itself.
        (Not used by the shell, but used by ourselves internally.)
    IDropTarget(1) produces a droptarget for the single item.

    IShellView(0) ?? doesn't do anything
    IShellView(1) produces a shellview for the single item.
        (Nobody tries this yet, but I'm ready for it.)
\*****************************************************************************/
HRESULT CFtpFolder::GetUIObjectOfHfpl(HWND hwndOwner, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    HRESULT hr = E_INVALIDARG;

    if (IsEqualIID(riid, IID_IExtractIconA) ||
        IsEqualIID(riid, IID_IExtractIconW) ||
        IsEqualIID(riid, IID_IQueryInfo))
    {
        hr = CFtpIcon_Create(this, pflHfpl, riid, ppvObj);
        //TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOfHfpl() CFtpIcon_Create() hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CFtpMenu_Create(this, pflHfpl, hwndOwner, riid, ppvObj, fFromCreateViewObject);
        TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOfHfpl() CFtpMenu_Create() hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        hr = CFtpObj_Create(this, pflHfpl, riid, ppvObj);       // Can fail in out of memory.
        TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOfHfpl() CFtpObj_Create() hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        // This will fail when someone gets a property sheet on an FTP PIDL Shortcut
        // that has a file as the destination.
        hr = CreateSubViewObject(hwndOwner, pflHfpl, riid, ppvObj);
        TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOfHfpl() CreateSubViewObject() hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IShellView))
    {
        ASSERT(0);  // Shouldn't happen
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        IQueryAssociations * pqa;
        
        hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void **)&pqa);
        if (SUCCEEDED(hr))
        {
            hr = pqa->Init(0, L"Folder", NULL, NULL);

            if (SUCCEEDED(hr))
                *ppvObj = (void *)pqa;
            else
                pqa->Release();
        }
    }
    else
    {
        //TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOfHfpl() E_NOINTERFACE");
        hr = E_NOINTERFACE;
    }

    if (FAILED(hr))
        *ppvObj = NULL;

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


static const LPCTSTR pszBadAppArray[] = {TEXT("aol.exe"), TEXT("waol.exe"), TEXT("msnviewr.exe"), TEXT("cs3.exe"), TEXT("msdev.exe")};

/*****************************************************************************\
    FUNCTION: IsAppFTPCompatible

    DESCRIPTION:
        Some apps (WebOC hosts) fail to navigate to FTP directories.
    We check the app here and see if it's one of those incompatible apps.

    I don't worry about perf because we can do the work only once and cache
    the result because our globals will be re-inited for each process.

    GOOD:
    ========================================================================
    iexplore.exe:   Good of course.
    explorer.exe:   Good of course.
    msdev.exe (v6): The HTML help works but folder navigations happen in
                    a new window.  I don't care because the same happens in
                    the shell (File System case).
    <Default Case>: These are apps built with VB's WebOC that work fine, but
                    they also have the open in new folder behavior.

    BAD and UGLY:
    ========================================================================
    msdev.exe (v5): You can navigate their Moniker help to FTP which will
                    cause a hang.
    [MSN] (msnviewr.exe): For some reason MSN calls IPersistFolder::Initialize with an invalid value.
           Navigating to the folder works but launching other folders cause them
           to appear in their own window and they immediately close.  This was
           on browser only so it may be because internet delegate folders aren't
           supported.

    [aol]: (waol.exe) This doesn't work either.
    cs3.exe (CompuServ): ????
    [ATT WorldNet]: ????
    [Protigy]: ????
    [SNAP]: ????
\*****************************************************************************/
BOOL IsAppFTPCompatible(void)
{
    static BOOL s_fIsAppCompatible;
    static BOOL s_fIsResultCached = FALSE;

    if (!s_fIsResultCached)
    {
        TCHAR szAppPath[MAX_PATH];

        s_fIsAppCompatible = TRUE;  // Assume all Web OC Hosts are fine...

        if (EVAL(GetModuleFileName(NULL, szAppPath, ARRAYSIZE(szAppPath))))
        {
            int nIndex;
            LPTSTR pszAppFileName = PathFindFileName(szAppPath);

            // Default to TRUE because if it's not in the registry, then default to compatible.
            s_fIsAppCompatible = SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER_COMPAT, pszAppFileName, FALSE, TRUE);
            for (nIndex = 0; nIndex < ARRAYSIZE(pszBadAppArray); nIndex++)
            {
                if (!StrCmpI(pszAppFileName, pszBadAppArray[nIndex]))
                {
                    // Default to FALSE because if it's not in the registry, then it's incompatible because
                    // it's in our list.
                    s_fIsAppCompatible = SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER_COMPAT, pszAppFileName, FALSE, FALSE);
                    break;
                }
            }
        }

        s_fIsResultCached = TRUE;
    }

    return s_fIsAppCompatible;
}


/*****************************************************************************\
    FUNCTION: CreateSubViewObject

    DESCRIPTION:
        Somebody is asking for a UI object of a subobject, which is
    better handled by the subobject than by the parent.

    Bind to the subobject and get the requested UI object thence.

    If the pidl list is empty, then we are talking about ourselves again.
\*****************************************************************************/
HRESULT CFtpFolder::CreateSubViewObject(HWND hwndOwner, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwItemsSelected = pflHfpl->GetCount();
    IShellFolder * psf = NULL;

    if (EVAL(ppvObj))             // I wouldn't be surprised if
        *ppvObj = NULL;            // somebody relied on this

    if (1 == dwItemsSelected)
    {
        LPITEMIDLIST pidl = pflHfpl->GetPidl(0);    // This doesn't clone the pidl so we don't need to free it.
        if (pidl)
            hr = BindToObject(pidl, 0, IID_IShellFolder, (LPVOID *)&psf);
    }
    else if (EVAL(0 == dwItemsSelected))
        hr = this->QueryInterface(IID_IShellFolder, (void **) &psf);

    ASSERT_POINTER_MATCHES_HRESULT(psf, hr);
    if (SUCCEEDED(hr))
    {
        // CreateViewObject will AddRef the psfT if it wants it
        hr = psf->CreateViewObject(hwndOwner, riid, ppvObj);
    }
    
    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    ATOMICRELEASE(psf);
    return  hr;
}



/*****************************************************************************\
      GetSiteMotd
\*****************************************************************************/

CFtpGlob * CFtpFolder::GetSiteMotd(void)
{
    CFtpGlob * pGlob = NULL;

    _InitFtpSite(); // Okay if it fails.
    if (m_pfs)
        pGlob = m_pfs->GetMotd();

    return pGlob;
}


HRESULT CFtpFolder::_Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate)
{
    IUnknown_Set(&m_pfs, NULL);
    return CBaseFolder::_Initialize(pidlTarget, pidlRoot, nBytesToPrivate);
}


// Sometimes the user will enter incorrect information without knowing.
// We would catch this if we verified everything that was entered, but
// we don't, we just take it on faith until we do the IEnumIDList.
// This is great for perf but is bad for catching these kinds of things.
// An example of this is the user using the File.Open dialog and going to
// "ftp://myserver/dir/".  They then enter "ftp://myserver/dir/file.txt"
// which will try to parse relative but it's an absolute path.
HRESULT CFtpFolder::_FilterBadInput(LPCTSTR pszUrl, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    // If pidlPrivate isn't empty, then we aren't at the
    // root, so reject any urls that are absolute (i.e. have
    // ftp: scheme).
    if (!IsRoot() && (URL_SCHEME_FTP == GetUrlScheme(pszUrl)))
        hr = E_FAIL;
    // More may come here...

    if (FAILED(hr) && *ppidl)
        Pidl_Set(ppidl, NULL);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _ForPopulateAndEnum

    DESCRIPTION:
        This function exists to detect the following case and if it's true,
    populate the cache (pfd) and return the pidl from that cache in ppidl.

     There is one last thing we need to try, we need to detect if:
    1) the URL has an URL path, and 
    2) the last item in the path doesn't have an extension and doesn't
       end in a slash ('/') to indicate it's a directory.
    If this case is true, we then need to find out if it is a directory
    or file by hitting the server.  This is needed because by the time
    we bind, it's too late to fall back to the other thing (IEnumIDList).
    The one thing we might need to be careful about is AutoComplete because
    they may call :: ParseDisplayName() for every character a user types.
    This won't be so bad because it's on a background thread, asynch, and
    the first enum within a segment will cause the cache to be populated
    within a that segment so subsequent enums will be fast.  The problem
    it that it's not uncommon for users to enter between 2 and 5 segments,
    and there would be 1 enum per segment.
\*****************************************************************************/
HRESULT CFtpFolder::_ForPopulateAndEnum(CFtpDir * pfd, LPCITEMIDLIST pidlBaseDir, LPCTSTR pszUrl, LPCWIRESTR pwLastDir, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;

    *ppidl = NULL;
    // We only care if the URL Path isn't empty AND it doesn't end in a '/' AND
    // it doesn't have an extension.
    if (pfd && !ILIsEmpty(pfd->GetPathPidlReference()) && (!pwLastDir || (0 == *PathFindExtensionA(pwLastDir))))
    {
        IEnumIDList * penumIDList;

        // NULL hwnd needs to suppress all UI.
        hr = CFtpEidl_Create(pfd, this, NULL, (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN), &penumIDList);
        if (SUCCEEDED(hr))
        {
            hr = penumIDList->Reset();
            ASSERT(SUCCEEDED(hr));
            // We are working off of the assumption that calling Reset will force it to hit the server and pull down all of the contents.

            LPITEMIDLIST pidlFromCache = (LPITEMIDLIST) pfd->GetPidlFromWireName(pwLastDir);
            if (pidlFromCache)
            {
                // It was found, this means that it exists now in the cache after we
                // forced it to be populated.
                *ppidl = ILCombine(pidlBaseDir, pidlFromCache);
                ILFree(pidlFromCache);
            }
            else
                hr = E_FAIL;

            penumIDList->Release();
        }
    }

    return hr;
}


HRESULT CFtpFolder::_GetCachedPidlFromDisplayName(LPCTSTR pszDisplayName, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    if (ppidl)
    {
        CFtpDir * pfd = GetFtpDir();

        if (pfd)
        {
            // We may have a pointer but the cache may still be empty, as in case NT #353324
            CFtpPidlList * pfl = pfd->GetHfpl();
            if (pfl)
            {
                // Yes, so we will continue to use the cache.  Now let's get rid of that
                // temp pointer.
                pfl->Release();
            }
            else
            {
                // No we don't have it cashed, so pretend the pfd was returned NULL.
                pfd->Release();
                pfd = NULL;
            }
        }

        *ppidl = NULL;
        if (!pfd)
        {
            LPITEMIDLIST pidlBaseDir;

            hr = CreateFtpPidlFromUrl(pszDisplayName, GetCWireEncoding(), NULL, &pidlBaseDir, m_pm, FALSE);
            if (SUCCEEDED(hr))  // May fail because of AutoComplete.
            {
                // If it's not pointing to just a server, then we can enum the contents and
                // find out if it's is a file or directory.
                if (!ILIsEmpty(pidlBaseDir) && !FtpID_IsServerItemID(ILFindLastID(pidlBaseDir)))
                {
                    CFtpSite * pfs;
            
                    hr = SiteCache_PidlLookup(pidlBaseDir, TRUE, m_pm, &pfs);
                    if (SUCCEEDED(hr))
                    {
                        LPCWIRESTR pwLastDirName;

                        // If we are using a hidden password, then ::GetDisplayNameOf() hands out
                        // these "ftp://user@server/dir/" URLs and the password is hidden.  If
                        // :: ParseDisplayName() is given one of these URLs and we are currently in
                        // that server w/that user name, then :: ParseDisplayNameOf() needs to hand
                        // out a pidl with the correct hidden password cookie.
                        //
                        // Is pidlNav the same as GetPublicRootPidlReference() except pidlNav doesn't
                        // have a password.  The same means that the servers match, and the user names
                        // match.
                        EVAL(SUCCEEDED(pfs->UpdateHiddenPassword(pidlBaseDir)));

                        // This is sneaky because pwLastDirName will point into them itemID
                        // that will be removed.  The memory won't really be removed, it will
                        // just have the size set to zero.
                        pwLastDirName = FtpPidl_GetLastItemWireName(pidlBaseDir);

                        ILRemoveLastID(pidlBaseDir);
                        pfs->GetFtpDir(pidlBaseDir, &pfd);

                        if (pfd)
                        {
                            LPITEMIDLIST pidlFromCache = (LPITEMIDLIST) pfd->GetPidlFromWireName(pwLastDirName);
                            if (pidlFromCache)
                            {
                                // It was found, this means we were probably in ftp://serverX/Dir1/
                                // and the user entered something from that directory or another directory
                                // taht we have alread displayed to the user and it's in our cache.
                                *ppidl = ILCombine(pidlBaseDir, pidlFromCache);
                                ILFree(pidlFromCache);
                                hr = S_OK;
                            }
                            else
                            {
                                // There is one last thing we need to try, we need to detect if:
                                // 1) the URL has an URL path, and 
                                // 2) the last item in the path doesn't have an extension and doesn't
                                //    end in a slash ('/') to indicate it's a directory.
                                // If this case is true, we then need to find out if it is a directory
                                // or file by hitting the server.  This is needed because by the time
                                // we bind, it's too late to fall back to the other thing (IEnumIDList).
                                // The one thing we might need to be careful about is AutoComplete because
                                // they may call :: ParseDisplayName() for every character a user types.
                                // This won't be so bad because it's on a background thread, asynch, and
                                // the first enum within a segment will cause the cache to be populated
                                // within a that segment so subsequent enums will be fast.  The problem
                                // it that it's not uncommon for users to enter between 2 and 5 segments,
                                // and there would be 1 enum per segment.
                                hr = _ForPopulateAndEnum(pfd, pidlBaseDir, pszDisplayName, pwLastDirName, ppidl);
                            }


                            pfd->Release();
                        }
                        else
                            hr = E_FAIL;

                        pfs->Release();
                    }
                    else
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;

                ILFree(pidlBaseDir);
            }
        }
        else
        {
            //    Create a new enumeration object for the caller.
            // PERF: log 2 (sizeof(m_pflHfpl))
            *ppidl = (LPITEMIDLIST) pfd->GetPidlFromDisplayName(pszDisplayName);
            if (*ppidl)
            {
                hr = S_OK;
            }
            else
            {
                // If we got here, the cache for this directory is populated.
                // So if the name doesn't match, then either:
                // 1) it doesn't exist,
                // 2) the cache is out of date, or
                // 3) it's multilevel, (like "dir1\dir2\dir3") or
                // 4) It's a weird parsing token that our parent parse should have remoted, like "..", ".", "\", etc.
                // We will assome our parent parse takes care of #4, and #2 isn't true.

                // Is this multilevel? (Case #3)
                if (!StrChr(pszDisplayName, TEXT('/')))
                {
                    // No, so reject it and don't let our caller blindly accept it.
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }

            pfd->Release();
        }
    }

    return hr;
}


HRESULT CFtpFolder::_GetBindCtx(IBindCtx ** ppbc)
{
    HRESULT hr = CreateBindCtx(NULL, ppbc);

    if (SUCCEEDED(hr))	// Can fail with out of memory
    {
        hr = (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellIcon *));    // We want IUnknown, not IShellIcon, but this is to disambigiuate.
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }

    return hr;
}


HRESULT CFtpFolder::_GetLegacyURL(LPCITEMIDLIST pidl, IBindCtx * pbc, LPTSTR pszUrl, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlWithVRoot;

    // We now need to insert the virtual root path into the path section
    // of the URL because the old FTP support doesn't follow the correct
    // FTP URL spec that says that the virtual root needs to be left out
    // of the URL.
    hr = _ConvertPidlForRootedFix(pidl, &pidlWithVRoot);
    if (SUCCEEDED(hr))
    {
        WCHAR wzFrag[MAX_PATH];

        // SECURITY ISSUE: We need to get the URL w/password or it won't work, but
        //                 this will expose the password publicly.  We need a way for
        //                 the real FTP URL Pidl to hide the password.
        hr = UrlCreateFromPidlW(pidlWithVRoot, SHGDN_FORPARSING, pszUrl, cchSize, (ICU_ESCAPE | ICU_USERNAME), FALSE);
        if (ILGetHiddenStringW(pidl, IDLHID_URLFRAGMENT, wzFrag, ARRAYSIZE(wzFrag)))  // Add fragment if it exists.
            UrlCombineW(pszUrl, wzFrag, pszUrl, &cchSize, 0);

        ILFree(pidlWithVRoot);
    }

    return hr;
}


HRESULT CFtpFolder::_GetLegacyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlLegacy)
{
    IBindCtx * pbc = NULL;
    HRESULT hr = _GetBindCtx(&pbc);

    *ppidlLegacy = NULL;
    if (SUCCEEDED(hr))   // Can fail with out of memory.
    {
        WCHAR wzUrl[MAX_URL_STRING];

        hr = _GetLegacyURL(pidl, pbc, wzUrl, ARRAYSIZE(wzUrl));
        if (EVAL(SUCCEEDED(hr)))
        {
            TraceMsg(TF_FTPISF, "_BindToObject_OriginalFtpSupport() navigating to=%ls", wzUrl);
            hr = IEParseDisplayNameWithBCW(CP_ACP, wzUrl, pbc, ppidlLegacy);
        }

        pbc->Release();
    }

    return hr;
}


HRESULT CFtpFolder::_InitLegacyShellFolder(IShellFolder * psfLegacy, LPCITEMIDLIST pidlInit)
{
    IPersistFolder * ppf;
    HRESULT hr = psfLegacy->QueryInterface(IID_IPersistFolder, (void **) &ppf);

    if (SUCCEEDED(hr))
    {
        hr = ppf->Initialize(pidlInit);
        ppf->Release();
    }

    return hr;
}


HRESULT CFtpFolder::_INetBindToObject(LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;

    LPITEMIDLIST pidlFirst = GetPublicPidlRootIDClone();
    if (pidlFirst)
    {
        IShellFolder * psfInternetSF;

        hr = IEBindToObject(pidlFirst, &psfInternetSF);
        if (SUCCEEDED(hr))
        {
            hr = _InitLegacyShellFolder(psfInternetSF, pidlFirst);
            if (SUCCEEDED(hr))
            {
                // Note the I use ILNext() in order to skip past the Desktop ItemID,
                // which is internal knowledge I should not have.
                hr = psfInternetSF->BindToObject(_ILNext(pidl), pbc, riid, ppvObj);
            }

            psfInternetSF->Release();
        }

        ILFree(pidlFirst);
    }

    return hr;
}



HRESULT CFtpFolder::_BindToObject_OriginalFtpSupport(LPCITEMIDLIST pidl, REFIID riid, LPVOID * ppvObj)
{
    LPBC pbc = NULL;
    HRESULT hr = CreateBindCtx(NULL, &pbc);
    
    if (SUCCEEDED(hr))
    {
        hr = pbc->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellIcon *));    // We want IUnknown, not IShellIcon, but this is to disambigiuate.
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlLegacy;

            hr = _GetLegacyPidl(pidl, &pidlLegacy);
            if (SUCCEEDED(hr))
            {
                hr = _INetBindToObject(pidlLegacy, pbc, riid, ppvObj);
                ILFree(pidlLegacy);
            }
        }

        pbc->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION:   _IsValidPidlParameter

    DESCRIPTION:
        If this IShellFolder is rooted within our name space, then the pidl needs
    to be a valid relative pidl.  If we are rooted at the base of our name space,
    then it needs to be a full pidl.
\*****************************************************************************/
BOOL CFtpFolder::_IsValidPidlParameter(LPCITEMIDLIST pidl)
{
    BOOL fResult = TRUE;

    if (IsRoot())
        fResult = FtpPidl_IsValidFull(pidl);
    else
        fResult = FtpPidl_IsValidRelative(pidl);

    return fResult;
}

/*****************************************************************************\
    FUNCTION: IShellFolder::_BindToObject

    DESCRIPTION:
        We are now sure that we want to handle the support, so check what they
    want.
\*****************************************************************************/
HRESULT CFtpFolder::_BindToObject(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlFull, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate we want the old functionality to kick in.

    if (IsEqualIID(riid, IID_IShellFolder) ||
        IsEqualIID(riid, IID_IShellFolder2) ||
        IsEqualIID(riid, IID_IBrowserFrameOptions))
    {
        LPITEMIDLIST pidlTarget = ILCombine(GetPublicTargetPidlReference(), pidl);
        LPITEMIDLIST pidlRoot = (GetFolderPidl() ? ILCombine(GetFolderPidl(), pidl) : NULL);

        //  There's no point trying to verify that it's folders all
        //  the way down, because it's the caller's job not to combine
        //  pidls randomly.  Furthermore, they might not actually be marked
        //  as folders if we got them via ParseDisplayName.

        // NOTE: Binding will succeed even if the pidl isn't valid on the
        //       server.  In the future we may want to verify now so we
        //       don't hand out a IEnumIDList that won't work.  Currently,
        //       IEnumIDList will fail and cause a renavigation if it can
        //       connect to the server in a different way (different username
        //       password pair).  It would be better to do a redirect because
        //       the renavigation causes the bad entry in the navigation stack.
        //       We can't verify the item exists on the server if we have a WebProxy
        //       installed.

        hr = CFtpFolder_Create(pidlTarget, pidlRoot, GetPidlByteOffset(), riid, ppvObj);
        //TraceMsg(TF_FOLDER_SHRTCUTS, "CFtpFolder::_BindToObject() creating an FTP IShellFolder psf=%#08lx, pidlTarget=%#08lx, pidlRoot=%#08lx", *ppvObj, pidlTarget, pidlRoot);
        if (SUCCEEDED(hr))
        {
            IUnknown * punk = (IUnknown *) *ppvObj;
            IDelegateFolder * pdf;

            hr = punk->QueryInterface(IID_IDelegateFolder, (LPVOID *) &pdf);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = pdf->SetItemAlloc(m_pm);
                pdf->Release();
            }
        }

        ILFree(pidlTarget);
        ILFree(pidlRoot);
        //TraceMsg(TF_FTPISF, "CFtpFolder::BindToObject() IID_IShellFolder hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IMoniker))
    {
        hr = _PidlToMoniker(pidlFull, (IMoniker **) ppvObj);
    }
    else if (IsEqualIID(riid, IID_IStream))
    {
        hr = E_OUTOFMEMORY;
        
        CFtpDir * pfd = GetFtpDir();
        if (pfd)
        {
            DWORD dwAccess = (BindCtx_GetMode(pbc, STGM_READ) & STGM_WRITE) ? GENERIC_WRITE : GENERIC_READ;
            ULARGE_INTEGER uliTemp = {0};

            hr = CFtpStm_Create(pfd, pidlFull, dwAccess, (IStream **)ppvObj, uliTemp, uliTemp, NULL, FALSE);

            pfd->Release();
        }
    }
    else if (IsEqualIID(riid, IID_CFtpFolder))
    {
        IShellFolder * psf;

        // Nothing like a little recursion to keep the code clean.
        // The fact that we use IID_IShellFolder guarantees the breaking
        // of the recursion.
        hr = BindToObject(pidl, pbc, IID_IShellFolder, (void **) &psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->QueryInterface(riid, ppvObj);
            psf->Release();
        }
    }
    else
    {
        TraceMsg(TF_FTPISF, "CFtpFolder::BindToObject() unsupported interface hr=E_NOINTERFACE");
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: _ConvertPidlForRootedFix
 
    DESCRIPTION:
        If an FTP URL has a login name, that login may root the user under a directory other than "/".
    The FTP URL spec (RFC 1738) says that URL paths need to be relative to the rooted directory.  For example:
    If UserA's rooted account is in \usr\GroupA\UserA and the url is:
    ftp://UserA:FooBar@server/test/file.txt, then the real path is \usr\GroupA\UserA\test\file.txt.
    The problem is that the old FTP code doesn't respect this and requires:
    ftp://UserA:FooBar@server/usr/GroupA/UserA/test/file.txt, so we fix that here.
 
    PARAMETERS:
        pidlBefore [IN]: This will be a public pidl to the item to navigate to.
            This means it will be: [TheINet][FtpServerID][...]
        *ppidlWithVRoot [OUT]: This will be the same public pidl that was passed in except
            any ItemIDs that come from pfs->GetVirtualRootReference() will be inserted
            between the ServerID and ItemIDs.
\*****************************************************************************/
HRESULT CFtpFolder::_ConvertPidlForRootedFix(LPCITEMIDLIST pidlBefore, LPITEMIDLIST * ppidlWithVRoot)
{
    CFtpSite * pfs;
    HRESULT hr = SiteCache_PidlLookup(pidlBefore, FALSE, m_pm, &pfs);

    *ppidlWithVRoot = NULL;
    if (SUCCEEDED(hr) && pfs)
    {
        if (pfs->HasVirtualRoot())
        {
            LPCITEMIDLIST pidlVirtualRoot = pfs->GetVirtualRootReference();
            LPITEMIDLIST pidlUrlPath = (LPITEMIDLIST)pidlBefore;

            // Skip past non-FTP Server/ItemIDs. (TheInternet)
            while (pidlUrlPath && !ILIsEmpty(pidlUrlPath) && !FtpID_IsServerItemID(pidlUrlPath))
                pidlUrlPath = _ILNext(pidlUrlPath);

            if (FtpID_IsServerItemID(pidlUrlPath))
                pidlUrlPath = _ILNext(pidlUrlPath);

            if (EVAL(pidlUrlPath))
            {
                LPITEMIDLIST pidlFullWithVRoot;
                USHORT cb = pidlUrlPath->mkid.cb;

                pidlUrlPath->mkid.cb = 0;
                pidlFullWithVRoot = ILCombine(pidlBefore, pidlVirtualRoot);
                pidlUrlPath->mkid.cb = cb;

                if (pidlFullWithVRoot)
                {
                    FtpPidl_InsertVirtualRoot(pidlFullWithVRoot, pidlUrlPath, ppidlWithVRoot);
                    ILFree(pidlFullWithVRoot);
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;

        pfs->Release();
    }

    if (FAILED(hr))
    {
        *ppidlWithVRoot = ILClone(pidlBefore);
        if (*ppidlWithVRoot)
            hr = S_OK;
    }

    return hr;
}


BOOL CFtpFolder::IsUTF8Supported(void)
{
    if (EVAL(m_pfs))
        return m_pfs->IsUTF8Supported();

    return FALSE;
}

/*****************************************************************************\
     FUNCTION: IShellFolder::_PidlToMoniker
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpFolder::_PidlToMoniker(LPCITEMIDLIST pidl, IMoniker ** ppmk)
{
    HRESULT hr = E_INVALIDARG;

    *ppmk = NULL;
    if (EVAL(pidl))
    {
        IBindCtx * pbc;

        hr = _GetBindCtx(&pbc);
        if (SUCCEEDED(hr))
        {
            WCHAR wzUrl[MAX_URL_STRING];

            // URLMON expects incorrectly formatted URLs (where the virtual
            //        root is included in the url path).  We need to fix that
            //        here.
            hr = _GetLegacyURL(pidl, pbc, wzUrl, ARRAYSIZE(wzUrl));
            if (SUCCEEDED(hr))
            {
                hr = CreateURLMoniker(NULL, wzUrl, ppmk);
            }

            pbc->Release();
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppmk, hr);
    return hr;
}


HRESULT CFtpFolder::_CreateShellView(HWND hwndOwner, void ** ppvObj)
{
    IShellFolderViewCB * psfvCallBack;

    HRESULT hr = CFtpView_Create(this, hwndOwner, IID_IShellFolderViewCB, (LPVOID *) &psfvCallBack);
    if (SUCCEEDED(hr))
    {
        // GetPublicTargetPidlReference() is used because it's passed to SFVM_GETNOTIFY
        // to synch ChangeNotify messages.
        hr = CBaseFolder::_CreateShellView(hwndOwner, ppvObj, FTP_SHCNE_EVENTS, 
                        FVM_DETAILS, psfvCallBack, GetPublicTargetPidlReference(), CBaseFolderViewCB::_IShellFolderViewCallBack);
        psfvCallBack->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}

HKEY ClassKeyFromExtension(LPCWIRESTR pszExt)
{
    HKEY hkey = NULL;
    WIRECHAR szProgID[MAX_PATH];
    DWORD cbProgID = sizeof(szProgID);

    if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, (void *)szProgID, &cbProgID))
    {
        // the entension points to a ProgID, use that.
        RegOpenKeyA(HKEY_CLASSES_ROOT, szProgID, &hkey);
    }
    else
    {
        // No ProgID, use the extension as the program ID.
        RegOpenKeyA(HKEY_CLASSES_ROOT, pszExt, &hkey);
    }

    return hkey;
}

#define SZ_REGVALUE_DOCOBJECT            TEXT("DocObject")
#define SZ_REGVALUE_BROWSEINPLACE        TEXT("BrowseInPlace")

BOOL _IsDocObjViewerInstalled(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    // Return FALSE if it's just pointing to an FTP server.
    if (!FtpID_IsServerItemID(ILFindLastID(pidl)))
    {
        LPCWIRESTR pwWireFileName = FtpPidl_GetLastItemWireName(pidl);
        LPCWIRESTR pszExt = PathFindExtensionA(pwWireFileName);

        if (pszExt)
        {
            HKEY hkey = ClassKeyFromExtension(pszExt);
            if (hkey)
            {
                if ((ERROR_SUCCESS == RegQueryValue(hkey, SZ_REGVALUE_DOCOBJECT, 0, NULL)) ||
                    (ERROR_SUCCESS == RegQueryValue(hkey, SZ_REGVALUE_BROWSEINPLACE, 0, NULL)))
                {
                    fResult = TRUE;
                }

                RegCloseKey(hkey);
            }
        }
    }

    return fResult;
}


ULONG FtpGetAttributesOf(LPCITEMIDLIST pidl)
{
    ASSERT(IsValidPIDL(pidl));

    DWORD dwAttributes = FtpPidl_GetAttributes(pidl);   // Get File based attributes.
    ULONG rgfInOut = Misc_SfgaoFromFileAttributes(dwAttributes); // Turn them into IShellFolder attributes.
    return rgfInOut;
}





//===========================
// *** IShellFolder2 Interface ***
//===========================

STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb)
{
    HRESULT hres;
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, cb);   // create a one-dimensional safe array
    if (psa) 
    {
        memcpy(psa->pvData, pv, cb);

        memset(pvar, 0, sizeof(*pvar));  // VariantInit()
        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}


/*****************************************************************************\
    FUNCTION: IShellFolder2::GetDetailsEx

    DESCRIPTION:
        This function will be called when the caller wants detailed info about
    and item.  SHGetDataFromIDList() is one such caller and that is commonly
    called by the Shell Object model when using CSDFldrItem::get_Size(LONG *pul)
    and other such APIs.
\*****************************************************************************/
HRESULT CFtpFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (IsEqualGUID(pscid->fmtid, FMTID_ShellDetails) && (PID_FINDDATA == pscid->pid))
    {
        WIN32_FIND_DATAW wfd;

        // I can handle this.
        LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);

        if (pidlFull)
        {
            hr = Win32FindDataFromPidl(pidlFull, &wfd, TRUE, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromBuffer(pv, (PVOID)&wfd, sizeof(wfd));
            }
            ILFree(pidlFull);
        }
    }
    else
    {
        hr = CBaseFolder::GetDetailsEx(pidl, pscid, pv);
    }

    return hr;
}



//===========================
// *** IShellFolder Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IShellFolder:: ParseDisplayName

    DESCRIPTION:
        The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    For now, we disallow backslash, "*" and "?" from filenames.
    Backslashes don't sit well with wininet, and wildcards
    mess up the "quick FindFirst to see if the file exists".

    We also disallow encoded slashes, because they mess up the way
    we manage subpidls.

    Annoying feature: You can't pass -1 as the output buffer size.
    NLS returns ERROR_INVALID_PARAMETER if you try.  So you have to pass
    the actual size.  Sigh.
\*****************************************************************************/
HRESULT CFtpFolder::ParseDisplayName(HWND hwnd, LPBC pbcReserved, LPOLESTR pwszDisplayName,
                        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = S_OK;

    *ppidl = NULL;
    if (pchEaten)
        *pchEaten = 0;

    // PERF: log 2 (sizeof(m_pflHfpl))
    hr = _GetCachedPidlFromDisplayName(pwszDisplayName, ppidl); 
    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr))
    {
        // Are we are rooted within an FTP Server?
        if (IsRoot())
        {
            // No, so parse the entire thing

            // There is only one case where we want to hide the password,
            // and that is when the user entered it into the "Login"
            // dialog.  Since we entering it into the dialog will cause a
            // redirect to an URL with that password in it, we need to determie
            // if we are being called during this redirect.  If so,
            // the password just came from the Login dialog and we need to hide it.

            // This will work for fully qualified Ftp URLs
            hr = CreateFtpPidlFromUrl(pwszDisplayName, GetCWireEncoding(), pchEaten, ppidl, m_pm, FALSE);
            if (SUCCEEDED(hr))
            {
                CFtpSite * pfs;

                hr = SiteCache_PidlLookup(*ppidl, TRUE, m_pm, &pfs);
                if (SUCCEEDED(hr))
                {
                    // If we are using a hidden password, then ::GetDisplayNameOf() hands out
                    // these "ftp://user@server/dir/" URLs and the password is hidden.  If
                    // ::ParseDisplayName() is given one of these URLs and we are currently in
                    // that server w/that user name, then ::ParseDisplayNameOf() needs to hand
                    // out a pidl with the correct hidden password cookie.
                    //
                    // Is pidlNav the same as GetPublicPidlReference() except pidlNav doesn't
                    // have a password.  The same means that the servers match, and the user names
                    // match.
                    EVAL(SUCCEEDED(pfs->UpdateHiddenPassword(*ppidl)));
                    pfs->Release();
                }
            }
        }
        else
        {
            // Yes, so do a relative parse

            // Sometimes the user will enter incorrect information without knowing.
            // We would catch this if we verified everything that was entered, but
            // we don't, we just take it on faith until we do the IEnumIDList.
            // This is great for perf but is bad for catching these kinds of things.
            // An example of this is the user using the File.Open dialog and going to
            // "ftp://myserver/dir/".  They then enter "ftp://myserver/dir/file.txt"
            // which will try to parse relative but it's an absolute path.
            hr = _FilterBadInput(pwszDisplayName, ppidl);
            if (SUCCEEDED(hr))
            {
                CFtpDir * pfd = GetFtpDir();
                if (pfd)
                    hr = CreateFtpPidlFromDisplayPath(pwszDisplayName, pfd->GetFtpSite()->GetCWireEncoding(), pchEaten, ppidl, FALSE, FALSE);
                else
                    hr = E_OUTOFMEMORY;

                pfd->Release();
            }
        }
    }

    if (SUCCEEDED(hr) && pdwAttributes)
    {
        hr = GetAttributesOf(1, (LPCITEMIDLIST *) ppidl, pdwAttributes);
        if (FAILED(hr))
            ILFree(*ppidl);
    }

#ifdef DEBUG
    TCHAR szUrlDebug[MAX_URL_STRING];
    
    szUrlDebug[0] = 0;
    if (*ppidl)
        UrlCreateFromPidl(*ppidl, SHGDN_FORPARSING, szUrlDebug, ARRAYSIZE(szUrlDebug), ICU_USERNAME, FALSE);

    TraceMsg(TF_FTPISF, "CFtpFolder::ParseDisplayName(%ls) CreateFtpPidlFromUrl() returned hres=%#08lx %ls", pwszDisplayName, hr, szUrlDebug);
    ASSERT(FAILED(hr) || IsValidPIDL(*ppidl));
#endif // DEBUG

    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);
    return hr;
}

IMalloc * CFtpFolder::GetIMalloc(void)
{
    IMalloc * pm = NULL;

    IUnknown_Set(&pm, m_pm);
    ASSERT(pm);
    return pm;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::EnumObjects

    DESCRIPTION:
        Design subtlety: If we couldn't create an enumeration on the server,
    succeed, but return an enumerator that shows no objects.

    This is necessary so that our IShellView callback can put
    up error UI.  If we failed the create, the shell would
    destroy the view without giving us a chance to say what's
    up.

    It's also important for write-only directories like /incoming,
    so that the user can drag files into the directory without
    necessarily being able to drag files out.
\*****************************************************************************/
HRESULT CFtpFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList)
{
    HRESULT hres = E_FAIL;
    CFtpDir * pfd = GetFtpDir();

    // This will happen if some TARD tries to just CoCreateInstance our
    // Name Space extension and see what contents we have.  TweakUI
    // is an example of one such abuser.  Since we can only populate
    // our contents after we navigate to a FTP server, we are empty.
    *ppenumIDList = NULL;
    if (pfd)
    {
        //    Create a new enumeration object for the caller.
        ASSERT(m_pm);
        hres = CFtpEidl_Create(pfd, this, hwndOwner, grfFlags, ppenumIDList);
        TraceMsg(TF_FTPISF, "CFtpFolder::EnumObjects() CFtpEidl_Create() returned hres=%#08lx", hres);

        pfd->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppenumIDList, hres);
    return hres;
}


BOOL CFtpFolder::_NeedToFallBackRelative(LPCITEMIDLIST pidl, BOOL * pfDisplayProxyFallBackDlg)
{
    LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);
    BOOL fFallBack = FALSE;

    if (pidlFull)
    {
        fFallBack = _NeedToFallBack(pidl, pfDisplayProxyFallBackDlg);
        ILFree(pidlFull);
    }

    return fFallBack;
}



/*****************************************************************************\
    FUNCTION: _NeedToFallBack

    DESCRIPTION:
        We need to fall back to the old URLMON support in these cases:
    #1 It's a file, we let the old code use URLMON to do the download.
    #2 The app (WebOC host) has bugs that cause us to fail.
    #3 The user turned off the New FTP UI. (For whatever reason)
    #4 The proxy is a web proxy and allows URLMON but not WININET access,
       so fall back to the old support.
    #5 WININET doesn't support VMS servers, so we need to fall back in that case.

    NOTE: The order is important because we always need to calc
          fIsProxyBlockingFTP so we only display the fallback dlg
          in the correct case.
\*****************************************************************************/
BOOL CFtpFolder::_NeedToFallBack(LPCITEMIDLIST pidlFull, BOOL * pfDisplayProxyFallBackDlg)
{
    BOOL fNeedToFallBack = TRUE;

    *pfDisplayProxyFallBackDlg = FALSE;

    // TweakUI sends us an Empty pidls so don't fault. NT #396234.
    if (pidlFull && !ILIsEmpty(pidlFull))
    {
        BOOL fIsDirectory;

        if (IsFtpPidlQuestionable(pidlFull))
            _FixQuestionablePidl(pidlFull);

        fIsDirectory = (!FtpPidl_HasPath(pidlFull) || FtpPidl_IsDirectory(pidlFull, FALSE));
        if (fIsDirectory)       // #1
        {
            if (IsAppFTPCompatible())   // #2
            {
                if (!SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER, SZ_REGKEY_USE_OLD_UI, FALSE, FALSE)) // #3
                {
                    // The binding code passes us a bind context and that would be a good
                    // key to determine if were are about to navigate to the site.  The
                    // problem is that we can't skip the proxy checking because we will
                    // fail later.
                    //
                    // #224285 is an example where navigating from ftp://ftp.microsoft.com/ to
                    // "www.microsoft.com" will cause CShellUrl to call :: BindToObject and then
                    // our IEnumIDList::Next() which will give an error message.
                    //
                    // Are we unable to get access to the server because there is
                    // a CERN type proxy blocking us?
                    // PERF: Only check for the proxy if we have a bind context because
                    //       the only place we are called from to navigate is
                    //       CDocObjectFolder:: BindToObject() and we are guaranteed that they
                    //       pass it to us.
                    if (!_IsProxyBlockingSite(pidlFull))   // #4
                    {
                        // Is this a VMS Server? If yes, fallback
                        // to URLMON support because wininet doesn't work with this kind of server.
                        if (!_IsServerVMS(pidlFull))
                        {
                            // Only continue if the user didn't turn the new UI Off.
                            fNeedToFallBack = FALSE;
                        }
                    }
                    else
                        *pfDisplayProxyFallBackDlg = TRUE;
                }
            }
        }
    }

    return fNeedToFallBack;
}


/*****************************************************************************\
    FUNCTION: IShellFolder:: BindToObject

    DESCRIPTION:
        First thing we need to do, is see if we want to over ride the default
    IE FTP support.  If we do, we call otherwise, we just fallback to the old
    support.  We want the new UI if: a) it's a directory, b) the web proxy doesn't
    block us, and c) the user didn't turn us off.

    PERF/TODO:
        OrderItem_GetSystemImageListIndexFromCache (\shell\lib\dpastuff.cpp)
    uses riid=IShellFolder when trying to find out the icon.  We don't want
    to hit the net in that case, so force them to pass a pbc to indicate skipping
    the net in that case.
\*****************************************************************************/
HRESULT CFtpFolder::BindToObject(LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate we want the old functionality to kick in.

    if (ppvObj)
        *ppvObj = NULL;

    if (!pidl || ILIsEmpty(pidl) || !_IsValidPidlParameter(pidl))
    {
        // Caller, are you smoking crack?  What's the idea of passing
        // an empty pidl. (Comdlg32 is known to do this)
        hr = E_INVALIDARG;
    }
    else
    {
        BOOL fDisplayProxyFallBackDlg = FALSE;
        LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);

        if (pidlFull)
        {
            // We need to handle it.
            hr = _BindToObject(pidl, pidlFull, pbc, riid, ppvObj);

            // Maybe we still need to handle it if 
            ASSERT(HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr);
            ILFree(pidlFull);
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::BindToStorage
 
    DESCRIPTION:
         We need to implement this so the user can Open and Save files in
    the standard Open Dialog and Save Dialog.
\*****************************************************************************/
HRESULT CFtpFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    *ppvObj = 0;
    if (EVAL(pidl))
    {
        IMoniker * pmk;

        hr = _PidlToMoniker(pidl, &pmk);
        if (SUCCEEDED(hr))
        {
            hr =  pmk->BindToStorage(pbc, NULL, riid, ppvObj);
            pmk->Release();
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    TraceMsg(TF_FTPISF, "CFtpFolder::BindToStorage() hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::CompareIDs

    DESCRIPTION:
        ici - column on which to sort.  Note! that we rely on the fact that
    IShellFolders are uniform; we do not need to bind to the shell folder in
    order to compare its sub-itemids.

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  In fact, they can.
\*****************************************************************************/
HRESULT CFtpFolder::CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ASSERT(IsValidPIDL(pidl1));
    ASSERT(IsValidPIDL(pidl2));

    return FtpItemID_CompareIDs(ici, pidl1, pidl2, FCMP_GROUPDIRS);
}


HRESULT CFtpFolder::_CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_FAIL;
    CFtpDir * pfd = GetFtpDir();

    *ppvObj = NULL;            // Explorer relies on this
    //TraceMsg(TF_FTPISF, "CFtpObj::CreateViewObject() ");
    if (pfd)
    {
        if (IsEqualIID(riid, IID_IDropTarget))
        {
            //  Don't create a drop target for the root FTP folder.
            if (IsRoot())
                hr = E_NOINTERFACE;
            else
            {
                CFtpDrop * pfm;
                hr = CFtpDrop_Create(this, hwndOwner, &pfm);
                if (SUCCEEDED(hr))
                {
                    hr = pfm->QueryInterface(riid, ppvObj);
                    pfm->Release();
                }
            }
        }
        else
            hr = E_NOINTERFACE;

        // TODO: IID_IShellDetails
        pfd->Release();
    }
    else
        hr = E_FAIL;            // Can't do that yet - Never _Initialize'd

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    if (FAILED(hr))
        hr = CBaseFolder::CreateViewObject(hwndOwner, riid, ppvObj);

    return hr;
}


IShellFolder * CFtpFolder::_GetLegacyShellFolder(void)
{
    IShellFolder * psfLegacy = NULL;

    // I assert that this succeeds because I need to make
    // sure every install case has this CLSID publicly available.
    if (SUCCEEDED(CoCreateInstance(CLSID_CDocObjectFolder, NULL, CLSCTX_INPROC_SERVER, IID_IShellFolder, (void **)&psfLegacy)))
    {
        LPITEMIDLIST pidl = GetPrivatePidlClone();

        if (pidl && !ILIsEmpty(pidl))
        {
            LPITEMIDLIST pidlLast = (LPITEMIDLIST) ILGetLastID(pidl);
            LPITEMIDLIST pidlLegacy;

            if (!FtpID_IsServerItemID(pidlLast))
            {
                // NT #291513: We want to force the last item to always be marked as a file
                //          because then it will not have the trailing '/' in the URL when we
                //          pass it to URLMON.  This way, we leave wether it's a file or dir
                //          ambigious for URLMON to figure out.  This is because we can't
                //          disambiguate because the proxy blocks us but URLMON handles it
                //          correctly.
                FtpPidl_SetFileItemType(pidlLast, FALSE);
                FtpPidl_SetAttributes(pidl, FILE_ATTRIBUTE_NORMAL);
            }

            if (SUCCEEDED(_GetLegacyPidl(pidl, &pidlLegacy)))
            {
                if (FAILED(_InitLegacyShellFolder(psfLegacy, pidlLegacy)))
                    ATOMICRELEASE(psfLegacy);

                ILFree(pidlLegacy);
            }
            
            ILFree(pidl);
        }
    }

    return psfLegacy;
}


/*****************************************************************************\
    FUNCTION: IShellFolder:: CreateViewObject

    DESCRIPTION:
    _UNDOCUMENTED_: This entire method is not documented.

    _UNDOCUMENTED_: It is not documented that you need to
    provide an IDropTarget object if you want the view to
    act as a drop target.

    IDropTarget produces a droptarget for the folder itself.

    _UNDOCUMENTED_: The IShellView interface is not documented.

    IShellView produces a shell view for the folder itself.

    _UNOBVIOUS_:  Not obvious that this is how the shell gets
    a context menu for the folder itself.  (You might think it
    comes from GetUIObjectOf...)

    IContextMenu produces a context menu for the folder itself.
    This is important for supporting things like New and Paste.

    IShellDetails (undocumented) is the direct interface to
    GetDetailsOf and ColumnClick, which is now obsolete, replaced
    by the DVM_GETDETAILSOF and DVM_COLUMNCLICK notifications.

    _UNDOCUMENTED_: SHCreateShellFolderViewEx is not documented.

    Yes, it's annoying how some things are handled by CreateViewObject
    and some things are handled by GetUIObjectOf(cpidl = 0), so we
    keep having to forward the requests back and forth.  Particularly
    annoying because the shell actually comes through both ways.

    For example, if the user drags something onto a folder,
    it does a CreateViewObject(IDropTarget), because it might not
    be able to bind to the parent to get the IDropTarget (if the
    folder is the root of a namespace).

    But if you drag an object onto a subfolder of a folder, the shell
    asks for a GetUIObjectOf(pidl, IDropTarget) so it can talk to
    the drop target of the subobject.  It does this to allow the
    shell folder to create a quick IDropTarget without necessarily
    binding to the subobject first.

    We don't do any such optimization, so GetUIObjectOf() simply
    binds to the subfolder and uses CreateViewObject().


    If the IShellFolder doesn't have an FtpSite (typically because it
    has not been IPersistFolder::Initialize'd), then fail any attempt
    to create a view object.
\*****************************************************************************/
HRESULT CFtpFolder::CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_FAIL;
    BOOL fDisplayProxyFallBackDlg = TRUE;

    // We don't need to wory about falling back with a few interfaces, 
    // IResolveShellLink is one of them.  There may be others, and we should
    // add them if they are used often or in common scenarios because of the
    // HUGE PERF IMPACT of _NeedToFallBack() which checks the net for a proxy
    // blocking us.  TODO: Investigate if IID_IDropTarget, IID_IContextMenu can be added.
    if (!IsEqualIID(riid, IID_IResolveShellLink) && !IsEqualIID(riid, IID_IShellDetails) &&
        _NeedToFallBack(GetPrivatePidlReference(), &fDisplayProxyFallBackDlg))
    {
        IShellFolder * psfLegacy = _GetLegacyShellFolder();

        // We only want to display the proxy blocking dialog when we are creating the view.
        if (fDisplayProxyFallBackDlg && IsEqualIID(riid, IID_IShellView))
        {
            DisplayBlockingProxyDialog(GetPrivatePidlReference(), hwndOwner);
        }

        if (psfLegacy)
        {
            hr = psfLegacy->CreateViewObject(hwndOwner, riid, ppvObj);
            psfLegacy->Release();
        }
    }
    else
    {
        hr = _CreateViewObject(hwndOwner, riid, ppvObj);
    }
    

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::GetAttributesOf

    DESCRIPTION:
        If we are given cpidl = 0, then we are being asked for attributes
    on the folder itself.  But note that some people pass slightly
    confused versions of cpidl = 0, as noted in the comment block below.

    If the SFGAO_VALIDATE bit is set with cpidl = 0, then the view
    object is warning us that it is about to refresh, so we should
    throw away any cached information.

    NOTE!  ftpcm.cpp relies heavily on the fact that this routine will
    fail when given complex pidls.  (This allows ftpcm.cpp to assume
    that all the pidls are directly in the affected folder.)

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  I don't know whether or not
    they can, so I'll code defensively and watch out for them.

    Does a server need to return SFGAO_HASSUBFOLDER?  We don't currently
    do that and it would be a lot of work and incure a huge perf hit
    if we did.
\*****************************************************************************/
HRESULT CFtpFolder::GetAttributesOf(UINT cpidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    HRESULT hr;
    DWORD dwMask = *rgfInOut;

    //    _UNDOCUMENTED_:
    //    Some people pass cpidl = 1 but ILIsEmpty(apidl[0]),
    //    intending to pass cpidl = 0.  While we're being distracted
    //    by these sorts of people, may as well catch apidl[0] == 0 also...
    //    Oh, and defview sometimes passes cpidl = 1 but apidl == 0...
    if (cpidl > 0 && apidl && apidl[0] && !ILIsEmpty(apidl[0]))
    {
        UINT ipidl;

        //  Can't multi-rename because there's nowhere to pass the new names.
        //  Can't multi-paste since you don't know where it really goes.
        if (cpidl > 1)
        {
            *rgfInOut &= ~SFGAO_CANRENAME;
            *rgfInOut &= ~SFGAO_DROPTARGET;
        }
        hr = S_OK;
        for (ipidl = 0; ipidl < cpidl; ipidl++)
        {
            // This maybe a fully qualified pidl or relative pidl
            LPITEMIDLIST pidlFull;

            if (ILIsSimple(apidl[ipidl]))
                pidlFull = CreateFullPrivatePidl(apidl[0]);
            else
                pidlFull = (LPITEMIDLIST) apidl[0];

            *rgfInOut &= FtpGetAttributesOf(pidlFull);

            // BUG NT #166783: shell32 v3 & v4 (Win95 & NT4 orig) won't allow you
            // to allow SFGAO_CANLINK but disallow the link to be created in your
            // own folder.  So we need to disable this item in browser only.
            if (SHELL_VERSION_NT5 != GetShellVersion())
                *rgfInOut &= ~SFGAO_CANLINK;

            if (apidl[0] != pidlFull)
                ILFree(pidlFull);       // We alloced it so we free it.
        }
    }
    else
    {
        // At top-level, SFGAO_DROPTARGET is also disabled
        if (IsRoot())
            *rgfInOut &= ~SFGAO_DROPTARGET;

        *rgfInOut &= ~(SFGAO_GHOSTED | SFGAO_LINK | SFGAO_READONLY |
                   SFGAO_SHARE | SFGAO_REMOVABLE);

        if (*rgfInOut & SFGAO_VALIDATE)
            InvalidateCache();      // About to refresh...

        hr = S_OK;
    }

//    TraceMsg(TF_FTPISF, "CFtpFolder::GetAttributesOf() *rgfInOut=%#08lx, hr=%#08lx", *rgfInOut, hr);
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Creates an pflHfpl and asks CFtpFolder_GetUIObjectOfHfpl (qv)
    to do the real work.

    Note that we always release the pflHfpl.  If GetUIObjectOfHfpl
    needs to keep the pflHfpl, it will do its own AddRef().
\*****************************************************************************/
HRESULT CFtpFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj)
{
     return _GetUIObjectOf(hwndOwner, cidl, rgpidl, riid, prgfInOut, ppvObj, FALSE);
}


/*****************************************************************************\
    DESCRIPTION:
        Creates an pflHfpl and asks CFtpFolder_GetUIObjectOfHfpl (qv)
    to do the real work.

    Note that we always release the pflHfpl.  If GetUIObjectOfHfpl
    needs to keep the pflHfpl, it will do its own AddRef().
\*****************************************************************************/
HRESULT CFtpFolder::_GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    CFtpPidlList * pflHfpl = NULL;
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFull;
    
    if (rgpidl)
        pidlFull = CreateFullPrivatePidl(rgpidl[0]);
    else
        pidlFull = GetPrivatePidlClone();
    
    if (ppvObj)
        *ppvObj = NULL;

    // Is the proxy blocking us?  If yes, don't do anything
    // because we don't want our Context Menu to appear for the
    // original FTP UI.
    // It's not blocking so go ahead.
    hr = CFtpPidlList_Create(cidl, rgpidl, &pflHfpl);
    if (SUCCEEDED(hr))
    {
        _InitFtpSite(); // GetUIObjectOfHfpl() will later need m_pfs. 
        hr = GetUIObjectOfHfpl(hwndOwner, pflHfpl, riid, ppvObj, fFromCreateViewObject);
        pflHfpl->Release();
    }

    if (pidlFull)
        ILFree(pidlFull);

//    TraceMsg(TF_FTPISF, "CFtpFolder::GetUIObjectOf() hres=%#08lx", hr);
    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::GetDisplayNameOf

    DESCRIPTION:
        Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    FTP UNICODE ISSUE:
        The FTP spec (RFC 959 (?)) says that FTP uses 8-bit BYTEs as
    names.  If the 8th bit is zero, these are treated as ANSI.
    But it's not specified what the 8th bit means when it's set?
    Some FTP clients have been pushing DBCS/MBCS up using the 8th bit
    but this incurs data loss because the code page is lost and cross
    code page strings are not supported.  For that reason, a combination
    of UTF-8 (by default) should be used and fall back to DBCS with
    code page guessing (maybe need UI to guess code page).

    We need to use WININET BYTE APIs (BYTE means ANSI with an ambiguous 8th bit).
    We then need to store those bytes in our cache (CFtpDir).  When we display
    these strings in UI, we need to convert them to unicode and guess weather
    it's UTF-8 or DBCS encoded.
\*****************************************************************************/
HRESULT CFtpFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pStrRet)
{
    HRESULT hr = E_FAIL;

    // It's invalid for someone to pass us an empty pidl, but some do.
    // (comdlg32\GetPathFromLocation)  Reject it now.
    if (ILIsEmpty(pidl) || !EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);
    if (pidlFull)
    {
        ASSERT(IsValidPIDL(pidlFull));

        hr = StrRetFromFtpPidl(pStrRet, shgno, pidlFull);
        ILFree(pidlFull);
    }

//    TraceMsg(TF_FTPISF, "CFtpFolder::GetDisplayNameOf() szName=%hs, hres=%#08lx", pStrRet->cStr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::SetNameOf

    DESCRIPTION:
        The real work is done by SetNameOf.
\*****************************************************************************/
HRESULT CFtpFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pwszName,
                                DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = S_FALSE;
    TCHAR szPath[MAX_PATH];
    BOOL fContinueToRename = TRUE;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    CFtpDir * pfd = GetFtpDir();
    if (!pfd)
    {
        return E_OUTOFMEMORY;
    }

    ASSERT(IsValidPIDL(pidl));

    SHUnicodeToTChar(pwszName, szPath, ARRAYSIZE(szPath));
    // You can not rename a folder or file to have spaces at the beginning or end.  This
    // is because the path is sent over the wire as "RENAME foobar.txt     foobar2.txt"
    // so note that the spaces are ambiguis so the server will ignore spaces before or after the
    // file.  If the caller has spaces before or after the path, remove them.  Spaces in
    // the middle are acceptable.
    PathRemoveBlanks(szPath);

    // Does the new item not have an extension and this isn't a directory?
    if ((0 == PathFindExtension(szPath)[0]) && !FtpPidl_IsDirectory(pidl, FALSE))
    {
        LPCWIRESTR pszFileName = FtpPidl_GetLastItemWireName(pidl);
        // Yes, then we are scared that they may be loosing an extension.

        // Did the original name have an extension?
        if (pszFileName && PathFindExtensionA(pszFileName)[0])
        {
            // Yes, so now we are scared they may loose it and not be able
            // to find the src app.  Ask the user if they really want to do this
            // rename if that will mean the file will no longer have an extension.

            // Hey browser, can I display UI?
            if (EVAL(hwndOwner))
            {
                // Hay browser, cover me, I'm going to do UI.
                IUnknown_EnableModless(_punkSite, FALSE);

                TCHAR szTitle[MAX_PATH];
                TCHAR szReplaceMsg[MAX_PATH*4];

                EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_RENAME_TITLE, szTitle, ARRAYSIZE(szTitle)));
                EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_RENAME_EXT_WRN, szReplaceMsg, ARRAYSIZE(szReplaceMsg)));
                if (IDNO == MessageBox(hwndOwner, szReplaceMsg, szTitle, (MB_YESNO | MB_ICONEXCLAMATION)))
                    fContinueToRename = FALSE;  // Cancel the rename.

                IUnknown_EnableModless(_punkSite, TRUE);
            }
        }
    }

    if (fContinueToRename)
    {
        if (pfd)
        {
            hr = pfd->SetNameOf(this, hwndOwner, pidl, szPath, dwReserved, ppidlOut);
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && hwndOwner)
            {
                DisplayWininetError(hwndOwner, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_FILERENAME, IDS_FTPERR_WININET, MB_OK, NULL);
            }
        }

        TraceMsg(TF_FTPISF, "CFtpFolder::SetNameOf(%ls) hres=%#08lx", pwszName, hr);
        //        shell32.dll in IE4 (maybe earlier also) will infinitely call
        //    CFtpFolder::SetNameOf() over and over if it returns FAILED(hr);
        if (FAILED(hr))
            hr = S_FALSE;
    }

    if (ppidlOut)
    {
        ASSERT_POINTER_MATCHES_HRESULT(*ppidlOut, hr);
    }

    if (pfd)
    {
        pfd->Release();
    }

    return hr;
}


//===========================
// *** IPersistFolder Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IPersistFolder::Initialize

    DESCRIPTION:
        This is called when the shell creates a new "root".

    Note that we pass a fake "null" ID list as the second
    pidl to ::_Initialize, q.v., for explanation.

    _UNDOCUMENTED_: Undocumented method in undocumented interface.
\*****************************************************************************/
HRESULT CFtpFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(IsValidPIDL(pidl));

    HRESULT hr = _Initialize(pidl, NULL, ILGetSize(pidl) - sizeof(pidl->mkid.cb));
    //TraceMsg(TF_FTPISF, "CFtpFolder::Initialize() hres=%#08lx", hr);
    return hr;
}


//===========================
// *** IShellIcon Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IShellIcon::GetIconOf

    DESCRIPTION:
        Get the system icon imagelist index for a pidl.  Subtlety - If we are
    enumerating children of the root, their icon is a computer.

    _UNDOCUMENTED_: Undocumented method in undocumented interface.
\*****************************************************************************/
HRESULT CFtpFolder::GetIconOf(LPCITEMIDLIST pidl, UINT gil, LPINT pnIcon)
{
    HRESULT hr = S_OK;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    // If we want custom icons, make that change here.  We could want to do
    // that if we wanted folder icons from FTP sites to look different than
    // folder icons from the file system.  But we don't currently want that.
    *pnIcon = GetFtpIcon(gil, IsRoot());

    ASSERT(IsValidPIDL(pidl));
    if (EVAL(!IsRoot()))    // GetFtpIcon() is wrong so either fix it or verify we never try to use it.
    {
        SHFILEINFO sfi;
        hr = FtpPidl_GetFileInfo(pidl, &sfi, SHGFI_SYSICONINDEX |
                    ((gil & GIL_OPENICON) ? SHGFI_OPENICON : 0));

        if (SUCCEEDED(hr))
        {
            *pnIcon = sfi.iIcon;
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);
        }
    }

//    TraceMsg(TF_FTPISF, "CFtpFolder::GetIconOf() hres=%#08lx", hr);
    return hr;
}



//===========================
// *** IShellIconOverlay Interface ***
//===========================
HRESULT CFtpFolder::GetOverlayIndexHelper(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    *pIndex = 0;
    // Is this a soft link? (Meaning it won't have a windows link
    // extension (.lnk, .url, ...) but we still want the shortcut cue.
    if (pidl && FtpPidl_IsSoftLink(pidl))
    {
        if (!m_psiom)
        {
            hr = CoCreateInstance(CLSID_CFSIconOverlayManager, NULL, CLSCTX_INPROC_SERVER, IID_IShellIconOverlayManager, (void **)&m_psiom);
        }

        if (m_psiom)
        {
            hr = m_psiom->GetReservedOverlayInfo(L"", FtpPidl_GetAttributes(pidl), pIndex, dwFlags, SIOM_RESERVED_LINK);
        }
    }

    return hr;
}


//===========================
// *** IDelegateFolder Interface ***
//===========================
/*****************************************************************************\
    FUNCTION: IDelegateFolder::SetItemAlloc

    DESCRIPTION:
        Gives us the pidl allocator.
\*****************************************************************************/
HRESULT CFtpFolder::SetItemAlloc(IMalloc *pm)
{
    IUnknown_Set(&m_pm, pm);

//    TraceMsg(TF_FTPISF, "CFtpFolder::SetItemAlloc(IMalloc *pm=%#08lx) hres=%#08lx", pm, S_OK);
    return S_OK;
}


//===========================
// *** IBrowserFrameOptions Interface ***
//===========================
/*****************************************************************************\
    DESCRIPTION:
        Tell the browser/host what behaviors we want.  This lets the caller
    know when we want to act like the shell, the browser, or even unique.
\*****************************************************************************/
HRESULT CFtpFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // This function is called in the follow situations:
    // ftp://bryanst/ (w/ & w/o folder shortcut)
    // ftp://bryanst/default.htm (w/ & w/o folder shortcut)
    // ftp://bryanst/notes.txt (w/ & w/o folder shortcut)
    // ftp://bryanst/resume.doc (w/ & w/o folder shortcut)
    // ftp://bryanst/ (w/ & w/o folder shortcut)
    // ftp://bryanst/ (w/ & w/o folder shortcut)
    // ftp://bryanst/ (w/ & w/o folder shortcut)
    HRESULT hr = E_INVALIDARG;

    if (pdwOptions)
    {
        // We want both "Internet Options" and "Folder Options".
        *pdwOptions = dwMask & (BFO_BOTH_OPTIONS | BFO_BROWSE_NO_IN_NEW_PROCESS |
                                BFO_NO_REOPEN_NEXT_RESTART |
                                BFO_ENABLE_HYPERLINK_TRACKING | BFO_USE_IE_LOGOBANDING |
                                BFO_ADD_IE_TOCAPTIONBAR | BFO_USE_DIALUP_REF);
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CFtpFolder_Create

    DESCRIPTION:
        Note that we release the pff that Common_New created, because we
    are done with it.  The real refcount is handled by the
    CFtpFolder_QueryInterface.
\*****************************************************************************/
HRESULT CFtpFolder_Create(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;
    CFtpFolder * pff = new CFtpFolder();

    *ppvObj = NULL;
    if (pff)
    {
        hres = pff->QueryInterface(riid, ppvObj);
        pff->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hres);
    return hres;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpFolder_Create(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int ib, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;
    CFtpFolder * pff = new CFtpFolder();

    ASSERT(IsValidPIDL(pidlTarget));
    ASSERT(!pidlRoot || IsValidPIDL(pidlRoot));

    *ppvObj = NULL;
    if (!pff)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        hr = pff->_Initialize(pidlTarget, pidlRoot, ib);        // Can fail in out of memory
        if (SUCCEEDED(hr))
            hr = pff->QueryInterface(riid, ppvObj);

        pff->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpFolder::CFtpFolder() : CBaseFolder((LPCLSID) &CLSID_FtpFolder)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfs);
    ASSERT(!m_pm);
    ASSERT(!m_puhs);
    ASSERT(!m_psiom);

    // Needed because we need to call CoCreateInstance() on Browser Only.
    LEAK_ADDREF(LEAK_CFtpFolder);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpFolder::~CFtpFolder()
{
    ATOMICRELEASE(m_pfs);
    ATOMICRELEASE(m_pm);
    ATOMICRELEASE(m_puhs);
    ATOMICRELEASE(m_psiom);

    if (m_hinstInetCpl)
        FreeLibrary(m_hinstInetCpl);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpFolder);
}


//===========================
// *** IUnknown Interface ***
//===========================

HRESULT CFtpFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IShellIcon))
    {
        *ppvObj = SAFECAST(this, IShellIcon*);
    }
//  This causes all icons to use my custom ftp folder icon, so I will do this when that is fixed.
#ifdef FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY
    else if (IsEqualIID(riid, IID_IShellIconOverlay))
    {
        *ppvObj = SAFECAST(this, IShellIconOverlay*);
    }
#endif // FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY
    else if (IsEqualIID(riid, IID_IPersistFolder))
    {
        *ppvObj = SAFECAST(this, IPersistFolder*);
    }
    else if (IsEqualIID(riid, IID_IDelegateFolder))
    {
        *ppvObj = SAFECAST(this, IDelegateFolder*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else if (IsEqualIID(riid, IID_IPersistFolder2))
    {
        *ppvObj = SAFECAST(this, IPersistFolder2*);
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppvObj = SAFECAST(this, IShellPropSheetExt*);
    }
    else if (IsEqualIID(riid, IID_IBrowserFrameOptions))
    {
        *ppvObj = SAFECAST(this, IBrowserFrameOptions*);
    }
    else if (IsEqualIID(riid, IID_CFtpFolder))
    {
        // Only valid if caller lives in msieftp.dll
        *ppvObj = (void *)this;
    }
    else
        return CBaseFolder::QueryInterface(riid, ppvObj);

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpinet.h ===
/*****************************************************************************
 *
 *	ftpinet.h - Wrapper for WININET stuff
 *
 *****************************************************************************/

#ifndef _FTPINET_H
#define _FTPINET_H


HINTERNET GetWininetSessionHandle(void);
void UnloadWininet(void);


#endif // _FTPINET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpicon.cpp ===
/*****************************************************************************
 *
 *    ftpicon.cpp - IExtractIcon interface
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpicon.h"
#include "ftpurl.h"




INT GetFtpIcon(UINT uFlags, BOOL fIsRoot)
{
    INT nIcon = (uFlags & GIL_OPENICON) ? IDI_FTPOPENFOLDER : IDI_FTPFOLDER;

    if (fIsRoot)
        nIcon = IDI_FTPSERVER;      // This is an FTP Server Icon.

    return nIcon;
}



#ifndef UNICODE
#define PathFindExtensionA PathFindExtension
#endif

//===========================
// *** IExtractIconA Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: GetIconLocation

    DESCRIPTION:
        Get the icon location from the registry.

    _UNDOCUMENTED_:  Not mentioned is that if you return GIL_NOTFILENAME,
    you should take steps to ensure uniqueness of the non-filename
    return value, to avoid colliding with non-filenames from other
    shell extensions.

    _UNDOCUMENTED_:  The inability of SHGetFileInfo to work properly
    on "magic internal" cached association icons like "*23" is not
    documented.  As a result of this "feature", the SHGFI_ICONLOCATION
    flag is useless.


    Actually, we can still use SHGetFileInfo; we'll use the shell's own
    feature against it.  We'll do a SHGFI_SYSICONINDEX and return that
    as the icon index, with "*" as the GIL_NOTFILENAME.


    We don't handle the cases where we ought to use GIL_SIMULATEDOC.
\*****************************************************************************/
HRESULT CFtpIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    static CHAR szMSIEFTP[MAX_PATH] = "";

    if (0 == szMSIEFTP[0])
        GetModuleFileNameA(HINST_THISDLL, szMSIEFTP, ARRAYSIZE(szMSIEFTP));

    // NOTE: This is negative because it's a resource index.
    *piIndex = (0 - GetFtpIcon(uFlags, m_nRoot));

    if (pwFlags)
        *pwFlags = GIL_PERCLASS; //(uFlags & GIL_OPENICON);

    StrCpyNA(szIconFile, szMSIEFTP, cchMax);

    return S_OK;
}


//===========================
// *** IExtractIconW Interface ***
//===========================
HRESULT CFtpIcon::GetIconLocation(UINT uFlags, LPWSTR wzIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hres;
    CHAR szIconFile[MAX_PATH];

    ASSERT_SINGLE_THREADED;
    hres = GetIconLocation(uFlags, szIconFile, ARRAYSIZE(szIconFile), piIndex, pwFlags);
    if (EVAL(SUCCEEDED(hres)))
        SHAnsiToUnicode(szIconFile, wzIconFile, cchMax);

    return hres;
}


//===========================
// *** IQueryInfo Interface ***
//===========================
HRESULT CFtpIcon::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    ASSERT_SINGLE_THREADED;
    if (ppwszTip)       // The shell doesn't check the return value
        *ppwszTip = NULL; // so we always have to NULL the output pointer.

//        SHStrDupW(L"", ppwszTip);

    return E_NOTIMPL;

/**************
    // This InfoTip will appear when the user hovers over an item in defview.
    // We don't want to support this now because it isn't needed and looks different
    // than the shell.

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;

    if (!ppwszTip)
        return E_INVALIDARG;

    *ppwszTip = NULL;
    if (m_pflHfpl && (pidl = m_pflHfpl->GetPidl(0)))
    {
        WCHAR wzToolTip[MAX_URL_STRING];

        hr = FtpPidl_GetDisplayName(pidl, wzItemName, ARRAYSIZE(wzItemName));
        if (EVAL(SUCCEEDED(hr)))
            hr = SHStrDupW(wzToolTip, ppwszTip);
    }

    return hr;
***********/
}

HRESULT CFtpIcon::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}




/*****************************************************************************
 *    CFtpIcon_Create
 *
 *    We just stash away the pflHfpl; the real work happens on the
 *    GetIconLocation call.
 *
 *    _HACKHACK_: psf = 0 if we are being called by the property sheet code.
 *****************************************************************************/
HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;
    CFtpIcon * pfi;

    *ppvObj = NULL;

    hres = CFtpIcon_Create(pff, pflHfpl, &pfi);
    if (SUCCEEDED(hres))
    {
        hres = pfi->QueryInterface(riid, ppvObj);
        pfi->Release();
    }

    return hres;
}


/*****************************************************************************
 *    CFtpIcon_Create
 *
 *    We just stash away the m_pflHfpl; the real work happens on the
 *    GetIconLocation call.
 *
 *    _HACKHACK_: psf = 0 if we are being called by the property sheet code.
 *****************************************************************************/
HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpIcon ** ppfi)
{
    HRESULT hres= E_OUTOFMEMORY;

    *ppfi = new CFtpIcon();
    if (*ppfi)
    {
        IUnknown_Set(&(*ppfi)->m_pflHfpl, pflHfpl);
        if (pff && pff->IsRoot())
        {
            (*ppfi)->m_nRoot++;
        }
        hres = S_OK;
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpIcon::CFtpIcon() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pflHfpl);
    ASSERT(!m_nRoot);

    INIT_SINGLE_THREADED_ASSERT;
    LEAK_ADDREF(LEAK_CFtpIcon);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpIcon::~CFtpIcon()
{
    ATOMICRELEASE(m_pflHfpl);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpIcon);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpIcon::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpIcon::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpIcon::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFtpIcon, IExtractIconW),
        QITABENT(CFtpIcon, IExtractIconA),
        QITABENT(CFtpIcon, IQueryInfo),
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpicon.h ===
/*****************************************************************************
 *    ftpicon.h
 *****************************************************************************/

#ifndef _FTPICON_H
#define _FTPICON_H


INT GetFtpIcon(UINT uFlags, BOOL fIsRoot);

/*****************************************************************************
    CFtpIcon

    The stuff that tells the shell which icon to use.
    Just plain annoying.  No real work is happening.
    Fortunately, the shell does most of the real work.

    Again, note that the szName is a plain char and not a TCHAR,
    because UNIX filenames are always ASCII.

    Extract() returning S_FALSE means "Could you do it for me?  Thanks."
 *****************************************************************************/

class CFtpIcon          : public IExtractIconW
                        , public IExtractIconA
                        , public IQueryInfo
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IExtractIconA ***
    virtual STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    virtual STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize) {return S_FALSE;};
    
    // *** IExtractIconW ***
    virtual STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    virtual STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize) {return S_FALSE;};

    // *** IQueryInfo ***
    virtual STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    virtual STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);


public:
    CFtpIcon();
    ~CFtpIcon(void);
    // Friend Functions
    friend HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppv);
    friend HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpIcon ** ppfm);

protected:
    // Private Member Variables
    int                     m_cRef;

    CFtpPidlList *          m_pflHfpl;      // FtpDir in which our pidls live
    int                     m_nRoot;        // Gross HACKHACK (see CFtpIcon_Create)
    SINGLE_THREADED_MEMBER_VARIABLE;

    // Private Member Functions
    int ParseIconLocation(LPSTR pszIconFile);
    void GetDefaultIcon(LPSTR szIconFile, UINT cchMax, HKEY hk);
    HRESULT GetIconLocHkey(LPSTR szIconFile, UINT cchMax, LPINT pi, HKEY hk);
};

#endif // _FTPICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpmi.cpp ===
/*****************************************************************************
 *
 *	ftpmi.cpp - IMalloc interface for allocing pidls
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpmi.h"


/*****************************************************************************
 *	IMalloc::Alloc
 *****************************************************************************/

LPVOID CMallocItem::Alloc(ULONG cbSize)
{
    WORD cbActualSize = sizeof(DELEGATEITEMID) - 1 + cbSize;
    PDELEGATEITEMID pidl = (PDELEGATEITEMID)SHAlloc(cbActualSize + 2);

    if (pidl)
    {
        pidl->cbSize = cbActualSize;
        pidl->wOuter = 0x6646;          // "Ff"
        pidl->cbInner = (WORD)cbSize;
        *(WORD *)&(((BYTE *)pidl)[cbActualSize]) = 0;
    }

    return pidl;
}

/*****************************************************************************
 *	IMalloc::Realloc
 *****************************************************************************/

LPVOID CMallocItem::Realloc(LPVOID pv, ULONG cb)
{
    return NULL;
}

/*****************************************************************************
 *	IMalloc::Free
 *****************************************************************************/

void CMallocItem::Free(LPVOID pv)
{
    SHFree(pv);
}

/*****************************************************************************
 *	IMalloc::GetSize
 *****************************************************************************/

ULONG CMallocItem::GetSize(LPVOID pv)
{
    return (ULONG)-1;
}

/*****************************************************************************
 *	IMalloc::DidAlloc
 *****************************************************************************/

int CMallocItem::DidAlloc(LPVOID pv)
{
    return -1;
}

/*****************************************************************************
 *	IMalloc::HeapMinimize
 *****************************************************************************/

void CMallocItem::HeapMinimize(void)
{
    NULL;
}


/*****************************************************************************
 *	CMallocItem_Create
 *****************************************************************************/

HRESULT CMallocItem_Create(IMalloc ** ppm)
{
    HRESULT hres = E_OUTOFMEMORY;
    CMallocItem * pmi = new CMallocItem();

    if (pmi)
    {
        hres = pmi->QueryInterface(IID_IMalloc, (LPVOID *) ppm);
        pmi->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CMallocItem::CMallocItem() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    LEAK_ADDREF(LEAK_CMallocItem);
}


/****************************************************\
    Destructor
\****************************************************/
CMallocItem::~CMallocItem()
{
    DllRelease();
    LEAK_DELREF(LEAK_CMallocItem);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CMallocItem::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CMallocItem::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CMallocItem::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IMalloc))
    {
        *ppvObj = SAFECAST(this, IMalloc *);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CMallocItem::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpmi.h ===
/*****************************************************************************
 *	ftpmi.h
 *****************************************************************************/

#ifndef _FTPMALLOCITEM_H
#define _FTPMALLOCITEM_H



/*****************************************************************************
 *
 *	CMallocItem
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

class CMallocItem       : public IMalloc
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IMalloc ***
    virtual STDMETHODIMP_(LPVOID) Alloc(ULONG cb);
    virtual STDMETHODIMP_(LPVOID) Realloc(LPVOID pv, ULONG cb);
    virtual STDMETHODIMP_(void) Free(LPVOID pv);
    virtual STDMETHODIMP_(ULONG) GetSize(LPVOID pv);
    virtual STDMETHODIMP_(int) DidAlloc(LPVOID pv);
    virtual STDMETHODIMP_(void) HeapMinimize();

public:
    CMallocItem();
    ~CMallocItem(void);

    // Friend Functions
    friend HRESULT CMallocItem_Create(IMalloc ** ppm);

protected:
    int                     m_cRef;
};

#endif // _FTPMALLOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpinet.cpp ===
/*****************************************************************************
 *
 *    ftpinet.cpp - Interfacing to WinINet
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpinet.h"

#define SHInterlockedCompareExchangePointer SHInterlockedCompareExchange


/*****************************************************************************
 *
 *    Const strings for our Wininet stuff.
 *
 *****************************************************************************/

HINSTANCE g_hinstWininet = NULL;    /* The DLL handle */
HINTERNET g_hint = NULL;        /* Shared internet anchor handle */

#define SZ_WININET_AGENT TEXT("Microsoft(r) Windows(tm) FTP Folder")


/*****************************************************************************\
    FUNCTION: InitWininet
\*****************************************************************************/
void InitWininet(void)
{
    // You can't use a critical section around LoadLibrary().
    ASSERTNONCRITICAL;

    if (!g_hinstWininet)
    {
        HINSTANCE hinstTemp = LoadLibrary(TEXT("WININET.DLL"));

        if (EVAL(hinstTemp))
        {
            // Can we successfully put it here?
            if (SHInterlockedCompareExchangePointer((void **)&g_hinstWininet, hinstTemp, NULL))
            {
                // No, someone else beat us there.
                ASSERT(g_hinstWininet);
                FreeLibrary(hinstTemp);
            }
        }
    }

    if (EVAL(g_hinstWininet))
    {
        if (!g_hint)
        {
            HINTERNET hinternetTemp;

            EVAL(SUCCEEDED(InternetOpenWrap(TRUE, SZ_WININET_AGENT, PRE_CONFIG_INTERNET_ACCESS, 0, 0, 0, &hinternetTemp)));
            if (EVAL(hinternetTemp))
            {
                // Can we successfully put it here?
                if (SHInterlockedCompareExchangePointer((void **)&g_hint, hinternetTemp, NULL))
                {
                    // No, someone else beat us there.
                    ASSERT(g_hint);
                    InternetCloseHandle(hinternetTemp);
                }
            }
        }
    }
}


/*****************************************************************************\
    FUNCTION: UnloadWininet
\*****************************************************************************/
void UnloadWininet(void)
{
    // You can't use a critical section around FreeLibrary() (I think).
    ASSERTNONCRITICAL;

    if (g_hint)
    {
        HINTERNET hinternetTemp = InterlockedExchangePointer(&g_hint, NULL);

        if (hinternetTemp)
        {
            InternetCloseHandle(hinternetTemp);
        }
    }

/************************
//  I want to unload wininet, I really do.  But this function is called
//  during process un-attach and it's better to leak wininet than to
//  call FreeLibrary() during process unattach.

    if (g_hinstWininet)
    {
        HINSTANCE hinstTemp = (HINSTANCE)InterlockedExchangePointer((void **) &g_hinstWininet, NULL);

        if (hinstTemp)
        {
            FreeLibrary(hinstTemp);
        }
    }
*********************/
}

/*****************************************************************************\
 *    hintShared
 *
 *    Obtain the shared internet handle that we use for all our stuff.
 *    We load WinINet only on demand, so that quick things will be quick.
 *    If this procedure fails, the reason can be obtained via GetLastError().
 *    (Note that this assumes that we always try to InitWininet().)
\*****************************************************************************/
HINTERNET GetWininetSessionHandle(void)
{
    //    Avoid taking the critical section unless you really need to.
    if (!g_hint)
    {
        InitWininet();
        ASSERT(g_hint);
    }
    return g_hint;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftplist.h ===
/*****************************************************************************
 *	ftplist.h
 *****************************************************************************/

#ifndef _FTPLIST_H
#define _FTPLIST_H

#include "util.h"


#define FLM_ADDED           0
#define FLM_FINALIZE        1



/*****************************************************************************
 *
 *	CFtpList
 *
 *****************************************************************************/

class CFtpList          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CFtpList(PFNDPAENUMCALLBACK fncDestroy);
    ~CFtpList(void);

    // Public Member Functions
    HRESULT AppendItem(LPVOID pv);
    HRESULT InsertSorted(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam);
    LPVOID GetItemPtr(int nIndex)   { return DPA_GetPtr(m_hdpa, nIndex); };
    LPVOID Find(PFNDPACOMPARE pfn, LPCVOID pv);
    void Enum(PFNDPAENUMCALLBACK pfn, LPVOID pv) { DPA_EnumCallback(m_hdpa, pfn, pv); };
    void SetItemPtr(int nIndex, LPVOID pv)   { DPA_SetPtr(m_hdpa, nIndex, pv); };
    void DeleteItemPtr(LPVOID pv);
    void DeletePtrByIndex(int nIndex) {DPA_DeletePtr(m_hdpa, nIndex);};
    int GetCount(void)              { return DPA_GetPtrCount(m_hdpa); };
    int SortedSearch(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options);


    // Friend Functions
    friend HRESULT CFtpList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CFtpList ** ppfl);

protected:
    // Private Member Variables
    int                     m_cRef;

    HDPA                    m_hdpa;
    PFNDPAENUMCALLBACK      m_pfnDestroy;
};

#endif // _FTPLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftplist.cpp ===
/*****************************************************************************\
    CFtpList.cpp - Internal list manager

    It is the caller's responsibility to manage any needed serialization.
\*****************************************************************************/

#include "priv.h"
#include "ftplist.h"


/*****************************************************************************\
    FUNCTION: CFtpList::DeleteItemPtr

    Remove the element "pv" from the array.
\*****************************************************************************/

void CFtpList::DeleteItemPtr(LPVOID pv)
{
    int nIndex;

    ASSERT(m_hdpa);
    nIndex = DPA_GetPtrIndex(m_hdpa, pv);
    TraceMsg(TF_FTPLIST, "CFtpList::DeleteItemPtr(pv=%#08lx) this=%#08lx, nIndex=%d", pv, this, nIndex);

    if (-1 != nIndex)
        DPA_DeletePtr(m_hdpa, nIndex);
}


/*****************************************************************************\
    FUNCTION: AppendItem

    Add a new pv to the growing array.
\*****************************************************************************/
HRESULT CFtpList::AppendItem(LPVOID pv)
{
    ASSERT(m_hdpa);
    DPA_AppendPtr(m_hdpa, pv);
    //TraceMsg(TF_FTPLIST, "CFtpList::AppendItem(pv=%#08lx) this=%#08lx", pv, this);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: InsertSorted

    Add a new pv to the growing array.
\*****************************************************************************/
HRESULT CFtpList::InsertSorted(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam)
{
    ASSERT(m_hdpa);
    DPA_SortedInsertPtr(m_hdpa, pv, 0, pfnCompare, lParam, DPAS_INSERTBEFORE, pv);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: SortedSearch

    DESCRIPTION:
        Search thru the list for the item.
\*****************************************************************************/
int CFtpList::SortedSearch(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    return DPA_Search(m_hdpa, pv, 0, pfnCompare, lParam, options);
}


/*****************************************************************************\
    FUNCTION: Find

    Call back once for each item in the pv list.  Stops when the
    callback returns 0, returning the item that triggered the match.

    The callback typically returns the result of a comparison function.
\*****************************************************************************/
LPVOID CFtpList::Find(PFNDPACOMPARE pfn, LPCVOID pv)
{
    LPVOID pvoid = NULL;
    int nIndex;

    nIndex = DPA_Search(m_hdpa, (LPVOID) pv, 0, pfn, NULL, 0);

    if (-1 != nIndex)
        pvoid = DPA_GetPtr(m_hdpa, nIndex);

    //TraceMsg(TF_FTPLIST, "CFtpList::Find(pfn=%#08lx; pv=%#08lx) this=%#08lx, nIndex=%d, result=%#08lx", pfn, pv, this, nIndex, pvoid);

    return pvoid;
}

/*****************************************************************************\
    CFtpList_Create

    Start up a new pv list, with a recommended initial size and other
    callback info.
\*****************************************************************************/
HRESULT CFtpList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CFtpList ** ppfl)
{
    HRESULT hres = E_OUTOFMEMORY;
    CFtpList * pfl = new CFtpList(pfn);
    *ppfl = pfl;

    if (pfl)
    {
        pfl->m_hdpa = DPA_Create(nGrow);
       //CFtpList_Create(pfn=%#08lx) this=%#08lx, cpvInit=%d, nGrow=%d", pfn, pfl, cpvInit, nGrow);

        if (EVAL(pfl->m_hdpa))
            hres = S_OK;
        else
        {
            pfl->Release();
            *ppfl = NULL;
        }
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpList::CFtpList(PFNDPAENUMCALLBACK pfnDestroy) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);

    m_pfnDestroy = pfnDestroy;
    LEAK_ADDREF(LEAK_CFtpList);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpList::~CFtpList()
{
    //TraceMsg(TF_FTPLIST, "CFtpList::~CFtpList() this=%#08lx", this);
    if (m_pfnDestroy)
        DPA_DestroyCallback(m_hdpa, m_pfnDestroy, NULL);
    else
        DPA_Destroy(m_hdpa);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpList);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpList::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpList::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpList::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftppf.cpp ===
/*****************************************************************************
 *
 *	ftppf.cpp - Progress Feedback
 *
 *****************************************************************************/

#include "priv.h"

/*****************************************************************************
 *
 *	HPF - Handle to progress feedback
 *
 *	Shhh...  Don't tell anyone, but it's just a window handle.
 *
 *	It's the handle of the status bar window to use.  We use the
 *	second part (part number one, since they start at zero) to display
 *	connection feedback.
 *
 *	We don't use SIMPLE mode, because DefView uses SIMPLE mode to display
 *	menu feedback.
 *
 *****************************************************************************/

#define hwndNil	

/*****************************************************************************
 *
 *	FtpPf_Begin
 *
 *****************************************************************************/

HPF FtpPf_Begin(HWND hwndOwner)
{
    HWND hwnd;
    ASSERTNONCRITICAL;
    hwnd = Misc_FindStatusBar(hwndOwner);
    if (hwnd)
    {
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
    }
    return (HPF)hwnd;
}

/*****************************************************************************
 *
 *	FtpPf_Status
 *
 *	ids = string to display in status bar
 *	ptsz = optional insert
 *
 *****************************************************************************/

void FtpPf_Status(HPF hpf, UINT ids, LPCTSTR pszParameters)
{
    HWND hwnd = (HWND)hpf;

    ASSERTNONCRITICAL;
    if (EVAL(hwnd))
    {
	    TCHAR szMsgTemplate[256];
	    TCHAR szMessage[1024];

	    LoadString(g_hinst, ids, szMsgTemplate, ARRAYSIZE(szMsgTemplate));
	    wnsprintf(szMessage, ARRAYSIZE(szMessage), szMsgTemplate, pszParameters);
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, (LPARAM)szMessage);
	    UpdateWindow(hwnd);
    }
}

/*****************************************************************************
 *
 *	FtpPf_End
 *
 *****************************************************************************/

void FtpPf_End(HPF hpf)
{
    HWND hwnd;
    ASSERTNONCRITICAL;
    hwnd = (HWND)hpf;
    if (hwnd)
    {
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftppidl.h ===
/*****************************************************************************
 *
 *	ftppidl.h - LPITEMIDLIST management routines
 *
 *****************************************************************************/


#ifndef _FTPPIDL_H
#define _FTPPIDL_H


/****************************************************\
    FTP PIDL to URL functions
\****************************************************/
#ifdef UNICODE
#define UrlCreateFromPidl   UrlCreateFromPidlW
#else // UNICODE
#define UrlCreateFromPidl   UrlCreateFromPidlA
#endif // UNICODE


// Create FTP Pidl
HRESULT CreateFtpPidlFromFtpWirePath(LPCWIRESTR pwFtpWirePath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir);
HRESULT CreateFtpPidlFromDisplayPath(LPCWSTR pwzFullPath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir);


HRESULT CreateFtpPidlFromUrl(LPCTSTR pszName, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword);
HRESULT CreateFtpPidlFromUrlEx(LPCTSTR pszUrl, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword, BOOL fIsTypeKnown, BOOL fIsDir);
HRESULT CreateFtpPidlFromUrlPathAndPidl(LPCITEMIDLIST pidl, CWireEncoding * pwe, LPCWIRESTR pwFtpWirePath, LPITEMIDLIST * ppidl);

// Get Data from FTP Pidl
HRESULT UrlCreateFromPidlW(LPCITEMIDLIST pidl, DWORD shgno, LPWSTR pwzUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword);
HRESULT UrlCreateFromPidlA(LPCITEMIDLIST pidl, DWORD shgno, LPSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword);
HRESULT GetDisplayPathFromPidl(LPCITEMIDLIST pidl, LPWSTR pwzDisplayPath, DWORD cchUrlPathSize, BOOL fDirsOnly);
HRESULT GetWirePathFromPidl(LPCITEMIDLIST pidl, LPWIRESTR pwWirePath, DWORD cchUrlPathSize, BOOL fDirsOnly);



// Functions to work on an entire FTP PIDLs
BOOL FtpPidl_IsValid(LPCITEMIDLIST pidl);
BOOL FtpPidl_IsValidFull(LPCITEMIDLIST pidl);
BOOL FtpPidl_IsValidRelative(LPCITEMIDLIST pidl);
DWORD FtpPidl_GetVersion(LPCITEMIDLIST pidl);
BOOL FtpID_IsServerItemID(LPCITEMIDLIST pidl);
LPCITEMIDLIST FtpID_GetLastIDReferense(LPCITEMIDLIST pidl);

HRESULT FtpPidl_GetServer(LPCITEMIDLIST pidl, LPTSTR pszServer, DWORD cchSize);
BOOL FtpPidl_IsDNSServerName(LPCITEMIDLIST pidl);
HRESULT FtpPidl_GetUserName(LPCITEMIDLIST pidl, LPTSTR pszUserName, DWORD cchSize);
HRESULT FtpPidl_GetPassword(LPCITEMIDLIST pidl, LPTSTR pszPassword, DWORD cchSize, BOOL fIncludingHidenPassword);
HRESULT FtpPidl_GetDownloadTypeStr(LPCITEMIDLIST pidl, LPTSTR pszDownloadType, DWORD cchSize);
DWORD FtpPidl_GetDownloadType(LPCITEMIDLIST pidl);
INTERNET_PORT FtpPidl_GetPortNum(LPCITEMIDLIST pidl);
BOOL FtpPidl_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown);
ULONGLONG FtpPidl_GetFileSize(LPCITEMIDLIST pidl);
HRESULT FtpPidl_SetFileSize(LPCITEMIDLIST pidl, DWORD dwSizeHigh, DWORD dwSizeLow);
DWORD FtpPidl_GetAttributes(LPCITEMIDLIST pidl);
BOOL FtpPidl_HasPath(LPCITEMIDLIST pidl);
HRESULT FtpPidl_SetFileItemType(LPITEMIDLIST pidl, BOOL fIsDir);
HRESULT FtpPidl_GetFileInfo(LPCITEMIDLIST pidl, SHFILEINFO *psfi, DWORD rgf);
HRESULT FtpPidl_GetFileType(LPCITEMIDLIST pidl, LPTSTR pszType, DWORD cchSize);
HRESULT FtpPidl_GetFileTypeStrRet(LPCITEMIDLIST pidl, LPSTRRET pstr);
HRESULT FtpPidl_GetFragment(LPCITEMIDLIST pidl, LPTSTR pszFragment, DWORD cchSize);
HRESULT FtpPidl_SetAttributes(LPCITEMIDLIST pidl, DWORD dwAttribs);

HRESULT FtpPidl_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pwName, DWORD cchSize);
HRESULT FtpPidl_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize);
LPCWIRESTR FtpPidl_GetFileWireName(LPCITEMIDLIST pidl);
LPCWIRESTR FtpPidl_GetLastItemWireName(LPCITEMIDLIST pidl);
HRESULT FtpPidl_GetLastItemDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize);
HRESULT FtpPidl_GetLastFileDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize);
BOOL FtpPidl_IsAnonymous(LPCITEMIDLIST pidl);

HRESULT FtpPidl_ReplacePath(LPCITEMIDLIST pidlServer, LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidlOut);


#define FILEATTRIB_DIRSOFTLINK (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)
#define FtpPidl_IsDirSoftLink(pidl)        (FILEATTRIB_DIRSOFTLINK == (FILEATTRIB_DIRSOFTLINK & FtpPidl_GetAttributes(pidl)))
#define FtpPidl_IsSoftLink(pidl)        (FILE_ATTRIBUTE_REPARSE_POINT & FtpPidl_GetAttributes(pidl))


// WIN32_FIND_DATA normally stores the dates/times in a time zone independent (UTC)
// way, but FTP doesn't.  This requires conversions of dates when transfering
// from one to another.
FILETIME FtpPidl_GetFileTime(LPCITEMIDLIST pidl);   // Return value is UTC
FILETIME FtpPidl_GetFTPFileTime(LPCITEMIDLIST pidl);    // Return value is in Local Time Zone.
void FtpItemID_SetFileTime(LPCITEMIDLIST pidl, FILETIME fileTime);   // fileTime is in UTC
HRESULT Win32FindDataFromPidl(LPCITEMIDLIST pidl, LPWIN32_FIND_DATA pwfd, BOOL fFullPath, BOOL fInDisplayFormat);
HRESULT FtpPidl_SetFileTime(LPCITEMIDLIST pidl, FILETIME ftTimeDate);   // ftTimeDate In UTC

HRESULT FtpPidl_InsertVirtualRoot(LPCITEMIDLIST pidlVirtualRoot, LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidl);

BOOL IsFtpPidlQuestionable(LPCITEMIDLIST pidl);

#define FtpPidl_DirChoose(pidl, dir, file)  (FtpPidl_IsDirectory(pidl, TRUE) ? dir : file)

LPITEMIDLIST ILCloneFirstItemID(LPITEMIDLIST pidl);


/****************************************************\
    FTP Individual ServerID/ItemID functions
\****************************************************/

// Ftp ServerID Helper Functions
HRESULT FtpServerID_GetServer(LPCITEMIDLIST pidl, LPTSTR szServer, DWORD cchSize);
BOOL FtpServerID_ServerStrCmp(LPCITEMIDLIST pidl, LPCTSTR pszServer);
HRESULT FtpServerID_SetHiddenPassword(LPITEMIDLIST pidl, LPCTSTR pszPassword);
DWORD FtpServerID_GetTypeID(LPCITEMIDLIST pidl);
INTERNET_PORT FtpServerID_GetPortNum(LPCITEMIDLIST pidl);
HRESULT FtpServerID_Create(LPCTSTR pszServer, LPCTSTR pszUserName, LPCTSTR pszPassword, 
                     DWORD dwFlags, INTERNET_PORT ipPortNum, LPITEMIDLIST * ppidl, IMalloc *pm, BOOL fHidePassword);


// Ftp ItemID Creation Functions
HRESULT FtpItemID_CreateFake(LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, BOOL fTypeKnown, BOOL fIsFile, BOOL fIsFragment, LPITEMIDLIST * ppidl);
HRESULT FtpItemID_CreateReal(const LPFTP_FIND_DATA pwfd, LPCWSTR pwzDisplayName, LPITEMIDLIST * ppidl);


// Ftp ItemID Helper Functions
HRESULT FtpItemID_CreateWithNewName(LPCITEMIDLIST pidl, LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, LPITEMIDLIST * ppidlOut);
HRESULT FtpItemID_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize);
HRESULT FtpItemID_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pszName, DWORD cchSize);
HRESULT FtpItemID_GetFragment(LPCITEMIDLIST pidl, LPTSTR pszName, DWORD cchSize);
HRESULT FtpItemID_GetNameA(LPCITEMIDLIST pidl, LPSTR pszName, DWORD cchSize);
BOOL FtpItemID_IsFragment(LPCITEMIDLIST pidl);
BOOL FtpItemID_IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL FtpPidl_IsPathEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL FtpItemID_IsParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
LPCITEMIDLIST FtpItemID_FindDifference(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);

DWORD FtpItemID_GetAttributes(LPCITEMIDLIST pidl);
DWORD FtpItemID_SetDirAttribute(LPCITEMIDLIST pidl);
HRESULT FtpItemID_SetAttributes(LPCITEMIDLIST pidl, DWORD dwFileAttributes);
DWORD FtpItemID_GetUNIXPermissions(LPCITEMIDLIST pidl);
HRESULT FtpItemID_SetUNIXPermissions(LPCITEMIDLIST pidl, DWORD dwFileAttributes);

LPCWIRESTR FtpItemID_GetWireNameReference(LPCITEMIDLIST pidl);
LPCUWSTR FtpItemID_GetDisplayNameReference(LPCITEMIDLIST pidl);

ULONGLONG FtpItemID_GetFileSize(LPCITEMIDLIST pidl);
void FtpItemID_SetFileSize(LPCITEMIDLIST pidl, ULARGE_INTEGER uliFileSize);
DWORD FtpItemID_GetFileSizeLo(LPCITEMIDLIST pidl);
DWORD FtpItemID_GetFileSizeHi(LPCITEMIDLIST pidl);

DWORD FtpItemID_GetCompatFlags(LPCITEMIDLIST pidl);
HRESULT FtpItemID_SetCompatFlags(LPCITEMIDLIST pidl, DWORD dwCompatFlags);

BOOL FtpItemID_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown);

// Flags for FtpItemID dwCompatFlags
#define COMPAT_APPENDSLASHTOURL   0x00000001

// Flags for dwCompFlags
#define FCMP_NORMAL             0x00000000
#define FCMP_GROUPDIRS          0x00000001
#define FCMP_CASEINSENSE        0x00000002

HRESULT FtpItemID_CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags);
int FtpItemID_CompareIDsInt(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags);



LPITEMIDLIST FtpCloneServerID(LPCITEMIDLIST pidl);
HRESULT PurgeSessionKey(void);

// NOT USED
//HRESULT CreateFtpPidlFromFindData(LPCTSTR pszBaseUrl, const LPWIN32_FIND_DATA pwfd, LPITEMIDLIST * ppidl, IMalloc * pm);
//HRESULT UrlGetFileNameFromPidl(LPCITEMIDLIST pidl, LPTSTR pszFileName, DWORD cchSize);
//HRESULT FtpServerID_CopyHiddenPassword(LPCITEMIDLIST pidlSrc, LPITEMIDLIST pidlDest);


#endif // _FTPPIDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftppl.cpp ===
/*****************************************************************************
 *
 *    ftppl.cpp - FTP LPITEMIDLIST List object
 *
 *****************************************************************************/

#include "priv.h"
#include "ftppl.h"
#include "ftpurl.h"

typedef struct tagINETENUM
{
    HINTERNET               hint;
    BOOL *                  pfValidhinst;
    LPVOID                  pvData;
    LPFNPROCESSITEMCB       pfnProcessItemCB;
    LPCITEMIDLIST           pidlRoot;
    HRESULT                 hr;
} INETENUM;


/*****************************************************************************\
     FUNCTION: RecursiveEnum
 
    DESCRIPTION:
        This function will pack the parameters needed during the enum.
\*****************************************************************************/
HRESULT CFtpPidlList::RecursiveEnum(LPCITEMIDLIST pidlRoot, LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPVOID pvData)
{
    INETENUM inetEnum = {hint, NULL, pvData, pfnProcessItemCB, pidlRoot, S_OK};

    Enum(RecursiveProcessPidl, (LPVOID) &inetEnum);

    return inetEnum.hr;
}


// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int CFtpPidlList::ComparePidlName(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam)
{
    DWORD dwFlags = FCMP_NORMAL;

    if (lParam)
        dwFlags |= FCMP_CASEINSENSE;

    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    return FtpItemID_CompareIDsInt(COL_NAME, (LPCITEMIDLIST)pvPidl1, (LPCITEMIDLIST)pvPidl2, dwFlags);
}


HRESULT CFtpPidlList::InsertSorted(LPCITEMIDLIST pidl)
{
    m_pfl->InsertSorted(ILClone(pidl), CFtpPidlList::ComparePidlName, FALSE /*Case Insensitive*/);
    return S_OK;
};


int CFtpPidlList::FindPidlIndex(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive)
{
    return m_pfl->SortedSearch((LPVOID) pidlToFind, CFtpPidlList::ComparePidlName, (LPARAM)fCaseInsensitive, DPAS_SORTED);
}


LPITEMIDLIST CFtpPidlList::FindPidl(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive)
{
    LPITEMIDLIST pidlFound = NULL;
    int nIndex = FindPidlIndex(pidlToFind, fCaseInsensitive);

    if (-1 != nIndex)
    {
        pidlFound = ILClone(GetPidl(nIndex));
    }

    return pidlFound;
}


HRESULT CFtpPidlList::CompareAndDeletePidl(LPCITEMIDLIST pidlToDelete)
{
    HRESULT hr = S_FALSE;
    int nIndex = FindPidlIndex(pidlToDelete, FALSE /*Case Insensitive*/);

    if (-1 != nIndex)
    {
        LPITEMIDLIST pidlCurrent = GetPidl((UINT)nIndex);
        if (EVAL(pidlCurrent))
        {
            ASSERT(0 == FtpItemID_CompareIDsInt(COL_NAME, pidlCurrent, pidlToDelete, FCMP_NORMAL));
            m_pfl->DeletePtrByIndex(nIndex);
            ILFree(pidlCurrent);    // Deallocate the memory
            hr = S_OK;  // Found and deleted.
        }
    }

    return hr;
}


void CFtpPidlList::Delete(int nIndex)
{
    LPITEMIDLIST pidlToDelete = GetPidl(nIndex);

    ILFree(pidlToDelete);   // Free the memory.
    m_pfl->DeletePtrByIndex(nIndex);
}


HRESULT CFtpPidlList::ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest)
{
    HRESULT hr = S_FALSE;
    int nIndex = FindPidlIndex(pidlSrc, FALSE);

    if (-1 != nIndex)
    {
        LPITEMIDLIST pidlCurrent = GetPidl((UINT)nIndex);
        if (EVAL(pidlCurrent))
        {
            ASSERT(0 == FtpItemID_CompareIDsInt(COL_NAME, pidlCurrent, pidlSrc, FCMP_NORMAL));
            ILFree(pidlCurrent);    // Deallocate the memory
            m_pfl->DeletePtrByIndex(nIndex);
            InsertSorted(pidlDest);         // This function does the ILClone()
            hr = S_OK;  // Found and deleted.
        }
    }

    return hr;
}

void CFtpPidlList::AssertSorted(void)
{
#ifdef DEBUG
    // For perf reasons, we need to keep this list in order.
    // This is mainly because parse display name looks thru
    // the list, so we want that to be fast.
    for (int nIndex = (GetCount() - 2); (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl1 = GetPidl((UINT)nIndex);
        LPITEMIDLIST pidl2 = GetPidl((UINT)nIndex + 1);

        // Assert that pidl1 comes before pidl2.
        if (!EVAL(0 >= FtpItemID_CompareIDsInt(COL_NAME, pidl1, pidl2, FCMP_NORMAL)))
        {
            TCHAR szPidl1[MAX_PATH];
            TCHAR szPidl2[MAX_PATH];

            if (FtpID_IsServerItemID(pidl1))
                FtpPidl_GetServer(pidl1, szPidl1, ARRAYSIZE(szPidl1));
            else
                FtpPidl_GetDisplayName(pidl1, szPidl1, ARRAYSIZE(szPidl1));

            if (FtpID_IsServerItemID(pidl2))
                FtpPidl_GetServer(pidl2, szPidl2, ARRAYSIZE(szPidl2));
            else
                FtpPidl_GetDisplayName(pidl2, szPidl2, ARRAYSIZE(szPidl2));

            TraceMsg(TF_ERROR, "CFtpPidlList::AssertSorted() '%s' & '%s' where found out of order", szPidl1, szPidl2);
        }
        // We do NOT need to free pidl1 or pidl2 because we get a pointer to someone else's copy.
    }

#endif // DEBUG
}


void CFtpPidlList::TraceDump(LPCITEMIDLIST pidl, LPCTSTR pszCaller)
{
#ifdef DEBUG
/*
    TCHAR szUrl[MAX_URL_STRING];

    UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_USERNAME, FALSE);
    TraceMsg(TF_PIDLLIST_DUMP, "CFtpPidlList::TraceDump() root is '%s', called from '%s'", szUrl, pszCaller);

    // Let's look at the contents.
    for (int nIndex = (GetCount() - 1); (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidlFull = ILCombine(pidl, GetPidl((UINT)nIndex));

        if (pidlFull)
        {
            UrlCreateFromPidl(pidlFull, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_USERNAME, FALSE);
            TraceMsg(TF_PIDLLIST_DUMP, "CFtpPidlList::TraceDump() Index=%d, url=%s", nIndex, szUrl);
            ILFree(pidlFull);
        }
    }
*/
#endif // DEBUG
}

void CFtpPidlList::UseCachedDirListings(BOOL fUseCachedDirListings)
{
    // Normally we do two passes in the tree walker code.  The first
    // pass is to count up the time required to do the download. We
    // normally force WININET to not use cached results because someone
    // else could have changed the contents on the server.
    // On the second pass, we normally do the work (upload, download, delete)
    // and we want to use the cached results to get the perf advantage
    // and the results shouldn't be more than a minute out of date.

    if (fUseCachedDirListings)
        m_dwInetFlags = INTERNET_NO_CALLBACK;
    else
        m_dwInetFlags = (INTERNET_NO_CALLBACK | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD);
}

BOOL CFtpPidlList::AreAllFolders(void)
{
    BOOL fAllFolder = TRUE;

    for (int nIndex = (GetCount() - 1); fAllFolder && (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl = GetPidl((UINT)nIndex);
        if (EVAL(pidl))
            fAllFolder = FtpPidl_IsDirectory(pidl, TRUE);

        // We do NOT need to free pidl because we get a pointer to someone else's copy.
    }

    return fAllFolder;
}


BOOL CFtpPidlList::AreAllFiles(void)
{
    BOOL fAllFiles = TRUE;

    for (int nIndex = (GetCount() - 1); fAllFiles && (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl = GetPidl((UINT)nIndex);
        if (EVAL(pidl))
            fAllFiles = !FtpPidl_IsDirectory(pidl, TRUE);

        // We do NOT need to free pidl because we get a pointer to someone else's copy.
    }

    return fAllFiles;
}


/*****************************************************************************
 *
 *    CFtpPidlList::_Fill
 *
 *    Fill a list with an array.
 *
 *    The elements in the array are copied rather than stolen.
 *
 *****************************************************************************/

HRESULT CFtpPidlList::_Fill(int cpidl, LPCITEMIDLIST rgpidl[])
{
    HRESULT hres = S_OK;

    for (int ipidl = 0; (ipidl < cpidl) && SUCCEEDED(hres); ipidl++)
    {
        ASSERT(IsValidPIDL(rgpidl[ipidl]));
        hres = InsertSorted(rgpidl[ipidl]);
    }

    return hres;
}


/*****************************************************************************
 *
 *    CFtpPidlList::GetPidlList
 *
 *****************************************************************************/

LPCITEMIDLIST * CFtpPidlList::GetPidlList(void)
{
    LPITEMIDLIST * ppidl;

    ppidl = (LPITEMIDLIST *) LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * GetCount());
    if (ppidl)
    {
        int nIndex;

        for (nIndex = 0; nIndex < GetCount(); nIndex++)
        {
            // Later we can make this user ILClone() if we want to be able to wack on the
            // pidl list while this list is being used.
            ppidl[nIndex] = GetPidl(nIndex);
        }
    }

    return (LPCITEMIDLIST *) ppidl;
}


/*****************************************************************************
 *
 *    CFtpPidlList::FreePidlList
 *
 *****************************************************************************/

void CFtpPidlList::FreePidlList(LPCITEMIDLIST * ppidl)
{
    LocalFree(ppidl);
}


/*****************************************************************************
 *
 *    CFtpPidlList_Create
 *
 *    Start up a new pv list, with a recommended initial size and other
 *    callback info.
 *
 *****************************************************************************/

HRESULT CFtpPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CFtpPidlList ** ppflpidl)
{
    HRESULT hres = E_OUTOFMEMORY;
    CFtpPidlList * pflpidl;
    *ppflpidl = pflpidl = new CFtpPidlList();

    if (pflpidl)
    {
        hres = pflpidl->_Fill(cpidl, rgpidl);

        if (!EVAL(SUCCEEDED(hres)))
        {
            ASSERT(pflpidl->GetCount() == 0);
            IUnknown_Set(ppflpidl, NULL);
        }
    }

    return hres;
}


int CALLBACK PidlListDestroyCallback(LPVOID p, LPVOID pData)
{
    ILFree((LPITEMIDLIST) p);
    return 1;
}


/****************************************************\
    Constructor
\****************************************************/
CFtpPidlList::CFtpPidlList() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfl);
    
    CFtpList_Create(100, PidlListDestroyCallback, 100, &m_pfl);
    ASSERT(m_pfl); // BUGBUG can fail in low memory
    UseCachedDirListings(FALSE);

    LEAK_ADDREF(LEAK_CFtpPidlList);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpPidlList::~CFtpPidlList()
{
    AssertSorted();
    if (m_pfl)
        m_pfl->Release();

    DllRelease();
    LEAK_DELREF(LEAK_CFtpPidlList);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpPidlList::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpPidlList::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpPidlList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpPidlList::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


////////////////////////////////////////////////////////////////////
// Pild List Enum Helpers
////////////////////////////////////////////////////////////////////

/*****************************************************************************\
     FUNCTION: RecursiveProcessPidl
 
    DESCRIPTION:
        This function will will be called for each item in the initial Pidl List
    (before the recursion occurs).  This is a wrapper because the first list is
    a list of pidls.  The subsequent lists are of WIN32_FIND_DATA types.
\*****************************************************************************/
int RecursiveProcessPidl(LPVOID pvPidl, LPVOID pvInetEnum)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    INETENUM * pInetEnum = (INETENUM *) pvInetEnum;
    LPITEMIDLIST pidlFull = ILCombine(pInetEnum->pidlRoot, pidl);

    if (pidlFull)
    {
        pInetEnum->hr = pInetEnum->pfnProcessItemCB((LPVOID) pInetEnum->pfnProcessItemCB, pInetEnum->hint, pidlFull, pInetEnum->pfValidhinst, pInetEnum->pvData);
        ILFree(pidlFull);
    }

    return (SUCCEEDED(pInetEnum->hr) ? TRUE : FALSE);
}


/*****************************************************************************\
     FUNCTION: _EnumFolderPrep
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET FTP APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.
\*****************************************************************************/
HRESULT _EnumFolderPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, CFtpPidlList * pPidlList, CWireEncoding * pwe, LPITEMIDLIST * ppidlCurrFtpPath)
{
    HRESULT hr = S_OK;

    // 1. Get Current Directory (To restore later).
    hr = FtpGetCurrentDirectoryPidlWrap(hint, TRUE, pwe, ppidlCurrFtpPath);
    if (SUCCEEDED(hr))
    {
        CMultiLanguageCache cmlc;
        CWireEncoding we;

        if (!pwe)
            pwe = &we;

        // It's important that this is a relative CD.
        // 2. Change Directory Into the subdirectory.   
        hr = FtpSetCurrentDirectoryWrap(hint, TRUE, FtpPidl_GetLastItemWireName(pidlFull));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlItem;
            HINTERNET hInetFind = NULL;

            hr = FtpFindFirstFilePidlWrap(hint, TRUE, &cmlc, pwe, NULL, &pidlItem, pPidlList->m_dwInetFlags, NULL, &hInetFind);
            if (hInetFind)
            {
                do
                {
                    LPCWIRESTR pwireStr = FtpPidl_GetLastItemWireName(pidlFull);
                    if (IS_VALID_FILE(pwireStr))
                    {
                        // Store entire pidl (containing WIN32_FIND_DATA) so we can get
                        // the attributes and other info later.  Seeing if it's a dir
                        // is one need...
                        pPidlList->InsertSorted(pidlItem);
                    }

                    ILFree(pidlItem);
                    hr = InternetFindNextFilePidlWrap(hInetFind, TRUE, &cmlc, pwe, &pidlItem);
                }
                while (SUCCEEDED(hr));
            
                ILFree(pidlItem);
                InternetCloseHandle(hInetFind);
            }

            if (ERROR_NO_MORE_FILES == HRESULT_CODE(hr))
                hr = S_OK;
        }

        EVAL(SUCCEEDED(pwe->ReSetCodePages(&cmlc, pPidlList)));
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: _GetPathDifference
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET FTP APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.

    PARAMETERS:
        pszBaseUrl - This needs to be escaped.
        pszDir - This needs to be escaped.
        *ppszUrlPathDiff - This will be UnEscaped.
\*****************************************************************************/
void _GetPathDifference(LPCTSTR pszBaseUrl, LPCTSTR pszDir, LPTSTR * ppszUrlPathDiff)
{
    TCHAR szUrlPathDiff[MAX_URL_STRING];
    TCHAR szFullUrl[MAX_URL_STRING];
    DWORD cchSize = ARRAYSIZE(szFullUrl);

    // This is needed for this case:
    // pszBaseUrl="ftp://server/subdir1/", pszDir="/subdir1/subdir2/file.txt"
    // So, szUrlPathDiff="subdir2/file.txt" instead of pszDir
    //
    // ICU_NO_ENCODE is needed because Download Dlg may have paths with
    // spaces that can't be escaped.
    InternetCombineUrl(pszBaseUrl, pszDir, szFullUrl, &cchSize, ICU_NO_ENCODE);
    UrlGetDifference(pszBaseUrl, szFullUrl, szUrlPathDiff, ARRAYSIZE(szUrlPathDiff));

    // We will now use szFullUrl to store the UnEscaped version since these buffers
    // are so large.
    UnEscapeString(szUrlPathDiff, szFullUrl, ARRAYSIZE(szFullUrl));
    Str_SetPtr(ppszUrlPathDiff, szFullUrl);
}


/*****************************************************************************\
     FUNCTION: EnumFolder
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    PARAMETERS:
        (pszBaseUrl=ftp://server/dir1/, pszDir=dir2, DirToEnum=ftp://server/dir1/dir2/)
        pszDir - This is the directory we are enumerating. (dir2)  It is relative to pszBaseUrl.
        hint - The current working directory will be set to pszBaseUrl.  _EnumFolderPrep will make it go into pszDir.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET FTP APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.
\*****************************************************************************/
HRESULT EnumFolder(LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, CWireEncoding * pwe, BOOL * pfValidhinst, LPVOID pvData)
{
    CFtpPidlList * pPidlList;
    BOOL fValidhinst = TRUE;

    HRESULT hr = CFtpPidlList_Create(0, &pidlFull, &pPidlList);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlCurrFtpPath = NULL;

        hr = _EnumFolderPrep(hint, pidlFull, pPidlList, pwe, &pidlCurrFtpPath);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            // 4. Process each file name, which may be recursive.
            // This loop and the while loop above need to be
            // separated because it's not possible to create
            // more than one FTP Find File handle based on the
            // same session.
            for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < pPidlList->GetCount()); nIndex++)
            {
                LPITEMIDLIST pidlNewFull = ILCombine(pidlFull, pPidlList->GetPidl(nIndex));

                hr = pfnProcessItemCB(pfnProcessItemCB, hint, pidlNewFull, &fValidhinst, pvData);
                ILFree(pidlNewFull);
            }

            // 5. Go back to original directory (from Step 2)
            // The only time we don't want to return to the original directory is if
            // the hinst was freed in an wininet callback function.  We may cache the hinst
            // so we need the directory to be valid later.
            if (fValidhinst)
            {
                if (SUCCEEDED(hr))
                {
                    // We still want to reset the directory but we don't want to over write
                    // the original error message.
                    hr = FtpSetCurrentDirectoryPidlWrap(hint, TRUE, pidlCurrFtpPath, TRUE, TRUE);
                }
            }

            Pidl_Set(&pidlCurrFtpPath, NULL);
        }

        pPidlList->Release();
    }

    if (pfValidhinst)
        *pfValidhinst = fValidhinst;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftppl.h ===
/*****************************************************************************
 *	ftppl.h
 *****************************************************************************/

#ifndef _FTPPIDLLIST_H
#define _FTPPIDLLIST_H


#include "ftplist.h"

typedef HRESULT (CALLBACK *LPFNPROCESSITEMCB)(LPVOID pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData);

HRESULT EnumFolder(LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, CWireEncoding * pwe, BOOL * pfValidhinst, LPVOID pvData);
int RecursiveProcessPidl(LPVOID pvPidl, LPVOID pvInetEnum);


/*****************************************************************************
 *
 *	CFtpPidlList
 *
 *****************************************************************************/

class CFtpPidlList      : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CFtpPidlList();
    ~CFtpPidlList(void);

    // Public Member Functions
    HRESULT CompareAndDeletePidl(LPCITEMIDLIST pidl);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest);
    HRESULT InsertSorted(LPCITEMIDLIST pidl);
    HRESULT RecursiveEnum(LPCITEMIDLIST pidlRoot, LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPVOID pvData);
    void Enum(PFNDPAENUMCALLBACK pfn, LPVOID pv) { m_pfl->Enum(pfn, pv); };
    void DeletePidl(LPITEMIDLIST pidl) { m_pfl->DeleteItemPtr((LPVOID) pidl);  ILFree(pidl); };
    void Delete(int nIndex);
    int GetCount(void)  { return m_pfl->GetCount(); };
    int FindPidlIndex(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive);
    LPITEMIDLIST GetPidl(UINT ipv) { return (LPITEMIDLIST) m_pfl->GetItemPtr(ipv); };   // TODO: Rename GetPidlReference()
    LPITEMIDLIST FindPidl(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive);
    BOOL AreAllFolders(void);
    BOOL AreAllFiles(void);

    LPCITEMIDLIST * GetPidlList(void);
    void FreePidlList(LPCITEMIDLIST * ppidl);
    void TraceDump(LPCITEMIDLIST pidl, LPCTSTR pszCaller);

    void UseCachedDirListings(BOOL fUseCachedDirListings);

    // Friend Functions
    static int CFtpPidlList::ComparePidlName(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam);
    friend HRESULT CFtpPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CFtpPidlList ** ppfl);
    friend HRESULT _EnumFolderPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, CFtpPidlList * pPidlList, CWireEncoding * pwe, LPITEMIDLIST * ppidlCurrFtpPath);

protected:
    // Private Member Variables
    int                     m_cRef;

    CFtpList *              m_pfl;
    CWireEncoding *         m_pwe;          // We don't hold a ref, so we assume the object will outlive us.
    DWORD                   m_dwInetFlags;  // What flags do we want to set for enumeration?

    // Private Member Functions
    HRESULT _Fill(int cpidl, LPCITEMIDLIST rgpidl[]);
    void AssertSorted(void);
};


#endif // _FTPPIDLLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpobj.h ===
/*****************************************************************************\
    FILE: ftpobj.h
\*****************************************************************************/

#ifndef _FTPOBJ_H
#define _FTPOBJ_H

#include "ftpefe.h"


typedef struct
{
    DVTARGETDEVICE dvTargetDevice;
    FORMATETC formatEtc;
    STGMEDIUM medium;
} FORMATETC_STGMEDIUM;


/*****************************************************************************\
    CLASS: CFtpObj

    Careful!  The elements of m_stgCache are rather weird due to delayed
    rendering.  If m_stgCache[].tymed == TYMED_HGLOBAL but
    m_stgCache[].hGlobal == 0, then the FORMATETC exists in the DataObject,
    but hasn't been rendered yet.

    It will be rendered when you call CFtpObj::_ForceRender().

    This weirdness with delayed rendering means that you have to be
    careful when you try to access the gizmo.

    1. Before trying to use the gizmo, use CFtpObj::_ForceRender().
    2. When trying to free the gizmo, use CFtpObj::_ReleasePstg().

    Yet another weirdness with m_stgCache is that all hGlobal's have a
    special babysitter pUnkForRelease.  This is important so that
    interactions between CFtpObj::GetData and CFtpObj::SetData are isolated.

    (If you were lazy and used the CFtpObj itself as the pUnkForRelease,
    then you'd run into trouble if somebody tried to SetData into the
    data object, which overwrites an hGlobal you had previously given away.)

    m_nStartIndex/m_nEndIndex: We give out a list of FILEDESCRIPTORS in the
    FILEGROUPDESCRIPTOR.  If the directory attribute is set, the caller will
    just create the directory.  If it's a file, it will call IDataObject::GetData()
    with DROP_FCont.  We would like to display progress on the old shell because
    it normally doesn't display progress until NT5.  We need to decide when to start
    and stop.  We set m_nStartIndex to -1 to indicate that we don't know.  When we
    get a DROP_FCont call, we then calculate the first and the last.  We will then
    display the progress dialog until the caller has either called the last one or
    errored out.

    The data is kept in two places.  The data we offer and render is in m_stgCache.
    The data we will carry is stored in m_hdsaSetData.
\*****************************************************************************/
class CFtpObj           : public IDataObject
                        , public IPersistStream
                        , public IInternetSecurityMgrSite
                        , public IAsyncOperation
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IDataObject ***
    virtual STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    virtual STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    virtual STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    virtual STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    virtual STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    virtual STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    virtual STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, DWORD * pdwConnection);
    virtual STDMETHODIMP DUnadvise(DWORD dwConnection);
    virtual STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);
    
    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_FtpDataObject; return S_OK; }
    
    // *** IPersistStream ***
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);

    // *** IInternetSecurityMgrSite ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { if (phwnd) *phwnd = NULL; return S_OK; };
    virtual STDMETHODIMP EnableModeless(BOOL fEnable) {return E_NOTIMPL;};

    // *** IAsyncOperation methods ***
    virtual STDMETHODIMP SetAsyncMode(BOOL fDoOpAsync) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetAsyncMode(BOOL * pfIsOpAsync);
    virtual STDMETHODIMP StartOperation(IBindCtx * pbcReserved);
    virtual STDMETHODIMP InOperation(BOOL * pfInAsyncOp);
    virtual STDMETHODIMP EndOperation(HRESULT hResult, IBindCtx * pbcReserved, DWORD dwEffects);

public:
    CFtpObj();
    ~CFtpObj(void);

    // Public Member Functions
    static int _DSA_FreeCB(LPVOID pvItem, LPVOID pvlparam);
    CFtpPidlList * GetHfpl() { return m_pflHfpl;};

    // Friend Functions
    friend HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpObj ** ppfo);
    friend HRESULT CFtpObj_Create(REFIID riid, void ** ppvObj);
    friend class CFtpEfe;

protected:
    // Private Member Variables
    int                     m_cRef;

    CFtpFolder *            m_pff;          // My dad
    CFtpDir *               m_pfd;          // My dad's home
    CFtpPidlList *          m_pflHfpl;      // List/Array of pidls
    STGMEDIUM               m_stgCache[DROP_MAX];
    HDSA                    m_hdsaSetData;  // Array of SetData.  Each item is a FORMATETC_STGMEDIUM.

    // Members for Progress on Legacy systems.
    IProgressDialog *       m_ppd;
    ULARGE_INTEGER          m_uliCompleted;
    ULARGE_INTEGER          m_uliTotal;
    int                     m_nStartIndex;  // Commented above in CLASS: CFtpObj
    int                     m_nEndIndex;    // Commented above in CLASS: CFtpObj
    BOOL                    m_fFGDRendered; // Did we expand m_pflHfpl?
    BOOL                    m_fCheckSecurity;  // TRUE means check security and display UI.  FALSE means it's unsafe and cancel w/o UI because it was already shown..
    BOOL                    m_fDidAsynchStart; // Did the IDropTarget call IAsynchDataObject::StartOperation() to start the copy? (To show he supports it)
    BOOL                    m_fErrAlreadyDisplayed; // Did was already display the error?
    IUnknown *              m_punkThreadRef; // Don't allow the browser closing to cancel our drag/drop operation.

    // Private Member Functions
    void _CheckStg(void);
    BOOL _IsLindexOkay(int ife, FORMATETC *pfeWant);
    HRESULT _FindData(FORMATETC *pfe, PINT piOut);
    HRESULT _FindDataForGet(FORMATETC *pfe, PINT piOut);
    HGLOBAL _DelayRender_FGD(BOOL fUnicode);
    HRESULT _DelayRender_IDList(STGMEDIUM * pStgMedium);
    HRESULT _DelayRender_URL(STGMEDIUM * pStgMedium);
    HRESULT _DelayRender_PrefDe(STGMEDIUM * pStgMedium);
    HRESULT _RenderOlePersist(STGMEDIUM * pStgMedium);
    HRESULT _RenderFGD(int nIndex, STGMEDIUM * pStgMedium);
    HRESULT _ForceRender(int ife);
    HRESULT _RefThread(void);
    CFtpPidlList * _ExpandPidlListRecursively(CFtpPidlList * ppidlListSrc);

    int _FindExtraDataIndex(FORMATETC *pfe);
    HRESULT _SetExtraData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease);
    HRESULT _RenderFileContents(LPFORMATETC pfe, LPSTGMEDIUM pstg);

    HRESULT _DoProgressForLegacySystemsPre(void);
    HRESULT _DoProgressForLegacySystemsStart(LPCITEMIDLIST pidl, int nIndex);
    HRESULT _DoProgressForLegacySystemsPost(LPCITEMIDLIST pidl, BOOL fLast);
    HRESULT _SetProgressDialogValues(int nIndex);
    HRESULT _CloseProgressDialog(void);
};

#endif // _FTPOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpobj.cpp ===
/*****************************************************************************
 *
 *    ftpobj.cpp - IDataObject interface
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpobj.h"
#include "ftpurl.h"
#include <shlwapi.h>


// CLSIDs
// {299D0193-6DAA-11d2-B679-006097DF5BD4}
const GUID CLSID_FtpDataObject = { 0x299d0193, 0x6daa, 0x11d2, 0xb6, 0x79, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 };

/*****************************************************************************
 *
 *    g_dropTypes conveniently mirrors our FORMATETCs.
 *
 *    Hardly coincidence, of course.  Enum_Fe did the real work.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *    Preinitialized global data.
 *
 *****************************************************************************/
FORMATETC g_formatEtcOffsets;
FORMATETC g_formatPasteSucceeded;
CLIPFORMAT g_cfTargetCLSID;

FORMATETC g_dropTypes[] =
{
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_ISTREAM },  // DROP_FCont
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_FGDW
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_FGDA
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_IDList
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_URL
//    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_Offsets
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_PrefDe
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_PerfDe
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_FTP_PRIVATE
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_OLEPERSIST - see _RenderOlePersist() for desc.
    { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_Hdrop
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }, // DROP_FNMA
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }  // DROP_FNMW
};



/*****************************************************************************\
    GLOBAL: c_stgInit

    DESCRIPTION:
        Mostly straightforward.  The only major weirdness is that cfURL
    is delay-rendered iff the m_pflHfpl contains only one object.  Otherwise,
    cfURL is not supported.  (URLs can refer to only one object at a time.)
\*****************************************************************************/
STGMEDIUM c_stgInit[] =
{
    { 0, 0, 0 },  // DROP_FCont
    { TYMED_HGLOBAL, 0, 0 },    // DROP_FGDW - delay-rendered
    { TYMED_HGLOBAL, 0, 0 },    // DROP_FGDA - delay-rendered
    { TYMED_HGLOBAL, 0, 0 },    // DROP_IDList - delay-rendered
    { 0, 0, 0 },                // DROP_URL - opt delay-rendered
//    { 0, 0, 0 },                // DROP_Offsets
    { TYMED_HGLOBAL, 0, 0 },    // DROP_PrefDe - delay-rendered
    { 0, 0, 0 },                // DROP_PerfDe
    { TYMED_HGLOBAL, 0, 0 },    // DROP_FTP_PRIVATE
    { TYMED_HGLOBAL, 0, 0 },    // DROP_OLEPERSIST - see _RenderOlePersist() for desc.
    { 0, 0, 0 },                // DROP_Hdrop
    { 0, 0, 0 },                // DROP_FNMA
    { 0, 0, 0 }                 // DROP_FNMW
};



/*****************************************************************************\
    FUNCTION: TraceMsgWithFormatEtc

    DESCRIPTION:
\*****************************************************************************/
void TraceMsgWithFormat(DWORD dwFlags, LPCSTR pszBefore, LPFORMATETC pFormatEtc, LPCSTR pszAfter, HRESULT hr)
{
#ifdef DEBUG
    TCHAR szFormatName[MAX_PATH];
    TCHAR szMedium[MAX_PATH];

    szFormatName[0] = 0;
    szMedium[0] = 0;
    if (pFormatEtc)
    {
        // This may fail if it's a basic format.
        if (!GetClipboardFormatName(pFormatEtc->cfFormat, szFormatName, ARRAYSIZE(szFormatName)))
            wnsprintf(szFormatName, ARRAYSIZE(szFormatName), TEXT("Pre-defined=%d"), pFormatEtc->cfFormat);

        switch (pFormatEtc->tymed)
        {
        case TYMED_HGLOBAL: StrCpyN(szMedium, TEXT("HGLOBAL"), ARRAYSIZE(szMedium)); break;
        case TYMED_FILE: StrCpyN(szMedium, TEXT("File"), ARRAYSIZE(szMedium)); break;
        case TYMED_GDI: StrCpyN(szMedium, TEXT("GDI"), ARRAYSIZE(szMedium)); break;
        case TYMED_MFPICT: StrCpyN(szMedium, TEXT("MFPICT"), ARRAYSIZE(szMedium)); break;
        case TYMED_ENHMF: StrCpyN(szMedium, TEXT("ENHMF"), ARRAYSIZE(szMedium)); break;
        case TYMED_ISTORAGE: StrCpyN(szMedium, TEXT("ISTORAGE"), ARRAYSIZE(szMedium)); break;
        case TYMED_ISTREAM: StrCpyN(szMedium, TEXT("ISTREAM"), ARRAYSIZE(szMedium)); break;
        }
    }
    else
    {
        szMedium[0] = 0;
    }

    TraceMsg(dwFlags, "%hs [FRMTETC: %ls, lndx: %d, %ls] hr=%#08lx, %hs", pszBefore, szFormatName, pFormatEtc->lindex, szMedium, hr, pszAfter);
#endif // DEBUG
}


/*****************************************************************************\
    FUNCTION: _IsLindexOkay
 
   DESCRIPTION:
    If ife != DROP_FCont, then pfeWant->lindex must be -1.
 
    If ife == DROP_FCont, then pfeWant->lindex must be in the range
    0 ... m_pflHfpl->GetCount() - 1
\*****************************************************************************/
BOOL CFtpObj::_IsLindexOkay(int ife, FORMATETC *pfeWant)
{
    BOOL fResult;

    if (ife != DROP_FCont)
        fResult = pfeWant->lindex == -1;
    else
        fResult = (LONG)pfeWant->lindex < m_pflHfpl->GetCount();

    return fResult;
}


/*****************************************************************************\
    FUNCTION: _FindData

    DESCRIPTION:
        Locate our FORMATETC/STGMEDIUM given a FORMATETC from somebody else.
    On success, stores the index found into *piOut.
 
    We do not allow clients to change the TYMED of a FORMATETC, so
    in fact checking the TYMED is what we want, even on a SetData.
\*****************************************************************************/
HRESULT CFtpObj::_FindData(FORMATETC *pfe, PINT piOut)
{
    int nIndex;
    HRESULT hres = DV_E_FORMATETC;

    *piOut = 0;
    for (nIndex = DROP_FCont; nIndex < DROP_OFFERMAX; nIndex++)
    {
        ASSERT(0 == (g_dropTypes[nIndex]).ptd);
        ASSERT(g_dropTypes[nIndex].dwAspect == DVASPECT_CONTENT);

        if ((pfe->cfFormat == g_dropTypes[nIndex].cfFormat) && !ShouldSkipDropFormat(nIndex))
        {
            if (EVAL(g_dropTypes[nIndex].ptd == NULL))
            {
                if (EVAL(pfe->dwAspect == DVASPECT_CONTENT))
                {
                    if (EVAL(g_dropTypes[nIndex].tymed & pfe->tymed))
                    {
                        if (EVAL(_IsLindexOkay(nIndex, pfe)))
                        {
                            *piOut = nIndex;
                            hres = S_OK;
                        }
                        else
                            hres = DV_E_LINDEX;
                    }
                    else
                        hres = DV_E_TYMED;
                }
                else
                    hres = DV_E_DVASPECT;
            }
            else
                hres = DV_E_DVTARGETDEVICE;
            break;
        }
    }

    return hres;
}


/*****************************************************************************\
    FUNCTION: _FindDataForGet
 
    DESCRIPTION:
        Locate our FORMATETC/STGMEDIUM given a FORMATETC from somebody else.
    On success, stores the index found into *piOut.  Unlike _FindData, we will
    fail the call if the data object doesn't currently have the clipboard format.
    (Delayed render counts as "currently having it".  What we are filtering out
    are formats for which GetData will necessarily fail.)
\*****************************************************************************/
HRESULT CFtpObj::_FindDataForGet(FORMATETC *pfe, PINT piOut)
{
    HRESULT hr = _FindData(pfe, piOut);

    // TODO: g_cfHIDA should return an array of pidls for each folder.
    //       If we do this, the caller will support creating Shortcuts
    //       (LNK files) that point to these pidls.  We may want to do 
    //       that later.

    if (SUCCEEDED(hr))
    {
        if (*piOut != DROP_FCont)
        {
            if (m_stgCache[*piOut].tymed)
            {
                // Do we have data at all?
                // (possibly delay-rendered)
            }
            else
                hr = DV_E_FORMATETC;        // I guess not
        }
        else
        {
            // File contents always okay
        }
    }

#ifdef DEBUG
    if (FAILED(hr))
    {
        //TraceMsg(TF_FTPDRAGDROP, "CFtpObj::_FindDataForGet(FORMATETC.cfFormat=%d) Failed.", pfe->cfFormat);
        *piOut = 0xBAADF00D;
    }
#endif

    return hr;
}


// The following are used to enumerate sub directories when creating a list of pidls for
// a directory download (Ftp->FileSys).
typedef struct tagGENPIDLLIST
{
    CFtpPidlList *      ppidlList;
    IMalloc *           pm;
    IProgressDialog *   ppd;
    CWireEncoding *     pwe;
} GENPIDLLIST;


/*****************************************************************************\
     FUNCTION: ProcessItemCB
 
    DESCRIPTION:
        This function will add the specified pidl to the list.  It will then
    detect if it's a folder and if so, will call EnumFolder() to recursively
    enum it's contents and call ProcessItemCB() for each one.
 
    PARAMETERS:
\*****************************************************************************/
HRESULT ProcessItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    GENPIDLLIST * pGenPidlList = (GENPIDLLIST *) pvData;
    HRESULT hr = S_OK;

    // Does the user want to cancel?
    if (pGenPidlList->ppd && pGenPidlList->ppd->HasUserCancelled())
    {
        EVAL(SUCCEEDED(pGenPidlList->ppd->StopProgressDialog()));
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    if (SUCCEEDED(hr))
    {
        // No, don't cancel so continue...

        // Add everything except SoftLinks.
        // This is because dir SoftLinks may cause infinite recurion.
        // Someday, we may want to upload a shortcut but
        // that's too much work for now.
        if (0 != FtpPidl_GetAttributes(pidlFull))
        {
            // We exist to do this:
            pGenPidlList->ppidlList->InsertSorted(pidlFull);
        }

        // Is this a dir/folder that we need to recurse into?
        if (SUCCEEDED(hr) && (FILE_ATTRIBUTE_DIRECTORY & FtpPidl_GetAttributes(pidlFull)))
        {
            hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, pGenPidlList->pwe, pfValidhinst, pvData);
        }
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: _ExpandPidlListRecursively
 
    DESCRIPTION:
        This function will take the pidl list (ppidlListSrc) and call into it
    to enumerate.  It will provide ProcessItemCB as the callback function.
    This function will help it create a new CFtpPidlList which will not only
    contain the pidls in a base folder, but also all the pidls in any subfolders
    that are in the original list.

    Delay-render a file group descriptor.
\*****************************************************************************/
CFtpPidlList * CFtpObj::_ExpandPidlListRecursively(CFtpPidlList * ppidlListSrc)
{
    GENPIDLLIST pep = {0};

    pep.ppidlList = NULL;
    pep.ppd = m_ppd;
    pep.pwe = m_pff->GetCWireEncoding();
    if (SUCCEEDED(CFtpPidlList_Create(0, NULL, &pep.ppidlList)))
    {
        m_pff->GetItemAllocator(&pep.pm);

        if (EVAL(m_pfd) && EVAL(pep.pm))
        {
            HINTERNET hint;

            if (SUCCEEDED(m_pfd->GetHint(NULL, NULL, &hint, NULL, m_pff)))
            {
                LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());

                if (pidlRoot)
                {
                    HRESULT hr = ppidlListSrc->RecursiveEnum(pidlRoot, ProcessItemCB, hint, (LPVOID) &pep);
                   
                    if (m_ppd)
                        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));

                    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && !m_fErrAlreadyDisplayed)
                    {
                        pep.ppidlList->Release();
                        pep.ppidlList = NULL;

                        // Oh, I want a real hwnd, but where or where can I get one?
                        DisplayWininetErrorEx(NULL, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DROPFAIL, IDS_FTPERR_WININET, MB_OK, NULL, NULL);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions

                        // We need to suppress subsequent error dlgs from this location
                        // because callers like to ask for FILEGROUPDESCRIPTORA and
                        // if that fails, ask for FILEGROUPDESCRIPTORW and we don't
                        // want an error dialog for each.
                        m_fErrAlreadyDisplayed = TRUE;
                    }

                    ILFree(pidlRoot);
                }

                m_pfd->ReleaseHint(hint);
                pep.pm->Release();
            }
        }
    }

    return pep.ppidlList;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_FGD

    DESCRIPTION:
        Delay-render a file group descriptor
\*****************************************************************************/
HGLOBAL CFtpObj::_DelayRender_FGD(BOOL fUnicode)
{
    HGLOBAL hGlobal = NULL;
    
    if (m_fCheckSecurity &&
        ZoneCheckPidlAction(SAFECAST(this, IInternetSecurityMgrSite *), URLACTION_SHELL_FILE_DOWNLOAD, m_pff->GetPrivatePidlReference(), (PUAF_DEFAULT | PUAF_WARN_IF_DENIED)))
    {
        m_pflHfpl->TraceDump(m_pff->GetPrivatePidlReference(), TEXT("_DelayRender_FGD() TraceDump before"));
        CFtpPidlList * pPidlList;
    
        if (!m_fFGDRendered)
        {
            pPidlList = _ExpandPidlListRecursively(m_pflHfpl);
            if (pPidlList)
            {
                // We succeeded so now it's expanded.
                m_fFGDRendered = TRUE;
            }
        }
        else
        {
            m_pflHfpl->AddRef();
            pPidlList = m_pflHfpl;
        }

        if (pPidlList)
        {
            hGlobal = Misc_HFGD_Create(pPidlList, m_pff->GetPrivatePidlReference(), fUnicode);
            IUnknown_Set(&m_pflHfpl, pPidlList);
            m_pflHfpl->TraceDump(m_pff->GetPrivatePidlReference(), TEXT("_DelayRender_FGD() TraceDump after"));
            pPidlList->Release();
        }
    }
    else
    {
        // Suppress future UI.  We don't need to check any more
        // because our pidl won't change.  We could not pass PUAF_WARN_IF_DENIED
        // but that won't suppress the UI in the prompt case. (Only admins can
        // turn on the prompt case).
        m_fCheckSecurity = FALSE;
    }

    return hGlobal;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_IDList

    DESCRIPTION:
        Delay-render an ID List Array (HIDA)
\*****************************************************************************/
HRESULT CFtpObj::_DelayRender_IDList(STGMEDIUM * pStgMedium)
{
    pStgMedium->hGlobal = Misc_HIDA_Create(m_pff->GetPublicRootPidlReference(), m_pflHfpl);

    ASSERT(pStgMedium->hGlobal);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_URL

    DESCRIPTION:
        The caller wants an URL in an Ansi String
\*****************************************************************************/
HRESULT CFtpObj::_DelayRender_URL(STGMEDIUM * pStgMedium)
{
    LPSTR pszUrl = NULL;
    LPITEMIDLIST pidlFull = NULL;
    LPITEMIDLIST pidl = m_pflHfpl->GetPidl(0);

    ASSERT(pidl);   // We need this
    // Sometimes m_pflHfpl->GetPidl(0) is fully qualified and
    // sometimes it's not.
    if (!FtpID_IsServerItemID(pidl))
    {
        pidlFull = ILCombine(m_pfd->GetPidlReference(), pidl);
        pidl = pidlFull;
    }

    ASSERT(m_pflHfpl->GetCount() == 1); // How do we give them more than 1 URL?
    if (pidl)
    {
        TCHAR szUrl[MAX_URL_STRING];

        if (EVAL(SUCCEEDED(UrlCreateFromPidl(pidl, SHGDN_FORADDRESSBAR, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), TRUE))))
        {
            DWORD cchSize = (lstrlen(szUrl) + 1);

            pszUrl = (LPSTR) LocalAlloc(LPTR, (cchSize * sizeof(CHAR)));
            if (pszUrl)
                SHTCharToAnsi(szUrl, pszUrl, cchSize);
        }

        ILFree(pidlFull);
    }

    pStgMedium->hGlobal = (HGLOBAL) pszUrl;
    return S_OK;
}



#pragma BEGIN_CONST_DATA

DROPEFFECT c_deCopyLink = DROPEFFECT_COPY | DROPEFFECT_LINK;
DROPEFFECT c_deLink     =          DROPEFFECT_LINK;

#pragma END_CONST_DATA
/*****************************************************************************\
    FUNCTION: _DelayRender_PrefDe

    DESCRIPTION:
        Delay-render a preferred drop effect.
 
    The preferred drop effect is DROPEFFECT_COPY (with DROPEFFECT_LINK as fallback),
    unless you are dragging an FTP site, in which case it's just DROPEFFECT_LINK.
 
    DROPEFFECT_MOVE is never preferred.  We can do it; it just isn't preferred.
 
    NOTES: About DROPEFFECT_MOVE
    We cannot support Move on platforms before NT5 because of a Recycle Bin bug
    were it would clain to have succeeded with the copy but it actually didn't
    copy anything.  On NT5, the Recycle Bin drop target will call pDataObject->SetData()
    with a data type of "Dropped On" and the data being the CLSID of the drop
    target in addition to really copying the files to the recycle bin.  This will 
    let us delete the files knowing they are in the recycle bin.
\*****************************************************************************/
HRESULT CFtpObj::_DelayRender_PrefDe(STGMEDIUM * pStgMedium)
{
    DROPEFFECT * pde;

    if (!m_pfd->IsRoot())
        pde = &c_deCopyLink;
    else
        pde = &c_deLink;

    return Misc_CreateHglob(sizeof(*pde), pde, &pStgMedium->hGlobal);
}


/*****************************************************************************\
    FUNCTION: _RenderOlePersist

    DESCRIPTION:
        When the copy source goes away (the process shuts down), it calls
    OleFlushClipboard.  OLE will then copy our data, release us, and then
    give out our data later.  This works for most things except for:
    1. When lindex needs to very.  This doesn't work because ole doesn't know
       how to ask us how may lindexs they need to copy.
    2. If this object has a private interface OLE doesn't know about.  For us,
       it's IAsyncOperation.

   To get around this problem, we want OLE to recreate us when some possible
   paste target calls OleGetClipboard.  We want OLE to call OleLoadFromStream()
   to have us CoCreated and reload our persisted data via IPersistStream.
   OLE doesn't want to do this by default or they may have backward compat
   problems so they want a sign from the heavens, or at least from us, that
   we will work.  They ping our "OleClipboardPersistOnFlush" clipboard format
   to ask this.
\*****************************************************************************/
HRESULT CFtpObj::_RenderOlePersist(STGMEDIUM * pStgMedium)
{
    // The actual cookie value is opaque to the outside world.  Since
    // we don't use it either, we just leave it at zero in case we use
    // it in the future.  It's mere existence will cause OLE to do the
    // use our IPersistStream, which is what we want.
    DWORD dwCookie = 0;
    return Misc_CreateHglob(sizeof(dwCookie), &dwCookie, &pStgMedium->hGlobal);
}


/*****************************************************************************\
    FUNCTION: _RenderFGD

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::_RenderFGD(int nIndex, STGMEDIUM * pStgMedium)
{
    HRESULT hr = _DoProgressForLegacySystemsPre();

    if (SUCCEEDED(hr))
        pStgMedium->hGlobal = _DelayRender_FGD((DROP_FGDW == nIndex) ? TRUE : FALSE);

    if (!pStgMedium->hGlobal)
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);    // Probably failed because of Zones check.

    return hr;
}


/*****************************************************************************\
    FUNCTION: _ForceRender

    DESCRIPTION:
        We previously delayed rendering the data for perf reasons.  This function
    was called, so we now need to render the data.
\*****************************************************************************/
HRESULT CFtpObj::_ForceRender(int nIndex)
{
    HRESULT hr = S_OK;

    // We only support HGLOBALs here, but the caller may be valid
    // to ask for something we don't support or an extended data.
    //    ASSERT((m_stgCache[nIndex].tymed) == TYMED_HGLOBAL);

    if (!m_stgCache[nIndex].hGlobal)
    {
        STGMEDIUM medium = {TYMED_HGLOBAL, 0, NULL};

        switch (nIndex)
        {
        case DROP_FCont:
            ASSERT(0);
            break;
        case DROP_FGDW:
        case DROP_FGDA:
            hr = _RenderFGD(nIndex, &medium);
            break;
        case DROP_IDList:
            hr = _DelayRender_IDList(&medium);
            break;
/* Nuke
        case DROP_Offsets:
            ASSERT(0);
//            hglob = _DelayRender_Offsets();
            break;
*/
        case DROP_PrefDe:
            hr = _DelayRender_PrefDe(&medium);
            break;
        case DROP_PerfDe:
            ASSERT(0);
//            hglob = _DelayRender_PerfDe();
            break;
        case DROP_FTP_PRIVATE:
            hr = DV_E_FORMATETC;
            break;
        case DROP_OLEPERSIST:
            hr = _RenderOlePersist(&medium);
            break;
        case DROP_Hdrop:
            ASSERT(0);
//            hglob = _DelayRender_Hdrop();
            break;
        case DROP_FNMA:
            ASSERT(0);
//            hglob = _DelayRender_FNM();
            break;
        case DROP_FNMW:
            ASSERT(0);
//            hglob = _DelayRender_FNM();
            break;
        case DROP_URL:
            hr = _DelayRender_URL(&medium);
            break;
        default:
            ASSERT(0);      // Should never hit.
            break;
        }

        if (medium.hGlobal)  // Will fail if the Zones Security Check Fails.
        {
            m_stgCache[nIndex].pUnkForRelease = NULL;
            m_stgCache[nIndex].hGlobal = medium.hGlobal;
        }
        else
        {
            if (S_OK == hr)
                hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr))
        TraceMsg(TF_FTPDRAGDROP, "CFtpObj::_ForceRender() FAILED. hres=%#08lx", hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsPre

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  This function will display a progress dialog while we
    walk the server and expand the pidls that are needed to be copied.
    Later, 
\*****************************************************************************/
HRESULT CFtpObj::_DoProgressForLegacySystemsPre(void)
{
    HRESULT hr = S_OK;

    if (DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion()))
    {
        TraceMsg(TF_ALWAYS, "CFtpObj::_DoProgressForLegacySystemsPre() going to do the Legacy dialogs.");

        // Do we need to initialize the list?
        if (!m_ppd && (-1 == m_nStartIndex))
        {
            // Yes, so create the create the dialog and find the sizes of the list.
            if (m_ppd)
                _CloseProgressDialog();

            m_uliCompleted.QuadPart = 0;
            m_uliTotal.QuadPart = 0;
            m_ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_FTPDOWNLOAD);
            if (m_ppd)
            {
                WCHAR wzProgressDialogStr[MAX_PATH];

                // Tell the user we are calculating how long it will take.
                if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DOWNLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                    EVAL(SUCCEEDED(m_ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));

                // We give a NULL punkEnableModless because we don't want to go modal.
                EVAL(SUCCEEDED(m_ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL)));
           }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsStart

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  Only return FAILED(hr) if IProgressDialog::HasUserCancelled().
\*****************************************************************************/
HRESULT CFtpObj::_DoProgressForLegacySystemsStart(LPCITEMIDLIST pidl, int nIndex)
{
    HRESULT hr = S_OK;

    if (DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion()))
    {
        TraceMsg(TF_ALWAYS, "CFtpObj::_DoProgressForLegacySystemsStart() going to do the Legacy dialogs.");

        // Do we need to initialize the list?
        if (-1 == m_nStartIndex)
            hr = _SetProgressDialogValues(nIndex);   // Yes, so do so.

        if (EVAL(m_ppd))
        {
            WCHAR wzTemplate[MAX_PATH];
            WCHAR wzPath[MAX_PATH];
            WCHAR wzStatusText[MAX_PATH];
            WCHAR wzTemp[MAX_PATH];
            LPITEMIDLIST pidlBase = (LPITEMIDLIST) pidl;

            EVAL(SUCCEEDED(m_ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL)));

            // Generate the string "Downloading <FileName>..." status string
            EVAL(LoadStringW(HINST_THISDLL, IDS_DOWNLOADING, wzTemplate, ARRAYSIZE(wzTemplate)));
            FtpPidl_GetLastItemDisplayName(pidl, wzTemp, ARRAYSIZE(wzTemp));
            wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, wzTemp);
            EVAL(SUCCEEDED(m_ppd->SetLine(1, wzStatusText, FALSE, NULL)));

            if (FtpPidl_IsDirectory(pidl, FALSE))
            {
                pidlBase = ILClone(pidl);
                ILRemoveLastID(pidlBase);
            }

            // Generate the string "From <SrcFileDir>" status string
            GetDisplayPathFromPidl(pidlBase, wzPath, ARRAYSIZE(wzPath), TRUE);
            EVAL(LoadStringW(HINST_THISDLL, IDS_DL_SRC_DIR, wzTemplate, ARRAYSIZE(wzTemplate)));
            wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, wzPath);
            EVAL(SUCCEEDED(m_ppd->SetLine(2, wzStatusText, FALSE, NULL)));

            EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliCompleted.QuadPart, m_uliTotal.QuadPart)));
            TraceMsg(TF_ALWAYS, "CFtpObj::_DoProgressForLegacySystemsStart() SetProgress64(%#08lx, %#08lx)", m_uliCompleted.LowPart, m_uliTotal.LowPart);
            if (m_ppd->HasUserCancelled())
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            if (pidlBase != pidl)   // Did we allocated it?
                ILFree(pidlBase);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsPost

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  Only return FAILED(hr) if IProgressDialog::HasUserCancelled().
\*****************************************************************************/
HRESULT CFtpObj::_DoProgressForLegacySystemsPost(LPCITEMIDLIST pidl, BOOL fLast)
{
    HRESULT hr = S_OK;

    if ((DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion())) && EVAL(m_ppd))
    {
        if (pidl)
        {
            // Add the file size to the Completed.
            m_uliCompleted.QuadPart += FtpPidl_GetFileSize(pidl);
        }

        TraceMsg(TF_ALWAYS, "CFtpObj::_DoProgressForLegacySystemsPost() Closing DLG");

        if (fLast)
            IUnknown_Set((IUnknown **)&m_ppd, NULL);    // The stream will close the dialog and release it.
    }

    return hr;
}


HRESULT CFtpObj::_SetProgressDialogValues(int nIndex)
{
    HRESULT hr = S_OK;

    m_nStartIndex = nIndex;
    if (EVAL(m_ppd))
    {
        // Calculate m_nEndIndex
        while (nIndex < m_pflHfpl->GetCount())
        {
            if (!FtpPidl_IsDirectory(m_pflHfpl->GetPidl(nIndex), FALSE))
                m_nEndIndex = nIndex;
            nIndex++;
        }

        for (nIndex = 0; nIndex < m_pflHfpl->GetCount(); nIndex++)
        {
            LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(nIndex);
            m_uliTotal.QuadPart += FtpPidl_GetFileSize(pidl);
        }

        // Reset because the above for loop can take a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        EVAL(SUCCEEDED(m_ppd->Timer(PDTIMER_RESET, NULL)));
   }

    return hr;
}


HRESULT CFtpObj::_CloseProgressDialog(void)
{
    m_nStartIndex = -1; // Indicate we haven't inited yet.
    if (m_ppd)
    {
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
        IUnknown_Set((IUnknown **)&m_ppd, NULL);
    }
    return S_OK;
}


HRESULT CFtpObj::_RefThread(void)
{
    if (NULL == m_punkThreadRef)
    {
        // This is valid to fail from some hosts who won't go away,
        // so they don't need to support ref counting threads.
        SHGetThreadRef(&m_punkThreadRef);
    }

    return S_OK;
}


HRESULT CFtpObj::_RenderFileContents(LPFORMATETC pfe, LPSTGMEDIUM pstg)
{
    HRESULT hr = E_INVALIDARG;

    // callers have a bad habit of asking for lindex == -1 because
    // that means 'all' data.  But how can you hand out one IStream* for
    // all files?
    if (-1 != pfe->lindex)
    {
        LPITEMIDLIST pidl = m_pflHfpl->GetPidl(pfe->lindex);
        //    FileContents are always regenerated afresh.
        pstg->pUnkForRelease = 0;
        pstg->tymed = TYMED_ISTREAM;

        if (pidl)
        {
            hr = _DoProgressForLegacySystemsStart(pidl, pfe->lindex);
            if (SUCCEEDED(hr))
            {
                // Is it a directory?
                if (FtpPidl_IsDirectory(pidl, FALSE))
                {
                    // Yes, so pack the name and attributes
                    hr = DV_E_LINDEX;
                    AssertMsg(0, TEXT("Someone is asking for a FILECONTENTs for a directory item."));
                }
                else
                {
                    // No, so give them the stream.
                    
                    // shell32 v5 will display progress dialogs, but we need to
                    // display progress dialogs for shell32 v3 or v4.  We do this
                    // by creating the progress dialog when the caller asks for the
                    // first stream.  We then need to find out when they call for
                    // the last stream and then hand off the IProgressDialog to the
                    // CFtpStm.  The CFtpStm will then close down the dialog when the
                    // caller closes it.
                    hr = CFtpStm_Create(m_pfd, pidl, GENERIC_READ, &pstg->pstm, m_uliCompleted, m_uliTotal, m_ppd, (pfe->lindex == m_nEndIndex));
                    EVAL(SUCCEEDED(_DoProgressForLegacySystemsPost(pidl, (pfe->lindex == m_nEndIndex))));
                }
            }
            else
            {
                // The user may have cancelled
                ASSERT(HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr);
            }
        }

        if (FAILED(hr))
            _CloseProgressDialog();
    }

    //TraceMsg(TF_FTPDRAGDROP, "CFtpObj::GetData() CFtpStm_Create() returned hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IsEqualFORMATETC
  
    DESCRIPTION:
        The two fields of a FORMATETC that need to match to be equivalent are:
    cfFormat and lindex.
\*****************************************************************************/
BOOL IsEqualFORMATETC(FORMATETC * pfe1, FORMATETC * pfe2)
{
    BOOL fIsEqual = FALSE;

    if ((pfe1->cfFormat == pfe2->cfFormat) && (pfe1->lindex == pfe2->lindex))
    {
        fIsEqual = TRUE;
    }

    return fIsEqual;
}


/*****************************************************************************\
      FUNCTION: _FreeExtraData
  
      DESCRIPTION:
\*****************************************************************************/
int CFtpObj::_DSA_FreeCB(LPVOID pvItem, LPVOID pvlparam)
{
    FORMATETC_STGMEDIUM * pfs = (FORMATETC_STGMEDIUM *) pvItem;

    if (EVAL(pfs))
        ReleaseStgMedium(&(pfs->medium));

    return 1;
}


/*****************************************************************************\
      FUNCTION: _FindSetDataIndex
  
      DESCRIPTION:
\*****************************************************************************/
int CFtpObj::_FindExtraDataIndex(FORMATETC *pfe)
{
    int nIndex;

    for (nIndex = (DSA_GetItemCount(m_hdsaSetData) - 1); nIndex >= 0; nIndex--)
    {
        FORMATETC_STGMEDIUM * pfs = (FORMATETC_STGMEDIUM *) DSA_GetItemPtr(m_hdsaSetData, nIndex);

        if (IsEqualFORMATETC(pfe, &pfs->formatEtc))
        {
            return nIndex;
        }
    }

    return -1;
}


/*****************************************************************************\
      FUNCTION: _SetExtraData
  
      DESCRIPTION:
        We don't render the data, but we will carry it because someone may need
      or want it.  This is the case with the drag source's defview pushing in
      the icon points via CFSTR_SHELLIDLISTOFFSET for the drop target.
\*****************************************************************************/
HRESULT CFtpObj::_SetExtraData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease)
{
    HRESULT hr;
    int nIndex = _FindExtraDataIndex(pfe);

    // Do we already have someone's copy?
    if (-1 == nIndex)
    {
        FORMATETC_STGMEDIUM fs;

        fs.formatEtc = *pfe;

        // If there is a pointer, copy the data because we can't maintain the lifetime
        // of the pointer.
        if (fs.formatEtc.ptd)
        {
            fs.dvTargetDevice = *(pfe->ptd);
            fs.formatEtc.ptd = &fs.dvTargetDevice;
        }

        hr = CopyStgMediumWrap(pstg, &fs.medium);
        if (EVAL(SUCCEEDED(hr)))
        {
            // No, so just append it to the end.
            DSA_AppendItem(m_hdsaSetData, &fs);
        }
    }
    else
    {
        FORMATETC_STGMEDIUM fs;

        DSA_GetItem(m_hdsaSetData, nIndex, &fs);
        // Free the previous guy.
        ReleaseStgMedium(&fs.medium);

        // Yes, so Replace it.
        hr = CopyStgMediumWrap(pstg, &fs.medium);
        if (EVAL(SUCCEEDED(hr)))
        {
            // Replace the data.
            DSA_SetItem(m_hdsaSetData, nIndex, &fs);
        }
    }

    return hr;
}


typedef struct
{
    DWORD dwVersion;
    DWORD dwExtraSize;   // After pidl list
    BOOL fFGDRendered;
    DWORD dwReserved1;
    DWORD dwReserved2;
} FTPDATAOBJ_PERSISTSTRUCT;


/*****************************************************************************\
    FUNCTION: FormatEtcSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FormatEtcSaveToStream(IStream *pStm, FORMATETC * pFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        // We don't support ptd because where would the allocation be
        // on the load?
        if (EVAL(NULL == pFormatEtc->ptd))
        {
            WCHAR szFormatName[MAX_PATH];

            if (EVAL(GetClipboardFormatNameW(pFormatEtc->cfFormat, szFormatName, ARRAYSIZE(szFormatName))))
            {
                DWORD cbFormatNameSize = ((lstrlenW(szFormatName) + 1) * sizeof(szFormatName[0]));

                hr = pStm->Write(pFormatEtc, SIZEOF(*pFormatEtc), NULL);
                if (SUCCEEDED(hr))
                {
                    hr = pStm->Write(&cbFormatNameSize, SIZEOF(cbFormatNameSize), NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = pStm->Write(szFormatName, cbFormatNameSize, NULL);
                    }
                }
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FormatEtcLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FormatEtcLoadFromStream(IStream *pStm, FORMATETC * pFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = pStm->Read(pFormatEtc, SIZEOF(*pFormatEtc), NULL);
        ASSERT(NULL == pFormatEtc->ptd);    // We don't support this.

        if (SUCCEEDED(hr))
        {
            DWORD cbFormatNameSize;

            hr = pStm->Read(&cbFormatNameSize, SIZEOF(cbFormatNameSize), NULL);
            if (SUCCEEDED(hr))
            {
                WCHAR szFormatName[MAX_PATH];

                hr = pStm->Read(szFormatName, cbFormatNameSize, NULL);
                if (SUCCEEDED(hr))
                {
                    pFormatEtc->cfFormat = (CLIPFORMAT)RegisterClipboardFormatW(szFormatName);
                }
            }
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

    }

    return hr;
}


typedef struct
{
    DWORD dwVersion;
    DWORD dwExtraSize;               // After this struct
    DWORD dwTymed;              // What type of data is stored?
    BOOL fUnkForRelease;        // Did we save the object after this?
    DWORD dwReserved1;          //
    DWORD dwReserved2;          //
} STGMEDIUM_PERSISTSTRUCT;

/*****************************************************************************\
    FUNCTION: StgMediumSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT StgMediumSaveToStream(IStream *pStm, STGMEDIUM * pMedium)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        STGMEDIUM_PERSISTSTRUCT smps = {0};

        smps.dwVersion = 1;
        smps.dwTymed = pMedium->tymed;

        switch (pMedium->tymed)
        {
        case TYMED_HGLOBAL:
        {
            IStream * pstmHGlobal;

            hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &pstmHGlobal);
            if (SUCCEEDED(hr))
            {
                STATSTG statStg;

                hr = pstmHGlobal->Stat(&statStg, STATFLAG_NONAME);
                if (SUCCEEDED(hr))
                {
                    ASSERT(!statStg.cbSize.HighPart);
                    smps.dwExtraSize = statStg.cbSize.LowPart;
                    hr = pStm->Write(&smps, SIZEOF(smps), NULL);
                    if (SUCCEEDED(hr))
                        hr = pstmHGlobal->CopyTo(pStm, statStg.cbSize, NULL, NULL);
                }

                pstmHGlobal->Release();
            }
        }
        break;

        case TYMED_FILE:
            smps.dwExtraSize = ((lstrlenW(pMedium->lpszFileName) + 1) * sizeof(WCHAR));

            hr = pStm->Write(&smps, SIZEOF(smps), NULL);
            if (SUCCEEDED(hr))
            {
                hr = pStm->Write(pMedium->lpszFileName, smps.dwExtraSize, NULL);
                ASSERT(SUCCEEDED(hr));
            }
            break;

        case TYMED_GDI:
        case TYMED_MFPICT:
        case TYMED_ENHMF:
        case TYMED_ISTORAGE:
        case TYMED_ISTREAM:
        default:
            ASSERT(0);  // What are you doing?  Impl this if you need it.
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}


LPWSTR OLESTRAlloc(DWORD cchSize)
{
    return (LPWSTR) new WCHAR [cchSize + 1];
}


/*****************************************************************************\
    FUNCTION: StgMediumLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT StgMediumLoadFromStream(IStream *pStm, STGMEDIUM * pMedium)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm && pMedium)
    {
        STGMEDIUM_PERSISTSTRUCT smps;

        pMedium->pUnkForRelease = NULL;
        hr = pStm->Read(&smps, SIZEOF(smps), NULL);
        if (SUCCEEDED(hr))
        {
            pMedium->tymed = smps.dwTymed;
            ASSERT(!pMedium->pUnkForRelease);

            switch (pMedium->tymed)
            {
            case TYMED_HGLOBAL:
            {
                IStream * pstmTemp;
                hr = CreateStreamOnHGlobal(NULL, FALSE, &pstmTemp);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER uli = {0};

                    uli.LowPart = smps.dwExtraSize;
                    hr = pStm->CopyTo(pstmTemp, uli, NULL, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = GetHGlobalFromStream(pstmTemp, &pMedium->hGlobal);
                    }

                    pstmTemp->Release();
                }
            }
            break;

            case TYMED_FILE:
                pMedium->lpszFileName = OLESTRAlloc(smps.dwExtraSize / sizeof(WCHAR));
                if (pMedium->lpszFileName)
                    hr = pStm->Read(pMedium->lpszFileName, smps.dwExtraSize, NULL);
                else
                    hr = E_OUTOFMEMORY;
                break;

            case TYMED_GDI:
            case TYMED_MFPICT:
            case TYMED_ENHMF:
            case TYMED_ISTORAGE:
            case TYMED_ISTREAM:
            default:
                ASSERT(0);  // What are you doing?  Impl this if you need it.
                // Some future version must have done the save, so skip the
                // data so we don't leave unread data.
                if (0 != smps.dwExtraSize)
                {
                    LARGE_INTEGER li = {0};

                    li.LowPart = smps.dwExtraSize;
                    EVAL(SUCCEEDED(pStm->Seek(li, STREAM_SEEK_CUR, NULL)));
                }
                hr = E_NOTIMPL;
                break;
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FORMATETC_STGMEDIUMSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FORMATETC_STGMEDIUMSaveToStream(IStream *pStm, FORMATETC_STGMEDIUM * pfdops)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = FormatEtcSaveToStream(pStm, &pfdops->formatEtc);
        if (SUCCEEDED(hr))
            hr = StgMediumSaveToStream(pStm, &pfdops->medium);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FORMATETC_STGMEDIUMLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FORMATETC_STGMEDIUMLoadFromStream(IStream *pStm, FORMATETC_STGMEDIUM * pfdops)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = FormatEtcLoadFromStream(pStm, &pfdops->formatEtc);
        if (SUCCEEDED(hr))
            hr = StgMediumLoadFromStream(pStm, &pfdops->medium);
    }

    return hr;
}



/////////////////////////////////
////// IAsynchDataObject Impl
/////////////////////////////////


/*****************************************************************************\
    FUNCTION: IAsyncOperation::GetAsyncMode

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::GetAsyncMode(BOOL * pfIsOpAsync)
{
    *pfIsOpAsync = TRUE;
    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::StartOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::StartOperation(IBindCtx * pbcReserved)
{
    ASSERT(!pbcReserved);
    m_fDidAsynchStart = TRUE;

    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::InOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::InOperation(BOOL * pfInAsyncOp)
{
    if (m_fDidAsynchStart)
        *pfInAsyncOp = TRUE;
    else
        *pfInAsyncOp = FALSE;

    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::EndOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::EndOperation(HRESULT hResult, IBindCtx * pbcReserved, DWORD dwEffects)
{
    if (SUCCEEDED(hResult) &&
        (DROPEFFECT_MOVE == dwEffects))
    {
        CFtpPidlList * pPidlListNew = CreateRelativePidlList(m_pff, m_pflHfpl);

        if (pPidlListNew)
        {
            Misc_DeleteHfpl(m_pff, GetDesktopWindow(), pPidlListNew);
            pPidlListNew->Release();
        }
    }
 
    m_fDidAsynchStart = FALSE;
    return S_OK;
}
  


/////////////////////////////////
////// IPersistStream Impl
/////////////////////////////////


/*****************************************************************************\
    FUNCTION: IPersistStream::Load

    DESCRIPTION:
        See IPersistStream::Save() for the layout of the stream.
\*****************************************************************************/
HRESULT CFtpObj::Load(IStream *pStm)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        FTPDATAOBJ_PERSISTSTRUCT fdoss;
        DWORD dwNumPidls;
        DWORD dwNumStgMedium;

        hr = pStm->Read(&fdoss, SIZEOF(fdoss), NULL);   // #1
        // If we rev the version, read it now (fdoss.dwVersion)

        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

            ASSERT(!m_pff);
            m_fFGDRendered = fdoss.fFGDRendered;

            hr = ILLoadFromStream(pStm, &pidl); // #2
            if (SUCCEEDED(hr))
            {
                hr = SHBindToIDList(pidl, NULL, IID_CFtpFolder, (void **)&m_pff);
                if (SUCCEEDED(hr))
                    m_pfd = m_pff->GetFtpDir();

                ASSERT(m_pfd);
                ILFree(pidl);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pStm->Read(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3
            if (SUCCEEDED(hr))
                hr = CFtpPidlList_Create(0, NULL, &m_pflHfpl);
        }

        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

                hr = ILLoadFromStream(pStm, &pidl); // #4
                if (SUCCEEDED(hr))
                {
                    hr = m_pflHfpl->InsertSorted(pidl);
                    ILFree(pidl);
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = pStm->Read(&dwNumStgMedium, SIZEOF(dwNumStgMedium), NULL);  // #5

        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumStgMedium) && SUCCEEDED(hr); nIndex++)
            {
                FORMATETC_STGMEDIUM fs;

                hr = FORMATETC_STGMEDIUMLoadFromStream(pStm, &fs);   // #6
                if (SUCCEEDED(hr))
                    DSA_AppendItem(m_hdsaSetData, &fs);
            }
        }

        if (SUCCEEDED(hr))
        {
            // We may be reading a version newer than us, so skip their data.
            if (0 != fdoss.dwExtraSize)
            {
                LARGE_INTEGER li = {0};
                
                li.LowPart = fdoss.dwExtraSize;
                hr = pStm->Seek(li, STREAM_SEEK_CUR, NULL);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IPersistStream::Save

    DESCRIPTION:
        The stream will be layed out in the following way:

    Version 1:
        1. FTPDATAOBJ_PERSISTSTRUCT - Constant sized data.
        <PidlList BEGIN>
            2. PIDL pidl - Pidl for m_pff.  It will be a public pidl (fully qualified
                        from the shell root)
            3. DWORD dwNumPidls - Number of pidls coming.
            4. PIDL pidl(n) - Pidl in slot (n) of m_pflHfpl
        <PidlList END>
        5. DWORD dwNumStgMedium - Number of FORMATETC_STGMEDIUMs coming
        6. FORMATETC_STGMEDIUM fmtstg(n) - dwNumStgMedium FORMATETC_STGMEDIUMs.
\*****************************************************************************/
HRESULT CFtpObj::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        FTPDATAOBJ_PERSISTSTRUCT fdoss = {0};
        DWORD dwNumPidls = m_pflHfpl->GetCount();
        DWORD dwNumStgMedium = DSA_GetItemCount(m_hdsaSetData);

        fdoss.dwVersion = 1;
        fdoss.fFGDRendered = m_fFGDRendered;
        hr = pStm->Write(&fdoss, SIZEOF(fdoss), NULL);  // #1
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pff);
            hr = ILSaveToStream(pStm, m_pff->GetPublicRootPidlReference()); // #2
        }

        if (SUCCEEDED(hr))
            hr = pStm->Write(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3

        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                LPITEMIDLIST pidlCur = m_pflHfpl->GetPidl(nIndex);

                ASSERT(pidlCur);
                hr = ILSaveToStream(pStm, pidlCur); // #4
            }
        }

        if (SUCCEEDED(hr))
            hr = pStm->Write(&dwNumStgMedium, SIZEOF(dwNumStgMedium), NULL);  // #5

        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumStgMedium) && SUCCEEDED(hr); nIndex++)
            {
                FORMATETC_STGMEDIUM fs;

                DSA_GetItem(m_hdsaSetData, nIndex, &fs);

                hr = FORMATETC_STGMEDIUMSaveToStream(pStm, &fs);   // #6
            }
        }

    }

    return hr;
}


#define MAX_STREAM_SIZE    (500 * 1024) // 500k
/*****************************************************************************\
    FUNCTION: IPersistStream::GetSizeMax

    DESCRIPTION:
        Now this is tough.  I can't calculate the real value because I don't know
    how big the hglobals are going to be for the user provided data.  I will
    assume everything fits in
\*****************************************************************************/
HRESULT CFtpObj::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    if (pcbSize)
    {
        pcbSize->HighPart = 0;
        pcbSize->LowPart = MAX_STREAM_SIZE;
    }
    
    return E_NOTIMPL;
}


/////////////////////////////////
////// IDataObject Impl
/////////////////////////////////

/*****************************************************************************\
    FUNCTION: IDataObject::GetData

    DESCRIPTION:
        Render the data in the requested format and put it into the
    STGMEDIUM structure.
\*****************************************************************************/
HRESULT CFtpObj::GetData(LPFORMATETC pfe, LPSTGMEDIUM pstg)
{
    int ife;
    HRESULT hr;

    hr = _FindDataForGet(pfe, &ife);
    if (SUCCEEDED(hr))
    {
        if (ife == DROP_FCont)
            hr = _RenderFileContents(pfe, pstg);
        else
        {
            hr = _ForceRender(ife);
            if (SUCCEEDED(hr))  // May not succeed for security reasons.
            {
                ASSERT(m_stgCache[ife].hGlobal);

                // It's possible to use the hacking STGMEDIUM.pUnkForRelease to give away
                // pointers to our data, but we then need massive amounts of code to babysite
                // the lifetime of those pointers.  This becomes more work when ::SetData() can
                // replace that data, so we just take the hit of the memcpy for less code.
                hr = CopyStgMediumWrap(&m_stgCache[ife], pstg);
                ASSERT(SUCCEEDED(hr));
                ASSERT(NULL == pstg->pUnkForRelease);
                //TraceMsg(TF_FTPDRAGDROP, "CFtpObj::GetData() pstg->hGlobal=%#08lx. pstg->pUnkForRelease=%#08lx.", pstg->hGlobal, pstg->pUnkForRelease);
            }
        }

        TraceMsgWithFormat(TF_FTPDRAGDROP, "CFtpObj::GetData()", pfe, "Format in static list", hr);
    }
    else
    {
        int nIndex = _FindExtraDataIndex(pfe);

        if (-1 == nIndex)
            hr = E_FAIL;
        else
        {
            FORMATETC_STGMEDIUM fs;

            DSA_GetItem(m_hdsaSetData, nIndex, &fs);
            hr = CopyStgMediumWrap(&fs.medium, pstg);
        }

        TraceMsgWithFormat(TF_FTPDRAGDROP, "CFtpObj::GetData()", pfe, "Looking in dyn list", hr);
    }

    return hr;
}


/*****************************************************************************\
    IDataObject::GetDataHere

    Render the data in the requested format and put it into the
    object provided by the caller.
\*****************************************************************************/
HRESULT CFtpObj::GetDataHere(FORMATETC *pfe, STGMEDIUM *pstg)
{
    TraceMsg(TF_FTPDRAGDROP, "CFtpObj::GetDataHere() pfe->cfFormat=%d.", pfe->cfFormat);
    return E_NOTIMPL;
}



/*****************************************************************************\
    FUNCTION: IDataObject::QueryGetData

    DESCRIPTION:
       Indicate whether we could provide data in the requested format.
\*****************************************************************************/
HRESULT CFtpObj::QueryGetData(FORMATETC *pfe)
{
    int ife;
    HRESULT hr = _FindDataForGet(pfe, &ife);
    
    if (FAILED(hr))
    {
        // If it wasn't one of the types we offer, see if it was given to us via
        // IDataObject::SetData().
        int nIndex = _FindExtraDataIndex(pfe);

        if (-1 != nIndex)
            hr = S_OK;
    }

    TraceMsgWithFormat(TF_FTPDRAGDROP, "CFtpObj::QueryGetData()", pfe, "", hr);
    return hr;
}


/*****************************************************************************\
      FUNCTION: IDataObject::GetCanonicalFormatEtc
  
      DESCRIPTION:
      Our data are not sensitive to device-specific renderings,
      so we do what the book tells us to do.
 
      Or we *try* to do what the book tells us to do.
 
      OLE random documentation of the day:
      IDataObject::GetCanonicalFormatEtc.
 
      Turns out that the man page contradicts itself within sentences:
 
         DATA_S_SAMEFORMATETC - The FORMATETC structures are the same
                    and NULL is returned in pfeOut.
 
         If the data object never provides device-specific renderings,
         the implementation of IDataObject::GetCanonicalFormatEtc
         simply copies the input FORMATETC to the output FORMATETC,
         stores a null in the ptd field, and returns DATA_S_SAMEFORMATETC.
 
      And it turns out that the shell doesn't do *either* of these things.
      It just returns DATA_S_SAMEFORMATETC and doesn't touch pfeOut.
 
      The book is even more confused.  Under pfeOut, it says
 
         The value is NULL if the method returns DATA_S_SAMEFORMATETC.
 
      This makes no sense.  The caller provides the value of pfeOut.
      How can the caller possibly know that the method is going to return
      DATA_S_SAMEFORMATETC before it calls it?  If you expect the
      method to write "pfeOut = 0" before returning, you're nuts.  That
      communicates nothing to the caller.
 
      I'll just do what the shell does.
\*****************************************************************************/
HRESULT CFtpObj::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return DATA_S_SAMEFORMATETC;
}


/*****************************************************************************\
      FUNCTION: IDataObject::SetData
  
      DESCRIPTION:
      We let people change TYMED_HGLOBAL gizmos, but nothing else.
  
      We need to do a careful two-step when replacing the HGLOBAL.
      If the user gave us a plain HGLOBAL without a pUnkForRelease,
      we need to invent our own pUnkForRelease to track it.  But we
      don't want to release the old STGMEDIUM until we're sure we
      can accept the new one.
  
      fRelease == 0 makes life doubly interesting, because we also
      have to clone the HGLOBAL (and remember to free the clone on the
      error path).
  
      _SOMEDAY_/TODO -- Need to support PerformedDropEffect so we can
      clean up stuff on a cut/paste.
\*****************************************************************************/
HRESULT CFtpObj::SetData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease)
{
    int ife;
    HRESULT hr;

    hr = _FindData(pfe, &ife);
    if (SUCCEEDED(hr))
    {
        if (ife == DROP_FCont)
        {
            TraceMsg(TF_FTPDRAGDROP, "CFtpObj::SetData(FORMATETC.cfFormat=%d) ife == DROP_FCont", pfe->cfFormat);
            hr = DV_E_FORMATETC;
        }
        else
        {
            ASSERT(g_dropTypes[ife].tymed == TYMED_HGLOBAL);
            ASSERT(pstg->tymed == TYMED_HGLOBAL);
            if (pstg->hGlobal)
            {
                STGMEDIUM stg = {0};

                hr = CopyStgMediumWrap(pstg, &stg);
                if (SUCCEEDED(hr))
                {
                    ReleaseStgMedium(&m_stgCache[ife]);
                    m_stgCache[ife] = stg;
                }
            }
            else
            {            // Tried to SetData a _DelayRender
                hr = DV_E_STGMEDIUM;   
            }
        }

        TraceMsgWithFormat(TF_FTPDRAGDROP, "CFtpObj::SetData()", pfe, "in static list", hr);
    }
    else
    {
        hr = _SetExtraData(pfe, pstg, fRelease);
        TraceMsgWithFormat(TF_FTPDRAGDROP, "CFtpObj::SetData()", pfe, "in dyn list", hr);
    }

    return hr;
}


/*****************************************************************************\
      FUNCTION: IDataObject::EnumFormatEtc
  
      DESCRIPTION:
        _UNDOCUMENTED_:  If you drag something from a DefView, it will
      check the data object to see if it has a hida.  If so, then it
      will cook up a CFSTR_SHELLIDLISTOFFSET *for you* and SetData
      the information into the data object.  So in order to get
      position-aware drag/drop working, you must allow DefView to change
      your CFSTR_SHELLIDLISTOFFSET.
 
     We allow all FORMATETCs to be modified except for FileContents.
\*****************************************************************************/
HRESULT CFtpObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenum)
{
    HRESULT hres;

    switch (dwDirection)
    {
    case DATADIR_GET:
        hres = CFtpEfe_Create(DROP_OFFERMAX - DROP_FCont, &g_dropTypes[DROP_FCont],
                   &m_stgCache[DROP_FCont], this, ppenum);
        TraceMsg(TF_FTPDRAGDROP, "CFtpObj::EnumFormatEtc(DATADIR_GET) CFtpEfe_Create() returned hres=%#08lx", hres);
        break;

    case DATADIR_SET:
        hres = CFtpEfe_Create(DROP_OFFERMAX - DROP_OFFERMIN, &g_dropTypes[DROP_OFFERMIN],
                   &m_stgCache[DROP_OFFERMIN], NULL, ppenum);
        TraceMsg(TF_FTPDRAGDROP, "CFtpObj::EnumFormatEtc(DATADIR_SET) CFtpEfe_Create() returned hres=%#08lx", hres);
        break;

    default:
        ASSERT(0);
        hres = E_NOTIMPL;
        break;
    }

    return hres;
}


/*****************************************************************************\
      FUNCTION: IDataObject::DAdvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::DAdvise(FORMATETC *pfe, DWORD advfl, IAdviseSink *padv, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: IDataObject::DUnadvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: IDataObject::EnumDAdvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj::EnumDAdvise(IEnumSTATDATA **ppeadv)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: CFtpObj_Create
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;
    CFtpObj * pfo;

    *ppvObj = NULL;

    hres = CFtpObj_Create(pff, pflHfpl, &pfo);
    if (SUCCEEDED(hres))
    {
        pfo->QueryInterface(riid, ppvObj);
        pfo->Release();
    }

     return hres;
}


/*****************************************************************************\
      FUNCTION: CFtpObj_Create
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpObj ** ppfo)
{
    HRESULT hres = S_OK;

    if (EVAL(pflHfpl->GetCount()))
    {
        *ppfo = new CFtpObj();

        if (*ppfo)
        {
            CFtpObj * pfo = *ppfo;
            pfo->m_pfd = pff->GetFtpDir();

            if (pfo->m_pfd)
            {
                pfo->m_pff = pff;
                if (pff)
                    pff->AddRef();

                IUnknown_Set(&pfo->m_pflHfpl, pflHfpl);
                
                if (pfo->m_pflHfpl->GetCount() == 1)
                {
                    pfo->m_stgCache[DROP_URL].tymed = TYMED_HGLOBAL;
                }
            }
            else
            {
                hres = E_FAIL;
                (*ppfo)->Release();
                *ppfo = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;

    }
    else
    {
        *ppfo = NULL;
        hres = E_INVALIDARG;        /* Trying to get UI object of nil? */
    }

    return hres;
}


/*****************************************************************************\
    FUNCTION: CFtpObj_Create

    DESCRIPTION:
        This will be called by the Class Factory when the IDataObject gets
    persisted and then wants to be recreated in a new process. (Happens
    after the original thread/process calls OleFlushClipboard.
\*****************************************************************************/
HRESULT CFtpObj_Create(REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFtpObj * pfo = new CFtpObj();

    *ppvObj = NULL;
    if (pfo)
    {
        hr = pfo->QueryInterface(riid, ppvObj);
        pfo->Release();
    }

     return hr;
}

#define SETDATA_GROWSIZE        3

/****************************************************\
    Constructor
\****************************************************/
CFtpObj::CFtpObj() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_fDidAsynchStart);

    // NT #245306: If the user drags files from an FTP window (Thread 1)
    //    to a shell window (Thread 2), the shell window will do
    //    the drop on a background thread (thread 3).  Since the
    //    UI thread is no longer blocked, the user can now close
    //    the window.  The problem is that OLE is using Thread 2
    //    for marshalling.  In order to solve this problem, we
    //    ref count the thread for items that rely on it.
    //    This include FTP, normal Download, and other things
    //    in the future.
//    SHIncrementThreadModelessCount();

    m_nStartIndex = -1; // -1 means we don't know the start.
    m_fFGDRendered = FALSE;
    m_fCheckSecurity = TRUE;      // We need to keep checking.

    m_hdsaSetData = DSA_Create(sizeof(FORMATETC_STGMEDIUM), SETDATA_GROWSIZE);

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_stgInit); nIndex++)
    {
        ASSERT(nIndex < ARRAYSIZE(m_stgCache));
        m_stgCache[nIndex] = c_stgInit[nIndex];
    }

    _RefThread();
    // The receiver may use us in the background, so make sure that our thread
    // doesn't go away.
    LEAK_ADDREF(LEAK_CFtpObj);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpObj::~CFtpObj()
{
    int ife;

    _CloseProgressDialog();
    for (ife = DROP_OFFERMIN; ife < DROP_OFFERMAX; ife++)
    {
        ReleaseStgMedium(&m_stgCache[ife]);
    }

    if (m_ppd)
        m_ppd->StopProgressDialog();

    IUnknown_Set((IUnknown **)&m_ppd, NULL);
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&m_pflHfpl, NULL);

    DSA_DestroyCallback(m_hdsaSetData, &_DSA_FreeCB, NULL);

    // NT #245306: If the user drags files from an FTP window (Thread 1)
    //    to a shell window (Thread 2), the shell window will do
    //    the drop on a background thread (thread 3).  Since the
    //    UI thread is no longer blocked, the user can now close
    //    the window.  The problem is that OLE is using Thread 2
    //    for marshalling.  In order to solve this problem, we
    //    ref count the thread for items that rely on it.
    //    This include FTP, normal Download, and other things
    //    in the future.
    ATOMICRELEASE(m_punkThreadRef);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpObj);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpObj::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpObj::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CFtpObj::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFtpObj, IDataObject),
        QITABENT(CFtpObj, IInternetSecurityMgrSite),
        QITABENT(CFtpObj, IPersist),
        QITABENT(CFtpObj, IPersistStream),
        QITABENT(CFtpObj, IAsyncOperation),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftppidl.cpp ===
/*****************************************************************************\
    ftppidl.cpp - Pointers to Item ID Lists

    This is the only file that knows the internal format of our IDLs.
\*****************************************************************************/

#include "priv.h"
#include "ftppidl.h"
#include "ftpurl.h"
#include "cookie.h"


#define NOT_INITIALIZED         10
DWORD g_fNoPasswordsInAddressBar = NOT_INITIALIZED;

#define SESSIONKEY      FILETIME

// Private FtpServerID Helpers
HRESULT FtpServerID_GetServer(LPCITEMIDLIST pidl, LPTSTR szServer, DWORD cchSize);
DWORD FtpItemID_GetTypeID(LPCITEMIDLIST pidl);

// v0 never went to customers but was used in NT5 before 1799       - Shipped in: Never.
// v1 This switch was to use password cookies for a security fix.   - Shipped in: Never.
// v2 this was done to not use the IDelegate's IMalloc for non-first ItemIDs  - Shipped in: Never (5/15/98)
// v3 add extra padding to ItemIDs so their dwType matches that of ServerIDs - Shipped in: IE5b1, IE5b2, NT5b2 (5/25/98)
// v4 add wzDisplayName to FtpItemID                                - Shipped in: IE5 RTM & NT5 b3  (11/16/98)

#define PIDL_VERSION_NUMBER_UPGRADE 3
#define PIDL_VERSION_NUMBER 4



#define     SIZE_ITEMID_SIZEFIELD        (sizeof(DWORD) + sizeof(WORD))
#define     SIZE_ITEMID_TERMINATOR       (sizeof(DWORD))


/****************************************************\
    IDType

    DESCRIPTION:
        These bits go into FTPIDLIST.dwIDType and describe
    what type of pidl it is AND which areas of the
    data structure have been verified by getting the
    data directly from the server.
\****************************************************/

#define IDTYPE_ISVALID           0x00000001    // Set if TYPE is valid
#define IDTYPE_SERVER            (0x00000002 | IDTYPE_ISVALID)    // Server
#define IDTYPE_DIR               (0x00000004 | IDTYPE_ISVALID)    // Folder/Dir
#define IDTYPE_FILE              (0x00000008 | IDTYPE_ISVALID)    // File
#define IDTYPE_FILEORDIR         (0x00000010 | IDTYPE_ISVALID)    // File or Dir.  Wasn't specified.
#define IDTYPE_FRAGMENT          (0x00000020 | IDTYPE_ISVALID)    // File Fragment (i.e. foobar.htm#SECTION_3)

// These are bits that indicate
// For Server ItemIDs
#define IDVALID_PORT_NUM         0x00000100     // Was the port number specified
#define IDVALID_USERNAME         0x00000200     // Was the login name specified
#define IDVALID_PASSWORD         0x00000400     // Was the password specified
#define IDVALID_DLTYPE           0x00000800     // Download Type is specified.
#define IDVALID_DL_ASCII         0x00001000     // Download as ASCII if set, otherwise, download as BINARY.
#define IDVALID_HIDE_PASSWORD    0x00002000     // The Password entry is invalid so use the sessionkey to look it up.

#define VALID_SERVER_BITS (IDTYPE_ISVALID|IDTYPE_SERVER|IDVALID_PORT_NUM|IDVALID_USERNAME|IDVALID_PASSWORD|IDVALID_DLTYPE|IDVALID_DL_ASCII|IDVALID_HIDE_PASSWORD)
#define IS_VALID_SERVER_ITEMID(pItemId) (!(pItemId & ~VALID_SERVER_BITS))

// For Dir/File ItemIDs
#define IDVALID_FILESIZE         0x00010000     // Did we get the file size from the server?
#define IDVALID_MOD_DATE         0x00020000     // Did we get the modification date from the server?

#define VALID_DIRORFILE_BITS (IDTYPE_ISVALID|IDTYPE_DIR|IDTYPE_FILE|IDTYPE_FILEORDIR|IDTYPE_FRAGMENT|IDVALID_FILESIZE|IDVALID_MOD_DATE)
#define IS_VALID_DIRORFILE_ITEMID(pItemId) (!(pItemId & (~VALID_DIRORFILE_BITS & ~IDTYPE_ISVALID)))


#define IS_FRAGMENT(pFtpIDList)       (IDTYPE_ISVALID != (IDTYPE_FRAGMENT & pFtpIDList->dwIDType))

///////////////////////////////////////////////////////////
// FTP Pidl Helper Functions 
///////////////////////////////////////////////////////////

/*****************************************************************************\
    FUNCTION: UrlGetAbstractPathFromPidl

    DESCRIPTION:
        pszUrlPath will be UNEscaped and in Wire Bytes.
\*****************************************************************************/
HRESULT UrlGetAbstractPathFromPidl(LPCITEMIDLIST pidl, BOOL fDirsOnly, BOOL fInWireBytes, void * pvPath, DWORD cchUrlPathSize)
{
    HRESULT hr = S_OK;
    LPWIRESTR pwWirePath = (LPWIRESTR) pvPath;
    LPWSTR pwzDisplayPath = (LPWSTR) pvPath;

    if (!EVAL(FtpPidl_IsValid(pidl)))
        return E_INVALIDARG;

    ASSERT(pvPath && (0 < cchUrlPathSize));
    ASSERT(IsValidPIDL(pidl));

    if (fInWireBytes)
    {
        pwWirePath[0] = '/';
        pwWirePath[1] = '\0'; // Make this path absolute.
    }
    else
    {
        pwzDisplayPath[0] = L'/';
        pwzDisplayPath[1] = L'\0'; // Make this path absolute.
    }

    if (!ILIsEmpty(pidl) && FtpID_IsServerItemID(pidl))       // If it's not a server, we are in trouble.
        pidl = _ILNext(pidl);   // Skip past the Server Pidl.

    for (; !ILIsEmpty(pidl); pidl = _ILNext(pidl))
    {
        if (!fDirsOnly || FtpItemID_IsDirectory(pidl, TRUE) || !ILIsEmpty(_ILNext(pidl)))
        {
            if (!FtpItemID_IsFragment(pidl))
            {
                if (fInWireBytes)
                {
                    LPCWIRESTR pwWireName = FtpItemID_GetWireNameReference(pidl);

                    if (pwWireName)
                    {
                        // The caller should never need the URL Path escaped because
                        // that will happen when it's converted into an URL.
                        WirePathAppend(pwWirePath, cchUrlPathSize, pwWireName);
                    }
                }
                else
                {
                    WCHAR szDisplayName[MAX_PATH];

                    if (SUCCEEDED(FtpItemID_GetDisplayName(pidl, szDisplayName, ARRAYSIZE(szDisplayName))))
                    {
                        // The caller should never need the URL Path escaped because
                        // that will happen when it's converted into an URL.
                        DisplayPathAppend(pwzDisplayPath, cchUrlPathSize, szDisplayName);
                    }
                }
            }
        }

        if (SUCCEEDED(hr) &&
            (FtpItemID_IsDirectory(pidl, FALSE) || (FtpItemID_GetCompatFlags(pidl) & COMPAT_APPENDSLASHTOURL)))
        {
            if (fInWireBytes)
                WirePathAppendSlash(pwWirePath, cchUrlPathSize); // Always make sure dirs end in '/'.
            else
                DisplayPathAppendSlash(pwzDisplayPath, cchUrlPathSize); // Always make sure dirs end in '/'.
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetDisplayPathFromPidl

    DESCRIPTION:
        pwzDisplayPath will be UNEscaped and in display unicode.
\*****************************************************************************/
HRESULT GetDisplayPathFromPidl(LPCITEMIDLIST pidl, LPWSTR pwzDisplayPath, DWORD cchUrlPathSize, BOOL fDirsOnly)
{
    return UrlGetAbstractPathFromPidl(pidl, fDirsOnly, FALSE, (void *) pwzDisplayPath, cchUrlPathSize);
}


/*****************************************************************************\
    FUNCTION: GetWirePathFromPidl

    DESCRIPTION:
        pszUrlPath will be UNEscaped and in Wire Bytes.
\*****************************************************************************/
HRESULT GetWirePathFromPidl(LPCITEMIDLIST pidl, LPWIRESTR pwWirePath, DWORD cchUrlPathSize, BOOL fDirsOnly)
{
    return UrlGetAbstractPathFromPidl(pidl, fDirsOnly, TRUE, (void *) pwWirePath, cchUrlPathSize);
}


#ifndef UNICODE
/*****************************************************************************\
    FUNCTION: UrlCreateFromPidlW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlCreateFromPidlW(LPCITEMIDLIST pidl, DWORD shgno, LPWSTR pwzUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];

    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), dwFlags, fHidePassword);
    if (SUCCEEDED(hr))
        SHTCharToUnicode(szUrl, pwzUrl, cchSize);

    return hr;
}

#else // UNICODE

/*****************************************************************************\
    FUNCTION: UrlCreateFromPidlA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlCreateFromPidlA(LPCITEMIDLIST pidl, DWORD shgno, LPSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];

    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), dwFlags, fHidePassword);
    if (SUCCEEDED(hr))
        SHTCharToAnsi(szUrl, pszUrl, cchSize);

    return hr;
}

#endif // UNICODE


BOOL IncludePassword(void)
{
    if (NOT_INITIALIZED == g_fNoPasswordsInAddressBar)
        g_fNoPasswordsInAddressBar = !SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_PASSWDSIN_ADDRBAR, FALSE, TRUE);

    return g_fNoPasswordsInAddressBar;
}


HRESULT ParseUrlCreateFromPidl(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr = S_OK;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR szFragment[MAX_PATH];
    TCHAR szDownloadType[MAX_PATH] = TEXT("");
    INTERNET_PORT ipPortNum = INTERNET_DEFAULT_FTP_PORT;

    if (ILIsEmpty(pidl))
    {
        ASSERT(0); // We should never have an empty pidl.  Get BryanSt if we hit this.  Why does CFtpFolder have ILIsEmpty(m_pidlHere).
        szServer[0] = szUrlPath[0] = szUserName[0] = szPassword[0] = TEXT('\0');
        hr = E_FAIL;
    }
    else
    {
        FtpPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer));
        GetDisplayPathFromPidl(pidl, szUrlPath, ARRAYSIZE(szUrlPath), FALSE);
        FtpPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName));
        if (FAILED(FtpPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), !fHidePassword)))
            szPassword[0] = 0;

        FtpPidl_GetFragment(pidl, szFragment, ARRAYSIZE(szPassword));
        FtpPidl_GetDownloadTypeStr(pidl, szDownloadType, ARRAYSIZE(szDownloadType));
        UrlPathAdd(szUrlPath, ARRAYSIZE(szUrlPath), szDownloadType);
        ipPortNum = FtpPidl_GetPortNum(pidl);
    }

    if (SUCCEEDED(hr))
    {
        hr = UrlCreateEx(szServer, NULL_FOR_EMPTYSTR(szUserName), szPassword, szUrlPath, szFragment, ipPortNum, szDownloadType, pszUrl, cchSize, dwFlags);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFullPrettyName
    
    DESCRIPTION:
        The user wants a pretty name so these are the cases we need to worry
    about:
    URL:                                               Pretty Name:
    ----------------------------------                 ---------------------
    ftp://joe:psswd@serv/                              serv
    ftp://joe:psswd@serv/dir1/                         dir1 on serv
    ftp://joe:psswd@serv/dir1/dir2/                    dir2 on serv
    ftp://joe:psswd@serv/dir1/dir2/file.txt            file.txt on serv
\*****************************************************************************/
HRESULT GetFullPrettyName(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

    FtpPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer));
    // Is there anything after the ServerItemID?
    if (!ILIsEmpty(_ILNext(pidl)))
    {
        // Yes, so let's get the name of the last item and
        // make the string "<LastItemName> on <Server>".
        WCHAR szLastItem[MAX_PATH];

        FtpItemID_GetDisplayName(ILFindLastID(pidl), szLastItem, ARRAYSIZE(szLastItem));
        LPTSTR pszStrArray[] = {szServer, (LPTSTR)szLastItem};
        
        // IE #56648: Akabir found that FormatMessageW & FormatMessageWrapW() do not
        // correctly handle UNICODE strings on Win9x.  Therefore, we need to use
        // FormatMessageA() in that case.
        if (IsOSNT())
        {
            TCHAR szTemplate[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_PRETTYNAMEFORMAT, szTemplate, ARRAYSIZE(szTemplate));
            EVAL(FormatMessage((FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY), (LPVOID)szTemplate,
                                0, 0, pszUrl, cchSize, (va_list*)pszStrArray));
        }
        else
        {
            CHAR szTemplateAnsi[MAX_PATH];
            CHAR szURLAnsi[MAX_URL_STRING];
            CHAR szServerAnsi[INTERNET_MAX_HOST_NAME_LENGTH];
            CHAR szFileNameAnsi[MAX_PATH];
            LPCSTR pszStrArrayAnsi[] = {szServerAnsi, szFileNameAnsi};

            SHTCharToAnsi(szServer, szServerAnsi, ARRAYSIZE(szServerAnsi));
            SHUnicodeToAnsi(szLastItem, szFileNameAnsi, ARRAYSIZE(szFileNameAnsi));

            LoadStringA(HINST_THISDLL, IDS_PRETTYNAMEFORMATA, szTemplateAnsi, ARRAYSIZE(szTemplateAnsi));
            EVAL(FormatMessageA((FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY), (LPVOID)szTemplateAnsi,
                                0, 0, szURLAnsi, ARRAYSIZE(szURLAnsi), (va_list*)pszStrArrayAnsi));

            SHAnsiToTChar(szURLAnsi, pszUrl, cchSize);
        }
    }
    else
    {
        // No, so we are done.
        StrCpyN(pszUrl, szServer, cchSize);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlCreateFromPidl
    
    DESCRIPTION:
        Common worker that handles SHGDN_FORPARSING style GetDisplayNameOf's.

    Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    _CHARSET_:  Since FTP filenames are always in the ANSI character
    set, by RFC 1738, we can return ANSI display names without loss
    of fidelity.  In a general folder implementation, we should be
    using cStr to return display names, so that the UNICODE
    version of the shell extension can handle UNICODE names.
\*****************************************************************************/
HRESULT UrlCreateFromPidl(LPCITEMIDLIST pidl, DWORD shgno, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr = S_OK;

    pszUrl[0] = 0;
    if (!EVAL(pidl) ||
        !EVAL(IsValidPIDL(pidl)) ||
        !FtpPidl_IsValid(pidl) ||
        !FtpID_IsServerItemID(pidl) ||
        !EVAL(pszUrl && (0 < cchSize)))
    {
        return E_INVALIDARG;
    }

    if (shgno & SHGDN_INFOLDER)
    {
        // shgno & SHGDN_INFOLDER ?
        LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

        if (EVAL(pidlLast && !ILIsEmpty(pidlLast)))
        {
            hr = FtpPidl_GetDisplayName(pidlLast, pszUrl, cchSize);

            // Do they want to reparse it later?  If they do and it's
            // a server, we need to give out the scheme also.
            // (SHGDN_INFOLDER) = "ServerName"
            // (SHGDN_INFOLDER|SHGDN_FORPARSING) = "ftp://ServerName/"
            if ((shgno & SHGDN_FORPARSING) &&
                (FtpID_IsServerItemID(pidlLast)))
            {
                // Yes, so we need to add the server name.
                TCHAR szServerName[MAX_PATH];

                StrCpyN(szServerName, pszUrl, ARRAYSIZE(szServerName));
                wnsprintf(pszUrl, cchSize, TEXT("ftp://%s/"), szServerName);
            }
        }
        else
            hr = E_FAIL;
    }
    else
    {
        // Assume they want the full URL.
        if (!EVAL((shgno & SHGDN_FORPARSING) || 
               (shgno & SHGDN_FORADDRESSBAR) ||
               (shgno == SHGDN_NORMAL)))
        {
            TraceMsg(TF_ALWAYS, "UrlCreateFromPidl() shgno=%#08lx and I dont know what to do with that.", shgno);
        }

        if ((shgno & SHGDN_FORPARSING) || (shgno & SHGDN_FORADDRESSBAR))
        {
            hr = ParseUrlCreateFromPidl(pidl, pszUrl, cchSize, dwFlags, fHidePassword);
        }
        else
            hr = GetFullPrettyName(pidl, pszUrl, cchSize);
    }

//    TraceMsg(TF_FTPURL_UTILS, "UrlCreateFromPidl() pszUrl=%ls, shgno=%#08lX", pszUrl, shgno);
    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateFtpPidlFromDisplayPathHelper

    DESCRIPTION:
        The work done in CreateFtpPidlFromUrlPath requires a fair amount of
    stack space so we do most of the work in CreateFtpPidlFromDisplayPathHelper
    to prevent overflowing the stack.
\*****************************************************************************/
HRESULT CreateFtpPidlFromDisplayPathHelper(LPCWSTR pwzFullPath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir, LPITEMIDLIST * ppidlCurrentID, LPWSTR * ppwzRemaining)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    WCHAR wzFirstItem[MAX_PATH];
    WIRECHAR wFirstWireItem[MAX_PATH];
    WCHAR wzRemaining[MAX_PATH];
    BOOL fIsCurrSegmentADir = FALSE;
    BOOL fIsCurrSegmentTypeKnown = fIsTypeKnown;
    BOOL fIsFragSeparator = FALSE;

    *ppwzRemaining = NULL;
    *ppidl = 0;

    if (pcchEaten)
        *pcchEaten = 0;     // The caller will parse the entire URL so we don't need to fill this in.

    if (L'/' == pwzFullPath[0])
        pwzFullPath = (LPWSTR) CharNextW(pwzFullPath);

    DisplayPathGetFirstSegment(pwzFullPath, wzFirstItem, ARRAYSIZE(wzFirstItem), NULL, wzRemaining, ARRAYSIZE(wzRemaining), &fIsCurrSegmentADir);
    // Is this the last segment?
    if (!wzRemaining[0])
    {
        // Yes, so if the caller knows the type of the last segment, use it now.
        if (fIsTypeKnown)
            fIsCurrSegmentADir = fIsDir;
    }
    else
    {
        // No, so we are assured that fIsDirCurrent is correct because it must have been followed
        // by a '/', or how could it be followed by another path segment?
        fIsCurrSegmentTypeKnown = TRUE;
        ASSERT(fIsCurrSegmentADir);
    }

    // NOTE: If the user entered "ftp://serv/Dir1/Dir2" fIsDir will be false for Dir2.
    //       It will be marked as ambigious. (TODO: Check for extension?)

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, wzFirstItem, ((pwe && pwe->IsUTF8Supported()) ? WIREENC_USE_UTF8 : WIREENC_NONE), wFirstWireItem, ARRAYSIZE(wFirstWireItem))));
    hr = FtpItemID_CreateFake(wzFirstItem, wFirstWireItem, fIsCurrSegmentTypeKnown, !fIsCurrSegmentADir, FALSE, &pidl);
    ASSERT(IsValidPIDL(pidl));

    if (SUCCEEDED(hr))
    {
        if (wzRemaining[0])
        {
            Str_SetPtrW(ppwzRemaining, wzRemaining);
            *ppidlCurrentID = pidl;
        }
        else
            *ppidl = pidl;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateFtpPidlFromUrlPath

    DESCRIPTION:
        This function will be passed the 'Path' of the URL and will create
    each of the IDs for each path segment.  This will happen by creating an ID
    for the first path segment and then Combining that with the remaining
    IDs which are obtained by a recursive call.

    URL = "ftp://<UserName>:<Password>@<HostName>:<PortNum>/Dir1/Dir2/Dir3/file.txt[;Type=[a|b|d]]"
    Url Path = "Dir1/Dir2/Dir3/file.txt"

    pszFullPath - This URL will contain an URL Path (/Dir1/Dir2/MayBeFileOrDir).
    fIsTypeKnown - We can detect all directories w/o ambiguity because they end
                   end '/' except for the last directory.  fIsTypeKnown is used
                   if this information is known.  If TRUE, fIsDir will be used to
                   disambiguate the last item.  If FALSE, the last item will be marked
                   a directory if it doesn't have an extension.

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateFtpPidlFromDisplayPath(LPCWSTR pwzFullPath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir)
{
    HRESULT hr = E_FAIL;
    LPWSTR pwzRemaining = NULL;
    LPITEMIDLIST pidlCurrentID = NULL;

    hr = CreateFtpPidlFromDisplayPathHelper(pwzFullPath, pwe, pcchEaten, ppidl, fIsTypeKnown, fIsDir, &pidlCurrentID, &pwzRemaining);
    if (SUCCEEDED(hr) && pwzRemaining)
    {
        LPITEMIDLIST pidlSub;

        hr = CreateFtpPidlFromDisplayPath(pwzRemaining, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
        if (SUCCEEDED(hr))
        {
            *ppidl = ILCombine(pidlCurrentID, pidlSub);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
            ILFree(pidlSub);
        }

        ILFree(pidlCurrentID);
        Str_SetPtrW(&pwzRemaining, NULL);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateFtpPidlFromDisplayPathHelper

    DESCRIPTION:
        The work done in CreateFtpPidlFromUrlPath requires a fair amount of
    stack space so we do most of the work in CreateFtpPidlFromDisplayPathHelper
    to prevent overflowing the stack.
\*****************************************************************************/
HRESULT CreateFtpPidlFromFtpWirePathHelper(LPCWIRESTR pwFtpWirePath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir, LPITEMIDLIST * ppidlCurrentID, LPWIRESTR * ppwRemaining)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    WIRECHAR wFirstItem[MAX_PATH];
    WCHAR wzFirstItemDisplayName[MAX_PATH];
    WIRECHAR wRemaining[MAX_PATH];
    BOOL fIsCurrSegmentADir = FALSE;
    BOOL fIsCurrSegmentTypeKnown = fIsTypeKnown;
    BOOL fIsFragSeparator = FALSE;

    *ppwRemaining = NULL;
    *ppidl = 0;

    if (pcchEaten)
        *pcchEaten = 0;     // The caller will parse the entire URL so we don't need to fill this in.

    if ('/' == pwFtpWirePath[0])
        pwFtpWirePath = (LPWIRESTR) CharNextA(pwFtpWirePath);

    WirePathGetFirstSegment(pwFtpWirePath, wFirstItem, ARRAYSIZE(wFirstItem), NULL, wRemaining, ARRAYSIZE(wRemaining), &fIsCurrSegmentADir);
    // Is this the last segment?
    if (!wRemaining[0])
    {
        // Yes, so if the caller knows the type of the last segment, use it now.
        if (fIsTypeKnown)
            fIsCurrSegmentADir = fIsDir;
    }
    else
    {
        // No, so we are assured that fIsDirCurrent is correct because it must have been followed
        // by a '/', or how could it be followed by another path segment?
        fIsCurrSegmentTypeKnown = TRUE;
        ASSERT(fIsCurrSegmentADir);
    }

    // NOTE: If the user entered "ftp://serv/Dir1/Dir2" fIsDir will be false for Dir2.
    //       It will be marked as ambigious. (TODO: Check for extension?)
    EVAL(SUCCEEDED(pwe->WireBytesToUnicode(NULL, wFirstItem, WIREENC_IMPROVE_ACCURACY, wzFirstItemDisplayName, ARRAYSIZE(wzFirstItemDisplayName))));
    hr = FtpItemID_CreateFake(wzFirstItemDisplayName, wFirstItem, fIsCurrSegmentTypeKnown, !fIsCurrSegmentADir, FALSE, &pidl);
    ASSERT(IsValidPIDL(pidl));

    if (SUCCEEDED(hr))
    {
        if (wRemaining[0])
        {
            Str_SetPtrA(ppwRemaining, wRemaining);
            *ppidlCurrentID = pidl;
        }
        else
            *ppidl = pidl;
    }

    return hr;
}


HRESULT CreateFtpPidlFromFtpWirePath(LPCWIRESTR pwFtpWirePath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir)
{
    HRESULT hr = E_FAIL;
    LPWIRESTR pwRemaining = NULL;
    LPITEMIDLIST pidlCurrentID = NULL;

    *ppidl = NULL;
    if (!pwFtpWirePath[0] || (0 == StrCmpA(pwFtpWirePath, SZ_URL_SLASHA)))
        return S_OK;

    hr = CreateFtpPidlFromFtpWirePathHelper(pwFtpWirePath, pwe, pcchEaten, ppidl, fIsTypeKnown, fIsDir, &pidlCurrentID, &pwRemaining);
    if (SUCCEEDED(hr) && pwRemaining)
    {
        LPITEMIDLIST pidlSub;

        hr = CreateFtpPidlFromFtpWirePath(pwRemaining, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
        if (SUCCEEDED(hr))
        {
            *ppidl = ILCombine(pidlCurrentID, pidlSub);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
            ILFree(pidlSub);
        }

        ILFree(pidlCurrentID);
        Str_SetPtrA(&pwRemaining, NULL);
    }

    return hr;
}


HRESULT CreateFtpPidlFromUrlPathAndPidl(LPCITEMIDLIST pidl, CWireEncoding * pwe, LPCWIRESTR pwFtpWirePath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNew = ILClone(pidl);

    if (pidlNew)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST) ILGetLastID(pidlNew);

        while (!FtpID_IsServerItemID(pidlLast))
        {
            pidlLast->mkid.cb = 0;  // Remove this ID.
            pidlLast = (LPITEMIDLIST) ILGetLastID(pidlNew);
        }

        LPITEMIDLIST pidlUrlPath = NULL;
        hr = CreateFtpPidlFromFtpWirePath(pwFtpWirePath, pwe, NULL, &pidlUrlPath, TRUE, TRUE);
        if (SUCCEEDED(hr))
        {
            *ppidl = ILCombine(pidlNew, pidlUrlPath);
        }

        if (pidlLast)
            ILFree(pidlLast);

        if (pidlUrlPath)
            ILFree(pidlUrlPath);
    }

    return hr;
}


/*****************************************************************************\
    CreateFtpPidlFromUrl

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateFtpPidlFromUrl(LPCTSTR pszUrl, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword)
{
    return CreateFtpPidlFromUrlEx(pszUrl, pwe, pcchEaten, ppidl, pm, fHidePassword, FALSE, FALSE);
}


/*****************************************************************************\
    FUNCTION: CreateFtpPidlFromUrlEx

    DESCRIPTION:
    pszUrl - This URL will contain an URL Path (/Dir1/Dir2/MayBeFileOrDir).
    fIsTypeKnown - We can detect all directories w/o ambiguity because they end
                   end '/' except for the last directory.  fIsTypeKnown is used
                   if this information is known.  If TRUE, fIsDir will be used to
                   disambiguate the last item.  If FALSE, the last item will be marked
                   a directory if it doesn't have an extension.

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateFtpPidlFromUrlEx(LPCTSTR pszUrl, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword, BOOL fIsTypeKnown, BOOL fIsDir)
{
    URL_COMPONENTS urlComps = {0};
    HRESULT hr = E_FAIL;

    // URL = "ftp://<UserName>:<Password>@<HostName>:<PortNum>/Dir1/Dir2/Dir3/file.txt[;Type=[a|b|d]]"
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szExtraInfo[MAX_PATH];    // Includes Port Number and download type (ASCII, Binary, Detect)
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    *ppidl = 0;

    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);

    urlComps.lpszUserName = szUserName;
    urlComps.dwUserNameLength = ARRAYSIZE(szUserName);
    urlComps.lpszPassword = szPassword;
    urlComps.dwPasswordLength = ARRAYSIZE(szPassword);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    BOOL fResult = InternetCrackUrl(pszUrl, 0, ICU_DECODE, &urlComps);
    if (fResult && (INTERNET_SCHEME_FTP == urlComps.nScheme))
    {
        LPITEMIDLIST pidl;
        DWORD dwDownloadType = 0;   // Indicate that it hasn't yet been specified.
        BOOL fASCII;

        ASSERT(INTERNET_SCHEME_FTP == urlComps.nScheme);
        // NOTE:
        //          If the user is trying to give an NT UserName/DomainName pair, a bug will be encountered.
        //          Url in AddressBand="ftp://DomainName\UserName:Password@ServerName/"
        //          Url passed to us="ftp://DomainName/UserName:Password@ServerName/"
        //          We need to detect this case and fix it because this will cause "DomainName" to become
        //          the server name and the rest will become the UrlPath.
        // ASSERT(!StrChr(szUrlPath, TEXT(':')) && !StrChr(szUrlPath, TEXT('@')));

        if (S_OK == UrlRemoveDownloadType(szUrlPath, NULL, &fASCII))
        {
            if (fASCII)
                dwDownloadType = (IDVALID_DLTYPE | IDVALID_DL_ASCII);
            else
                dwDownloadType = IDVALID_DLTYPE;
        }

        if (!szServer[0])
        {
            TraceMsg(TF_FTPURL_UTILS, "CreateFtpPidlFromUrl() failed because szServer=%s", szServer);
            hr = E_FAIL;    // Bad URL so fail.
        }
        else
        {
            //TraceMsg(TF_FTPURL_UTILS, "CreateFtpPidlFromUrl() szServer=%s, szUrlPath=%s, szUserName=%s, szPassword=%s", szServer, szUrlPath, szUserName, szPassword);
            hr = FtpServerID_Create(szServer, szUserName, szPassword, dwDownloadType, urlComps.nPort, &pidl, pm, fHidePassword);
            if (SUCCEEDED(hr))
            {
                ASSERT(IsValidPIDL(pidl));
                if (szUrlPath[0] && StrCmp(szUrlPath, SZ_URL_SLASH))
                {
                    LPITEMIDLIST pidlSub;

                    hr = CreateFtpPidlFromDisplayPath(szUrlPath, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
                    if (SUCCEEDED(hr))
                    {
                        // Wininet chokes during requests through Netscape proxies when the GET is
                        // redirected by the proxy to include the slash.  Both FTP folder and
                        // web-based FTP navigations are affected by this.
                        if (szUrlPath[lstrlen(szUrlPath)-1] == TEXT(CH_URL_URL_SLASHA))
                        {
                            LPCITEMIDLIST pidlLast = ILGetLastID(pidlSub);

                            if (pidlLast)
                                FtpItemID_SetCompatFlags(pidlLast, FtpItemID_GetCompatFlags(pidlLast) | COMPAT_APPENDSLASHTOURL);
                        }
                        *ppidl = ILCombine(pidl, pidlSub);
                        if (szExtraInfo[0])
                        {
                            LPITEMIDLIST pidlFragment;
                            WIRECHAR wFragment[MAX_PATH];

                            // The code page is just whatever the user is using but oh well, I don't 
                            // care about fragments.
                            SHUnicodeToAnsi(szExtraInfo, wFragment, ARRAYSIZE(wFragment));
                            // There is a fragment, so we need to add it.
                            hr = FtpItemID_CreateFake(szExtraInfo, wFragment, TRUE, FALSE, TRUE, &pidlFragment);
                            if (SUCCEEDED(hr))
                            {
                                LPITEMIDLIST pidlPrevious = *ppidl;

                                *ppidl = ILCombine(pidlPrevious, pidlFragment);
                                ILFree(pidlPrevious);
                                ILFree(pidlFragment);
                            }
                        }

                        hr = *ppidl ? S_OK : E_OUTOFMEMORY;
                        ILFree(pidlSub);
                    }
                    ILFree(pidl);
                }
                else
                    *ppidl = pidl;

                if (SUCCEEDED(hr))
                {
                    ASSERT(IsValidPIDL(*ppidl));
                    if (pcchEaten)
                        *pcchEaten = lstrlen(pszUrl);      // TODO: Someday we can do this recursively.
                }
            }
        }
    }
    else
        TraceMsg(TF_FTPURL_UTILS, "CreateFtpPidlFromUrl() failed InternetCrackUrl() because pszUrl=%s, fResult=%d, urlComps.nScheme=%d", pszUrl, fResult, urlComps.nScheme);

    //TraceMsg(TF_FTPURL_UTILS, "CreateFtpPidlFromUrl() is returning, hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: Win32FindDataFromPidl
 
    DESCRIPTION:
        Fill in the WIN32_FIND_DATA data structure from the info in the pidl.
\*****************************************************************************/
HRESULT Win32FindDataFromPidl(LPCITEMIDLIST pidl, LPWIN32_FIND_DATAW pwfd, BOOL fFullPath, BOOL fInDisplayFormat)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    ASSERT(pwfd);
    if (!EVAL(FtpPidl_IsValid(pidl)))
        return E_INVALIDARG;

    // I don't want to lie when I pass out File Size and Date info.
    if ((IDVALID_FILESIZE | IDVALID_MOD_DATE) & FtpItemID_GetTypeID(pidlLast))
    {
        pwfd->dwReserved0 = 0;
        pwfd->dwReserved1 = 0;
        pwfd->cAlternateFileName[0] = 0;

        pwfd->nFileSizeLow = FtpItemID_GetFileSizeLo(pidlLast);
        pwfd->nFileSizeHigh = FtpItemID_GetFileSizeHi(pidlLast);
        pwfd->dwFileAttributes = FtpItemID_GetAttributes(pidlLast);

        // See the notes in priv.h on how time works.
        pwfd->ftCreationTime = FtpPidl_GetFTPFileTime(pidlLast);
        pwfd->ftLastWriteTime = pwfd->ftCreationTime;
        pwfd->ftLastAccessTime = pwfd->ftCreationTime;

        if (fFullPath)
        {
            if (fInDisplayFormat)
                hr = GetDisplayPathFromPidl(pidl, pwfd->cFileName, ARRAYSIZE(pwfd->cFileName), FALSE);
            else
                hr = GetWirePathFromPidl(pidl, (LPWIRESTR)pwfd->cFileName, ARRAYSIZE(pwfd->cFileName), FALSE);
        }
        else
        { 
            hr = S_OK;
            if (fInDisplayFormat)
            {
                FtpPidl_GetLastFileDisplayName(pidl, pwfd->cFileName, ARRAYSIZE(pwfd->cFileName));
            }
            else
            {
                LPCWIRESTR pszName = FtpPidl_GetLastItemWireName(pidl);

                StrCpyNA((LPWIRESTR)pwfd->cFileName, (pszName ? pszName : ""), ARRAYSIZE(pwfd->cFileName));
            }
        }
    }

    return hr;
}



STDAPI_(UINT) ILGetSizeOfFirst(LPCITEMIDLIST pidl)
{
    return pidl->mkid.cb;
}





/****************************************************\
    FTP Server ItemIDs
\****************************************************/

/****************************************************\
    FTP PIDL Cooking functions
\****************************************************/

/*****************************************************************************\
    DATA STRUCTURE: FTPIDLIST

    DESCRIPTION:
        What our private IDLIST looks like for a file, a dir, or a fragment.

    The bytes sent to an ftp server or received from an FTP server are
    wire bytes (could be UTF-8 or DBCS/MBCS) encoded.  We also store
    a unicode version that has already been converted after trying to guess
    the code page.

    Note that the use of any TCHAR inside an IDLIST is COMPLETELY WRONG!
    IDLISTs can be saved in a file and reloaded later.  If it were saved
    by an ANSI version of the shell extension but loaded by a UNICODE
    version, things would turn ugly real fast.
\*****************************************************************************/

/*****************************************************************************\
    FTPSERVERIDLIST structure

    A typical full pidl looks like this:
    <Not Our ItemID> [Our ItemID]

    <The Internet>\[server,username,password,port#,downloadtype]\[subdir]\...\[file]

    The <The Internet> part is whatever the shell gives us in our
    CFtpFolder::_Initialize, telling us where in the namespace
    we are rooted.

    We are concerned only with the parts after the <The Internet> root,
    the offset to which is remembered in the CFtpFolder class
    in m_ibPidlRoot.  Ways of accessing various bits of
    information related to our full pidl are provided by our
    CFtpFolder implementation, qv.

    The first FTP IDList entry describes the server.  The remaining
    entries describe objects (files or folders) on the server.
\*****************************************************************************/

typedef struct tagFTPSERVERIDLIST
{
    DWORD dwIDType;                 // Server ItemID or Dir ItemID?  Which Bits are valid?
    DWORD dwVersion;                // version
    SESSIONKEY sessionKey;          // Session Key
    DWORD dwPasswordCookie;         // Password Cookie
    DWORD dwReserved1;              // for future use
    DWORD dwReserved2;              // for future use
    DWORD dwReserved3;              // for future use
    DWORD dwPortNumber;             // Port Number on server
    DWORD cchServerSize;            // StrLen of szServer
    CHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];        // Server
    DWORD cchUserNameSize;          // StrLen of szUserName
    CHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];      // User Name for Login
    DWORD cchPasswordSize;          // StrLen of szPassword
    CHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];      // Password for Login
} FTPSERVERIDLIST;

typedef UNALIGNED FTPSERVERIDLIST * LPFTPSERVERIDLIST;



/*****************************************************************************\
    DESCRIPTION:
        On ia64, we need to worry about alignment issues.  The easiest way is
    to allocate the struct we have in our PIDL so it's quad word aligned.
    We can then use existing code to read out of it.  The problem is that
    we need to be compatible with old pidls from pre-whistler that are only
    DWORD aligned (for alpha machines).
\*****************************************************************************/
LPFTPSERVERIDLIST FtpServerID_GetDataThunk(LPCITEMIDLIST pidl)
{
#ifndef ALIGNMENT_MACHINE
    LPFTPSERVERIDLIST pFtpServerItemId = (LPFTPSERVERIDLIST) ProtocolIdlInnerData(pidl);
    if (!FtpPidl_IsValid(pidl) ||
        !IS_VALID_SERVER_ITEMID(pFtpServerItemId->dwIDType)) // If any other bits are sit, it's invalid.
    {
        pFtpServerItemId = NULL;
    }

#else
    LPFTPSERVERIDLIST pFtpServerItemId = NULL;
    LPFTPSERVERIDLIST pLocation = (LPFTPSERVERIDLIST) ProtocolIdlInnerData(pidl);

    if (FtpPidl_IsValid(pidl) &&
        IS_VALID_SERVER_ITEMID(pLocation->dwIDType)) // If any other bits are sit, it's invalid.
    {
        DWORD cbOffset = (DWORD) (((BYTE *)pLocation - (BYTE *)pidl) % ALIGN_QUAD);
        DWORD cbSize = ILGetSizeOfFirst(pidl);
        pFtpServerItemId = (LPFTPSERVERIDLIST) LocalAlloc(LPTR, cbSize + cbOffset);
        if (pFtpServerItemId)
        {
            CopyMemory(pFtpServerItemId, pLocation, cbSize-cbOffset);
        }
    }

#endif // ALIGNMENT_MACHINE

    return pFtpServerItemId;
}


void FtpServerID_FreeThunk(LPFTPSERVERIDLIST pFtpServerItemId)
{
#ifndef ALIGNMENT_MACHINE
    // We don't need to do anything.
#else
    if (pFtpServerItemId)
    {
        LocalFree(pFtpServerItemId);
    }
#endif // ALIGNMENT_MACHINE
}


LPFTPSERVERIDLIST FtpServerID_GetDataSafe(LPCITEMIDLIST pidl)
{
    LPFTPSERVERIDLIST pFtpServerItemId = NULL;
    
    if (EVAL(pidl) && !ILIsEmpty(pidl))
    {
        pFtpServerItemId = (LPFTPSERVERIDLIST) ProtocolIdlInnerData(pidl);
    }

    return pFtpServerItemId;
}


LPFTPSERVERIDLIST FtpServerID_GetDataSafeThunk(LPCITEMIDLIST pidl)
{
    LPFTPSERVERIDLIST pFtpServerItemId = NULL;
    
    if (pidl && !ILIsEmpty(pidl))
    {
        pFtpServerItemId = FtpServerID_GetDataThunk(pidl);
    }

    return pFtpServerItemId;
}


BOOL FtpID_IsServerItemID(LPCITEMIDLIST pidl)
{
    LPFTPSERVERIDLIST pFtpServerItemID = FtpServerID_GetDataSafeThunk(pidl);
    BOOL fIsServerItemID = FALSE;

    if (pFtpServerItemID && IS_VALID_SERVER_ITEMID(pFtpServerItemID->dwIDType))
        fIsServerItemID = TRUE;

    FtpServerID_FreeThunk(pFtpServerItemID);
    return fIsServerItemID;
}


LPCITEMIDLIST FtpID_GetLastIDReferense(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlCurrent = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (!pidl || ILIsEmpty(pidl))
        return pidl;

    for (; !ILIsEmpty(pidlNext); pidl = _ILNext(pidl))
    {
        pidlCurrent = pidlNext;
        pidlNext = _ILNext(pidlNext);
    }

    return pidlCurrent;
}


CCookieList * g_pCookieList = NULL;

CCookieList * GetCookieList(void)
{
    ENTERCRITICAL;
    if (!g_pCookieList)
        g_pCookieList = new CCookieList();
    ASSERT(g_pCookieList);
    LEAVECRITICAL;

    return g_pCookieList;
}

SESSIONKEY g_SessionKey = {-1, -1};

HRESULT PurgeSessionKey(void)
{
    GetSystemTimeAsFileTime(&g_SessionKey);

    return S_OK;
}

SESSIONKEY GetSessionKey(void)
{    
    if (-1 == g_SessionKey.dwHighDateTime)
        PurgeSessionKey();
    
    return g_SessionKey;
}

BOOL AreSessionKeysEqual(SESSIONKEY sk1, SESSIONKEY sk2)
{
    if ((sk1.dwHighDateTime == sk2.dwHighDateTime) &&
        (sk1.dwLowDateTime == sk2.dwLowDateTime))
    {
        return TRUE;
    }

    return FALSE;
}

// This is used in order to make sure Alpha machines don't get DWORD mis-aligned.
#define LENGTH_AFTER_ALIGN(nLen, nAlignSize)        (((nLen) % (nAlignSize)) ? ((nLen) + ((nAlignSize) - ((nLen) % (nAlignSize)))) : (nLen))

/****************************************************\
    FUNCTION: FtpServerID_Create

    DESCRIPTION:
        Create a Ftp Server ItemID and fill it in.
\****************************************************/
HRESULT FtpServerID_Create(LPCTSTR pszServer, LPCTSTR pszUserName, LPCTSTR pszPassword, 
                     DWORD dwFlags, INTERNET_PORT ipPortNum, LPITEMIDLIST * ppidl, IMalloc *pm, BOOL fHidePassword)
{
    HRESULT hr;
    DWORD cb;
    LPITEMIDLIST pidl = NULL;
    DWORD cchServerLen = lstrlen(pszServer);
    DWORD cchUserNameLen = lstrlen(pszUserName);
    DWORD cchPasswordLen = lstrlen(pszPassword);
    LPFTPSERVERIDLIST pFtpServerID = NULL;

    cchServerLen = LENGTH_AFTER_ALIGN(cchServerLen + 1, sizeof(DWORD));
    cchUserNameLen = LENGTH_AFTER_ALIGN(cchUserNameLen + 1, sizeof(DWORD));
    cchPasswordLen = LENGTH_AFTER_ALIGN(cchPasswordLen + 1, sizeof(DWORD));

    if (!(EVAL(ppidl) && pszServer[0]))
        return E_FAIL;

    // Set bits in dwFlags that are appropriate
    if (pszUserName[0])
        dwFlags |= IDVALID_USERNAME;

    if (pszPassword[0])
        dwFlags |= IDVALID_PASSWORD;

    // Find lenght of FTPSERVERIDLIST struct without the MAX_PATH strings
    cb = (sizeof(*pFtpServerID) - sizeof(pFtpServerID->szServer) - sizeof(pFtpServerID->szUserName) - sizeof(pFtpServerID->szPassword));

    // Add the size of the strings.
    cb += (cchServerLen + cchUserNameLen + cchPasswordLen);

    ASSERT(0 == (cb % sizeof(DWORD)));  // Make sure it's DWORD aligned for Alpha machines.

    pFtpServerID = (LPFTPSERVERIDLIST) LocalAlloc(LPTR, cb);
    if (pFtpServerID)
    {
        LPSTR pszNext;

        pszNext = pFtpServerID->szServer;

        ZeroMemory(pFtpServerID, cb);
        pFtpServerID->dwIDType = (dwFlags | IDTYPE_ISVALID | IDTYPE_SERVER | IDVALID_PORT_NUM);
        ASSERT(IS_VALID_SERVER_ITEMID(pFtpServerID->dwIDType));

        pFtpServerID->dwVersion = PIDL_VERSION_NUMBER;
        pFtpServerID->sessionKey = GetSessionKey();
        pFtpServerID->dwPasswordCookie = -1;
        pFtpServerID->dwPortNumber = ipPortNum;

        pFtpServerID->cchServerSize = cchServerLen;
        SHTCharToAnsi(pszServer, pszNext, pFtpServerID->cchServerSize);

        pszNext += cchServerLen; // Advance to cchUserNameSize
        *((LPDWORD) pszNext) = cchUserNameLen;  // Fill in cchUserNameSize
        pszNext = (LPSTR)(((UNALIGNED BYTE *) pszNext) + sizeof(DWORD)); // Advance to szUserName
        SHTCharToAnsi(pszUserName, pszNext, cchUserNameLen);

        if (fHidePassword)
        {
            pFtpServerID->dwIDType |= IDVALID_HIDE_PASSWORD;
            if (EVAL(GetCookieList()))
                pFtpServerID->dwPasswordCookie = GetCookieList()->GetCookie(pszPassword);

            ASSERT(-1 != pFtpServerID->dwPasswordCookie);
            pszPassword = TEXT("");
        }

//        TraceMsg(TF_FTPURL_UTILS, "FtpServerID_Create(\"ftp://%s:%s@%s/\") dwIDType=%#80lx", pszUserName, pszPassword, pszServer, pFtpServerID->dwIDType);
        pszNext += cchUserNameLen; // Advance to cchPasswordLen
        *((LPDWORD) pszNext) = cchPasswordLen;  // Fill in cchPasswordLen
        pszNext = (LPSTR)(((UNALIGNED BYTE *) pszNext) + sizeof(DWORD)); // Advance to szPassword
        SHTCharToAnsi(pszPassword, pszNext, cchPasswordLen);  // Fill in pszPassword

        pidl = (LPITEMIDLIST) pm->Alloc(cb);
        if (pidl)
        {
            LPFTPSERVERIDLIST pFtpServerIDDest = FtpServerID_GetDataSafe(pidl);

            if (pFtpServerIDDest)
            {
                CopyMemory(pFtpServerIDDest, pFtpServerID, cb);
            }
        }

        LocalFree(pFtpServerID);
    }

    *ppidl = pidl;
    hr = pidl ? S_OK : E_OUTOFMEMORY;
    ASSERT(IsValidPIDL(*ppidl));

    return hr;
}


DWORD FtpServerID_GetTypeID(LPCITEMIDLIST pidl)
{
    DWORD dwResult = 0;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    ASSERT(FtpID_IsServerItemID(pidl));
    if (pFtpServerID && 
        EVAL(FtpPidl_IsValid(pidl)))
    {
        dwResult = pFtpServerID->dwIDType;
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return dwResult;
}


HRESULT FtpServerID_GetServer(LPCITEMIDLIST pidl, LPTSTR pszServer, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    if (pFtpServerID)
    {
        SHAnsiToTChar(pFtpServerID->szServer, pszServer, cchSize);
        FtpServerID_FreeThunk(pFtpServerID);
		hr = S_OK;
    }

    return hr;
}


BOOL FtpServerID_ServerStrCmp(LPCITEMIDLIST pidl, LPCTSTR pszServer)
{
    BOOL fMatch = FALSE;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

#ifdef UNICODE
    CHAR szServerAnsi[MAX_PATH];

    SHUnicodeToAnsi(pszServer, szServerAnsi, ARRAYSIZE(szServerAnsi));
#endif // UNICODE

    if (pFtpServerID)
    {
#ifdef UNICODE
        fMatch = (0 == StrCmpA(pFtpServerID->szServer, szServerAnsi));
#else // UNICODE
        fMatch = (0 == StrCmpA(pFtpServerID->szServer, pszServer));
#endif // UNICODE
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return fMatch;
}


HRESULT FtpServerID_GetUserName(LPCITEMIDLIST pidl, LPTSTR pszUserName, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    if (pFtpServerID)
    {
        LPCSTR pszSourceUserName = pFtpServerID->szServer + pFtpServerID->cchServerSize + sizeof(DWORD);

        SHAnsiToTChar(pszSourceUserName, pszUserName, cchSize);
        hr = S_OK;
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return hr;
}

HRESULT FtpServerID_GetPassword(LPCITEMIDLIST pidl, LPTSTR pszPassword, DWORD cchSize, BOOL fIncludingHiddenPassword)
{
    HRESULT hr = E_FAIL;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    pszPassword[0] = 0;
    if (pFtpServerID)
    {
        // Was the password hidden?
        if (fIncludingHiddenPassword &&
            (IDVALID_HIDE_PASSWORD & pFtpServerID->dwIDType))
        {
            // Yes, so get it out of the cookie jar (list)
            if (EVAL(GetCookieList()) &&
                AreSessionKeysEqual(pFtpServerID->sessionKey, GetSessionKey()))
            {
                hr = GetCookieList()->GetString(pFtpServerID->dwPasswordCookie, pszPassword, cchSize);
            }
        }
        else
        {
            // No, so what's in the pidl is the real password.
            BYTE * pvSizeOfUserName = (BYTE *) (pFtpServerID->szServer + pFtpServerID->cchServerSize);
            DWORD dwSizeOfUserName = *(DWORD *) pvSizeOfUserName;
            LPCSTR pszSourcePassword = (LPCSTR) (pvSizeOfUserName + dwSizeOfUserName + 2*sizeof(DWORD));

            SHAnsiToTChar(pszSourcePassword, pszPassword, cchSize);
            hr = S_OK;
        }
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return hr;
}

INTERNET_PORT FtpServerID_GetPortNum(LPCITEMIDLIST pidl)
{
    INTERNET_PORT portReturn = INTERNET_DEFAULT_FTP_PORT;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    ASSERT(FtpID_IsServerItemID(pidl));
    if (pFtpServerID)
    {
        portReturn = (INTERNET_PORT)pFtpServerID->dwPortNumber;
        FtpServerID_FreeThunk(pFtpServerID);
    }

    return portReturn;
}


HRESULT FtpServerID_SetHiddenPassword(LPITEMIDLIST pidl, LPCTSTR pszPassword)
{
    HRESULT hr = E_INVALIDARG;
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    ASSERT(FtpID_IsServerItemID(pidl));
    if (pFtpServerID)
    {
        pFtpServerID->sessionKey = GetSessionKey();
        pFtpServerID->dwIDType |= IDVALID_HIDE_PASSWORD;
        if (EVAL(GetCookieList()))
            pFtpServerID->dwPasswordCookie = GetCookieList()->GetCookie(pszPassword);
        hr = S_OK;
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return hr;
}


HRESULT FtpServerID_GetStrRet(LPCITEMIDLIST pidl, LPSTRRET lpName)
{
    LPFTPSERVERIDLIST pFtpServerID = FtpServerID_GetDataThunk(pidl);

    ASSERT(FtpID_IsServerItemID(pidl));
    if (pFtpServerID)
    {
        lpName->uType = STRRET_OFFSET;
        lpName->uOffset = (DWORD) (sizeof(FTPSERVERIDLIST) - sizeof(pFtpServerID->szServer) + (LPBYTE)pFtpServerID - (LPBYTE)pidl);
    }
    else
    {
        lpName->uType = STRRET_CSTR;
        lpName->cStr[0] = '\0';
    }

    FtpServerID_FreeThunk(pFtpServerID);
    return S_OK;
}





/****************************************************\
    FTP File/Dir ItemIDs
\****************************************************/

typedef struct tagFTPIDLIST
{
    DWORD dwIDType;         // Server ItemID or Dir ItemID?  Which Bits are valid?
    DWORD dwAttributes;     // What are the file/dir attributes
    ULARGE_INTEGER uliFileSize;
    FILETIME ftModified;    // Stored in Local Time Zone. (FTP Time)
    DWORD dwUNIXPermission; // UNIX CHMOD Permissions (0x00000777, 4=Read, 2=Write, 1=Exec, <Owner><Group><All>)
    DWORD dwCompatFlags;    // Special case handling
    WIRECHAR szWireName[MAX_PATH];          // Needs to go last.
    WCHAR wzDisplayName[MAX_PATH];  // Converted to unicode to be displayed in the UI.
} FTPIDLIST;

typedef UNALIGNED FTPIDLIST * LPFTPIDLIST;

HRESULT FtpItemID_Alloc(LPFTPIDLIST pfi, LPITEMIDLIST * ppidl);


typedef struct _FTPIDLIST_WITHHEADER
{
    USHORT  cb;             // size
    FTPIDLIST fidListData;
    USHORT  cbTerminator;   // size of next ID (Empty)
} FTPIDLIST_WITHHEADER;



LPFTPIDLIST FtpItemID_GetDataInternal(LPCITEMIDLIST pidl)
{
    BYTE * pbData = (BYTE *) pidl;

    pbData += SIZE_ITEMID_SIZEFIELD;      // Skip over the size.
    LPFTPIDLIST pFtpItemId = (LPFTPIDLIST) pbData;

    if (!EVAL(IS_VALID_DIRORFILE_ITEMID(pFtpItemId->dwIDType))) // If any other bits are sit, it's invalid.
        pFtpItemId = NULL;

    return pFtpItemId;
}


/*****************************************************************************\
    DESCRIPTION:
        On ia64, we need to worry about alignment issues.  The easiest way is
    to allocate the struct we have in our PIDL so it's quad word aligned.
    We can then use existing code to read out of it.  The problem is that
    we need to be compatible with old pidls from pre-whistler that are only
    DWORD aligned (for alpha machines).
\*****************************************************************************/
LPFTPIDLIST FtpItemID_GetDataThunk(LPCITEMIDLIST pidl)
{
#ifndef ALIGNMENT_MACHINE
    LPFTPIDLIST pFtpItemId = FtpItemID_GetDataInternal(pidl);
#else
    LPFTPIDLIST pFtpItemId = NULL;
    LPFTPIDLIST pLocation = FtpItemID_GetDataInternal(pidl);

    if (pLocation)
    {
        DWORD cbSize = ILGetSizeOfFirst(pidl);
        pFtpItemId = (LPFTPIDLIST) LocalAlloc(LPTR, cbSize);
        if (pFtpItemId)
        {
            CopyMemory(pFtpItemId, pLocation, cbSize - SIZE_ITEMID_SIZEFIELD);
        }
    }
#endif // ALIGNMENT_MACHINE

    return pFtpItemId;
}


void FtpItemID_FreeThunk(LPFTPIDLIST pFtpItemId)
{
#ifndef ALIGNMENT_MACHINE
    // We don't need to do anything.
#else
    if (pFtpItemId)
    {
        LocalFree(pFtpItemId);
    }
#endif // ALIGNMENT_MACHINE
}


LPCUWSTR FtpItemID_GetDisplayNameReference(LPCITEMIDLIST pidl)
{
    BYTE * pbData = (BYTE *) pidl;
    LPCUWSTR pwzDisplayName = NULL;
    DWORD cbWireName;

    // Is the version OK?
//    if (PIDL_VERSION_NUMBER > FtpPidl_GetVersion(pidl))
//        return NULL;

    pbData += SIZE_ITEMID_SIZEFIELD;      // Skip over the size.
    LPFTPIDLIST pFtpItemId = (LPFTPIDLIST) pbData;

    cbWireName = LENGTH_AFTER_ALIGN((lstrlenA(pFtpItemId->szWireName) + 1), sizeof(DWORD));
    pwzDisplayName = (LPCUWSTR) ((BYTE *)(&pFtpItemId->szWireName[0]) + cbWireName);

    if (!EVAL(IS_VALID_DIRORFILE_ITEMID(pFtpItemId->dwIDType))) // If any other bits are sit, it's invalid.
        pwzDisplayName = NULL;

    return pwzDisplayName;
}

DWORD FtpItemID_GetTypeID(LPCITEMIDLIST pidl)
{
    LPFTPIDLIST pFtpItemId = FtpItemID_GetDataThunk(pidl);
    DWORD dwType = (pFtpItemId ? pFtpItemId->dwIDType : 0);

    FtpItemID_FreeThunk(pFtpItemId);
    return dwType;
}


void FtpItemID_SetTypeID(LPITEMIDLIST pidl, DWORD dwNewTypeID)
{
    LPFTPIDLIST pFtpItemId = FtpItemID_GetDataInternal(pidl);
    if (EVAL(pFtpItemId))
        pFtpItemId->dwIDType = dwNewTypeID;
}


/****************************************************\
    FUNCTION: FtpItemID_Alloc

    DESCRIPTION:
        We are passed a pointer to a FTPIDLIST data
    structure and our goal is to create a ItemID from
    it.  This mainly includes making it only big enough
    for the current string(s).
\****************************************************/
HRESULT FtpItemID_Alloc(LPFTPIDLIST pfi, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    WORD cbTotal;
    WORD cbDataFirst;
    WORD cbData;
    BYTE * pbMemory;
    DWORD cchSizeOfName = lstrlenA(pfi->szWireName);
    DWORD cchSizeOfDispName = ualstrlenW(pfi->wzDisplayName);

    ASSERT(pfi && ppidl);

    // Find lenght of FTPIDLIST struct if the szName member only needed enought room
    // for the string, not the full MAX_PATH.
    // Size EQUALS: (Everything in the struct) - (the 2 full statusly sized strings) + (the 2 packed strings + alignment)
    cbDataFirst = (WORD)((sizeof(*pfi) - sizeof(pfi->szWireName) - sizeof(pfi->wzDisplayName)) + LENGTH_AFTER_ALIGN(cchSizeOfName + 1, sizeof(DWORD)) - sizeof(DWORD));
    cbData = cbDataFirst + (WORD) LENGTH_AFTER_ALIGN((cchSizeOfDispName + 1) * sizeof(WCHAR), sizeof(DWORD));

    ASSERT((cbData % sizeof(DWORD)) == 0);  // Verify it's DWORD aligned.
    cbTotal = (SIZE_ITEMID_SIZEFIELD + cbData + SIZE_ITEMID_TERMINATOR);

    pbMemory = (BYTE *) CoTaskMemAlloc(cbTotal);
    if (pbMemory)
    {
        USHORT * pIDSize = (USHORT *)pbMemory;
        BYTE * pbData = (pbMemory + SIZE_ITEMID_SIZEFIELD);        // the Data starts at the second DWORD.
        USHORT * pIDTerminator = (USHORT *)(pbMemory + SIZE_ITEMID_SIZEFIELD + cbData);

        pIDSize[0] = (cbTotal - SIZE_ITEMID_TERMINATOR);      // Set the size of the ItemID (including the next ItemID as terminator)
        ASSERT(cbData <= sizeof(*pfi)); // Don't let me copy too much.
        CopyMemory(pbData, pfi, cbDataFirst);
        CopyMemory((pbData + cbDataFirst), &(pfi->wzDisplayName), ((cchSizeOfDispName + 1) * sizeof(WCHAR)));
        pIDTerminator[0] = 0;  // Terminate the next ID.

//        TraceMsg(TF_FTPURL_UTILS, "FtpItemID_Alloc(\"%ls\") dwIDType=%#08lx, dwAttributes=%#08lx", pfi->wzDisplayName, pfi->dwIDType, pfi->dwAttributes);
    }

    *ppidl = (LPITEMIDLIST) pbMemory;
    hr = pbMemory ? S_OK : E_OUTOFMEMORY;

    ASSERT(IsValidPIDL(*ppidl));
    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpItemID_CreateReal

    DESCRIPTION:
        Cook up a pidl based on a WIN32_FIND_DATA.

    The cFileName field is itself MAX_PATH characters long,
    so its length cannot possibly exceed MAX_PATH...
\*****************************************************************************/
HRESULT FtpItemID_CreateReal(const LPFTP_FIND_DATA pwfd, LPCWSTR pwzDisplayName, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    FTPIDLIST fi = {0};

    // Fill in fi.
    fi.dwIDType = (IDTYPE_ISVALID | IDVALID_FILESIZE | IDVALID_MOD_DATE);
    fi.uliFileSize.LowPart = pwfd->nFileSizeLow;
    fi.uliFileSize.HighPart = pwfd->nFileSizeHigh;
    fi.ftModified = pwfd->ftLastWriteTime;
    fi.dwAttributes = pwfd->dwFileAttributes;
    fi.dwUNIXPermission = pwfd->dwReserved0;    // Set by WININET
    StrCpyNA(fi.szWireName, pwfd->cFileName, ARRAYSIZE(fi.szWireName));
    StrCpyN(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));

    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        fi.dwIDType |= IDTYPE_DIR;
    else
        fi.dwIDType |= IDTYPE_FILE;

    hr = FtpItemID_Alloc(&fi, ppidl);
    ASSERT(IsValidPIDL(*ppidl));

    return hr;
}


/****************************************************\
    FUNCTION: FtpItemID_CreateFake

    DESCRIPTION:
        Create a ItemID but we are only setting the
    name.  We don't know the true file attributes,
    file size, or modification date yet because
    we haven't touched the server yet.  If we did,
    we would use the returned WIN32_FIND_DATA struct
    to create the ItemID by using FtpItemID_CreateReal().
\****************************************************/
HRESULT FtpItemID_CreateFake(LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, BOOL fTypeKnown, BOOL fIsFile, BOOL fIsFragment, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    DWORD dwType = IDTYPE_ISVALID;
    FTPIDLIST fi = {0};

    // Is it unknown?
    if (!fTypeKnown)
    {
        // HACK: We will assume everything w/o a file extension is a Dir
        //    and everything w/an extension is a file.
        fTypeKnown = TRUE;
        fIsFile = (!pwzDisplayName || (0 == *PathFindExtension(pwzDisplayName))) ? FALSE : TRUE;
    }
    if (fTypeKnown)
    {
        if (fIsFile)
            dwType |= IDTYPE_FILE;
        else if (fIsFragment)
            dwType |= IDTYPE_FRAGMENT;
        else
            dwType |= IDTYPE_DIR;
    }
    else
    {
        // You need to know if it's a fragment because there is no
        // heuristic to find out.
        ASSERT(!fIsFragment);

        dwType |= IDTYPE_FILEORDIR;
    }

    fi.dwIDType = dwType;
    fi.dwAttributes = (fIsFile ? FILE_ATTRIBUTE_NORMAL : FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_DIRECTORY);
    fi.uliFileSize.QuadPart = 0;
    StrCpyNW(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));
    StrCpyNA(fi.szWireName, pwWireName, ARRAYSIZE(fi.szWireName));

    hr = FtpItemID_Alloc(&fi, ppidl);
    ASSERT(IsValidPIDL(*ppidl));
    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpItemID_SetName

    DESCRIPTION:
        The user chose a new name for the ftp file or dir (in unicode).  We
    now need to create the name in wire bytes and we will use the original
    wire byte name to decide how to do that (from pidl).
\*****************************************************************************/
HRESULT FtpItemID_CreateWithNewName(LPCITEMIDLIST pidl, LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr = E_FAIL;
    FTPIDLIST fi;
    const FTPIDLIST UNALIGNED * pfi = FtpItemID_GetDataThunk(pidl);

    if (pfi)
    {
        CWireEncoding cWireEncoding;

        CopyMemory(&fi, pfi, sizeof(FTPIDLIST) - sizeof(fi.szWireName) - sizeof(fi.wzDisplayName));
        StrCpyNW(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));
        StrCpyNA(fi.szWireName, pwWireName, ARRAYSIZE(fi.szWireName));

        hr = FtpItemID_Alloc(&fi, ppidlOut);
        ASSERT(IsValidPIDL(*ppidlOut));
        FtpItemID_FreeThunk((FTPIDLIST UNALIGNED *) pfi);
    }

    return hr;
}


HRESULT Private_GetFileInfo(SHFILEINFO *psfi, DWORD rgf, LPCTSTR pszName, DWORD dwFileAttributes)
{
    HRESULT hr = E_FAIL;

    if (SHGetFileInfo(pszName, dwFileAttributes, psfi, sizeof(*psfi), rgf | SHGFI_USEFILEATTRIBUTES))
        hr = S_OK;

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpPidl_GetFileInfo

    DESCRIPTION:
        _UNDOCUMENTED_:  We strip the Hidden and System bits so
    that SHGetFileInfo won't think that we're passing something
    that might be a junction.

    We also force the SHGFI_USEFILEATTRIBUTES bit to remind the shell
    that this isn't a file.
\*****************************************************************************/
HRESULT FtpPidl_GetFileInfo(LPCITEMIDLIST pidl, SHFILEINFO *psfi, DWORD rgf)
{
    HRESULT hr = E_FAIL;
    TCHAR szDisplayName[MAX_PATH];

    psfi->iIcon = 0;
    psfi->hIcon = NULL;
    psfi->dwAttributes = 0;
    psfi->szDisplayName[0] = 0;
    psfi->szTypeName[0] = 0;

    ASSERT(IsValidPIDL(pidl));
    if (FtpID_IsServerItemID(pidl))
    {
        FtpServerID_GetServer(pidl, szDisplayName, ARRAYSIZE(szDisplayName));
        hr = Private_GetFileInfo(psfi, rgf, szDisplayName, FILE_ATTRIBUTE_DIRECTORY);
        if (psfi->hIcon)
            DestroyIcon(psfi->hIcon);

        psfi->hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_FTPFOLDER));
        ASSERT(psfi->hIcon);

        // Now replace the type (szTypeName) with "FTP Server" because
        // it could go in the Properties dialog
        EVAL(LoadString(HINST_THISDLL, IDS_ITEMTYPE_SERVER, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName)));
    }
    else
    {
        LPFTPIDLIST pfi = FtpItemID_GetDataThunk(pidl);

        if (pfi)
        {
            FtpItemID_GetDisplayName(pidl, szDisplayName, ARRAYSIZE(szDisplayName));
            hr = Private_GetFileInfo(psfi, rgf, szDisplayName, (pfi->dwAttributes & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)));

            FtpItemID_FreeThunk(pfi);
        }
    }

    return hr;
}

HRESULT FtpPidl_GetFileType(LPCITEMIDLIST pidl, LPTSTR pszType, DWORD cchSize)
{
    SHFILEINFO sfi;
    HRESULT hr;

    ASSERT(IsValidPIDL(pidl));
    hr = FtpPidl_GetFileInfo(pidl, &sfi, SHGFI_TYPENAME);
    if (SUCCEEDED(hr))
    {
        StrCpyN(pszType, sfi.szTypeName, cchSize);
        if (sfi.hIcon)
            DestroyIcon(sfi.hIcon);
    }

    return hr;
}


HRESULT FtpPidl_GetFileTypeStrRet(LPCITEMIDLIST pidl, LPSTRRET pstr)
{
    WCHAR szType[MAX_URL_STRING];
    HRESULT hr;

    ASSERT(IsValidPIDL(pidl));
    hr = FtpPidl_GetFileType(pidl, szType, ARRAYSIZE(szType));
    if (EVAL(SUCCEEDED(hr)))
        StringToStrRetW(szType, pstr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _FtpItemID_CompareOneID

    DESCRIPTION:
        ici - attribute (column) to compare

    Note! that UNIX filenames are case-*sensitive*.

    We make two passes on the name.  If the names are different in other
    than case, we return the result of that comparison.  Otherwise,
    we return the result of a case-sensitive comparison.

    This algorithm ensures that the items sort themselves in a
    case-insensitive way, with ties broken by a case-sensitive
    comparison.  This makes ftp folders act "mostly" like normal
    folders.

    _UNDOCUMENTED_: The documentation says that the ici parameter
    is undefined and must be zero.  In reality, it is the column
    number (defined by IShellView) for which the comparison is to
    be made.
\*****************************************************************************/
HRESULT _FtpItemID_CompareOneID(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    int iRc = 0;    // 0 means we don't know.
    HRESULT hr = S_OK;

    ASSERT(IsValidPIDL(pidl1));
    ASSERT(IsValidPIDL(pidl2));

    // Are they both the same type? (Both Dirs or both files?)
    if (!(dwCompFlags & FCMP_GROUPDIRS) || (!FtpPidl_IsDirectory(pidl1, FALSE) == !FtpPidl_IsDirectory(pidl2, FALSE)))
    {
        switch (ici & SHCIDS_COLUMNMASK)
        {
        case COL_NAME:
        {
            // Yes they are the same, so we will key off the name...
            WIRECHAR szName1[MAX_PATH];
            WIRECHAR szName2[MAX_PATH];

            szName1[0] = TEXT('\0');
            szName2[0] = TEXT('\0');

            FtpPidl_GetWireName(pidl1, szName1, ARRAYSIZE(szName1));
            FtpPidl_GetWireName(pidl2, szName2, ARRAYSIZE(szName2));

            iRc = StrCmpIA(szName1, szName2);
            if (0 == iRc)
            {
                if (!(dwCompFlags & FCMP_CASEINSENSE))
                    iRc = StrCmpA(szName1, szName2);

/*
                // They are the same name, so now lets check on the username
                // if they are Server IDs.
                if ((0 == iRc) && (FtpID_IsServerItemID(pidl1)))
                {
                    FtpPidl_GetUserName(pidl1, szName1, ARRAYSIZE(szName1));
                    FtpPidl_GetUserName(pidl2, szName2, ARRAYSIZE(szName2));
                    iRc = StrCmp(szName1, szName2);
                }
*/
            }
        }
        break;

        case COL_SIZE:
            if (FtpPidl_GetFileSize(pidl1) < FtpPidl_GetFileSize(pidl2))
                iRc = -1;
            else if (FtpPidl_GetFileSize(pidl1) > FtpPidl_GetFileSize(pidl2))
                iRc = +1;
            else
                iRc = 0;        // I don't know
            break;

        case COL_TYPE:
            if (!FtpID_IsServerItemID(pidl1) && !FtpID_IsServerItemID(pidl2))
            {
                TCHAR szType1[MAX_PATH];

                hr = FtpPidl_GetFileType(pidl1, szType1, ARRAYSIZE(szType1));
                if (EVAL(SUCCEEDED(hr)))
                {
                    TCHAR szType2[MAX_PATH];
                    hr = FtpPidl_GetFileType(pidl2, szType2, ARRAYSIZE(szType2));
                    if (EVAL(SUCCEEDED(hr)))
                        iRc = StrCmpI(szType1, szType2);
                }
            }
            break;

        case COL_MODIFIED:
        {
            FILETIME ft1 = FtpPidl_GetFileTime(pidl1);
            FILETIME ft2 = FtpPidl_GetFileTime(pidl2);
            iRc = CompareFileTime(&ft1, &ft2);
        }
            break;

        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    else
    {
        // No they are different.  We want the Folder to always come first.
        // This doesn't seam right, but it forces folders to bubble to the top
        // in the most frequent case and it matches DefView's Behavior.
        if (FtpPidl_IsDirectory(pidl1, FALSE))
            iRc = -1;
        else
            iRc = 1;
    }

    if (S_OK == hr)
        hr = HRESULT_FROM_SUCCESS_VALUE(iRc);   // encode the sort value in the return code.

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpItemID_CompareIDs
    
    DESCRIPTION:
        ici - attribute (column) to compare

    Note! that we rely on the fact that IShellFolders are
    uniform; we do not need to bind to the shell folder in
    order to compare its sub-itemids.

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  In fact, they can.

    The reason why the shell asks you to handle complex pidls
    is that you can often short-circuit the comparison by walking
    the ID list directly.  (Formally speaking, you need to bind
    to each ID and then call yourself recursively.  But if your
    pidls are uniform, you can just use a loop like the one below.)
\*****************************************************************************/
HRESULT FtpItemID_CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    HRESULT hr;

    if (!pidl1 || ILIsEmpty(pidl1))
    {
        if (!pidl2 || ILIsEmpty(pidl2))
            hr = HRESULT_FROM_SUCCESS_VALUE(0);        // Both ID lists are empty
        else
            hr = HRESULT_FROM_SUCCESS_VALUE(-1);        // pidl1 is empty, pidl2 is nonempty
    }
    else
    {
        if (!pidl2 || ILIsEmpty(pidl2))
            hr = HRESULT_FROM_SUCCESS_VALUE(1);     // pidl1 is nonempty, pidl2 is empty
        else
        {
            ASSERT(IsValidPIDL(pidl1));
            ASSERT(IsValidPIDL(pidl2));
            hr = _FtpItemID_CompareOneID(ici, pidl1, pidl2, dwCompFlags);    // both are nonempty
        }
    }

    // If this level of ItemsIDs are equal, then we will compare the next
    // level of ItemIDs
    if ((hr == HRESULT_FROM_SUCCESS_VALUE(0)) && pidl1 && !ILIsEmpty(pidl1))
        hr = FtpItemID_CompareIDs(ici, _ILNext(pidl1), _ILNext(pidl2), dwCompFlags);

    return hr;
}


int FtpItemID_CompareIDsInt(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    HRESULT hr = FtpItemID_CompareIDs(ici, pidl1, pidl2, dwCompFlags);
    int nResult = (DWORD)(short)hr;

    return nResult;
}

DWORD FtpItemID_GetAttributes(LPCITEMIDLIST pidl)
{
    DWORD dwAttributes = 0;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (pFtpIDList)
    {
        dwAttributes = pFtpIDList->dwAttributes;
        FtpItemID_FreeThunk(pFtpIDList);
    }

    return dwAttributes;
}

HRESULT FtpItemID_SetAttributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList)
        return E_INVALIDARG;

    pFtpIDList->dwAttributes = dwAttribs;
    return S_OK;
}


DWORD FtpItemID_GetUNIXPermissions(LPCITEMIDLIST pidl)
{
    DWORD dwPermissions = 0;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (pFtpIDList)
    {
        dwPermissions = pFtpIDList->dwUNIXPermission;
        FtpItemID_FreeThunk(pFtpIDList);
    }

    return dwPermissions;
}


HRESULT FtpItemID_SetUNIXPermissions(LPCITEMIDLIST pidl, DWORD dwUNIXPermission)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList)
        return E_INVALIDARG;

    pFtpIDList->dwUNIXPermission = dwUNIXPermission;
    return S_OK;
}


DWORD FtpItemID_GetCompatFlags(LPCITEMIDLIST pidl)
{
    DWORD dwCompatFlags = 0;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (pFtpIDList)
    {
        dwCompatFlags = pFtpIDList->dwCompatFlags;
        FtpItemID_FreeThunk(pFtpIDList);
    }

    return dwCompatFlags;
}


HRESULT FtpItemID_SetCompatFlags(LPCITEMIDLIST pidl, DWORD dwCompatFlags)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList)
        return E_INVALIDARG;

    pFtpIDList->dwCompatFlags = dwCompatFlags;
    return S_OK;
}


ULONGLONG FtpItemID_GetFileSize(LPCITEMIDLIST pidl)
{
    ULONGLONG uliFileSize = 0;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (pFtpIDList)
    {
        ASSERT(IsFlagSet(pFtpIDList->dwIDType, IDVALID_FILESIZE));
        uliFileSize = pFtpIDList->uliFileSize.QuadPart;
        FtpItemID_FreeThunk(pFtpIDList);
    }

    return uliFileSize;
}

void FtpItemID_SetFileSize(LPCITEMIDLIST pidl, ULARGE_INTEGER uliFileSize)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList)
        return;

    pFtpIDList->uliFileSize = uliFileSize;
    pFtpIDList->dwIDType |= IDVALID_FILESIZE;
}

DWORD FtpItemID_GetFileSizeLo(LPCITEMIDLIST pidl)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (!pFtpIDList)
        return NULL;

    ASSERT(IsFlagSet(pFtpIDList->dwIDType, IDVALID_FILESIZE));
    DWORD dwSize = pFtpIDList->uliFileSize.LowPart;
    FtpItemID_FreeThunk(pFtpIDList);

    return dwSize;
}

DWORD FtpItemID_GetFileSizeHi(LPCITEMIDLIST pidl)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (!pFtpIDList)
        return NULL;

    ASSERT(IsFlagSet(pFtpIDList->dwIDType, IDVALID_FILESIZE));
    DWORD dwSize = pFtpIDList->uliFileSize.HighPart;
    FtpItemID_FreeThunk(pFtpIDList);

    return dwSize;
}


// Return value is in Local Time Zone.
FILETIME FtpItemID_GetFileTime(LPCITEMIDLIST pidl)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);
    FILETIME ftEmpty = {0};

    if (pFtpIDList)
    {
        ASSERT(IsFlagSet(pFtpIDList->dwIDType, IDVALID_MOD_DATE));
        ftEmpty = pFtpIDList->ftModified;

        FtpItemID_FreeThunk(pFtpIDList);
    }

    return ftEmpty;
}


LPCWIRESTR FtpItemID_GetWireNameReference(LPCITEMIDLIST pidl)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList || IS_FRAGMENT(pFtpIDList))
        return NULL;

    return pFtpIDList->szWireName;
}


HRESULT FtpItemID_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (pFtpIDList)
    {
        if (!IS_FRAGMENT(pFtpIDList))
        {
			LPCUWSTR pszUnalignedName = FtpItemID_GetDisplayNameReference(pidl);

			if (pszUnalignedName)
			{
	            // The display name wasn't stored in v3
				ualstrcpynW(pwzName, pszUnalignedName, cchSize);
			}
        }
        else 
        {
            pwzName[0] = TEXT('\0');
            hr = E_FAIL;
        }

        FtpItemID_FreeThunk(pFtpIDList);
    }

    return hr;
}


HRESULT FtpItemID_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (pFtpIDList && !IS_FRAGMENT(pFtpIDList))
        StrCpyNA(pszName, pFtpIDList->szWireName, cchSize);
    else 
    {
        pszName[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}


HRESULT FtpItemID_GetFragment(LPCITEMIDLIST pidl, LPWSTR pwzFragmentStr, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (pFtpIDList && IS_FRAGMENT(pFtpIDList))
	{
		LPCUWSTR pszUnalignedName = FtpItemID_GetDisplayNameReference(pidl);

		if (pszUnalignedName)
		{
	        // The display name wasn't stored in v3
			ualstrcpynW(pwzFragmentStr, pszUnalignedName, cchSize);
			hr = S_OK;
		}
	}
    else 
    {
        pwzFragmentStr[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}


BOOL FtpItemID_IsFragment(LPCITEMIDLIST pidl)
{
    BOOL fIsFrag = FALSE;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (pFtpIDList && IS_FRAGMENT(pFtpIDList))
        fIsFrag = TRUE;

    return fIsFrag;
}


// fileTime In UTC
void FtpItemID_SetFileTime(LPCITEMIDLIST pidl, FILETIME fileTime)
{
    FILETIME fileTimeLocal;
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataInternal(pidl);

    if (!pFtpIDList)
        return;

    FileTimeToLocalFileTime(&fileTime, &fileTimeLocal);
    pFtpIDList->ftModified = fileTimeLocal;
    pFtpIDList->dwIDType |= IDVALID_MOD_DATE;
}

BOOL FtpItemID_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown)
{
    LPFTPIDLIST pFtpIDList = FtpItemID_GetDataThunk(pidl);

    if (!pFtpIDList)
        return NULL;

    BOOL fIsDir = (IsFlagSet(pFtpIDList->dwIDType, IDTYPE_DIR));
    
    if (fAssumeDirForUnknown && (IDTYPE_FILEORDIR == pFtpIDList->dwIDType))
    {
//        TraceMsg(TF_FTPURL_UTILS, "FtpItemID_IsDirectory() IDTYPE_FILEORDIR is set, so we assume %s", (fAssumeDirForUnknown ? TEXT("DIR") : TEXT("FILE")));
        fIsDir = TRUE;
    }
    else
    {
//        TraceMsg(TF_FTPURL_UTILS, "FtpItemID_IsDirectory() It is known to be a %s", (fIsDir ? TEXT("DIR") : TEXT("FILE")));
    }

    FtpItemID_FreeThunk(pFtpIDList);
    return fIsDir;
}




/****************************************************\
    Functions to work on an entire FTP PIDLs
\****************************************************/
#define SZ_ASCII_DOWNLOAD_TYPE       TEXT("a")
#define SZ_BINARY_DOWNLOAD_TYPE      TEXT("b")

HRESULT FtpPidl_GetDownloadTypeStr(LPCITEMIDLIST pidl, LPTSTR szDownloadType, DWORD cchTypeStrSize)
{
    HRESULT hr = S_FALSE;   // We may not have a type.
    DWORD dwTypeID = FtpServerID_GetTypeID(pidl);

    szDownloadType[0] = TEXT('\0');
    if (IDVALID_DLTYPE & dwTypeID)
    {
        hr = S_OK;
        StrCpyN(szDownloadType, SZ_FTP_URL_TYPE, cchTypeStrSize);

        if (IDVALID_DL_ASCII & dwTypeID)
            StrCatBuff(szDownloadType, SZ_ASCII_DOWNLOAD_TYPE, cchTypeStrSize);
        else
            StrCatBuff(szDownloadType, SZ_BINARY_DOWNLOAD_TYPE, cchTypeStrSize);
    }

    return hr;
}

DWORD FtpPidl_GetDownloadType(LPCITEMIDLIST pidl)
{
    DWORD dwAttribs = FTP_TRANSFER_TYPE_UNKNOWN;
    DWORD dwTypeID = FtpServerID_GetTypeID(pidl);

    ASSERT(FtpID_IsServerItemID(pidl));
    if (IDVALID_DLTYPE & dwTypeID)
    {
        if (IDVALID_DL_ASCII & dwTypeID)
            dwAttribs = FTP_TRANSFER_TYPE_ASCII;
        else
            dwAttribs = FTP_TRANSFER_TYPE_BINARY;
    }

    return dwAttribs;
}


INTERNET_PORT FtpPidl_GetPortNum(LPCITEMIDLIST pidl)
{
    ASSERT(FtpID_IsServerItemID(pidl));

    return FtpServerID_GetPortNum(pidl);
}


BOOL FtpPidl_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown)
{
    BOOL fIsDir = FALSE;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
        fIsDir = FtpItemID_IsDirectory(pidlLast, fAssumeDirForUnknown);

    return fIsDir;
}


BOOL FtpPidl_IsAnonymous(LPCITEMIDLIST pidl)
{
    BOOL fIsAnonymous = TRUE;

    if (IDVALID_USERNAME & FtpServerID_GetTypeID(pidl))
        fIsAnonymous = FALSE;

    return fIsAnonymous;
}


HRESULT FtpPidl_GetServer(LPCITEMIDLIST pidl, LPTSTR pszServer, DWORD cchSize)
{
    if (!FtpID_IsServerItemID(pidl)) // Will fail if we are handed a non-server ID.
        return E_FAIL;

    return FtpServerID_GetServer(pidl, pszServer, cchSize);
}


BOOL FtpPidl_IsDNSServerName(LPCITEMIDLIST pidl)
{
    BOOL fIsDNSServer = FALSE;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

    if (EVAL(SUCCEEDED(FtpPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer)))))
        fIsDNSServer = !IsIPAddressStr(szServer);

    return fIsDNSServer;
}


HRESULT FtpPidl_GetUserName(LPCITEMIDLIST pidl, LPTSTR pszUserName, DWORD cchSize)
{
    ASSERT(FtpID_IsServerItemID(pidl));
    return FtpServerID_GetUserName(pidl, pszUserName, cchSize);
}

HRESULT FtpPidl_GetPassword(LPCITEMIDLIST pidl, LPTSTR pszPassword, DWORD cchSize, BOOL fIncludingHiddenPassword)
{
    ASSERT(FtpID_IsServerItemID(pidl));
    return FtpServerID_GetPassword(pidl, pszPassword, cchSize, fIncludingHiddenPassword);
}


ULONGLONG FtpPidl_GetFileSize(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);
    ULONGLONG ullFileSize;
    ullFileSize = 0;

    if (!FtpID_IsServerItemID(pidlLast))
        ullFileSize = FtpItemID_GetFileSize(pidlLast);

    return ullFileSize;
}


HRESULT FtpPidl_SetFileSize(LPCITEMIDLIST pidl, DWORD dwSizeHigh, DWORD dwSizeLow)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
    {
        ULARGE_INTEGER uliFileSize;

        uliFileSize.HighPart = dwSizeHigh;
        uliFileSize.LowPart = dwSizeLow;
        FtpItemID_SetFileSize(pidlLast, uliFileSize);
        hr = S_OK;
    }

    return hr;
}

// Return value in UTC time.
FILETIME FtpPidl_GetFileTime(LPCITEMIDLIST pidl)
{
    FILETIME fileTimeFTP = FtpPidl_GetFTPFileTime(pidl);   // This is what servers will be.
    FILETIME fileTime;

    EVAL(LocalFileTimeToFileTime(&fileTimeFTP, &fileTime));

    return fileTime;
}


// Return value is in Local Time Zone.
FILETIME FtpPidl_GetFTPFileTime(LPCITEMIDLIST pidl)
{
    FILETIME fileTime = {0};   // This is what servers will be.

    if (!FtpID_IsServerItemID(pidl))
        fileTime = FtpItemID_GetFileTime(pidl);

    return fileTime;
}


HRESULT FtpPidl_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        if (FtpID_IsServerItemID(pidl))
            hr = FtpServerID_GetServer(pidl, pwzName, cchSize);
        else
            hr = FtpItemID_GetDisplayName(pidl, pwzName, cchSize);
    }

    return hr;
}


HRESULT FtpPidl_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pwName, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        if (FtpID_IsServerItemID(pidl))
        {
            WCHAR wzServerName[INTERNET_MAX_HOST_NAME_LENGTH];

            // It's a good thing Server Names need to be in US ANSI
            hr = FtpServerID_GetServer(pidl, wzServerName, ARRAYSIZE(wzServerName));
            SHUnicodeToAnsi(wzServerName, pwName, cchSize);
        }
        else
            hr = FtpItemID_GetWireName(pidl, pwName, cchSize);
    }

    return hr;
}


HRESULT FtpPidl_GetFragment(LPCITEMIDLIST pidl, LPTSTR pszFragment, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
        hr = FtpItemID_GetFragment(pidlLast, pszFragment, cchSize);
    else
    {
        pszFragment[0] = 0;
    }

    return hr;
}


DWORD FtpPidl_GetAttributes(LPCITEMIDLIST pidl)
{
    DWORD dwAttribs = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_TEMPORARY;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
        dwAttribs = FtpItemID_GetAttributes(pidlLast);
    else
        dwAttribs = FILE_ATTRIBUTE_DIRECTORY;

    return dwAttribs;
}


HRESULT FtpPidl_SetAttributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
        hr = FtpItemID_SetAttributes(pidlLast, dwAttribs);

    return hr;
}


// ftTimeDate In UTC
HRESULT FtpPidl_SetFileTime(LPCITEMIDLIST pidl, FILETIME ftTimeDate)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!FtpID_IsServerItemID(pidlLast))
    {
        FtpItemID_SetFileTime(pidlLast, ftTimeDate);
        hr = S_OK;
    }

    return hr;
}


/****************************************************\
    FUNCTION: FtpPidl_GetFileWireName

    DESCRIPTION:
        Get the file name.
\****************************************************/
LPCWIRESTR FtpPidl_GetFileWireName(LPCITEMIDLIST pidl)
{
    if (EVAL(!FtpID_IsServerItemID(pidl)) &&
        !FtpItemID_IsFragment(pidl))
    {
        return FtpItemID_GetWireNameReference(pidl);
    }

    return NULL;
}


/****************************************************\
    FUNCTION: FtpPidl_GetLastItemDisplayName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
HRESULT FtpPidl_GetLastItemDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (EVAL(!FtpID_IsServerItemID(pidlLast)) &&
        FtpItemID_GetDisplayNameReference(pidlLast))
    {
        hr = FtpItemID_GetDisplayName(pidlLast, pwzName, cchSize);
    }

    return hr;
}


/****************************************************\
    FUNCTION: FtpPidl_GetLastItemWireName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
LPCWIRESTR FtpPidl_GetLastItemWireName(LPCITEMIDLIST pidl)
{
    LPCWIRESTR pszName = NULL;

    if (pidl)
    {
        LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

        if (FtpItemID_IsFragment(pidlLast) && (pidlLast != pidl))
        {
            // Oops, we went to far.  Step back one.
            LPCITEMIDLIST pidlFrag = pidlLast;

            pidlLast = pidl;    // Start back at the beginning.
            while (!FtpItemID_IsEqual(_ILNext(pidlLast), pidlFrag))
            {
                if (ILIsEmpty(pidlLast))
                    return NULL;    // Break infinite loop.

                pidlLast = _ILNext(pidlLast);
            }
        }

        pszName = FtpPidl_GetFileWireName(pidlLast);
    }

    return pszName;
}


/****************************************************\
    FUNCTION: FtpPidl_GetLastFileDisplayName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
HRESULT FtpPidl_GetLastFileDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (FtpItemID_IsFragment(pidlLast) && (pidlLast != pidl))
    {
        // Oops, we went to far.  Step back one.
        LPCITEMIDLIST pidlFrag = pidlLast;

        pidlLast = pidl;    // Start back at the beginning.
        while (!FtpItemID_IsEqual(_ILNext(pidlLast), pidlFrag))
        {
            if (ILIsEmpty(pidlLast))
                return NULL;    // Break infinite loop.

            pidlLast = _ILNext(pidlLast);
        }
    }

    if (EVAL(!FtpID_IsServerItemID(pidlLast)))
    {
		LPCUWSTR pszUnalignedName = FtpItemID_GetDisplayNameReference(pidlLast);

		if (pszUnalignedName)
		{
			ualstrcpynW(pwzName, pszUnalignedName, cchSize);
			hr = S_OK;
		}
    }

    return hr;
}


/****************************************************\
    FUNCTION: FtpPidl_InsertVirtualRoot

    DESCRIPTION:
        This function will insert the virtual root path
    (pidlVirtualRoot) into pidlFtpPath.

    PARAMETERS:
        pidlVirtualRoot: Does not have a ServerID
        pidlFtpPath: Can have a ServerID
        *ppidl: Will be pidlVirtualRoot with item ItemIDs from
            pidlFtpPath behind it. (No ServerID)
\****************************************************/
HRESULT FtpPidl_InsertVirtualRoot(LPCITEMIDLIST pidlVirtualRoot, LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (FtpID_IsServerItemID(pidlFtpPath))
        pidlFtpPath = _ILNext(pidlFtpPath);

    *ppidl = ILCombine(pidlVirtualRoot, pidlFtpPath);
    if (*ppidl)
        hr = S_OK;

    return hr;
}


DWORD FtpPidl_GetVersion(LPCITEMIDLIST pidl)
{
    DWORD dwVersion = 0;

    if (EVAL(FtpID_IsServerItemID(pidl)))
    {
        LPFTPSERVERIDLIST pFtpServerItemID = FtpServerID_GetDataSafeThunk(pidl);

        if (pFtpServerItemID)
        {
            dwVersion = pFtpServerItemID->dwVersion;
            FtpServerID_FreeThunk(pFtpServerItemID);
        }
    }

    return dwVersion;
}


BOOL FtpPidl_IsValid(LPCITEMIDLIST pidl)
{
    if (!EVAL(IsValidPIDL(pidl)))
        return FALSE;

    return TRUE;
}


BOOL FtpPidl_IsValidFull(LPCITEMIDLIST pidl)
{
    if (!EVAL(FtpID_IsServerItemID(pidl)))
        return FALSE;

    if (!EVAL(FtpPidl_IsValid(pidl)))
        return FALSE;

    // We consider anything older than PIDL_VERSION_NUMBER_UPGRADE
    // to be invalid.
    return ((PIDL_VERSION_NUMBER_UPGRADE - 1) < FtpPidl_GetVersion(pidl));
}


BOOL FtpPidl_IsValidRelative(LPCITEMIDLIST pidl)
{
    if (!EVAL(!FtpID_IsServerItemID(pidl)))
        return FALSE;       // This is a server item id which is not relative.

    return FtpPidl_IsValid(pidl);
}


LPITEMIDLIST ILCloneFirstItemID(LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlCopy = ILClone(pidl);

    if (pidlCopy && pidlCopy->mkid.cb)
    {
        LPITEMIDLIST pSecondID = (LPITEMIDLIST)_ILNext(pidlCopy);

        ASSERT(pSecondID);
        // Remove the last one
        pSecondID->mkid.cb = 0; // null-terminator
    }

    return pidlCopy;
}

BOOL FtpPidl_HasPath(LPCITEMIDLIST pidl)
{
    BOOL fResult = TRUE;
    
    if (!FtpPidl_IsValid(pidl) || !EVAL(FtpID_IsServerItemID(pidl)))
        return FALSE;

    if (!ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
        fResult = FALSE;

    return fResult;
}


HRESULT FtpPidl_SetFileItemType(LPITEMIDLIST pidl, BOOL fIsDir)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);
    HRESULT hr = E_INVALIDARG;
        
    if (EVAL(FtpPidl_IsValid(pidl)) && EVAL(!FtpID_IsServerItemID(pidlLast)))
    {
        DWORD dwIDType = FtpItemID_GetTypeID(pidlLast);

        ClearFlag(dwIDType, (IDTYPE_FILEORDIR | IDTYPE_DIR | IDTYPE_FILE));
        SetFlag(dwIDType, (fIsDir ? IDTYPE_DIR : IDTYPE_FILE));
        FtpItemID_SetTypeID((LPITEMIDLIST) pidlLast, dwIDType);

        hr = S_OK;
    }

    return hr;
}


BOOL IsFtpPidlQuestionable(LPCITEMIDLIST pidl)
{
    BOOL fIsQuestionable = FALSE;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    // Is it a Server Pidl? (All Server pidls aren't questionable)
    if (FtpPidl_IsValid(pidl) && !FtpID_IsServerItemID(pidlLast))
    {
        // No, so it might be questionable.

        // Does it have "File or Dir" bit set?
        if (IsFlagSet(FtpItemID_GetTypeID(pidlLast), IDTYPE_FILEORDIR))
            fIsQuestionable = TRUE;
    }
    
    return fIsQuestionable;
}


LPITEMIDLIST FtpCloneServerID(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlResult = NULL;

    if (EVAL(FtpID_IsServerItemID(pidl)))
    {
        pidlResult = ILClone(pidl);

        while (!ILIsEmpty(_ILNext(pidlResult)))
            ILRemoveLastID(pidlResult);
    }

    return pidlResult;
}


/*****************************************************************************\
    FUNCTION: FtpPidl_ReplacePath

    DESCRIPTION:
        This function will fill in *ppidlOut with a pidl that contains the
    FtpServerID from pidlServer and the FtpItemIDs from pidlFtpPath.
\*****************************************************************************/
HRESULT FtpPidl_ReplacePath(LPCITEMIDLIST pidlServer, LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr = E_INVALIDARG;

    *ppidlOut = NULL;
    if (EVAL(FtpID_IsServerItemID(pidlServer)))
    {
        LPITEMIDLIST pidlServerOnly = FtpCloneServerID(pidlServer);

        if (pidlServerOnly)
        {
            if (FtpID_IsServerItemID(pidlFtpPath))
                pidlFtpPath = _ILNext(pidlFtpPath);

            *ppidlOut = ILCombine(pidlServerOnly, pidlFtpPath);
            if (*ppidlOut)
                hr = S_OK;
            else
                hr = E_FAIL;

            ILFree(pidlServerOnly);
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppidlOut, hr);
    return hr;
}


BOOL FtpItemID_IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Don't repeat recursively.
    return (S_OK == _FtpItemID_CompareOneID(COL_NAME, pidl1, pidl2, FALSE));
}


BOOL FtpPidl_IsPathEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // This works recursively.
    return ((0 == FtpItemID_CompareIDsInt(COL_NAME, pidl1, pidl2, FCMP_NORMAL)) ? TRUE : FALSE);
}


// is pidlChild a child of pidlParent
BOOL FtpItemID_IsParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    BOOL fIsChild = TRUE;

    if (pidlChild)
    {
        LPITEMIDLIST pidl1Iterate = (LPITEMIDLIST) pidlParent;
        LPITEMIDLIST pidl2Iterate = (LPITEMIDLIST) pidlChild;

        ASSERT(!FtpID_IsServerItemID(pidl1Iterate) && pidlParent && !FtpID_IsServerItemID(pidl2Iterate));

        // Let's see if pidl starts off with 
        while (fIsChild && pidl1Iterate && !ILIsEmpty(pidl1Iterate) &&
                pidl2Iterate && !ILIsEmpty(pidl2Iterate) && 
                FtpItemID_IsEqual(pidl1Iterate, pidl2Iterate))
        {
            fIsChild = FtpItemID_IsEqual(pidl1Iterate, pidl2Iterate);

            pidl1Iterate = _ILNext(pidl1Iterate);
            pidl2Iterate = _ILNext(pidl2Iterate);
        }

        if (!(ILIsEmpty(pidl1Iterate) && !ILIsEmpty(pidl2Iterate)))
            fIsChild = FALSE;
    }
    else
        fIsChild = FALSE;

    return fIsChild;
}


// is pidlChild a child of pidlParent, so all the itemIDs in
// pidlParent are in pidlChild, but pidlChild has more.
// This will return a pointer to those itemIDs.
LPCITEMIDLIST FtpItemID_FindDifference(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    LPCITEMIDLIST pidlDiff = (LPITEMIDLIST) pidlChild;

    if (pidlChild)
    {
        LPITEMIDLIST pidl1Iterate = (LPITEMIDLIST) pidlParent;

        if (FtpID_IsServerItemID(pidl1Iterate))
            pidl1Iterate = _ILNext(pidl1Iterate);

        if (FtpID_IsServerItemID(pidlDiff))
            pidlDiff = _ILNext(pidlDiff);

        // Let's see if pidl starts off with 
        while (pidl1Iterate && !ILIsEmpty(pidl1Iterate) &&
                pidlDiff && !ILIsEmpty(pidlDiff) && 
                FtpItemID_IsEqual(pidl1Iterate, pidlDiff))
        {
            pidlDiff = _ILNext(pidlDiff);
            pidl1Iterate = _ILNext(pidl1Iterate);
        }
    }

    return pidlDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpprop.cpp ===
/*****************************************************************************\
 *
 *    ftpprop.cpp - Property sheets
 *
\*****************************************************************************/

#include "priv.h"
#include "ftpprop.h"
#include "util.h"
#include "resource.h"


void CFtpProp::_HideCHMOD_UI(HWND hDlg)
{
    // Now, so hide the UI.
    for (int nIndex = IDD_CHMOD; nIndex <= IDC_CHMOD_LAST; nIndex++)
        ShowEnableWindow(GetDlgItem(hDlg, nIndex), FALSE);
}


DWORD CFtpProp::_GetUnixPermissions(void)
{
    DWORD dwPermissions = 0;
    LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(0);     // They don't give us a ref.

    if (pidl)
    {
        dwPermissions = FtpItemID_GetUNIXPermissions(ILGetLastID(pidl));
    }

    return dwPermissions;
}


static const DWORD c_dwUnixPermissionArray[] = {UNIX_CHMOD_READ_OWNER, UNIX_CHMOD_WRITE_OWNER, UNIX_CHMOD_EXEC_OWNER,
                                                UNIX_CHMOD_READ_GROUP, UNIX_CHMOD_WRITE_GROUP, UNIX_CHMOD_EXEC_GROUP,
                                                UNIX_CHMOD_READ_ALL, UNIX_CHMOD_WRITE_ALL, UNIX_CHMOD_EXEC_ALL};

// NOTE: If we need to set focus rects for the check boxes, we can steal code from:
//         \\rastaman\ntwin\src\shell\security\aclui\chklist.cpp

HRESULT CFtpProp::_SetCHMOD_UI(HWND hDlg)
{
    DWORD dwUnixPermissions = _GetUnixPermissions();

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_dwUnixPermissionArray); nIndex++)
    {
        // Is this permission set?
        CheckDlgButton(hDlg, (IDD_CHMOD + nIndex), (dwUnixPermissions & c_dwUnixPermissionArray[nIndex]));
    }

    return S_OK;
}


DWORD CFtpProp::_GetCHMOD_UI(HWND hDlg)
{
    DWORD dwUnixPermissions = 0;

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_dwUnixPermissionArray); nIndex++)
    {
        // Is it checked in the UI?
        if (IsDlgButtonChecked(hDlg, (IDD_CHMOD + nIndex)))
        {
            // Yes, so set the big.
            dwUnixPermissions |= c_dwUnixPermissionArray[nIndex];
        }
    }

    return dwUnixPermissions;
}


/*****************************************************************************\
    FUNCTION: _SetCHMOD_CB

    DESCRIPTION:
        If we were able to rename the file, return the output pidl.
    Also tell anybody who cares that this LPITEMIDLIST needs to be refreshed.

    The "A" emphasizes that the filename is received in ANSI.

    _UNDOCUMENTED_: The documentation on SetNameOf's treatment of
    the source pidl is random.  It seems to suggest that the source
    pidl is ILFree'd by SetNameOf, but it isn't.
\*****************************************************************************/
HRESULT CFtpProp::_CommitCHMOD(HINTERNET hint, HINTPROCINFO * phpi, BOOL * pfReleaseHint)
{
    HRESULT hr;
    HINTERNET hintResponse;
    WIRECHAR wFtpCommand[MAX_PATH];
    LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(0);     // They don't give us a ref.

    // 1. Create "SITE chmod <m_dwNewPermissions> <filename>" string
    wnsprintfA(wFtpCommand, ARRAYSIZE(wFtpCommand), FTP_CMD_SITE_CHMOD_TEMPL, m_dwNewPermissions, FtpPidl_GetLastItemWireName(pidl));

    hr = FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, wFtpCommand, NULL, &hintResponse);
    if (SUCCEEDED(hr))
    {
        // Update the pidl with the new Permissions so our cache isn't out of date.
        CFtpDir * pfd = m_pff->GetFtpDir();

        FtpItemID_SetUNIXPermissions(pidl, m_dwNewPermissions);
        if (pfd)
        {
            pfd->ReplacePidl(pidl, pidl);
            FtpChangeNotify(m_hwnd, FtpPidl_DirChoose(pidl, SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM), m_pff, pfd, pidl, pidl, TRUE);
            pfd->Release();
        }

        InternetCloseHandleWrap(hintResponse, TRUE);
    }
    else
    {
        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_CHMOD, IDS_FTPERR_WININET, MB_OK, NULL);
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}


HRESULT CFtpProp::_CommitCHMOD_CB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvData, BOOL * pfReleaseHint)
{
    CFtpProp * pfp = (CFtpProp *) pvData;

    return pfp->_CommitCHMOD(hint, phpi, pfReleaseHint);
}


/*****************************************************************************\
    FUNCTION: OnInitDialog

    DESCRIPTION: 
        Fill the dialog with cool stuff.
\*****************************************************************************/
BOOL CFtpProp::OnInitDialog(HWND hDlg)
{
    EVAL(SUCCEEDED(m_ftpDialogTemplate.InitDialog(hDlg, TRUE, IDC_ITEM, m_pff, m_pflHfpl)));

    m_fChangeModeSupported = FALSE; // Default to false

#ifdef FEATURE_CHANGE_PERMISSIONS
    // Is the correct number of items selected to possibly enable the CHMOD feature?
    if (1 == m_pflHfpl->GetCount())
    {
        // Yes, now the question is, is it supported by the server?
        CFtpDir * pfd = m_pff->GetFtpDir();

        if (pfd)
        {
            // Does the server support it?
            m_fChangeModeSupported = pfd->IsCHMODSupported();
            if (m_fChangeModeSupported)
            {
                // Yes, so hide the "Not supported by server" string.
                ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);
                _SetCHMOD_UI(hDlg); // Update the checkboxes with what's available.
            }
            else
            {
                // No, so hide the CHMOD UI.  The warning that it's not supported by
                // the server is already visible.
                _HideCHMOD_UI(hDlg);
            }

            pfd->Release();
        }
        else
        {
            // No, so hide the CHMOD UI.  This happens on the property sheet for
            // the server.
            _HideCHMOD_UI(hDlg);

            // Also remove the server not supported warning.
            ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);
        }
    }
    else
    {
        // No, so just remove that UI.
        _HideCHMOD_UI(hDlg);

        // Also remove the server not supported warning.
        ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);

        // Maybe we need a message saying, "Can't do this with this many items selected"
    }
#endif // FEATURE_CHANGE_PERMISSIONS

    return 1;
}


/*****************************************************************************\
    FUNCTION: OnClose

    DESCRIPTION: 
\*****************************************************************************/
BOOL CFtpProp::OnClose(HWND hDlg)
{
    BOOL fResult = TRUE;

#ifdef FEATURE_CHANGE_PERMISSIONS
    // Did m_ftpDialogTemplate.OnClose() finish all the work it needed in order
    // to close?  This work currently changes the filename.  If so, we
    // will then want to try to apply the UNIX Permission changes if any where
    // made.
    if (m_fChangeModeSupported)
    {
        // Now we need to apply the CHMOD.
        // TODO:
        DWORD dwCurPermissions = _GetUnixPermissions();
        m_dwNewPermissions = _GetCHMOD_UI(hDlg);

        // Did the user change the permissions
        if (dwCurPermissions != m_dwNewPermissions)
        {
            CFtpDir * pfd = m_pff->GetFtpDir();

            if (pfd)
            {
                // Yes, so commit those changes to the server.
                if (FAILED(pfd->WithHint(NULL, m_hwnd, _CommitCHMOD_CB, (LPVOID) this, NULL, m_pff)))
                {
                    EVAL(SUCCEEDED(_SetCHMOD_UI(hDlg)));
                    fResult = FALSE;
                }

                pfd->Release();
            }
        }
    }
#endif // FEATURE_CHANGE_PERMISSIONS

    if (fResult)
    {
        m_ftpDialogTemplate.OnClose(hDlg, m_hwnd, m_pff, m_pflHfpl);
    }

    return fResult;
}


/*****************************************************************************\
    FUNCTION: OnDestroy

    DESCRIPTION: 
        Fill the dialog with cool stuff.
\*****************************************************************************/
BOOL CFtpProp::OnDestroy(HWND hDlg)
{
    m_ftpDialogTemplate.OnDestroy(hDlg, TRUE, IDC_ITEM, m_pff, m_pflHfpl);

    return TRUE;
}


#ifdef FEATURE_CHANGE_PERMISSIONS
INT_PTR CFtpProp::_SetWhiteBGCtlColor(HWND hDlg, HDC hdc, HWND hwndCtl)
{
    INT_PTR fResult = 0;

    if ((hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GROUPBOX)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_OWNER)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_GROUP)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_ALL)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OE)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GE)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AE)))
    {
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

        fResult = (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
    }

    return fResult;
}
#endif // FEATURE_CHANGE_PERMISSIONS


/*****************************************************************************\
 *    DlgProc
\*****************************************************************************/
INT_PTR CFtpProp::DlgProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;   // not Handled
    CFtpProp * pfp = (CFtpProp *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (wm)
    {
    case WM_INITDIALOG:
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
        pfp =  (CFtpProp *)ppsp->lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pfp);

        ASSERT(pfp);
        fResult = pfp->OnInitDialog(hDlg);
    }
    break;

    case WM_NOTIFY:
        if (lParam)
        {
            switch (((NMHDR *)lParam)->code) 
            {
                case PSN_APPLY:
                    if (pfp->OnClose(hDlg))
                    {
                        fResult = FALSE;    // Tell comctl32 I'm happy
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        fResult = TRUE;    // Tell comctl32 to look at the error code and don't close.
                    }
                break;
                
                case PSN_TRANSLATEACCELERATOR:
                    if (pfp->m_ftpDialogTemplate.HasNameChanged(hDlg, pfp->m_pff, pfp->m_pflHfpl))
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    break;
            }
        }
        break;

#ifdef FEATURE_CHANGE_PERMISSIONS
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
        fResult = pfp->_SetWhiteBGCtlColor(hDlg, (HDC)wParam, (HWND)lParam);
        break;
#endif // FEATURE_CHANGE_PERMISSIONS

    case WM_DESTROY:
        fResult = pfp->OnDestroy(hDlg);
        break;

    }

    return fResult;
}


/*****************************************************************************\
 *    DoProp_OnThread
 *
 *    Display a property sheet on the current thread.
 *
 *    WARNING!  VIOLATION OF OLE REFERENCE STUFF!
 *
 *    The PFP that comes in must be Release()d when we're done.
 *
 *    The reason is that the caller has "given us" the reference;
 *    we now own it and are responsible for releasing it.
\*****************************************************************************/
DWORD CFtpProp::_PropertySheetThread(void)
{
    HRESULT hrOleInit;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp;
    TCHAR szTitle[MAX_PATH];

    hrOleInit = SHOleInitialize(0);
    ASSERT(SUCCEEDED(hrOleInit));

    // This will allow the dialog to work with items outside of the font.
    // So Date, Name, and URL can be in the correct font even through
    // it's not supported by the DLL's font.
    InitComctlForNaviteFonts();
    LoadString(HINST_THISDLL, IDS_PROP_SHEET_TITLE, szTitle, ARRAYSIZE(szTitle));

    // psh.hwndParent being NULL or valid will determine if the property
    // sheet appears in the taskbar.  We do want it there to be consistent
    // with the shell.
    //
    // NOTE: Comctl32's property sheet code will make this act modal by
    //         disabling the parent window (m_hwnd).  We need to fix this
    //         (#202885) by creating a dummy window and using that as the
    //         parent.

    psh.hwndParent = SHCreateWorkerWindow(NULL, m_hwnd, 0, 0, NULL, NULL);
    psh.dwSize = sizeof(psh);
    psh.dwFlags = (PSH_PROPTITLE | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP);
    psh.hInstance = g_hinst;
    psh.pszCaption = szTitle;
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = &psp;

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_FILEPROP);
    psp.pfnDlgProc = CFtpProp::DlgProc;
    psp.lParam = (LPARAM)this;

    PropertySheet(&psh);

    DestroyWindow(psh.hwndParent);

    this->Release();

    SHOleUninitialize(hrOleInit);
    return 0;
}


/*****************************************************************************\
 *    CFtpProp_DoProp
 *
 *    Display a property sheet with stuff in it.
\*****************************************************************************/
HRESULT CFtpProp_DoProp(CFtpPidlList * pflHfpl, CFtpFolder * pff, HWND hwnd)
{
    CFtpProp * pfp;
    HRESULT hres = CFtpProp_Create(pflHfpl, pff, hwnd, &pfp);

    if (SUCCEEDED(hres))
    {
        HANDLE hThread;
        DWORD id;

        hThread = CreateThread(0, 0, CFtpProp::_PropertySheetThreadProc, (LPVOID) pfp, 0, &id);
        if (hThread)
        {
            // It will release it self if the thread was created.
            CloseHandle(hThread);
            hres = S_OK;
        }
        else
        {
            pfp->Release();
            hres = E_UNEXPECTED;
        }
    }

    return hres;
}


/*****************************************************************************\
 *    CFtpProp_Create
 *
 *    Display a property sheet with stuff in it.
\*****************************************************************************/
HRESULT CFtpProp_Create(CFtpPidlList * pflHfpl, CFtpFolder * pff, HWND hwnd, CFtpProp ** ppfp)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFtpProp * pfp;

    pfp = *ppfp = new CFtpProp();
    if (pfp)
    {
        pfp->m_pff = pff;
        if (pff)
            pff->AddRef();

        pfp->m_pflHfpl = pflHfpl;
        if (pflHfpl)
            pflHfpl->AddRef();

        pfp->m_hwnd = hwnd;

        hr = S_OK;
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpProp::CFtpProp() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_hwnd);

    LEAK_ADDREF(LEAK_CFtpProp);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpProp::~CFtpProp()
{
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pflHfpl, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpProp);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpProp::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpProp::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpProp::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpProp::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpstm.cpp ===
/*****************************************************************************
 *
 *    ftpstm.cpp - IStream interface
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpstm.h"
#include "ftpurl.h"

#define     UPDATE_PROGRESS_EVERY       (10*1024)       // Update progress every 10k

/*****************************************************************************
 *    CFtpStm::ReadOrWrite
 *****************************************************************************/
HRESULT CFtpStm::ReadOrWrite(LPVOID pv, ULONG cb, ULONG * pcb, DWORD dwAccess, STMIO io, HRESULT hresFail)
{
    HRESULT hr = STG_E_ACCESSDENIED;

    if (EVAL(m_dwAccessType & dwAccess))
    {
        ULONG cbOut;
        if (!pcb)
            pcb = &cbOut;

        hr = io(m_hint, TRUE, pv, cb, pcb);
        if (SUCCEEDED(hr) && m_ppd)
        {
            m_uliComplete.QuadPart += cb;
            m_ulBytesSinceProgressUpdate += cb;
            if (m_ulBytesSinceProgressUpdate > UPDATE_PROGRESS_EVERY)
            {
                m_ulBytesSinceProgressUpdate = 0;
                EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliComplete.QuadPart, m_uliTotal.QuadPart)));
            }

            if (TRUE == m_ppd->HasUserCancelled())
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}


//===========================
// *** IStream Interface ***
//===========================

/*****************************************************************************
 *    IStream::Read
 *****************************************************************************/
HRESULT CFtpStm::Read(LPVOID pv, ULONG cb, PULONG pcb)
{
    return ReadOrWrite(pv, cb, pcb, GENERIC_READ, InternetReadFileWrap, S_FALSE);
}


/*****************************************************************************
 *    IStream::Write
 *****************************************************************************/
HRESULT CFtpStm::Write(LPCVOID pv, ULONG cb, PULONG pcb)
{
    return ReadOrWrite((LPVOID)pv, cb, pcb, GENERIC_WRITE, (STMIO) InternetWriteFileWrap, STG_E_WRITEFAULT);
}


/*****************************************************************************
 *    IStream::CopyTo
 *
 *    _UNOBVIOUS_:  Implementing CopyTo is mandatory for drag/drop to work.
 *****************************************************************************/
#define SIZE_STREAM_COPY_BUFFER     (1024*16)        // 16k is the perfect size for 

HRESULT CFtpStm::CopyTo(IStream * pstmDest, ULARGE_INTEGER cbToCopy, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = E_FAIL;
    IStream * pstmSrc;

    if (EVAL(SUCCEEDED(hr = QueryInterface(IID_IStream, (LPVOID *) &pstmSrc))))
    {
        ULARGE_INTEGER uliTotalIn;
        ULARGE_INTEGER uliTotalOut;
        uliTotalIn.QuadPart = uliTotalOut.QuadPart = 0;
        BYTE buffer[SIZE_STREAM_COPY_BUFFER];

        for (;;)
        {
            // Very unusual loop control
            ULONG cbIn = 0;        // In case pstmSrc forgets to

            //    No matter how you write this, the compiler emits horrid code.
            ULONG cb = (ULONG)min(SIZE_STREAM_COPY_BUFFER, cbToCopy.LowPart);
            hr = pstmSrc->Read(buffer, cb, &cbIn);
            uliTotalIn.QuadPart += cbIn;
            if (SUCCEEDED(hr) && cbIn)
            {
                ULARGE_INTEGER uliOut;    // In case pstmDest forgets to
                uliOut.QuadPart = 0;

                hr = pstmDest->Write(buffer, cbIn, &(uliOut.LowPart));
                uliTotalOut.QuadPart += uliOut.QuadPart;
                if (EVAL(SUCCEEDED(hr) && uliOut.QuadPart))
                {
                    // Onward
                }
                else
                {
                    break;        // Error or medium full
                }
            }
            else
            {
                break;            // Error or EOF reached
            }
        }

        if (pcbRead)
            pcbRead->QuadPart = uliTotalIn.QuadPart;

        if (pcbWritten)
            pcbWritten->QuadPart = uliTotalOut.QuadPart;

        pstmSrc->Release();
    }

    return hr;
}


/*****************************************************************************
 *    IStream::Commit
 *
 *    NOTE: WinINet doesn't really implement this, so I just do my best
 *****************************************************************************/
HRESULT CFtpStm::Commit(DWORD grfCommitFlags)
{
    return S_OK;
}


/*****************************************************************************
 *    IStream::LockRegion
 *
 *    You can't lock an ftp stream.
 *****************************************************************************/
HRESULT CFtpStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}


/*****************************************************************************
 *    IStream::UnlockRegion
 *
 *    You can't unlock an ftp stream because you can't lock one...
 *****************************************************************************/
HRESULT CFtpStm::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}


/*****************************************************************************
 *    IStream::Stat
 *
 *    We fill in what we can.
 *
 *    As the pwcsName, we put the URL that the stream represents, and
 *    install ourselves as the clsid.
 *****************************************************************************/
HRESULT CFtpStm::Stat(STATSTG *pstat, DWORD grfStatFlag)
{
    HRESULT hr;

    ZeroMemory(pstat, sizeof(*pstat));
    pstat->type = STGTY_STREAM;

    pstat->mtime = FtpPidl_GetFileTime(ILFindLastID(m_pidl));
    pstat->cbSize.QuadPart = FtpItemID_GetFileSize(ILFindLastID(m_pidl));

    pstat->grfMode |= STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
    if (m_dwAccessType & GENERIC_READ)
        pstat->grfMode |= STGM_READ;

    if (m_dwAccessType & GENERIC_WRITE)
        pstat->grfMode |= STGM_WRITE;

    if (grfStatFlag & STATFLAG_NONAME)
        hr = S_OK;
    else
    {
        pstat->pwcsName = (LPWSTR) SHAlloc(MAX_PATH * sizeof(WCHAR));
        if (pstat->pwcsName)
        {
            hr = FtpPidl_GetLastFileDisplayName(m_pidl, pstat->pwcsName, MAX_PATH);
        }
        else
            hr = STG_E_INSUFFICIENTMEMORY;    // N.B., not E_OUTOFMEMORY
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION:   CFtpStm_Create

    DESCRIPTION:
        The caller will display errors, so don't do that here.
\*****************************************************************************/
HRESULT CFtpStm_Create(CFtpDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, IStream ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg)
{
    CFtpStm * pfstm = new CFtpStm();
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwError = ERROR_SUCCESS;

    *ppstream = NULL;
    if (pfstm)
    {
        Pidl_Set(&(pfstm->m_pidl), pidl);
        ASSERT(pfstm->m_pidl);
        pfstm->m_dwAccessType = dwAccess;
        IUnknown_Set(&pfstm->m_pfd, pfd);
        IUnknown_Set((IUnknown **)&pfstm->m_ppd, (IUnknown *)ppd);
        pfstm->m_uliComplete = uliComplete;
        pfstm->m_uliTotal = uliTotal;
        pfstm->m_fClosePrgDlg = fClosePrgDlg;

        //      GetHint() is going to want to spew status into the Status Bar
        //   But how do we get the hwnd?  This is an architectural question that
        //   we need to solve for all Shell Extensions.  The answer is to not use
        //   the progress bar in the status bar but a Progress Dialog.  But it's
        //   the responsibility of the caller to do that.
        HWND hwnd = NULL;

        hr = pfd->GetHint(hwnd, NULL, &pfstm->m_hintSession, NULL, NULL);
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidlVirtualRoot;

            hr = pfd->GetFtpSite()->GetVirtualRoot(&pidlVirtualRoot);
            if (EVAL(SUCCEEDED(hr)))
            {
                LPITEMIDLIST pidlOriginalFtpPath;
                CWireEncoding * pwe = pfd->GetFtpSite()->GetCWireEncoding();

                hr = FtpGetCurrentDirectoryPidlWrap(pfstm->m_hintSession, TRUE, pwe, &pidlOriginalFtpPath);
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlWithVirtualRoot;

                    hr = FtpPidl_InsertVirtualRoot(pidlVirtualRoot, pidl, &pidlWithVirtualRoot);
                    if (SUCCEEDED(hr))
                    {
                        hr = FtpSetCurrentDirectoryPidlWrap(pfstm->m_hintSession, TRUE, pidlWithVirtualRoot, TRUE, TRUE);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwDownloadType = FtpPidl_GetDownloadType(pidl);

                            // PERF: I bet we would be faster if we delayed the open until
                            //       the first ::Read(), ::Write(), or ::CopyToStream() call.
                            Pidl_Set(&pfstm->m_pidlOriginalFtpPath, pidlOriginalFtpPath);
                            hr = FtpOpenFileWrap(pfstm->m_hintSession, TRUE, FtpPidl_GetLastItemWireName(pidl), pfstm->m_dwAccessType, dwDownloadType, 0, &pfstm->m_hint);
                        }

                        ILFree(pidlWithVirtualRoot);
                    }

                    ILFree(pidlOriginalFtpPath);
                }

                ILFree(pidlVirtualRoot);
            }
        }

        if (SUCCEEDED(hr))
            hr = pfstm->QueryInterface(IID_IStream, (LPVOID *) ppstream);

        pfstm->Release();
    }

    return hr;
}




/****************************************************\
    Constructor
\****************************************************/
CFtpStm::CFtpStm() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hint);
    ASSERT(!m_dwAccessType);
    ASSERT(!m_pfd);
    ASSERT(!m_hintSession);
    ASSERT(!m_pidl);
    ASSERT(!m_ppd);

    LEAK_ADDREF(LEAK_CFtpStm);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpStm::~CFtpStm()
{
    if (m_hint)
    {
        InternetCloseHandle(m_hint);
    }

    // This COM object works like this:
    // 1. The constructor opens a handle to the server and
    //    Changes directory into the dir we are going to work in.
    // 2. The original dir is saved (m_pidlOriginalFtpPath) in order to be restored later
    //    because we cache the internet handle for perf and to keep our place on the server.
    // 3. The caller of this COM object can then copy data.
    // 4. We then Change directory to the original dir here before we close the internet handle.s
    if (m_pidlOriginalFtpPath && EVAL(m_hintSession))
    {
        EVAL(SUCCEEDED(FtpSetCurrentDirectoryPidlWrap(m_hintSession, TRUE, m_pidlOriginalFtpPath, TRUE, TRUE)));
        Pidl_Set(&m_pidlOriginalFtpPath, NULL);
    }

    if (m_hintSession)
        m_pfd->ReleaseHint(m_hintSession);

    ATOMICRELEASE(m_pfd);

    if (m_ppd && m_fClosePrgDlg)
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
    ATOMICRELEASE(m_ppd);

    ILFree(m_pidl);
    ILFree(m_pidlOriginalFtpPath);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpStm);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpStm::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpStm::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpStm::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream))
    {
        *ppvObj = SAFECAST(this, IStream*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpStm::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpsite.h ===
/*****************************************************************************
 *    ftpsite.h
 *****************************************************************************/

#ifndef _FTPSITE_H
#define _FTPSITE_H

#include "ftpfoldr.h"
#include "ftplist.h"
#include "ftpinet.h"
#include "ftpurl.h"
#include "account.h"
#include "util.h"

HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CFtpSite ** ppfs);


int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvFtpSite, LPARAM lParam);
HRESULT CFtpPunkList_Purge(CFtpList ** pfl);

/*****************************************************************************
 *    CFtpSite
 *****************************************************************************/

class CFtpSite              : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CFtpSite();
    ~CFtpSite();

    // Public Member Functions
    void CollectMotd(HINTERNET hint);
    void ReleaseHint(LPCITEMIDLIST pidlFtpPath, HINTERNET hint);
    HRESULT GetHint(HWND hwnd, LPCITEMIDLIST pidlFtpPath, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CFtpFolder * pff);
    BOOL QueryMotd(void);
    BOOL IsServerVMS(void) {return m_fIsServerVMS;};
    BOOL HasVirtualRoot(void);
    CFtpGlob * GetMotd(void);
    CFtpList * GetCFtpList(void);
    CWireEncoding * GetCWireEncoding(void) {return &m_cwe;};
    HRESULT GetFtpDir(LPCITEMIDLIST pidl, CFtpDir ** ppfd);
    HRESULT GetFtpDir(LPCTSTR pszUrlPath, CFtpDir ** ppfd) {return GetFtpDir(m_pszServer, pszUrlPath, ppfd);};
    HRESULT GetFtpDir(LPCTSTR pszServer, LPCTSTR pszUrlPath, CFtpDir ** ppfd);

    HRESULT GetVirtualRoot(LPITEMIDLIST * ppidl);
    HRESULT PidlInsertVirtualRoot(LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidl);
    LPCITEMIDLIST GetVirtualRootReference(void) {return (LPCITEMIDLIST) m_pidlVirtualDir;};

    HRESULT GetServer(LPTSTR pszServer, DWORD cchSize) { StrCpyN(pszServer, HANDLE_NULLSTR(m_pszServer), cchSize); return S_OK; };
    HRESULT GetUser(LPTSTR pszUser, DWORD cchSize) { StrCpyN(pszUser, HANDLE_NULLSTR(m_pszUser), cchSize); return S_OK; };
    HRESULT GetPassword(LPTSTR pszPassword, DWORD cchSize) { StrCpyN(pszPassword, HANDLE_NULLSTR(m_pszPassword), cchSize); return S_OK; };
    HRESULT UpdateHiddenPassword(LPITEMIDLIST pidl);
    HRESULT SetRedirPassword(LPCTSTR pszPassword) {Str_SetPtr(&m_pszRedirPassword, pszPassword); return S_OK;};
    HRESULT FlushSubDirs(LPCITEMIDLIST pidl);

    LPITEMIDLIST GetPidl(void);

    BOOL IsCHMODSupported(void) {return m_fIsCHMODSupported;};
    BOOL IsUTF8Supported(void) {return m_fInUTF8Mode;};
    BOOL IsSiteBlockedByRatings(HWND hwndDialogOwner);
    void FlushRatingsInfo(void) {m_fRatingsChecked = m_fRatingsAllow = FALSE;};

    static void FlushHintCB(LPVOID pvFtpSite);


    // Friend Functions
    friend HRESULT CFtpSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CFtpSite ** ppfs);
    friend HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CFtpSite ** ppfs);

    friend int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvFtpSite, LPARAM lParam);
    friend class CFtpView;


protected:
    // Private Member Variables
    int m_cRef;

    BOOL            m_fMotd;            // There is a Motd at all
    BOOL            m_fNewMotd;         // Motd has changed
    HINTERNET       m_hint;             // Session for this site
    LPGLOBALTIMEOUTINFO m_hgti;         // Timeout for the session handle
    CFtpList *      m_FtpDirList;       // List of FtpDir's attached to me. (No Ref Held)
    CFtpGlob *      m_pfgMotd;          //
    IMalloc *       m_pm;               // Used for creating full pidls if needed.

    LPTSTR          m_pszServer;        // Server name
    LPITEMIDLIST    m_pidl;             // What ftp dir is hint in? (Not including the virtual root) (Does begin with ServerID)
    LPTSTR          m_pszUser;          // 0 or "" means "anonymous"
    LPTSTR          m_pszPassword;      // User's Password
    LPTSTR          m_pszFragment;      // URL fragment
    LPITEMIDLIST    m_pidlVirtualDir;   // Our rooted directory on the server.
    LPTSTR          m_pszRedirPassword; // What was the password if it was changed?
    LPTSTR          m_pszLookupStr;     // Str to lookup.
    INTERNET_PORT   m_ipPortNum;        // The port number
    BOOL            m_fDLTypeSpecified; // Did the user specify a Download Type to use? (ASCII vs. Binary)
    BOOL            m_fASCIIDownload;   // If specified, was it ASCII? (Else, Binary)
    CAccounts       m_cAccount;
    BOOL            m_fRatingsChecked;  // Did I check ratings yet?
    BOOL            m_fRatingsAllow;    // Does ratings allow access to this site?
    BOOL            m_fFeaturesQueried; // 
    BOOL            m_fInUTF8Mode;      // Did a success value come back from the 'UTF8' command?
    BOOL            m_fIsCHMODSupported;// Is the CHMOD UNIX command supported via the 'SITE CHMOD' FTP Command?
    BOOL            m_fIsServerVMS;     // Is this a VMS server?

    CWireEncoding   m_cwe;              // What codepage and confidence in that codepage of the MOTD and filenames?

    // Protected Member Functions
    HRESULT _RedirectAndUpdate(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlFtpPath, LPCTSTR pszFragment, IUnknown * punkSite, CFtpFolder * pff);
    HRESULT _Redirect(LPITEMIDLIST pidl, IUnknown * punkSite, CFtpFolder * pff);
    HRESULT _SetDirectory(HINTERNET hint, HWND hwnd, LPCITEMIDLIST pidlNewDir, CStatusBar * psb, int * pnTriesLeft);

private:
    // Private Member Functions
    HRESULT _SetPidl(LPCITEMIDLIST pidlFtpPath);
    HRESULT _QueryServerFeatures(HINTERNET hint);
    HRESULT _CheckToEnableCHMOD(LPCWIRESTR pwResponse);
    HRESULT _LoginToTheServer(HWND hwnd, HINTERNET hintDll, HINTERNET * phint, LPCITEMIDLIST pidlFtpPath, CStatusBar * psb, IUnknown * punkSite, CFtpFolder * pff);
    HRESULT _SetRedirPassword(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlFtpPath, LPCTSTR pszFragment);

    void FlushHint(void);
    void FlushHintCritial(void);

    // Private Friend Functions
    friend HRESULT SiteCache_PrivSearch(LPCTSTR pszLookup, LPCITEMIDLIST pidl, IMalloc * pm, CFtpSite ** ppfs);
};



HRESULT CFtpSite_Init(void);
HRESULT CFtpSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CFtpSite ** ppfs);


#endif // _FTPSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpprop.h ===
/*****************************************************************************
 *	ftpprop.h
 *****************************************************************************/

#ifndef _FTPPROP_H
#define _FTPPROP_H

#include "ftpdhlp.h"
#include "ftppl.h"

HRESULT CFtpProp_DoProp(CFtpPidlList * pflHfpl, CFtpFolder * pff, HWND hwnd);



/*****************************************************************************\
    CLASS: CFtpProp

    DESCRIPTION:
        NOTE! that we use the IShellFolder on the wrong thread!

    Take careful note that all the CFtpFolder methods we call are thread-safe.
    The Change UNIX Permissions feature works by sending the command
    "SITE CHMOD <permissions> <filename>" to the server.
\*****************************************************************************/

class CFtpProp          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
public:
    CFtpProp();
    ~CFtpProp(void);

    // Friend Functions
    friend HRESULT CFtpProp_Create(CFtpPidlList * pflHfpl, CFtpFolder * pff, HWND hwnd, CFtpProp ** ppfp);
    static HRESULT _CommitCHMOD_CB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);
    static DWORD _PropertySheetThreadProc(LPVOID pvCFtpProp) {return ((CFtpProp *) pvCFtpProp)->_PropertySheetThread(); };

protected:
    // Public Member Variables
    int                     m_cRef;

    CFtpFolder *            m_pff;          // Folder that owns the pidls
    CFtpPidlList *          m_pflHfpl;      // 
    HWND                    m_hwnd;         // browser window for UI and Legacy ChangeNotify
    CFtpDialogTemplate      m_ftpDialogTemplate;
    BOOL                    m_fChangeModeSupported;
    DWORD                   m_dwNewPermissions;

    
    // Public Member Functions
    BOOL OnInitDialog(HWND hdlg);
    BOOL OnClose(HWND hDlg);
    BOOL OnDestroy(HWND hDlg);
    DWORD _PropertySheetThread(void);
    void _HideCHMOD_UI(HWND hDlg);
    HRESULT _SetCHMOD_UI(HWND hDlg);
    DWORD _GetCHMOD_UI(HWND hDlg);
    DWORD _GetUnixPermissions(void);
    HRESULT _CommitCHMOD(HINTERNET hint, HINTPROCINFO * phpi, BOOL * pfReleaseHint);
    INT_PTR _SetWhiteBGCtlColor(HWND hDlg, HDC hdc, HWND hwndCtl);

    static INT_PTR DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
};

DWORD DoProp_OnThread(LPVOID pv);


#endif // _FTPPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpstm.h ===
/*****************************************************************************
 *	ftpstm.h
 *****************************************************************************/

#ifndef _FTPSTREAM_H
#define _FTPSTREAM_H

typedef HRESULT (*STMIO)(HINTERNET hinst, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten);

/*****************************************************************************
 *
 *	CFtpStm
 *
 *
 *****************************************************************************/

class CFtpStm           : public IStream
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IStream ***
    virtual STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    virtual STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    virtual STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition) { return(E_NOTIMPL); };
    virtual STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) { return(E_NOTIMPL); };
    virtual STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);
    virtual STDMETHODIMP Revert(void) { return(E_NOTIMPL); };
    virtual STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    virtual STDMETHODIMP Clone(IStream **ppstm) { return(E_NOTIMPL); };


public:
    CFtpStm();
    ~CFtpStm(void);

    // Public Member Functions
    HRESULT ReadOrWrite(LPVOID pv, ULONG cb, ULONG * pcb, DWORD dwAccess, STMIO io, HRESULT hresFail);


    // Friend Functions
    friend HRESULT CFtpStm_Create(CFtpDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, IStream ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg);

protected:
    // Private Member Variables
    int                     m_cRef;

    HINTERNET               m_hint;             //
    DWORD                   m_dwAccessType;     //
    CFtpDir *               m_pfd;              //
    HINTERNET               m_hintSession;      //
    LPITEMIDLIST            m_pidl;             //
    IProgressDialog *       m_ppd;              //
    ULARGE_INTEGER          m_uliComplete;      //
    ULARGE_INTEGER          m_uliTotal;         //
    BOOL                    m_fClosePrgDlg;     // Do we want to close the progress dialog after we finish copying this stream?
    ULONG                   m_ulBytesSinceProgressUpdate;     // When was the last time I displayed progress?
    LPITEMIDLIST            m_pidlOriginalFtpPath;    // We need to return the current directory for this handle to this location when we are done.
};

#endif // _FTPSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpsite.cpp ===
/*****************************************************************************\
 *    ftpsite.cpp - Internal object that manages a single FTP site
\*****************************************************************************/

#include "priv.h"
#include "ftpsite.h"
#include "ftpinet.h"
#include "ftpurl.h"
#include "statusbr.h"
#include "offline.h"
#include <ratings.h>
#include <wininet.h>

#ifdef DEBUG
DWORD g_dwOpenConnections = 0;      // Ref Counting Open Connections
#endif // DEBUG

/*****************************************************************************\
 *    CFtpSite
 *
 *    EEK!  RFC 1738 is really scary.  FTP sites don't necessarily
 *    start you at the root, and RFC1738 says that ftp://foo/bar asks
 *    for the file bar in the DEFAULT directory, not the root!
\*****************************************************************************/
CFtpList * g_FtpSiteCache = NULL;                /* The list of all open FTP sites */


void CFtpSite::FlushHint(void)
{
    HINTERNET hint = m_hint;

    m_hint = NULL;
    if (hint)
    {
        // Our caller needs to be holding the critical section
        // while we modify m_hint
        ASSERTCRITICAL;

        InternetCloseHandle(hint);
//        DEBUG_CODE(g_dwOpenConnections--;);
    }
}


void CFtpSite::FlushHintCritial(void)
{
    ASSERTNONCRITICAL;

    ENTERCRITICAL;
    FlushHint();
    LEAVECRITICAL;
}


void CFtpSite::FlushHintCB(LPVOID pvFtpSite)
{
    CFtpSite * pfs = (CFtpSite *) pvFtpSite;

    if (pfs)
    {
        pfs->FlushHint();
        pfs->Release();
    }
}


/*****************************************************************************\
 *    An InternetConnect has just completed.  Get the motd and cache it.
 *
 *    hint - the connected handle, possibly 0 if error
\*****************************************************************************/
void CFtpSite::CollectMotd(HINTERNET hint)
{
    CFtpGlob * pfg = GetFtpResponse(&m_cwe);

    ENTERCRITICAL;
    m_fMotd = m_pfgMotd ? TRUE : FALSE;            // We have a motd

    IUnknown_Set(&m_pfgMotd, NULL);
    m_pfgMotd = pfg;

    LEAVECRITICAL;
}


/*****************************************************************************\
    FUNCTION: ReleaseHint

    DESCRIPTION:
        An FtpDir client is finished with a handle to the FTP site.
    Put it into the cache, and throw away what used to be there.

    We always keep the most recent handle, because that reduces the
    likelihood that the server will close the connection due to extended
    inactivity.

    The critical section around this entire procedure is important,
    else we open up all sorts of really ugly race conditions.  E.g.,
    the timeout might trigger before we're finished initializing it.
    Or somebody might ask for the handle before we're ready.
\*****************************************************************************/
void CFtpSite::ReleaseHint(LPCITEMIDLIST pidlFtpPath, HINTERNET hint)
{
    ENTERCRITICAL;

    TriggerDelayedAction(&m_hgti);    // Kick out the old one

    _SetPidl(pidlFtpPath);
    m_hint = hint;

    if (SUCCEEDED(SetDelayedAction(FlushHintCB, (LPVOID) this, &m_hgti)))
        AddRef();   // We just gave away a ref.
    else
        FlushHint();    // Oh well, can't cache it

    LEAVECRITICAL;
}


// NT #362108: We need to set the redirect password for the CFtpSite that
// contains the server, the user name, but a blank password to be redirected
// to the CFtpSite that does have the correct password.  This way, if a user
// logs in and doesn't save the password in the URL or the secure cache, we
// then put it in the in memory password cache so it stays valid for that
// "browser" session (defined by process lifetime).  We then need to redirect
// future navigations that go to that 
HRESULT CFtpSite::_SetRedirPassword(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlFtpPath, LPCTSTR pszFragment)
{
    TCHAR szUrl[MAX_URL_STRING];
    HRESULT hr;

    hr = UrlCreate(pszServer, pszUser, TEXT(""), TEXT(""), pszFragment, ipPortNum, NULL, szUrl, ARRAYSIZE(szUrl));
    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidlServer;

        hr = CreateFtpPidlFromUrl(szUrl, GetCWireEncoding(), NULL, &pidlServer, m_pm, TRUE);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = ILCombine(pidlServer, pidlFtpPath);

            if (pidl)
            {
                CFtpSite * pfsDest = NULL;

                // The user name has changed so we need to update the
                // CFtpSite with the new user name also.
                hr = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfsDest);
                if (SUCCEEDED(hr))
                {
                    pfsDest->SetRedirPassword(pszPassword);
                    pfsDest->Release();
                }

                ILFree(pidl);
            }

            ILFree(pidlServer);
        }
    }

    return hr;
}

HRESULT CFtpSite::_RedirectAndUpdate(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlFtpPath, LPCTSTR pszFragment, IUnknown * punkSite, CFtpFolder * pff)
{
    TCHAR szUrl[MAX_URL_STRING];
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    HRESULT hr;

    StrCpyN(szUser, pszUser, ARRAYSIZE(szUser));    // Copy because of possible reentrancy
    hr = UrlCreate(pszServer, szUser, pszPassword, TEXT(""), pszFragment, ipPortNum, NULL, szUrl, ARRAYSIZE(szUrl));
    if (EVAL(SUCCEEDED(hr) && pff))
    {
        LPITEMIDLIST pidlServer;

        hr = CreateFtpPidlFromUrl(szUrl, GetCWireEncoding(), NULL, &pidlServer, m_pm, TRUE);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = ILCombine(pidlServer, pidlFtpPath);

            if (pidl)
            {
                // If the user changed the password, we need to setup a redirect so
                // they can return later. (NT #362108)
                if (m_pszUser && !StrCmp(m_pszUser, szUser) && StrCmp(m_pszPassword, pszPassword))
                {
                    _SetRedirPassword(pszServer, ipPortNum, szUser, pszPassword, pidlFtpPath, pszFragment);
                }

                // If the user name changed, set a redirect.
                if (!m_pszUser || StrCmp(m_pszUser, szUser))
                {
                    CFtpSite * pfsDest = NULL;

                    // The user name has changed so we need to update the
                    // CFtpSite with the new user name also.
                    hr = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfsDest);
                    if (SUCCEEDED(hr))
                    {
                        pfsDest->SetRedirPassword(pszPassword);
                        pfsDest->Release();
                    }
                }

                hr = _Redirect(pidl, punkSite, pff);
                ILFree(pidl);
            }

            ILFree(pidlServer);
        }
    }

    return hr;
}


HRESULT CFtpSite::_Redirect(LPITEMIDLIST pidl, IUnknown * punkSite, CFtpFolder * pff)
{
    LPITEMIDLIST pidlFull = pff->CreateFullPublicPidl(pidl);
    HRESULT hr = E_INVALIDARG;

    if (pidlFull)
    {
        hr = IUnknown_PidlNavigate(punkSite, pidlFull, FALSE);

        ASSERT(SUCCEEDED(hr));
        ILFree(pidlFull);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetDirectory

    DESCRIPTION:
        When the caller wants a handle to the server, they often want a different
    directory than what's in the cache.  This function needs to change into
    the new directory.
\*****************************************************************************/
HRESULT CFtpSite::_SetDirectory(HINTERNET hint, HWND hwnd, LPCITEMIDLIST pidlNewDir, CStatusBar * psb, int * pnTriesLeft)
{
    HRESULT hr = S_OK;

    if (pidlNewDir && FtpID_IsServerItemID(pidlNewDir))
        pidlNewDir = _ILNext(pidlNewDir);   // Skip the server.

    ASSERT(m_pidl);
    // NT #300889: I would like to cache the dir but sometimes it gets
    //             out of wack and m_pidl doesn't match the HINTERNET's
    //             cwd.  PERF: This could be fixed in the future but
    //             this perf tweak isn't work the work now (small gain).
//  if (m_pidl && !FtpPidl_IsPathEqual(_ILNext(m_pidl), pidlNewDir))
    {
        LPITEMIDLIST pidlWithVirtualRoot = NULL;

        if (psb)
        {
            WCHAR wzDisplayPath[MAX_PATH];  // For Statusbar.
            
            if (pidlNewDir && SUCCEEDED(GetDisplayPathFromPidl(pidlNewDir, wzDisplayPath, ARRAYSIZE(wzDisplayPath), TRUE)))
                psb->SetStatusMessage(IDS_CHDIR, wzDisplayPath);
            else
                psb->SetStatusMessage(IDS_CHDIR, L"\\");
        }

        hr = PidlInsertVirtualRoot(pidlNewDir, &pidlWithVirtualRoot);
        if (SUCCEEDED(hr))
        {
            hr = FtpSetCurrentDirectoryPidlWrap(hint, TRUE, pidlWithVirtualRoot, TRUE, TRUE);
            if (SUCCEEDED(hr))  // Ok if failed. (No Access?)
            {
                hr = _SetPidl(pidlNewDir);
            }
            else
            {

                ReleaseHint(NULL, hint); // Nowhere
                if (hr == HRESULT_FROM_WIN32(ERROR_FTP_DROPPED))
                    FlushHintCritial(); // Don't cache dead hint
                else
                {
                    DisplayWininetError(hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_CHANGEDIR, IDS_FTPERR_WININET, MB_OK, NULL);
                    *pnTriesLeft = 0;   // Make sure we don't keep display UI.
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                hint = 0;
            }

            ILFree(pidlWithVirtualRoot);
        }

        if (psb)
            psb->SetStatusMessage(IDS_EMPTY, 0);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoginToTheServer

    DESCRIPTION:
        We want an HINTERNET to do some FTP operation but we don't have one
    cached.  So, login to create it.

    WARNING: This function will be called in a critical section and needs to 
             return in one.  However, it may leave the critical section for a
             while.
\*****************************************************************************/
HRESULT CFtpSite::_LoginToTheServer(HWND hwnd, HINTERNET hintDll, HINTERNET * phint, LPCITEMIDLIST pidlFtpPath, CStatusBar * psb, IUnknown * punkSite, CFtpFolder * pff)
{
    HRESULT hr = S_OK;

    ASSERTCRITICAL;
    BOOL fKeepTryingToLogin = FALSE;
    BOOL fTryOldPassword = TRUE;

    LEAVECRITICALNOASSERT;
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    StrCpyN(szUser, m_pszUser, ARRAYSIZE(szUser));
    StrCpyN(szPassword, m_pszPassword, ARRAYSIZE(szPassword));

    ASSERT(m_pszServer);
    if (psb)
        psb->SetStatusMessage(IDS_CONNECTING, m_pszServer);

    do
    {
        hr = InternetConnectWrap(hintDll, TRUE, HANDLE_NULLSTR(m_pszServer), m_ipPortNum, NULL_FOR_EMPTYSTR(szUser), NULL_FOR_EMPTYSTR(szPassword), INTERNET_SERVICE_FTP, 0, 0, phint);
        if (*phint)
            fKeepTryingToLogin = FALSE; // Move up.
        else
        {
            BOOL fSkipLoginDialog = FALSE;

            // Display Login dialog to get new user name/password to try again or cancel login.
            // fKeepTryingToLogin = TRUE if Dialog said [LOGIN].
            if (((ERROR_INTERNET_LOGIN_FAILURE == HRESULT_CODE(hr)) ||
                (ERROR_INTERNET_INCORRECT_USER_NAME == HRESULT_CODE(hr)) ||
                (ERROR_INTERNET_INCORRECT_PASSWORD == HRESULT_CODE(hr))) && hwnd)
            {
                BOOL fIsAnonymous = (!szUser[0] || !StrCmpI(szUser, TEXT("anonymous")) ? TRUE : FALSE);
                DWORD dwLoginFlags = (fIsAnonymous ? LOGINFLAGS_ANON_LOGINJUSTFAILED : LOGINFLAGS_USER_LOGINJUSTFAILED);

                if (fTryOldPassword)
                {
                    hr = m_cAccount.GetUserName(HANDLE_NULLSTR(m_pszServer), szUser, ARRAYSIZE(szUser));
                    if (S_OK == hr)
                    {
                        hr = m_cAccount.GetPassword(HANDLE_NULLSTR(m_pszServer), szUser, szPassword, ARRAYSIZE(szPassword));
                        if (S_OK == hr)
                        {
                            fKeepTryingToLogin = TRUE;
                            fSkipLoginDialog = TRUE;
                        }
                    }
                }
            
                if (!fSkipLoginDialog)
                {
                    // If the user tried to log in anonymously and failed, we want to try
                    // logging in with a password.  If the user tried logging in with a password
                    // and failed, we want to keep trying to log in with a password.
                    // 
                    // DisplayLoginDialog returns S_OK for OK pressed, S_FALSE for Cancel button, and
                    //       FAILED() for something is really messed up.
                    hr = m_cAccount.DisplayLoginDialog(hwnd, dwLoginFlags, HANDLE_NULLSTR(m_pszServer),
                                szUser, ARRAYSIZE(szUser), szPassword, ARRAYSIZE(szPassword));
                }

                // S_FALSE means the user cancelled out of the Login dialog.
                // We need to turn this into an error value so the caller,
                // CFtpDir::WithHint() won't call the callback.
                if (S_FALSE == hr)
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

                fKeepTryingToLogin = (SUCCEEDED(hr) ? TRUE : FALSE);
                if (fKeepTryingToLogin)
                {
                    // We need to set the cancelled error so we don't display the
                    // error message after this.
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                fTryOldPassword = FALSE;
            }
            else
                fKeepTryingToLogin = FALSE;
        }
    }
    while (fKeepTryingToLogin);

    if (!*phint)
    {
        ASSERT(2 != HRESULT_CODE(hr));        // error 2 = wininet not configured


#ifdef DEBUG
        // Gee, I wonder why I couldn't connect, let's find out.
        TCHAR szBuff[1500];
        InternetGetLastResponseInfoDisplayWrap(FALSE, NULL, szBuff, ARRAYSIZE(szBuff));
        // This may happen if the server has too many connections.  We may want to sniff
        // for this and offer to keep trying.  These are the response from the various
        // FTP Servers in this case:
        // IIS v5: 421 Too many people are connected.  Please come back when the server is less busy.
        // UNIX: ???
#endif // DEBUG
    }
    // Was a different login name or password needed in order to login successfully?
    else
    {
        LPITEMIDLIST pidlVirtualDir;

        CollectMotd(*phint);
        _QueryServerFeatures(*phint);
        // Ref Count the open connections.
//                  DEBUG_CODE(g_dwOpenConnections++;);

        // Is it a VMS Server?
        if (m_fIsServerVMS)
        {
            // Yes, so skip getting pidlVirtualDir because wininet gives us
            // garbage for FtpGetCurrentDirectoryA().
        }
        else
        {
            // NOTE: If the connection isn't annonymous, the server may put the user
            //   into a sub directory called a virtual root.  We need to squirel that
            //   directory away because it may be needed when going into sub directories
            //   relative to this virtual root.
            //     Example: ftp://user1:password@server/ puts you into /users/user1/
            //     Then: ftp://user1:password@server/dir1 really should be /users/user1/dir1/
            hr = FtpGetCurrentDirectoryPidlWrap(*phint, TRUE, GetCWireEncoding(), &pidlVirtualDir);
            if (SUCCEEDED(hr))
            {
                // Are we rooted at '/'? (Meaning no virtual root)
                Pidl_Set(&m_pidlVirtualDir, pidlVirtualDir);
                ILFree(pidlVirtualDir);
            }
        }

        //DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "CFtpSite::GetHint() FtpGetCurrentDirectory() returned %#08lx", hr));
        if (StrCmp(HANDLE_NULLSTR(m_pszUser), szUser) || StrCmp(HANDLE_NULLSTR(m_pszPassword), szPassword))
        {
            // Yes, so redirect so the AddressBand and User Status Bar pane update.
            // We normally log in with m_pidl because normally we login with
            // a default directory ('\') and then change directories to the final location.
            // we do this so isolate access denied to the server and access denied to the
            // directory.
            //
            // We pass pidlFtpPath instead in this case because it will tell the browser
            // to re-direct and we won't get a chance to do the ChangeDir later.

            Str_SetPtr(&m_pszRedirPassword, szPassword);

            _RedirectAndUpdate(m_pszServer, m_ipPortNum, szUser, szPassword, pidlFtpPath, m_pszFragment, punkSite, pff);
            hr = HRESULT_FROM_WIN32(ERROR_NETWORK_ACCESS_DENIED);
        }
    }

    // Can we assume annonymous logins don't use virtual roots?
    ASSERT(FAILED(hr) || (m_pidlVirtualDir && szUser[0]) || !(m_pidlVirtualDir && szUser[0]));

    if (psb)
        psb->SetStatusMessage(IDS_EMPTY, NULL);
    ENTERCRITICALNOASSERT;

    // The directory is empty.
    _SetPidl(NULL);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetHint

    DESCRIPTION:
        An IShellFolder client wants a handle to the FTP site.
    Pull it from the cache if possible.

    The caller should have marked the IShellFolder as busy.

    EEK!  RFC 1738 is really scary.  FTP sites don't necessarily
    start you at the root, and RFC1738 says that ftp://foo/bar asks
    for the file bar in the DEFAULT directory, not the root!
\*****************************************************************************/
HRESULT CFtpSite::GetHint(HWND hwnd, LPCITEMIDLIST pidlFtpPath, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CFtpFolder * pff)
{
    HINTERNET hint = NULL;
    HINTERNET hintDll = GetWininetSessionHandle();
    HRESULT hr = S_OK;

    if (!hintDll)
    {
        // No point in retrying if we can't init Wininet
        hr = HRESULT_FROM_WIN32(GetLastError());    // Save error code
    }
    else
    {
        int cTriesLeft = 1; // This is a feature that would be cool to implement.
        hr = AssureNetConnection(NULL, hwnd, m_pszServer, NULL, TRUE);

        if (ILIsEmpty(pidlFtpPath))
            pidlFtpPath = NULL;

        if (SUCCEEDED(hr))
        {
            // The CS is protecting m_hint.  First guy gets to remove and use the cached internet session.
            // subsequent callers need create new ones since internet sessions have state while in use. (Current dir, etc.)
            ASSERTNONCRITICAL;
            ENTERCRITICALNOASSERT;

            do
            {
                BOOL fReuseExistingConnection = FALSE;
                hr = E_FAIL;    // We don't have our hint yet...

                ASSERTCRITICAL;
                hint = (HINTERNET) InterlockedExchangePointer(&m_hint, 0);
                if (hint)
                {
                    HINTERNET hintResponse;

                    TriggerDelayedAction(&m_hgti);      // Nothing will happen
                    fReuseExistingConnection = TRUE;    // We will need to change it for the current user.

                    // We want (S_OK == hr) if our login session is still good.  Else, we want to
                    // re-login.
                    hr = FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, FTP_CMD_NO_OP, NULL, &hintResponse);
                    if (SUCCEEDED(hr))
                    {
                        TraceMsg(TF_FTPOPERATION, "CFtpSite::GetHint() We are going to use a cached HINTERNET.");
                        InternetCloseHandleWrap(hintResponse, TRUE);
                    }
                    else
                    {
                        TraceMsg(TF_FTPOPERATION, "CFtpSite::GetHint() Can't used cached HINTERNET because server didn't respond to NOOP.");
                        InternetCloseHandleWrap(hint, TRUE);
                    }
                }
                
                if (FAILED(hr))
                {
                    hr = _LoginToTheServer(hwnd, hintDll, &hint, pidlFtpPath, psb, punkSite, pff);
                    TraceMsg(TF_FTPOPERATION, "CFtpSite::GetHint() We had to login because we didn't have a cached HINTERNET.");
                }

                ASSERTCRITICAL;
                LEAVECRITICALNOASSERT;

                // Do we need to CD into a specific directory?  Yes, if...
                // 1. We succeeded above, AND
                // 2. We are already using a connection so the dir may be incorrect, OR
                // 3. We need a non-default dir.
                if (SUCCEEDED(hr) && (fReuseExistingConnection || pidlFtpPath))   // pidlFtpPath may be NULL.
                    hr = _SetDirectory(hint, hwnd, pidlFtpPath, psb, &cTriesLeft);

                ENTERCRITICALNOASSERT;
                ASSERTCRITICAL;
            }
            while (hr == HRESULT_FROM_WIN32(ERROR_FTP_DROPPED) && --cTriesLeft);

            LEAVECRITICALNOASSERT;
        }
    }

    *phint = hint;
    return hr;
}


HRESULT CFtpSite::_CheckToEnableCHMOD(LPCWIRESTR pwResponse)
{
    HRESULT hr = S_FALSE;
    // TODO: We should probably be more restictive in how we parse the
    //       response.  We should probably verify there is some kind of
    //       white space before and after the command.
    LPCWIRESTR pwCommand = StrStrIA(pwResponse, FTP_UNIXCMD_CHMODA);

    // Does this FTP server support the "SITE CHMOD" command?
    if (pwCommand)
    {
        // Yes, so we may want to use it later.
        m_fIsCHMODSupported = TRUE;

        // We can later respond with:
        // "SITE chmod xyz FileName.txt"
        // x is for Owner, (4=Read, 2=Write, 1=Execute)
        // y is for Owner, (4=Read, 2=Write, 1=Execute)
        // z is for Owner, (4=Read, 2=Write, 1=Execute)
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _QueryServerFeatures

    DESCRIPTION:
        Find out what the server is and isn't capable of.  Information we could
    use:
        SITE: Find out OS specific commands that may be useful.  "chmod" is one
              of them.
        HELP SITE: Find out what the OS supports.
        SYST: Find out the OS type.
        NOOP: See if the connection is still alive.
        MLST: Unambiguous Directory listing with dates in UTC.
        MLSD: 
        FEAT: Features supported. UTF8 is the one we care about. 

    Response to "SITE HELP" for these servers:
        UNIX Type: L8 Version: BSD-199506
        UNIX Type: L8
           UMASK   CHMOD   GROUP   NEWER   INDEX   ALIAS   GROUPS 
           IDLE    HELP    GPASS   MINFO   EXEC    CDPATH 

        Windows_NT version 4.0
           CKM DIRSTYLE HELP STATS    
\*****************************************************************************/
HRESULT CFtpSite::_QueryServerFeatures(HINTERNET hint)
{
    HRESULT hr = E_FAIL;
    HINTERNET hintResponse;

    // Can we turn on 'UTF8' encoding?
    if (SUCCEEDED(FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, FTP_CMD_UTF8, NULL, &hintResponse)))
    {
        m_fInUTF8Mode = TRUE;
        m_cwe.SetUTF8Support(TRUE);
        TraceMsg(TF_FTP_OTHER, "_QueryServerFeatures() in UTF8 Mode");

        InternetCloseHandleWrap(hintResponse, TRUE);
    }
    else
    {
        TraceMsg(TF_FTP_OTHER, "_QueryServerFeatures() NOT in UTF8 Mode");
        m_fInUTF8Mode = FALSE;
    }

    if (!m_fFeaturesQueried)
    {
        // Is type of server software is running?  We want to know if we are running
        // on VMS, because in that case we want to fall back to HTML view (URLMON).
        // This is because the wininet guys don't want to support it.
        if (SUCCEEDED(FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, FTP_CMD_SYSTEM, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                // Is this a VMS server?
                if (StrStrIA(wResponse, FTP_SYST_VMS))
                    m_fIsServerVMS = TRUE;

                TraceMsg(TF_FTP_OTHER, "_QueryServerFeatures() SYSTM returned %hs.", wResponse);
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }


#ifdef FEATURE_CHANGE_PERMISSIONS
        // Is the server capable of supporting the UNIX "chmod" command
        // to change permissions on the file?
        if (SUCCEEDED(FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, FTP_CMD_SITE_HELP, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                _CheckToEnableCHMOD(wResponse);
//                TraceMsg(TF_FTP_OTHER, "_QueryServerFeatures() SITE HELP returned success");
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }
#endif // FEATURE_CHANGE_PERMISSIONS

/*
        // Is the server capable of supporting the UNIX "chmod" command
        // to change permissions on the file?
        if (SUCCEEDED(FtpCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, FTP_CMD_SITE, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                TraceMsg(TF_FTP_OTHER, "_QueryServerFeatures() SITE returned succeess");
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }
*/
    
        m_fFeaturesQueried = TRUE;
    }

    return S_OK;    // This shouldn't fail.
}


LPITEMIDLIST CFtpSite::GetPidl(void)
{
    return ILClone(m_pidl);
}


/*****************************************************************************\
    FUNCTION: _SetPidl

    DESCRIPTION:
        m_pidl contains the ServerID and the ItemIDs making up the path of where
    m_hint is currently located.  This function will take a new path in pidlFtpPath
    and update m_pidl so it still has the server.
\*****************************************************************************/
HRESULT CFtpSite::_SetPidl(LPCITEMIDLIST pidlFtpPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlServer = FtpCloneServerID(m_pidl);

    if (pidlServer)
    {
        LPITEMIDLIST pidlNew = ILCombine(pidlServer, pidlFtpPath);

        if (pidlNew)
        {
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = S_OK;
        }

        ILFree(pidlServer);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: QueryMotd

    DESCRIPTION:
        Determine whether there is a motd at all.
\*****************************************************************************/
BOOL CFtpSite::QueryMotd(void)
{
    return m_fMotd;
}


HRESULT CFtpSite::GetVirtualRoot(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_FALSE;
    *ppidl = NULL;

    if (m_pidlVirtualDir)
    {
        *ppidl = ILClone(m_pidlVirtualDir);
        hr = S_OK;
    }

    return S_OK;
}


HRESULT CFtpSite::PidlInsertVirtualRoot(LPCITEMIDLIST pidlFtpPath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    *ppidl = NULL;
    if (!m_pidlVirtualDir)
        *ppidl = ILClone(pidlFtpPath);
    else
    {
        LPITEMIDLIST pidlTemp = NULL;

        if (pidlFtpPath && FtpID_IsServerItemID(pidlFtpPath))
        {
            pidlTemp = FtpCloneServerID(pidlFtpPath);
            pidlFtpPath = _ILNext(pidlFtpPath);
        }

        LPITEMIDLIST pidlWithVRoot = ILCombine(pidlTemp, m_pidlVirtualDir);
        if (pidlWithVRoot)
        {
            *ppidl = ILCombine(pidlWithVRoot, pidlFtpPath);
            ILFree(pidlWithVRoot);
        }
        
        ILFree(pidlTemp);
    }

    return S_OK;
}


BOOL CFtpSite::HasVirtualRoot(void)
{
    return (m_pidlVirtualDir ? TRUE : FALSE);
}


/*****************************************************************************\
      GetMotd
  
      Returns the HFGLOB that babysits the motd.  The refcount has been
      incremented.
\*****************************************************************************/
CFtpGlob * CFtpSite::GetMotd(void)
{
    if (m_pfgMotd)
        m_pfgMotd->AddRef();

    return m_pfgMotd;
}


/*****************************************************************************\
      GetCFtpList
  
      Return the CFtpList * that remembers which folders live in this CFtpSite *.
  
      WARNING!  The caller must own the critical section when calling
      this routine, because the returned CFtpList * is not refcounted!
\*****************************************************************************/
CFtpList * CFtpSite::GetCFtpList(void)
{
    return m_FtpDirList;
}


/*****************************************************************************\
      _CompareSites
  
      Callback during SiteCache_PrivSearch to see if the site is already in the
      list.
\*****************************************************************************/
int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvFtpSite, LPARAM lParam)
{
    CFtpSite * pfs = (CFtpSite *) pvFtpSite;
    LPCTSTR pszLookupStrNew = (LPCTSTR) pvStrSite;
    LPCTSTR pszLookupStr = (pfs->m_pszLookupStr ? pfs->m_pszLookupStr : TEXT(""));

    ASSERT(pszLookupStr && pszLookupStr);
    return StrCmpI(pszLookupStr, pszLookupStrNew);
}


/*****************************************************************************\
    FUNCTION: SiteCache_PrivSearch

    DESCRIPTION:
        We cache information about an FTP Server to prevent hitting the net all
    the time.  This state is stored in CFtpSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CFtpSite object, we need to have one per
    user/password combo.
\*****************************************************************************/
HRESULT SiteCache_PrivSearch(LPCTSTR pszLookup, LPCITEMIDLIST pidl, IMalloc * pm, CFtpSite ** ppfs)
{
    CFtpSite * pfs = NULL;
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    // CFtpSite_Init() can fail in low memory
    if (SUCCEEDED(CFtpSite_Init()))
    {
        pfs = (CFtpSite *) g_FtpSiteCache->Find(_CompareSites, (LPVOID)pszLookup);   // Add CFtpSite:: ?
        if (!pfs)
        {
            //  We need to hold the critical section while setting up
            //  the new CFtpSite structure, lest somebody else come in
            //  and try to create the same CFtpSite while we are busy.
            hr = CFtpSite_Create(pidl, pszLookup, pm, &pfs);
            if (SUCCEEDED(hr))
            {
                hr = g_FtpSiteCache->AppendItem(pfs);
                if (!(SUCCEEDED(hr)))
                    IUnknown_Set(&pfs, NULL);
            }
        }
    }

    *ppfs = pfs;
    if (pfs)
        pfs->AddRef();
    LEAVECRITICAL;

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}



/*****************************************************************************\
    FUNCTION: SiteCache_PidlLookupPrivHelper

    DESCRIPTION:
        We cache information about an FTP Server to prevent hitting the net all
    the time.  This state is stored in CFtpSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CFtpSite object, we need to have one per
    user/password combo.
    
        SiteCache_PidlLookup() does the high level work of deciding if we want
    to do a password redirect.  This function just wraps the creating of the
    lookup string and the fetching of the site.
\*****************************************************************************/
HRESULT SiteCache_PidlLookupPrivHelper(LPCITEMIDLIST pidl, IMalloc * pm, CFtpSite ** ppfs)
{
    HRESULT hr = E_FAIL;
    TCHAR szLookup[MAX_PATH];

    *ppfs = NULL;
    hr = PidlGenerateSiteLookupStr(pidl, szLookup, ARRAYSIZE(szLookup));
    // May fail w/Outofmemory

    if (SUCCEEDED(hr))
        hr = SiteCache_PrivSearch((pidl ? szLookup : TEXT('\0')), pidl, pm, ppfs);

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: SiteCache_PidlLookupPrivHelper

    DESCRIPTION:
        We cache information about an FTP Server to prevent hitting the net all
    the time.  This state is stored in CFtpSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CFtpSite object, we need to have one per
    user/password combo.
\*****************************************************************************/
HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CFtpSite ** ppfs)
{
    HRESULT hr = E_FAIL;

    if (pidl && !ILIsEmpty(pidl))
    {
        hr = SiteCache_PidlLookupPrivHelper(pidl, pm, ppfs);

        // Okay, we found a site but we may need to redirect to another site
        // because the password is wrong.  This happens if a user goes to
        // ServerA w/UserA and PasswordA but PasswordA is invalid.  So,
        // PasswordB is entered and the navigation completes successfully.
        // Now either the navigation occurs again with PasswordA or w/o
        // a password (because the addrbar removes it), then we need to
        // look it up again and get it.
        if (SUCCEEDED(hr) && (*ppfs)->m_pszRedirPassword && fPasswordRedir)
        {
            LPITEMIDLIST pidlNew;   // with new (redirected) password

            if (FtpPidl_IsAnonymous(pidl))
            {
                pidlNew = ILClone(pidl);
                if (!pidlNew)
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // We need to redirect to get that CFtpSite.
                hr = PidlReplaceUserPassword(pidl, &pidlNew, pm, NULL, (*ppfs)->m_pszRedirPassword);
            }

            (*ppfs)->Release();
            *ppfs = NULL;
            if (SUCCEEDED(hr))
            {
                hr = SiteCache_PidlLookupPrivHelper(pidlNew, pm, ppfs);
                ILFree(pidlNew);
            }
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: UpdateHiddenPassword

     DESCRIPTION:
        Since our IShellFolder::GetDisplayNameOf() will hide the password in some
     cases, we need to 'patch' display names that come thru our
     IShellFolder::GetDisplayName().  If a display name is coming in, we will
     see if the CFtpSite has a m_pszRedirPassword.  If it did, then the user entered
     a password via the 'Login As...' dialog in place of the empty password,
     which made it hidden.  If this is the case, we then have IShellFolder::ParseDisplayName()
     patch back in the password.
\*****************************************************************************/
HRESULT CFtpSite::UpdateHiddenPassword(LPITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    // Is it a candidate to a password to be inserted?
    if (m_pszPassword && 
        EVAL(SUCCEEDED(FtpPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName)))) &&
        szUserName[0] &&
        SUCCEEDED(FtpPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), TRUE)) &&
        !szPassword[0]) 
    {
        // Yes...
        hr = FtpServerID_SetHiddenPassword(pidl, m_pszPassword);
    }

    return hr;
}


/*****************************************************************************\
     CFtpSite::GetFtpDir
\*****************************************************************************/
HRESULT CFtpSite::GetFtpDir(LPCTSTR pszServer, LPCWSTR pszUrlPath, CFtpDir ** ppfd)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    *ppfd = NULL;
    hr = UrlCreate(pszServer, NULL, NULL, pszUrlPath, NULL, INTERNET_DEFAULT_FTP_PORT, NULL, szUrl, ARRAYSIZE(szUrl));  // Cannot fail on valid URLs.
    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidl;

        // We know this is a path.
        hr = CreateFtpPidlFromUrlEx(szUrl, GetCWireEncoding(), NULL, &pidl, m_pm, FALSE, TRUE, TRUE);       // Can fail in out of memory
        if (SUCCEEDED(hr))
        {
            hr = GetFtpDir(pidl, ppfd);
            ILFree(pidl);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFtpDir

    DESCRIPTION:
        Obtain the FtpDir structure for an FTP site, creating one if
    necessary.  It is the caller's responsibility to Release the
    FtpDir when finished.
\*****************************************************************************/
HRESULT CFtpSite::GetFtpDir(LPCITEMIDLIST pidl, CFtpDir ** ppfd)
{
    HRESULT hr = S_OK;
    CFtpDir * pfd = NULL;

    ENTERCRITICAL;
    ASSERT(ppfd && m_FtpDirList);

    pfd = (CFtpDir *) m_FtpDirList->Find(_CompareDirs, (LPVOID) pidl);
    if (!pfd)
    {
        // We need to hold the critical section while setting up
        // the new FtpDir structure, lest somebody else come in
        // and try to create the same FtpDir while we are busy.
        hr = CFtpDir_Create(this, pidl, &pfd);
        if (SUCCEEDED(hr))
        {
            // NOTE: REF-COUNTING
            //      Note that CFtpDir has a pointer (m_pfs) to a CFtpSite.
            //      We just added a back pointer in CFtpSite's list of CFtpDir(s),
            //      so it's necessary for that back pointer to not have a ref.
            //      This will not be a problem because the back pointers will
            //      always be valid because: 1) CFtpDir's destructor removes the backpointer,
            //      and 2) CFtpDir holds a ref on CFtpSite, so it won't go away until
            //      all the CFtpDir(s) are good and ready.  -BryanSt
            hr = m_FtpDirList->AppendItem(pfd);
            if (FAILED(hr))
                IUnknown_Set(&pfd, NULL);
        }
    }
    LEAVECRITICAL;

    *ppfd = pfd;
    if (pfd)
        pfd->AddRef();

    return hr;
}


/*****************************************************************************\
    FUNCTION: FlushSubDirs

    DESCRIPTION:
        Every subdir of pidl is no longer valid so flush them.  This is done
    because the parent dir may have changed names so they are invalid.

    PARAMETERS:
        pidl: Path of ItemIDs (no-ServerID) that includes the full path w/o
              the virtual root.  This matches CFtpDir::m_pidlFtpDir
\*****************************************************************************/
HRESULT CFtpSite::FlushSubDirs(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    CFtpDir * pfd = NULL;
    int nIndex;

    ENTERCRITICAL;

    // Count down so deleting items won't mess up the indicies.
    for (nIndex = (m_FtpDirList->GetCount() - 1); nIndex >= 0; nIndex--)
    {
        pfd = (CFtpDir *) m_FtpDirList->GetItemPtr(nIndex);
        if (pfd)
        {
            // Is this a child?
            if (FtpItemID_IsParent(pidl, pfd->GetPathPidlReference()))
            {
                // Yes, pfd is a child of pidl so delete it.
                m_FtpDirList->DeletePtrByIndex(nIndex);
                pfd->Release();
            }
        }
    }
    LEAVECRITICAL;

    return hr;
}


BOOL CFtpSite::IsSiteBlockedByRatings(HWND hwndDialogOwner)
{
    if (!m_fRatingsChecked)
    {
        void * pvRatingDetails = NULL;
        TCHAR szUrl[MAX_URL_STRING];
        CHAR szUrlAnsi[MAX_URL_STRING];
        HRESULT hr = S_OK;  // Assume allowed (in case no ratings)

        EVAL(SUCCEEDED(UrlCreateFromPidlW(m_pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), FALSE)));
        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));

        if (IS_RATINGS_ENABLED())
        {
            // S_OK - Allowed, S_FALSE - Not Allowed, FAILED() - not rated.
            hr = RatingCheckUserAccess(NULL, szUrlAnsi, NULL, NULL, 0, &pvRatingDetails);
            if (S_OK != hr)    // Does user want to override with parent password in dialog?
                hr = RatingAccessDeniedDialog2(hwndDialogOwner, NULL, pvRatingDetails);

            if (pvRatingDetails)
                RatingFreeDetails(pvRatingDetails);
        }

        if (S_OK == hr)     // It's off by default.
            m_fRatingsAllow = TRUE;

        m_fRatingsChecked = TRUE;
    }

    return !m_fRatingsAllow;
}


/*****************************************************************************\
      CFtpSite_Init
  
      Initialize the global list of FTP sites.
  
      Note that the DLL refcount is decremented after this is created,
      so that this internal list doesn't prevent us from unloading.
\*****************************************************************************/
HRESULT CFtpSite_Init(void)
{
    HRESULT hr = S_OK;

    if (!g_FtpSiteCache)
        hr = CFtpList_Create(10, NULL, 10, &g_FtpSiteCache);

    return hr;
}


/*****************************************************************************\
      FtpSitePurge_CallBack
  
      Purge the global list of FTP sites.
\*****************************************************************************/
int FtpSitePurge_CallBack(LPVOID pvPunk, LPVOID pv)
{
    IUnknown * punk = (IUnknown *) pvPunk;

    if (punk)
        punk->Release();

    return 1;
}


/*****************************************************************************\
      CFtpPunkList_Purge
  
      Purge the global list of FTP sites.
\*****************************************************************************/
HRESULT CFtpPunkList_Purge(CFtpList ** pfl)
{
    TraceMsg(TF_FTP_DLLLOADING, "CFtpPunkList_Purge() Purging our cache.");
    if (*pfl)
    {
        (*pfl)->Enum(FtpSitePurge_CallBack, NULL);
        IUnknown_Set(pfl, NULL);
    }

    return S_OK;
}


/*****************************************************************************\
      CFtpSite_Create
  
      Create a brand new CFtpSite given a name.
\*****************************************************************************/
HRESULT CFtpSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CFtpSite ** ppfs)
{
    CFtpSite * pfs = new CFtpSite();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pidl && pszLookupStr && ppfs);
    *ppfs = NULL;
    if (pfs)
    {
        Str_SetPtr(&pfs->m_pszLookupStr, pszLookupStr);

        IUnknown_Set((IUnknown **) &(pfs->m_pm), pm);
        hr = CFtpList_Create(10, NULL, 10, &pfs->m_FtpDirList);
        if (SUCCEEDED(hr))
        {
            // Did someone give us an empty URL?
            if (EVAL(pidl) && EVAL(FtpPidl_IsValid(pidl)))
            {
                TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
                TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
                TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
                TCHAR szFragment[INTERNET_MAX_PASSWORD_LENGTH];

                EVAL(SUCCEEDED(FtpPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer))));
                Str_SetPtr(&pfs->m_pszServer, szServer);

                Pidl_Set(&pfs->m_pidl, pidl);

                EVAL(SUCCEEDED(FtpPidl_GetUserName(pidl, szUser, ARRAYSIZE(szUser))));
                Str_SetPtr(&pfs->m_pszUser, szUser);
                
                if (FAILED(FtpPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), TRUE)))
                {
                       // Password expired
                    szPassword[0] = 0;
                }

                Str_SetPtr(&pfs->m_pszPassword, szPassword);
                FtpPidl_GetFragment(pidl, szFragment, ARRAYSIZE(szFragment));
                Str_SetPtr(&pfs->m_pszFragment, szFragment);

                pfs->m_ipPortNum = FtpPidl_GetPortNum(pidl);

                switch (FtpPidl_GetDownloadType(pidl))
                {
                case FTP_TRANSFER_TYPE_UNKNOWN:
                    pfs->m_fDLTypeSpecified = FALSE;
                    pfs->m_fASCIIDownload = FALSE;
                    break;
                case FTP_TRANSFER_TYPE_ASCII:
                    pfs->m_fDLTypeSpecified = TRUE;
                    pfs->m_fASCIIDownload = TRUE;
                    break;
                case FTP_TRANSFER_TYPE_BINARY:
                    pfs->m_fDLTypeSpecified = TRUE;
                    pfs->m_fASCIIDownload = FALSE;
                    break;
                default:
                    ASSERT(0);
                }
            }
            else
            {
                Str_SetPtr(&pfs->m_pszServer, NULL);
                Str_SetPtr(&pfs->m_pszUser, NULL);
                Str_SetPtr(&pfs->m_pszPassword, NULL);
                Str_SetPtr(&pfs->m_pszFragment, NULL);

                Pidl_Set(&pfs->m_pidl, NULL);
                pfs->m_fDLTypeSpecified = FALSE;
            }
            *ppfs = pfs;
        }
        else
        {
            hr = E_FAIL;
            pfs->Release();
        }
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpSite::CFtpSite() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pszServer);
    ASSERT(!m_pidl);
    ASSERT(!m_pszUser);
    ASSERT(!m_pszPassword);
    ASSERT(!m_pszFragment);
    ASSERT(!m_pszLookupStr);
    ASSERT(!m_pidlVirtualDir);

    ASSERT(!m_fMotd);
    ASSERT(!m_hint);
    ASSERT(!m_hgti);
    ASSERT(!m_FtpDirList);
    ASSERT(!m_fRatingsChecked);
    ASSERT(!m_fRatingsAllow);

    LEAK_ADDREF(LEAK_CFtpSite);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpSite::~CFtpSite()
{
    FlushHint();        // Frees m_hgti

    Str_SetPtr(&m_pszServer, NULL);
    Str_SetPtr(&m_pszUser, NULL);
    Str_SetPtr(&m_pszPassword, NULL);
    Str_SetPtr(&m_pszFragment, NULL);
    Str_SetPtr(&m_pszLookupStr, NULL);
    Str_SetPtr(&m_pszRedirPassword, NULL);

    Pidl_Set(&m_pidlVirtualDir, NULL);
    Pidl_Set(&m_pidl, NULL);

    IUnknown_Set(&m_pfgMotd, NULL);

    ASSERTCRITICAL;

    CFtpPunkList_Purge(&m_FtpDirList);

    TriggerDelayedAction(&m_hgti);    // Out goes the cached handle
    ASSERT(m_hint == 0);        // Make sure he's gone
    ATOMICRELEASE(m_pm);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpSite);
}


//===========================
// *** IUnknown Interface ***
ULONG CFtpSite::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpSite::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CFtpSite::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpSite::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpresp.cpp ===
/*****************************************************************************
 *
 *    ftpresp.cpp - Parsing FTP responses
 *
 *****************************************************************************/

#include "priv.h"


/*****************************************************************************\
    FUNCTION: FindEndOfStrOrLine

    DESCRIPTION:
        Find the end of the line ('\n') or the end of the string ('\0').
\*****************************************************************************/
LPWIRESTR FindEndOfStrOrLine(LPWIRESTR pszString)
{
    while (*pszString != '\0')
    {
        if (('\n' == pszString[0]))
        {
            while (('\n' == pszString[0]))
               pszString++;

            break;
        }
        pszString++;
    }

    return pszString;
}


/*****************************************************************************\
    FUNCTION: FindFirstMajorResponse

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR FindFirstMajorResponse(LPWIRESTR pszResponse)
{
    while ((pszResponse[0]) && ('-' != pszResponse[3]))
        pszResponse = FindEndOfStrOrLine(pszResponse);

    return pszResponse;
}


/*****************************************************************************\
    FUNCTION: GetNextResponseSection

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR GetNextResponseSection(LPWIRESTR pszCompleteResponse, LPWIRESTR * ppszResponseStart)
{
    LPWIRESTR pszNextResponse = NULL;

    // There may be a few minor responses.  Skip over them...
    pszCompleteResponse = FindFirstMajorResponse(pszCompleteResponse);

    // Were we never able to fine a major response?
    if (!pszCompleteResponse[0])
        return NULL;    // No, so return failure.

    // We are off to find the next major response.
    //    We should be looking at a response code.
    ASSERT('-' == pszCompleteResponse[3]);

    // Slop saves us here
    //    Extended response.  Copy until we see the match.
    //  As we copy, we also clean up the lines, removing
    //  the random punctuation servers prepend to continuations.
    //
    //  wu-ftp prepends the extended response code to each line:
    //
    //  230-Welcome to ftp.foo.com.  Please read the rules
    //  230-and regulations in the file RULES.
    //  230 Guest login ok, access restrictions apply.
    //
    //  Microsoft Internet Information Server prepends a space:
    //
    //  230-This is ftp.microsoft.com.  See the index.txt file
    //   in the root directory for more information.
    //  230 Anonymous user logged in as anonymous.
    //
    WIRECHAR szResponseNumber[5];            // example: "230-"
    WIRECHAR szResponseEnd[5];                // example: "230 "
    StrCpyNA(szResponseNumber, pszCompleteResponse, ARRAYSIZE(szResponseNumber));
    ASSERT(4 == lstrlenA(szResponseNumber));
    StrCpyNA(szResponseEnd, szResponseNumber, ARRAYSIZE(szResponseEnd));
    szResponseEnd[3] = ' ';

    pszNextResponse = pszCompleteResponse;
    *ppszResponseStart = pszCompleteResponse;
    do
    {
        //  Skip past the header.
        if (!StrCmpNA(szResponseNumber, pszNextResponse, 4))
            pszNextResponse += 4;    // wu-ftp
        else if ((pszNextResponse[0] == ' ') && (!StrCmpNA(szResponseNumber, &pszNextResponse[1], 4)))
            pszNextResponse += 5;    // ftp.microsoft.com
        else if (pszNextResponse[0] == ' ')
            pszNextResponse++;    // IIS

        //  Skip the rest of the line.
        pszNextResponse = FindEndOfStrOrLine(pszNextResponse);
    }
    while (pszNextResponse[0] && StrCmpNA(pszNextResponse, szResponseEnd, 4));
        /* Now gobble the trailer */

    if ('\0' == pszNextResponse[0])
        pszNextResponse = NULL;     // We are at the end.

    return pszNextResponse;
}


/*****************************************************************************\
    FUNCTION: StripResponseHeaders

    DESCRIPTION:
\*****************************************************************************/
void StripResponseHeaders(LPWIRESTR pszResponse)
{
    //    We should be looking at a response code.
    if ((3 < lstrlenA(pszResponse)) && (pszResponse[3] == '-'))
    {
        LPWIRESTR pszIterator = pszResponse;
        WIRECHAR szResponseNumber[5];            // example: "230-"
        WIRECHAR szResponseEnd[5];                // example: "230 "
        BOOL fFirstPass = TRUE;

        StrCpyNA(szResponseNumber, pszResponse, ARRAYSIZE(szResponseNumber));
        ASSERT(4 == lstrlenA(szResponseNumber));
        StrCpyNA(szResponseEnd, szResponseNumber, ARRAYSIZE(szResponseEnd));
        szResponseEnd[3] = ' ';

        do
        {
            //  Skip past the header.
            if (!StrCmpNA(szResponseNumber, pszIterator, 4))
                RemoveCharsFromStringA(pszIterator, 3);    // wu-ftp
            else if ((pszIterator[0] == ' ') && (!StrCmpNA(szResponseNumber, &pszIterator[1], 4)))
                RemoveCharsFromStringA(pszIterator, 4);    // ftp.microsoft.com
            else if (pszIterator[0] == ' ')
                NULL;    // IIS

            if (fFirstPass)
            {
                fFirstPass = FALSE;
                RemoveCharsFromStringA(pszIterator, 1);    // IIS
            }
            else
                pszIterator[0] = ' ';    // Make that new line a space.

            //  Skip the rest of the line.
            pszIterator = FindEndOfStrOrLine(pszIterator);
        }
        while (pszIterator[0] && StrCmpNA(pszIterator, szResponseEnd, 4));
        
        RemoveCharsFromStringA(pszIterator, 4);         // Now gobble the trailer
    }
}


/*****************************************************************************\
    FUNCTION: GetMOTDMessage

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR GetMOTDMessage(LPWIRESTR pwResponse, DWORD cchResponse)
{
    LPWIRESTR pszMOTD = NULL;
    LPWIRESTR pszLast = &pwResponse[lstrlenA(pwResponse)];
    LPWIRESTR pszNext = pwResponse;
    LPWIRESTR pszEnd = NULL;

    while (pszNext = GetNextResponseSection(pszNext, &pszLast))
    {
        pszEnd = pszNext;
    }

    if (pszEnd)
        pszEnd[0] = '\0';   // Terminate it so we don't get the minor responses after our response.
    
    DWORD cchSize = (lstrlenA(pszLast) + 1);
    pszMOTD = (LPWIRESTR) GlobalAlloc(GPTR, cchSize * sizeof(WIRECHAR));
    if (pszMOTD)
    {
        StrCpyNA(pszMOTD, pszLast, cchSize);
        StripResponseHeaders(pszMOTD);
    }

    return pszMOTD;
}


/*****************************************************************************\
    FUNCTION: GetFtpResponse

    DESCRIPTION:
        Get the MOTD from the Response
\*****************************************************************************/
CFtpGlob * GetFtpResponse(CWireEncoding * pwe)
{
    CFtpGlob * pfg = NULL;
    DWORD cchResponse = 0;
    LPWIRESTR pwWireResponse;
    DWORD dwError;

    InternetGetLastResponseInfoWrap(TRUE, &dwError, NULL, &cchResponse);
    cchResponse++;                /* +1 for the terminating 0 */

    pwWireResponse = (LPWIRESTR)LocalAlloc(LPTR, cchResponse * sizeof(WIRECHAR));
    if (pwWireResponse)
    {
        if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, pwWireResponse, &cchResponse)))
        {
            LPWIRESTR pwMOTD = GetMOTDMessage(pwWireResponse, cchResponse);
            if (pwMOTD)
            {
                LPWSTR pwzDisplayMOTD;
                DWORD cchSize = (lstrlenA(pwMOTD) + 1);

                pwzDisplayMOTD = (LPWSTR)GlobalAlloc(LPTR, cchSize * sizeof(WCHAR));
                if (pwzDisplayMOTD)
                {
                    pwe->WireBytesToUnicode(NULL, pwMOTD, WIREENC_IMPROVE_ACCURACY, pwzDisplayMOTD, cchSize);

                    pfg = CFtpGlob_CreateStr(pwzDisplayMOTD);
                    if (!(pfg))
                        GlobalFree(pwzDisplayMOTD);    // Couldn't track message
                }

                GlobalFree(pwMOTD);
            }
        }
        LocalFree(pwWireResponse);
    }

    return pfg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpurl.cpp ===
/*****************************************************************************
 *
 *    ftpurl.cpp - Creating, encoding, and decoding URLs
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpurl.h"



///////////////////////////////////////////////////////////////////////
// URL Path Functions (Obsolete?)
///////////////////////////////////////////////////////////////////////

/*****************************************************************************\
    FUNCTION: UrlGetPath

    DESCRIPTION:
        pszUrlPath will NOT include the fragment if there is any.
\*****************************************************************************/
HRESULT UrlGetDifference(LPCTSTR pszBaseUrl, LPCTSTR pszSuperUrl, LPTSTR pszPathDiff, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    pszPathDiff[0] = TEXT('\0');
    if ((lstrlen(pszBaseUrl) <= lstrlen(pszSuperUrl)) &&
        !StrCmpN(pszBaseUrl, pszSuperUrl, lstrlen(pszBaseUrl) - 1))
    {
        LPTSTR pszDelta = (LPTSTR) &pszSuperUrl[lstrlen(pszBaseUrl)];

        if (TEXT('/') == pszDelta[0])
            pszDelta = CharNext(pszDelta);  // Skip past this.
        
        StrCpyN(pszPathDiff, pszDelta, cchSize);
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlGetPath

    DESCRIPTION:
        pszUrlPath will NOT include the fragment if there is any.
\*****************************************************************************/
HRESULT UrlPathToFilePath(LPCTSTR pszSourceUrlPath, LPTSTR pszDestFilePath, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;
    LPTSTR pszSeparator;

    // Is the source and destination the differnt?
    if (pszSourceUrlPath != pszDestFilePath)
    {
        // Yes, so we need to fill the dest before we start modifying it.
        StrCpyN(pszDestFilePath, pszSourceUrlPath, cchSize);
    }

    while (pszSeparator = StrChr(pszDestFilePath, TEXT('/')))
        pszSeparator[0] = TEXT('\\');

    // Some people use "Test%20File.txt" when "%20" is really in the file name.
//    ASSERT(!StrChr(pszDestFilePath, TEXT('%'))); // Assert it doesn't contain '%' or it probably has escaped url stuff.
    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveSlashW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveSlashW(LPWSTR pszUrlPath)
{
    LPWSTR pszEndOfPath = &pszUrlPath[lstrlenW(pszUrlPath) - 1];

    // Is it missing a backslash?
    if ((pszEndOfPath >= pszUrlPath) && (CH_URL_URL_SLASHW == pszEndOfPath[0]))
        pszEndOfPath[0] = 0;    // Yes, so remove it.

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveSlashA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveSlashA(LPSTR pszUrlPath)
{
    LPSTR pszEndOfPath = &pszUrlPath[lstrlenA(pszUrlPath) - 1];

    // Is it missing a backslash?
    if ((pszEndOfPath >= pszUrlPath) && (CH_URL_URL_SLASHA == pszEndOfPath[0]))
        pszEndOfPath[0] = 0;    // Yes, so remove it.

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveFrontSlashW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveFrontSlashW(LPWSTR pszUrlPath)
{
    if (pszUrlPath && (CH_URL_URL_SLASHW == pszUrlPath[0]))
        return CharReplaceWithStrW(pszUrlPath, lstrlen(pszUrlPath), 1, SZ_EMPTYW);
    else
        return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveFrontSlashA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveFrontSlashA(LPSTR pszUrlPath)
{
    if (pszUrlPath && (CH_URL_URL_SLASHA == pszUrlPath[0]))
        return CharReplaceWithStrA(pszUrlPath, lstrlenA(pszUrlPath), 1, SZ_EMPTYA);
    else
        return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathToFilePathW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathToFilePathW(LPWSTR pszPath)
{
    while (pszPath = StrChrW(pszPath, CH_URL_URL_SLASHW))
        pszPath[0] = CH_URL_SLASHW;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathToFilePathA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathToFilePathA(LPSTR pszPath)
{
    while (pszPath = StrChrA(pszPath, CH_URL_URL_SLASHA))
        pszPath[0] = CH_URL_SLASHA;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: FilePathToUrlPathW

    DESCRIPTION:
\*****************************************************************************/
HRESULT FilePathToUrlPathW(LPWSTR pszPath)
{
    while (pszPath = StrChrW(pszPath, CH_URL_SLASHW))
        pszPath[0] = CH_URL_URL_SLASHW;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: FilePathToUrlPathA

    DESCRIPTION:
\*****************************************************************************/
HRESULT FilePathToUrlPathA(LPSTR pszPath)
{
    while (pszPath = StrChrA(pszPath, CH_URL_SLASHA))
        pszPath[0] = CH_URL_URL_SLASHA;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT UrlPathAdd(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment)
{
    // If the segment starts with a slash, skip it.
    if (TEXT('/') == pszSegment[0])
        pszSegment = CharNext(pszSegment);

    StrCatBuff(pszUrl, pszSegment, cchUrlSize);

    return S_OK;
}


/*****************************************************************************\
     StrRetFromFtpPidl
\*****************************************************************************/
HRESULT StrRetFromFtpPidl(LPSTRRET pStrRet, DWORD shgno, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    szUrl[0] = 0;
    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE | ICU_USERNAME, TRUE);
    if (SUCCEEDED(hr))
    {
        // Will it fit into STRRET.cStr?
        if (lstrlen(szUrl) < ARRAYSIZE(pStrRet->cStr))
        {
            // Yes, so there it goes...
            pStrRet->uType = STRRET_CSTR;
            SHTCharToAnsi(szUrl, pStrRet->cStr, ARRAYSIZE(pStrRet->cStr));
        }
        else
        {
            // No, so we will need to allocate it
            LPWSTR pwzAllocedStr = NULL;
            UINT cch = lstrlen(szUrl) + 1;

            pwzAllocedStr = (LPWSTR) SHAlloc(CbFromCchW(cch));
            pStrRet->uType = STRRET_WSTR;
            pStrRet->pOleStr = pwzAllocedStr;
            if (pwzAllocedStr)
                SHTCharToUnicode(szUrl, pwzAllocedStr, cch);
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetLastSegment

    DESCRIPTION:
\*****************************************************************************/
LPTSTR GetLastSegment(LPCTSTR pszUrl)
{
    LPTSTR pszLastSeg = (LPTSTR) pszUrl;
    LPTSTR pszNextPossibleSeg;

    while (pszNextPossibleSeg = StrChr(pszLastSeg, TEXT('/')))
    {
        if (TEXT('\0') != CharNext(pszNextPossibleSeg))
            pszLastSeg = CharNext(pszNextPossibleSeg);
        else
            break;  // We are done.
    }

    if (TEXT('/') == pszLastSeg[0])
        pszLastSeg = CharNext(pszLastSeg);

    return pszLastSeg;
}


/*****************************************************************************\
    FUNCTION: UrlRemoveDownloadType

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlRemoveDownloadType(LPTSTR pszUrlPath, BOOL * pfTypeSpecified, BOOL * pfType)
{
    HRESULT hr = S_FALSE;   // Specified? (Not yet)
    LPTSTR pszDownloadType;

    if (pfTypeSpecified)
        *pfTypeSpecified = TRUE;

    // Did the user specify a download type. szPath="Dir1/Dir2/file.txt;type=a".
    // TODO: Search Recursively because each segment in the path can have a 
    //       type.
    //       Example Url="ftp://server/Dir1;type=a/Dir2;type=a/File.txt;type=b
    if (pszDownloadType = StrStrI(pszUrlPath, SZ_FTP_URL_TYPE))
    {
        TCHAR chType;

        if (pfTypeSpecified)
            *pfTypeSpecified = TRUE;

        pszDownloadType[0] = TEXT('\0');   // Terminate pszUrlPath and remove this junk.
        chType = pszDownloadType[ARRAYSIZE(SZ_FTP_URL_TYPE) - 1];

        if (pfType)
        {
            if ((TEXT('a') == chType) || (TEXT('A') == chType))
                *pfType = TRUE;
            else
                *pfType = TRUE;
        }

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IsIPAddressStr

    DESCRIPTION:
    This function exists to detect an IP Address server name ("124.42.3.53") vs.
    a DNS domain name ("foobar", or "ftp.foobar.com").  I current accept more than
    4 segments because of 6-bit IP address.

    TODO: To be thurough, I should probably made sure each segment is
          smaller than 256.
\*****************************************************************************/
BOOL IsIPAddressStr(LPTSTR pszServer)
{
    BOOL fIsIPAddressStr = TRUE;
    LPTSTR pszCurrentChar = pszServer;
    int nDigits = 0;
    int nSegments = 1;

    while (fIsIPAddressStr && pszCurrentChar[0])
    {
        if (TEXT('.') == pszCurrentChar[0])
        {
            nSegments++;
            if ((0 == nDigits) || (4 < nDigits))
                fIsIPAddressStr = FALSE;    // it started with a '.', ie, ".xxxxx"

            nDigits = 0;
        }

        nDigits++;
        if (nDigits > 4)
            fIsIPAddressStr = FALSE;    // To many digits, ie "12345.xxxx"

        if (((TEXT('0') > pszCurrentChar[0]) || (TEXT('9') < pszCurrentChar[0])) &&
            (TEXT('.') != pszCurrentChar[0]))
        {
            fIsIPAddressStr = FALSE;    // it's outside of the 0-9 range.
        }

        pszCurrentChar++;   // Next character.
    }

    if (nSegments != 4)
        fIsIPAddressStr = FALSE;    // Needs to have at least 4 segments ("1.2.3.4", "1.2.3.4.5")

    return fIsIPAddressStr;
}


/*****************************************************************************\
    FUNCTION: PidlGenerateSiteLookupStr

    DESCRIPTION:
    Sample Input: "ftp://user:password@ftp.server.com:69/Dir1/Dir2/File.txt"
    Sample Output: "ftp://user:password@ftp.server.com:69/"

    This is used to keep track of unique servers for CFtpSite.  A CFtpSite needs
    to be created for each unique site, which includes different users that are
    logged onto the same site because of rooted directories.
\*****************************************************************************/
HRESULT PidlGenerateSiteLookupStr(LPCITEMIDLIST pidl, LPTSTR pszLookupStr, DWORD cchSize)
{
    HRESULT hr = E_FAIL;

    // Some strange clients pass in non-Server IDs, like comdlg.
    if (FtpID_IsServerItemID(pidl))
    {
        LPITEMIDLIST pidlServer = FtpCloneServerID(pidl);
        
        if (pidlServer)
        {
            hr = UrlCreateFromPidlW(pidlServer, SHGDN_FORPARSING, pszLookupStr, cchSize, (ICU_ESCAPE | ICU_USERNAME), FALSE);
            ILFree(pidlServer);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT PidlReplaceUserPassword(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    HRESULT hr = FtpPidl_GetServer(pidlIn, szServer, ARRAYSIZE(szServer));

    if (!pszUserName)   // May be NULL.
    {
        pszUserName = szUserName;
        EVAL(SUCCEEDED(FtpPidl_GetUserName(pidlIn, szUserName, ARRAYSIZE(szUserName))));
    }

    *ppidlOut = NULL;
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlServer;

        hr = FtpServerID_Create(szServer, pszUserName, pszPassword, FtpServerID_GetTypeID(pidlIn), FtpServerID_GetPortNum(pidlIn), &pidlServer, pm, TRUE);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFtpPath = _ILNext(pidlIn);

            *ppidlOut = ILCombine(pidlServer, pidlFtpPath);
            ILFree(pidlServer);
        }
    }

    return hr;
}


HRESULT UrlReplaceUserPassword(LPTSTR pszUrlPath, DWORD cchSize, LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    HRESULT hr = E_FAIL;
    URL_COMPONENTS urlComps = {0};
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR szExtraInfo[MAX_PATH];    // Includes Port Number and download type (ASCII, Binary, Detect)
    BOOL fResult;

    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    urlComps.lpszUserName = szUserName;
    urlComps.dwUserNameLength = ARRAYSIZE(szUserName);
    urlComps.lpszPassword = szPassword;
    urlComps.dwPasswordLength = ARRAYSIZE(szPassword);

    fResult = InternetCrackUrl(pszUrlPath, 0, ICU_DECODE, &urlComps);
    if (fResult)
    {
        urlComps.dwStructSize = sizeof(urlComps);
        urlComps.lpszHostName = szServer;

        urlComps.lpszUserName = (LPTSTR)(pszUserName ? pszUserName : szUserName);
        urlComps.dwUserNameLength = (pszUserName ? lstrlen(pszUserName) : lstrlen(szUserName));
        urlComps.lpszPassword = (LPTSTR)pszPassword;    // It may be valid for caller to pass NULL
        urlComps.dwPasswordLength = (pszPassword ? lstrlen(pszPassword) : 0);
        urlComps.lpszExtraInfo = szExtraInfo;
        urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

        fResult = InternetCreateUrl(&urlComps, (ICU_ESCAPE_AUTHORITY | ICU_ESCAPE | ICU_USERNAME), pszUrlPath, &cchSize);
        if (fResult)
        {
            hr = S_OK;
        }
    }

    return hr;
}


// InternetCreateUrlW() will write into pszUrl but won't terminate the string.
// This is hard to detect because half the time the place where the terminator should
// go may coincidentally contain a terminator.  This code forces the bug to happen.
#define TEST_FOR_INTERNETCREATEURL_BUG      1
#define INTERNETCREATEURL_BUG_WORKAROUND     1

HRESULT UrlCreateEx(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    DWORD cchSizeCopy = cchSize;

#if DEBUG && TEST_FOR_INTERNETCREATEURL_BUG
    LPTSTR pszDebugStr = pszUrl;
    for (DWORD dwIndex = (cchSize - 2); dwIndex; dwIndex--)
    {
#ifndef INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr[0] = -1;         // This will force a buffer w/o terminators.
#else // INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr[0] = 0;         // This will work around the bug.
#endif // INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr++;
    }
#endif // DEBUG && TEST_FOR_INTERNETCREATEURL_BUG

    URL_COMPONENTS urlComp = {sizeof(URL_COMPONENTS), NULL, 0, INTERNET_SCHEME_FTP, (LPTSTR) pszServer, 0,
                              ipPortNum, (LPTSTR) NULL_FOR_EMPTYSTR(pszUser), 0, (LPTSTR) NULL_FOR_EMPTYSTR(pszPassword), 0,
                              (LPTSTR) pszUrlPath, 0, (LPTSTR) NULL, 0};
    
    if (EVAL(InternetCreateUrl(&urlComp, dwFlags | ICU_ESCAPE_AUTHORITY | ICU_USERNAME, pszUrl, &cchSizeCopy)))
    {
        hr = S_OK;
        if (pszFragment)
            StrCatBuff(pszUrl, pszFragment, cchSize);
    }

#if DEBUG && TEST_FOR_INTERNETCREATEURL_BUG
#ifdef INTERNETCREATEURL_BUG_WORKAROUND
    // Make sure we hit a terminator and not a -1, which should never happen in URL strings.
    for (pszDebugStr = pszUrl; pszDebugStr[0]; pszDebugStr++)
        ASSERT(-1 != pszDebugStr[0]);
#endif // INTERNETCREATEURL_BUG_WORKAROUND
#endif // DEBUG && TEST_FOR_INTERNETCREATEURL_BUG

    return hr;
}


HRESULT UrlCreate(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize)
{
    return UrlCreateEx(pszServer, pszUser, pszPassword, pszUrlPath, pszFragment, ipPortNum, pszDownloadType, pszUrl, cchSize, ICU_ESCAPE);
}


BOOL IsEmptyUrlPath(LPCTSTR pszUrlPath)
{
    BOOL fResult = FALSE;

    if (!pszUrlPath ||
        !pszUrlPath[0] ||
        (((TEXT('/') == pszUrlPath[0]) && (!pszUrlPath[1]))))
    {
        fResult = TRUE;
    }

    return fResult;
}



///////////////////////////////////////////////////////////////////////
// Wire Path Functions (UTF-8 or DBCS/MBCS)
///////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: WirePathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT WirePathAdd(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment)
{
    // If the segment starts with a slash, skip it.
    if ('/' == pwWireSegment[0])
        pwWireSegment = CharNextA(pwWireSegment);

    StrCatBuffA(pwWirePath, pwWireSegment, cchUrlSize);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: WirePathAppendSlash

    DESCRIPTION:
\*****************************************************************************/
HRESULT WirePathAppendSlash(LPWIRESTR pwWirePath, DWORD cchWirePathSize)
{
    HRESULT hr = E_FAIL;
    DWORD cchSize = lstrlenA(pwWirePath);

    // Is there enough room?
    if (cchSize < (cchWirePathSize - 1))
    {
        LPWIRESTR pwEndOfPath = &pwWirePath[cchSize - 1];

        // Is it missing a backslash?
        if ((pwEndOfPath >= pwWirePath) && '/' != pwEndOfPath[0])
            StrCatBuffA(pwEndOfPath, SZ_URL_SLASHA, (int)(cchWirePathSize - (pwEndOfPath - pwWirePath)));    // Yes, so add it.

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: WirePathAppend

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT WirePathAppend(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment)
{
    if (!EVAL(pwWireSegment))
        return E_INVALIDARG;

    WirePathAppendSlash(pwWirePath, cchUrlSize); // Make sure the base url ends in a '/'. Note it may be "ftp://".
    return WirePathAdd(pwWirePath, cchUrlSize, pwWireSegment);
}


/*****************************************************************************\
    FUNCTION: UrlGetFirstPathSegment

    PARAMETERS:
    [IN]  pszFullPath - "Dir1\Dir2\Dir3"
    [OUT] szFirstItem - "Dir1"              [OPTIONAL]
    [OUT] szRemaining - "Dir2\Dir3"         [OPTIONAL]
\*****************************************************************************/
HRESULT WirePathGetFirstSegment(LPCWIRESTR pwFtpWirePath, LPWIRESTR wFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWIRESTR wRemaining, DWORD cchRemainingSize, BOOL * pfIsDir)
{
    HRESULT hr = S_OK;
    LPCWIRESTR pwSegEnding = StrChrA(pwFtpWirePath, CH_URL_URL_SLASH);

    if (pfIsDir)
        *pfIsDir = FALSE;

    ASSERT((CH_URL_URL_SLASHA != pwFtpWirePath[0]));    // You will probably not get what you want.
    if (pwSegEnding)
    {
        if (wFirstItem)
        {
            DWORD cchSize = (DWORD) (pwSegEnding - pwFtpWirePath + 1);
            StrCpyNA(wFirstItem, pwFtpWirePath, (cchSize <= cchFirstItemSize) ? cchSize : cchFirstItemSize);
        }

        if (pfIsDir && (CH_URL_URL_SLASHA == pwSegEnding[0]))
            *pfIsDir = TRUE;    // Tell them that it is a directory.

        if (wRemaining)
            StrCpyNA(wRemaining, CharNextA(pwSegEnding), cchRemainingSize);

        if (0 == pwSegEnding[1])
            hr = S_FALSE;   // End of the line.
    }
    else
    {
        if (wFirstItem)
            StrCpyNA(wFirstItem, pwFtpWirePath, cchFirstItemSize);    // pszFullPath contains only one segment 

        if (wRemaining)
            wRemaining[0] = 0;
        hr = S_FALSE;       // Indicate that there aren't any more directories left.
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////
// Display Path Functions (Unicode)
///////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: DisplayPathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT DisplayPathAdd(LPWSTR pwzUrl, DWORD cchUrlSize, LPCWSTR pwzSegment)
{
    // If the segment starts with a slash, skip it.
    if (L'/' == pwzSegment[0])
        pwzSegment = CharNext(pwzSegment);

    StrCatBuffW(pwzUrl, pwzSegment, cchUrlSize);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: DisplayPathAppendSlash

    DESCRIPTION:
\*****************************************************************************/
HRESULT DisplayPathAppendSlash(LPWSTR pwzDisplayPath, DWORD cchSize)
{
    DWORD cchCurrentSize = lstrlenW(pwzDisplayPath);
    HRESULT hr = CO_E_PATHTOOLONG;

    if (cchCurrentSize < (cchSize - 2))
    {
        LPWSTR pwzEndOfPath = &pwzDisplayPath[cchCurrentSize - 1];

        // Is it missing a backslash?
        if ((pwzEndOfPath >= pwzDisplayPath) && TEXT('/') != pwzEndOfPath[0])
            StrCatBuff(pwzEndOfPath, SZ_URL_SLASH, (cchSize - cchCurrentSize + 1));    // Yes, so add it.

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: DisplayPathAppend

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT DisplayPathAppend(LPWSTR pwzDisplayPath, DWORD cchUrlSize, LPCWSTR pwzDisplaySegment)
{
    if (!EVAL(pwzDisplaySegment))
        return E_INVALIDARG;

    DisplayPathAppendSlash(pwzDisplayPath, cchUrlSize); // Make sure the base url ends in a '/'. Note it may be "ftp://".
    return DisplayPathAdd(pwzDisplayPath, cchUrlSize, pwzDisplaySegment);
}


/*****************************************************************************\
    FUNCTION: DisplayPathGetFirstSegment

    PARAMETERS:
    [IN]  pszFullPath - "Dir1\Dir2\Dir3"
    [OUT] szFirstItem - "Dir1"              [OPTIONAL]
    [OUT] szRemaining - "Dir2\Dir3"         [OPTIONAL]
\*****************************************************************************/
HRESULT DisplayPathGetFirstSegment(LPCWSTR pwzFullPath, LPWSTR pwzFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWSTR pwzRemaining, DWORD cchRemainingSize, BOOL * pfIsDir)
{
    HRESULT hr = S_OK;
    LPWSTR pwzSegEnding = StrChrW(pwzFullPath, CH_URL_URL_SLASH);

    if (pfIsDir)
        *pfIsDir = FALSE;

    // This will happen if the user enters an incorrect URL, like "ftp://wired//"
    //  ASSERT((CH_URL_URL_SLASHW != pwzFullPath[0]));    // You will probably not get what you want.
    if (pwzSegEnding)
    {
        if (pwzFirstItem)
        {
            DWORD cchSize = (DWORD) (pwzSegEnding - pwzFullPath + 1);
            StrCpyNW(pwzFirstItem, pwzFullPath, (cchSize <= cchFirstItemSize) ? cchSize : cchFirstItemSize);
        }

        if (pfIsDir && (CH_URL_URL_SLASHW == pwzSegEnding[0]))
            *pfIsDir = TRUE;    // Tell them that it is a directory.

        if (pwzRemaining)
            StrCpyNW(pwzRemaining, CharNextW(pwzSegEnding), cchRemainingSize);

        if (0 == pwzSegEnding[1])
            hr = S_FALSE;   // End of the line.
    }
    else
    {
        if (pwzFirstItem)
            StrCpyNW(pwzFirstItem, pwzFullPath, cchFirstItemSize);    // pszFullPath contains only one segment 

        if (pwzRemaining)
            pwzRemaining[0] = 0;
        hr = S_FALSE;       // Indicate that there aren't any more directories left.
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpwith.cpp ===
/*****************************************************************************
 *
 *	ftpwith.cpp - "With" procedures
 *
 *****************************************************************************/

#include "priv.h"

/*****************************************************************************
 *
 *	With_Hglob
 *
 *	Allocate a moveable HGLOBAL of the requested size, lock it, then call
 *	the callback.  On return, unlock it and get out.
 *
 *	Returns the allocated HGLOBAL, or 0.
 *
 *****************************************************************************/

HGLOBAL With_Hglob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef)
{
    HGLOBAL hglob = GlobalAlloc(GHND, cb);
    if (hglob)
    {
	    LPVOID pv = GlobalLock(hglob);
	    if (pv)
        {
	        BOOL fRc = pfn(pv, pvRef);
	        GlobalUnlock(hglob);
	        if (!fRc)
            {
		        GlobalFree(hglob);
		        hglob = 0;
	        }
	    }
        else
        {
	        GlobalFree(hglob);
	        hglob = 0;
	    }
    }

    return hglob;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\isf.h ===
/*****************************************************************************\
    FILE: isf.h

    DESCRIPTION:
        This is a base class that implements the default behavior of IShellFolder.
\*****************************************************************************/

#ifndef _DEFAULT_ISHELLFOLDER_H
#define _DEFAULT_ISHELLFOLDER_H

#include "cowsite.h"


/*****************************************************************************\
    CLASS: CBaseFolder

    DESCRIPTION:
        The stuff that tracks the state of a folder.

    The cBusy field tracks how many sub-objects have been created
    (e.g., IEnumIDList) which still contain references to this
    folder's identity.  You cannot change the folder's identity
    (via IPersistFolder::Initialize) while there are outstanding
    subobjects.

    The number of cBusy's never exceeds the number of cRef's, because
    each subobject that requires the folder identity must retain a
    reference to the folder itself.  That way, the folder won't be
    Release()d while the identity is still needed.

    Name Space description (for m_pidlComplete & m_nIDOffsetToOurNameSpaceRoot):
    The name space is provided by the shell to describe resources for the user.
    This class is a base implementation so users can create their own name space
    that is rooted in the shell's name space.  A PIDL is a list of ItemID, each of
    which represent one level in the name space.  The list provides a path thru
    the name space to a specific item.  Example:
    [Desktop][My Computer][C:\][Dir1][Dir2][File.htm][#goto_description_secion]
    [Desktop][The Internet][ftp://server/][Dir1][Dir2][file.txt]
    [Desktop][My Computer][PrivateNS lvl1][lvl2][lvl3]...
    (Public Name Space)   (Private Name Space)
    [GNS Level1][GNS Levl2][Pri LVL1][P LVL2][P LVL3]...

    In the example immediately above, this CBaseFolder can create a name space
    under "My Computer" that has 3 levels (lvl1, lvl2, lvl3).  An instance of this
    COM object will be positioned at one level of the sub name space (lvl1, lvl2, or lvl3).

    m_pidlComplete - is the list of ItemIDs from the base [Desktop] to the current location
                maybe lvl2.
    m_nIDOffsetToOurNameSpaceRoot - is the number of bytes of m_pidlComplete that you need
                to skip to get to the first ItemID in the private name space (which
                is the name space owned by this class).
\*****************************************************************************/

class CBaseFolder       : public IShellFolder2
                        , public IPersistFolder3
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IShellFolder ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                            ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    virtual STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);
    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // *** IShellFolder2 ***
    virtual STDMETHODIMP GetDefaultSearchGUID(GUID *pguid) {return E_NOTIMPL;};
    virtual STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pcsFlags) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd) {return E_NOTIMPL;};
    virtual STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) {return E_NOTIMPL;};

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    
    // *** IPersistFolder2 ***
    virtual STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // *** IPersistFolder3 ***
    virtual STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti);
    virtual STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *ppfti);

public:
    CBaseFolder(LPCLSID pClassID);
    virtual ~CBaseFolder(void);

    // Public Member Functions
    virtual HRESULT _GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject);
    virtual HRESULT _Initialize(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlAliasRoot, int nBytesToPrivate);
    virtual HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj) = 0;       // PURE
    virtual HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj, LONG lEvents, FOLDERVIEWMODE fvm, IShellFolderViewCB * psfvCallBack, 
                            LPCITEMIDLIST pidl, LPFNVIEWCALLBACK pfnCallback);

    LPCITEMIDLIST GetPublicTargetPidlReference(void) { return m_pidl;};
    LPITEMIDLIST GetPublicTargetPidlClone(void) { return ILClone(GetPublicTargetPidlReference());};
    LPCITEMIDLIST GetPublicRootPidlReference(void) { return (m_pidlRoot ? m_pidlRoot : m_pidl);};
    LPITEMIDLIST GetPublicRootPidlClone(void) { return ILClone(GetPublicRootPidlReference());};
    LPCITEMIDLIST GetPrivatePidlReference(void);
    LPITEMIDLIST GetPrivatePidlClone(void) { return ILClone(GetPrivatePidlReference());};
    LPITEMIDLIST GetPublicPidlRootIDClone(void);
    LPITEMIDLIST CreateFullPublicPidlFromRelative(LPCITEMIDLIST pidlPrivateSubPidl);
    LPITEMIDLIST CreateFullPrivatePidl(LPCITEMIDLIST pidlPrivateSubPidl);
    LPITEMIDLIST CreateFullPublicPidl(LPCITEMIDLIST pidlPrivatePidl);

    LPCITEMIDLIST GetFolderPidl(void) { return m_pidlRoot;};

protected:
    int                     m_cRef;

    int GetPidlByteOffset(void) { return m_nIDOffsetToPrivate;};

private:
    LPITEMIDLIST            m_pidl;                 // Public Pidl - Complete list of IDs from very base of NameSpace to this name space and into this name space to the point of being rooted.
    LPITEMIDLIST            m_pidlRoot;             // Pidl of Folder Shortcut.
    int                     m_nIDOffsetToPrivate;   // number of bytes from the start of m_pidlComplete to the first ItemID in our name space.
    LPCLSID                 m_pClassID;             // My CLSID
};

#endif // _DEFAULT_ISHELLFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpwebvw.cpp ===
/*****************************************************************************\
    FILE: ftpwebvw.h

    DESCRIPTION:
        This file exists so WebView can automate the Ftp Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

#include "priv.h"
#include "ftpwebvw.h"
#include "msieftp.h"
#include <shlguid.h>

//===========================
// *** IDispatch Interface ***
//===========================

STDMETHODIMP CFtpWebView::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFtpWebView::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFtpWebView::GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}

STDMETHODIMP CFtpWebView::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}



//===========================
// *** IFtpWebView Interface ***
//===========================


// IID_IShellFolderView added locally for doj compliance.  It's a private interface, but not used on w2k or above
// so it doesn't haved to be doc'ed.
#include <initguid.h>
// 37A378C0-F82D-11CE-AE65-08002B2E1262
DEFINE_GUID(IID_IShellFolderView, 0x37A378C0L, 0xF82D, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

/*****************************************************************************\
    FUNCTION: _GetIFtpWebView

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::_GetIFtpWebView(IFtpWebView ** ppfwb)
{
    IShellFolderViewCB * psfvcb = NULL;
    HRESULT hr = S_FALSE;

    ASSERT(_punkSite);
    if (EVAL(ppfwb))
        *ppfwb = NULL;

    IUnknown_QueryService(_punkSite, SID_ShellFolderViewCB, IID_IShellFolderViewCB, (LPVOID *) &psfvcb);
    // IE4's shell32 doesn't support QS(SID_ShellFolderViewCB, IID_IShellFolderViewCB), so we need to
    // QS(SID_ShellFolderViewCB, IShellFolderView) and then use IShellFolderView::SetCallback()
    if (!psfvcb)
    {
        IDefViewFrame * pdvf = NULL;

        IUnknown_QueryService(_punkSite, SID_DefView, IID_IDefViewFrame, (LPVOID *) &pdvf);
        if (EVAL(pdvf))
        {
            IShellFolderView * psfv = NULL;

            pdvf->QueryInterface(IID_IShellFolderView, (LPVOID *) &psfv);
            if (EVAL(psfv))
            {
                if (EVAL(SUCCEEDED(psfv->SetCallback(NULL, &psfvcb))))
                {
                    IShellFolderViewCB * psfvcbTemp = NULL;

                    if (SUCCEEDED(psfv->SetCallback(psfvcb, &psfvcbTemp)) && psfvcbTemp)
                    {
                        // We should get NULL back but if not, release the ref instead of leaking.
                        psfvcbTemp->Release();
                    }
                }

                psfv->Release();
            }

            pdvf->Release();
        }
    }
    
    if (EVAL(psfvcb))
    {
        if (EVAL(SUCCEEDED(psfvcb->QueryInterface(IID_IFtpWebView, (LPVOID *) ppfwb))))
            hr = S_OK;

        psfvcb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_MessageOfTheDay

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_MessageOfTheDay(BSTR * pbstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_MessageOfTheDay(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_UserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_UserName(BSTR * pbstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_UserName(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_Server

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_Server(BSTR * pbstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_Server(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_Directory

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_Directory(BSTR * pbstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_Directory(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_PasswordLength

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_PasswordLength(long * plLength)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_PasswordLength(plLength);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_EmailAddress(BSTR * pbstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_EmailAddress(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::put_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::put_EmailAddress(BSTR bstr)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->put_EmailAddress(bstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_CurrentLoginAnonymous

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_CurrentLoginAnonymous(pfAnonymousLogin);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginAnonymously

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::LoginAnonymously(void)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginAnonymously();
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginWithPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::LoginWithPassword(BSTR bUserName, BSTR bPassword)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginWithPassword(bUserName, bPassword);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginWithoutPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::LoginWithoutPassword(BSTR bUserName)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginWithoutPassword(bUserName);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::InvokeHelp

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView::InvokeHelp(void)
{
    IFtpWebView * pfwb;
    HRESULT hr = _GetIFtpWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->InvokeHelp();
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CFtpWebView_Create

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpWebView_Create(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFtpWebView * pfwv = new CFtpWebView();

    if (pfwv)
    {
        hr = pfwv->QueryInterface(riid, ppv);
        pfwv->Release();
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpWebView::CFtpWebView() : m_cRef(1), CImpIDispatch(&IID_IFtpWebView)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.

    LEAK_ADDREF(LEAK_CFtpWebView);
}


/****************************************************\
    Destructor
\****************************************************/
/*****************************************************************************
 *
 *      FtpView_OnRelease (from shell32.IShellView)
 *
 *      When the view is released, clean up various stuff.
 *
 *      (Note that there is a race here, because this->hwndOwner
 *      doesn't get zero'd out on the OnWindowDestroy because the shell
 *      doesn't give us a pdvsci...)
 *
 *      We release the psf before triggering the timeout, which is a
 *      signal to the trigger not to do anything.
 *
 *      _UNDOCUMENTED_: This callback and its parameters are not documented.
 *
 *****************************************************************************/
CFtpWebView::~CFtpWebView()
{
    DllRelease();
    LEAK_DELREF(LEAK_CFtpWebView);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpWebView::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpWebView::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpWebView::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFtpWebView, IObjectWithSite),
        QITABENT(CFtpWebView, IDispatch),
        QITABENT(CFtpWebView, IObjectSafety),
        QITABENT(CFtpWebView, IFtpWebView),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpwebvw.h ===
/*****************************************************************************\
    FILE: ftpwebvw.h

    DESCRIPTION:
        This file exists so WebView can automate the Ftp Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

#ifndef _FTPWEBVIEW_H_
#define _FTPWEBVIEW_H_

#include "dspsprt.h"
#include "cowsite.h"
#include "cobjsafe.h"
#include "msieftp.h"

HRESULT CFtpWebView_Create(REFIID riid, void **ppvObj);

/*****************************************************************************\
    CLASS: CFtpWebView

    DESCRIPTION:
        This file exists so WebView can automate the Ftp Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

class CFtpWebView 
                :  public CImpIDispatch
                ,  public CObjectWithSite
                ,  public CObjectSafety
                ,  public IFtpWebView
{    

public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // *** IFtpWebView ***
    virtual STDMETHODIMP get_Server(BSTR * pbstr);
    virtual STDMETHODIMP get_Directory(BSTR * pbstr);
    virtual STDMETHODIMP get_UserName(BSTR * pbstr);
    virtual STDMETHODIMP get_PasswordLength(long * plLength);
    virtual STDMETHODIMP get_EmailAddress(BSTR * pbstr);
    virtual STDMETHODIMP put_EmailAddress(BSTR bstr);
    virtual STDMETHODIMP get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin);
    virtual STDMETHODIMP get_MessageOfTheDay(BSTR * pbstr);
    virtual STDMETHODIMP LoginAnonymously(void);
    virtual STDMETHODIMP LoginWithPassword(BSTR bUserName, BSTR bPassword);
    virtual STDMETHODIMP LoginWithoutPassword(BSTR bUserName);
    virtual STDMETHODIMP InvokeHelp(void);

public:
    // Friend Functions
    friend HRESULT CFtpWebView_Create(REFIID riid, void **ppvObj);

private:
    // Private Member Variables
    int                     m_cRef;

    // Private Member Functions
    CFtpWebView();
    ~CFtpWebView();

    HRESULT _GetIFtpWebView(IFtpWebView ** ppfwb);
};


#endif // _FTPWEBVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpurl.h ===
/*****************************************************************************
 *
 *	ftpurl.h - Creating, encoding, and decoding URLs
 *
 *****************************************************************************/

#ifndef _FTPURL_H
#define _FTPURL_H


///////////////////////////////////////////////////////////////////////
// URL Path Functions (Obsolete?)
///////////////////////////////////////////////////////////////////////
// URL Path Wacking
HRESULT UrlPathRemoveSlashW(LPWSTR pszUrlPath);
HRESULT UrlPathRemoveSlashA(LPSTR pszUrlPath);
HRESULT UrlPathRemoveFrontSlashW(LPWSTR pszUrlPath);
HRESULT UrlPathRemoveFrontSlashA(LPSTR pszUrlPath);
HRESULT UrlPathToFilePathW(LPWSTR pszPath);
HRESULT UrlPathToFilePathA(LPSTR pszPath);
HRESULT FilePathToUrlPathW(LPWSTR pszPath);
HRESULT FilePathToUrlPathA(LPSTR pszPath);

#ifdef UNICODE
#define UrlPathRemoveSlash          UrlPathRemoveSlashW
#define UrlPathRemoveFrontSlash     UrlPathRemoveFrontSlashW
#else // UNICODE
#define UrlPathRemoveSlash          UrlPathRemoveSlashA
#define UrlPathRemoveFrontSlash     UrlPathRemoveFrontSlashA
#endif // UNICODE

HRESULT UrlGetDifference(LPCTSTR pszBaseUrl, LPCTSTR pszSuperUrl, LPTSTR pszPathDiff, DWORD cchSize);
HRESULT UrlPathAdd(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment);
HRESULT UrlPathToFilePath(LPCTSTR pszSourceUrlPath, LPTSTR pszDestFilePath, DWORD cchSize);
HRESULT UrlRemoveDownloadType(LPTSTR pszUrlPath, BOOL * pfTypeSpecified, BOOL * pfType);
HRESULT UrlReplaceUserPassword(LPTSTR pszUrlPath, DWORD cchSize, LPCTSTR pszUserName, LPCTSTR pszPassword);
HRESULT PidlReplaceUserPassword(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUserName, LPCTSTR pszPassword);
//HRESULT UrlPathAppendSlash(LPTSTR pszUrlPath);
//HRESULT UrlPathGetLastSegment(LPCTSTR pszUrl, LPTSTR pszSegment, DWORD cchSegSize);
//HRESULT UrlPathRemoveLastSegment(LPTSTR pszUrl);
//HRESULT UrlGetPath(LPCTSTR pszUrl, DWORD dwFlags, LPTSTR pszUrlPath, DWORD cchUrlPathSize);
//HRESULT UrlPathAppend(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment);
//HRESULT UrlReplaceUrlPath(LPTSTR pszUrl, DWORD cchSize, LPCTSTR pszUrlPath);
//HRESULT PidlReplaceUrlPath(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUrlPath);


///////////////////////////////////////////////////////////////////////
// Wire Path Functions (UTF-8 or DBCS/MBCS)
///////////////////////////////////////////////////////////////////////
HRESULT WirePathAppend(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment);
HRESULT WirePathAppendSlash(LPWIRESTR pwWirePath, DWORD cchWirePathSize);
HRESULT WirePathGetFirstSegment(LPCWIRESTR pwFtpWirePath, LPWIRESTR wFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWIRESTR wRemaining, DWORD cchRemainingSize, BOOL * pfIsDir);


///////////////////////////////////////////////////////////////////////
// Display Path Functions (Unicode)
///////////////////////////////////////////////////////////////////////
HRESULT DisplayPathAppend(LPWSTR pwzDisplayPath, DWORD cchUrlSize, LPCWSTR pwzDisplaySegment);
HRESULT DisplayPathAppendSlash(LPWSTR pwzDisplayPath, DWORD cchSize);
HRESULT DisplayPathGetFirstSegment(LPCWSTR pwzFullPath, LPWSTR pwzFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWSTR pwzRemaining, DWORD cchRemainingSize, BOOL * pfIsDir);




// Other Functions
//HRESULT UrlCreateFromFindData(LPCTSTR pszBaseUrl, const LPWIN32_FIND_DATA pwfd, LPTSTR pszFullUrl, DWORD cchFullUrlSize);
HRESULT UrlCreate(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize);
HRESULT UrlCreateEx(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags);
HRESULT StrRetFromFtpPidl(LPSTRRET pStrRet, DWORD shgno, LPCITEMIDLIST pidl);
HRESULT PidlGenerateSiteLookupStr(LPCITEMIDLIST pidl, LPTSTR pszLookupStr, DWORD cchSize);
BOOL IsIPAddressStr(LPTSTR pszServer);
BOOL IsEmptyUrlPath(LPCTSTR pszUrlPath);

#endif // _FTPURL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\isf.cpp ===
/*****************************************************************************\
    FILE:   isf.cpp

    DESCRIPTION:
        This is a base class that implements the default behavior of IShellFolder.
\*****************************************************************************/

#include "priv.h"
#include "isf.h"
#include <shlobj.h>



/*****************************************************************************\
    FUNCTION: IShellFolder::ParseDisplayName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::ParseDisplayName(HWND hwnd, LPBC pbcReserved, LPOLESTR pwszDisplayName,
                        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    if (pdwAttributes)
        *pdwAttributes = 0;

    if (ppidl)
        *ppidl = NULL;

    return E_NOTIMPL;
}

/*****************************************************************************\
    FUNCTION: IShellFolder::EnumObjects

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList)
{
    if (ppenumIDList)
        *ppenumIDList = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::BindToObject

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::BindToStorage
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::CompareIDs
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::CreateViewObject
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IShellView))
        hr = _CreateShellView(hwndOwner, ppvObj);
    else if (IsEqualIID(riid, IID_IContextMenu))
        hr = _GetUIObjectOf(hwndOwner, 0, NULL, riid, 0, ppvObj, TRUE);
    else
        hr = E_NOINTERFACE;

    return hr;
}


BOOL IsShellIntegration(void)
{
    BOOL fResult = FALSE;
    HINSTANCE hInst = LoadLibrary(TEXT("shell32.dll"));

    if (hInst)
    {
        LPVOID pv = GetProcAddress(hInst, "DllGetVersion");
        if (pv)
            fResult = TRUE;
        FreeLibrary(hInst);
    }
    
    return fResult;
}

HRESULT CBaseFolder::_CreateShellView(HWND hwndOwner, void ** ppvObj, LONG lEvents, FOLDERVIEWMODE fvm, 
                                       IShellFolderViewCB * psfvCallBack, LPCITEMIDLIST pidl, LPFNVIEWCALLBACK pfnCallback)
{
    HRESULT hr;
    IShellFolder * psf;

    hr = this->QueryInterface(IID_IShellFolder, (LPVOID *) &psf);
    if (EVAL(SUCCEEDED(hr)))
    {
        SFV_CREATE sfvCreate =      // SHCreateShellFolderView struct
        {
                sizeof(SFV_CREATE),
                psf,            // psf
                NULL,           // psvOuter
                psfvCallBack    // psfvcb - (IShellFolderViewCB *)
        };

        // SHCreateShellFolderView isn't in the original shell.  We can't rely on the 
        // the Delayload code because it's exported by ordinal and the original
        // shell had a different exports by the same number.
        if (IsShellIntegration())
            hr = _SHCreateShellFolderView(&sfvCreate, (LPSHELLVIEW FAR*)ppvObj);
        else
            hr = E_FAIL;  // Force us to go into the next try.

        // If we aren't running on a machine with Shell Integration, SHCreateShellFolderView will fail.
        if (FAILED(hr))
        {
            CSFV csfv;

            csfv.cbSize = sizeof(csfv);
            csfv.pshf = psf;
            csfv.psvOuter = (IShellView *) psfvCallBack;      // Hack but it works...
            csfv.pidl = pidl;           // This is feed to SFVM_GETNOTIFY so it needs to be a pidlTarget.
            csfv.lEvents = lEvents;
            csfv.pfnCallback = pfnCallback;
            csfv.fvm = fvm;         // vs. FVM_ICON, ...

            hr = SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW FAR*)ppvObj);
            if (SUCCEEDED(hr))
                psfvCallBack->AddRef();     // We gave them a ref.
        }

        psf->Release();
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetAttributesOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetAttributesOf(UINT cpidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetUIObjectOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::_GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject)
{
    return GetUIObjectOf(hwndOwner, cidl, rgpidl, riid, prgfInOut, ppvOut);
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetDisplayNameOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pStrRet)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::SetNameOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pwszName,
                                DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    return E_NOTIMPL;
}


//===========================
// *** IShellFolder2 Interface ***
//===========================

//===========================
// *** IPersist Interface ***
//===========================

/*****************************************************************************\
     FUNCTION: IPersist::GetClassID
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetClassID(LPCLSID pClassID)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(pClassID))
    {
        if (EVAL(m_pClassID))
        {
            *pClassID = *m_pClassID;
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }

    return hr;
}

//===========================
// *** IPersistFolder Interface ***
//===========================

/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(!m_pidl);   // Don't reroot us.
    return _Initialize(pidl, NULL, ILGetSize(pidl) - sizeof(pidl->mkid.cb));
}

//===========================
// *** IPersistFolder2 Interface ***
//===========================

/*****************************************************************************\ 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(ppidl))
    {
        hr = E_FAIL;

        if (m_pidlRoot)
        {
            *ppidl = ILClone(m_pidlRoot);
        }
        else if (EVAL(m_pidl))
        {
            *ppidl = GetPublicTargetPidlClone();
        }

        if (*ppidl)
            hr = S_OK;
    }

    return hr;
}

//===========================
// *** IPersistFolder3 Interface ***
//===========================
HRESULT GetPidlFromPersistFolderTargetInfo(const PERSIST_FOLDER_TARGET_INFO *ppfti, LPITEMIDLIST * ppidl, BOOL fFree)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;
        if (ppfti->pidlTargetFolder)
        {
            *ppidl = (fFree ? ppfti->pidlTargetFolder : ILClone(ppfti->pidlTargetFolder));
            if (*ppidl)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (ppfti->szTargetParsingName[0])
            {
                hr = IEParseDisplayNameWithBCW(CP_ACP, ppfti->szTargetParsingName, NULL, ppidl);
            }

            if (!*ppidl && (-1 != ppfti->csidl))
            {
                hr = SHGetSpecialFolderLocation(NULL, ppfti->csidl, ppidl);
            }
        }
    }
    
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(pidlRoot))
    {
        if (ppfti)
        {
            // We are a Folder Shortcut.
            LPITEMIDLIST pidlTarget;

            hr = GetPidlFromPersistFolderTargetInfo(ppfti, &pidlTarget, FALSE);  // Get the real root.           
            TraceMsg(TF_FOLDER_SHRTCUTS, "CBaseFolder::InitializeEx() this=%#08lx, pidlTarget=%#08lx, pidlRoot=%#08lx", this, pidlTarget, pidlRoot);

            AssertMsg((NULL != pidlTarget), TEXT("CBaseFolder::InitializeEx() We are useless without a pidlTarget so watch me go limp."));
            if (pidlTarget)
            {
                hr = _Initialize(pidlTarget, pidlRoot, m_nIDOffsetToPrivate);
                ILFree(pidlTarget);
            }
        }
        else
        {
            // We aren't a folder shortcut.
            hr = Initialize(pidlRoot);
        }
    }

    return hr;
}


HRESULT CBaseFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *ppfti)
{
    HRESULT hr = E_INVALIDARG;

    AssertMsg((NULL != ppfti), TEXT("CBaseFolder::GetFolderTargetInfo() Caller passed an invalid param."));
    if (ppfti)
    {
        ZeroMemory(ppfti, sizeof(*ppfti)); 

        ppfti->pidlTargetFolder = ILClone(m_pidlRoot);
        ppfti->dwAttributes = -1;
        ppfti->csidl = -1;
        hr = S_OK;
    }

    return hr;
}


LPCITEMIDLIST CBaseFolder::GetPrivatePidlReference(void)
{
    return _ILSkip(m_pidl, m_nIDOffsetToPrivate);
}

// This function always needs the InternetExplorer pidl.
LPITEMIDLIST CBaseFolder::GetPublicPidlRootIDClone(void)
{
    LPITEMIDLIST pidlFull = ILClone(m_pidl);
    LPITEMIDLIST pidlPrivStart = _ILSkip(pidlFull, m_nIDOffsetToPrivate);

    // Strip all Private ItemIDs
    while (!ILIsEmpty(pidlPrivStart))
        ILRemoveLastID(pidlPrivStart);

    return pidlFull;
}

LPITEMIDLIST CBaseFolder::CreateFullPrivatePidl(LPCITEMIDLIST pidlPrivateSubPidl)
{
    return ILCombine(GetPrivatePidlReference(), pidlPrivateSubPidl);
}

LPITEMIDLIST CBaseFolder::CreateFullPublicPidlFromRelative(LPCITEMIDLIST pidlPrivateSubPidl)
{
    return ILCombine(GetPublicRootPidlReference(), pidlPrivateSubPidl);
}

LPITEMIDLIST CBaseFolder::CreateFullPublicPidl(LPCITEMIDLIST pidlPrivatePidl)
{
    LPITEMIDLIST pidlRoot = GetPublicPidlRootIDClone();
    LPITEMIDLIST pidlResult = NULL;
    
    if (pidlRoot)
    {
        pidlResult = ILCombine(pidlRoot, pidlPrivatePidl);
        ILFree(pidlRoot);
    }

    return pidlResult;
}

HRESULT CBaseFolder::_Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate)
{
    HRESULT hr = E_INVALIDARG;

    if (pidlTarget)
    {
        ILFree(m_pidl);
        ILFree(m_pidlRoot);    
        m_pidl = ILClone(pidlTarget);
        m_pidlRoot = ILClone(pidlRoot); // This is the Folder Shortcut pidl.  We don't use it outselves.

        if (m_pidl)
        {
            m_nIDOffsetToPrivate = nBytesToPrivate;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CBaseFolder::CBaseFolder(LPCLSID pClassID) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pidl);
    ASSERT(!m_nIDOffsetToPrivate);
    ASSERT(!m_pClassID);

    m_pClassID = pClassID;
    ASSERT(pClassID);
}


/****************************************************\
    Destructor
\****************************************************/
CBaseFolder::~CBaseFolder()
{
    Pidl_Set(&m_pidlRoot, NULL);    // Folder Shortcut pidl
    Pidl_Set(&m_pidl, NULL);
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CBaseFolder::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CBaseFolder::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CBaseFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CBaseFolder, IShellFolder, IShellFolder2),
        QITABENTMULTI(CBaseFolder, IPersist, IPersistFolder),
        QITABENTMULTI(CBaseFolder, IPersist, IPersistFolder3),
        QITABENTMULTI(CBaseFolder, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CBaseFolder, IPersistFolder2, IPersistFolder3),
        QITABENT(CBaseFolder, IShellFolder2),
        QITABENT(CBaseFolder, IPersistFolder3),
        QITABENT(CBaseFolder, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\isfvcb.h ===
/*****************************************************************************\
    FILE: isfvcb.h

    DESCRIPTION:
        This is a base class that implements the default behavior of 
    IShellFolderViewCallBack.  This allows default DefView implementation with this
    callback to override specific behavior.
\*****************************************************************************/


#ifndef _CBASEFOLDERVIEWCB_H
#define _CBASEFOLDERVIEWCB_H



class CBaseFolderViewCB
                : public IShellFolderViewCB
                , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IShellFolderViewCB methods ***
    virtual STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    // Friend Functions
    static HRESULT _IShellFolderViewCallBack(IShellView * psvOuter, IShellFolder * psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Private Member Variables
    int                     m_cRef;

    IUnknown *              m_psfv;                 // Our parent's IShellFolderView. (Same as _punkSite)
    DWORD                   m_dwSignature;

    enum { c_dwSignature = 0x43564642 }; // "BFVC" - BaseFolderViewCb

    // Private Member Functions
    CBaseFolderViewCB();
    virtual ~CBaseFolderViewCB();

    // We have implementations for these.
    virtual HRESULT _OnSetISFV(IShellFolderView * psfv);

    // The caller needs to provide implementations for these
    // or they will get default behavior.
    virtual HRESULT _OnWindowCreated(void) {return E_NOTIMPL;};
    virtual HRESULT _OnDefItemCount(LPINT pi) {return E_NOTIMPL;};
    virtual HRESULT _OnGetHelpText(LPARAM lParam, WPARAM wParam) {return E_NOTIMPL;};
    virtual HRESULT _OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd) {return E_NOTIMPL;};
    virtual HRESULT _OnGetZone(DWORD * pdwZone, WPARAM wParam) {return E_NOTIMPL;};
    virtual HRESULT _OnGetPane(DWORD dwPaneID, DWORD * pdwPane) {return E_NOTIMPL;};
    virtual HRESULT _OnRefresh(BOOL fReload) {return E_NOTIMPL;};
    virtual HRESULT _OnDidDragDrop(DROPEFFECT de, IDataObject * pdto) {return E_NOTIMPL;};
    virtual HRESULT _OnGetDetailsOf(UINT ici, PDETAILSINFO pdi) {return E_NOTIMPL;};
    virtual HRESULT _OnInvokeCommand(UINT idc) {return E_NOTIMPL;};
    virtual HRESULT _OnMergeMenu(LPQCMINFO pqcm) {return E_NOTIMPL;};
    virtual HRESULT _OnUnMergeMenu(HMENU hMenu) {return E_NOTIMPL;};
    virtual HRESULT _OnColumnClick(UINT ici) {return E_NOTIMPL;};
    virtual HRESULT _OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents) {return E_NOTIMPL;};
    virtual HRESULT _OnFSNotify(LPITEMIDLIST * ppidl, LONG * lEvents) {return E_NOTIMPL;};
    virtual HRESULT _OnQueryFSNotify(SHChangeNotifyEntry * pshcne) {return E_NOTIMPL;};
    virtual HRESULT _OnSize(LONG x, LONG y) {return E_NOTIMPL;};
    virtual HRESULT _OnUpdateStatusBar(void) {return E_NOTIMPL;};
    virtual HRESULT _OnThisIDList(LPITEMIDLIST * ppidl) {return E_NOTIMPL;};
    virtual HRESULT _OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData) {return E_NOTIMPL;};
    virtual HRESULT _OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex) {return E_NOTIMPL;};
    virtual HRESULT _OnBackGroundEnumDone(void) {return E_NOTIMPL;};
};

#endif // _CBASEFOLDERVIEWCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\isfvcb.cpp ===
/*****************************************************************************\
    FILE: isfvcb.cpp

    DESCRIPTION:
        This is a base class that implements the default behavior of 
    IShellFolderViewCallBack.  This allows default DefView implementation with this
    callback to override specific behavior.
\*****************************************************************************/

#include "priv.h"
#include "isfvcb.h"


//===========================
// *** IShellFolderViewCB Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: _OnSetISFV

    DESCRIPTION:
        Same as ::SetSite();
\*****************************************************************************/
HRESULT CBaseFolderViewCB::_OnSetISFV(IShellFolderView * psfv)
{
    IUnknown_Set((IUnknown **) &m_psfv, (IUnknown *) psfv);
    return S_OK;
}

/*****************************************************************************\
    FUNCTION: IShellFolderViewCB::MessageSFVCB

    DESCRIPTION:
\*****************************************************************************/
#define NOTHANDLED(m) case m: hr = E_NOTIMPL; break

HRESULT CBaseFolderViewCB::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;

    switch (uMsg)
    {
    case DVM_GETDETAILSOF:
        hr = _OnGetDetailsOf((UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_COLUMNCLICK:
        hr = _OnColumnClick((UINT)wParam);
        break;

    case DVM_MERGEMENU:
        hr = _OnMergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_UNMERGEMENU:
        hr = _OnUnMergeMenu((HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        hr = _OnInvokeCommand((UINT)wParam);
        break;

    case DVM_GETHELPTEXT:
        hr = _OnGetHelpText(lParam, wParam);
        break;

    case SFVM_GETHELPTOPIC:
        hr = _OnGetHelpTopic((SFVM_HELPTOPIC_DATA *) lParam);
        break;

    case DVM_GETTOOLTIPTEXT:
        // TODO: Implement
        hr = E_NOTIMPL;
        break;

    case DVM_UPDATESTATUSBAR:
        // TODO: Implement
        hr = _OnUpdateStatusBar();
        break;

    case DVM_WINDOWCREATED:
        hr = _OnWindowCreated();
        break;

    case SFVM_BACKGROUNDENUMDONE:
        hr = _OnBackGroundEnumDone();
        break;

    case DVM_INITMENUPOPUP:
        hr = _OnInitMenuPopup((HMENU) lParam, (UINT) HIWORD(wParam), (UINT) LOWORD(wParam));
        break;

    case DVM_RELEASE:
    {
        CBaseFolderViewCB * pfv = (CBaseFolderViewCB *) lParam;
        if (pfv)
            hr = pfv->Release();
    }
    break;

    case DVM_DEFITEMCOUNT:
        hr = _OnDefItemCount((LPINT)lParam);
        break;

    case DVM_DIDDRAGDROP:
        hr = _OnDidDragDrop((DROPEFFECT)wParam, (IDataObject *)lParam);
        break;

    case DVM_REFRESH:
        hr = _OnRefresh((BOOL) wParam);
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = _OnAddPropertyPages((SFVM_PROPPAGE_DATA *)lParam);
        break;

    case DVM_BACKGROUNDENUM:
        //  WARNING!  If we return S_OK from DVM_BACKGROUNDENUM, we also
        //  are promising that we support free threading on our IEnumIDList
        //  interface!  This allows the shell to do enumeration on our
        //  IEnumIDList on a separate background thread.
        hr = S_OK;                    // Always enum in background
        break;

    case SFVM_DONTCUSTOMIZE:
        if (lParam)
            *((BOOL *) lParam) = FALSE;  // Yes, we are customizable.
        hr = S_OK;
        break;

    case SFVM_GETZONE:
        hr = _OnGetZone((DWORD *) lParam, wParam);
        break;

    case SFVM_GETPANE:
        hr = _OnGetPane((DWORD) wParam, (DWORD *)lParam);
        break;

    case SFVM_SETISFV:
        hr = _OnSetISFV((IShellFolderView *)lParam);
        break;

    case SFVM_GETNOTIFY:
        hr = _OnGetNotify((LPITEMIDLIST *) wParam, (LONG *) lParam);
        break;

    case SFVM_FSNOTIFY:
        hr = _OnFSNotify((LPITEMIDLIST *) wParam, (LONG *) lParam);
        break;

    case SFVM_QUERYFSNOTIFY:
        hr = _OnQueryFSNotify((SHChangeNotifyEntry *) lParam);
        break;

    case SFVM_SIZE:
        hr = _OnSize((LONG) wParam, (LONG) lParam);
        break;

    case SFVM_THISIDLIST:
        hr = _OnThisIDList((LPITEMIDLIST *) lParam);
        break;


    // The following are some we could do.
    // SFVM_HWNDMAIN

    // Others that aren't currently handled.
    NOTHANDLED(DVM_GETBUTTONINFO);
    NOTHANDLED(DVM_GETBUTTONS);
    NOTHANDLED(DVM_SELCHANGE);
    NOTHANDLED(DVM_DRAWITEM);
    NOTHANDLED(DVM_MEASUREITEM);
    NOTHANDLED(DVM_EXITMENULOOP);
    NOTHANDLED(DVM_GETCCHMAX);
    NOTHANDLED(DVM_WINDOWDESTROY);
    NOTHANDLED(DVM_SETFOCUS);
    NOTHANDLED(DVM_KILLFOCUS);
    NOTHANDLED(DVM_QUERYCOPYHOOK);
    NOTHANDLED(DVM_NOTIFYCOPYHOOK);
    NOTHANDLED(DVM_DEFVIEWMODE);
#if 0
    NOTHANDLED(DVM_INSERTITEM);         // Too verbose
    NOTHANDLED(DVM_DELETEITEM);
#endif

    NOTHANDLED(DVM_GETWORKINGDIR);
    NOTHANDLED(DVM_GETCOLSAVESTREAM);
    NOTHANDLED(DVM_SELECTALL);
    NOTHANDLED(DVM_SUPPORTSIDENTIFY);
    NOTHANDLED(DVM_FOLDERISPARENT);
    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CBaseFolderViewCB::CBaseFolderViewCB() : m_cRef(1), m_dwSignature(c_dwSignature)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_psfv);

}


/****************************************************\
    Destructor
\****************************************************/
CBaseFolderViewCB::~CBaseFolderViewCB()
{
    m_dwSignature = 0;                  // Turn off _IShellFolderViewCallBack
    IUnknown_Set((IUnknown **)&m_psfv, NULL);
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CBaseFolderViewCB::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CBaseFolderViewCB::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

// {7982F251-C37A-11d1-9823-006097DF5BD4}
static const GUID CIID_PrivateThis = { 0x7982f251, 0xc37a, 0x11d1, { 0x98, 0x23, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };

HRESULT CBaseFolderViewCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IShellFolderViewCB))
    {
        *ppvObj = SAFECAST(this, IShellFolderViewCB*);
    }
    else
    if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CBaseFolderViewCB::_IShellFolderViewCallBack(IShellView * psvOuter, IShellFolder * psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IShellFolderViewCB * psfvcb = NULL;
    HRESULT hr = E_FAIL;


    // Now this is a total hack.  I am bastardizing the pszOuter param to really be the this pointer that
    // is the IShellFolderViewCB interface of the CBaseFolderViewCB object.  I use the SFVM_WINDOWDESTROY event to
    // release the object but DefView calls us back with one more message before we completely go away
    // and that message is SFVM_SETISFV.  Everytime the SFVM_SETISFV is called with a NULL lParam, it's
    // equivalent to calling ::SetSite(NULL).  We can ignore this because we release the back pointer in our
    // destructor.
    if (((SFVM_SETISFV == uMsg) && !lParam) ||
        (SFVM_PRERELEASE == uMsg))
    {
        return S_OK;
    }

    // psvOuter is really our CBaseFolderViewCB.  Sniff around to make sure.
    // Note that this casting must exactly invert the casts that we do in
    // CBaseFolder::_CreateShellView.

    CBaseFolderViewCB *pbfvcb = (CBaseFolderViewCB *)(IShellFolderViewCB *)psvOuter;

    if (EVAL(!IsBadReadPtr(pbfvcb, sizeof(CBaseFolderViewCB))) &&
        EVAL(pbfvcb->m_dwSignature == c_dwSignature))
    {

        // psvOuter is really our CBaseFolderViewCB and let's make sure with this QI.
        hr = psvOuter->QueryInterface(IID_IShellFolderViewCB, (void **) &psfvcb);
        if (EVAL(psfvcb))
        {
            hr = psfvcb->MessageSFVCB(uMsg, wParam, lParam);

            if ((SFVM_WINDOWDESTROY == uMsg)) // (DVM_WINDOWDESTROY == SFVM_WINDOWDESTROY)
            {
                ASSERT(!lParam);    // Sometimes callers want this to be freed.
                psvOuter->Release();     // We are releasing the psvOuter that DefView is holding.  We shouldn't be called again.
            }

            psfvcb->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\newmenu.h ===
/*****************************************************************************\
    FILE: newmenu.h
    
    DESCRIPTION:
        The file supports the "New" menu to create new items on the FTP server.
    This currently only supports Folders but hopefully it will support other
    items later.
\*****************************************************************************/

#ifndef _NEWMENU_H
#define _NEWMENU_H

// For CreateNewFolderCB:
// The following struct is used when recursively downloading
// files/dirs from the FTP server after a "Download" verb.
typedef struct tagFTPCREATEFOLDERSTRUCT
{
    LPCWSTR             pszNewFolderName;
    CFtpFolder *        pff;
} FTPCREATEFOLDERSTRUCT;


// Public APIs (DLL wide)
HRESULT CreateNewFolder(HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, IUnknown * punkSite, BOOL fPosition, POINT point);
HRESULT CreateNewFolderCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvFCFS, BOOL * pfReleaseHint);


#endif // _NEWMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\offline.h ===
/****************************************************\
    FILE: offline.h

    DESCRIPTION:
        Handle 'offline' status and Dial-up UI
\****************************************************/

#ifndef _OFFLINE_H
#define _OFFLINE_H


#ifdef FEATURE_OFFLINE
BOOL IsGlobalOffline(VOID);
VOID SetOffline(IN BOOL fOffline);
#endif // FEATURE_OFFLINE

HRESULT AssureNetConnection(HINTERNET hint, HWND hwndParent, LPCWSTR pwzServerName, LPCITEMIDLIST pidl, BOOL fShowUI);


#endif // _OFFLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\passwordapi.h ===
/*****************************************************************************\
    FILE: passwordapi.h
    
    DESCRIPTION:
        We want to store FTP passwords in a secure API.  We will use the
    PStore APIs on WinNT and the PWL APIs on Win9x.  This code was taken
    from wininet.

    Copyright (c) 1998  Microsoft Corporation
\*****************************************************************************/

#ifndef _PASSWORDAPI_H
#define _PASSWORDAPI_H

#include "priv.h"
#include "util.h"


// ----------------Public function prototypes----------------------

// Determines availability of credential cache.
HRESULT InitCredentialPersist(void);

// Persist credentials (username/password).
HRESULT SetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszValue);

// Get persisted credentials (username/password).
HRESULT GetCachedCredentials(LPCWSTR pszKey, LPWSTR pszValue, DWORD cchSize);

// Remove persisted credentials (username/password).
HRESULT RemoveCachedCredentials(LPCWSTR pszKey);

HRESULT InitCredentialPersist(void);


#endif // _PASSWORDAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\passwordapi.cpp ===
/*****************************************************************************\
    FILE: passwordapi.cpp

    DESCRIPTION:
        We want to store FTP passwords in a secure API.  We will use the
    PStore APIs on WinNT and the PWL APIs on Win9x.  This code was taken
    from wininet.

    BryanSt (Bryan Starbuck) - Created
    BryanSt (Bryan Starbuck) - Updated to support DP API for Win2k

    Copyright (c) 1998-2000  Microsoft Corporation
\*****************************************************************************/

#include "priv.h"
#include <pstore.h>
#include <wincrypt.h>           // Defines DATA_BLOB
#include <passwordapi.h>

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals
#define SIZE_MAX_KEY_SIZE               2048    // For lookup key (In our case, URL w/user name & server, without password & path)
#define SIZE_MAX_VALUE_SIZE             2048    // For stored value (In our case the password)


// MPR.DLL exports used by top level API.
typedef DWORD (APIENTRY *PFWNETGETCACHEDPASSWORD)    (LPCSTR, WORD, LPCSTR, LPWORD, BYTE);
typedef DWORD (APIENTRY *PFWNETCACHEPASSWORD)        (LPCSTR, WORD, LPCSTR, WORD, BYTE, UINT);
typedef DWORD (APIENTRY *PFWNETREMOVECACHEDPASSWORD) (LPCSTR, WORD, BYTE);

// PWL related variables.
static HMODULE MhmodWNET                                        = NULL;
static PFWNETGETCACHEDPASSWORD g_pfWNetGetCachedPassword        = NULL;
static PFWNETCACHEPASSWORD g_pfWNetCachePassword                = NULL;
static PFWNETREMOVECACHEDPASSWORD g_pfWNetRemoveCachedPassword  = NULL;

// Pstore related variables.
static PFNPSTORECREATEINSTANCE s_pPStoreCreateInstance = NULL;

#define STR_FTP_CACHE_CREDENTIALS                   L"MS IE FTP Passwords";
#define PSTORE_MODULE                               TEXT("pstorec.dll")
#define WNETDLL_MODULE                              TEXT("mpr.dll")
#define WNETGETCACHEDPASS                           "WNetGetCachedPassword"
#define WNETCACHEPASS                               "WNetCachePassword"
#define WNETREMOVECACHEDPASS                        "WNetRemoveCachedPassword"

#define DISABLE_PASSWORD_CACHE        1


// PWL related defines.

// Password-cache-entry, this should be in PCACHE.
#define PCE_WWW_BASIC 0x13  

// NOTE: We would logically like to unload the dll of the API we use (s_pPStoreCreateInstance) via FreeLibrary(PSTORE_MODULE),
//   but we would need to do that when we unload our DLL.  We can't do that because it leads to crashing
//   and badness.


// Wininet uses this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType = 
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.
// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPCSTR pszKey, DWORD cbKey, LPCSTR pszCred, DWORD cbCred);
DWORD PWLGetCachedCredentials(LPCSTR pszKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials(LPCSTR pszKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPCWSTR pszKey, LPWSTR pszCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPCWSTR pszKey);

HRESULT CreatePStore(IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore *pIPStore);


#define FEATURE_USE_DPAPI
// The DPAPI is an improved version of PStore that started shipping in Win2k.  This
// has better security and should be used when it is available.  Pete Skelly informed
// me of this.  CliffV also has a password credentials manager, but that probably wouldn't
// be applicable for FTP.
HRESULT DPAPISetCachedCredentials(IN LPCWSTR pszKey, IN LPCWSTR pszValue, IN OPTIONAL LPCWSTR pszDescription);
HRESULT DPAPIGetCachedCredentials(IN LPCWSTR pszKey, IN LPWSTR pszValue, IN int cchSize);
HRESULT DPAPIRemoveCachedCredentials(IN LPCWSTR pszKey);

// *--------------------------- Top Level APIs ---------------------------------*



/****************************************************\
    FUNCTION: InitCredentialPersist

    DESCRIPTION:
        Try to init the cache.   

    PARAMETERS:
    Return Value:
        S_OK if it will work correctly.
        S_FASE if turned off by admin.
        HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED) if the password caching APIs aren't installed on NT.
\****************************************************/
HRESULT InitCredentialPersist(void)
{
    HRESULT hr = S_OK;
    DWORD dwDisable;
    DWORD cbSize = sizeof(dwDisable);

    // First check to see if persistence is disabled via registry.
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGVALUE_DISABLE_PASSWORD_CACHE, NULL, (void *)&dwDisable, &cbSize))
        && (dwDisable == DISABLE_PASSWORD_CACHE))
    {
        // Persistence disabled via registry.
        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        // We use PWL for Win95; this should be available.
        if (!IsOS(OS_NT))
        {
            // hr already equals S_OK and no more work is needed.
        }
        else
        {
            HINSTANCE hInstPStoreC = 0;

            // If is WinNT, check if PStore is installed. 
            hInstPStoreC = LoadLibrary(PSTORE_MODULE);
            if (!hInstPStoreC)
                hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);
            else
            {
                // Get CreatePStoreInstance function pointer.
                s_pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE) GetProcAddress(hInstPStoreC, "PStoreCreateInstance");

                if (!s_pPStoreCreateInstance)
                    hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);
                else
                {
                    IPStore * pIPStore = NULL;

                    // Create an IPStore.
                    hr = CreatePStore(&pIPStore);

                    // We just did this to see if it worked, so
                    // the hr was set correctly.
                    if (pIPStore)
                        ReleasePStore(pIPStore);
                }
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: SetCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT SetCachedCredentials(LPCWSTR pwzKey, LPCWSTR pwzValue)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            // Use the PWL (Password List) API on Win9x

            CHAR szKey[SIZE_MAX_KEY_SIZE];
            CHAR szValue[SIZE_MAX_VALUE_SIZE];

            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            ASSERT(lstrlenW(pwzValue) < ARRAYSIZE(szValue));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            SHUnicodeToAnsi(pwzValue, szValue, ARRAYSIZE(szValue));
            DWORD cbKey = ((lstrlenA(szKey) + 1) * sizeof(szKey[0]));
            DWORD cbCred = ((lstrlenA(szValue) + 1) * sizeof(szValue[0]));

            // Store credentials using PWL.
            DWORD dwError = PWLSetCachedCredentials(szKey, cbKey, szValue, cbCred);
            hr = HRESULT_FROM_WIN32(dwError);
        }
        else
        {
            hr = E_FAIL;

#ifdef FEATURE_USE_DPAPI
            if (5 <= GetOSVer())
            {
                // Use the DPAPI (Data Protection) API on Win2k and later.
                // This has the latest and greatest in protection.
                WCHAR wzDescription[MAX_URL_STRING];

                wnsprintfW(wzDescription, ARRAYSIZE(wzDescription), L"FTP password for: %ls", pwzKey);
                hr = DPAPISetCachedCredentials(pwzKey, pwzValue, wzDescription);
            }
#endif // FEATURE_USE_DPAPI

            if (FAILED(hr)) // Fall back to PStore in case DP is won't work unless we do UI.
            {
                // Use the PStore API on pre-Win2k.
                DWORD cbCred = ((lstrlenW(pwzValue) + 1) * sizeof(pwzValue[0]));

                // Store credentials using PStore.
                DWORD dwError = PStoreSetCachedCredentials(pwzKey, pwzValue, cbCred);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: GetCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT GetCachedCredentials(LPCWSTR pwzKey, LPWSTR pwzValue, DWORD cchSize)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            // Use the PWL (Password List) API on Win9x

            CHAR szKey[SIZE_MAX_KEY_SIZE];
            CHAR szValue[SIZE_MAX_VALUE_SIZE];
            DWORD cchTempSize = ARRAYSIZE(szValue);

            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            ASSERT(cchSize < ARRAYSIZE(szValue));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            DWORD cbKey = ((lstrlenA(szKey) + 1) * sizeof(szKey[0]));

            szValue[0] = 0;
            // Store credentials using PWL.
            DWORD dwError = PWLGetCachedCredentials(szKey, cbKey, szValue, &cchTempSize);
            hr = HRESULT_FROM_WIN32(dwError);
            SHAnsiToUnicode(szValue, pwzValue, cchSize);
        }
        else
        {
            hr = E_FAIL;

#ifdef FEATURE_USE_DPAPI
            if (5 <= GetOSVer())
            {
                // Use the DPAPI (Data Protection) API on Win2k and later.
                // This has the latest and greatest in protection.
                hr = DPAPIGetCachedCredentials(pwzKey, pwzValue, cchSize);
            }
#endif // FEATURE_USE_DPAPI

            if (FAILED(hr)) // Fall back to PStore in case DP is won't work unless we do UI.
            {
                // Use the PStore API on pre-Win2k.

                cchSize++;  // Include terminator.
                cchSize *= sizeof(pwzValue[0]);

                pwzValue[0] = 0;
                // Store credentials using PStore.
                DWORD dwError = PStoreGetCachedCredentials(pwzKey, pwzValue, &cchSize);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

    }

    return hr;
}


/****************************************************\
    FUNCTION: RemoveCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT RemoveCachedCredentials(LPCWSTR pwzKey)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            // Use the PWL (Password List) API on Win9x

            CHAR szKey[SIZE_MAX_KEY_SIZE];
            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            DWORD cbKey = (lstrlenA(szKey) * sizeof(szKey[0]));

            // Remove credentials from PWL.
            DWORD dwError = PWLRemoveCachedCredentials(szKey, cbKey);
            hr = HRESULT_FROM_WIN32(dwError);
        }
        else
        {
            hr = E_FAIL;

#ifdef FEATURE_USE_DPAPI
            if (5 <= GetOSVer())
            {
                // Use the DPAPI (Data Protection) API on Win2k and later.
                // This has the latest and greatest in protection.
                hr = DPAPIRemoveCachedCredentials(pwzKey);
            }
#endif // FEATURE_USE_DPAPI

            if (FAILED(hr)) // Fall back to PStore in case DP is won't work unless we do UI.
            {
                // Remove credentials from PStore.
                DWORD dwError = PStoreRemoveCachedCredentials(pwzKey);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

    }

    return hr;
}


/*--------------------------- PWL Functions ---------------------------------*/



/*-----------------------------------------------------------------------------
  PWLSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLSetCachedCredentials(LPCSTR pszKey, DWORD cbKey, 
                              LPCSTR pszCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;
    
    // Store credentials.  
    dwError =  (*g_pfWNetCachePassword) (pszKey, (WORD) cbKey, pszCred, (WORD) cbCred, PCE_WWW_BASIC, 0); 

    return dwError;
}




/*-----------------------------------------------------------------------------
  PWLGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLGetCachedCredentials  (LPCSTR pszKey, DWORD cbKey, 
                                LPSTR pszCred, LPDWORD pcbCred)
{    
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    // Retrieve credentials.
    dwError = (*g_pfWNetGetCachedPassword) (pszKey, (WORD) cbKey, pszCred, 
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);
    
    return dwError;
}



/*-----------------------------------------------------------------------------
  PWLRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLRemoveCachedCredentials  (LPCSTR pszKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    dwError = (*g_pfWNetRemoveCachedPassword) (pszKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


/*-----------------------------------------------------------------------------
  LoadWNet
  ---------------------------------------------------------------------------*/
BOOL LoadWNet(VOID)
{
    BOOL fReturn;
    
    // MPR.DLL already loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);
    
    // Fail if not loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    g_pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    g_pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    g_pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(g_pfWNetGetCachedPassword 
          && g_pfWNetCachePassword
          && g_pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    
    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



/*-----------------------------------------------------------------------------
  PStoreSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreSetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszCred, DWORD cbCred, BOOL fRemove)
{
    ASSERT(s_pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;
    
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    IPStore *       pStore = NULL;
    
    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = STR_FTP_CACHE_CREDENTIALS;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    ASSERT(pStore != NULL);
               
    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType, 
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;
            
    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (pszCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               pszKey,
                               cbCred,
                               (LPBYTE) pszCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                pszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);
    
    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}                                                                       


/*-----------------------------------------------------------------------------
  PStoreGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreGetCachedCredentials(LPCWSTR pszKey, LPWSTR pszCred, LPDWORD pcbCred)
{
    ASSERT(s_pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;
    
    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    ASSERT(pStore != NULL);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          pszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(pszCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    
    return dwError;
}

/*-----------------------------------------------------------------------------
  PStoreRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreRemoveCachedCredentials(LPCWSTR pszKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(pszKey, NULL, 0, TRUE);
}

// PStore utility functions

/*-----------------------------------------------------------------------------
  CreatePStore
  ---------------------------------------------------------------------------*/
HRESULT CreatePStore(IPStore **ppIPStore)
{
    return s_pPStoreCreateInstance (ppIPStore, NULL, NULL, 0);
}


/*-----------------------------------------------------------------------------
  ReleasePStore
  ---------------------------------------------------------------------------*/
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}






/*--------------------------- DP (Data Protection) Functions ---------------------------------*/
void ClearDataBlob(DATA_BLOB * pdbBlobToFree)
{
    if (pdbBlobToFree && pdbBlobToFree->pbData)
    {
        LocalFree(pdbBlobToFree->pbData);
    }
}


/*-----------------------------------------------------------------------------
  PWLSetCachedCredentials
  ---------------------------------------------------------------------------*/
HRESULT DPAPISetCachedCredentials(IN LPCWSTR pszKey, IN LPCWSTR pszValue, IN OPTIONAL LPCWSTR pszDescription)
{
    HRESULT hr = S_OK;
    DATA_BLOB dbEncrypted = {0};
    DATA_BLOB dbUnencrypted;

    dbUnencrypted.pbData = (unsigned char *) pszValue;
    dbUnencrypted.cbData = ((lstrlenW(pszValue) + 1) * sizeof(pszValue[0]));

    if (!_CryptProtectData(&dbUnencrypted, pszDescription, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dbEncrypted))
    {
         hr = HRESULT_FROM_WIN32(GetLastError());   // It failed, so get the real err value.
    }
    else
    {
        WCHAR wzDPKey[MAX_URL_STRING+MAX_PATH];

        wnsprintfW(wzDPKey, ARRAYSIZE(wzDPKey), L"DPAPI: %ls", pszKey);

        AssertMsg((NULL != dbEncrypted.pbData), TEXT("If the API succeeded but they didn't give us the encrypted version.  -BryanSt"));
        // Use the PStore to actually store the data, but we use a different key.
        DWORD dwError = PStoreSetCachedCredentials(wzDPKey, (LPCWSTR)dbEncrypted.pbData, dbEncrypted.cbData);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    ClearDataBlob(&dbEncrypted);
    return hr;
}


#define MAX_ENCRYPTED_PASSWORD_SIZE         20*1024         // The DP API should be able to store our tiny encrypted password into 20k.

/*-----------------------------------------------------------------------------
  PWLGetCachedCredentials
  ---------------------------------------------------------------------------*/
HRESULT DPAPIGetCachedCredentials(IN LPCWSTR pszKey, IN LPWSTR pszValue, IN int cchSize)
{
    HRESULT hr = E_OUTOFMEMORY;
    DATA_BLOB dbEncrypted = {0};
    dbEncrypted.pbData = (unsigned char *) LocalAlloc(LPTR, MAX_ENCRYPTED_PASSWORD_SIZE);
    dbEncrypted.cbData = MAX_ENCRYPTED_PASSWORD_SIZE;

    StrCpyNW(pszValue, L"", cchSize);  // Init the buffer in case of an error.
    if (dbEncrypted.pbData)
    {
        WCHAR wzDPKey[MAX_URL_STRING+MAX_PATH];

        // Use the PStore to actually store the data, but we use a different key.
        wnsprintfW(wzDPKey, ARRAYSIZE(wzDPKey), L"DPAPI: %ls", pszKey);
        DWORD dwError = PStoreGetCachedCredentials(wzDPKey, (LPWSTR)dbEncrypted.pbData, &dbEncrypted.cbData);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            DATA_BLOB dbUnencrypted = {0};

            if (_CryptUnprotectData(&dbEncrypted, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dbUnencrypted))
            {
                StrCpyNW(pszValue, (LPCWSTR)dbUnencrypted.pbData, cchSize);  // Init the buffer in case of an error.
                ClearDataBlob(&dbUnencrypted);
            }
            else
            {
                 hr = HRESULT_FROM_WIN32(GetLastError());   // It failed, so get the real err value.
            }
        }

        LocalFree(dbEncrypted.pbData);
    }

    return hr;
}


/*-----------------------------------------------------------------------------
  PWLRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
HRESULT DPAPIRemoveCachedCredentials(IN LPCWSTR pszKey)
{
    WCHAR wzDPKey[MAX_URL_STRING+MAX_PATH];

    wnsprintfW(wzDPKey, ARRAYSIZE(wzDPKey), L"DPAPI: %ls", pszKey);
    DWORD dwError = PStoreRemoveCachedCredentials(wzDPKey);
    return HRESULT_FROM_WIN32(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\newmenu.cpp ===
/*****************************************************************************\
    FILE: newmenu.cpp
    
    DESCRIPTION:
        The file supports the "New" menu to create new items on the FTP server.
    This currently only supports Folders but hopefully it will support other
    items later.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "newmenu.h"

// This is used to surf the hwnds to find the one we need to
// hack because IShellView2::SelectAndPositionItem() isn't implemented
// on Browser Only.
#define DEFVIEW_CLASS_BROWSERONLYA       "SHELLDLL_DefView"


/////////////////////////////////////////////////////////////////////////
///////  Private helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

LPITEMIDLIST DV_GetPIDL(HWND hwndLV, int i)
{
    LV_ITEM item;

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.lParam = 0;
    if (i != -1)
    {
        ListView_GetItem(hwndLV, &item);
    }

    return (LPITEMIDLIST) item.lParam;
}


int DefView_FindItemHack(CFtpFolder * pff, HWND hwndListView, LPCITEMIDLIST pidl)
{
    int nIndex;
    int nItemsTotal;

    nItemsTotal = ListView_GetItemCount(hwndListView);
    for (nIndex = 0; nItemsTotal > nIndex; nIndex++)
    {
        HRESULT hres = ResultFromShort(-1);
        LPITEMIDLIST pidlT = DV_GetPIDL(hwndListView, nIndex);
        if (!pidlT)
            return -1;

        hres = pff->CompareIDs(COL_NAME, pidl, pidlT);

        ASSERT(SUCCEEDED(hres));
        if (FAILED(hres))
            return -1;

        if (ShortFromResult(hres) == 0)
        {
            return nIndex;
        }
    }

    return -1;  // not found
}


typedef struct tagFOLDERNAMECOMP
{
    BOOL *      pfFound;
    LPCWSTR     pszFolderName;
} FOLDERNAMECOMP;


/*****************************************************************************\
    FUNCTION: _ComparePidlAndFolderStr

    DESCRIPTION:
        Compare the pidl and folder name str.
\*****************************************************************************/
int _ComparePidlAndFolderStr(LPVOID pvPidl, LPVOID pvFolderNameComp)
{
    FOLDERNAMECOMP * pFolderNameComp = (FOLDERNAMECOMP *) pvFolderNameComp;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    WCHAR wzDisplayName[MAX_PATH];
    BOOL fContinue = TRUE;

    if (EVAL(SUCCEEDED(FtpPidl_GetDisplayName(pidl, wzDisplayName, ARRAYSIZE(wzDisplayName)))))
    {
        if (!StrCmpW(wzDisplayName, pFolderNameComp->pszFolderName))
        {
            *pFolderNameComp->pfFound = TRUE;
            fContinue = FALSE;
        }
    }

    return fContinue;   // Continue looking?
}


/*****************************************************************************\
    FUNCTION: _DoesFolderExist

    DESCRIPTION:
        Look thru all the items (files and folders) in this folder and see if
    any have the same name as pszFolderName.
\*****************************************************************************/
BOOL _DoesFolderExist(LPCWSTR pszFolderName, CFtpDir * pfd)
{
    BOOL fExist = FALSE;
    if (EVAL(pfd))
    {
        CFtpPidlList * pPidlList = pfd->GetHfpl();

        // This may fail, but the worst that will happen is that the new folder won't appear.
        // This happens when the cache is flushed.
        if (pPidlList)
        {
            FOLDERNAMECOMP folderNameComp = {&fExist, pszFolderName};

            pPidlList->Enum(_ComparePidlAndFolderStr, (LPVOID) &folderNameComp);
            pPidlList->Release();
        }
    }

    return fExist;
}


/*****************************************************************************\
    FUNCTION: _CreateNewFolderName

    DESCRIPTION:
        Create the name of a new folder.
\*****************************************************************************/
HRESULT _CreateNewFolderName(LPWSTR pszNewFolder, DWORD cchSize, CFtpDir * pfd)
{
    HRESULT hr = S_OK;
    int nTry = 1;
    WCHAR wzTemplate[MAX_PATH];

    wzTemplate[0] = 0;

    LoadStringW(HINST_THISDLL, IDS_NEW_FOLDER_FIRST, pszNewFolder, cchSize);
    while (_DoesFolderExist(pszNewFolder, pfd))
    {
        if (0 == wzTemplate[0])
            LoadStringW(HINST_THISDLL, IDS_NEW_FOLDER_TEMPLATE, wzTemplate, ARRAYSIZE(wzTemplate));

        nTry++; // Try the next number.
        wnsprintf(pszNewFolder, cchSize, wzTemplate, nTry);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _CreateNewFolder

    DESCRIPTION:
        Create the actual directory.
\*****************************************************************************/
HRESULT CreateNewFolderCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvFCFS, BOOL * pfReleaseHint)
{
    HRESULT hr = S_OK;
    FTPCREATEFOLDERSTRUCT * pfcfs = (FTPCREATEFOLDERSTRUCT *) pvFCFS;
    WIRECHAR wFilePath[MAX_PATH];
    CWireEncoding * pWireEncoding = phpi->pfd->GetFtpSite()->GetCWireEncoding();

    hr = pWireEncoding->UnicodeToWireBytes(NULL, pfcfs->pszNewFolderName, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wFilePath, ARRAYSIZE(wFilePath));
    if (EVAL(SUCCEEDED(hr)))
    {
        hr = FtpCreateDirectoryWrap(hint, TRUE, wFilePath);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlNew;
            HINTERNET hIntFind;

            // For some reason, FtpFindFirstFile needs an '*' behind the name.
            StrCatBuffA(wFilePath, SZ_ASTRICSA, ARRAYSIZE(wFilePath));

            hr = FtpFindFirstFilePidlWrap(hint, TRUE, NULL, pWireEncoding, wFilePath, &pidlNew, (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD), 0, &hIntFind);
            if (EVAL(SUCCEEDED(hr)))
            {
                // Notify the folder of the new item so the Shell Folder updates.
                // PERF: I worry about doing a FtpFindFirstFile() being too expensive onto to get the date correct
                //       for SHChangeNotify().
                FtpChangeNotify(phpi->hwnd, SHCNE_MKDIR, pfcfs->pff, phpi->pfd, pidlNew, NULL, TRUE);

                ILFree(pidlNew);
                InternetCloseHandle(hIntFind);
            }
        }
    }

    return hr;
}




/////////////////////////////////////////////////////////////////////////
///////  DLL Wide Functions    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

HRESULT CreateNewFolder(HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, IUnknown * punkSite, BOOL fPosition, POINT point)
{
    HRESULT hr = E_FAIL;
    CFtpDir * pfdTemp = NULL;

    if (!pfd)
        pfd = pfdTemp = pff->GetFtpDir();

    if (EVAL(pfd))
    {
        WCHAR wzNewFolderName[MAX_PATH];

        // 1. Check if "New Folder" exists.
        // 2. Cycle thru names until a unique name is found.
        hr = _CreateNewFolderName(wzNewFolderName, ARRAYSIZE(wzNewFolderName), pfd);
        if (EVAL(SUCCEEDED(hr) && pfd))
        {
            FTPCREATEFOLDERSTRUCT fcfs = {wzNewFolderName, pff};

            // 3. Create a Directory with that name.
            hr = pfd->WithHint(NULL, hwnd, CreateNewFolderCB, (LPVOID) &fcfs, punkSite, pff);
            if (SUCCEEDED(hr))
            {
                WIRECHAR wNewFolderWireName[MAX_PATH];
                LPITEMIDLIST pidlFolder = NULL;
                CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

                // Give me UTF-8 baby.
                EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, wzNewFolderName, (pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wNewFolderWireName, ARRAYSIZE(wNewFolderWireName))));
                if (EVAL(SUCCEEDED(FtpItemID_CreateFake(wzNewFolderName, wNewFolderWireName, TRUE, FALSE, FALSE, &pidlFolder))))
                {
                    // Is this browser only?
                    if (SHELL_VERSION_W95NT4 == GetShellVersion())
                    {
                        HWND hwndDefView = NULL;
                        // Yes, so we need to do this the hard way.
                
                        // 1. 
                        ShellFolderView_SetItemPos(hwnd, pidlFolder, point.x, point.y);
                        hwndDefView = FindWindowExA(hwnd, NULL, DEFVIEW_CLASS_BROWSERONLYA, NULL);

                        if (EVAL(hwndDefView))
                        {
                            HWND hwndListView = FindWindowExA(hwndDefView, NULL, WC_LISTVIEWA, NULL);

                            if (EVAL(hwndListView))
                            {
                                 int nIndex = DefView_FindItemHack(pff, hwndListView, pidlFolder);

                                 if (EVAL(-1 != nIndex))
                                    ListView_EditLabel(hwndListView, nIndex);
                            }
                        }
                    }
                    else
                    {
                        // No, so this won't be as hard.
                        IShellView2 * pShellView2 = NULL;

//                      ASSERT(punkSite);   // Can happen when invoked from Captionbar.
                        IUnknown_QueryService(punkSite, SID_DefView, IID_IShellView2, (void **)&pShellView2);
                        if (!pShellView2)
                        {
                            IDefViewFrame * pdvf = NULL;
                            IUnknown_QueryService(punkSite, SID_DefView, IID_IDefViewFrame, (void **)&pdvf);
                            if (pdvf)   // Can fail when invoked from caption bar.
                            {
                                EVAL(SUCCEEDED(pdvf->QueryInterface(IID_IShellView2, (void **) &pShellView2)));
                                pdvf->Release();
                            }
                        }

                        if (pShellView2)    // Can fail when invoked from the caption bar.  Oh well, cry me a river.
                        {
                            if (fPosition)
                                pShellView2->SelectAndPositionItem(pidlFolder, (SVSI_SELECT | SVSI_TRANSLATEPT | SVSI_EDIT), &point);
                            else
                                pShellView2->SelectItem(pidlFolder, (SVSI_EDIT | SVSI_SELECT));

                            pShellView2->Release();
                        }
                    }

                    ILFree(pidlFolder);
                }
            }
            else
            {
                // An error occured, so display UI.  Most often because access is denied.
                DisplayWininetError(hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_NEWFOLDER, IDS_FTPERR_WININET, MB_OK, NULL);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        if (pfdTemp)
            pfdTemp->Release();
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\offline.cpp ===
/****************************************************\
    FILE: offline.cpp

    DESCRIPTION:
        Handle 'offline' status and Dial-up UI
\****************************************************/

#include "priv.h"
#include "util.h"


#ifdef FEATURE_OFFLINE
/****************************************************\
    FUNCTION: IsGlobalOffline

    DESCRIPTION:
        Determines whether wininet is in global offline mode

    PARAMETERS:
        None

    RETURN VALUE:
        BOOL
            TRUE    - offline
            FALSE   - online
\****************************************************/
BOOL IsGlobalOffline(VOID)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}


/****************************************************\
    FUNCTION: SetOffline

    DESCRIPTION:
        Sets wininet's offline mode

    PARAMETERS:
        fOffline - online or offline

    RETURN VALUE:
        None.
\****************************************************/
VOID SetOffline(IN BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci = {0};

    if(fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    }
    else
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}
#endif // FEATURE_OFFLINE


/****************************************************\
    FUNCTION: AssureNetConnection

    DESCRIPTION:
\****************************************************/
HRESULT AssureNetConnection(HINTERNET hint, HWND hwndParent, LPCWSTR pwzServerName, LPCITEMIDLIST pidl, BOOL fShowUI)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_OFFLINE
    if (IsGlobalOffline())
    {
        // Assume we need to cancel the FTP operation because we are offline.
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

        // Can we prompt to go online?
        if (fShowUI)
        {
            TCHAR szTitle[MAX_PATH];
            TCHAR szPromptMsg[MAX_PATH];

            EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_TITLE, szTitle, ARRAYSIZE(szTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_OFFLINE_PROMPTTOGOONLINE, szPromptMsg, ARRAYSIZE(szPromptMsg)));

            if (IDYES == MessageBox(hwndParent, szPromptMsg, szTitle, (MB_ICONQUESTION | MB_YESNO)))
            {
                SetOffline(FALSE);
                hr = S_OK;
            }
        }
    }
#endif // FEATURE_OFFLINE

#ifdef FEATURE_DIALER
    if (S_OK == hr)
    {
        TCHAR szUrl[MAX_URL_STRING];

        StrCpyN(szUrl, TEXT("ftp://"), ARRAYSIZE(szUrl));
        StrCatBuff(szUrl, pwzServerName, ARRAYSIZE(szUrl));

        // PERF: Does this value get cached?
        if (FALSE == InternetCheckConnection(szUrl, FLAG_ICC_FORCE_CONNECTION, 0)
            ||
#ifdef FEATURE_TEST_DIALER
        (IDNO == MessageBox(hwndParent, TEXT("TEST: Do you want to dial?"), TEXT("Test Dialer"), MB_YESNO))
#endif // FEATURE_TEST_DIALER
            )
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }
#endif // FEATURE_DIALER

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************
 *
 *      Magic comments:
 *
 *      _UNDOCUMENTED_: Something that is not documented in the SDK.
 *
 *      _UNOBVIOUS_: Some unusual feature that isn't obvious from the
 *      documentation.  A candidate for a "Tips and Tricks" chapter.
 *
 *      _HACKHACK_: Something that is gross but necessary.
 *
 *      _CHARSET_: Character set issues.
 *
 *      Magic ifdefs:
 *
  *****************************************************************************/


/*****************************************************************************
 *
 *      Global Includes
 *
 *****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
// Don't do this if RC_INVOKED because Fusion will #include <windows.h> before
// we get a chance to override the value of _WIN32_WINDOWS, and our choice
// of 0x0400 will generate a redefinition error...  Fortunately, resource files
// are reasonably insensitive to Windows versions.
#ifndef RC_INVOKED
#ifdef _WIN32_WINDOWS
#undef _WIN32_WINDOWS
#endif // _WIN32_WINDOWS
#define _WIN32_WINDOWS      0x501
#endif

#ifdef WINVER
#undef WINVER
#endif // WINVER
#define WINVER              0x501

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif // _WIN32_WINNT
#define _WIN32_WINNT        0x501

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#define STRICT

#include <windows.h>

#ifdef  RC_INVOKED              /* Define some tags to speed up rc.exe */
#define __RPCNDR_H__            /* Don't need RPC network data representation */
#define __RPC_H__               /* Don't need RPC */
#include <oleidl.h>             /* Get the DROPEFFECT stuff */
#define _OLE2_H_                /* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */
#else // RC_INVOKED
#include <windowsx.h>
#endif // RC_INVOKED


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>
#include <shlobj.h>
#include <shlobjp.h>             // For IProgressDialog
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>
#include <shlapip.h>

#include <shsemip.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shdocvw.h>
#include <shlguid.h>
#include <ieguidp.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>


#include <help.h>

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
//#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>
#include <prsht.h>
#include <inetcpl.h>
#include <uastrfnc.h>
#include <align.h>

#include <commctrl.h>

#include "unithunk.h"

// Trace flags
#define TF_FTPREF           0x00000100      // Dll Reference
#define TF_FTPPERF          0x00000200      // Perf
#define TF_FTPALLOCS        0x00000400      // Object Allocs
#define TF_FTPDRAGDROP      0x00000800      // Drag and Drop
#define TF_FTPLIST          0x00001000      // HDPA Wrapper
#define TF_FTPISF           0x00002000      // IShellFolder
#define TF_FTPQI            0x00004000      // QueryInterface
#define TF_FTPSTATUSBAR     0x00008000      // Status Bar Spew
#define TF_FTPOPERATION     0x00010000      // Ftp Operation (Put File, Get File, CreateDir, DeleteDir, ...)
#define TF_FTPURL_UTILS     0x00020000      // Ftp Url Operations (Pidl->Url, Url->Pidl, ...)
#define TF_FTP_DLLLOADING   0x00040000      // Loading Other DLLs
#define TF_FTP_OTHER        0x00080000      // Misc.
#define TF_FTP_IDENUM       0x00100000      // IDList Enum (IIDEnum).
#define TF_CHANGENOTIFY     0x00200000      // Change Notify
#define TF_PIDLLIST_DUMP    0x00400000      // Dump the contents in the Pidl List
#define TF_WININET_DEBUG    0x00800000      // Dump wininet calls
#define TF_BKGD_THREAD      0x01000000      // Background thread that caches wininet handles.
#define TF_FOLDER_SHRTCUTS  0x02000000      // Info about Folder Shortcuts.


/*****************************************************************************
 *
 *      Global Helper Macros/Typedefs
 *
 *****************************************************************************/

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
//
// #define USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////



#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif // OLD_HLIFACE

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// shorthand
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else // NOATOMICRELESEFUNC

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
#ifndef USE_IE5_UTILS
#define ATOMICRELEASE(p)                FtpCopy_IUnknown_AtomicRelease((LPVOID*)&p)
void FtpCopy_IUnknown_AtomicRelease(LPVOID* ppunk);
#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
#endif // NOATOMICRELESEFUNC

#endif // ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif // SAFERELEASE
#define SAFERELEASE(p) ATOMICRELEASE(p)


#define IsInRange               InRange

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#ifdef  UNICODE
   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;
#endif /* UNICODE */

typedef unsigned __int64 QWORD, * LPQWORD;


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define CALLWNDPROC WNDPROC


extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst


#include "idispids.h"


// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


/*****************************************************************************
 *
 *      Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")


// Convert an array name (A) to a generic count (c).
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define pvByteIndexCb(pv, cb) ((LPVOID)((PBYTE)pv + (cb)))


#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG


#undef lstrcatnW

#undef  lstrcpy
#define lstrcpy             BUG_BUG_BAD_lstrcpy

#undef  lstrcpyW
#define lstrcpyW            BUG_BUG_BAD_lstrcpyW

#undef  lstrcpyA
#define lstrcpyA            BUG_BUG_BAD_lstrcpyA

#undef  lstrcpynW
#define lstrcpynW           BUG_BUG_BAD_lstrcpynW

#undef  lstrcmpW
#define lstrcmpW            BUG_BUG_BAD_lstrcmpW

#undef  lstrcmpiW
#define lstrcmpiW           BUG_BUG_BAD_lstrcmpiW

#undef  lstrcatW
#define lstrcatW            BUG_BUG_BAD_lstrcatW

#undef  lstrcatnW
#define lstrcatnW           BUG_BUG_BAD_lstrcatnW

#undef  StrCat
#define StrCat              BUG_BUG_BAD_StrCat

#undef  StrCatW
#define StrCatW             BUG_BUG_BAD_StrCatW

#undef  StrCatA
#define StrCatA             BUG_BUG_BAD_StrCatA

// Fix shell32 bugs:
#define ILCombine           ILCombineWrapper
#define ILClone             ILCloneWrapper
#define ILFree              ILFreeWrapper

LPITEMIDLIST ILCombineWrapper(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
LPITEMIDLIST ILCloneWrapper(LPCITEMIDLIST pidl);
void ILFreeWrapper(LPITEMIDLIST pidl);

/*****************************************************************************
 *
 *      Wrappers and other quickies
 *
 *****************************************************************************/

#define HRESULT_FROM_SUCCESS_VALUE(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))

#define ILIsSimple(pidl) (ILIsEmpty(_ILNext(pidl)))

typedef DWORD DROPEFFECT;

#define ProtocolIdlInnerData(pidl)  ((LPVOID)&(((PDELEGATEITEMID)(pidl))->rgb[0]))
#define ProtocolIdlInnerDataSize  (sizeof(DELEGATEITEMID) - (sizeof(BYTE)*2))

/*****************************************************************************
 *
 *      Const globals:  Never change.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern char c_szSlash[];        /* "/" */

extern WORD c_wZero;            /* A word of zeros */

#pragma END_CONST_DATA

#define c_pidlNil               ((LPCITEMIDLIST)&c_wZero)       /* null pidl */
#define c_tszNil                ((LPCTSTR)&c_wZero)     /* null string */
#define c_szNil                 ((LPCSTR)&c_wZero)      /* null string */

/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *      WARNING! <shelldll\idlcomm.h> #define's various g_cf's, so we need
 *      to #undef them before we start partying on them again.
 *
 *****************************************************************************/

#undef g_cfFileDescriptor
#undef g_cfFileContents
#undef g_cfShellIDList
#undef g_cfFileNameMap
#undef g_cfPreferredDe

extern HINSTANCE                g_hinst;                    // My instance handle
extern CHAR                     g_szShell32[MAX_PATH];      // Full path to shell32.dll (must be ANSI)


// Detect "." or ".." as invalid files
#define IS_VALID_FILE(str)        (!(('.' == str[0]) && (('\0' == str[1]) || (('.' == str[1]) && ('\0' == str[2])))))

extern FORMATETC g_formatEtcOffsets;
extern FORMATETC g_formatPasteSucceeded;
extern FORMATETC g_dropTypes[];

extern CLIPFORMAT g_cfTargetCLSID;

// TODO: 
//     Create a DROP_FTP clipboard format that will
//     give a source URL, a destination URL, and
//     a list of files that need to be moved or copied
//     from relative to the source URL to relative to
//     the destination URL.

enum DROPTYPES
{
    // File contents is inherently weird
    DROP_FCont = 0,     // File contents

    // Clipboard formats we offer from our DataObject
    DROP_FGDW,          // File Group DescriptorW 1
    DROP_FGDA,          // File Group DescriptorA 2
    DROP_IDList,        // ID List Array 3
    DROP_URL,           // Uniform Resource Locator 4
//    DROP_Offsets,       // Shell Object Offsets
    DROP_PrefDe,        // Preferred Drop Effect 5
    DROP_PerfDe,        // Performed Drop Effect 6
    DROP_FTP_PRIVATE,   // Ftp Private Data - Flag to indicate Ftp was the drag source 7
    DROP_OLEPERSIST,        // Used by ole to realize that they should persist via IPersistStream across OleFlushClipboard calls.

    // Clipboard formats we query but do not offer
    DROP_Hdrop,         // File Drop
    DROP_FNMA,          // File Name Map (Ansi)
    DROP_FNMW           // File Name Map (Unicode)
};

#define DROP_OFFERMIN           DROP_FGDW
#define DROP_OFFERMAX           DROP_Hdrop
#define DROP_MAX                (DROP_FNMW+1)

/*****************************************************************************
 *
 *      Global state management.
 *
 *      DLL reference count, DLL critical section.
 *
 *****************************************************************************/

void DllAddRef(void);
void DllRelease(void);

#ifdef UNICODE
#define EMPTYSTR_FOR_NULL EMPTYSTR_FOR_NULLW
#else // UNICODE
#define EMPTYSTR_FOR_NULL EMPTYSTR_FOR_NULLA
#endif // UNICODE

#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)
#define EMPTYSTR_FOR_NULLA(str)          ((str) ? (str) : "")
#define EMPTYSTR_FOR_NULLW(str)          ((str) ? (str) : L"")

typedef void (*LISTPROC)(UINT flm, LPVOID pv);

/*****************************************************************************
 *      Local Includes
 *****************************************************************************/


class CFtpFolder;
class CFtpSite;
class CFtpList;
class CFtpDir;
class CFtpPidlList;
class CFtpMenu;
class CFtpDrop;
class CFtpEidl;
class CFtpObj;
class CFtpProp;
class CFtpView;
class CFtpIcon;
class CStatusBar;


#define FTP_SHCNE_EVENTS            (SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_RMDIR | SHCNE_DELETE | SHCNE_MKDIR | SHCNE_CREATE | SHCNE_RENAMEFOLDER | SHCNE_RENAMEITEM | SHCNE_ATTRIBUTES)


typedef struct HINTPROCINFO {
    CFtpDir *   pfd;                    /* CFtpDir in which it's happening */
    HWND        hwnd;                   /* The window to use for UI */
    CStatusBar * psb;                   /* The status bar object. */
} HPI, *PHPI;

typedef HRESULT (*HINTPROC)(HINTERNET hint, PHPI phpi, LPVOID pv, BOOL * pfReleaseHint);

void GetCfBufA(UINT cf, PSTR psz, int cch);

// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;


typedef void (*DELAYEDACTIONPROC)(LPVOID);

typedef struct GLOBALTIMEOUTINFO GLOBALTIMEOUTINFO, * LPGLOBALTIMEOUTINFO;

struct GLOBALTIMEOUTINFO
{
    LPGLOBALTIMEOUTINFO     hgtiNext;
    LPGLOBALTIMEOUTINFO     hgtiPrev;
    LPGLOBALTIMEOUTINFO *   phgtiOwner;
    DWORD                   dwTrigger;
    DELAYEDACTIONPROC       pfn;        // Callback procedure
    LPVOID                  pvRef;      // Reference data for timer
};



#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)


#define LEAK_CFtpFolder                 0
#define LEAK_CFtpDir                    1
#define LEAK_CFtpSite                   2
#define LEAK_CFtpObj                    3
#define LEAK_CFtpEidl                   4
#define LEAK_CFtpDrop                   5
#define LEAK_CFtpList                   6
#define LEAK_CFtpStm                    7
#define LEAK_CAccount                   8
#define LEAK_CFtpFactory                9
#define LEAK_CFtpContextMenu            10
#define LEAK_CFtpEfe                    11
#define LEAK_CFtpGlob                   12
#define LEAK_CFtpIcon                   13
#define LEAK_CMallocItem                14
#define LEAK_CFtpPidlList               15
#define LEAK_CFtpProp                   16
#define LEAK_CStatusBar                 17
#define LEAK_CFtpView                   18
#define LEAK_CFtpWebView                19
#define LEAK_CCookieList                20
#define LEAK_CDropOperation             21


#ifdef DEBUG
typedef struct tagLEAKSTRUCT
{
    DWORD dwRef;
    CHAR szObject[MAX_PATH];
} LEAKSTRUCT;

extern LEAKSTRUCT g_LeakList[];
#define LEAK_ADDREF(dwIndex)    DEBUG_CODE(g_LeakList[dwIndex].dwRef++)
#define LEAK_DELREF(dwIndex)    DEBUG_CODE(g_LeakList[dwIndex].dwRef--)

#else // DEBUG
#define LEAK_ADDREF(dwIndex)    NULL
#define LEAK_DELREF(dwIndex)    NULL
#endif // DEBUG

/*****************************************************************************
 *
 *      ftpdhlp.c - DialogBox helpers
 *
 *****************************************************************************/

// Only update after 50k bytes were copied.
#define SIZE_PROGRESS_AFTERBYTES    50000

typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
    DWORD dwCompletedInCurFile;
    DWORD dwLastDisplayed;              // We only display in chuncks of 50k, so what was the last chunk we displayed. Chunck #3 means between 100k and 150k.
    HINTERNET hint;                     // Used to cancel operation.
} PROGRESSINFO, * LPPROGRESSINFO;


typedef const BYTE *LPCBYTE;


typedef union FDI {
    struct {
        WORD    id;
        WORD    fdio;
    };
    DWORD dw;
} FDI, *PFDI;

typedef const FDI *PCFDI;

#define FDIO_ICON       0
#define FDIO_NAME       1
#define FDIO_TYPE       2
#define FDIO_LOCATION   3
#define FDIO_SIZE       4
#define FDIO_DATE       5
#define FDIO_COUNT      7
#define FDIO_CANMULTI   8

#define FDII_HFPL       0
#define FDII_WFDA       3

void FtpDlg_InitDlg(HWND hdlg, UINT id, CFtpFolder * pff, LPCVOID pv, UINT fdii);

#define FDI_FILEICON    { IDC_FILEICON, FDIO_ICON,      }
#define FDI_FILENAME    { IDC_FILENAME, FDIO_NAME,      }
#define FDI_FILETYPE    { IDC_FILETYPE, FDIO_TYPE,      }
#define FDI_LOCATION    { IDC_LOCATION, FDIO_LOCATION,  }
#define FDI_FILESIZE    { IDC_FILESIZE, FDIO_SIZE,      }
#define FDI_FILETIME    { IDC_FILETIME, FDIO_DATE,      }


#define imiTop          0
#define imiBottom       ((UINT)-1)

typedef void (*GLOBALTIMEOUTPROC)(LPVOID);


/*****************************************************************************\
   UNIX Chmod Bits
\*****************************************************************************/
#define UNIX_CHMOD_READ_OWNER               0x00000400
#define UNIX_CHMOD_WRITE_OWNER              0x00000200
#define UNIX_CHMOD_EXEC_OWNER               0x00000100
#define UNIX_CHMOD_READ_GROUP               0x00000040
#define UNIX_CHMOD_WRITE_GROUP              0x00000020
#define UNIX_CHMOD_EXEC_GROUP               0x00000010
#define UNIX_CHMOD_READ_ALL                 0x00000004
#define UNIX_CHMOD_WRITE_ALL                0x00000002
#define UNIX_CHMOD_EXEC_ALL                 0x00000001



/*****************************************************************************\
   STRINGS
\*****************************************************************************/
#define SZ_FTPURLA                          "ftp://"
#define SZ_EMPTYA                           ""
#define SZ_MESSAGE_FILEA                    "MESSAGE.TXT"
#define SZ_ALL_FILESA                       "*.*"
#define SZ_URL_SLASHA                       "/"
#define SZ_FTP_URL_TYPEA                    ";type="  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACEA                   "%20"
#define SZ_ESCAPED_SLASHA                   "%5c"
#define SZ_DOTA                             "."
#define SZ_ASTRICSA                         "*"
#define SZ_DOS_SLASHA                       "\\"
#define SZ_SPACEA                           " "
#define SZ_HASH_ENCODEDA                    "%23"

#define SZ_FTPURLW                          L"ftp://"
#define SZ_EMPTYW                           L""
#define SZ_MESSAGE_FILEW                    L"MESSAGE.TXT"
#define SZ_ALL_FILESW                       L"*.*"
#define SZ_URL_SLASHW                       L"/"
#define SZ_FTP_URL_TYPEW                    L";type="  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACEW                   L"%20"
#define SZ_ESCAPED_SLASHW                   L"%5c"
#define SZ_DOTW                             L"."
#define SZ_ASTRICSW                         L"*"
#define SZ_DOS_SLASHW                       L"\\"
#define SZ_SPACEW                           L" "
#define SZ_HASH_ENCODEDW                    L"%23"


#define SZ_FTPURL                           TEXT(SZ_FTPURLA)
#define SZ_EMPTY                            TEXT(SZ_EMPTYA)
#define SZ_MESSAGE_FILE                     TEXT(SZ_MESSAGE_FILEA)
#define SZ_ALL_FILES                        TEXT(SZ_ALL_FILESA)
#define SZ_URL_SLASH                        TEXT(SZ_URL_SLASHA)
#define SZ_FTP_URL_TYPE                     TEXT(SZ_FTP_URL_TYPEA)  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACE                    TEXT(SZ_ESCAPED_SPACEA)
#define SZ_ESCAPED_SLASH                    TEXT(SZ_ESCAPED_SLASHA)
#define SZ_DOT                              TEXT(SZ_DOTA)
#define SZ_ASTRICS                          TEXT(SZ_ASTRICSA)
#define SZ_DOS_SLASH                        TEXT(SZ_DOS_SLASHA)
#define SZ_SPACE                            TEXT(SZ_SPACEA)
#define SZ_HASH_ENCODED                     TEXT(SZ_HASH_ENCODEDA)

#define SZ_ANONYMOUS                        TEXT("anonymous")

#define CH_URL_SLASHA                       '\\'
#define CH_URL_URL_SLASHA                   '/'
#define CH_URL_LOGON_SEPARATORA             '@'
#define CH_URL_PASSWORD_SEPARATORA          ':'
#define CH_URL_TEMP_LOGON_SEPARATORA        '-'
#define CH_HASH_DECODEDA                    '#'

#define CH_URL_SLASHW                       L'\\'
#define CH_URL_URL_SLASHW                   L'/'
#define CH_URL_LOGON_SEPARATORW             L'@'
#define CH_URL_PASSWORD_SEPARATORW          L':'
#define CH_URL_TEMP_LOGON_SEPARATORW        L'-'
#define CH_HASH_DECODEDW                    L'#'

#define CH_URL_SLASH                        TEXT(CH_URL_SLASHA)
#define CH_URL_URL_SLASH                    TEXT(CH_URL_URL_SLASHA)
#define CH_URL_LOGON_SEPARATOR              TEXT(CH_URL_LOGON_SEPARATORA)
#define CH_URL_PASSWORD_SEPARATOR           TEXT(CH_URL_PASSWORD_SEPARATORA)
#define CH_URL_TEMP_LOGON_SEPARATOR         TEXT(CH_URL_TEMP_LOGON_SEPARATORA)
#define CH_HASH_DECODED                     TEXT(CH_HASH_DECODEDA)

// FTP Commands
#define FTP_CMD_SYSTEM                      "syst"
#define FTP_CMD_SITE                        "site"
#define FTP_CMD_SITE_HELP                   "site help"
#define FTP_CMD_SITE_CHMOD_TEMPL            "site chmod %lx %s"
#define FTP_CMD_FEAT                        "feat"
#define FTP_CMD_UTF8                        "opts utf8 on"
#define FTP_CMD_NO_OP                       "noop"

// UNIX Commands (Used via SITE FTP command)
#define FTP_UNIXCMD_CHMODA                  "chmod"

#define FTP_SYST_VMS                        "VMS "


/*****************************************************************************\
   REG Keys and Values
\*****************************************************************************/
// FTP Registry Keys
#define SZ_REGKEY_FTPCLASS                  TEXT("ftp")
#define SZ_REGKEY_MICROSOFTSOFTWARE         TEXT("Software\\Microsoft")
#define SZ_REGKEY_FTPFOLDER                 TEXT("Software\\Microsoft\\Ftp")
#define SZ_REGKEY_FTPFOLDER_ACCOUNTS        TEXT("Software\\Microsoft\\Ftp\\Accounts\\")
#define SZ_REGKEY_FTPFOLDER_COMPAT          TEXT("Software\\Microsoft\\Ftp\\Compatible")
#define SZ_REGKEY_INTERNET_SETTINGS         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define SZ_REGKEY_INTERNET_SETTINGS_LAN     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\LAN")
#define SZ_REGKEY_INTERNET_EXPLORER         TEXT("Software\\Microsoft\\Internet Explorer")


// FTP Registry Values
#define SZ_REGVALUE_PASSWDSIN_ADDRBAR       TEXT("PasswordsInAddressBar")
#define SZ_REGVALUE_DOWNLOAD_DIR            TEXT("Download Directory")
#define SZ_REGVALUE_DOWNLOAD_TYPE           TEXT("Download Type")
#define SZ_REGVALUE_WARN_ABOUT_PROXY        TEXT("Warn About Proxy")
#define SZ_REGVALUE_DEFAULT_FTP_CLIENT      TEXT("ShellFolder")
#define SZ_REGVALUE_PREVIOUS_FTP_CLIENT     TEXT("Previous FTP Client")
#define SZ_REGVALUE_PROXY_SERVER            TEXT("ProxyServer")
#define SZ_REGVALUE_URL_ENCODING            TEXT("UrlEncoding")
#define SZ_REGVALUE_DISABLE_PASSWORD_CACHE  TEXT("DisablePasswordCaching")


// FTP Registry Data
#define SZ_REGDATA_IE_FTP_CLIENT            TEXT("{63da6ec0-2e98-11cf-8d82-444553540000}")

// Accounts
#define SZ_REGVALUE_DEFAULT_USER            TEXT("Default User")
#define SZ_REGVALUE_ACCOUNTNAME             TEXT("Name")
#define SZ_REGVALUE_PASSWORD                TEXT("Password")
#define SZ_ACCOUNT_PROP                     TEXT("CAccount_This")
#define SZ_REGKEY_LOGIN_ATTRIBS             TEXT("Login Attributes")
#define SZ_REGKEY_EMAIL_NAME                TEXT("EmailName")
#define SZ_REGKEY_USE_OLD_UI                TEXT("Use Web Based FTP")
#define SZ_REGVALUE_FTP_PASV                TEXT("Use PASV")

/*****************************************************************************\
   FEATURES
\*****************************************************************************/
// Features
//#define FEATURE_DIALER
//#define FEATURE_OFFLINE

// Feature Tests
#define FEATURE_TEST_OFFLINE
#define FEATURE_TEST_DIALER

#define FEATURE_SAVE_PASSWORD
#define FEATURE_CHANGE_PERMISSIONS  // UNIX CHMOD command

// #define FEATURE_FTP_TO_FTP_COPY
#define FEATURE_CUT_MOVE
//  #define ADD_ABOUTBOX


/*****************************************************************************\
   UNIQUE IDENTIFIERS
\*****************************************************************************/
// CLSIDs/IIDs Private to msieftp.dll
// WARNING: Never move these CLSID/IID definitions outside of the DLL.
//
// {299D0193-6DAA-11d2-B679-006097DF5BD4}
extern const GUID CLSID_FtpDataObject;
// {A11501B3-6EA4-11d2-B679-006097DF5BD4}
extern const GUID IID_CFtpFolder;


/*****************************************************************************\
   Local Includes
\*****************************************************************************/

class CFtpFolder;
class CFtpSite;
class CFtpStm;

#include "codepage.h"
#include "encoding.h"
#include "dllload.h"
#include "ftpdir.h"
#include "ftplist.h"
#include "ftppidl.h"
#include "ftpinet.h"
#include "ftppl.h"
#include "util.h"
#include "ftpapi.h"



/*****************************************************************************
 *      Object Constructors
 *****************************************************************************/

HRESULT CFtpFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject);
HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, HWND hwnd, BOOL fFromCreateViewObject, CFtpMenu ** ppfm);
HRESULT CFtpDrop_Create(CFtpFolder * pff, HWND hwnd, CFtpDrop ** ppfm);
HRESULT CFtpEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CFtpObj * pfo, IEnumFORMATETC ** ppenum);
HRESULT CFtpEidl_Create(CFtpDir * pfd, CFtpFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum);
HRESULT CFtpFolder_Create(REFIID riid, LPVOID * ppvObj);
HRESULT CFtpInstaller_Create(REFIID riid, LPVOID * ppvObj);
IUnknown * CFtpGlob_Create(HGLOBAL hglob);
CFtpGlob * CFtpGlob_CreateStr(LPCTSTR pszStr);
HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppv);
HRESULT CFtpIcon_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpIcon ** ppfm);
HRESULT CFtpList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CFtpList ** ppfl);
HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
HRESULT CFtpObj_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, CFtpObj ** ppfo);
HRESULT CFtpObj_Create(REFIID riid, void ** ppvObj);
HRESULT CFtpProp_Create(CFtpPidlList * pflHfpl, CFtpFolder * pff, HWND hwnd, CFtpProp ** ppfp);
HRESULT CFtpStm_Create(CFtpDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, CFtpStm ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg);
HRESULT CFtpView_Create(CFtpFolder * pff, HWND hwndOwner, CFtpView ** ppfv);
HRESULT CFtpSite_Create(LPCSTR pszSite, CFtpSite ** ppfs);
HRESULT CFtpPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CFtpPidlList ** ppfl);



void TriggerDelayedAction(LPGLOBALTIMEOUTINFO * phgti);
STDMETHODIMP SetDelayedAction(DELAYEDACTIONPROC pfn, LPVOID pvRef, LPGLOBALTIMEOUTINFO * phgti);
HRESULT PurgeDelayedActions(void);
BOOL AreOutstandingDelayedActions(void);

UINT FtpConfirmDeleteDialog(HWND hwnd, CFtpPidlList * pflHfpl, CFtpFolder * pff);
UINT FtpConfirmReplaceDialog(HWND hwnd, LPWIN32_FIND_DATA pwfdLocal, LPFTP_FIND_DATA pwfdRemote, int cobj, CFtpFolder * pff);
UINT FtpConfirmReplaceDialog(HWND hwnd, LPFTP_FIND_DATA pwfdLocal, LPWIN32_FIND_DATA pwfdRemote, int cobj, CFtpFolder * pff);

CFtpView * GetCFtpViewFromDefViewSite(IUnknown * punkSite);

/*****************************************************************************\
    FTP Notes and Issues

    Time/Date Stamps on FTP Files:
        There are two issues, the date on the server isn't time zone independent,
    and FTP/Wininet only do LastWriteTime (not CreationTime & LastAccessedTime).
    1. Corrdinated Universal Time (UTC) is the format to use to store time in
       a time zone indepndent manner.  Time displayed to the user then gets
       converted at the last moment so it's correct wrt the time zone.  FindFirstFile()
       does fill in the WIN32_FIND_DATA structure with UTC time, but wininet doesn't.
       This means that this FTP code can't do the UTC->LocalTime convertion when
       displaying the date/time.
    2. Only the modified date is sent via FTP.  Oh well, not to sever.

    Threading Issues:
        FTP can be called from several threads:
    1. Main UI Thread: CFtpFolder, ....
    2. Folder Contents Enum: CFtpFolder, IEnumIDList, CFtpDir, CFtpSite.
    2. AutoComplete Enum: CFtpFolder, IEnumIDList, CFtpDir, CFtpSite.

    PERF:
        1. We only cache an FTP session (InternetConnect()) for 10 seconds.  We should
           increase this to 50sec to 90 or maybe 120sec. This is currently done because
           we need to force the session to close down early when we are going to shutdown
           the process or try to unload our dll.
        2. Our Tree Walker code for recusrive operations (upload, download, delete) (in ftppl.cpp)
           calls FtpGetCurrentDirectory() and FtpSetCurrentDirectory() too often. To fix
           this, we need to verify we don't recurse into SOFTLINK directories because
           this is what requires the FtpGetCurrentDirectory.  This also could cause a
           recursion death bug and infinite loop.  We would then create
           ::_CacheChangeDir() and ::_CommitChangeDir() so the could remain
           simple but we would cache several Change Directories.
        3. If the desktop or desktop toolbars have FTP Shortcuts, the icon is
           extracted in such a way that we hit the net. Bad bad bad.
           Fix this, even if this mean hacking.
\*****************************************************************************/


// WARNING: Don't put any #defines or typedefs after the includes or they won't be recognized.
#include <shfusion.h>

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\proxycache.h ===
/*****************************************************************************\
    FILE: proxycache.h
    
    DESCRIPTION:
        FTP Folder uses WININET which doesn't work thru CERN proxies.  In that
    case, we need to hand control of the FTP URL back to the browser to do the
    old URLMON handling of it.  The problem is that testing for a CERN proxy
    blocking access is expensive.
\*****************************************************************************/

#ifndef _PROXYCACHE_H
#define _PROXYCACHE_H

// Public APIs (DLL wide)
BOOL ProxyCache_IsProxyBlocking(LPCITEMIDLIST pidl, BOOL * pfIsBlocking);
void ProxyCache_SetProxyBlocking(LPCITEMIDLIST pidl, BOOL fIsBlocking);

#endif // _PROXYCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\statusbr.h ===
/*****************************************************************************
 *	statusbr.h
 *****************************************************************************/

#ifndef _STATUSBAR_H
#define _STATUSBAR_H

#include <urlmon.h>

CStatusBar * CStatusBar_Create(HWND hwndStatus);

#define MAX_NUM_ZONES_ICONS         12

enum ICON_TODISPLAY
{
    ITD_WriteAllowed = 0,
    ITD_WriteNotAllowed,
    ITD_MAX
};

enum ICON_SLOT
{
    ISLOT_WritePermission = 0,
    ISLOT_MAX
};

#define STATUS_PANE_STATUS      0
#define STATUS_PANE_USERNAME    1
#define STATUS_PANE_ZONE        2
// #define STATUS_PANE_WRITEICON   4


/*****************************************************************************
 *
 *	CStatusBar
 *
 *****************************************************************************/

class CStatusBar
{
public:
    CStatusBar(HWND hwndStatus);
    ~CStatusBar(void);

    // Public Member Functions
    void SetStatusMessage(UINT nMessageID, LPCTSTR pszExtra);

    void SetUserName(LPCTSTR pszUserName, BOOL fAnnonymous);
    void SetFolderAttribute(BOOL fWriteAllowed);
    void UpdateZonesPane(LPCTSTR pszUrl);
    HRESULT Resize(LONG x, LONG y);

    friend CStatusBar * CStatusBar_Create(HWND hwndStatus) { return new CStatusBar(hwndStatus); };

protected:
    // Private Member Variables
    BOOL                    m_fInited : 1;
    BOOL                    m_fWriteAllowed : 1;

    HWND                    m_hwndStatus;                   // HWND for entire bar
    IInternetSecurityManager *  m_pism;
    IInternetZoneManager *  m_pizm;
    HICON                   m_arhiconZones[MAX_NUM_ZONES_ICONS];
    long                    m_lCurrentZone;
    HICON                   m_arhiconGeneral[ITD_MAX];

    LPTSTR                  m_pszUserName;
    LPTSTR                  m_pszUserNameTT;


    // Private Member Variables
    HRESULT _InitStatusBar(void);
    HRESULT _SetParts(void);

    HRESULT _SetIconAndTip(ICON_SLOT nIconSlot, ICON_TODISPLAY nIconToDisplay, LPCTSTR pszTip);
    HRESULT _LoadZoneInfo(LPCTSTR pszUrl);
    HRESULT _SetZone(void);
    void _SetUserParts(void);
    void _CacheZonesIcons(void);
};

#endif // _STATUSBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\security.h ===
/*****************************************************************************\
    FILE: security.h
\*****************************************************************************/

#ifndef _SECURITY_H
#define _SECURITY_H


BOOL ZoneCheckUrlAction(IUnknown * punkSite, DWORD dwAction, LPCTSTR pszUrl, DWORD dwFlags);
BOOL ZoneCheckPidlAction(IUnknown * punkSite, DWORD dwAction, LPCITEMIDLIST pidl, DWORD dwFlags);


#endif // _SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\resource.h ===
// Resource IDs for FTPFOLDR
//


#include <intlid.h>
#ifndef WC_LINK
#define WC_LINK         L"SysLink"
#endif // WC_LINK

#ifndef SS_CENTERIMAGE
#define SS_CENTERIMAGE       0x00000200L
#endif // SS_CENTERIMAGE

#ifndef SS_REALSIZECONTROL
#define SS_REALSIZECONTROL       0x00000040L
#endif // SS_REALSIZECONTROL

#include <commctrl.h>     // for WC_COMBOBOXEX



// This means the control won't have a name.
#define IDC_UNUSED          -1


/*****************************************************************************
 *
 *      Icons
 *
 *****************************************************************************/

//#define IDI_FTPSERVER       1               // Icon for an FTP Server
#define IDI_FTPSERVER       IDI_FTPFOLDER   // Icon for an FTP Server
#define IDI_FTPFOLDER       2               // Icon for a closed folder on a FTP Server
#define IDI_FTPOPENFOLDER   3               // Icon for an open folder on a FTP Server
#define IDI_FTPMULTIDOC     4               // Icon for several ftp items.
#define IDI_DELETEITEM      5               // Delete File
// 2 Holes
#define IDI_REPLACE         8               // File being overwritten
#define IDI_KEY             9               // Key icon for Login As dialog
#define IDI_NETFOLDER       IDI_FTPFOLDER   // Folder for Proxy Blocking dialog

#define IDI_WRITE_ALLOWED   10              // This folder has write access 
#define IDI_WRITE_NOTALLOWED 11             // This folder does not have read access 
#define IDC_WARNING         12              // Warning icon for Login As dialog

/*****************************************************************************
 *
 *      Menus
 *
 *****************************************************************************/

#define IDM_ITEMCONTEXT         1   // Context menu for items

#define IDM_M_FOLDERVERBS       0   // Verbs only for folders
#define IDM_M_FILEVERBS         1   // Verbs only for files
#define IDM_M_VERBS             2   // Verbs appropriate for all selected items (in addition to above)
#define IDM_M_SHAREDVERBS       3   // Verbs shared with defview (Common Shell verbs that aren't added in Context Menu)
#define IDM_M_BACKGROUNDVERBS   4   // Verbs for the background menu (only when nothing is selected)

#define IDM_M_BACKGROUND_POPUPMERGE     10   // Items that need to be merged with the current menu. (Arrange Items).

#define IDC_ITEM_OPEN           0   // &Open -- folders only
#define IDC_ITEM_EXPLORE        1   // &Explore -- folders only
#define IDC_ITEM_DOWNLOAD       2   // Do&wnload
#define IDC_ITEM_BKGNDPROP      3   // Properties for the background folder.
#define IDC_LOGIN_AS            4   // Login as...
#define IDC_ITEM_NEWFOLDER      5   // New Folder - Background Folder Only

#define IDC_ITEM_ABOUTSITE      6
#define IDC_ITEM_ABOUTFTP       7

#define IDM_SHARED_EDIT_CUT     8
#define IDM_SHARED_EDIT_COPY    9
#define IDM_SHARED_EDIT_PASTE   10
#define IDM_SHARED_FILE_LINK    11
#define IDM_SHARED_FILE_DELETE  12
#define IDM_SHARED_FILE_RENAME  13
#define IDM_SHARED_FILE_PROP    14

#define IDC_ITEM_FTPHELP        15

#define IDC_ITEM_MAX            16

/*****************************************************************************/

#define IDM_FTPMERGE            2    /* Menu bar */

/*
 *  These are biased by SFVIDM_CLIENT_FIRST and can go up to 255.
 *  However, IDM_SORT_* uses 0x30 through 0x3F.
 */
#define IDM_PROPERTIESBG        20

#define IDM_ID_DEBUG            0x40    /* 0x40 through 0x60 */

/*****************************************************************************/

#define IDM_DROPCONTEXT         3   /* Context menu for nondefault d/d */

/*****************************************************************************/

#define IDM_FOLDERCONTEXT       4   /* Context menu for folder background */

#define IDM_FOLDER_NEW          0
#define IDM_FOLDER_PROP         1

/*****************************************************************************\
    Shared dialog IDs

    Use these deltas whenever you want to use FtpDlg_InitDlg to
    initialize a group of controls based on a list of pidls.

    NOTE!  These cannot be an enum because the resource compiler doesn't
    understand enums.
\*****************************************************************************/

#define DLGTEML_FILENAME            0       // Name of file(s)
#define DLGTEML_FILENAMEEDITABLE    1       // Editable filename
#define DLGTEML_FILEICON            2       // Icon for file(s)
#define DLGTEML_FILESIZE            3       // Size of file(s)
#define DLGTEML_FILETIME            4       // Modification time of file(s)
#define DLGTEML_FILETYPE            5       // Type description for file(s)
#define DLGTEML_LOCATION            6       // Location of folder
#define DLGTEML_COUNT               7       // Location of count
#define DLGTEML_MAX                 8

#define DLGTEML_LABEL               20      // The label for an item (DLGTEML_FILENAME) equals (DLGTEML_FILENAME+DLGTEML_LABEL)

/*****************************************************************************
 *
 *      Derived dialog IDs
 *
 *****************************************************************************/

#define IDC_ITEM                110
#define IDC_FILENAME            (IDC_ITEM + DLGTEML_FILENAME)
#define IDC_FILENAME_EDITABLE   (IDC_ITEM + DLGTEML_FILENAMEEDITABLE)
#define IDC_FILEICON            (IDC_ITEM + DLGTEML_FILEICON)
#define IDC_FILESIZE            (IDC_ITEM + DLGTEML_FILESIZE)
#define IDC_FILETIME            (IDC_ITEM + DLGTEML_FILETIME)
#define IDC_FILETYPE            (IDC_ITEM + DLGTEML_FILETYPE)
#define IDC_LOCATION            (IDC_ITEM + DLGTEML_LOCATION)
#define IDC_COUNT               (IDC_ITEM + DLGTEML_COUNT)

#define IDC_FILETIME_LABEL      (IDC_ITEM + DLGTEML_FILETIME + DLGTEML_LABEL)
#define IDC_FILESIZE_LABEL      (IDC_ITEM + DLGTEML_FILESIZE + DLGTEML_LABEL)

#define IDC_ITEM2               120
#define IDC_FILENAME2           (IDC_ITEM2 + DLGTEML_FILENAME)
#define IDC_FILENAME_EDITABLE2  (IDC_ITEM2 + DLGTEML_FILENAMEEDITABLE)
#define IDC_FILEICON2           (IDC_ITEM2 + DLGTEML_FILEICON)
#define IDC_FILESIZE2           (IDC_ITEM2 + DLGTEML_FILESIZE)
#define IDC_FILETIME2           (IDC_ITEM2 + DLGTEML_FILETIME)
#define IDC_FILETYPE2           (IDC_ITEM2 + DLGTEML_FILETYPE)
#define IDC_LOCATION2           (IDC_ITEM2 + DLGTEML_LOCATION)
#define IDC_COUNT2              (IDC_ITEM2 + DLGTEML_COUNT)

#define IDC_FILETIME2_LABEL     (IDC_ITEM2 + DLGTEML_FILETIME + DLGTEML_LABEL)
#define IDC_FILESIZE2_LABEL     (IDC_ITEM2 + DLGTEML_FILESIZE + DLGTEML_LABEL)

/*****************************************************************************
 *
 *      Dialogs (and dialog controls)
 *
 *****************************************************************************/

#define IDD_REPLACE             1       /* File being overwritten */

#define IDC_REPLACE_YES         IDYES   /* Overwrite it */
#define IDC_REPLACE_YESTOALL    32      /* Overwrite it and everything else */
#define IDC_REPLACE_NO          IDNO    /* Skip this file */
#define IDC_REPLACE_NOTOALL     33      /* Skip all files that conflict */
#define IDC_REPLACE_CANCEL      IDCANCEL /* Stop copying */

#define IDC_REPLACE_OLDFILE     35      /* Description of old file */
#define IDC_REPLACE_NEWFILE     37      /* Description of new file */
#define IDC_REPLACE_NEWICON     38      /* Icon of new file */

/*****************************************************************************/

#define IDD_DELETEFILE          2       /* File being deleted */
#define IDD_DELETEFOLDER        3       /* Folder being deleted */
#define IDD_DELETEMULTI         4       /* Files/Folders being deleted */

/*****************************************************************************/

#define IDD_FILEPROP            32
#define IDC_READONLY            7

// Some items in the Login Dialog are the same across all three dialogs,
// but some change.
// These are the items that are all the same.
#define IDD_LOGINDLG                        40
#define IDC_LOGINDLG_FTPSERVER              (IDD_LOGINDLG + 1)
#define IDC_LOGINDLG_ANONYMOUS_CBOX         (IDD_LOGINDLG + 2)

// These are the items that are different.
#define IDC_LOGINDLG_USERNAME               (IDD_LOGINDLG + 3)
#define IDC_LOGINDLG_USERNAME_ANON          (IDD_LOGINDLG + 4)
#define IDC_LOGINDLG_MESSAGE_ANONREJECT     (IDD_LOGINDLG + 5)
#define IDC_LOGINDLG_MESSAGE_NORMAL         (IDD_LOGINDLG + 6)
#define IDC_LOGINDLG_MESSAGE_USERREJECT     (IDD_LOGINDLG + 7)
#define IDC_LOGINDLG_PASSWORD_DLG1          (IDD_LOGINDLG + 8)
#define IDC_LOGINDLG_PASSWORD_DLG2          (IDD_LOGINDLG + 9)
#define IDC_LOGINDLG_PASSWORD_LABEL_DLG1    (IDD_LOGINDLG + 10)
#define IDC_LOGINDLG_PASSWORD_LABEL_DLG2    (IDD_LOGINDLG + 11)
#define IDC_LOGINDLG_NOTES_DLG1             (IDD_LOGINDLG + 12)
#define IDC_LOGINDLG_NOTES_DLG2             (IDD_LOGINDLG + 13)
#define IDC_LOGINDLG_SAVE_PASSWORD          (IDD_LOGINDLG + 14)
#define IDC_LOGINDLG_LINK                   (IDD_LOGINDLG + 15)
#define IDC_LOGINDLG_NOTES_DLG3             (IDD_LOGINDLG + 16)
#define IDC_LOGINDLG_WARNING_ICON           (IDD_LOGINDLG + 17)



#define IDD_MOTDDLG                         80
#define IDC_MOTDDLG_MESSAGE                 (IDD_MOTDDLG + 1)

#define IDD_DOWNLOADDIALOG                  90
#define IDC_DOWNLOAD_MESSAGE                (IDD_DOWNLOADDIALOG + 1)
#define IDC_DOWNLOAD_TITLE                  (IDD_DOWNLOADDIALOG + 2)
#define IDC_DOWNLOAD_DIR                    (IDD_DOWNLOADDIALOG + 3)
#define IDC_BROWSE_BUTTON                   (IDD_DOWNLOADDIALOG + 4)
#define IDC_DOWNLOAD_AS                     (IDD_DOWNLOADDIALOG + 5)
#define IDC_DOWNLOAD_AS_LIST                (IDD_DOWNLOADDIALOG + 6)
#define IDC_DOWNLOAD_BUTTON                 (IDD_DOWNLOADDIALOG + 7)

#define DLG_MOVECOPYPROGRESS                100
#define IDD_ANIMATE                         (DLG_MOVECOPYPROGRESS + 1)
#define IDD_NAME                            (DLG_MOVECOPYPROGRESS + 2)
#define IDD_TONAME                          (DLG_MOVECOPYPROGRESS + 3)
#define IDD_TIMEEST                         (DLG_MOVECOPYPROGRESS + 5)
#define IDD_PROBAR                          (DLG_MOVECOPYPROGRESS + 4)

#define IDD_PROXYDIALOG                     110
#define IDC_PROXY_MESSAGE                   (IDD_PROXYDIALOG + 0)

#define IDD_CHMOD                           140
#define IDC_CHMOD_OR                        (IDD_CHMOD + 0)
#define IDC_CHMOD_OW                        (IDD_CHMOD + 1)
#define IDC_CHMOD_OE                        (IDD_CHMOD + 2)
#define IDC_CHMOD_GR                        (IDD_CHMOD + 3)
#define IDC_CHMOD_GW                        (IDD_CHMOD + 4)
#define IDC_CHMOD_GE                        (IDD_CHMOD + 5)
#define IDC_CHMOD_AR                        (IDD_CHMOD + 6)
#define IDC_CHMOD_AW                        (IDD_CHMOD + 7)
#define IDC_CHMOD_AE                        (IDD_CHMOD + 8)

#define IDC_CHMOD_LABEL_EXECUTE             (IDD_CHMOD + 9)
#define IDC_CHMOD_LABEL_PERM                (IDD_CHMOD + 10)
#define IDC_CHMOD_LABEL_OWNER               (IDD_CHMOD + 11)
#define IDC_CHMOD_LABEL_GROUP               (IDD_CHMOD + 12)
#define IDC_CHMOD_LABEL_ALL                 (IDD_CHMOD + 13)
#define IDC_CHMOD_LABEL_READ                (IDD_CHMOD + 14)
#define IDC_CHMOD_LABEL_WRITE               (IDD_CHMOD + 15)
#define IDC_CHMOD_GROUPBOX                  (IDD_CHMOD + 16)

#define IDC_CHMOD_LAST                      (IDD_CHMOD + 16)
#define IDC_CHMOD_NOT_ALLOWED               (IDD_CHMOD + 17)


/*****************************************************************************
 *
 *      Column headings (for details view)
 *
 *****************************************************************************/

#define COL_NAME            0
#define COL_SIZE            1
#define COL_TYPE            2
#define COL_MODIFIED        3
#define COL_MAX             4

#define IDM_SORT_FIRST        0x0030
#define IDM_SORTBYNAME        (IDM_SORT_FIRST + 0x0000)
#define IDM_SORTBYSIZE        (IDM_SORT_FIRST + 0x0001)
#define IDM_SORTBYTYPE        (IDM_SORT_FIRST + 0x0002)
#define IDM_SORTBYDATE        (IDM_SORT_FIRST + 0x0003)

#define CONVERT_IDMID_TO_COLNAME(idc)      ((idc) - IDM_SORT_FIRST)

#if CONVERT_IDMID_TO_COLNAME(IDM_SORTBYNAME) != COL_NAME || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYSIZE) != COL_SIZE || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYTYPE) != COL_TYPE || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYDATE) != COL_MODIFIED
#error FSIDM_ and ici are out of sync.
#endif

/*****************************************************************************
 *
 *      Strings
 *
 *****************************************************************************/

/* 0 ... 31 reserved for help text for IDC_ITEM_XXX menu commands */
#define IDS_ITEM_HELP(idc)       (idc)

/* 32 .. 39 reserved for title text for iciXXX column indices */
#define IDS_HEADER_NAME(ici)    (32+ici)

/* 40 .. 47 reserved for help text for iciXXX column indices */
#define IDS_HEADER_HELP(ici)    (40+ici)

/* 64 .. 95 reserved for progress feedback */
#define IDS_EMPTY               64
#define IDS_CONNECTING          65
#define IDS_CHDIR               66
#define IDS_LS                  67
#define IDS_DELETING            68
#define IDS_RENAMING            69
#define IDS_GETFINDDATA         70
#define IDS_COPYING             71
#define IDS_DOWNLOADING         72
#define IDS_DL_SRC_DEST         73
#define IDS_COPY_TITLE          74
#define IDS_MOVE_TITLE          75
#define IDS_DELETE_TITLE        76
#define IDS_DOWNLOAD_TITLE      77
#define IDS_DL_TYPE_AUTOMATIC   78
#define IDS_DL_TYPE_ASCII       79
#define IDS_DL_TYPE_BINARY      80
#define IDS_DL_SRC_DIR          81


#define IDA_FTPDOWNLOAD         0x100   // This matches IDA_DOWNLOAD (in shdocvw.dll)
#define IDA_FTPUPLOAD           0x101   // FS->Ftp Animation (in msieftp.dll)
#define IDA_FTPDELETE           0x102   // Ftp->Air (Hard Delete) (in msieftp.dll)

/* 256 onward are just random strings */
#define IDS_NUMBERK             256
#define IDS_NUMBERTB            257

#define IDS_HELP_MSIEFTPTITLE   258
#define IDS_HELP_ABOUTFOLDER    259
#define IDS_HELP_ABOUTBOX       260
#define IDS_HELP_WELCOMEMSGTITLE 261
#define IDS_PROP_SHEET_TITLE    262
#define IDS_PRETTYNAMEFORMAT    263
#define IDS_SEVERAL_SELECTED    264
#define IDS_ELLIPSES            265
#define IDS_NEW_FOLDER_FIRST    266
#define IDS_NEW_FOLDER_TEMPLATE 267
#define IDS_PRETTYNAMEFORMATA   268

#define IDS_CANTSHUTDOWN        280
#define IDS_PROGRESS_CANCEL     282
#define IDS_NO_MESSAGEOFTHEDAY  285
#define IDS_ITEMTYPE_FOLDER     286
#define IDS_ITEMTYPE_SERVER     287
#define IDS_PROGRESS_UPLOADTIMECALC   288
#define IDS_PROGRESS_DELETETIMECALC   289
#define IDS_PROGRESS_DOWNLOADTIMECALC 290
#define IDS_OFFLINE_PROMPTTOGOONLINE  291
#define IDS_RECYCLE_IS_PERM_WARNING   292

// STATUS BAR Strings

// Status Bar Icon ToolTips
// These Text Strings are the tool tips for the icons.
#define IDS_BEGIN_SB_TOOLTIPS   300
#define IDS_WRITE_ALLOWED       300              // This folder has write access 
#define IDS_WRITE_NOTALLOWED    301              // This folder does not have read access 

// Progress Bar ToolTips
#define IDS_PROG_ZERO           330              // Zero percent.
#define IDS_PROG_NPERCENT       331              // n percent.
#define IDS_PROG_DONE           332              // 100 percent.

// Zones
#define IDS_ZONES_UNKNOWN       340              // Unknown Zone
#define IDS_ZONES_TOOLTIP       341              // Zone Status Bar Pane Tooltip

// User Status Bar Pane
#define IDS_USER_TEMPLATE       350              // "User: <UserName>"
#define IDS_USER_ANNONYMOUS     351               // <UserName> = "Annonymous"
#define IDS_USER_USERTOOLTIP    352              // Info on type of user log-in. (non-Annonymously)
#define IDS_USER_ANNONTOOLTIP   353              // Info on type of user log-in. (Annonymously)

#define IDS_LOGIN_WEBDAVLINK    354              // This is the hyperlink we launch when the user clicks on the WebDAV security link

// FTP Errors
#define IDS_FTPERR_TITLE            400              // Title for Messages.
#define IDS_FTPERR_TITLE_ERROR      401              // Title for Error Messages.
#define IDS_FTPERR_UNKNOWN          402              // Unknown error.
#define IDS_FTPERR_WININET          403              // Prep Wininet Error
#define IDS_FTPERR_WININET_CONTINUE 404          // Prep Wininet Error and ask if user wants to continue
#define IDS_FTPERR_FILECOPY         405              // Error putting file on FTP Server
#define IDS_FTPERR_DIRCOPY          406              // Error Creating a directory on the FTP Server
#define IDS_FTPERR_FILERENAME       407              // Error renaming file on FTP Server
#define IDS_FTPERR_CHANGEDIR        408              // Error opening that folder on the FTP Server
#define IDS_FTPERR_DELETE           409              // Error deleting that folder or file on the FTP Server
#define IDS_FTPERR_OPENFOLDER       410              // Error opening that folder on the FTP Server
#define IDS_FTPERR_FOLDERENUM       411              // Error getting the rest of the file names in the folder on the FTP Server
#define IDS_FTPERR_NEWFOLDER        412              // Error create a new folder on the FTP Server
#define IDS_FTPERR_DROPFAIL         413              // Error dropping a file or folder.
#define IDS_FTPERR_INVALIDFTPNAME   414            // This file name isn't a valid FTP File Name.  Maybe unicode.
#define IDS_FTPERR_CREATEDIRPROMPT  415           // The directory doesn't exist, do you want to create it?
#define IDS_FTPERR_CREATEFAILED     416              // Attempting to create the directory failed.
#define IDS_FTPERR_GETDIRLISTING    417             // An error occured reading the contents of the folder
#define IDS_FTPERR_DOWNLOADING      418             // Download failed
#define IDS_FTPERR_RENAME_REPLACE   419           // A file with this name already exists.  Do you want to replace that file?
#define IDS_FTPERR_RENAME_EXT_WRN   420           // If you change a filename extension, the file may become unusable.\n\nAre you sure you want to change it?
#define IDS_FTPERR_RENAME_TITLE     421           // Rename title ("Rename")
#define IDS_FTP_PROXY_WARNING       422           // The folder '%s' is currently read-only.\n\nThe proxy server to which you are connected will only enable...
#define IDS_FTPERR_CHMOD            423           // An error occured changing the permissions on the file or folder on the FTP Server.  Make sure you have permission to change this item.
#define IDS_FTPERR_BAD_DL_TARGET    424           // Bad dir chosen in SHBrowseForFolder


// Login Dialog Message
#define IDS_LOGIN_LOGINAS           450              // 
#define IDS_LOGIN_SERVER            451              // 


// Dialog Strings
#define IDS_DLG_DOWNLOAD_TITLE      500              // Title for the 'Choose Download Directory' dialog.



#define IDS_INSTALL_TEMPLATE        700              // 
// do not use 701
#define IDS_INSTALL_TEMPLATE_NT5    702              // 
// or 703


// HTML dialog resources
#define RT_FILE                     2110


#define IDC_MESSAGECHECKEX          0x1202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\security.cpp ===
/*****************************************************************************\
    FILE: security.h
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include <imm.h>
#include <mshtml.h>

BOOL ProcessUrlAction(IUnknown * punkSite, LPCTSTR pszUrl, DWORD dwAction, DWORD dwFlags)
{
    BOOL fAllowed = FALSE;

    if (pszUrl) 
    {
        IInternetSecurityManager *pSecMgr;
        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IInternetSecurityManager, 
                                       (void **)&pSecMgr))) 
        {
            WCHAR wzUrl[MAX_URL_STRING];
            DWORD dwZoneID = URLZONE_UNTRUSTED;
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            IUnknown_SetSite(pSecMgr, punkSite);
            SHTCharToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));
            if (S_OK == pSecMgr->ProcessUrlAction(wzUrl, dwAction, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&dwContext, sizeof(dwContext), dwFlags, 0))
            {
                if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
                    fAllowed = TRUE;
            }
            IUnknown_SetSite(pSecMgr, NULL);
            pSecMgr->Release();
        }
    } 

    return fAllowed;
}


/*****************************************************************************\
    FUNCTION: SecurityZoneCheck
    
    PARAMETERS:
        punkSite: Site for QS, and enabling modal if UI needed.
        dwAction: verb to check. normally URLACTION_SHELL_VERB
        pidl: FTP URL that we need to verify
        pszUrl: FTP URL that we need to verify
        dwFlags: normally PUAF_DEFAULT | PUAF_WARN_IF_DENIED

    DESCRIPTION:
        Only pidl or pszUrl is passed.  This function will check if the verb
    (dwAction) is allowed in this zone.  Our first job is to find the zone which
    can be any of the following:
    1. Third party app that supports IInternetHostSecurityManager have a chance to disallow the action.
    2. Hosted in DefView w/WebView.  Zone of WebView can fail the action.
    3. Hosted in HTML FRAME.  Zone comes from trident can fail the action
    4. Hosted in DefView w/o WebView.  Zone comes from pidl or pszUrl and that can fail the action.
\*****************************************************************************/
BOOL ZoneCheckUrlAction(IUnknown * punkSite, DWORD dwAction, LPCTSTR pszUrl, DWORD dwFlags)
{
    BOOL IsSafe = TRUE; // Assume we will allow this.
    IInternetHostSecurityManager * pihsm;

    // What we want to do is allow this to happen only if the author of the HTML that hosts
    // the DefView is safe.  It's OK if they point to something unsafe, because they are
    // trusted.
    // 1. Third party app that supports IInternetHostSecurityManager have a chance to disallow the action.
    if (SUCCEEDED(IUnknown_QueryService(punkSite, IID_IInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pihsm)))
    {
        if (S_OK != ZoneCheckHost(pihsm, dwAction, dwFlags))
        {
            // This zone is not OK or the user choose to not allow this to happen,
            // so cancel the operation.
            IsSafe = FALSE;    // Turn off functionality.
        }

        pihsm->Release();
    }

    // 1. Hosted in DefView w/WebView.  Zone of WebView can fail the action.
    if (IsSafe)
    {
        IOleCommandTarget * pct;

        if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_IOleCommandTarget, (void **)&pct)))
        {
            VARIANT vTemplatePath;
            vTemplatePath.vt = VT_EMPTY;
            if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vTemplatePath) == S_OK)
            {
                if ((vTemplatePath.vt == VT_BSTR) && (S_OK != LocalZoneCheckPath(vTemplatePath.bstrVal, punkSite)))
                    IsSafe = FALSE;

                // We were able to talk to the browser, so don't fall back on Trident because they may be
                // less secure.
                VariantClear(&vTemplatePath);
            }
            pct->Release();
        }
    }
    
    // 3. Hosted in HTML FRAME.  Zone comes from trident can fail the action
    if (IsSafe)
    {
        // Try to use the URL from the document to zone check 
        IHTMLDocument2 *pHtmlDoc;
        if (punkSite && SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR bstrPath;
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrPath)))
            {
                if (S_OK != ZoneCheckHost(pihsm, dwAction, dwFlags))
                {
                    // This zone is not OK or the user choose to not allow this to happen,
                    // so cancel the operation.
                    IsSafe = FALSE;    // Turn off functionality.
                }
                SysFreeString(bstrPath);
            }
            pHtmlDoc->Release();
        }
    }

    // 4. Hosted in DefView w/o WebView.  Zone comes from pidl or pszUrl and that can fail the action.
    if (IsSafe)
    {
        IsSafe = ProcessUrlAction(punkSite, pszUrl, dwAction, dwFlags);
    }

    return IsSafe;
}

//*/
BOOL ZoneCheckPidlAction(IUnknown * punkSite, DWORD dwAction, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    TCHAR szUrl[MAX_URL_STRING];

    if (FAILED(UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), FALSE)))
        return FALSE;

    return ZoneCheckUrlAction(punkSite, dwAction, szUrl, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\proxycache.cpp ===
/*****************************************************************************\
    FILE: proxycache.cpp
    
    DESCRIPTION:
        FTP Folder uses WININET which doesn't work thru CERN proxies.  In that
    case, we need to hand control of the FTP URL back to the browser to do the
    old URLMON handling of it.  The problem is that testing for a CERN proxy
    blocking access is expensive.
\*****************************************************************************/

#include "priv.h"
#include "util.h"

#define PROXY_CACHE_SIZE    15

typedef struct
{
    TCHAR szServerName[INTERNET_MAX_HOST_NAME_LENGTH];
    BOOL fIsBlocking;
} PROXYCACHEENTRY;

static int g_nLastIndex = 0;
static BOOL g_fInited = FALSE;
static TCHAR g_szProxyServer[MAX_URL_STRING] = {0};
static PROXYCACHEENTRY g_ProxyCache[PROXY_CACHE_SIZE];






/////////////////////////////////////////////////////////////////////////
///////  Private helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

void ProxyCache_Init(void)
{
    g_nLastIndex = 0;

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_ProxyCache); nIndex++)
    {
        g_ProxyCache[nIndex].fIsBlocking = FALSE;
        g_ProxyCache[nIndex].szServerName[0] = 0;
    }

    g_fInited = TRUE;
}


/****************************************************\
    FUNCTION: ProxyCache_WasProxyChanged

    DESCRIPTION:
        See if someone changed the proxy settings via
    the inetcpl.  This is important because it is
    frustration to find FTP fails because of the proxy
    settings, fix the proxy settings, and then it still
    doesn't work because we cached the results.
\****************************************************/
BOOL ProxyCache_WasProxyChanged(void)
{
    BOOL fWasChanged = FALSE;
    TCHAR szCurrProxyServer[MAX_URL_STRING];
    DWORD cbSize = SIZEOF(szCurrProxyServer);

    // PERF: If I wanted to be really fast, I would cache the hkey
    //       so this would be faster.  But since my DLL can be loaded/unloaded
    //       serveral times in a process, I would leak each instance unless I
    //       released the hkey in DLL_PROCESS_DETACH
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS_LAN, SZ_REGVALUE_PROXY_SERVER, NULL, szCurrProxyServer, &cbSize))
    {
        // Is this the first time? (Is g_szProxyServer empty?)
        if (!g_szProxyServer[0])
            StrCpyN(g_szProxyServer, szCurrProxyServer, ARRAYSIZE(g_szProxyServer));

        // Did it change?
        if (StrCmp(szCurrProxyServer, g_szProxyServer))
            fWasChanged = TRUE;
    }

    return fWasChanged;
}



/////////////////////////////////////////////////////////////////////////
///////  APIs helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


/****************************************************\
    FUNCTION: ProxyCache_IsProxyBlocking

    DESCRIPTION:
        Look in the cache with the FTP server in pidl
    and see if we have a cached value that indicates
    if it's blocked by the proxy.

    PARAMETERS:
        *pfIsBlocking - Is the proxy blocking.
        return - Is the value cached
\****************************************************/
BOOL ProxyCache_IsProxyBlocking(LPCITEMIDLIST pidl, BOOL * pfIsBlocking)
{
    BOOL fIsInCache = FALSE;

    if (ProxyCache_WasProxyChanged())
        ProxyCache_Init();  // Purge the results

    *pfIsBlocking = FALSE;  // Assume we don't know.
    if (!g_fInited)
    {
        ProxyCache_Init();
    }
    else
    {
        int nCount = ARRAYSIZE(g_ProxyCache);
        TCHAR szNewServer[INTERNET_MAX_HOST_NAME_LENGTH];

        // Is this the same server we tried last time?  If so,
        // let's just cache the return value.
        FtpPidl_GetServer(pidl, szNewServer, ARRAYSIZE(szNewServer));
        for (int nIndex = g_nLastIndex; nCount && g_ProxyCache[nIndex].szServerName[0]; nCount--, nIndex--)
        {
            if (nIndex < 0)
                nIndex = (PROXY_CACHE_SIZE - 1);

            if (!StrCmp(szNewServer, g_ProxyCache[nIndex].szServerName))
            {
                // Yes, so bail.
                *pfIsBlocking = g_ProxyCache[nIndex].fIsBlocking;
                fIsInCache = TRUE;
                break;
            }
        }
    }

    return fIsInCache;
}


/****************************************************\
    FUNCTION: ProxyCache_SetProxyBlocking

    DESCRIPTION:

    PARAMETERS:
        *pfIsBlocking - Is the proxy blocking.
        return - Is the value cached
\****************************************************/
void ProxyCache_SetProxyBlocking(LPCITEMIDLIST pidl, BOOL fIsBlocking)
{
    TCHAR szNewServer[INTERNET_MAX_HOST_NAME_LENGTH];

    // Add it to the cache because our caller will hit the server to
    // verify and we can be ready for next time.
    g_nLastIndex++;
    if (g_nLastIndex >= PROXY_CACHE_SIZE)
        g_nLastIndex = 0;

    FtpPidl_GetServer(pidl, szNewServer, ARRAYSIZE(szNewServer));
    StrCpyN(g_ProxyCache[g_nLastIndex].szServerName, szNewServer, ARRAYSIZE(g_ProxyCache[g_nLastIndex].szServerName));
    g_ProxyCache[g_nLastIndex].fIsBlocking = fIsBlocking;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\statusbr.cpp ===
/*****************************************************************************
 *
 *      statusbr.cpp - Take care of the status bar.
 *
 *****************************************************************************/

#include "priv.h"
#include "statusbr.h"

// HACKHACK: 
//      \nt\public\sdk\inc\multimon.h overrides the normal GetSystemMetrics() with
//      xGetSystemMetrics().  The problem is that you can't link because you need to
//      have at least one file in your project that #defines COMPILE_MULTIMON_STUBS
//      so that these stub override functions will get implemented.
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"


#define PANE_WIDTH_USERNAME     125
#define STATUS_PANES            3


//////////////////////////////////////////////////////////////////
//  General Text Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::SetStatusMessage(UINT nMessageID, LPCTSTR pszExtra)
{
    if (NULL == this)
        return;

    _InitStatusBar();       // This is a NO-OP if it's already inited.

    ASSERTNONCRITICAL;
    if (m_hwndStatus)
    {
        TCHAR szMsg[256] = TEXT("%s");
        TCHAR szBuf[1024];

        if (nMessageID)
            LoadString(g_hinst, nMessageID, szMsg, ARRAYSIZE(szMsg));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szMsg, pszExtra);

//        TraceMsg(TF_FTPSTATUSBAR, "CStatusBar::SetStatusMessage() Message=%s", szBuf);
        SendMessage(m_hwndStatus, SB_SETTEXT, STATUS_PANE_STATUS, (LPARAM)szBuf);
        SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_STATUS, (LPARAM)szBuf);
        UpdateWindow(m_hwndStatus);
    }
}


//////////////////////////////////////////////////////////////////
//  User Name Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::SetUserName(LPCTSTR pszUserName, BOOL fAnnonymous)
{
    TCHAR szTipText[MAX_PATH];
    TCHAR szStrTemplate[MAX_PATH];

    _InitStatusBar();       // This is a NO-OP if it's already inited.
    //TraceMsg(TF_FTPSTATUSBAR, "CStatusBar::SetUserName(pszUserName=%s, fAnnonymous=%d)", pszUserName, fAnnonymous);

    ASSERT(pszUserName);
    LoadString(HINST_THISDLL, IDS_USER_TEMPLATE, szStrTemplate, ARRAYSIZE(szStrTemplate));

    if (fAnnonymous)
    {
        TCHAR szAnnonymousName[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_USER_ANNONYMOUS, szAnnonymousName, ARRAYSIZE(szAnnonymousName));
        wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, szAnnonymousName);
    }
    else
        wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, pszUserName);
        

    Str_SetPtr(&m_pszUserName, szTipText);

    LoadString(HINST_THISDLL, (fAnnonymous ? IDS_USER_ANNONTOOLTIP : IDS_USER_USERTOOLTIP), szStrTemplate, ARRAYSIZE(szStrTemplate));
    wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, pszUserName);
    Str_SetPtr(&m_pszUserNameTT, szTipText);
    _SetUserParts();
}


void CStatusBar::_SetUserParts(void)
{
    SendMessage(m_hwndStatus, SB_SETTEXT, STATUS_PANE_USERNAME, (LPARAM)(m_pszUserName ? m_pszUserName : TEXT("")));
    SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_USERNAME, (LPARAM)(m_pszUserNameTT ? m_pszUserNameTT : TEXT("")));
}


//////////////////////////////////////////////////////////////////
//  Icons Panes (Read, Write, ...)
//////////////////////////////////////////////////////////////////

#define GET_RESID_FROM_PERMISSION(nType, nAllowed)  (IDS_BEGIN_SB_TOOLTIPS + nType + (nAllowed ? 0 : 1))

void CStatusBar::SetFolderAttribute(BOOL fWriteAllowed)
{
    TCHAR szToolTip[MAX_PATH];

    _InitStatusBar();       // This is a NO-OP if it's already inited.

    m_fWriteAllowed = fWriteAllowed;
    LoadString(HINST_THISDLL, GET_RESID_FROM_PERMISSION(ITD_WriteAllowed, fWriteAllowed), szToolTip, ARRAYSIZE(szToolTip));
    _SetIconAndTip(ISLOT_WritePermission, fWriteAllowed ? ITD_WriteAllowed : ITD_WriteNotAllowed, szToolTip);
}

HRESULT CStatusBar::_SetIconAndTip(ICON_SLOT nIconSlot, ICON_TODISPLAY nIconToDisplay, LPCTSTR pszTip)
{
    /*
    if (EVAL(m_hwndStatus))
    {
        if (!m_arhiconGeneral[nIconToDisplay])
        {
            m_arhiconGeneral[nIconToDisplay] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(nIconToDisplay + IDI_WRITE_ALLOWED), 
                IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
        }

        SendMessage(m_hwndStatus, SB_SETICON, STATUS_PANE_WRITEICON, (LPARAM)m_arhiconGeneral[nIconToDisplay]);
        SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_WRITEICON, (LPARAM)pszTip);
    }
*/
    return S_OK;
}


//////////////////////////////////////////////////////////////////
//  Zones Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::UpdateZonesPane(LPCTSTR pszUrl)
{
    _InitStatusBar();       // This is a NO-OP if it's already inited.
    if (EVAL(SUCCEEDED(_LoadZoneInfo(pszUrl))))
        EVAL(SUCCEEDED(_SetZone()));
}

HRESULT CStatusBar::_LoadZoneInfo(LPCTSTR pszUrl)
{
    m_lCurrentZone = ZONE_UNKNOWN;
    if (!m_pism)
        CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (void **)&m_pism);

    if (m_pism)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        SHTCharToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));
        m_pism->MapUrlToZone(wzUrl, (DWORD*)&m_lCurrentZone, 0);
    }        

    return S_OK;
}

HRESULT CStatusBar::_SetZone(void)
{
    ZONEATTRIBUTES za = {SIZEOF(za)};
    HICON hIcon = NULL;
            
    if (!m_arhiconZones[0])
        _CacheZonesIcons();
            
    if (m_pizm && (m_lCurrentZone != ZONE_UNKNOWN))
    {
        m_pizm->GetZoneAttributes(m_lCurrentZone, &za);
        hIcon = m_arhiconZones[m_lCurrentZone];
    }
    else
        _LoadStringW(HINST_THISDLL, IDS_ZONES_UNKNOWN, za.szDisplayName, ARRAYSIZE(za.szDisplayName));
    
    SendMessage(m_hwndStatus, SB_SETTEXTW, STATUS_PANE_ZONE, (LPARAM)za.szDisplayName);
    SendMessage(m_hwndStatus, SB_SETTIPTEXTW, STATUS_PANE_ZONE, (LPARAM)za.szDisplayName);
    SendMessage(m_hwndStatus, SB_SETICON, STATUS_PANE_ZONE, (LPARAM)hIcon);
    return S_OK;
}

void CStatusBar::_CacheZonesIcons(void)
{
    DWORD dwZoneCount = 0;

    if (!m_pizm)
        CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetZoneManager, (void **)&m_pizm);
    
    if (m_pizm)
    {
        DWORD dwZoneEnum;

        if (EVAL(SUCCEEDED(m_pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0))))
        {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};
                WORD            iIcon=0;
                HICON           hIcon = NULL;

                m_pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                m_pizm->GetZoneAttributes(dwZone, &za);

                // Zone icons are in two formats.
                // wininet.dll#1200 where 1200 is the res id.
                // or foo.ico directly pointing to an icon file.
                // search for the '#'
                LPWSTR pwsz = StrChrW(za.szIconPath, TEXTW('#'));

                if (pwsz)
                {
                    TCHAR           szIconPath[MAX_PATH];        
                    // if we found it, then we have the foo.dll#00001200 format
                    pwsz[0] = TEXTW('\0');
                    SHUnicodeToTChar(za.szIconPath, szIconPath, ARRAYSIZE(szIconPath));
                    iIcon = (WORD)StrToIntW(pwsz+1);
                    ExtractIconEx(szIconPath,(INT)(-1*iIcon), NULL, &hIcon, 1 );
                }
                else
                    hIcon = (HICON)ExtractAssociatedIconExW(HINST_THISDLL, za.szIconPath, (LPWORD)&iIcon, &iIcon);
                    
                if (nIndex < MAX_NUM_ZONES_ICONS)
                     m_arhiconZones[nIndex] = hIcon;
            }
            m_pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }    
}


HRESULT CStatusBar::Resize(LONG x, LONG y)
{
    return _SetParts();
}


//////////////////////////////////////////////////////////////////
//  General Functions
//////////////////////////////////////////////////////////////////

HRESULT CStatusBar::_InitStatusBar(void)
{
    HRESULT hr = S_OK;

    // Only reformat the StatusBar if we haven't yet, or
    // if someone formatted it away from us. (@!%*#)
    if ((!m_fInited) ||
        (STATUS_PANES != SendMessage(m_hwndStatus, SB_GETPARTS, 0, 0L)))
    {
        m_fInited = TRUE;
        hr = _SetParts();
    }

    return hr;
}


HRESULT CStatusBar::_SetParts(void)
{
    HRESULT hr = S_OK;
    RECT rc;

    ASSERTNONCRITICAL;

#ifdef OLD_STYLE_STATUSBAR
    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
#else // OLD_STYLE_STATUSBAR

    GetClientRect(m_hwndStatus, &rc);
    const UINT cxZone = ZoneComputePaneSize(m_hwndStatus);
    const UINT cxUserName = PANE_WIDTH_USERNAME;

    INT nStatusBarWidth = rc.right - rc.left;                             
    INT arnRtEdge[STATUS_PANES] = {1};
    INT nIconPaneWidth = GetSystemMetrics(SM_CXSMICON) + (GetSystemMetrics(SM_CXEDGE) * 4);
    INT nWidthReqd = cxZone + cxUserName + (nIconPaneWidth * 1);

    arnRtEdge[STATUS_PANE_STATUS] = max(1, nStatusBarWidth - nWidthReqd);

    nWidthReqd -= cxUserName;
    arnRtEdge[STATUS_PANE_USERNAME] = max(1, nStatusBarWidth - nWidthReqd);

    /*
    nWidthReqd -= (nIconPaneWidth);
    arnRtEdge[STATUS_PANE_WRITEICON] = max(1, nStatusBarWidth - nWidthReqd);
    */

    arnRtEdge[STATUS_PANE_ZONE] = -1;

    LRESULT nParts = 0;
    nParts = SendMessage(m_hwndStatus, SB_GETPARTS, 0, 0L);
    if (nParts != STATUS_PANES)
    {
        for ( int n = 0; n < nParts; n++)
        {
            SendMessage(m_hwndStatus, SB_SETTEXT, n, NULL);
            SendMessage(m_hwndStatus, SB_SETICON, n, NULL);
        }
        SendMessage(m_hwndStatus, SB_SETPARTS, 0, 0L);
    }

    SendMessage(m_hwndStatus, SB_SETPARTS, STATUS_PANES, (LPARAM)arnRtEdge);

    SendMessage(m_hwndStatus, SB_GETRECT, 1, (LPARAM)&rc);
    InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));

    SendMessage(m_hwndStatus, SB_SETTEXT, 1, (LPARAM)SZ_EMPTY);
    SendMessage(m_hwndStatus, SB_SETMINHEIGHT, GetSystemMetrics(SM_CYSMICON) + GetSystemMetrics(SM_CYBORDER) * 2, 0L);
    _SetZone();
    _SetUserParts();

#endif // OLD_STYLE_STATUSBAR
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CStatusBar::CStatusBar(HWND hwndStatus)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pism);
    ASSERT(!m_pizm);
    ASSERT(!m_pszUserName);
    ASSERT(!m_pszUserNameTT);

    m_hwndStatus = hwndStatus;
    m_lCurrentZone = ZONE_UNKNOWN;

    LEAK_ADDREF(LEAK_CStatusBar);
}


/****************************************************\
    Destructor
\****************************************************/
CStatusBar::~CStatusBar(void)
{
    int nIndex;

    IUnknown_Set((IUnknown **) &m_pism, NULL);
    IUnknown_Set((IUnknown **) &m_pizm, NULL);

    Str_SetPtr(&m_pszUserName, NULL);
    Str_SetPtr(&m_pszUserNameTT, NULL);

    for (nIndex = 0; nIndex < MAX_NUM_ZONES_ICONS; nIndex++)
    {
        if (m_arhiconZones[nIndex])
            DestroyIcon(m_arhiconZones[nIndex]);
    }

    for (nIndex = 0; nIndex < ITD_MAX; nIndex++)
    {
        if (m_arhiconGeneral[nIndex])
            DestroyIcon(m_arhiconGeneral[nIndex]);
    }

    ASSERTNONCRITICAL;
    SendMessage(m_hwndStatus, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);

    DllRelease();
    LEAK_DELREF(LEAK_CStatusBar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\unithunk.h ===
/*****************************************************************************\
    FILE: unithunk.h
\*****************************************************************************/

#ifndef _UNICODE_THUNK_WRAPPERS_H
#define _UNICODE_THUNK_WRAPPERS_H



#define POST_IE5_BETA

// NOTES:
//    CharPrevW and lstrcpyW doesn't appear to be used in our code.
//
// The .map file will show that we link to MessageBoxW and GetNumberFormatW but
// that is okay because we only use it on NT.

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
#ifndef USE_IE5_UTILS
#define IUnknown_Set                    UnicWrapper_IUnknown_Set
#define SHWaitForSendMessageThread      UnicWrapper_SHWaitForSendMessageThread
#define AutoCompleteFileSysInEditbox    UnicWrapper_AutoCompleteFileSysInEditbox

void            UnicWrapper_IUnknown_Set(IUnknown ** ppunk, IUnknown * punk);
DWORD UnicWrapper_SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
HRESULT AutoCompleteFileSysInEditbox(HWND hwndEdit);

#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////


#endif // _UNICODE_THUNK_WRAPPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\util.h ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "encoding.h"
#include "ftpfoldr.h"
#include "ftpdir.h"
#include "ftpsite.h"
#include "ftplist.h"
#include "ftpefe.h"
#include "ftpglob.h"
#include "ftpcm.h"
#include "ftpstm.h"
#include "dllload.h"
#include "security.h"

// Don't ship with this on.  Only for BryanSt's debugging
//#define DEBUG_WININET_BREAKS

#define DOES_POINTER_MATCHES_HRESULT(pointer, hr)         ((pointer && SUCCEEDED(hr)) || (!pointer && FAILED(hr)))
#define ASSERT_POINTER_MATCHES_HRESULT(pointer, hr)       ASSERT(DOES_POINTER_MATCHES_HRESULT((pointer), hr))
#define EVAL_POINTER_MATCHES_HRESULT(pointer, hr)         EVAL(DOES_POINTER_MATCHES_HRESULT((pointer), hr)

extern "C" void *_ReturnAddress();

#pragma intrinsic(_ReturnAddress)

#ifdef DEBUG    // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG
#define CREATE_CALLERS_ADDRESS
#define GET_CALLERS_ADDRESS        _ReturnAddress()

#ifdef DEBUG_WININET_BREAKS
#define WININET_ASSERT(val)         ASSERT(val)
#endif // DEBUG_WININET_BREAKS

void TraceMsgWithCurrentDir(DWORD dwTFOperation, LPCSTR pszMessage, HINTERNET hint);
void DebugStartWatch(void);
DWORD DebugStopWatch(void);
#else // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG
#define CREATE_CALLERS_ADDRESS     NULL;
#define GET_CALLERS_ADDRESS        0x00000000

#define TraceMsgWithCurrentDir(dwTFOperation, pszMessage, hint)         NULL;
#define DebugStartWatch()                                               NULL;
#define DebugStopWatch()                                                0
#endif  // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG

#ifndef WININET_ASSERT
#define WININET_ASSERT(val)         NULL
#endif // DEBUG_WININET_BREAKS





#define ChooseWindow(hwnd1, hwnd2)           (hwnd1 ? hwnd1 : hwnd2)
typedef BOOL (*HGLOBWITHPROC)(LPVOID pv, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode);

int SHMessageBox(HWND hwnd, LPCTSTR pszMessage, UINT uMessageID, UINT uTitleID, UINT uType);
//HRESULT ShellExecFtpUrl(LPCTSTR pszUrl);
//HRESULT ShellExecFtpPidl(LPCITEMIDLIST pidl);


// SHChangeNotify() wrappers that will update our cache of the FTP server contents before
//   calling SHChangeNotify().  This will make sure DefView still has valid dates when it
//   converts the pidl passed to SHChangeNotify() to a display name and then has us turn
//   it back into a pidl via ::ParseDisplayName().  DefView does this to
void FtpChangeNotify(HWND hwnd, LONG wEventId, CFtpFolder * pff, CFtpDir * pfd, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fTopLevel);

BOOL IsLegacyChangeNotifyNeeded(LONG wEventId);
HRESULT ForceDefViewRefresh(HWND hwnd, LPCITEMIDLIST pidl);
DWORD GetOSVer(void);
BOOL IsOSNT(void);


#define HANDLE_NULLSTR(str)         (str ? str : SZ_EMPTY)
#define HANDLE_NULLSTRA(str)         (str ? str : "")

// Allocation Helper Funcitions
void            IUnknown_Set(IMalloc ** ppm, IMalloc * pm);
void            IUnknown_Set(CFtpFolder ** ppff, CFtpFolder * pff);
void            IUnknown_Set(CFtpDir ** ppfd, CFtpDir * pfd);
void            IUnknown_Set(CFtpSite ** ppfs, CFtpSite * pfs);
void            IUnknown_Set(CFtpList ** ppfl, CFtpList * pfl);
void            IUnknown_Set(CFtpPidlList ** ppflpidl, CFtpPidlList * pflpidl);
void            IUnknown_Set(CFtpEfe ** ppfefe, CFtpEfe * pfefe);
void            IUnknown_Set(CFtpGlob ** ppfg, CFtpGlob * pfg);
void            IUnknown_Set(CFtpMenu ** ppfcm, CFtpMenu * pfcm);
void            IUnknown_Set(CFtpStm ** ppfstm, CFtpStm * pfstm);

HRESULT IUnknown_PidlNavigate(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry);
//HRESULT IUnknown_UrlNavigate(IUnknown * punk, LPCTSTR pszUrl);
DWORD StrListLength(LPCTSTR ppszStrList);

#ifdef UNICODE
#define TCharSysAllocString(psz)    SysAllocString(psz)
#define Str_StrAndThunk             Str_StrAndThunkW
#else
extern BSTR AllocBStrFromString(LPCTSTR);
#define TCharSysAllocString(psz)    AllocBStrFromString(psz)
#define Str_StrAndThunk             Str_StrAndThunkA
#endif

HRESULT Str_StrAndThunkW(LPTSTR * ppszOut, LPCWSTR pwzIn, BOOL fStringList);
HRESULT Str_StrAndThunkA(LPTSTR * ppszOut, LPCSTR pszIn, BOOL fStringList);

DWORD   GetUrlSchemeA(LPCSTR psz);
DWORD   GetUrlSchemeW(LPCWSTR pwz);


DWORD Misc_SfgaoFromFileAttributes(DWORD dwFAFLFlags);
HRESULT Misc_StringFromFileTime(LPTSTR pszDateTime, DWORD cchSize, LPFILETIME pft, DWORD flType);
HRESULT Misc_CreateHglob(SIZE_T cb, LPVOID pv, HGLOBAL *phglob);
int _HIDA_Create_Tally(LPVOID pvPidl, LPVOID pv);
int _HIDA_Create_AddIdl(LPVOID pvPidl, LPVOID pv);
BOOL _Misc_HIDA_Init(LPCVOID hida, LPCVOID pv, BOOL fUnicode);
HIDA Misc_HIDA_Create(LPCITEMIDLIST pidlFolder, CFtpPidlList * pflHfpl);
BOOL _Misc_HFGD_Init(LPVOID pv, LPVOID pvHFPL, BOOL fUnicode);
HGLOBAL Misc_HFGD_Create(CFtpPidlList * pflHfpl, LPCITEMIDLIST pidlItem, BOOL fUnicode);
UINT AddToPopupMenu(HMENU hmenuDst, UINT idMenuToAdd, UINT idSubMenuIndex, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
UINT MergeInToPopupMenu(HMENU hmenuDst, UINT idMenuToMerge, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
HMENU GetMenuFromID(HMENU hmenu, UINT idm);
UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax);
HRESULT Misc_CopyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
HRESULT Misc_CloneHglobal(HGLOBAL hglob, HGLOBAL *phglob);
HRESULT Misc_DeleteHfpl(CFtpFolder * pff, HWND hwnd, CFtpPidlList * pflHfpl);
HWND Misc_FindStatusBar(HWND hwndOwner);
void GetCfBufA(UINT cf, LPSTR psz, int cch);
HGLOBAL AllocHGlob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode);
LPITEMIDLIST GetPidlFromFtpFolderAndPidlList(CFtpFolder * pff, CFtpPidlList * pflHfpl);
HRESULT FtpSafeCreateDirectory(HWND hwnd, HINTERNET hint, CMultiLanguageCache * pmlc, CFtpFolder * pff, CFtpDir * pfd, IProgressDialog * ppd, LPCWSTR pwzFtpPath, BOOL fRoot);
BOOL IsValidFtpAnsiFileName(LPCTSTR pszString);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);


enum SHELL_VERSION
{
    SHELL_VERSION_UNKNOWN        = 0,
    SHELL_VERSION_W95NT4,
    SHELL_VERSION_IE4,
    SHELL_VERSION_NT5,
};

SHELL_VERSION GetShellVersion(void);
DWORD GetShdocvwVersion(void);
BOOL ShouldSkipDropFormat(int nIndex);
HWND GetProgressHWnd(IProgressDialog * ppd, HWND hwndDefault);

void FtpProgressInternetStatusCB(IN HINTERNET hInternet, IN DWORD_PTR pdwContext, IN DWORD dwInternetStatus, IN LPVOID lpwStatusInfo, IN DWORD dwStatusInfoLen);


// In ftpresp.cpp
CFtpGlob * GetFtpResponse(CWireEncoding * pwe);
LPITEMIDLIST SHILCreateFromPathWrapper(LPCTSTR pszPath);
HRESULT _SetStatusBarZone(CStatusBar * psb, CFtpSite * pfs);
HRESULT CreateFromToStr(LPWSTR pwzStrOut, DWORD cchSize, ...);

int _LoadStringW(HINSTANCE hinst, UINT id, LPWSTR wsz, UINT cchMax);        // Implemented in olestuff.cpp
void SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
int DisplayWininetError(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd);
int DisplayWininetErrorEx(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd, LPCWSTR pwzDetails);
void ShowEnableWindow(HWND hwnd, BOOL fHide);

HRESULT RemoveCharsFromString(LPTSTR pszLocToRemove, DWORD cchSizeToRemove);
HRESULT RemoveCharsFromStringA(LPSTR pszLocToRemove, DWORD cchSizeToRemove);
HRESULT CharReplaceWithStrA(LPSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPSTR pszStrToInsert);
HRESULT CharReplaceWithStrW(LPWSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPWSTR pszStrToInsert);

HRESULT EscapeString(LPCTSTR pszStrToEscape, LPTSTR pszEscapedStr, DWORD cchSize);
HRESULT UnEscapeString(LPCTSTR pszStrToUnEscape, LPTSTR pszUnEscapedStr, DWORD cchSize);

HRESULT DisplayBlockingProxyDialog(LPCITEMIDLIST pidl, HWND hwnd);
HRESULT CopyStgMediumWrap(const STGMEDIUM * pcstgmedSrc, STGMEDIUM * pstgmedDest);
HRESULT SHBindToIDList(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDAPI StringToStrRetW(LPCWSTR pwzString, STRRET *pstrret);
HRESULT LoginAsViaFolder(HWND hwnd, CFtpFolder * pff, IUnknown * punkSite);
HRESULT LoginAs(HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, IUnknown * punkSite);
void InitComctlForNaviteFonts(void);
CFtpPidlList * CreateRelativePidlList(CFtpFolder * pff, CFtpPidlList * pPidlListFull);


LPCITEMIDLIST ILGetLastID(LPCITEMIDLIST pidl);
LPCITEMIDLIST ILGetLastNonFragID(LPCITEMIDLIST pidl);
IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation);
HRESULT AddFTPPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPARAM lParam, HINSTANCE * phinstInetCpl, IUnknown * punkSite);
BOOL Is7BitAnsi(LPCWIRESTR pwByteStr);
HRESULT SHPathPrepareForWriteWrapW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc, DWORD dwFlags);

STDAPI DataObj_SetPreferredEffect(IDataObject *pdtobj, DWORD dwEffect);
STDAPI DataObj_SetPasteSucceeded(IDataObject *pdtobj, DWORD dwEffect);
STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut);
STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid);
STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw);
#define     DEBUG_LEGACY_PROGRESS   0


EXTERN_C void _FTPDebugMemLeak(UINT wFlags, LPCTSTR pszFile, UINT iLine);
#define FTPDebugMemLeak(wFlags)  _FTPDebugMemLeak(wFlags, TEXT(__FILE__), __LINE__)


#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp
    
    DESCRIPTION:
        Shared stuff that operates on all classes.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "ftpurl.h"
#include "view.h"
#include "statusbr.h"
#include <commctrl.h>
#include <shdocvw.h>
#define CPP_FUNCTIONS
#include <crtfree.h>

HINSTANCE g_hinst;              /* My instance handle */
CHAR g_szShell32[MAX_PATH];     /* Full path to shell32.dll (must be ANSI) */

#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

// Shell32.dll v3 (original Win95/WinNT) has so many bugs when it receives
// an IDataObject with FILEGROUPDESCRIPTOR that it doesn't make sense to allow
// users to drag from FTP with FILEGROUPDESCRIPTOR on these early shell machines.
// This #define turns this on off.
//#define BROWSERONLY_DRAGGING        1

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.s
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
//
#ifndef USE_IE5_UTILS
void UnicWrapper_IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    ENTERCRITICAL;

    if (*ppunk)
        (*ppunk)->Release();

    *ppunk = punk;
    if (punk)
        punk->AddRef();

    LEAVECRITICAL;
}

void UnicWrapper_IUnknown_AtomicRelease(void ** ppunk)
{
    if (ppunk && *ppunk) {
        IUnknown* punk = *(IUnknown**)ppunk;
        *ppunk = NULL;
        punk->Release();
    }
}


DWORD UnicWrapper_SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate
    do
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_SENDMESSAGE);
        if (dwRet == WAIT_OBJECT_0 ||
            dwRet == WAIT_FAILED)
        {
            // The thread must have exited, so we are happy
            break;
        }

        if (dwRet == WAIT_TIMEOUT)
        {
            // The thread is taking too long to finish, so just
            // return and let the caller kill it
            break;
        }

        // There must be a pending SendMessage from either the
        // thread we are killing or some other thread/process besides
        // this one.  Do a PeekMessage to process the pending
        // SendMessage and try waiting again
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

        if (dwTimeout != INFINITE)
            dwTimeout = dwEnd - GetTickCount();
    }
    while((dwTimeout == INFINITE) || ((long)dwTimeout > 0));

    return(dwRet);
}


/****************************************************\
    FUNCTION: UnicWrapper_AutoCompleteFileSysInEditbox

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.
\****************************************************/
HRESULT UnicWrapper_AutoCompleteFileSysInEditbox(HWND hwndEdit)
{
    HRESULT hr;
    IUnknown * punkACLISF;

    hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLISF);
    if (SUCCEEDED(hr))
    {
        IAutoComplete * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete, (void **)&pac);
        if (SUCCEEDED(hr))
        {
            hr = pac->Init(hwndEdit, punkACLISF, NULL, NULL);
            pac->Release();
        }

        punkACLISF->Release();
    }

    return hr;
}


#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////


void IUnknown_Set(IMalloc ** ppm, IMalloc * pm)
{
    ENTERCRITICAL;

    if (*ppm)
        (*ppm)->Release();
    
    *ppm = pm;

    if (pm)
        pm->AddRef();

    LEAVECRITICAL;
}

// TODO: This is a remnent of using C++ in stead of real COM
void IUnknown_Set(CFtpFolder ** ppff, CFtpFolder * pff)
{
    ENTERCRITICAL;

    if (*ppff)
        (*ppff)->Release();
    
    *ppff = pff;

    if (pff)
        pff->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpDir ** ppfd, CFtpDir * pfd)
{
    ENTERCRITICAL;

    if (*ppfd)
        (*ppfd)->Release();
    
    *ppfd = pfd;

    if (pfd)
        pfd->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpSite ** ppfs, CFtpSite * pfs)
{
    ENTERCRITICAL;

    if (*ppfs)
        (*ppfs)->Release();
    
    *ppfs = pfs;

    if (pfs)
        pfs->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpList ** ppfl, CFtpList * pfl)
{
    ENTERCRITICAL;

    if (*ppfl)
        (*ppfl)->Release();
    
    *ppfl = pfl;

    if (pfl)
        pfl->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpPidlList ** ppflpidl, CFtpPidlList * pflpidl)
{
    ENTERCRITICAL;

    if (*ppflpidl)
        (*ppflpidl)->Release();
    
    *ppflpidl = pflpidl;

    if (pflpidl)
        pflpidl->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpEfe ** ppfefe, CFtpEfe * pfefe)
{
    ENTERCRITICAL;

    if (*ppfefe)
        (*ppfefe)->Release();
    
    *ppfefe = pfefe;

    if (pfefe)
        pfefe->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CFtpGlob ** ppfg, CFtpGlob * pfg)
{
    ENTERCRITICAL;

    if (*ppfg)
        (*ppfg)->Release();
    
    *ppfg = pfg;

    if (pfg)
        pfg->AddRef();

    LEAVECRITICAL;
}


void IUnknown_Set(CFtpMenu ** ppfcm, CFtpMenu * pfcm)
{
    ENTERCRITICAL;

    if (*ppfcm)
        (*ppfcm)->Release();
    
    *ppfcm = pfcm;

    if (pfcm)
        pfcm->AddRef();

    LEAVECRITICAL;
}


void IUnknown_Set(CFtpStm ** ppfstm, CFtpStm * pfstm)
{
    ENTERCRITICAL;

    if (*ppfstm)
        (*ppfstm)->Release();
    
    *ppfstm = pfstm;

    if (pfstm)
        pfstm->AddRef();

    LEAVECRITICAL;
}


#undef ILCombine
// Fix Shell32 bug
LPITEMIDLIST ILCombineWrapper(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (!pidl1)
        return ILClone(pidl2);

    if (!pidl2)
        return ILClone(pidl1);

    return ILCombine(pidl1, pidl2);
}


#undef ILClone
// Fix Shell32 bug
LPITEMIDLIST ILCloneWrapper(LPCITEMIDLIST pidl)
{
    if (!pidl)
        return NULL;

    return ILClone(pidl);
}


#undef ILFree
// Fix Shell32 bug
void ILFreeWrapper(LPITEMIDLIST pidl)
{
    if (pidl)
        ILFree(pidl);
}


// Don't ship with this on.
//#define DEBUG_LEGACY

BOOL IsLegacyChangeNotifyNeeded(LONG wEventId)
{
#ifdef DEBUG_LEGACY
    return TRUE;
#endif // DEBUG_LEGACY

    // The only version that doesn't support IDelegateFolder pidls is
    // shell32 v3 (w/o IE4 Shell Intergrated)
    BOOL fResult = (SHELL_VERSION_W95NT4 == GetShellVersion());
    
    return fResult;
}



/*****************************************************************************\
    FUNCTION: LegacyChangeNotify

    DESCRIPTION:
        Browser only can't read IDelegateFolder pidls (our Pidls), so we need
    to use this function instead of SHChangeNotify that will use hacks to
    get DefView's ListView to update by using 
    SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam).

    These are the messages to use.
    SFVM_ADDOBJECT (SHCNE_CREATE & SHCNE_MKDIR),
    SFVM_UPDATEOBJECT (SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM, SHCNE_ATTRIBUTES), or SFVM_REFRESHOBJECT(),
    SFVM_REMOVEOBJECT (SHCNE_RMDIR & SHCNE_DELETE).
\*****************************************************************************/
HRESULT LegacyChangeNotify(HWND hwnd, LONG wEventId, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (EVAL(hwnd))       // We can't talk to the window w/o this.
    {
        switch(wEventId)
        {
        case SHCNE_CREATE:
        case SHCNE_MKDIR:
        {
            // NOTE: If the item alread exists, it will create a new duplicate name.
            //         We need to skip this if it exists.
            LPCITEMIDLIST pidlRelative = ILGetLastID(pidl1);
            // SFVM_ADDOBJECT frees the pidl we give them.
            EVAL(SHShellFolderView_Message(hwnd, SFVM_ADDOBJECT, (LPARAM) ILClone(pidlRelative)));
            break;
        }
        case SHCNE_RMDIR:
        case SHCNE_DELETE:
        {
            LPCITEMIDLIST pidlRelative = ILGetLastID(pidl1);
            EVAL(SHShellFolderView_Message(hwnd, SFVM_REMOVEOBJECT, (LPARAM) pidlRelative));
            break;
        }
        case SHCNE_RENAMEFOLDER:
        case SHCNE_RENAMEITEM:
        case SHCNE_ATTRIBUTES:
        {
            LPCITEMIDLIST pidlArray[2];
            
            pidlArray[0] = ILGetLastID(pidl1);
            pidlArray[1] = ILClone(ILGetLastID(pidl2));
            EVAL(SHShellFolderView_Message(hwnd, SFVM_UPDATEOBJECT, (LPARAM) pidlArray));
            break;
        }
        }
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: FtpChangeNotify

    Convert the relative pidls into absolute pidls, then hand onwards
    to SHChangeNotify.  If we can't do the notification, tough.

    Issuing a change notify also invalidates the name-cache, because
    we know that something happened to the directory.

    If we wanted to be clever, we could edit the name-cache on the
    fly, but that would entail allocating a new name-cache, initializing
    it with the edited directory contents, then setting it as the new
    cache.  (We can't edit the name-cache in place because somebody
    might still be holding a reference to it.)  And all this work needs
    to be done under the critical section, so that nobody else tries
    to do the same thing simultaneously.  What's more, the only thing
    that this helps is the case where the user opens two views on
    the same folder from within the same process, which not a very
    common scenario.  Summary: It's just not worth it.

    Note that this must be done at the CFtpFolder level and not at the
    CFtpDir level, because CFtpDir doesn't know where we are rooted.
    (We might have several instances, each rooted at different places.)

    _UNDOCUMENTED_: The pidl1 and pidl2 parameters to SHChangeNotify
    are not documented.  It is also not mentioned (although it becomes
    obvious once you realize it) that the pidls passed to SHChangeNotify
    must be absolute.
\*****************************************************************************/
void FtpChangeNotify(HWND hwnd, LONG wEventId, CFtpFolder * pff, CFtpDir * pfd, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fTopLevel)
{
    ASSERT(pfd && IsValidPIDL(pidl1));
    ASSERT(!pidl2 || IsValidPIDL(pidl2));

    // Update our local cache because SHChangeNotify will come back in later and
    // want to create a pidl from a DisplayName and will then use that pidls
    // time/date.  This is done because the shell is trying to create a 'full'
    // pidl.
    switch (wEventId)
    {
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
//        TraceMsg(TF_CHANGENOTIFY, ((wEventId == SHCNE_CREATE) ? "FtpChangeNotify(SHCNE_CREATE), Name=%ls" : "FtpChangeNotify(SHCNE_MKDIR), Name=%s"), FtpPidl_GetFileDisplayName(pidl1));
        EVAL(SUCCEEDED(pfd->AddItem(pidl1)));
        break;
    case SHCNE_RMDIR:
    case SHCNE_DELETE:
//        TraceMsg(TF_CHANGENOTIFY, "FtpChangeNotify(SHCNE_DELETE), Name=%ls", FtpPidl_GetLastFileDisplayName(pidl1));
        pfd->DeletePidl(pidl1); // This may fail if we never populated that cache.
        break;
    case SHCNE_RENAMEFOLDER:
    {
        CFtpDir * pfdSubFolder = pfd->GetSubFtpDir(NULL, pidl1, TRUE);
        
        if (EVAL(pfdSubFolder))
        {
            LPITEMIDLIST pidlDest = pfd->GetSubPidl(NULL, pidl2, TRUE);

            if (EVAL(pidlDest))
            {
                EVAL(SUCCEEDED(pfdSubFolder->ChangeFolderName(pidlDest)));
                ILFree(pidlDest);
            }
            pfdSubFolder->Release();
        }
    }
    // break; Fall Thru so we change the pidl also.
    case SHCNE_RENAMEITEM:
    case SHCNE_ATTRIBUTES:
//        TraceMsg(TF_CHANGENOTIFY, "FtpChangeNotify(SHCNE_RENAMEITEM), Name1=%ls, Name2=%ls", FtpPidl_GetLastFileDisplayName(pidl1), FtpPidl_GetLastFileDisplayName(pidl2));
        EVAL(SUCCEEDED(pfd->ReplacePidl(pidl1, pidl2)));
        break;
    }

    pidl1 = pfd->GetSubPidl(pff, pidl1, TRUE);
    if (EVAL(pidl1))
    {
        if ((pidl2 == NULL) || (EVAL(pidl2 = pfd->GetSubPidl(pff, pidl2, TRUE))) != 0)
        {
            // LRESULT SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam)

            // Are we on something (browser only) that can't read
            // IDelegateFolder pidls (our Pidls)?
            if (IsLegacyChangeNotifyNeeded(wEventId))
            {
                // Yes, so SHChangeNotify won't work.  Use a work around.
                if (fTopLevel)  // Only top level changes are appropriate.
                    LegacyChangeNotify(hwnd, wEventId, pidl1, pidl2);
            }
            else
                SHChangeNotify(wEventId, (SHCNF_IDLIST | SHCNF_FLUSH), pidl1, pidl2);

            ILFree((LPITEMIDLIST)pidl2);
        }
        ILFree((LPITEMIDLIST)pidl1);
    }
}




/**************************************************************\
    FUNCTION: EscapeString

    DESCRIPTION:
\**************************************************************/
HRESULT EscapeString(LPCTSTR pszStrToEscape, LPTSTR pszEscapedStr, DWORD cchSize)
{
    LPCTSTR pszCopy = NULL;

    if (!pszStrToEscape)
    {
        Str_SetPtr((LPTSTR *) &pszCopy, pszEscapedStr);  // NULL pszStrToEscape means do pszEscapedStr in place.
        pszStrToEscape = pszCopy;
    }

    pszEscapedStr[0] = 0;
    if (pszStrToEscape && pszStrToEscape[0])
        UrlEscape(pszStrToEscape, pszEscapedStr, &cchSize, URL_ESCAPE_SEGMENT_ONLY);

    Str_SetPtr((LPTSTR *) &pszCopy, NULL);  // NULL pszStrToEscape means do pszEscapedStr in place.
    return S_OK;
}


/**************************************************************\
    FUNCTION: UnEscapeString

    DESCRIPTION:
\**************************************************************/
HRESULT UnEscapeString(LPCTSTR pszStrToUnEscape, LPTSTR pszUnEscapedStr, DWORD cchSize)
{
    LPCTSTR pszCopy = NULL;

    if (!pszStrToUnEscape)
    {
        Str_SetPtr((LPTSTR *) &pszCopy, pszUnEscapedStr);  // NULL pszStrToEscape means do pszEscapedStr in place.
        pszStrToUnEscape = pszCopy;
    }

    pszUnEscapedStr[0] = 0;
    UrlUnescape((LPTSTR)pszStrToUnEscape, pszUnEscapedStr, &cchSize, URL_ESCAPE_SEGMENT_ONLY);
    
    Str_SetPtr((LPTSTR *) &pszCopy, NULL);  // NULL pszStrToEscape means do pszEscapedStr in place.
    return S_OK;
}


/**************************************************************\
    Since wininet errors are often very generic, this function
    will generate error message of this format:

    "An error occurred while attempted to do x and it could not
     be completed.
     
    Details:
    <Wininet error that may be specific or generic>"
\**************************************************************/
int DisplayWininetErrorEx(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd, LPCWSTR pwzDetails)
{
    TCHAR szErrMessage[MAX_PATH*3];
    TCHAR szTitle[MAX_PATH];
    BOOL fIsWininetError = ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST));
    HMODULE hmod = (fIsWininetError ? GetModuleHandle(TEXT("WININET")) : NULL);
    UINT uiType = (IDS_FTPERR_GETDIRLISTING == idBaseErrorStr) ? MB_ICONINFORMATION : MB_ICONERROR;
    
    if (ppd)
    {
        // If we have a progress dialog, we want to close it down
        // because we will display an error message and the progress
        // dialog in the background looks really dumb.
        ppd->StopProgressDialog();
    }

    // Default message if FormatMessage doesn't recognize hres
    LoadString(HINST_THISDLL, idBaseErrorStr, szErrMessage, ARRAYSIZE(szErrMessage));
    LoadString(HINST_THISDLL, idTitleStr, szTitle, ARRAYSIZE(szTitle));

    // Yes we did, so display the error.
    WCHAR szDetails[MAX_URL_STRING*2];
    TCHAR szPromptTemplate[MAX_PATH];
    TCHAR szBuffer[MAX_PATH*4];

    LoadString(HINST_THISDLL, idDetailsStr, szPromptTemplate, ARRAYSIZE(szPromptTemplate));

    // Can wininet give us extended error messages?
    // UNIX servers cancel the connection if the disk or quote is full
    // but the return a value that explains that to the user.
    if ((ERROR_INTERNET_EXTENDED_ERROR == dwError) || 
        (ERROR_INTERNET_CONNECTION_ABORTED == dwError))
    {
        if (!pwzDetails)
        {
            // We could remove the FTP cmd numbers from before the err strings except advanced users
            // can use them to know more information about the state of the server when this happened.
            // StripResponseHeaders(pszMOTD);
            if (FAILED(InternetGetLastResponseInfoDisplayWrap(TRUE, &dwError, szDetails, ARRAYSIZE(szDetails))))
                szDetails[0] = 0;

            pwzDetails = (LPCWSTR) szDetails;
        }
    }
    else
    {
        if (fIsWininetError)
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)hmod, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);
        else
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, (LPCVOID)hmod, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);

        pwzDetails = (LPCWSTR) szDetails;
    }

    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szPromptTemplate, pwzDetails);
    StrCatBuff(szErrMessage, szBuffer, ARRAYSIZE(szErrMessage));

    return MessageBox(hwnd, szErrMessage, szTitle, (uiType | nMsgBoxType));
}


int DisplayWininetError(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd)
{
    if (hwnd)   // Only display if HWND exists.
        return DisplayWininetErrorEx(hwnd, fAssertOnNULLHWND, dwError, idTitleStr, idBaseErrorStr, idDetailsStr, nMsgBoxType, ppd, NULL);
    else
    {
        if (fAssertOnNULLHWND)
        {
//            ASSERT(hwnd);
        }

        TraceMsg(TF_ALWAYS, "DisplayWininetError() no HWND so no Error.");
    }

    return IDCANCEL;
}

#define CCH_SIZE_ERROR_MESSAGE  6*1024
HRESULT FtpSafeCreateDirectory(HWND hwnd, HINTERNET hint, CMultiLanguageCache * pmlc, CFtpFolder * pff, CFtpDir * pfd, IProgressDialog * ppd, LPCWSTR pwzFtpPath, BOOL fRoot)
{
    FTP_FIND_DATA wfd;
    HRESULT hr = S_OK;
    WIRECHAR wFtpPath[MAX_PATH];
    CWireEncoding * pwe = pfd->GetFtpSite()->GetCWireEncoding();
    
    if (SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzFtpPath, (pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wFtpPath, ARRAYSIZE(wFtpPath))))
    {
        hr = FtpCreateDirectoryWrap(hint, TRUE, wFtpPath);

        // PERF NOTE: It is faster to just try to create the directory and then ignore
        //       error return values that indicate that they failed to create because it
        //       already exists.  The problem I worry about is that there is some FTP server
        //       impl somewhere that will return the same error as failed to create because
        //       of access violation and we don't or can't return an error value.
        if (FAILED(hr)
// NOTE: IE #30208: Currently broken in wininet.  The dorks in wininet never fixed this because
//       they say it's no repro.  It's no repro because I did this work around!$#!@@#%!!!
// 
//         I want to test the attribute flags but for some reason the FILE_ATTRIBUTE_DIRECTORY bit
//         is also set for files!!!! (!@(*#!!!)
//          || !(FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
                )
        {
            // Maybe if failed because it already exists, which is fine by me.

            // First save off the error msg in case we need it for the err dlg later.
            CHAR szErrorMsg[CCH_SIZE_ERROR_MESSAGE];
            WCHAR wzErrorMsg[CCH_SIZE_ERROR_MESSAGE];
            DWORD cchSize = ARRAYSIZE(szErrorMsg);
            InternetGetLastResponseInfoWrap(TRUE, NULL, szErrorMsg, &cchSize);
            HRESULT hrOrig = hr;

            pwe->WireBytesToUnicode(NULL, szErrorMsg, WIREENC_NONE, wzErrorMsg, ARRAYSIZE(wzErrorMsg));
            // Does it already exist?
            hr = FtpDoesFileExist(hint, TRUE, wFtpPath, &wfd, (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD));

            // It's okay if we failed to create the directory because a -DIRECTORY- already exists
            // because we'll just use that directory.  However, it a file with that name exists, 
            // then we need the err msg.
            if ((S_OK != hr) || !(FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes))
            {
                // No, so it was a real error, now display the error message with the original
                // server response.
                DisplayWininetErrorEx(hwnd, TRUE, HRESULT_CODE(hrOrig), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DIRCOPY, IDS_FTPERR_WININET, MB_OK, ppd, wzErrorMsg);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        // Was it created successfully?
        if (SUCCEEDED(hr))
        {
            // Yes, so fire the change notify.
            LPITEMIDLIST pidlNewDir;
            FILETIME ftUTC;
            FTP_FIND_DATA wfd;

            GetSystemTimeAsFileTime(&ftUTC);   // UTC
            FileTimeToLocalFileTime(&ftUTC, &wfd.ftCreationTime);   // Need Local Time because FTP won't work in the cross time zones case.

            // For some reason, FtpFindFirstFile needs an '*' behind the name.
            StrCpyNA(wfd.cFileName, wFtpPath, ARRAYSIZE(wfd.cFileName));
            wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            wfd.ftLastWriteTime = wfd.ftCreationTime;
            wfd.ftLastAccessTime = wfd.ftCreationTime;
            wfd.nFileSizeLow = 0;
            wfd.nFileSizeHigh = 0;
            wfd.dwReserved0 = 0;
            wfd.dwReserved1 = 0;
            wfd.cAlternateFileName[0] = 0;

            hr = FtpItemID_CreateReal(&wfd, pwzFtpPath, &pidlNewDir);
            if (SUCCEEDED(hr))   // May happen on weird character set problems.
            {
                // Notify the folder of the new item so the Shell Folder updates.
                // PERF: Note that we should give SHChangeNotify() the information (time/date)
                //       from the local file system which may be different than on the server.
                //       But I don't think it's worth the perf to hit the server for the info.
                FtpChangeNotify(hwnd, SHCNE_MKDIR, pff, pfd, pidlNewDir, NULL, fRoot);
                ILFree(pidlNewDir);
            }
        }

    }

    return hr;
}


HWND GetProgressHWnd(IProgressDialog * ppd, HWND hwndDefault)
{
    if (ppd)
    {
        HWND hwndProgress = NULL;

        IUnknown_GetWindow(ppd, &hwndProgress);
        if (hwndProgress)
            hwndDefault = hwndProgress;
    }

    return hwndDefault;
}


// Returns FALSE if out of memory
int SHMessageBox(HWND hwnd, LPCTSTR pszMessage, UINT uMessageID, UINT uTitleID, UINT uType)
{
    int nResult = IDCANCEL;
    TCHAR szMessage[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    if (LoadString(HINST_THISDLL, uTitleID, szTitle, ARRAYSIZE(szTitle)) &&
        (pszMessage || 
         (uMessageID && LoadString(HINST_THISDLL, uMessageID, szMessage, ARRAYSIZE(szMessage)))))
    {
        nResult = MessageBox(hwnd, pszMessage ? pszMessage : szMessage, szTitle, uType);
    }

    return nResult;
}


BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}


LPITEMIDLIST SHILCreateFromPathWrapper(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;

    if (IsOSNT())
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        SHILCreateFromPath((LPCTSTR)wzPath, &pidl, NULL);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        SHILCreateFromPath((LPCTSTR)szPath, &pidl, NULL);
    }

    return pidl;
}


LPCITEMIDLIST ILGetLastID(LPCITEMIDLIST pidlIn)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST) pidlIn;

    while (!ILIsEmpty(_ILNext(pidl)))
        pidl = _ILNext(pidl);

    return pidl;
}


LPCITEMIDLIST ILGetLastNonFragID(LPCITEMIDLIST pidlIn)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST) pidlIn;

    while (!ILIsEmpty(_ILNext(pidl)) && !FtpItemID_IsFragment(_ILNext(pidl)))
        pidl = _ILNext(pidl);

    return pidl;
}



SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData,DWORD cbData)
{
    SAFEARRAY * psa;

    if (!pData || 0 == cbData)
        return NULL;  // nothing to do

    // create a one-dimensional safe array
    psa = SafeArrayCreateVector(VT_UI1,0,cbData);
    ASSERT(psa);

    if (psa) {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is OK.

        ASSERT(psa->pvData);
        memcpy(psa->pvData,pData,cbData);
    }

    return psa;
}


//
// PARAMETER:
//    pvar - Allocated by caller and filled in by this function.
//    pidl - Allocated by caller and caller needs to free.
//
// This function will take the PIDL parameter and COPY it
// into the Variant data structure.  This allows the pidl
// to be freed and the pvar to be used later, however, it
// is necessary to call VariantClear(pvar) to free memory
// that this function allocates.

BOOL InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl)
{
    UINT cb = ILGetSize(pidl);
    SAFEARRAY* psa = MakeSafeArrayFromData((LPCBYTE)pidl, cb);
    if (psa) {
        ASSERT(psa->cDims == 1);
        // ASSERT(psa->cbElements == cb);
        ASSERT(ILGetSize((LPCITEMIDLIST)psa->pvData)==cb);
        VariantInit(pvar);
        pvar->vt = VT_ARRAY|VT_UI1;
        pvar->parray = psa;
        return TRUE;
    }

    return FALSE;
}



BSTR BStrFromStr(LPCTSTR pszStr)
{
    BSTR bStr = NULL;

#ifdef UNICODE
    bStr = SysAllocString(pszStr);

#else // UNICODE
    DWORD cchSize = (lstrlen(pszStr) + 2);
    bStr = SysAllocStringLen(NULL, cchSize);
    if (bStr)
        SHAnsiToUnicode(pszStr, bStr, cchSize);

#endif // UNICODE

    return bStr;
}


HRESULT IUnknown_IWebBrowserNavigate2(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry)
{
    HRESULT hr = E_FAIL;
    IWebBrowser2 * pwb2;

    // punk will be NULL on Browser Only installs because the old
    // shell32 doesn't do ::SetSite().
    IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *) &pwb2);
    if (pwb2)
    {
        VARIANT varThePidl;

        if (InitVariantFromIDList(&varThePidl, pidl))
        {
            VARIANT varFlags;
            VARIANT * pvarFlags = PVAREMPTY;

            if (!fHistoryEntry)
            {
                varFlags.vt = VT_I4;
                varFlags.lVal = navNoHistory;
                pvarFlags = &varFlags;
            }

            hr = pwb2->Navigate2(&varThePidl, pvarFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
            VariantClear(&varThePidl);
        }
        pwb2->Release();
    }
    else
    {
        IShellBrowser * psb;

        // Maybe we are in comdlg32.
        hr = IUnknown_QueryService(punk, SID_SCommDlgBrowser, IID_IShellBrowser, (LPVOID *) &psb);
        if (SUCCEEDED(hr))
        {
            CFtpView * pfv = GetCFtpViewFromDefViewSite(punk);

            AssertMsg((NULL != pfv), TEXT("IUnknown_IWebBrowserNavigate2() defview gave us our IShellFolderViewCB so it needs to support this interface."));
            if (pfv)
            {
                // Are we on the forground thread?
                if (pfv->IsForegroundThread())
                {
                    // Yes, so this will be easy.  This is the case
                    // where "Login As..." was chosen from the background context menu item.
                    hr = psb->BrowseObject(pidl, 0);
                }
                else
                {
                    // No, so this is the case where we failed to login with the original
                    // UserName/Password and we will try again with the corrected Username/Password.

                    // Okay, we are talking to the ComDlg code but we don't want to use
                    // IShellBrowse::BrowseObject() because we are on a background thread. (NT #297732)
                    // Therefore, we want to have the IShellFolderViewCB (CFtpView) cause
                    // the redirect on the forground thread.  Let's inform
                    // CFtpView now to do this.
                    hr = pfv->SetRedirectPidl(pidl);
                }

                pfv->Release();
            }
            
            AssertMsg(SUCCEEDED(hr), TEXT("IUnknown_IWebBrowserNavigate2() defview needs to support QS(SID_ShellFolderViewCB) on all platforms that hit this point"));
            psb->Release();
        }
    }

    return hr;
}


HRESULT IUnknown_PidlNavigate(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry)
{
    HRESULT hrOle = SHCoInitialize();
    HRESULT hr = IUnknown_IWebBrowserNavigate2(punk, pidl, fHistoryEntry);

    // Try a pre-NT5 work around.
    // punk will be NULL on Browser Only installs because the old
    // shell32 doesn't do ::SetSite().
    if (FAILED(hr))
    {
        IWebBrowserApp * pauto = NULL;
        
        hr = SHGetIDispatchForFolder(pidl, &pauto);
        if (pauto)
        {
            hr = IUnknown_IWebBrowserNavigate2(pauto, pidl, fHistoryEntry);
            ASSERT(SUCCEEDED(hr));
            pauto->Release();
        }
    }

    ASSERT(SUCCEEDED(hrOle));
    SHCoUninitialize(hrOle);
    return hr;
}


/*****************************************************************************\

    HIDACREATEINFO

    Structure that collects all information needed when building
    an ID List Array.

\*****************************************************************************/

typedef struct tagHIDACREATEINFO
{
    HIDA hida;            /* The HIDA being built */
    UINT ipidl;            /* Who we are */
    UINT ib;            /* Where we are */
    UINT cb;            /* Where we're going */
    UINT cpidl;            /* How many we're doing */
    LPCITEMIDLIST pidlFolder;        /* The parent all these LPITEMIDLISTs live in */
    CFtpPidlList * pflHfpl;            /* The pidl list holding all the kids */
} HIDACREATEINFO, * LPHIDACREATEINFO;

#define pidaPhci(phci) ((LPIDA)(phci)->hida)    /* no need to lock */


/*****************************************************************************\
    Misc_SfgaoFromFileAttributes

    AIGH!

    UNIX and Win32 semantics on file permissions are different.

    On UNIX, the ability to rename or delete a file depends on
    your permissions on the parent folder.

    On Win32, the ability to rename or delete a file depends on
    your permissions on the file itself.

    Note that there is no such thing as "deny-read" attributes
    on Win32...  I wonder how WinINet handles that...

    I'm going to hope that WinINet does the proper handling of this,
    so I'll just proceed with Win32 semantics... I'm probably assuming too much...
\*****************************************************************************/
DWORD Misc_SfgaoFromFileAttributes(DWORD dwFAFLFlags)
{
    DWORD sfgao = SFGAO_CANLINK;    // You can always link

    sfgao |= SFGAO_HASPROPSHEET;    // You can always view properties

    sfgao |= SFGAO_CANCOPY;        // Deny-read?  No such thing! (Yet)

    if (dwFAFLFlags & FILE_ATTRIBUTE_READONLY)
    {        /* Can't delete it, sorry */
#ifdef _SOMEDAY_ASK_FRANCISH_WHAT_THIS_IS
        if (SHELL_VERSION_NT5 == GetShellVersion())
            sfgao |= SFGAO_READONLY;
#endif
    }
    else
    {
        sfgao |= (SFGAO_CANRENAME | SFGAO_CANDELETE);
#ifdef FEATURE_CUT_MOVE
        sfgao |= SFGAO_CANMOVE;
#endif // FEATURE_CUT_MOVE
    }

    if (dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY)
    {
        //Since FTP connections are expensive, assume SFGAO_HASSUBFOLDER
        sfgao |= SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_STORAGEANCESTOR;
    }
    else
    {
        // We always return the
        // SFGAO_BROWSABLE because we always want to do the navigation
        // using our IShellFolder::CreateViewObject().  In the case of
        // files, the CreateViewObject() that we create is for URLMON
        // which will do the download.  This is especially true for
        // Folder Shortcuts.
        sfgao |= SFGAO_BROWSABLE | SFGAO_STREAM;
    }

    return sfgao;
}

/*****************************************************************************\
    FUNCTION: Misc_StringFromFileTime

    DESCRIPTION:
        Get the date followed by the time.  flType can be DATE_SHORTDATE
    (for defview's details list) or DATE_LONGDATE for the property sheet.

    PARAMETERS:
        pft: This needs to be stored in UTC (NOT Time Zone dependent form!!!!)
\*****************************************************************************/
HRESULT Misc_StringFromFileTime(LPTSTR pszDateTime, DWORD cchSize, LPFILETIME pftUTC, DWORD flType)
{
    if (EVAL(pftUTC && pftUTC->dwHighDateTime))
    {
        // SHFormatDateTime() takes the date in UTC format.
        SHFormatDateTime(pftUTC, &flType, pszDateTime, cchSize);
    }
    else
        pszDateTime[0] = 0;

    return S_OK;
}


LPITEMIDLIST GetPidlFromFtpFolderAndPidlList(CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    LPCITEMIDLIST pidlBase = pff->GetPrivatePidlReference();
    LPCITEMIDLIST pidlRelative = ((0 == pflHfpl->GetCount()) ? c_pidlNil : pflHfpl->GetPidl(0));

    return ILCombine(pidlBase, pidlRelative);
}


IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation)
{
    IProgressDialog * ppd = NULL;
    
    if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd)))
    {
        WCHAR wzTitle[MAX_PATH];

        if (EVAL(LoadStringW(HINST_THISDLL, idTitle, wzTitle, ARRAYSIZE(wzTitle))))
            EVAL(SUCCEEDED(ppd->SetTitle(wzTitle)));

        EVAL(SUCCEEDED(ppd->SetAnimation(HINST_THISDLL, idAnimation)));
    }

    return ppd;
}


BOOL_PTR CALLBACK ProxyDlgWarningWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        LPCTSTR pszUrl = (LPCTSTR)lParam;
        TCHAR szMessage[MAX_PATH*3];
        TCHAR szTemplate[MAX_PATH*3];

        ASSERT(pszUrl);

        EVAL(LoadString(HINST_THISDLL, IDS_FTP_PROXY_WARNING, szTemplate, ARRAYSIZE(szTemplate)));
        wnsprintf(szMessage, ARRAYSIZE(szMessage), szTemplate, pszUrl);
        EVAL(SetWindowText(GetDlgItem(hDlg, IDC_PROXY_MESSAGE), szMessage));
    }

    return FALSE;
}


/*****************************************************************************\
    FUNCTION:   DisplayBlockingProxyDialog

    DESCRIPTION:
        Inform user that their CERN style proxy is blocking real FTP access so
    they can do something about it.

    Inform the user so they can: 
    A) Change proxies,
    B) Annoy their administrator to install real proxies,
    C) Install Remote WinSock themselves,
    D) or settle for their sorry situation in life and use the
       limited CERN proxy support and dream about the abilitity
       to rename, delete, and upload.

    This will be a no-op if the user clicks "Don't display this
    message again" check box.
\*****************************************************************************/
HRESULT DisplayBlockingProxyDialog(LPCITEMIDLIST pidl, HWND hwnd)
{
    // Did the IBindCtx provide information to allow us to do UI?
    if (hwnd)
    {
        TCHAR szUrl[MAX_PATH];
        HWND hwndParent = hwnd;

        // NT #321103: If the user used Start->Run to open the dialog, then
        //    it may not receive focus because our parent browser has not yet
        //    appeared (it doesn't have the WS_VISIBLE style yet and it has the
        //    WS_DISABLED style.  So we need to force our dialog to become active.
        if (hwndParent && !IsWindowVisible(hwndParent))
        {
            hwndParent = NULL;
        }

        UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), 0, TRUE);

        // Make it modal while the dialog is being displayed.
//        IUnknown_EnableModless(punkSite, FALSE);
        SHMessageBoxCheckEx(hwndParent, HINST_THISDLL, MAKEINTRESOURCE(IDD_PROXYDIALOG), ProxyDlgWarningWndProc, (LPVOID) szUrl, IDOK, SZ_REGVALUE_WARN_ABOUT_PROXY);
//        IUnknown_EnableModless(punkSite, TRUE);
    }

    return S_OK;
}


HRESULT CreateFromToStr(LPWSTR pwzStrOut, DWORD cchSize, ...)
{
    CHAR szStatusText[MAX_PATH];
    CHAR szTemplate[MAX_PATH];
    va_list vaParamList;
    
    va_start(vaParamList, cchSize);
    // Generate the string "From <SrcFtpUrlDir> to <DestFileDir>" status string
    EVAL(LoadStringA(HINST_THISDLL, IDS_DL_SRC_DEST, szTemplate, ARRAYSIZE(szTemplate)));
    if (EVAL(FormatMessageA(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szStatusText, ARRAYSIZE(szStatusText), &vaParamList)))
        SHAnsiToUnicode(szStatusText, pwzStrOut, cchSize);

    va_end(vaParamList);
    return S_OK;
}

/****************************************************\
    FUNCTION: FtpProgressInternetStatusCB

    DESCRIPTION: 
        This function is exists to be called back during
    long FTP operations so we can update the progress
    dialog during FtpPutFile or FtpGetFile.

    A pointer to our PROGRESSINFO struct is passed in
    dwContext.
\****************************************************/
void FtpProgressInternetStatusCB(IN HINTERNET hInternet, IN DWORD_PTR pdwContext, IN DWORD dwInternetStatus, IN LPVOID lpwStatusInfo, IN DWORD dwStatusInfoLen)
{
    LPPROGRESSINFO pProgInfo = (LPPROGRESSINFO) pdwContext;
    if (EVAL(pProgInfo))
    {
        switch (dwInternetStatus)
        {
        case INTERNET_STATUS_RESPONSE_RECEIVED:
        case INTERNET_STATUS_REQUEST_SENT:
            if (EVAL(lpwStatusInfo && (sizeof(DWORD) == dwStatusInfoLen)
                && pProgInfo))
            {
                if (pProgInfo->hint && pProgInfo->ppd->HasUserCancelled())
                {
                    EVAL(InternetCloseHandle(pProgInfo->hint));
                    pProgInfo->hint = NULL;
                }

                pProgInfo->dwCompletedInCurFile += *(LPDWORD)lpwStatusInfo;

                // Has a big enough chunck of the file completed that we need
                // to update the progress?  We only want to update the progress
                // every SIZE_PROGRESS_AFTERBYTES (50k) chunck.
                if (pProgInfo->dwLastDisplayed < (pProgInfo->dwCompletedInCurFile / SIZE_PROGRESS_AFTERBYTES))
                {
                    ULARGE_INTEGER uliBytesCompleted;

                    pProgInfo->dwLastDisplayed = (pProgInfo->dwCompletedInCurFile / SIZE_PROGRESS_AFTERBYTES);

                    uliBytesCompleted.HighPart = 0;
                    uliBytesCompleted.LowPart = pProgInfo->dwCompletedInCurFile;
                    uliBytesCompleted.QuadPart += pProgInfo->uliBytesCompleted.QuadPart;

                    if (pProgInfo->ppd)
                        EVAL(SUCCEEDED(pProgInfo->ppd->SetProgress64(uliBytesCompleted.QuadPart, pProgInfo->uliBytesTotal.QuadPart)));
                }
            }
            break;
        }
    }
}


/*****************************************************************************\
    Misc_CreateHglob

    Allocate an hglobal of the indicated size, initialized from the
    specified buffer.
\*****************************************************************************/
HRESULT Misc_CreateHglob(SIZE_T cb, LPVOID pv, HGLOBAL *phglob)
{
    HRESULT hres = E_OUTOFMEMORY;

    *phglob = 0;            // Rules are rules
    if (cb)
    {
        *phglob = (HGLOBAL) LocalAlloc(LPTR, cb);
        if (*phglob)
        {
            hres = S_OK;
            CopyMemory(*phglob, pv, cb);
        }
    }
    else
        hres = E_INVALIDARG;    // Can't clone a discardable block

    return hres;
}


/*****************************************************************************\
    _HIDA_Create_Tally

    Worker function for HIDA_Create which tallies up the total size.
\*****************************************************************************/
int _HIDA_Create_Tally(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    UINT *pcb = (UINT *) pv;
    int nContinue = (pv ? TRUE : FALSE);

    if (pcb)
    {
        *pcb += ILGetSize(pidl);
    }

    return nContinue;
}


/*****************************************************************************\
    _HIDA_Create_AddIdl

    Worker function for HIDA_Create which appends another ID List
    to the growing HIDA.
\*****************************************************************************/
int _HIDA_Create_AddIdl(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    LPHIDACREATEINFO phci = (LPHIDACREATEINFO) pv;
    UINT cb = ILGetSize(pidl);

    pidaPhci(phci)->aoffset[phci->ipidl++] = phci->ib;
    CopyMemory(pvByteIndexCb(pidaPhci(phci), phci->ib), pidl, cb);
    phci->ib += cb;

    return phci ? TRUE : FALSE;
}


/*****************************************************************************\
    _Misc_HIDA_Init

    Once we've allocated the memory for a HIDA, fill it with stuff.
\*****************************************************************************/
BOOL _Misc_HIDA_Init(LPVOID hida, LPVOID pv, LPCVOID pvParam2, BOOL fUnicode)
{
    LPHIDACREATEINFO phci = (LPHIDACREATEINFO) pv;

    phci->hida = hida;
    pidaPhci(phci)->cidl = phci->cpidl;
    phci->ipidl = 0;

    phci->pflHfpl->TraceDump(_ILNext(phci->pidlFolder), TEXT("_Misc_HIDA_Init() TraceDump Before"));

    _HIDA_Create_AddIdl((LPVOID) phci->pidlFolder, (LPVOID) phci);
    phci->pflHfpl->Enum(_HIDA_Create_AddIdl, (LPVOID) phci);

    phci->pflHfpl->TraceDump(_ILNext(phci->pidlFolder), TEXT("_Misc_HIDA_Init() TraceDump After"));

    return 1;
}


/*****************************************************************************\
    HIDA_Create

    Swiped from idlist.c in the shell because they didn't    ;Internal
    export it.                        ;Internal
\*****************************************************************************/
HIDA Misc_HIDA_Create(LPCITEMIDLIST pidlFolder, CFtpPidlList * pflHfpl)
{
    HIDACREATEINFO hci;
    LPHIDACREATEINFO phci = &hci;
    HIDA hida;

    pflHfpl->TraceDump(_ILNext(pidlFolder), TEXT("Misc_HIDA_Create() TraceDump Before"));
    phci->pidlFolder = pidlFolder;
    phci->pflHfpl = pflHfpl;
    phci->cpidl = pflHfpl->GetCount();
    phci->ib = sizeof(CIDA) + sizeof(UINT) * phci->cpidl;
    phci->cb = phci->ib + ILGetSize(pidlFolder);

    pflHfpl->Enum(_HIDA_Create_Tally, (LPVOID) &phci->cb);

    hida = AllocHGlob(phci->cb, _Misc_HIDA_Init, phci, NULL, FALSE);
    pflHfpl->TraceDump(_ILNext(pidlFolder), TEXT("Misc_HIDA_Create() TraceDump Before"));

    return hida;
}


typedef struct tagURL_FILEGROUP
{
    LPFILEGROUPDESCRIPTORA   pfgdA;
    LPFILEGROUPDESCRIPTORW   pfgdW;
    LPCITEMIDLIST            pidlParent;
} URL_FILEGROUP;

/*****************************************************************************\
    Misc_HFGD_Create

    Build a file group descriptor based on an pflHfpl.

    CFtpObj::_DelayRender_FGD() did the recursive walk to expand the list 
    of pidls, so we don't have to.
\*****************************************************************************/
#define cbFgdCfdW(cfd) FIELD_OFFSET(FILEGROUPDESCRIPTORW, fgd[cfd])
#define cbFgdCfdA(cfd) FIELD_OFFSET(FILEGROUPDESCRIPTORA, fgd[cfd])

int _Misc_HFGD_Create(LPVOID pvPidl, LPVOID pv)
{
    BOOL fSucceeded = TRUE;
    URL_FILEGROUP * pUrlFileGroup = (URL_FILEGROUP *) pv;
    LPCITEMIDLIST pidlFull = (LPCITEMIDLIST) pvPidl;
    LPCITEMIDLIST pidl;

    LPFILEGROUPDESCRIPTORA pfgdA = pUrlFileGroup->pfgdA;
    LPFILEGROUPDESCRIPTORW pfgdW = pUrlFileGroup->pfgdW;
    LPFILEDESCRIPTORA pfdA = (pfgdA ? &pfgdA->fgd[pfgdA->cItems++] : NULL);
    LPFILEDESCRIPTORW pfdW = (pfgdW ? &pfgdW->fgd[pfgdW->cItems++] : NULL);

    pidl = ILGetLastID(pidlFull);
    if (pfdA)
    {
#if !DEBUG_LEGACY_PROGRESS
        pfdA->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME | FD_PROGRESSUI);
#else // !DEBUG_LEGACY_PROGRESS
        pfdA->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME);
#endif // !DEBUG_LEGACY_PROGRESS
        pfdA->dwFileAttributes = FtpItemID_GetAttributes(pidl);
        pfdA->nFileSizeLow = FtpItemID_GetFileSizeLo(pidl);
        pfdA->nFileSizeHigh = FtpItemID_GetFileSizeHi(pidl);

        // all WIN32_FIND_DATA want to be stored in TimeZone independent
        // ways, except for WININET's FTP.  Also note that we only store Modified
        // time and use if for everything because of another UNIX/Wininet issue.
        // See priv.h on more FTP Time/Date issues.
        pfdA->ftCreationTime = FtpPidl_GetFileTime(ILFindLastID(pidl));
        pfdA->ftLastWriteTime = pfdA->ftCreationTime;
        pfdA->ftLastAccessTime = pfdA->ftCreationTime;
    }
    else
    {
#if !DEBUG_LEGACY_PROGRESS
        pfdW->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME | FD_PROGRESSUI);
#else // !DEBUG_LEGACY_PROGRESS
        pfdW->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME);
#endif // !DEBUG_LEGACY_PROGRESS
        pfdW->dwFileAttributes = FtpItemID_GetAttributes(pidl);
        pfdW->nFileSizeLow = FtpItemID_GetFileSizeLo(pidl);
        pfdW->nFileSizeHigh = FtpItemID_GetFileSizeHi(pidl);

        // all WIN32_FIND_DATA want to be stored in TimeZone independent
        // ways, except for WININET's FTP.  Also note that we only store Modified
        // time and use if for everything because of another UNIX/Wininet issue.
        // See priv.h on more FTP Time/Date issues.
        pfdW->ftCreationTime = FtpPidl_GetFileTime(ILFindLastID(pidl));
        pfdW->ftLastWriteTime = pfdW->ftCreationTime;
        pfdW->ftLastAccessTime = pfdW->ftCreationTime;
    }

    LPCITEMIDLIST pidlDiff = FtpItemID_FindDifference(pUrlFileGroup->pidlParent, pidlFull);

    if (pfdA)
    {
        GetWirePathFromPidl(pidlDiff, pfdA->cFileName, ARRAYSIZE(pfdA->cFileName), FALSE);
        UrlPathRemoveSlashA(pfdA->cFileName);
        UrlPathRemoveFrontSlashA(pfdA->cFileName);
        UrlPathToFilePathA(pfdA->cFileName);
    }
    else
    {
        GetDisplayPathFromPidl(pidlDiff, pfdW->cFileName, ARRAYSIZE(pfdW->cFileName), FALSE);
        UrlPathRemoveSlashW(pfdW->cFileName);
        UrlPathRemoveFrontSlashW(pfdW->cFileName);
        UrlPathToFilePathW(pfdW->cFileName);
    }

    TraceMsg(TF_FTPURL_UTILS, "_Misc_HFGD_Create() pfd(A/W)->dwFileAttributes=%#08lX", (pfdW ? pfdW->dwFileAttributes : pfdA->dwFileAttributes));

    return fSucceeded;
}


BOOL _Misc_HFGD_Init(LPVOID pv, LPVOID pvHFPL, LPCVOID pvParam2, BOOL fUnicode)
{
    CFtpPidlList * pflHfpl = (CFtpPidlList *) pvHFPL;
    URL_FILEGROUP urlFG = {0};

    urlFG.pidlParent = (LPCITEMIDLIST) pvParam2;
    if (fUnicode)
        urlFG.pfgdW = (LPFILEGROUPDESCRIPTORW) pv;
    else
        urlFG.pfgdA = (LPFILEGROUPDESCRIPTORA) pv;

    TraceMsg(TF_PIDLLIST_DUMP, "_Misc_HFGD_Init() TraceDump Before");
    pflHfpl->TraceDump(NULL, TEXT("_Misc_HFGD_Init() TraceDump before"));

    pflHfpl->Enum(_Misc_HFGD_Create, (LPVOID) &urlFG);

    pflHfpl->TraceDump(NULL, TEXT("_Misc_HFGD_Init() TraceDump after"));

    return 1;
}


HGLOBAL Misc_HFGD_Create(CFtpPidlList * pflHfpl, LPCITEMIDLIST pidlItem, BOOL fUnicode)
{
    DWORD dwCount = pflHfpl->GetCount();
    DWORD cbAllocSize = (fUnicode ? cbFgdCfdW(dwCount) : cbFgdCfdA(dwCount));

    return AllocHGlob(cbAllocSize, _Misc_HFGD_Init, pflHfpl, (LPCVOID) pidlItem, fUnicode);
}


// Returns the submenu of the given menu and ID.  Returns NULL if there
// is no submenu
int _MergePopupMenus(HMENU hmDest, HMENU hmSource, int idCmdFirst, int idCmdLast)
{
    int i, idFinal = idCmdFirst;

    for (i = GetMenuItemCount(hmSource) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     // just in case

        if (EVAL(GetMenuItemInfo(hmSource, i, TRUE, &mii)))
        {
            HMENU hmDestSub = GetMenuFromID(hmDest, mii.wID);
            if (hmDestSub)
            {
                int idTemp = Shell_MergeMenus(hmDestSub, mii.hSubMenu, (UINT)0, idCmdFirst, idCmdLast, MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                if (idFinal < idTemp)
                    idFinal = idTemp;
            }
        }
    }

    return idFinal;
}


/*****************************************************************************\
    FUNCTION: AddToPopupMenu

    DESCRIPTION:
      Swiped from utils.c in RNAUI, in turn swiped from the    ;Internal
      shell.                            ;Internal
                                  ;Internal
      Takes a destination menu and a (menu id, submenu index) pair,
      and inserts the items from the (menu id, submenu index) at location
      imi in the destination menu, with a separator, returning the number
      of items added.  (imi = index to menu item)
  
      Returns the first the number of items added.
  
      hmenuDst        - destination menu
      idMenuToAdd        - menu resource identifier
      idSubMenuIndex    - submenu from menu resource to act as template
      indexMenu        - location at which menu items should be inserted
      idCmdFirst        - first available menu identifier
      idCmdLast       - first unavailable menu identifier
      uFlags            - flags for Shell_MergeMenus
\*****************************************************************************/
#define FLAGS_MENUMERGE                 (MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS)

UINT AddToPopupMenu(HMENU hmenuDst, UINT idMenuToAdd, UINT idSubMenuIndex, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToAdd));
    if (hmenuSrc)
    {
        nLastItem = Shell_MergeMenus(hmenuDst, GetSubMenu(hmenuSrc, idSubMenuIndex), indexMenu, idCmdFirst, idCmdLast, (uFlags | FLAGS_MENUMERGE));
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}


UINT MergeInToPopupMenu(HMENU hmenuDst, UINT idMenuToMerge, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToMerge));
    if (hmenuSrc)
    {
        nLastItem = _MergePopupMenus(hmenuDst, hmenuSrc, idCmdFirst, idCmdLast);
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}


/*****************************************************************************\

    GetMenuFromID

    Swiped from defviewx.c in the shell.            ;Internal
                                ;Internal
    Given an actual menu and a menu identifier which corresponds
    to a submenu, return the submenu handle.

    hmenu - source menu
    idm   - menu identifier

\*****************************************************************************/
HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    HMENU hmenuRet = NULL;
    if (!hmenu)
        return NULL;

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    mii.cch = 0;             // just in case
    mii.hSubMenu = 0;        // in case GetMenuItemInfo fails

    if (GetMenuItemInfo(hmenu, idm, 0, &mii))
        hmenuRet = mii.hSubMenu;

    return hmenuRet;
}


/*****************************************************************************\
    MergeMenuHierarchy

    Swiped from defcm.c in the shell.            ;Internal
                                ;Internal
    Given an actual menu (hmenuDst), iterate over its submenus
    and merge corresponding submenus whose IDs match the IDs of
    actuals.

    hmenuDst - menu being adjusted
    hmenuSrc - template menu
    idcMin     - first available index
    idcMax     - first unavailable index
\*****************************************************************************/
UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax)
{
    int imi;
    UINT idcMaxUsed = idcMin;

    imi = GetMenuItemCount(hmenuSrc);
    while (--imi >= 0)
    {
        UINT idcT;
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     /* just in case */

        if (GetMenuItemInfo(hmenuSrc, imi, 1, &mii))
        {
            idcT = Shell_MergeMenus(GetMenuFromID(hmenuDst, mii.wID),
                mii.hSubMenu, (UINT)0, idcMin, idcMax,
                MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }

    return idcMaxUsed;
}


HRESULT _SetStatusBarZone(CStatusBar * psb, CFtpSite * pfs)
{
    if (EVAL(psb && pfs))
    {
        LPITEMIDLIST pidl = pfs->GetPidl();

        if (pidl)
        {
            TCHAR szUrl[MAX_URL_STRING];

            UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), 0, TRUE);
            psb->UpdateZonesPane(szUrl);
            ILFree(pidl);
        }
    }

    return S_OK;
}


/*****************************************************************************\

    Misc_CopyPidl

    I wrote this on my own, and discovered months later    ;Internal
    that this is the same as SHILClone...            ;Internal
                                ;Internal
\*****************************************************************************/
HRESULT Misc_CopyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILClone(pidl);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}


/*****************************************************************************\

    Misc_CloneHglobal

\*****************************************************************************/
HRESULT Misc_CloneHglobal(HGLOBAL hglob, HGLOBAL *phglob)
{
    LPVOID pv;
    HRESULT hres;

    ASSERT(hglob);
    *phglob = 0;            /* Rules are rules */
    pv = GlobalLock(hglob);
    if (EVAL(pv))
    {
        hres = Misc_CreateHglob(GlobalSize(hglob), pv, phglob);
        GlobalUnlock(hglob);
    }
    else
    {                /* Not a valid global handle */
        hres = E_INVALIDARG;
    }
    return hres;
}


#define FTP_PROPPAGES_FROM_INETCPL          (INET_PAGE_SECURITY | INET_PAGE_CONTENT | INET_PAGE_CONNECTION)

HRESULT AddFTPPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPARAM lParam, HINSTANCE * phinstInetCpl, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;

    if (NULL == *phinstInetCpl)
        *phinstInetCpl = LoadLibrary(TEXT("inetcpl.cpl"));

    // First add the pages from the Internet Control Panel.
    if (*phinstInetCpl)
    {
        PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(*phinstInetCpl, STR_ADDINTERNETPROPSHEETSEX);
        if (EVAL(pfnAddSheet))
        {
            IEPROPPAGEINFO iepi = {0};

            iepi.cbSize = sizeof(iepi);
            iepi.dwFlags = (DWORD)-1;       // all pages

            hr = pfnAddSheet(pfnAddPropSheetPage, lParam, 0, 0, &iepi);
        }
        // Don't FreeLibrary here, otherwise PropertyPage will GP-fault!
    }

    ASSERT(SUCCEEDED(hr));

    if (((LPPROPSHEETHEADER)lParam)->nPages > 0)
        return hr;
    else
        return S_FALSE;

}


#if 0
/*****************************************************************************\

    Misc_SetDataDword

\*****************************************************************************/
HRESULT Misc_SetDataDword(IDataObject *pdto, FORMATETC *pfe, DWORD dw)
{
    HRESULT hres;
    HGLOBAL hglob;

    hres = Misc_CreateHglob(sizeof(dw), &dw, &hglob);
    if (SUCCEEDED(hres))
    {
        STGMEDIUM stg = { TYMED_HGLOBAL, hglob, 0 };
        hres = pdto->SetData(&fe, &stg, 1);

        if (!(EVAL(SUCCEEDED(hres))))
            GlobalFree(hglob);
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
#endif


CFtpPidlList * CreateRelativePidlList(CFtpFolder * pff, CFtpPidlList * pPidlListFull)
{
    int nSize = pPidlListFull->GetCount();
    CFtpPidlList * pPidlListNew = NULL;

    if (nSize > 0)
    {
        LPCITEMIDLIST pidlFirst = pff->GetPrivatePidlReference();
        int nCount = 0;

        while (!ILIsEmpty(pidlFirst))
        {
            pidlFirst = _ILNext(pidlFirst);
            nCount++;
        }

        if (nSize > 0)
        {
            for (int nIndex = 0; nIndex < nSize; nIndex++)
            {
                int nLeft = nCount;
                LPITEMIDLIST pidl = pPidlListFull->GetPidl(nIndex);

                while (nLeft--)
                    pidl = _ILNext(pidl);

                AssertMsg((pidl ? TRUE : FALSE), TEXT("CreateRelativePidlList() pPidlListFull->GetPidl() should never fail because we got the size and no mem allocation is needed."));
                if (0 == nIndex)
                {
                    CFtpPidlList_Create(1, (LPCITEMIDLIST *)&pidl, &pPidlListNew);
                    if (!pPidlListNew)
                        break;
                }
                else
                {
                    // We only want to add top level nodes.
                    // ftp://s/d1/d2/         <- Root of copy.
                    // ftp://s/d1/d2/d3a/     <- First Top Level Item
                    // ftp://s/d1/d2/d3a/f1   <- Skip non-top level items
                    // ftp://s/d1/d2/d3b/     <- Second Top Level Item
                    if (pidl && !ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
                        pPidlListNew->InsertSorted(pidl);
                }
            }
        }
    }

    return pPidlListNew;
}


#define SZ_VERB_DELETEA             "delete"
/*****************************************************************************\
    FUNCTION: Misc_DeleteHfpl

    DESCRIPTION:
        Delete the objects described by a pflHfpl.
\*****************************************************************************/
HRESULT Misc_DeleteHfpl(CFtpFolder * pff, HWND hwnd, CFtpPidlList * pflHfpl)
{
    IContextMenu * pcm;
    HRESULT hr = pff->GetUIObjectOfHfpl(hwnd, pflHfpl, IID_IContextMenu, (LPVOID *)&pcm, FALSE);

    if (SUCCEEDED(hr))
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(ici),            // cbSize
            CMIC_MASK_FLAG_NO_UI,    // fMask
            hwnd,                    // hwnd
            SZ_VERB_DELETEA,        // lpVerb
            0,                        // lpParameters
            0,                        // lpDirectory
            0,                        // nShow
            0,                        // dwHotKey
            0,                        // hIcon
        };
        hr = pcm->InvokeCommand(&ici);
        pcm->Release();
    }
    else
    {
        // Couldn't delete source; oh well.  Don't need UI because
        // this should only happen in out of memory.
    }

    return hr;
}

/*****************************************************************************\

    Misc_FindStatusBar

    Get the status bar from a browser window.

    _UNDOCUMENTED_: The following quirks are not documented.

    Note that we need to be very paranoid about the way GetControlWindow
    works.  Some people (Desktop) properly return error if the window
    does not exist.  Others (Explorer) return S_OK when the window
    does not exist, but they kindly set *lphwndOut = 0.  Still others
    (Find File) return S_OK but leave *lphwndOut unchanged!

    In order to work with all these, we must manually set hwnd = 0
    before calling, and continue only if GetControlWindow returns success
    *and* the outgoing hwnd is nonzero.

    Furthermore, the documentation for GetControlWindow says that we
    have to check the window class before trusting the hwnd.

\*****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszStatusBarClass[] = STATUSCLASSNAME;

#pragma END_CONST_DATA

HWND Misc_FindStatusBar(HWND hwndOwner)
{
    HWND hwnd = 0;    // Must preinit in case GetControlWindow fails

    if (EVAL(hwndOwner))
    {
        IShellBrowser * psb = FileCabinet_GetIShellBrowser(hwndOwner);

        if (psb)
        {
            if (SUCCEEDED(psb->GetControlWindow(FCW_STATUS, &hwnd)) && hwnd) // This won't work when hosted in an IFRAME
            {
                //  Make sure it really is a status bar...
                TCHAR tszClass[ARRAYSIZE(c_tszStatusBarClass)+1];

                if (GetClassName(hwnd, tszClass, ARRAYSIZE(tszClass)) &&
                    !StrCmpI(tszClass, c_tszStatusBarClass))
                {
                    // We have a winner
                }
                else
                    hwnd = 0;        // False positive
            }
        }
    }

    return hwnd;
}

#ifdef DEBUG
void TraceMsgWithCurrentDir(DWORD dwTFOperation, LPCSTR pszMessage, HINTERNET hint)
{
    // For debugging...
    TCHAR szCurrentDir[MAX_PATH];
    DWORD cchDebugSize = ARRAYSIZE(szCurrentDir);

    DEBUG_CODE(DebugStartWatch());
    // PERF: Status FtpGetCurrentDirectory/FtpSetCurrentDirectory() takes
    //  180-280ms on ftp.microsoft.com on average.
    //  500-2000ms on ftp://ftp.tu-clausthal.de/ on average
    //  0-10ms on ftp://shapitst/ on average
    EVAL(FtpGetCurrentDirectory(hint, szCurrentDir, &cchDebugSize));
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "TraceMsgWithCurrentDir() FtpGetCurrentDirectory() returned %ls and took %lu milliseconds", szCurrentDir, DebugStopWatch()));
    TraceMsg(dwTFOperation, pszMessage, szCurrentDir);
}


void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, UlongToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, UlongToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG


/*****************************************************************************\

    GetCfBuf

    Convert a clipboard format name to something stringable.

\*****************************************************************************/
void GetCfBufA(UINT cf, LPSTR pszOut, int cchOut)
{
    if (!GetClipboardFormatNameA(cf, pszOut, cchOut))
       wnsprintfA(pszOut, cchOut, "[%04x]", cf);
}

/*****************************************************************************\

    AllocHGlob

    Allocate a moveable HGLOBAL of the requested size, lock it, then call
    the callback.  On return, unlock it and get out.

    Returns the allocated HGLOBAL, or 0.

\*****************************************************************************/

HGLOBAL AllocHGlob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode)
{
    HGLOBAL hglob = GlobalAlloc(GHND, cb);
    if (hglob)
    {
        LPVOID pv = GlobalLock(hglob);
        if (pv)
        {
            BOOL fRc = pfn(pv, pvRef, pvParam2, fUnicode);
            GlobalUnlock(hglob);
            if (!fRc)
            {
                GlobalFree(hglob);
                hglob = 0;
            }
        }
        else
        {
            GlobalFree(hglob);
            hglob = 0;
        }
    }

    return hglob;
}


SHELL_VERSION g_ShellVersion = SHELL_VERSION_UNKNOWN;
#define SHELL_VERSION_FOR_WIN95_AND_NT4     4


SHELL_VERSION GetShellVersion(void)
{
    if (SHELL_VERSION_UNKNOWN == g_ShellVersion)
    {
        g_ShellVersion = SHELL_VERSION_W95NT4;
        HINSTANCE hInst = LoadLibrary(TEXT("shell32.dll"));

        if (hInst)
        {
            DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hInst, "DllGetVersion");

            if (pfnDllGetVersion)
            {
                DLLVERSIONINFO dllVersionInfo;

                g_ShellVersion = SHELL_VERSION_IE4;      // Assume this.
                dllVersionInfo.cbSize = sizeof(dllVersionInfo);
                if (SUCCEEDED(pfnDllGetVersion(&dllVersionInfo)))
                {
                    if (SHELL_VERSION_FOR_WIN95_AND_NT4 < dllVersionInfo.dwMajorVersion)
                        g_ShellVersion = SHELL_VERSION_NT5;      // Assume this.
                }
            }
            FreeLibrary(hInst);
        }
    }
    
    return g_ShellVersion;
}

DWORD GetShdocvwVersion(void)
{
    static DWORD majorVersion=0;  // cache for perf

    if (majorVersion)
        return majorVersion;
    
    HINSTANCE hInst = LoadLibrary(TEXT("shdocvw.dll"));
    if (hInst)
    {
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hInst, "DllGetVersion");

        if (pfnDllGetVersion)
        {
            DLLVERSIONINFO dllVersionInfo;

            dllVersionInfo.cbSize = sizeof(dllVersionInfo);
            if (SUCCEEDED(pfnDllGetVersion(&dllVersionInfo)))
            {
                majorVersion = dllVersionInfo.dwMajorVersion;
            }
        }

        FreeLibrary(hInst);
    }

    return majorVersion;
}


BOOL ShouldSkipDropFormat(int nIndex)
{
    // Allow DROP_IDList or repositioning items withing
    // ftp windows won't work.
/*
    // We want to skip DROP_IDList on Win95 and WinNT4's shell
    // because it will cause the old shell to only offer DROPEFFECT_LINK
    // so download isn't available.
    if (((DROP_IDList == nIndex)) &&
        (SHELL_VERSION_W95NT4 == GetShellVersion()))
    {
        return TRUE;
    }
*/

#ifndef BROWSERONLY_DRAGGING
    if (((DROP_FGDW == nIndex) || (DROP_FGDA == nIndex)) &&
        (SHELL_VERSION_NT5 != GetShellVersion()))
    {
        return TRUE;
    }
#endif // BROWSERONLY_DRAGGING

    return FALSE;
}


void SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
}


void InitComctlForNaviteFonts(void)
{
    // hinst is ignored because we set it at our LibMain()
    INITCOMMONCONTROLSEX icex = {0};

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
}


BOOL DoesUrlContainNTDomainName(LPCTSTR pszUrl)
{
    BOOL fResult = FALSE;
    LPCTSTR pszPointer = pszUrl;

    if (lstrlen(pszPointer) > ARRAYSIZE(SZ_FTPURL))
    {
        pszPointer += ARRAYSIZE(SZ_FTPURL); // Skip past the scheme.
        pszPointer = StrChr(pszPointer, CH_URL_SLASH);
        if (pszPointer)
        {
            pszPointer = StrChr(CharNext(pszPointer), CH_URL_PASSWORD_SEPARATOR);
            if (pszPointer)
            {
                pszPointer = StrChr(CharNext(pszPointer), CH_URL_LOGON_SEPARATOR);
                if (pszPointer)
                    fResult = TRUE;
            }
        }
    }

    return fResult;
}


HRESULT CharReplaceWithStrW(LPWSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPWSTR pszStrToInsert)
{
    WCHAR szTemp[MAX_URL_STRING];

    StrCpyNW(szTemp, pszLocToInsert, ARRAYSIZE(szTemp));

    pszLocToInsert[0] = 0; // Terminate String here to kill char.
    StrCatBuffW(pszLocToInsert, pszStrToInsert, cchSize);
    StrCatBuffW(pszLocToInsert, &szTemp[cchChars], cchSize);

    return S_OK;
}


HRESULT CharReplaceWithStrA(LPSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPSTR pszStrToInsert)
{
    CHAR szTemp[MAX_URL_STRING];

    StrCpyNA(szTemp, pszLocToInsert, ARRAYSIZE(szTemp));

    pszLocToInsert[0] = 0; // Terminate String here to kill char.
    StrCatBuffA(pszLocToInsert, pszStrToInsert, cchSize);
    StrCatBuffA(pszLocToInsert, &szTemp[cchChars], cchSize);

    return S_OK;
}


HRESULT RemoveCharsFromString(LPTSTR pszLocToRemove, DWORD cchSizeToRemove)
{
    LPTSTR pszRest = &pszLocToRemove[cchSizeToRemove];

    MoveMemory((LPVOID) pszLocToRemove, (LPVOID) pszRest, (lstrlen(pszRest) + 1) * sizeof(TCHAR));
    return S_OK;
}


HRESULT RemoveCharsFromStringA(LPSTR pszLocToRemove, DWORD cchSizeToRemove)
{
    LPSTR pszRest = &pszLocToRemove[cchSizeToRemove];

    MoveMemory((LPVOID) pszLocToRemove, (LPVOID) pszRest, (lstrlenA(pszRest) + 1) * sizeof(CHAR));
    return S_OK;
}


// Helper function to convert Ansi string to allocated BSTR
#ifndef UNICODE
BSTR AllocBStrFromString(LPCTSTR psz)
{
    OLECHAR wsz[INFOTIPSIZE];  // assumes INFOTIPSIZE number of chars max

    SHAnsiToUnicode(psz, wsz, ARRAYSIZE(wsz));
    return SysAllocString(wsz);

}
#endif // UNICODE


/****************************************************\
    FUNCTION: StrListLength

    DESCRIPTION:
\****************************************************/
DWORD StrListLength(LPCTSTR ppszStrList)
{
    LPTSTR pszStr = (LPTSTR) ppszStrList;
    DWORD cchLength = 0;

    while (pszStr[0])
    {
        pszStr += (lstrlen(pszStr) + 1);
        cchLength++;
    }

    return cchLength;
}


/****************************************************\
    FUNCTION: CalcStrListSizeA

    DESCRIPTION:
\****************************************************/
DWORD CalcStrListSizeA(LPCSTR ppszStrList)
{
    LPSTR pszStr = (LPSTR) ppszStrList;
    DWORD cchSize = 1;

    while (pszStr[0])
    {
        DWORD cchSizeCurr = lstrlenA(pszStr) + 1;

        cchSize += cchSizeCurr;
        pszStr += cchSizeCurr;
    }

    return cchSize;
}


/****************************************************\
    FUNCTION: CalcStrListSizeW

    DESCRIPTION:
\****************************************************/
DWORD CalcStrListSizeW(LPCWSTR ppwzStrList)
{
    LPWSTR pwzStr = (LPWSTR) ppwzStrList;
    DWORD cchSize = 1;

    while (pwzStr[0])
    {
        DWORD cchSizeCurr = lstrlenW(pwzStr) + 1;

        cchSize += cchSizeCurr;
        pwzStr += cchSizeCurr;
    }

    return cchSize;
}


/****************************************************\
    FUNCTION: AnsiToUnicodeStrList

    DESCRIPTION:
\****************************************************/
void AnsiToUnicodeStrList(LPCSTR ppszStrListIn, LPCWSTR ppwzStrListOut, DWORD cchSize)
{
    LPWSTR pwzStrOut = (LPWSTR) ppwzStrListOut;
    LPSTR pszStrIn = (LPSTR) ppszStrListIn;

    while (pszStrIn[0])
    {
        SHAnsiToUnicode(pszStrIn, pwzStrOut, lstrlenA(pszStrIn) + 2);

        pszStrIn += lstrlenA(pszStrIn) + 1;
        pwzStrOut += lstrlenW(pwzStrOut) + 1;
    }

    pwzStrOut[0] = L'\0';
}


/****************************************************\
    FUNCTION: UnicodeToAnsiStrList

    DESCRIPTION:
\****************************************************/
void UnicodeToAnsiStrList(LPCWSTR ppwzStrListIn, LPCSTR ppszStrListOut, DWORD cchSize)
{
    LPSTR pszStrOut = (LPSTR) ppszStrListOut;
    LPWSTR pwzStrIn = (LPWSTR) ppwzStrListIn;

    while (pwzStrIn[0])
    {
        SHUnicodeToAnsi(pwzStrIn, pszStrOut, lstrlenW(pwzStrIn) + 2);

        pwzStrIn += lstrlenW(pwzStrIn) + 1;
        pszStrOut += lstrlenA(pszStrOut) + 1;
    }

    pszStrOut[0] = '\0';
}


/****************************************************\
    FUNCTION: Str_StrAndThunkA

    DESCRIPTION:
\****************************************************/
HRESULT Str_StrAndThunkA(LPTSTR * ppszOut, LPCSTR pszIn, BOOL fStringList)
{
#ifdef UNICODE
    if (!fStringList)
    {
        DWORD cchSize = (lstrlenA(pszIn) + 2);
        LPWSTR pwzBuffer = (LPWSTR) LocalAlloc(LPTR, cchSize * SIZEOF(WCHAR));

        if (!pwzBuffer)
            return E_OUTOFMEMORY;

        SHAnsiToUnicode(pszIn, pwzBuffer, cchSize);
        Str_SetPtrW(ppszOut, pwzBuffer);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeA(pszIn);
        Str_SetPtrW(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
        if (*ppszOut)
            AnsiToUnicodeStrList(pszIn, *ppszOut, cchSize);
    }

#else // UNICODE

    if (!fStringList)
    {
        // No thunking needed.
        Str_SetPtrA(ppszOut, pszIn);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeA(pszIn);
        Str_SetPtrA(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(CHAR));
        if (*ppszOut)
            CopyMemory(*ppszOut, pszIn, cchSize * sizeof(CHAR));
    }
#endif // UNICODE

    return S_OK;
}


BOOL IsValidFtpAnsiFileName(LPCTSTR pszString)
{
#ifdef UNICODE
    // TODO:
#endif // UNICODE
    return TRUE;
}


/****************************************************\
    FUNCTION: Str_StrAndThunkW

    DESCRIPTION:
\****************************************************/
HRESULT Str_StrAndThunkW(LPTSTR * ppszOut, LPCWSTR pwzIn, BOOL fStringList)
{
#ifdef UNICODE
    if (!fStringList)
    {
        // No thunking needed.
        Str_SetPtrW(ppszOut, pwzIn);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeW(pwzIn);
        Str_SetPtrW(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
        if (*ppszOut)
            CopyMemory(*ppszOut, pwzIn, cchSize * sizeof(WCHAR));
    }

#else // UNICODE

    if (!fStringList)
    {
        DWORD cchSize = (lstrlenW(pwzIn) + 2);
        LPSTR pszBuffer = (LPSTR) LocalAlloc(LPTR, cchSize * SIZEOF(CHAR));

        if (!pszBuffer)
            return E_OUTOFMEMORY;

        SHUnicodeToAnsi(pwzIn, pszBuffer, cchSize);
        Str_SetPtrA(ppszOut, pszBuffer);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeW(pwzIn);
        Str_SetPtrA(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(CHAR));
        if (*ppszOut)
            UnicodeToAnsiStrList(pwzIn, *ppszOut, cchSize * sizeof(CHAR));
    }
#endif // UNICODE

    return S_OK;
}


#ifndef UNICODE
// TruncateString
//
// purpose: cut a string at the given length in dbcs safe manner.
//          the string may be truncated at cch-2 if the sz[cch] points
//          to a lead byte that would result in cutting in the middle
//          of double byte character.
//
// update: made it faster for sbcs environment (5/26/97)
//         now returns adjusted cch            (6/20/97)
//
void  TruncateString(char *sz, int cchBufferSize)
{
    if (!sz || cchBufferSize <= 0) return;

    int cch = cchBufferSize - 1; // get index position to NULL out
    
    LPSTR psz = &sz[cch];
    
    while (psz >sz)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // Found non-leadbyte for the first time.
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or &sz[cch]
            psz++;
            break;
        }
    }
    if (((&sz[cch] - psz) & 1) && cch > 0)
    {
        // we're truncating the string in the middle of dbcs
        cch--;
    }
    sz[cch] = '\0';
    return;
}

#endif // UNICODE



HRESULT CopyStgMediumWrap(const STGMEDIUM * pcstgmedSrc, STGMEDIUM * pstgmedDest)
{
    HRESULT hr = CopyStgMedium(pcstgmedSrc, pstgmedDest);

    // if pstgmedDest->pUnkForElease is NULL,
    //  then we need to free hglobal because we own freeing the memory.
    //  else someone else owns the lifetime of the memory and releasing
    //  pUnkForElease is the way to indicate that we won't use it anymore.
    //
    // The problem is that urlmon's CopyStgMedium() ERRouniously copies the
    // pUnkForElease param in addition to cloning the memory.  This means
    // that we own freeing the memory but the pointer being non-NULL would
    // indicate that we don't own freeing the memory.

    // ASSERT(NULL == pstgmedDest->pUnkForElease);
    pstgmedDest->pUnkForRelease = NULL;

    return hr;
}


HRESULT SHBindToIDList(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (SUCCEEDED(hr))
    {
        hr = psf->BindToObject(pidl, pbc, riid, ppv);
        psf->Release();
    }

    return hr;
}



STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid)
{
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT) g_cfTargetCLSID, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        CLSID *pdw = (CLSID *)GlobalLock(medium.hGlobal);
        if (pdw)
        {
            *pclsid = *pdw;
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


STDAPI DataObj_SetPreferredEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    return DataObj_SetDWORD(pdtobj, g_dropTypes[DROP_PrefDe].cfFormat, dwEffect);
}


STDAPI DataObj_SetPasteSucceeded(IDataObject *pdtobj, DWORD dwEffect)
{
    return DataObj_SetDWORD(pdtobj, g_formatPasteSucceeded.cfFormat, dwEffect);
}




/****************************************************\
    FUNCTION: ShowEnableWindow

    DESCRIPTION:
        If you don't want a window to be visible or
    usable by the user, you need to call both
    ShowWindow(SW_HIDE) and EnableWindow(FALSE) or
    the window may be hidden but still accessible via
    the keyboard.
\****************************************************/
void ShowEnableWindow(HWND hwnd, BOOL fShow)
{
    ShowWindow(hwnd, (fShow ? SW_SHOW : SW_HIDE));
    EnableWindow(hwnd, fShow);
}


STDAPI StringToStrRetW(LPCWSTR pwzString, STRRET *pstrret)
{
    HRESULT hr = SHStrDupW(pwzString, &pstrret->pOleStr);
    if (SUCCEEDED(hr))
    {
        pstrret->uType = STRRET_WSTR;
    }
    return hr;
}


#define BIT_8_SET       0x80

BOOL Is7BitAnsi(LPCWIRESTR pwByteStr)
{
    BOOL fIs7BitAnsi = TRUE;

    if (pwByteStr)
    {
        while (pwByteStr[0]) 
        {
            if (BIT_8_SET & pwByteStr[0])
            {
                fIs7BitAnsi = FALSE;
                break;
            }

            pwByteStr++;
        }
    }

    return fIs7BitAnsi;
}


HRESULT LoginAs(HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;
    CFtpSite * pfs = pfd->GetFtpSite();

    ASSERT(hwnd && pff);
    if (pfs)
    {
        CAccounts cAccounts;
        TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
        TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
        LPCITEMIDLIST pidlPrevious = pfd->GetPidlReference();

        pfs->GetServer(szServer, ARRAYSIZE(szServer));
        pfs->GetUser(szUser, ARRAYSIZE(szUser));
        pfs->GetPassword(szPassword, ARRAYSIZE(szPassword));

        hr = cAccounts.DisplayLoginDialog(hwnd, LOGINFLAGS_DEFAULT, szServer, szUser, ARRAYSIZE(szUser), szPassword, ARRAYSIZE(szPassword));
        if (S_OK == hr)
        {
            LPITEMIDLIST pidlNew;

            ASSERT(pff->GetItemAllocatorDirect());
            hr = PidlReplaceUserPassword(pidlPrevious, &pidlNew, pff->GetItemAllocatorDirect(), szUser, szPassword);
            if (SUCCEEDED(hr))
            {
                CFtpSite * pfs;
                LPITEMIDLIST pidlRedirect;

                // We need to update the password in the site to redirect to the correct or new one.
                if (EVAL(SUCCEEDED(PidlReplaceUserPassword(pidlNew, &pidlRedirect, pff->GetItemAllocatorDirect(), szUser, TEXT(""))) &&
                         SUCCEEDED(SiteCache_PidlLookup(pidlRedirect, TRUE, pff->GetItemAllocatorDirect(), &pfs))))
                {
                    EVAL(SUCCEEDED(pfs->SetRedirPassword(szPassword)));
                    pfs->Release();
                    ILFree(pidlRedirect);
                }

                // pidl is a full private pidl.  pidlFull will be a full public pidl because
                // that's what the browser needs to get back from the root of THE public
                // name space back to and into us.
                LPITEMIDLIST pidlFull = pff->CreateFullPublicPidl(pidlNew);
                if (pidlFull)
                {
                    hr = IUnknown_PidlNavigate(punkSite, pidlFull, TRUE);
                    ILFree(pidlFull);
                }
                else
                    hr = E_FAIL;

                ILFree(pidlNew);
            }
        }
    }

    return hr;
}



HRESULT LoginAsViaFolder(HWND hwnd, CFtpFolder * pff, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;
    CFtpDir * pfd = pff->GetFtpDir();

    if (pfd)
    {
        hr = LoginAs(hwnd, pff, pfd, punkSite);
        pfd->Release();
    }

    return hr;
}


#define PATH_IS_DRIVE(wzPath)      (-1 != PathGetDriveNumberW(wzPath))

HRESULT SHPathPrepareForWriteWrapW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (SHELL_VERSION_NT5 == GetShellVersion())
    {
        // NT5's version of the API is better.
        hr = _SHPathPrepareForWriteW(hwnd, punkEnableModless, pwzPath, dwFlags);
    }
    else
    {
        if (PATH_IS_DRIVE(pwzPath))
        {
            hr = (SHCheckDiskForMediaW(hwnd, punkEnableModless, pwzPath, wFunc) ? S_OK : E_FAIL);
        }
        else
        {
            if (PathIsUNCW(pwzPath))
            {
                hr = (PathFileExistsW(pwzPath) ? S_OK : E_FAIL);
            }
        }
    }

    return hr;
}

// Helper function
int _LoadStringW(HINSTANCE hinst, UINT id, LPWSTR wsz, UINT cchMax)
{
    char szT[512];
    if (LoadStringA(hinst, id, szT, ARRAYSIZE(szT)))
    {
        TraceMsg(0, "LoadStringW just loaded (%s)", szT);
        return SHAnsiToUnicode(szT, wsz, cchMax) - 1;    // -1 for terminator
    }
    else
    {
        TraceMsg(DM_TRACE, "sdv TR LoadStringW(%x) failed", id);
        wsz[0] = L'\0';
    }
    return 0;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    HRESULT hr = S_OK;
    HINSTANCE hReturn = ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);

    if ((HINSTANCE)32 > hReturn)
    {
        hr = ResultFromLastError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\view.h ===
/*****************************************************************************\
    FILE: view.h

    DESCRIPTION:
        This is our ShellView which implements FTP specific behavior.  We get
    the default DefView implementation and then use IShellFolderViewCB to 
    override behavior specific to us.
\*****************************************************************************/

#ifndef _FTPVIEW_H
#define _FTPVIEW_H

#include "isfvcb.h"
#include "statusbr.h"
#include "msieftp.h"
#include "dspsprt.h"


CFtpView * GetCFtpViewFromDefViewSite(IUnknown * punkSite);
CStatusBar * GetCStatusBarFromDefViewSite(IUnknown * punkSite);
HRESULT FtpView_SetRedirectPidl(IUnknown * punkSite, LPCITEMIDLIST pidl);


class CFtpView
                : public CBaseFolderViewCB
                , public IFtpWebView
                , public CImpIDispatch
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CBaseFolderViewCB::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {return CBaseFolderViewCB::Release();};

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    
    // *** IFtpWebView methods ***
    virtual STDMETHODIMP get_Server(BSTR * pbstr);
    virtual STDMETHODIMP get_Directory(BSTR * pbstr);
    virtual STDMETHODIMP get_UserName(BSTR * pbstr);
    virtual STDMETHODIMP get_PasswordLength(long * plLength);
    virtual STDMETHODIMP get_EmailAddress(BSTR * pbstr);
    virtual STDMETHODIMP put_EmailAddress(BSTR bstr);
    virtual STDMETHODIMP get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin);
    virtual STDMETHODIMP get_MessageOfTheDay(BSTR * pbstr);
    virtual STDMETHODIMP LoginAnonymously(void);
    virtual STDMETHODIMP LoginWithPassword(BSTR bUserName, BSTR bPassword);
    virtual STDMETHODIMP LoginWithoutPassword(BSTR bUserName);
    virtual STDMETHODIMP InvokeHelp(void) {return _OnInvokeFtpHelp(m_hwndOwner);};

    // *** CFtpViewPriv methods ***
    BOOL IsForegroundThread(void);
    CStatusBar * GetStatusBar(void) { return m_psb; };
    HRESULT SetRedirectPidl(LPCITEMIDLIST pidlRedirect);

public:
    // Public Member Functions
    static HRESULT DummyHintCallback(HWND hwnd, CFtpFolder * pff, HINTERNET hint, LPVOID pv1, LPVOID pv2);

    // Friend Functions
    friend HRESULT CFtpView_Create(CFtpFolder * pff, HWND hwndOwner, REFIID riid, LPVOID * ppv);

protected:
    // Private Member Variables
    HWND                    m_hwndOwner;            // The owner window
    HWND                    m_hwndStatusBar;        // The Status Bar window
    CFtpFolder *            m_pff;                  // The owner Folder
    LPGLOBALTIMEOUTINFO     m_hgtiWelcome;          // The timeout for the welcome message
    CStatusBar *            m_psb;                  // The timeout for the welcome message
    HINSTANCE               m_hinstInetCpl;         // HANDLE to Internet Control panel for View.Options.
    RECT                    m_rcPrev;               // Previous size so we know when to ignore resizes.
    UINT                    m_idMergedMenus;        // Where did I start merging menus?
    UINT                    m_nMenuItemsAdded;      // How many menu items did I had?
    LPITEMIDLIST            m_pidlRedirect;         // We want to redirect to this pidl. See the comments in _OnBackGroundEnumDone().
    UINT                    m_nThreadID;            // What is the main thread?

    // Private Member Functions
    CFtpView(CFtpFolder * pff, HWND hwndOwner);
    ~CFtpView();

    void _InitStatusBar(void);
    void _ShowMotd(void);
    HRESULT _OnInvokeFtpHelp(HWND hwnd);
    HRESULT _LoginWithPassword(LPCTSTR pszUserName, LPCTSTR pszPassword);

    virtual HRESULT _OnWindowCreated(void);
    virtual HRESULT _OnDefItemCount(LPINT pi);
    virtual HRESULT _OnGetHelpText(LPARAM lParam, WPARAM wParam);
    virtual HRESULT _OnGetZone(DWORD * pdwZone, WPARAM wParam);
    virtual HRESULT _OnGetPane(DWORD dwPaneID, DWORD * pdwPane);
    virtual HRESULT _OnRefresh(BOOL fReload);
    virtual HRESULT _OnDidDragDrop(DROPEFFECT de, IDataObject * pdto);
    virtual HRESULT _OnGetDetailsOf(UINT ici, PDETAILSINFO pdi);
    virtual HRESULT _OnInvokeCommand(UINT idc);
    virtual HRESULT _OnMergeMenu(LPQCMINFO pqcm);
    virtual HRESULT _OnUnMergeMenu(HMENU hMenu);
    virtual HRESULT _OnColumnClick(UINT ici);
    virtual HRESULT _OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents);
    virtual HRESULT _OnSize(LONG x, LONG y);
    virtual HRESULT _OnUpdateStatusBar(void);
    virtual HRESULT _OnThisIDList(LPITEMIDLIST * ppidl);
    virtual HRESULT _OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData);
    virtual HRESULT _OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex);
    virtual HRESULT _OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd);
    virtual HRESULT _OnBackGroundEnumDone(void);

    HRESULT _OnInvokeLoginAs(HWND hwndOwner);
    HRESULT _OnInvokeNewFolder(HWND hwndOwner);

    void _ShowMotdPsf(HWND hwndOwner);

private:
    static INT_PTR CALLBACK _MOTDDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam);
};

#endif // _FTPVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\view.cpp ===
/*****************************************************************************\
    FILE: view.cpp

    DESCRIPTION:
        This is our ShellView which implements FTP specific behavior.  We get
    the default DefView implementation and then use IShellFolderViewCB to 
    override behavior specific to us.
\*****************************************************************************/

#include "priv.h"
#include "view.h"
#include "ftpobj.h"
#include "statusbr.h"
#include "dialogs.h"
#include <inetcpl.h>
#include <htmlhelp.h>
#include "newmenu.h"


extern ULONG g_cRef_CFtpView;

// {FBDB45F0-DBF8-11d2-BB9B-006097DF5BD4}   Private to msieftp.dll, NEVER EVER use outside of this DLL
const GUID IID_CFtpViewPrivThis = { 0xfbdb45f0, 0xdbf8, 0x11d2, { 0xbb, 0x9b, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };


/*****************************************************************************
 *
 *      COLINFO, c_rgci
 *
 *      Column information for DVM_GETDETAILSOF.
 *
 *****************************************************************************/

const struct COLINFO {
    UINT cchCol;
    UINT uiFmt;
} c_rgci[] = {
    {   30, LVCFMT_LEFT },
    {   10, LVCFMT_RIGHT },
    {   20, LVCFMT_LEFT },
    {   20, LVCFMT_LEFT },
};


BOOL CFtpView::IsForegroundThread(void)
{
    return (GetCurrentThreadId() == m_nThreadID);
}


/*****************************************************************************\
    FUNCTION: _MOTDDialogProc

    DESCRIPTION:
\*****************************************************************************/
INT_PTR CALLBACK CFtpView::_MOTDDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = FALSE;

    switch (wm)
    {
    case WM_INITDIALOG:
        {
            CFtpView * pThis = (CFtpView *) lParam;
            CFtpGlob * pfg = pThis->m_pff->GetSiteMotd();

            if (EVAL(pfg))
            {
                // TODO: NT #250018. Format the message and make it look pretty.
                //       so it doesn't have the FTP status numbers.  We may also
                //       want to filter only the message that comes thru with
                //       status numbers 230
                EVAL(SetWindowText(GetDlgItem(hDlg, IDC_MOTDDLG_MESSAGE), pfg->GetHGlobAsTCHAR()));
                pfg->Release();
            }

        }
        break;

    case WM_COMMAND:
        if ((IDOK == GET_WM_COMMAND_ID(wParam, lParam)) ||
            (IDCANCEL == GET_WM_COMMAND_ID(wParam, lParam)))
            EndDialog(hDlg, TRUE);
        break;
    }

    return lResult;
}


/*****************************************************************************
 *
 *      _ShowMotdPsf
 *
 *      Show the motd for a particular psf.
 *
 *****************************************************************************/
void CFtpView::_ShowMotdPsf(HWND hwndOwner)
{
    DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_MOTDDLG), hwndOwner, _MOTDDialogProc, (LPARAM)this);
}

/*****************************************************************************
 *
 *      _ShowMotd
 *
 *      When Explorer finally goes idle, this procedure will be called,
 *      and we will show the FTP site's (new) motd.
 *
 *****************************************************************************/
void CFtpView::_ShowMotd(void)
{
    m_hgtiWelcome = 0;

    if (EVAL(m_pff))
        _ShowMotdPsf(m_hwndOwner);
    else
    {
        // We got cancelled prematurely
    }
}

/*****************************************************************************
 *
 *      _OnGetDetailsOf
 *
 *      ici     - column for which information is requested
 *      pdi     -> DETAILSINFO
 *
 *      If pdi->pidl is 0, then we are asking for information about
 *      what columns to display.  If pdi->pidl is nonzero, then we
 *      are asking for particular information about the specified pidl.
 *
 *      _UNDOCUMENTED_: This callback and the DETAILSINFO structure
 *      are not documented.  Nor is the quirk about pdi->pidl as
 *      noted above.
 *
 *****************************************************************************/
#define MAX_SIZE_STR        30

HRESULT CFtpView::_OnGetDetailsOf(UINT ici, PDETAILSINFO pdi)
{
    HRESULT hr = E_FAIL;

    if (ici < COL_MAX)
    {
        pdi->str.uType = STRRET_CSTR;
        pdi->str.cStr[0] = '\0';

        if (pdi->pidl)
        {
            switch (ici)
            {
            case COL_NAME:
                {
                    WCHAR wzDisplayName[MAX_PATH];
                    hr = FtpItemID_GetDisplayName(pdi->pidl, wzDisplayName, ARRAYSIZE(wzDisplayName));
                    if (EVAL(SUCCEEDED(hr)))
                        StringToStrRetW(wzDisplayName, &pdi->str);
                }
                break;

            case COL_SIZE:
                //  (Directories don't get a size.  Shell rules.)
                if (!FtpPidl_IsDirectory(pdi->pidl, TRUE))
                {
                    LONGLONG llSize = (LONGLONG) FtpItemID_GetFileSize(pdi->pidl);
                    WCHAR wzSizeStr[MAX_SIZE_STR];

                    if (StrFormatByteSizeW(llSize, wzSizeStr, ARRAYSIZE(wzSizeStr)))
                        SHUnicodeToAnsi(wzSizeStr, pdi->str.cStr, ARRAYSIZE(pdi->str.cStr));
                    else
                        StrFormatByteSizeA(FtpItemID_GetFileSizeLo(pdi->pidl), pdi->str.cStr, ARRAYSIZE(pdi->str.cStr));
                }
                hr = S_OK;
            break;

            case COL_TYPE:
                hr = FtpPidl_GetFileTypeStrRet(pdi->pidl, &pdi->str);
                break;

            case COL_MODIFIED:
                {
                    TCHAR szDateTime[MAX_PATH];

                    // We need the time in UTC because that's what Misc_StringFromFileTime()
                    // wants.
                    FILETIME ftLastModifiedUTC = FtpPidl_GetFileTime(pdi->pidl);
                    DWORD dwFlags = FDTF_SHORTDATE | FDTF_SHORTTIME;

                    switch (pdi->fmt)
                    {
                        case LVCFMT_LEFT_TO_RIGHT :
                            dwFlags |= FDTF_LTRDATE;
                        break;

                        case LVCFMT_RIGHT_TO_LEFT :
                            dwFlags |= FDTF_RTLDATE;
                        break;
                    }

                    // Misc_StringFromFileTime() wants UTC
                    Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModifiedUTC, dwFlags);
                    hr = StringToStrRetW(szDateTime, &pdi->str);
                }
                break;
            }

        }
        else
        {
            WCHAR wzColumnLable[MAX_PATH];

            pdi->fmt = c_rgci[ici].uiFmt;
            pdi->cxChar = c_rgci[ici].cchCol;

            EVAL(LoadStringW(HINST_THISDLL, IDS_HEADER_NAME(ici), wzColumnLable, ARRAYSIZE(wzColumnLable)));
            hr = StringToStrRetW(wzColumnLable, &pdi->str);
        }
    }
    else
        hr = E_NOTIMPL;

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnColumnClick

    DESCRIPTION:
      _UNDOCUMENTED_: This callback and its parameters are not documented.
      _UNDOCUMENTED_: ShellFolderView_ReArrange is not documented.

    PARAMETERS:
      hwnd    - view window
      ici     - column that was clicked
\*****************************************************************************/
HRESULT CFtpView::_OnColumnClick(UINT ici)
{
    ShellFolderView_ReArrange(m_hwndOwner, ici);

    return S_OK;
}


HRESULT CFtpView::_OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData)
{
    return AddFTPPropertyPages(pData->pfn, pData->lParam, &m_hinstInetCpl, m_psfv);
}


/*****************************************************************************\
    FUNCTION: _OnInitMenuPopup

    DESCRIPTION:
        We use IContextMenu::QueryContectMenu() to merge background items into
    the File menu.  This doesn't work on browser only because it's not supported
    so we would like to see if this works.

    PARAMETERS:
\*****************************************************************************/
HRESULT CFtpView::_OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex)
{
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnMergeMenu

    DESCRIPTION:
      _UNDOCUMENTED_: This callback and its parameters are not documented.
      _UNDOCUMENTED_: Nothing about menu merging is documented.

    PARAMETERS:
      pqcm    - QueryContextMenu info
\*****************************************************************************/
HRESULT CFtpView::_OnMergeMenu(LPQCMINFO pqcm)
{
    HRESULT hr;
    HMENU hmenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDM_FTPMERGE));

    if (SHELL_VERSION_W95NT4 != GetShellVersion())
    {
        // We prefer to add "New" and "Login As" via
        // IContextMenu::QueryContextMenu() but it wasn't implemented
        // in browser only.  The IDM_FTPMERGE menu contains a second
        // copy for the browser only case so we need to remove them
        // if it's not browser only.
        EVAL(DeleteMenu(hmenu, FCIDM_MENU_FILE, MF_BYCOMMAND));
    }

    if (SHELL_VERSION_IE4 < GetShellVersion())
    {
        // Remove "Help.FTP Help" because we will have that work done
        // in "Help.Help Topics" on NT5 and after.  We don't do this for
        // earlier versions of shell32 because shell32 in NT5 is the 
        // first version to support "HtmlHelp" over WinHelp.  This is
        // needed because FTP's help is stored in IE's HTML Help files.
        EVAL(DeleteMenu(hmenu, IDC_ITEM_FTPHELP, MF_BYCOMMAND));
    }

    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        m_idMergedMenus = pqcm->idCmdFirst;
        m_nMenuItemsAdded = GetMenuItemCount(hmenu);
        DestroyMenu(hmenu);

        // Remove duplicate items. (Browser Only)
        _SHPrettyMenu(pqcm->hmenu);

        int nItems = GetMenuItemCount(pqcm->hmenu);
        if (nItems)
        {
            // Pretty the submenus because we added separators. NT #358197
            for (int nIndex = 0; nIndex < nItems; nIndex++)
            {
                HMENU hSubMenu = GetSubMenu(pqcm->hmenu, nIndex);
                _SHPrettyMenu(hSubMenu);
            }
        }

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    // NT #267081, some other people (IE) will reformat the StatusBar during the
    // asynch navigation.  I take this event (MergeMenus) and reformat the
    // status bar if necessary.
    _InitStatusBar();

    return hr;
}


/*****************************************************************************\
    FUNCTION: UnMergeMenu

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT UnMergeMenu(HMENU hMenu, UINT idOffset, HMENU hMenuTemplate)
{
    HRESULT hr = S_OK;
    UINT nIndex;
    UINT nEnd = GetMenuItemCount(hMenuTemplate);

    for (nIndex = 0; nIndex < nEnd; nIndex++)
    {
        UINT idToDelete = GetMenuItemID(hMenuTemplate, nIndex);

        if (-1 != idToDelete)
            DeleteMenu(hMenu, (idToDelete + idOffset), MF_BYPOSITION);
        else
        {
            // It may be a submenu, so we may need to recurse.
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU;
            mii.cch = 0;     // just in case

            if (GetMenuItemInfo(hMenuTemplate, nIndex, TRUE, &mii) && mii.hSubMenu)
            {
                // It is a sub menu, so delete those items also.
                hr = UnMergeMenu(hMenu, idOffset, mii.hSubMenu);
            }
        }
    }

    return hr;
}


HRESULT CFtpView::_OnUnMergeMenu(HMENU hMenu)
{
    HRESULT hr = S_OK;

    // Did I merge anything?
    if (m_idMergedMenus && m_nMenuItemsAdded)
    {
        HMENU hMenuFTP = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDM_FTPMERGE));

        if (hMenuFTP)
        {
            hr = UnMergeMenu(hMenu, m_idMergedMenus, hMenuFTP);
            DestroyMenu(hMenuFTP);
        }

        m_idMergedMenus = 0;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnInvokeLoginAs

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT CFtpView::_OnInvokeLoginAs(HWND hwndOwner)
{
    ASSERT(m_pff);
    return LoginAsViaFolder(hwndOwner, m_pff, m_psfv);
}


/*****************************************************************************\
    FUNCTION: _OnInvokeNewFolder

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT CFtpView::_OnInvokeNewFolder(HWND hwndOwner)
{
    POINT pt = {0,0};

    return CreateNewFolder(hwndOwner, m_pff, NULL, m_psfv, FALSE, pt);
}


/*****************************************************************************\
    FUNCTION: _OnInvokeCommand

    DESCRIPTION:
    _UNDOCUMENTED_: This callback and its parameters are not documented.
    _UNDOCUMENTED_: ShellFolderView_ReArrange is not documented.

    PARAMETERS:
    idc     - Command being invoked
\*****************************************************************************/
HRESULT CFtpView::_OnInvokeCommand(UINT idc)
{
    HRESULT hr = S_OK;

    switch (idc)
    {
    case IDM_SORTBYNAME:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYTYPE:
    case IDM_SORTBYDATE:
        ShellFolderView_ReArrange(m_hwndOwner, CONVERT_IDMID_TO_COLNAME(idc));
        break;

    case IDC_ITEM_ABOUTSITE:
        _ShowMotdPsf(m_hwndOwner);
        break;

    case IDC_ITEM_FTPHELP:
        _OnInvokeFtpHelp(m_hwndOwner);
        break;

    case IDC_LOGIN_AS:
        _OnInvokeLoginAs(m_hwndOwner);
        break;

    case IDC_ITEM_NEWFOLDER:
        _OnInvokeNewFolder(m_hwndOwner);
        break;

#ifdef ADD_ABOUTBOX
    case IDC_ITEM_ABOUTFTP:
        hr = DisplayAboutBox(m_hwndOwner);
        break;
#endif // ADD_ABOUTBOX

    default:
        ASSERT(0);
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetHelpText

    DESCRIPTION:
        The shell want's the Help Text but they want it in their format (Ansi
    vs. Unicode).
\*****************************************************************************/
HRESULT CFtpView::_OnGetHelpText(LPARAM lParam, WPARAM wParam)
{
    HRESULT hres = E_FAIL;
    UINT uiID = IDS_ITEM_HELP(LOWORD(wParam));
    TCHAR szHelpText[MAX_PATH];
    LPWSTR pwzHelpTextOut = (LPWSTR) lParam;    // Only one of these is correct and fUnicodeShell indicates which one.
    LPSTR pszHelpTextOut = (LPSTR) lParam;

    pwzHelpTextOut[0] = L'\0';   // Terminate string. (Ok if it's ANSI)

    szHelpText[0] = TEXT('\0');
    // This will fail for some items that the shell will provide for us.
    // These include View.ArrangeIcon.AutoArrange.
    // NOTE: This currently doesn't work for everything in the View.ArrangeIcon
    //         menu except AutoArrange because uiID is 30-33, 
    //         not 40-43 (IDS_HEADER_HELP(COL_NAME) - IDS_HEADER_HELP(COL_MODIFIED)).
    //         This will require changing the resource IDs but that will mess up
    //         the localizers and require changing IDS_HEADER_NAME().
    if (LoadString(HINST_THISDLL, uiID, szHelpText, ARRAYSIZE(szHelpText)))
    {
        HMODULE hMod = GetModuleHandle(TEXT("shell32.dll"));

        if (hMod)
        {
            BOOL fUnicodeShell = (NULL != GetProcAddress(hMod, "WOWShellExecute"));

            // NOTE: DVM_GETHELPTEXT will want a UNICODE string if we are running
            //       on NT and an Ansi string if we are running on Win95.  Let's thunk it to what
            //       they want.

            if (fUnicodeShell)
                SHTCharToUnicode(szHelpText, pwzHelpTextOut, HIWORD(wParam));
            else
                SHTCharToAnsi(szHelpText, pszHelpTextOut, HIWORD(wParam));

            hres = S_OK;
        }
    }

    return hres;
}


#define         SZ_HELPTOPIC_FILEA        "iexplore.chm > iedefault"
#define         SZ_HELPTOPIC_FTPSECTIONA  "ftp_over.htm"
#define         SZ_HELPTOPIC_FILEW         L"iexplore.chm"
#define         SZ_HELPTOPIC_FTPSECTIONW   L"ftp_over.htm"

/*****************************************************************************\
    FUNCTION: _OnInvokeFtpHelp

    DESCRIPTION:
        The wants Help specific to FTP.
\*****************************************************************************/
HRESULT CFtpView::_OnInvokeFtpHelp(HWND hwnd)
{
    HRESULT hr = E_INVALIDARG;
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_IEHelp;

//    ASSERT(m_hwndOwner && m_psfv);        // Not available on browser only
    IUnknown_EnableModless((IUnknown *)m_psfv, FALSE);
    hr = FaultInIEFeature(m_hwndOwner, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
    IUnknown_EnableModless((IUnknown *)m_psfv, TRUE);

    HtmlHelpA(NULL, SZ_HELPTOPIC_FILEA, HH_HELP_FINDER, (DWORD_PTR) SZ_HELPTOPIC_FTPSECTIONA);
    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetHelpTopic

    DESCRIPTION:
        Remove "Help.FTP Help" because we will have that work done
    in "Help.Help Topics" on NT5 and after.  We don't do this for
    earlier versions of shell32 because shell32 in NT5 is the 
    first version to support "HtmlHelp" over WinHelp.  This is
    needed because FTP's help is stored in IE's HTML Help files.
\*****************************************************************************/
HRESULT CFtpView::_OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd)
{
    HRESULT hr = E_NOTIMPL;

    // Remove "Help.FTP Help" because we will have that work done
    // in "Help.Help Topics" on NT5 and after.  We don't do this for
    // earlier versions of shell32 because shell32 in NT5 is the 
    // first version to support "HtmlHelp" over WinHelp.  This is
    // needed because FTP's help is stored in IE's HTML Help files.
    if (SHELL_VERSION_IE4 < GetShellVersion())
    {
        StrCpyNW(phtd->wszHelpFile, SZ_HELPTOPIC_FILEW, ARRAYSIZE(phtd->wszHelpFile));
        StrCpyNW(phtd->wszHelpTopic, SZ_HELPTOPIC_FTPSECTIONW, ARRAYSIZE(phtd->wszHelpTopic));
        hr = S_OK;
    }

    return hr;
}

/*****************************************************************************\
    FUNCTION: _OnGetZone

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnGetZone(DWORD * pdwZone, WPARAM wParam)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwZone = URLZONE_INTERNET;    // Default
    LPCITEMIDLIST pidl = m_pff->GetPrivatePidlReference();
    
    if (pidl)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        // NT #277100: This may fail if TweakUI is installed because
        //             they abuse us.
        hr = UrlCreateFromPidlW(pidl, SHGDN_FORPARSING, wzUrl, ARRAYSIZE(wzUrl), ICU_ESCAPE | ICU_USERNAME, FALSE);
        if (SUCCEEDED(hr))
        {
            IInternetSecurityManager * pism;

            if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IInternetSecurityManager, (void **) &pism)))
            {
                pism->MapUrlToZone(wzUrl, &dwZone, 0);
                pism->Release();
            }
        }
    }
    
    if (pdwZone)
    {
        *pdwZone = dwZone;
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetPane

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnGetPane(DWORD dwPaneID, DWORD * pdwPane)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwPane = PANE_NONE;    // Default unknown

    switch (dwPaneID)
    {
        case PANE_NAVIGATION:
            dwPane = STATUS_PANE_STATUS;
            break;
        case PANE_ZONE:
            dwPane = STATUS_PANE_ZONE;
            break;
        default:
            break;
    }

    if (pdwPane)
    {
        *pdwPane = dwPane;
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnRefresh

    DESCRIPTION:
        We need to purge the cache and force our selves to hit the server again.
\*****************************************************************************/
HRESULT CFtpView::_OnRefresh(BOOL fReload)
{
    if (EVAL(m_pff) && fReload)
        m_pff->InvalidateCache();

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnBackGroundEnumDone

    DESCRIPTION:
        Our enum happens on the background.  Sometimes we decide that we want
    to do a redirect during the enumeration because the UserName/Password
    didn't allow access to the server but the user provided a pair that does.
    Since we can't access the ComDlgBrowser's IShellBrowser::BrowseObject()
    on the background, we need to call it on the forground.  In order to do
    that, we need an event that happens on the forground.  Well this is that
    even baby.
\*****************************************************************************/
HRESULT CFtpView::_OnBackGroundEnumDone(void)
{
    HRESULT hr = S_OK;

    if (m_pidlRedirect)
    {
        LPITEMIDLIST pidlRedirect = NULL;

        ENTERCRITICAL;
        if (m_pidlRedirect)
        {
            pidlRedirect = m_pidlRedirect;
            m_pidlRedirect = NULL;
        }
        LEAVECRITICAL;

        if (pidlRedirect)
        {
            IShellBrowser * psb;
            hr = IUnknown_QueryService(_punkSite, SID_SCommDlgBrowser, IID_IShellBrowser, (LPVOID *) &psb);
            if (SUCCEEDED(hr))
            {
                hr = psb->BrowseObject(pidlRedirect, 0);
            
                AssertMsg(SUCCEEDED(hr), TEXT("CFtpView::_OnBackGroundEnumDone() defview needs to support QS(SID_ShellFolderViewCB) on all platforms that hit this point"));
                psb->Release();
            }

            ILFree(pidlRedirect);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetNotify

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents)
{
    if (EVAL(lEvents))
        *lEvents = FTP_SHCNE_EVENTS;

    if (EVAL(ppidl))
    {
        // Normally I would use pidlRoot to get ChangeNotify messages but since
        // that doesn't work, it's necessary to broadcast ChangeNotify messages
        // using pidlTarget and receive them using pidlTarget. This is the later
        // case.
        if (EVAL(m_pff))
            *ppidl = (LPITEMIDLIST) m_pff->GetPublicTargetPidlReference();
        else
            *ppidl = NULL;
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnSize

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnSize(LONG x, LONG y)
{
    RECT rcCurrent;
    HRESULT hr = S_OK;

    ASSERT(m_hwndOwner);
    GetWindowRect(m_hwndOwner, &rcCurrent);

    // Has the size really changed?
    if ((m_rcPrev.bottom != rcCurrent.bottom) ||
        (m_rcPrev.top != rcCurrent.top) ||
        (m_rcPrev.left != rcCurrent.left) ||
        (m_rcPrev.right != rcCurrent.right))
    {
        // yes, so update the StatusBar.
        if (m_psb)
            hr = m_psb->Resize(x, y);
        m_rcPrev = rcCurrent;
    }
    else
    {
        // No, so ignore it because we may stomp on some other
        // active view. (Because we get this message even after
        // another view took over the brower).

        // I don't care about resizing to zero.
        // I don't think the user will ever need it and it casues
        // bug #198695 where the addressband goes blank.  This is because
        // defview will call us thru each of the two places:
        // 1) CFtpFolder::CreateViewObject() (Old URL)
        // 2) CDefView::CreateViewWindow2()->CFtpView::_OnSize() (Old URL)
        // 3) DV_UpdateStatusBar()->CFtpView::_OnUpdateStatusBar() (New URL)
        // 4) ReleaseWindowLV()->WndSize()->CFtpView::_OnSize() (Old URL)
        // #4 makes us update the URL and replace #3 which is valid.
    }
    
    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnThisIDList

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnThisIDList(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_FALSE;

    if (EVAL(ppidl))
    {
        *ppidl = ILClone(m_pff->GetPublicRootPidlReference());
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnUpdateStatusBar

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::_OnUpdateStatusBar(void)
{
    HRESULT hr = S_FALSE;
    LPCITEMIDLIST pidl = m_pff->GetPrivatePidlReference();

    if (EVAL(pidl))
    {
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
        BOOL fAnnonymousLogin = TRUE;

        hr = FtpPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName));
        if (SUCCEEDED(hr) && szUserName[0])
            fAnnonymousLogin = FALSE;

        if (m_psb)
        {
            // Even if the above call fails, we set the user name to clear out
            // any old invalid values.
            m_psb->SetUserName(szUserName, fAnnonymousLogin);
        }

        EVAL(SUCCEEDED(_SetStatusBarZone(m_psb, m_pff->m_pfs)));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: SetRedirectPidl

    DESCRIPTION:
        See the comments in _OnBackGroundEnumDone().
\*****************************************************************************/
HRESULT CFtpView::SetRedirectPidl(LPCITEMIDLIST pidlRedirect)
{
    ENTERCRITICAL;
    Pidl_Set(&m_pidlRedirect, pidlRedirect);
    LEAVECRITICAL;
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: DummyHintCallback

    DESCRIPTION:
        Doesn't do anything; simply forces the connection to be established
    and the motd to be obtained.
\*****************************************************************************/
HRESULT CFtpView::DummyHintCallback(HWND hwnd, CFtpFolder * pff, HINTERNET hint, LPVOID pv1, LPVOID pv2)
{
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _InitStatusBar

    DESCRIPTION:
        Obtains and initializes the status bar window.
    It is not an error if the viewer does not provide a status bar.
\*****************************************************************************/
void CFtpView::_InitStatusBar(void)
{
    if (m_psb)
        m_psb->SetStatusMessage(IDS_EMPTY, 0);
}


/*****************************************************************************\
    FUNCTION: _OnWindowCreated (from shell32.IShellView)

    DESCRIPTION:
        When the window is created, we get the motd.  Very soon thereafter,
    DefView is going to ask for the IEnumIDList, which will now be
    in the cache.  (GROSS!  Screws up background enumeration!)

    Do this only if we don't already have a motd.
\*****************************************************************************/
HRESULT CFtpView::_OnWindowCreated(void)
{
    HRESULT hr = S_FALSE;

    // Previously, we cached the MOTD here, but we now do it else where.  We
    // could do it here also if we wanted to have a MOTD per site and per folder
    // but almost no servers support this and user's pretty much never need it.
    // Besides, there are ambiguious cases that we couldn't get right on other
    // servers.

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnDefItemCount (from shell32.IShellView)

    DESCRIPTION:
        _UNDOCUMENTED_: This callback and its parameters are not documented.

    Called to advise the browser of how many items we might have.  This
    allows preliminary UI to appear while we are busy enumerating
    the contents.
\*****************************************************************************/
HRESULT CFtpView::_OnDefItemCount(LPINT pi)
{
    *pi = 20;
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnDidDragDrop

    DESCRIPTION:
        Called to advise the browser that somebody did a drag/drop operation
    on objects in the folder.  If the effect was DROPEFFECT_MOVE, then
    we delete the source, if we aren't still doing the copy asynch on a
    background thread.

    RETURN VALUES:
        S_OK: We take responsibility of deleting the files which we can
              do here in the synch case, or in IAsynchOperation::EndOperation()
              in the asynch case.
        S_FALSE: We didn't do the delete but it's OK for the caller to do it.
                 so the caller needs to display UI and then delete via
                 IContextMenu->InvokeCommand(-delete-).
\*****************************************************************************/
HRESULT CFtpView::_OnDidDragDrop(DROPEFFECT de, IDataObject * pdo)
{
    HRESULT hr = S_OK;

    if (DROPEFFECT_MOVE == de)
    {
        IAsyncOperation * pao;

        hr = pdo->QueryInterface(IID_IAsyncOperation, (void **) &pao);
        if (SUCCEEDED(hr))
        {
            BOOL fInAsyncOp = TRUE;

            hr = pao->InOperation(&fInAsyncOp);
            hr = S_OK;  // Don't have caller do the delete.
            if (FALSE == fInAsyncOp)
            {
#ifdef FEATURE_CUT_MOVE
                CLSID clsid;
                BOOL fDoDelete = TRUE;
                CFtpObj * pfo = (CFtpObj *) pdo;

                // Is the destination the recycle bin?
                if (SUCCEEDED(DataObj_GetDropTarget(pdo, &clsid)) &&
                    IsEqualCLSID(clsid, CLSID_RecycleBin))
                {
                    // Yes, so we need to first inform the user that drops to the
                    // Recycle bin are perminate deletes and the user can't undo
                    // the operation.
                    if (IDYES != SHMessageBox(m_hwndOwner, NULL, IDS_RECYCLE_IS_PERM_WARNING, IDS_FTPERR_TITLE, (MB_ICONQUESTION | MB_YESNO)))
                        fDoDelete = FALSE;
                }

                // We didn't do the operation aynch so we need to DELETE the
                // files now to complete the MOVE operation (MOVE=Copy + Delete).
                if (fDoDelete)
                {
                    Misc_DeleteHfpl(m_pff, m_hwndOwner, pfo->GetHfpl());    // Will fail on permission denied.
                }

#else // FEATURE_CUT_MOVE
                hr = S_FALSE;   // Have parent do the delete.
#endif //FEATURE_CUT_MOVE
            }

            pao->Release();
        }
        else
            hr = S_OK;  // Don't have caller delete.  IAsyncOperation::EndOperation() will.
    }

    return hr;
}



//===========================
// *** IFtpWebView Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IFtpWebView::get_MessageOfTheDay

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_MessageOfTheDay(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szDefault[MAX_PATH];
            LPCTSTR pszMOTD = szDefault;
            CFtpGlob * pfg = m_pff->GetSiteMotd();

            szDefault[0] = 0;
            if (pfg)
                pszMOTD = pfg->GetHGlobAsTCHAR();

            // if we were not able to get the message of the day
            // from CFtpFolder or it was empty, display "None"
            if ((pszMOTD == szDefault) || (!pszMOTD[0]))
            {
                pszMOTD = szDefault;
                LoadString(HINST_THISDLL, IDS_NO_MESSAGEOFTHEDAY, szDefault, ARRAYSIZE(szDefault));
            }

            *pbstr = TCharSysAllocString(pszMOTD);

            if (pfg)
                pfg->Release();

            hr = S_OK;
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_Server

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_Server(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

            if (SUCCEEDED(FtpPidl_GetServer(m_pff->GetPrivatePidlReference(), szServer, ARRAYSIZE(szServer))))
            {
                *pbstr = TCharSysAllocString(szServer);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

//    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_Directory

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_Directory(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH];

            if (EVAL(SUCCEEDED(GetDisplayPathFromPidl(m_pff->GetPrivatePidlReference(), szUrlPath, ARRAYSIZE(szUrlPath), FALSE))))
            {
                *pbstr = TCharSysAllocString(szUrlPath);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_UserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_UserName(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];

            if (EVAL(SUCCEEDED(FtpPidl_GetUserName(m_pff->GetPrivatePidlReference(), szUserName, ARRAYSIZE(szUserName)))))
            {
                *pbstr = TCharSysAllocString((0 != szUserName[0]) ? szUserName : SZ_ANONYMOUS);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_PasswordLength

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_PasswordLength(long * plLength)
{
    HRESULT hr = S_FALSE;

    if (EVAL(plLength))
    {
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

        *plLength = 0;
        if (SUCCEEDED(FtpPidl_GetPassword(m_pff->GetPrivatePidlReference(), szPassword, ARRAYSIZE(szPassword), FALSE)))
        {
            *plLength = lstrlen(szPassword);
            hr = S_OK;
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*plLength, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_EmailAddress(BSTR * pbstr)
{
    HRESULT hr = S_OK;

    if (EVAL(pbstr))
    {
        TCHAR szEmailName[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cbSize = sizeof(szEmailName);

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, &dwType, szEmailName, &cbSize))
            *pbstr = TCharSysAllocString(szEmailName);
        else
        {
            hr = S_FALSE;
            *pbstr = NULL;
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::put_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::put_EmailAddress(BSTR bstr)
{
    HRESULT hr = S_OK;

    if (EVAL(bstr))
    {
        TCHAR szEmailName[MAX_PATH];

        SHUnicodeToTChar(bstr, szEmailName, ARRAYSIZE(szEmailName));
        if (ERROR_SUCCESS != SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, REG_SZ, szEmailName, sizeof(szEmailName)))
            hr = S_FALSE;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::get_CurrentLoginAnonymous

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin)
{
    HRESULT hr = S_OK;

    if (EVAL(pfAnonymousLogin))
    {
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];

        if (EVAL(m_pff) &&
            SUCCEEDED(FtpPidl_GetUserName(m_pff->GetPrivatePidlReference(), szUserName, ARRAYSIZE(szUserName))) &&
            szUserName[0] && (0 != StrCmpI(szUserName, TEXT("anonymous"))))
        {
            *pfAnonymousLogin = VARIANT_FALSE;
        }
        else
            *pfAnonymousLogin = VARIANT_TRUE;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginAnonymously

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::LoginAnonymously(void)
{
    return _LoginWithPassword(NULL, NULL);
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginWithPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::LoginWithPassword(BSTR bUserName, BSTR bPassword)
{
    HRESULT hr = S_OK;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    SHUnicodeToTChar(bUserName, szUserName, ARRAYSIZE(szUserName));
    SHUnicodeToTChar(bPassword, szPassword, ARRAYSIZE(szPassword));
    return _LoginWithPassword(szUserName, szPassword);
}


/*****************************************************************************\
    FUNCTION: IFtpWebView::LoginWithoutPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpView::LoginWithoutPassword(BSTR bUserName)
{
    HRESULT hr = S_FALSE;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    SHUnicodeToTChar(bUserName, szUserName, ARRAYSIZE(szUserName));
    if (SUCCEEDED(FtpPidl_GetPassword(m_pff->GetPrivatePidlReference(), szPassword, ARRAYSIZE(szPassword), TRUE)))
        hr = _LoginWithPassword(szUserName, szPassword);

    return hr;
    
}


HRESULT CFtpView::_LoginWithPassword(LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlUser;

    hr = PidlReplaceUserPassword(m_pff->GetPrivatePidlReference(), &pidlUser, m_pff->GetItemAllocatorDirect(), pszUserName, pszPassword);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFull = m_pff->CreateFullPublicPidl(pidlUser);
        if (pidlFull)
        {
            hr = IUnknown_PidlNavigate(m_psfv, pidlFull, TRUE);
            ASSERT(SUCCEEDED(hr));
            ILFree(pidlFull);
        }

        ILFree(pidlUser);
    }

    if (FAILED(hr))
        hr = S_FALSE;   // Automation interfaces don't like failure returns.

    return hr;
}


//===========================
// *** IDispatch Interface ***
//===========================

STDMETHODIMP CFtpView::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFtpView::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFtpView::GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}

STDMETHODIMP CFtpView::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


/*****************************************************************************
 *
 *	CFtpView_Create
 *
 *	Creates a brand new enumerator based on an ftp site.
 *
 *****************************************************************************/
HRESULT CFtpView_Create(CFtpFolder * pff, HWND hwndOwner, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFtpView * pfv = new CFtpView(pff, hwndOwner);

    if (pfv)
    {
        hr = pfv->QueryInterface(riid, ppv);
        pfv->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppv, hr);
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpView::CFtpView(CFtpFolder * pff, HWND hwndOwner) : CImpIDispatch(&LIBID_MSIEFTPLib)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hwndOwner);
    ASSERT(!m_hwndStatusBar);
    ASSERT(!m_pff);
    ASSERT(!m_hgtiWelcome);
    
    m_nThreadID = GetCurrentThreadId();
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
        m_hwndStatusBar = Misc_FindStatusBar(hwndOwner);
        m_psb = CStatusBar_Create(m_hwndStatusBar);
        _InitStatusBar();
    }

    m_rcPrev.top = m_rcPrev.bottom = m_rcPrev.right = m_rcPrev.left = -1;
    IUnknown_Set(&m_pff, pff);

    LEAK_ADDREF(LEAK_CFtpView);
    g_cRef_CFtpView++;  // Needed to determine when to purge cache.
}


/****************************************************\
    Destructor
\****************************************************/
/*****************************************************************************
 *      We release the psf before triggering the timeout, which is a
 *      signal to the trigger not to do anything.
 *
 *      _UNDOCUMENTED_: This callback and its parameters are not documented.
 *
 *****************************************************************************/
CFtpView::~CFtpView()
{
    IUnknown_Set(&m_pff, NULL);

    TriggerDelayedAction(&m_hgtiWelcome);   // Kick out the old one

    SetRedirectPidl(NULL);
    if (m_psb)
        delete m_psb;

    if (m_hinstInetCpl)
        FreeLibrary(m_hinstInetCpl);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpView);
    g_cRef_CFtpView--;  // Needed to determine when to purge cache.
}


//===========================
// *** IUnknown Interface ***
//===========================

HRESULT CFtpView::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch *);
    }
    else if (IsEqualIID(riid, IID_IFtpWebView))
    {
        *ppvObj = SAFECAST(this, IFtpWebView *);
    }
    else if (IsEqualIID(riid, IID_CFtpViewPrivThis))
    {
        *ppvObj = (void *)this;
    }
    else
        return CBaseFolderViewCB::QueryInterface(riid, ppvObj);

    AddRef();
    return S_OK;
}


CFtpView * GetCFtpViewFromDefViewSite(IUnknown * punkSite)
{
    CFtpView * pfv = NULL;
    IShellFolderViewCB * psfvcb = NULL;

    // This fails on Browser Only
    IUnknown_QueryService(punkSite, SID_ShellFolderViewCB, IID_IShellFolderViewCB, (LPVOID *) &psfvcb);
    if (psfvcb)
    {
        psfvcb->QueryInterface(IID_CFtpViewPrivThis, (void **) &pfv);
        psfvcb->Release();
    }

    return pfv;
}


CStatusBar * GetCStatusBarFromDefViewSite(IUnknown * punkSite)
{
    CStatusBar * psb = NULL;
    CFtpView * pfv = GetCFtpViewFromDefViewSite(punkSite);

    if (pfv)
    {
        psb = pfv->GetStatusBar();
        pfv->Release();
    }

    return psb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\compatibility.h ===
//  --------------------------------------------------------------------------
//  Module Name: Compatibility.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Module to handle compatibility problems in general.
//
//  History:    2000-08-03  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Compatibility_
#define     _Compatibility_

#include "DynamicArray.h"
#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CCompatibility
//
//  Purpose:    This class implements compatibility and solutions to
//              compatibility problems.
//
//  History:    2000-08-08  vtan        created
//  --------------------------------------------------------------------------

class   CCompatibility
{
    private:
        typedef bool    (CALLBACK * PFNENUMSESSIONPROCESSESPROC) (DWORD dwProcessID, void *pV);
    public:
        static  bool                HasEnoughMemoryForNewSession (void);
        static  void                DropSessionProcessesWorkingSets (void);
        static  NTSTATUS            TerminateNonCompliantApplications (void);
        static  void                MinimizeWindowsOnDisconnect (void);
        static  void                RestoreWindowsOnReconnect (void);

        static  NTSTATUS            StaticInitialize (void);
        static  NTSTATUS            StaticTerminate (void);
    private:
        static  NTSTATUS            ConnectToServer (void);
        static  NTSTATUS            RequestSwitchUser (void);
        static  bool    CALLBACK    CB_DropSessionProcessesWorkingSetsProc (DWORD dwProcessID, void *pV);
        static  bool                EnumSessionProcesses (DWORD dwSessionID, PFNENUMSESSIONPROCESSESPROC pfnCallback, void *pV);
        static  DWORD   WINAPI      CB_MinimizeWindowsWorkItem (void *pV);
        static  DWORD   WINAPI      CB_RestoreWindowsWorkItem (void *pV);
    private:
        static  HANDLE              s_hPort;
};

#endif  /*  _Compatibility_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\compatibility.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Compatibility.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Module to handle compatibility problems in general.
//
//  History:    2000-08-03  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Compatibility.h"

#include <lpcfus.h>
#include <trayp.h>

#include "KernelResources.h"
#include "RegistryResources.h"
#include "SingleThreadedExecution.h"

//  --------------------------------------------------------------------------
//  CCompatibility::HasEnoughMemoryForNewSession
//
//  Purpose:    LPC port to server
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

HANDLE              CCompatibility::s_hPort         =   INVALID_HANDLE_VALUE;

//  --------------------------------------------------------------------------
//  CCompatibility::HasEnoughMemoryForNewSession
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Currently unused. Was originally intended to be used to stop
//              disconnects if there isn't enough memory. Algorithm and/or
//              usage still to be decided.
//
//  History:    2000-08-03  vtan        created
//  --------------------------------------------------------------------------

bool    CCompatibility::HasEnoughMemoryForNewSession (void)

{
    return(true);
}

//  --------------------------------------------------------------------------
//  CCompatibility::DropSessionProcessesWorkSets
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Iterates all the processes in the session (of the calling
//              process) and drops their working sets. This is in preparation
//              for a disconnect when typically the session is idle.
//
//  History:    2000-08-03  vtan        created
//  --------------------------------------------------------------------------

void    CCompatibility::DropSessionProcessesWorkingSets (void)

{
    (bool)EnumSessionProcesses(NtCurrentPeb()->SessionId, CB_DropSessionProcessesWorkingSetsProc, NULL);
}

//  --------------------------------------------------------------------------
//  CCompatibility::TerminateNonCompliantApplications
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Requests disconnect capability from the Bad Application
//              Manager service. This will check the session to be
//              disconnected (this process -> the client) and walk its list
//              of processes registered as type 2 (terminate on disconnect).
//
//              If any of those processes cannot be identified as being
//              terminated gracefully then the disconnect is failed.
//
//              If the BAM is down then allow the call.
//
//  History:    2000-09-08  vtan        created
//              2000-11-02  vtan        rework to call BAM service
//  --------------------------------------------------------------------------

NTSTATUS    CCompatibility::TerminateNonCompliantApplications (void)

{
    NTSTATUS    status;

    if (s_hPort == INVALID_HANDLE_VALUE)
    {
        status = ConnectToServer();
    }
    else if (s_hPort != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    if (NT_SUCCESS(status))
    {
        status = RequestSwitchUser();

        //  If the port is disconnected because the service was stopped and
        //  restarted then dump the current handle and re-establish a new
        //  connection.

        if (status == STATUS_PORT_DISCONNECTED)
        {
            ReleaseHandle(s_hPort);
            s_hPort = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCompatibility::MinimizeWindowsOnDisconnect
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Creates a thread to walk the windows on WinSta0\Default and
//              minimize them. This is required because
//              user32!SetThreadDesktop doesn't work on the main thread of
//              winlogon due to the SAS window.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

void    CCompatibility::MinimizeWindowsOnDisconnect (void)

{
    (BOOL)QueueUserWorkItem(CB_MinimizeWindowsWorkItem, NULL, WT_EXECUTEDEFAULT);
}

//  --------------------------------------------------------------------------
//  CCompatibility::RestoreWindowsOnReconnect
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Walks the array of minimized windows for this session and
//              restores them. Deletes the array for the next time.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

void    CCompatibility::RestoreWindowsOnReconnect (void)

{
    (BOOL)QueueUserWorkItem(CB_RestoreWindowsWorkItem, NULL, WT_EXECUTEDEFAULT);
}

//  --------------------------------------------------------------------------
//  CCompatibility::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    
//
//  History:    2001-06-22  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCompatibility::StaticInitialize (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CCompatibility::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release resources used by the module.
//
//  History:    2001-06-22  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCompatibility::StaticTerminate (void)

{
    if ((s_hPort != INVALID_HANDLE_VALUE) && (s_hPort != NULL))
    {
        TBOOL(CloseHandle(s_hPort));
        s_hPort = INVALID_HANDLE_VALUE;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CCompatibility::ConnectToServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the Bad Application Manager server if no
//              connection has been established.
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCompatibility::ConnectToServer (void)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[32];

    ASSERTMSG(s_hPort == INVALID_HANDLE_VALUE, "Attempt to call CCompatibility::ConnectToServer more than once");
    RtlInitUnicodeString(&portName, FUS_PORT_NAME);
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    return(NtConnectPort(&s_hPort,
                         &portName,
                         &sqos,
                         NULL,
                         NULL,
                         NULL,
                         szConnectionInfo,
                         &ulConnectionInfoLength));
}

//  --------------------------------------------------------------------------
//  CCompatibility::RequestSwitchUser
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Request the BAM server to do BAM2.
//
//  History:    2001-03-08  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCompatibility::RequestSwitchUser (void)

{
    NTSTATUS                status;
    FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_REQUESTSWITCHUSER;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort, &portMessageIn.portMessage, &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiBAM.apiGeneric.status;
        if (NT_SUCCESS(status))
        {
            if (portMessageOut.apiBAM.apiSpecific.apiRequestSwitchUser.out.fAllowSwitch)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_ACCESS_DENIED;
            }
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCompatibility::CB_DropSessionProcessesWorkingSetsProc
//
//  Arguments:  dwProcessID     =   Process ID for this enumeration.
//              pV              =   User data pointer.
//
//  Returns:    bool
//
//  Purpose:    Attempts to open the given process ID to change the quotas.
//              This will drop the working set when set to -1.
//
//  History:    2000-08-07  vtan        created
//  --------------------------------------------------------------------------

bool    CCompatibility::CB_DropSessionProcessesWorkingSetsProc (DWORD dwProcessID, void *pV)

{
    UNREFERENCED_PARAMETER(pV);

    HANDLE  hProcess;

    ASSERTMSG(pV == NULL, "Unexpected pV passed to CCompatibility::CB_DropSessionProcessesWorkingSetsProc");
    hProcess = OpenProcess(PROCESS_SET_QUOTA, FALSE, dwProcessID);
    if (hProcess != NULL)
    {
        TBOOL(SetProcessWorkingSetSize(hProcess, static_cast<SIZE_T>(-1), static_cast<SIZE_T>(-1)));
        TBOOL(CloseHandle(hProcess));
    }
    return(true);
}

//  --------------------------------------------------------------------------
//  CCompatibility::EnumSessionProcesses
//
//  Arguments:  dwSessionID     =   Session ID to enumerate processes of.
//              pfnCallback     =   Callback procedure address.
//              pV              =   User defined data to pass to callback.
//
//  Returns:    bool
//
//  Purpose:    Enumerates all processes on the system looking only for those
//              in the given session ID. Once a process ID is found it passes
//              that back to the callback. The callback may return false to
//              terminate the loop and return a false result to the caller of
//              this function.
//
//  History:    2000-08-07  vtan        created
//  --------------------------------------------------------------------------

bool    CCompatibility::EnumSessionProcesses (DWORD dwSessionID, PFNENUMSESSIONPROCESSESPROC pfnCallback, void *pV)

{
    bool                        fResult;
    ULONG                       ulLengthToAllocate, ulLengthReturned;
    SYSTEM_PROCESS_INFORMATION  spi, *pSPI;

    fResult = false;
    (NTSTATUS)NtQuerySystemInformation(SystemProcessInformation,
                                       &spi,
                                       sizeof(spi),
                                       &ulLengthToAllocate);
    pSPI = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(LocalAlloc(LMEM_FIXED, ulLengthToAllocate));
    if (pSPI != NULL)
    {
        SYSTEM_PROCESS_INFORMATION  *pAllocatedSPI;

        pAllocatedSPI = pSPI;
        if (NT_SUCCESS(NtQuerySystemInformation(SystemProcessInformation,
                                                pSPI,
                                                ulLengthToAllocate,
                                                &ulLengthReturned)))
        {
            fResult = true;
            while (fResult && (pSPI != NULL))
            {
                if (pSPI->SessionId == dwSessionID)
                {
                    fResult = pfnCallback(HandleToUlong(pSPI->UniqueProcessId), pV);
                }
                if (pSPI->NextEntryOffset != 0)
                {
                    pSPI = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(reinterpret_cast<unsigned char*>(pSPI) + pSPI->NextEntryOffset);
                }
                else
                {
                    pSPI = NULL;
                }
            }
        }
        (HLOCAL)LocalFree(pAllocatedSPI);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CCompatibility::CB_MinimizeWindowsWorkItem
//
//  Arguments:  pV  =   User data.
//
//  Returns:    DWORD
//
//  Purpose:    Separate thread to handle switching to the default desktop and
//              enumerating the windows on it and minimizing them.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI      CCompatibility::CB_MinimizeWindowsWorkItem (void *pV)

{
    UNREFERENCED_PARAMETER(pV);

    CDesktop    desktop;

    if (NT_SUCCESS(desktop.Set(TEXT("Default"))))
    {
        HWND    hwndTray;

        hwndTray = FindWindow(TEXT("Shell_TrayWnd"), NULL);
        if (hwndTray != NULL)
        {
            // can be a post since we don't care how long it takes for the windows
            // to be minimized
            PostMessage(hwndTray, WM_COMMAND, 415 /* IDM_MINIMIZEALL */, 0);
        }
    }

    return(0);
}

//  --------------------------------------------------------------------------
//  CCompatibility::CB_RestoreWindowsWorkItem
//
//  Arguments:  pV  =   User data.
//
//  Returns:    DWORD
//
//  Purpose:    Separate thread to handle switching to the default desktop and
//              enumerating the windows on it and minimizing them.
//
//  History:    2001-04-25  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI      CCompatibility::CB_RestoreWindowsWorkItem (void *pV)

{
    UNREFERENCED_PARAMETER(pV);
    
    CDesktop    desktop;

    if (NT_SUCCESS(desktop.Set(TEXT("Default"))))
    {
        HWND    hwndTray;

        hwndTray = FindWindow(TEXT("Shell_TrayWnd"), NULL);
        if (hwndTray != NULL)
        {
            // use SendMessage to make this happen more quickly, otherwise the user
            // might wonder where all of their apps went
            SendMessage(hwndTray, WM_COMMAND, 416 /* IDM_UNDO */, 0);
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\credentialtransfer.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CredentialTransfer.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Classes to handle credential transfer from one winlogon to another.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "CredentialTransfer.h"

#include <winsta.h>

#include "Access.h"
#include "Compatibility.h"
#include "RegistryResources.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CCredentials::s_hKeyCredentials
//  CCredentials::s_szCredentialKeyName
//  CCredentials::s_szCredentialValueName
//
//  Purpose:    Static member variables.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

HKEY            CCredentials::s_hKeyCredentials             =   NULL;
const TCHAR     CCredentials::s_szCredentialKeyName[]       =   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Credentials");
const TCHAR     CCredentials::s_szCredentialValueName[]     =   TEXT("Name");

//  --------------------------------------------------------------------------
//  CCredentials::CCredentials
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CCredentials.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

CCredentials::CCredentials (void)

{
}

//  --------------------------------------------------------------------------
//  CCredentials::~CCredentials
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CCredentials.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

CCredentials::~CCredentials (void)

{
}

//  --------------------------------------------------------------------------
//  CCredentials::OpenConduit
//
//  Arguments:  phPipe  =   Handle to the named pipe returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the name of the named pipe from the volatile section of
//              the registry and opens the named pipe for read access. Returns
//              this handle back to the caller.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::OpenConduit (HANDLE *phPipe)

{
    NTSTATUS    status;
    HANDLE      hPipe;
    TCHAR       szName[MAX_PATH];

    hPipe = NULL;
    if (s_hKeyCredentials != NULL)
    {
        status = GetConduitName(szName, ARRAYSIZE(szName));
        if (NT_SUCCESS(status))
        {
            hPipe = CreateFile(szName,
                               GENERIC_READ,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);
            if (hPipe == INVALID_HANDLE_VALUE)
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
    }
    else
    {
        hPipe = INVALID_HANDLE_VALUE;
        status = STATUS_ACCESS_DENIED;
    }
    *phPipe = hPipe;
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentials::CreateConduit
//
//  Arguments:  pSecurityAttributes     =   Security to apply to named pipe.
//              phPipe                  =   Handle to named pipe returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates a uniquely named pipe and places this name in the
//              volatile section of the registry for the open method.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::CreateConduit (LPSECURITY_ATTRIBUTES pSecurityAttributes, HANDLE *phPipe)

{
    NTSTATUS    status;
    HANDLE      hPipe;

    hPipe = NULL;
    if (s_hKeyCredentials != NULL)
    {
        DWORD       dwNumber;
        int         iCount;
        TCHAR       szName[MAX_PATH];

        dwNumber = GetTickCount();
        iCount = 0;
        do
        {

            //  Create a name for the pipe based on the tickcount. If this collides
            //  with one already there (unlikely but possible) then add tickcount and
            //  try again. The named pipe is actually short lived.

            (NTSTATUS)CreateConduitName(dwNumber, szName);
            hPipe = CreateNamedPipe(szName,
                                    PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                    PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
                                    1,
                                    0,
                                    0,
                                    NMPWAIT_USE_DEFAULT_WAIT,
                                    pSecurityAttributes);
            if (hPipe == NULL)
            {
                dwNumber += GetTickCount();
                status = CStatusCode::StatusCodeOfLastError();
            }
            else
            {
                status = STATUS_SUCCESS;
            }
        } while (!NT_SUCCESS(status) && (++iCount <= 5));
        if (NT_SUCCESS(status))
        {
            status = SetConduitName(szName);
        }
    }
    else
    {
        hPipe = NULL;
        status = STATUS_ACCESS_DENIED;
    }
    *phPipe = hPipe;
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentials::ClearConduit
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Clears the named stored in the volatile section of the
//              registry.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::ClearConduit (void)

{
    return(ClearConduitName());
}

//  --------------------------------------------------------------------------
//  CCredentials::Pack
//
//  Arguments:  pLogonIPCCredentials    =   Credentials to pack.
//              ppvData                 =   Block of memory allocated.
//              pdwDataSize             =   Size of block of memory allocated.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Packs the credentials into a stream-lined structure for
//              transmission across a named pipe. This packs the user name,
//              domain and password into a known structure for the client
//              to pick up. The password is run encoded. The structure has
//              pointer references removed.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::Pack (LOGONIPC_CREDENTIALS *pLogonIPCCredentials, void* *ppvData, DWORD *pdwDataSize)

{
    NTSTATUS        status;
    DWORD           dwSize, dwSizeUsername, dwSizeDomain, dwSizePassword;
    unsigned char   *pUC;

    //  Marshall the credentials into the struct that is transferred across
    //  a named pipe. Calculate the size of the buffer required.

    dwSizeUsername = lstrlenW(pLogonIPCCredentials->userID.wszUsername) + sizeof('\0');
    dwSizeDomain = lstrlenW(pLogonIPCCredentials->userID.wszDomain) + sizeof('\0');
    dwSizePassword = lstrlenW(pLogonIPCCredentials->wszPassword) + sizeof('\0');
    *pdwDataSize = dwSize = sizeof(CREDENTIALS) + ((dwSizeUsername + dwSizeDomain + dwSizePassword) * sizeof(WCHAR));

    //  Allocate the buffer.

    *ppvData = pUC = static_cast<unsigned char*>(LocalAlloc(LMEM_FIXED, dwSize));
    if (pUC != NULL)
    {
        WCHAR           *pszUsername, *pszDomain, *pszPassword;
        CREDENTIALS     *pCredentials;

        //  Establish pointers into the buffer to fill it.

        pCredentials = reinterpret_cast<CREDENTIALS*>(pUC);
        pszUsername = reinterpret_cast<WCHAR*>(pUC + sizeof(CREDENTIALS));
        pszDomain = pszUsername + dwSizeUsername;
        pszPassword = pszDomain + dwSizeDomain;

        //  Copy the strings into the buffer.

        (WCHAR*)lstrcpyW(pszUsername, pLogonIPCCredentials->userID.wszUsername);
        (WCHAR*)lstrcpyW(pszDomain, pLogonIPCCredentials->userID.wszDomain);
        (WCHAR*)lstrcpyW(pszPassword, pLogonIPCCredentials->wszPassword);

        //  Erase the password string given.

        ZeroMemory(pLogonIPCCredentials->wszPassword, dwSizePassword * sizeof(WCHAR));

        //  Prepare a seed for the run encode.

        pCredentials->dwSize = dwSize;
        pCredentials->ucPasswordSeed = static_cast<unsigned char>(GetTickCount());

        //  Create UNICODE_STRING structures into the buffer.

        RtlInitUnicodeString(&pCredentials->username, pszUsername);
        RtlInitUnicodeString(&pCredentials->domain, pszDomain);
        RtlInitUnicodeString(&pCredentials->password, pszPassword);

        //  Run encode the password.

        RtlRunEncodeUnicodeString(&pCredentials->ucPasswordSeed, &pCredentials->password);

        //  Make the pointers relative.

        pCredentials->username.Buffer = reinterpret_cast<WCHAR*>(reinterpret_cast<unsigned char*>(pCredentials->username.Buffer) - pUC);
        pCredentials->domain.Buffer = reinterpret_cast<WCHAR*>(reinterpret_cast<unsigned char*>(pCredentials->domain.Buffer) - pUC);
        pCredentials->password.Buffer = reinterpret_cast<WCHAR*>(reinterpret_cast<unsigned char*>(pCredentials->password.Buffer) - pUC);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentials::Unpack
//
//  Arguments:  pvData                  =   Packed credentials from server.
//              pLogonIPCCredentials    =   Credentials received.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Client side usage that unpacks the structure.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::Unpack (void *pvData, LOGONIPC_CREDENTIALS *pLogonIPCCredentials)

{
    NTSTATUS        status;
    unsigned char   *pUC;

    //  Marshall the credentials from the struct that is transferred across
    //  a named pipe.

    pUC = static_cast<unsigned char*>(pvData);
    if (pUC != NULL)
    {
        CREDENTIALS     *pCredentials;

        pCredentials = reinterpret_cast<CREDENTIALS*>(pUC);

        //  Make the relative pointers absolute again.

        pCredentials->username.Buffer = reinterpret_cast<WCHAR*>(pUC + PtrToUlong(pCredentials->username.Buffer));
        pCredentials->domain.Buffer = reinterpret_cast<WCHAR*>(pUC + PtrToUlong(pCredentials->domain.Buffer));
        pCredentials->password.Buffer = reinterpret_cast<WCHAR*>(pUC + PtrToUlong(pCredentials->password.Buffer));

        //  Decode the run encoded password.

        RtlRunDecodeUnicodeString(pCredentials->ucPasswordSeed, &pCredentials->password);

        //  Copy it to the caller's struct.

        (WCHAR*)lstrcpyW(pLogonIPCCredentials->userID.wszUsername, pCredentials->username.Buffer);
        (WCHAR*)lstrcpyW(pLogonIPCCredentials->userID.wszDomain, pCredentials->domain.Buffer);
        (WCHAR*)lstrcpyW(pLogonIPCCredentials->wszPassword, pCredentials->password.Buffer);

        //  Zero the named pipe buffer.

        ZeroMemory(pCredentials->password.Buffer, (lstrlen(pCredentials->password.Buffer) + sizeof('\0')) * sizeof(WCHAR));

        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentials::StaticInitialize
//
//  Arguments:  fCreate     =   Create or open the registry key.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates the volatile key in the registry where the named pipe
//              name is placed for the client winlogon to pick. This section
//              is volatile and ACL'd to prevent access by anything other than
//              S-1-5-18 (NT AUTHORITY\SYSTEM).
//
//  History:    2001-01-12  vtan        created
//              2001-04-03  vtan        add opening capability
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::StaticInitialize (bool fCreate)

{
    NTSTATUS    status;

    if (s_hKeyCredentials == NULL)
    {
        LONG                    lErrorCode;
        PSECURITY_DESCRIPTOR    pSecurityDescriptor;

        //  Build a security descriptor for the registry key that allows:
        //      S-1-5-18        NT AUTHORITY\SYSTEM     KEY_ALL_ACCESS

        static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority   =   SECURITY_NT_AUTHORITY;

        static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
        {
            {
                &s_SecurityNTAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                KEY_ALL_ACCESS
            }
        };

        if (fCreate)
        {

            //  Build a security descriptor that allows the described access above.

            pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
            if (pSecurityDescriptor != NULL)
            {
                SECURITY_ATTRIBUTES     securityAttributes;

                securityAttributes.nLength = sizeof(securityAttributes);
                securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
                securityAttributes.bInheritHandle = FALSE;
                lErrorCode = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                            s_szCredentialKeyName,
                                            0,
                                            NULL,
                                            REG_OPTION_VOLATILE,
                                            KEY_QUERY_VALUE,
                                            &securityAttributes,
                                            &s_hKeyCredentials,
                                            NULL);
                (HLOCAL)LocalFree(pSecurityDescriptor);
            }
            else
            {
                lErrorCode = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            lErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      s_szCredentialKeyName,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &s_hKeyCredentials);
        }
        status = CStatusCode::StatusCodeOfErrorCode(lErrorCode);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentials::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    If a key is present the release the resource.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::StaticTerminate (void)

{
    if (s_hKeyCredentials != NULL)
    {
        TW32(RegCloseKey(s_hKeyCredentials));
        s_hKeyCredentials = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CCredentials::GetConduitName
//
//  Arguments:  pszName     =   Buffer for name of named pipe returned.
//              dwNameSize  =   Count of characters of buffer.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets the name of the named pipe from the volatile section of
//              the registry.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::GetConduitName (TCHAR *pszName, DWORD dwNameSize)

{
    LONG        lErrorCode;
    CRegKey     regKey;

    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             s_szCredentialKeyName,
                             KEY_QUERY_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        lErrorCode = regKey.GetString(s_szCredentialValueName, pszName, dwNameSize);
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CCredentials::SetConduitName
//
//  Arguments:  pszName     =   Name of the named pipe to write.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Writes the name of the named pipe to the secure volatile
//              section of the registry.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::SetConduitName (const TCHAR *pszName)

{
    LONG        lErrorCode;
    CRegKey     regKey;

    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             s_szCredentialKeyName,
                             KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        lErrorCode = regKey.SetString(s_szCredentialValueName, pszName);
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CCredentials::ClearConduitName
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Clears the name of the named pipe in the volatile section of
//              the registry.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::ClearConduitName (void)

{
    LONG        lErrorCode;
    CRegKey     regKey;

    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             s_szCredentialKeyName,
                             KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        lErrorCode = regKey.DeleteValue(s_szCredentialValueName);
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CCredentials::CreateConduitName
//
//  Arguments:  dwNumber    =   Number to use.
//              pszName     =   Name generated return buffer.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Generate a name based on the number for the named pipe. This
//              algorithm can be changed and all the callers will get the
//              result.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentials::CreateConduitName (DWORD dwNumber, TCHAR *pszName)

{
    (int)wsprintf(pszName, TEXT("\\\\.\\pipe\\LogonCredentials_0x%08x"), dwNumber);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::CCredentialServer
//
//  Arguments:  dwTimeout               =   Time out to wait.
//              pLogonIPCCredentials    =   Credentials to serve up.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the credential server. Allocate resources
//              required for the server end of the named pipe.
//
//  History:    2001-01-11  vtan        created
//              2001-06-13  vtan        added timeout
//  --------------------------------------------------------------------------

CCredentialServer::CCredentialServer (DWORD dwTimeout, LOGONIPC_CREDENTIALS *pLogonIPCCredentials) :
    CThread(),
    _dwTimeout((dwTimeout != 0) ? dwTimeout : INFINITE),
    _fTerminate(false),
    _hPipe(NULL),
    _pvData(NULL),
    _dwSize(0)

{
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    ASSERTMSG(_dwTimeout != 0, "_dwTimeout cannot be 0 in CCredentialServer::CCredentialServer");
    ZeroMemory(&_overlapped, sizeof(_overlapped));

    //  Build a security descriptor for the named pipe that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     GENERIC_ALL | STANDARD_RIGHTS_ALL
    //      S-1-5-32-544    <local administrators>  READ_CONTROL

    static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority   =   SECURITY_NT_AUTHORITY;

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            GENERIC_ALL | STANDARD_RIGHTS_ALL
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            READ_CONTROL
        }
    };

    //  Build a security descriptor that allows the described access above.

    pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    if (pSecurityDescriptor != NULL)
    {
        SECURITY_ATTRIBUTES     securityAttributes;

        securityAttributes.nLength = sizeof(securityAttributes);
        securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
        securityAttributes.bInheritHandle = FALSE;

        //  Create the named pipe with the security descriptor.

        if (NT_SUCCESS(CCredentials::CreateConduit(&securityAttributes, &_hPipe)))
        {
            ASSERTMSG(_hPipe != NULL, "NULL hPipe but success NTSTATUS code in CCredentialServer::CCredentialServer");

            //  Create an event for overlapped I/O.

            _overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        }
        (HLOCAL)LocalFree(pSecurityDescriptor);

        //  Package credentials.

        TSTATUS(CCredentials::Pack(pLogonIPCCredentials, &_pvData, &_dwSize));
    }
}

//  --------------------------------------------------------------------------
//  CCredentialServer::~CCredentialServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CCredentialServer. Release memory and
//              resources.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

CCredentialServer::~CCredentialServer (void)

{
    ReleaseMemory(_pvData);
    ReleaseHandle(_overlapped.hEvent);
    ReleaseHandle(_hPipe);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::IsReady
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is the credential server ready to run?
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

bool    CCredentialServer::IsReady (void)  const

{
    return((_hPipe != NULL) && (_overlapped.hEvent != NULL));
}

//  --------------------------------------------------------------------------
//  CCredentialServer::Start
//
//  Arguments:  pLogonIPCCredentials    =   Logon credentials.
//              dwWaitTime              =   Timeout value.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Starts a new thread as the server of the credentials for the
//              new logon session.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentialServer::Start (LOGONIPC_CREDENTIALS *pLogonIPCCredentials, DWORD dwWaitTime)

{
    NTSTATUS            status;
    CCredentialServer   *pCredentialServer;

    //  Otherwise credentials need to be transferred across sessions to
    //  a newly created session. Start the credential transfer server.

    status = STATUS_NO_MEMORY;
    pCredentialServer = new CCredentialServer(dwWaitTime, pLogonIPCCredentials);
    if (pCredentialServer != NULL)
    {
        if (pCredentialServer->IsCreated() && pCredentialServer->IsReady())
        {
            pCredentialServer->Resume();

            //  If the server is set up then disconnect the console.
            //  If this fails then we'll let the server thread timeout
            //  and terminate itself eventually.

            if (WinStationDisconnect(SERVERNAME_CURRENT, USER_SHARED_DATA->ActiveConsoleId, TRUE) != FALSE)
            {
                status = STATUS_SUCCESS;
                if ((dwWaitTime != 0) && (WAIT_OBJECT_0 != pCredentialServer->WaitForCompletion(dwWaitTime)))
                {
                    status = STATUS_UNSUCCESSFUL;
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            if (!NT_SUCCESS(status))
            {
                pCredentialServer->ExecutePrematureTermination();
            }
        }
        else
        {
            TSTATUS(pCredentialServer->Terminate());
        }
        pCredentialServer->Release();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::Start
//
//  Arguments:  pszUsername     =   User name.
//              pszDomain       =   Domain.
//              pszPassword     =   Password.
//              dwWaitTime      =   Timeout value.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Package up the parameters into the required struct and pass
//              it to the real function.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentialServer::Start (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwWaitTime)

{
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    (WCHAR*)lstrcpynW(logonIPCCredentials.userID.wszUsername, pszUsername, ARRAYSIZE(logonIPCCredentials.userID.wszUsername));
    (WCHAR*)lstrcpynW(logonIPCCredentials.userID.wszDomain, pszDomain, ARRAYSIZE(logonIPCCredentials.userID.wszDomain));
    (WCHAR*)lstrcpynW(logonIPCCredentials.wszPassword, pszPassword, ARRAYSIZE(logonIPCCredentials.wszPassword));
    return(Start(&logonIPCCredentials, dwWaitTime));
}

//  --------------------------------------------------------------------------
//  CCredentialServer::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Handles the server side of the named pipe credential transfer.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CCredentialServer::Entry (void)

{
    DWORD   dwWaitResult;

    //  Wait for a client to connect to the named pipe. Wait no more than 30 seconds.

    (BOOL)ConnectNamedPipe(_hPipe, &_overlapped);
    dwWaitResult = WaitForSingleObjectEx(_overlapped.hEvent, _dwTimeout, TRUE);
    if (!_fTerminate && (dwWaitResult == WAIT_OBJECT_0))
    {

        //  Write the size of the buffer to the named pipe for the client to retrieve.

        TBOOL(ResetEvent(_overlapped.hEvent));
        if (WriteFileEx(_hPipe,
                        &_dwSize,
                        sizeof(_dwSize),
                        &_overlapped,
                        CB_FileIOCompletionRoutine) != FALSE)
        {
            do
            {
                dwWaitResult = WaitForSingleObjectEx(_overlapped.hEvent, _dwTimeout, TRUE);
            } while (!_fTerminate && (dwWaitResult == WAIT_IO_COMPLETION));
            if (!_fTerminate)
            {

                //  Write the actual contents of the credentials to the named pipe.

                TBOOL(ResetEvent(_overlapped.hEvent));
                if (WriteFileEx(_hPipe,
                                _pvData,
                                _dwSize,
                                &_overlapped,
                                CB_FileIOCompletionRoutine) != FALSE)
                {
                    do
                    {
                        dwWaitResult = WaitForSingleObjectEx(_overlapped.hEvent, _dwTimeout, TRUE);
                    } while (!_fTerminate && (dwWaitResult == WAIT_IO_COMPLETION));
                }
            }
        }
    }
#ifdef  DEBUG
    else
    {
        INFORMATIONMSG("Wait on named pipe LogonCredentials abandoned in CCredentialsServer::Entry");
    }
#endif

    //  Disconnect the server side invalidating the client handle.

    TBOOL(DisconnectNamedPipe(_hPipe));

    //  Clear the name of the named pipe used in the volatile section of the registry.

    TSTATUS(CCredentials::ClearConduit());
    return(0);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::ExecutePrematureTermination
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Queues an APC to the server thread to force it to terminate.
//              Don't check for an error. Don't wait for termination.
//              Reference counting should ensure that abnormal termination
//              will still clean up references correctly.
//
//  History:    2001-06-13  vtan        created
//  --------------------------------------------------------------------------

void    CCredentialServer::ExecutePrematureTermination (void)

{
    _fTerminate = true;
    (BOOL)QueueUserAPC(CB_APCProc, _hThread, NULL);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::CB_APCProc
//
//  Arguments:  dwParam     =   User defined data.
//
//  Returns:    <none>
//
//  Purpose:    APCProc executed on thread in alertable wait state.
//
//  History:    2001-06-13  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CCredentialServer::CB_APCProc (ULONG_PTR dwParam)

{
    UNREFERENCED_PARAMETER(dwParam);
}

//  --------------------------------------------------------------------------
//  CCredentialServer::CB_FileIOCompletionRoutine
//
//  Arguments:  dwErrorCode                 =   Error code of operation.
//              dwNumberOfBytesTransferred  =   Number of bytes transferred.
//              lpOverlapped                =   OVERLAPPED structure.
//
//  Returns:    <none>
//
//  Purpose:    Does nothing but is required for overlapped I/O.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CCredentialServer::CB_FileIOCompletionRoutine (DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred, LPOVERLAPPED lpOverlapped)

{
    UNREFERENCED_PARAMETER(dwErrorCode);
    UNREFERENCED_PARAMETER(dwNumberOfBytesTransferred);

    TBOOL(SetEvent(lpOverlapped->hEvent));
}

//  --------------------------------------------------------------------------
//  CCredentialClient::Get
//
//  Arguments:  pLogonIPCCredentials    =   Credentials returned from server.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens and reads the named pipe for the credential transfer
//              from server (previous winlogon) to client (this winlogon).
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCredentialClient::Get (LOGONIPC_CREDENTIALS *pLogonIPCCredentials)

{
    NTSTATUS    status;
    HANDLE      hPipe;

    //  Open the named pipe.

    status = CCredentials::OpenConduit(&hPipe);
    if (NT_SUCCESS(status))
    {
        DWORD   dwSize, dwNumberOfBytesRead;

        ASSERTMSG(hPipe != INVALID_HANDLE_VALUE, "INVALID_HANDLE_VALUE in CCredentialClient::Get");

        //  Read the size of the buffer from the named pipe.

        if (ReadFile(hPipe,
                     &dwSize,
                     sizeof(dwSize),
                     &dwNumberOfBytesRead,
                     NULL) != FALSE)
        {
            void    *pvData;

            //  Allocate a block of memory for the buffer to be received
            //  from the named pipe.

            pvData = LocalAlloc(LMEM_FIXED, dwSize);
            if (pvData != NULL)
            {

                //  Read the buffer from the named pipe.

                if (ReadFile(hPipe,
                             pvData,
                             dwSize,
                             &dwNumberOfBytesRead,
                             NULL) != FALSE)
                {

                    //  Make an additional read to release the server side of the
                    //  named pipe.

                    (BOOL)ReadFile(hPipe,
                                   &dwSize,
                                   sizeof(dwSize),
                                   &dwNumberOfBytesRead,
                                   NULL);

                    //  Unpack the data into the LOGONIPC_CREDENTIALS parameter buffer.

                    status = CCredentials::Unpack(pvData, pLogonIPCCredentials);
                }
                else
                {
                    status = CStatusCode::StatusCodeOfLastError();
                }
                (HLOCAL)LocalFree(pvData);
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseHandle(hPipe));
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\dimmedwindow.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: DimmedWindow.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements the dimmed window when displaying logoff / shut down
//  dialog.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "DimmedWindow.h"

#include "RegistryResources.h"

//  --------------------------------------------------------------------------
//  CDimmedWindow::s_szWindowClassName
//
//  Purpose:    static member variables.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

const TCHAR     CDimmedWindow::s_szWindowClassName[]        =   TEXT("DimmedWindowClass");
const TCHAR     CDimmedWindow::s_szExplorerKeyName[]        =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer");
const TCHAR     CDimmedWindow::s_szExplorerPolicyKeyName[]  =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR     CDimmedWindow::s_szForceDimValueName[]      =   TEXT("ForceDimScreen");
#define RCW(rc) ((rc).right - (rc).left)
#define RCH(r) ((r).bottom - (r).top)
#define CHUNK_SIZE 20

void DimPixels(void* pvBitmapBits, int cLen, int Amount)
{
    ULONG* pulSrc = (ULONG*)pvBitmapBits;

    for (int i = cLen - 1; i >= 0; i--)
    {
        ULONG ulR = GetRValue(*pulSrc);
        ULONG ulG = GetGValue(*pulSrc);
        ULONG ulB = GetBValue(*pulSrc);
        ULONG ulGray = (54 * ulR + 183 * ulG + 19 * ulB) >> 8;
        ULONG ulTemp = ulGray * (0xff - Amount);
        ulR = (ulR * Amount + ulTemp) >> 8;
        ulG = (ulG * Amount + ulTemp) >> 8;
        ulB = (ulB * Amount + ulTemp) >> 8;
        *pulSrc = (*pulSrc & 0xff000000) | RGB(ulR, ulG, ulB);

        pulSrc++;
    }
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::CDimmedWindow
//
//  Arguments:  hInstance   =   HINSTANCE of the hosting process/DLL.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDimmedWindow. Registers the window class
//              DimmedWindowClass.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

CDimmedWindow::CDimmedWindow (HINSTANCE hInstance) :
    _lReferenceCount(1),
    _hInstance(hInstance),
    _atom(0),
    _hwnd(NULL),
    _fDithered(false),
    _pvPixels(NULL),
    _idxChunk(0),
    _idxSaturation(0),
    _hdcDimmed(NULL),
    _hbmOldDimmed(NULL),
    _hbmDimmed(NULL)
{
    WNDCLASSEX  wndClassEx;

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(wndClassEx);
    wndClassEx.lpfnWndProc = WndProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = s_szWindowClassName;
    wndClassEx.hCursor = LoadCursor(NULL, IDC_ARROW);
    _atom = RegisterClassEx(&wndClassEx);
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::~CDimmedWindow
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDimmedWindow. Destroys the dimmed window and
//              unregisters the window class.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

CDimmedWindow::~CDimmedWindow (void)

{
    if (_hdcDimmed)
    {
        SelectObject(_hdcDimmed, _hbmOldDimmed);
        DeleteDC(_hdcDimmed);
    }

    if (_hbmDimmed)
    {
        DeleteObject(_hbmDimmed);
    }

    if (_hwnd != NULL)
    {
        (BOOL)DestroyWindow(_hwnd);
    }

    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
    }
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::QueryInterface
//
//  Arguments:  riid        =   Interface to query support of.
//              ppvObject   =   Returned interface if successful.
//
//  Returns:    HRESULT
//
//  Purpose:    Returns the specified interface implemented by this object.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CDimmedWindow::QueryInterface (REFIID riid, void **ppvObject)

{
    HRESULT     hr;

    if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppvObject = static_cast<IUnknown*>(this);
        (LONG)InterlockedIncrement(&_lReferenceCount);
        hr = S_OK;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::AddRef
//
//  Arguments:  <none>
//
//  Returns:    ULONG
//
//  Purpose:    Increments the reference count and returns that value.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

ULONG   CDimmedWindow::AddRef (void)

{
    return(static_cast<ULONG>(InterlockedIncrement(&_lReferenceCount)));
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::Release
//
//  Arguments:  <none>
//
//  Returns:    ULONG
//
//  Purpose:    Decrements the reference count and if it reaches zero deletes
//              the object.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

ULONG   CDimmedWindow::Release (void)

{
    ASSERT( 0 != _lReferenceCount );
    ULONG cRef = InterlockedDecrement(&_lReferenceCount);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::Create
//
//  Arguments:  <none>
//
//  Returns:    HWND
//
//  Purpose:    Creates the dimmed window. Creates the window so that it
//              covers the whole screen area.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

HWND    CDimmedWindow::Create (void)

{
    BOOL    fScreenReader;
    bool    fNoDebuggerPresent, fConsoleSession, fNoScreenReaderPresent;

    fNoDebuggerPresent = !IsDebuggerPresent();
    fConsoleSession = (GetSystemMetrics(SM_REMOTESESSION) == FALSE);
    fNoScreenReaderPresent = ((SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenReader, 0) == FALSE) || (fScreenReader == FALSE));
    if (fNoDebuggerPresent &&
        fConsoleSession &&
        fNoScreenReaderPresent)
    {
        _xVirtualScreen = GetSystemMetrics(SM_XVIRTUALSCREEN);
        _yVirtualScreen = GetSystemMetrics(SM_YVIRTUALSCREEN);
        _cxVirtualScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        _cyVirtualScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        _hwnd = CreateWindowEx(WS_EX_TOPMOST,
                               s_szWindowClassName,
                               NULL,
                               WS_POPUP,
                               _xVirtualScreen, _yVirtualScreen,
                               _cxVirtualScreen, _cyVirtualScreen,
                               NULL, NULL, _hInstance, this);
        if (_hwnd != NULL)
        {
            bool    fDimmed;

            fDimmed = false;
            (BOOL)ShowWindow(_hwnd, SW_SHOW);
            TBOOL(SetForegroundWindow(_hwnd));

            // For beta: Always use a dither
            // if ((GetLowestScreenBitDepth() <= 8) || !IsDimScreen())
            {
                _fDithered = true;
            }
            (BOOL)EnableWindow(_hwnd, FALSE);
        }
    }
    return(_hwnd);
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::GetLowestScreenBitDepth
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Iterates the display devices looking the display with the
//              lowest bit depth.
//
//  History:    2000-05-22  vtan        created
//  --------------------------------------------------------------------------

int     CDimmedWindow::GetLowestScreenBitDepth (void)  const

{
    enum
    {
        INITIAL_VALUE   =   256
    };

    BOOL            fResult;
    int             iLowestScreenBitDepth, iDeviceNumber;
    DISPLAY_DEVICE  displayDevice;

    iLowestScreenBitDepth = INITIAL_VALUE;     //  Start at beyond 32-bit depth.
    iDeviceNumber = 0;
    displayDevice.cb = sizeof(displayDevice);
    fResult = EnumDisplayDevices(NULL, iDeviceNumber, &displayDevice, 0);
    while (fResult != FALSE)
    {
        if ((displayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) != 0)
        {
            HDC     hdcDisplay;

            hdcDisplay = CreateDC(displayDevice.DeviceName, displayDevice.DeviceName, NULL, NULL);
            if (hdcDisplay != NULL)
            {
                int     iResult;

                iResult = GetDeviceCaps(hdcDisplay, BITSPIXEL);
                if (iResult < iLowestScreenBitDepth)
                {
                    iLowestScreenBitDepth = iResult;
                }
                TBOOL(DeleteDC(hdcDisplay));
            }
        }
        displayDevice.cb = sizeof(displayDevice);
        fResult = EnumDisplayDevices(NULL, ++iDeviceNumber, &displayDevice, 0);
    }
    if (INITIAL_VALUE == iLowestScreenBitDepth)
    {
        iLowestScreenBitDepth = 8;
    }
    return(iLowestScreenBitDepth);
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::IsForcedDimScreen
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the force override of dimming is set on this
//              user or this machine. Check the local machine first. Then
//              check the user setting. Then check the user policy. Then
//              check the local machine policy.
//
//  History:    2000-05-23  vtan        created
//  --------------------------------------------------------------------------

bool    CDimmedWindow::IsForcedDimScreen (void)        const

{
    DWORD       dwForceDimScreen;
    CRegKey     regKey;

    dwForceDimScreen = 0;
    if (ERROR_SUCCESS == regKey.Open(HKEY_LOCAL_MACHINE, s_szExplorerKeyName, KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetDWORD(s_szForceDimValueName, dwForceDimScreen);
    }
    if (ERROR_SUCCESS == regKey.OpenCurrentUser(s_szExplorerKeyName, KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetDWORD(s_szForceDimValueName, dwForceDimScreen);
    }
    if (ERROR_SUCCESS == regKey.OpenCurrentUser(s_szExplorerPolicyKeyName, KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetDWORD(s_szForceDimValueName, dwForceDimScreen);
    }
    if (ERROR_SUCCESS == regKey.Open(HKEY_LOCAL_MACHINE, s_szExplorerPolicyKeyName, KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetDWORD(s_szForceDimValueName, dwForceDimScreen);
    }
    return(dwForceDimScreen != 0);
}

//  --------------------------------------------------------------------------
//  CDimmedWindow::IsDimScreen
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the screen should be dimmed. If not then the
//              screen will be dithered instead which is a cheaper operation
//              by doesn't look as nice.
//
//              1) If UI effects are disabled then don't ever dim.
//              2) Dim if screen area is small enough OR forced to dim.
//
//  History:    2000-05-23  vtan        created
//  --------------------------------------------------------------------------

bool    CDimmedWindow::IsDimScreen (void)              const

{
    bool    fIsUIEffectsActive;
    BOOL    fTemp;

    fIsUIEffectsActive = (SystemParametersInfo(SPI_GETUIEFFECTS, 0, &fTemp, 0) != FALSE) && (fTemp != FALSE);
    return(fIsUIEffectsActive && IsForcedDimScreen());
}


BOOL CDimmedWindow::StepDim()
{
    HDC hdcWindow = GetDC(_hwnd);

    if (_idxChunk >= 0 )
    {
        //
        //  In the first couple of passes, we slowly collect the screen 
        //  into our bitmap. We do this because Blt-ing the whole thing
        //  causes the system to hang. By doing it this way, we continue
        //  to pump messages, the UI stays responsive and it keeps the 
        //  mouse alive.
        //

        int y  = _idxChunk * CHUNK_SIZE;
        BitBlt(_hdcDimmed, 0, y, _cxVirtualScreen, CHUNK_SIZE, hdcWindow, 0, y, SRCCOPY);

        _idxChunk--;
        if (_idxChunk < 0)
        {
            //
            //  We're done getting the bitmap, now reset the timer
            //  so we slowly fade to grey.
            //

            SetTimer(_hwnd, 1, 250, NULL);
            _idxSaturation = 16;
        }

        return TRUE;    // don't kill the timer.
    }
    else
    {
        //
        //  In these passes, we are making the image more and more grey and
        //  then Blt-ing the result to the screen.
        //

        DimPixels(_pvPixels, _cxVirtualScreen * _cyVirtualScreen, 0xd5);
        BitBlt(hdcWindow, 0, 0, _cxVirtualScreen, _cyVirtualScreen, _hdcDimmed, 0, 0, SRCCOPY);

        _idxSaturation--;

        return (_idxSaturation > 0);    // when we hit zero, kill the timer.
    }
}

void CDimmedWindow::SetupDim()
{
    HDC     hdcWindow = GetDC(_hwnd);
    if (hdcWindow != NULL)
    {
        _hdcDimmed = CreateCompatibleDC(hdcWindow);
        if (_hdcDimmed != NULL)
        {
            BITMAPINFO  bmi;

            ZeroMemory(&bmi, sizeof(bmi));
            bmi.bmiHeader.biSize = sizeof(bmi);
            bmi.bmiHeader.biWidth =  _cxVirtualScreen;
            bmi.bmiHeader.biHeight = _cyVirtualScreen; 
            bmi.bmiHeader.biPlanes = 1;
            bmi.bmiHeader.biBitCount = 32;
            bmi.bmiHeader.biCompression = BI_RGB;
            bmi.bmiHeader.biSizeImage = 0;

            _hbmDimmed = CreateDIBSection(_hdcDimmed, &bmi, DIB_RGB_COLORS, &_pvPixels, NULL, 0);
            if (_hbmDimmed != NULL)
            {
                _hbmOldDimmed = (HBITMAP) SelectObject(_hdcDimmed, _hbmDimmed);
                _idxChunk = _cyVirtualScreen / CHUNK_SIZE;
            }
            else
            {
                ASSERT( NULL == _pvPixels );
                DeleteDC(_hdcDimmed);
                _hdcDimmed = NULL;
            }
        }
        ReleaseDC(_hwnd, hdcWindow);
    }
}

void    CDimmedWindow::Dither()

{
    static  const WORD  s_dwGrayBits[]  =
    {
        0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA
    };

    HDC hdcWindow = GetDC(_hwnd);
    if (hdcWindow != NULL)
    {
        HBITMAP hbmDimmed = CreateBitmap(8, 8, 1, 1, s_dwGrayBits);
        if (hbmDimmed != NULL)
        {
            HBRUSH hbrDimmed = CreatePatternBrush(hbmDimmed);
            if (hbrDimmed != NULL)
            {
                static  const int   ROP_DPna    =   0x000A0329;

                RECT    rc;
                HBRUSH  hbrSelected = static_cast<HBRUSH>(SelectObject(hdcWindow, hbrDimmed));
                TBOOL(GetClientRect(_hwnd, &rc));
                TBOOL(PatBlt(hdcWindow, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, ROP_DPna));
                SelectObject(hdcWindow, hbrSelected);

                TBOOL(DeleteObject(hbrDimmed));
            }

            TBOOL(DeleteObject(hbmDimmed));
        }
        TBOOL(ReleaseDC(_hwnd, hdcWindow));
    }
}


//  --------------------------------------------------------------------------
//  CDimmedWindow::WndProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    See the platform SDK under WindowProc.
//
//  Purpose:    WindowProc for the dimmed window. This just passes the
//              messages thru to DefWindowProc.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    CDimmedWindow::WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT         lResult = 0;
    CDimmedWindow   *pThis;

    pThis = reinterpret_cast<CDimmedWindow*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            pThis = reinterpret_cast<CDimmedWindow*>(pCreateStruct->lpCreateParams);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
            lResult = 0;
            if (pThis->_fDithered)
                pThis->Dither();
            else
            {
                pThis->SetupDim();
                if (pThis->_hdcDimmed)
                {
                    SetTimer(hwnd, 1, 30, NULL);
                }
            }
            break;
        }

        case WM_TIMER:
            if (!pThis->StepDim())
                KillTimer(hwnd, 1);
            break;

        case WM_PAINT:
        {
            HDC             hdcPaint;
            PAINTSTRUCT     ps;

            hdcPaint = BeginPaint(hwnd, &ps);
            TBOOL(EndPaint(hwnd, &ps));
            lResult = 0;
            break;
        }
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\credentialtransfer.h ===
//  --------------------------------------------------------------------------
//  Module Name: CredentialTransfer.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Classes to handle credential transfer from one winlogon to another.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _CredentialTransfer_
#define     _CredentialTransfer_

#include <ginaipc.h>

#include "Thread.h"

//  --------------------------------------------------------------------------
//  CCredentials
//
//  Purpose:    Class to manage marshalling of credentials into a block of
//              memory that can be used in a named pipe.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

class   CCredentials
{
    private:
        typedef struct _CREDENTIALS
        {
            DWORD           dwSize;
            unsigned char   ucPasswordSeed;
            UNICODE_STRING  username;
            UNICODE_STRING  domain;
            UNICODE_STRING  password;
        } CREDENTIALS, *PCREDENTIALS;
    private:
                                        CCredentials (void);
                                        ~CCredentials (void);
    public:
        static  NTSTATUS                OpenConduit (HANDLE *phPipe);
        static  NTSTATUS                CreateConduit (LPSECURITY_ATTRIBUTES pSecurityAttributes, HANDLE *phPipe);
        static  NTSTATUS                ClearConduit (void);

        static  NTSTATUS                Pack (LOGONIPC_CREDENTIALS *pLogonIPCCredentials, void* *ppvData, DWORD *pdwDataSize);
        static  NTSTATUS                Unpack (void *pvData, LOGONIPC_CREDENTIALS *pLogonIPCCredentials);

        static  NTSTATUS                StaticInitialize (bool fCreate);
        static  NTSTATUS                StaticTerminate (void);
    private:
        static  NTSTATUS                GetConduitName (TCHAR *pszName, DWORD dwNameSize);
        static  NTSTATUS                SetConduitName (const TCHAR *pszName);
        static  NTSTATUS                ClearConduitName (void);
        static  NTSTATUS                CreateConduitName (DWORD dwNumber, TCHAR *pszName);
    private:
        static  HKEY                    s_hKeyCredentials;
        static  const TCHAR             s_szCredentialKeyName[];
        static  const TCHAR             s_szCredentialValueName[];
};

//  --------------------------------------------------------------------------
//  CCredentialServer
//
//  Purpose:    Class to manage the server side of handing credentials from
//              one winlogon to another.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

class   CCredentialServer : public CThread
{
    private:
                                        CCredentialServer (void);
                                        CCredentialServer (DWORD dwTimeout, LOGONIPC_CREDENTIALS *pLogonIPCCredentials);
        virtual                         ~CCredentialServer (void);
    public:
                bool                    IsReady (void)  const;

        static  NTSTATUS                Start (LOGONIPC_CREDENTIALS *pLogonIPCCredentials, DWORD dwWaitTime);
        static  NTSTATUS                Start (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwWaitTime);
    protected:
        virtual DWORD                   Entry (void);
    private:
                void                    ExecutePrematureTermination (void);

        static  void    CALLBACK        CB_APCProc (ULONG_PTR dwParam);
        static  void    CALLBACK        CB_FileIOCompletionRoutine (DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred, LPOVERLAPPED lpOverlapped);
    private:
                DWORD                   _dwTimeout;
                bool                    _fTerminate;
                HANDLE                  _hPipe;
                OVERLAPPED              _overlapped;
                void*                   _pvData;
                DWORD                   _dwSize;
};

//  --------------------------------------------------------------------------
//  CCredentialClient
//
//  Purpose:    Class to manage the client side of handing credentials from
//              one winlogon to another.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

class   CCredentialClient
{
    private:
                                        CCredentialClient (void);
                                        ~CCredentialClient (void);
    public:
        static  NTSTATUS                Get (LOGONIPC_CREDENTIALS *pLogonIPCCredentials);
};

#endif  /*  _CredentialTransfer_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\exports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Exports.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  C header file that contains function prototypes that are to be exported
//  from msgina.dll
//
//  History:    2000-02-04  vtan        created
//              2000-02-28  vtan        added ShellIsFriendlyUIActive
//              2000-02-29  vtan        added ShellIsSingleUserNoPassword
//              2000-03-02  vtan        added ShellIsMultipleUsersEnabled
//              2000-04-27  vtan        added ShellTurnOffDialog
//              2000-04-27  vtan        added ShellACPIPowerButtonPressed
//              2000-05-03  vtan        added ShellStatusHostBegin
//              2000-05-03  vtan        added ShellStatusHostEnd
//              2000-05-04  vtan        added ShellSwitchWhenInteractiveReady
//              2000-05-18  vtan        added ShellDimScreen
//              2000-06-02  vtan        added ShellInstallAccountFilterData
//              2000-07-14  vtan        added ShellStatusHostShuttingDown
//              2000-07-27  vtan        added ShellIsSuspendAllowed
//              2000-07-28  vtan        added ShellEnableMultipleUsers
//              2000-07-28  vtan        added ShellEnableRemoteConnections
//              2000-08-01  vtan        added ShellEnableFriendlyUI
//              2000-08-01  vtan        added ShellIsRemoteConnectionsEnabled
//              2000-08-03  vtan        added ShellSwitchUser
//              2000-08-09  vtan        added ShellNotifyThemeUserChange
//              2000-08-14  vtan        added ShellIsUserInteractiveLogonAllowed
//              2000-10-13  vtan        added ShellStartThemeServer
//              2000-10-17  vtan        added ShellStopThemeServer
//              2000-11-30  vtan        removed ShellStartThemeServer
//              2000-11-30  vtan        removed ShellStopThemeServer
//              2001-01-11  vtan        renamed functions to _Shell
//              2001-01-11  vtan        added ShellReturnToWelcome
//              2001-01-31  vtan        added ShellStatusHostPowerEvent
//              2001-04-03  vtan        added ShellStartCredentialServer
//              2001-04-04  vtan        added ShellAcquireLogonMutex
//              2001-04-04  vtan        added ShellReleaseLogonMutex
//              2001-04-12  vtan        added ShellStatusHostHide
//              2001-04-12  vtan        added ShellStatusHostShow
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include <msginaexports.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <winsta.h>
#include <winwlx.h>
#include <LPCThemes.h>

#include "Compatibility.h"
#include "CredentialTransfer.h"
#include "DimmedWindow.h"
#include "LogonMutex.h"
#include "PowerButton.h"
#include "PrivilegeEnable.h"
#include "ReturnToWelcome.h"
#include "SpecialAccounts.h"
#include "StatusCode.h"
#include "SystemSettings.h"
#include "TokenInformation.h"
#include "TurnOffDialog.h"
#include "UserList.h"
#include "UserSettings.h"
#include "WaitInteractiveReady.h"

//  --------------------------------------------------------------------------
//  ::ShellGetUserList
//
//  Arguments:  fRemoveGuest            =   Always remove the "Guest" account.
//              pdwReturnEntryCount     =   Returned number of entries. This
//                                          may be NULL.
//              pvBuffer                =   Buffer containing user data. This
//                                          may be NULL.
//
//  Returns:    LONG
//
//  Purpose:    Gets the count of valid users and the user list on this
//              system. This calls a static member function so that the
//              context doesn't need to be supplied. This allows shgina (the
//              logonocx) to call this function as a stand-alone function.
//
//  History:    1999-10-15  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

EXTERN_C    LONG    _ShellGetUserList(BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList)

{
    return(CUserList::Get((fRemoveGuest != FALSE), pdwUserCount, reinterpret_cast<GINA_USER_INFORMATION**>(pUserList)));
}

//  --------------------------------------------------------------------------
//  ::ShellIsSingleUserNoPassword
//
//  Arguments:  pszUsername     =   Name of single user with no password.
//              pszDomain       =   Domain for the user.
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether this system is using friendly UI and has a
//              single user with no password. If there is a single user with
//              no password the login name is returned otherwise the parameter
//              is unused.
//
//  History:    2000-02-29  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain)

{
    BOOL    fResult;

    fResult = FALSE;
    if (CSystemSettings::IsFriendlyUIActive())
    {
        DWORD                   dwReturnedEntryCount;
        GINA_USER_INFORMATION   *pUserList;

        if (ERROR_SUCCESS == CUserList::Get(true, &dwReturnedEntryCount, &pUserList))
        {
            if (dwReturnedEntryCount == 1)
            {
                HANDLE  hToken;

                if (CTokenInformation::LogonUser(pUserList->pszName,
                                                 pUserList->pszDomain,
                                                 L"",
                                                 &hToken) == ERROR_SUCCESS)
                {
                    fResult = TRUE;
                    if (pwszUsername != NULL)
                    {
                        (WCHAR*)lstrcpyW(pwszUsername, pUserList->pszName);
                    }
                    if (pwszDomain != NULL)
                    {
                        (WCHAR*)lstrcpyW(pwszDomain, pUserList->pszDomain);
                    }
                    if (hToken != NULL)
                    {
                        TBOOL(CloseHandle(hToken));
                    }
                }
            }
            (HLOCAL)LocalFree(pUserList);
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ShellIsFriendlyUIActive
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the friendly UI is active.
//
//  History:    2000-02-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellIsFriendlyUIActive (void)

{
    return(CSystemSettings::IsFriendlyUIActive());
}

//  --------------------------------------------------------------------------
//  ::ShellIsMultipleUsersEnabled
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether multiple users is enabled. This includes
//              checking a registry key as well as whether terminal services
//              is enabled on this machine.
//
//  History:    2000-03-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellIsMultipleUsersEnabled (void)

{
    return(CSystemSettings::IsMultipleUsersEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellIsRemoteConnectionsEnabled
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether remote connections are enabled. This includes
//              checking a registry key as well as whether terminal services
//              is enabled on this machine.
//
//  History:    2000-08-01  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellIsRemoteConnectionsEnabled (void)

{
    return(CSystemSettings::IsRemoteConnectionsEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellEnableFriendlyUI
//
//  Arguments:  fEnable     =   Enable or disable friendly UI.
//
//  Returns:    BOOL
//
//  Purpose:    Enables or disables friendly UI via the CSystemSettings
//              implementaion.
//
//  History:    2000-08-01  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellEnableFriendlyUI (BOOL fEnable)

{
    return(CSystemSettings::EnableFriendlyUI(fEnable != FALSE));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableMultipleUsers
//
//  Arguments:  fEnable     =   Enable or disable multiple users.
//
//  Returns:    BOOL
//
//  Purpose:    Enables or disables multiple users via the CSystemSettings
//              implementaion.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellEnableMultipleUsers (BOOL fEnable)

{
    return(CSystemSettings::EnableMultipleUsers(fEnable != FALSE));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableRemoteConnections
//
//  Arguments:  fEnable     =   Enable or disable remote connections.
//
//  Returns:    BOOL
//
//  Purpose:    Enables or disables remote connections via the CSystemSettings
//              implementaion.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellEnableRemoteConnections (BOOL fEnable)

{
    return(CSystemSettings::EnableRemoteConnections(fEnable != FALSE));
}

//  --------------------------------------------------------------------------
//  ::ShellTurnOffDialog
//
//  Arguments:  hwndParent  =   HWND to parent the dialog to.
//
//  Returns:    DWORD
//
//  Purpose:    Displays the "Turn Off Computer" dialog and allows the user to
//              make a choice of available shut down options.
//
//  History:    2000-03-02  vtan        created
//              2000-04-17  vtan        moved from shell to msgina
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   _ShellTurnOffDialog (HWND hwndParent)

{
    CTurnOffDialog  turnOffDialog(hDllInstance);

    return(turnOffDialog.Show(hwndParent));
}

//  --------------------------------------------------------------------------
//  ::ShellACPIPowerButtonPressed
//
//  Arguments:  pWlxContext     =   PGLOBALS allocated at WlxInitialize.
//              uiEventType     =   Event code for the power message.
//              fLocked         =   Is workstation locked or not.
//
//  Returns:    DWORD
//
//  Purpose:    Displays the "Turn Off Computer" dialog and allows the user to
//              make a choice of available shut down options. This is called
//              in response to an ACPI power button press. The return codes
//              are MSGINA_DLG_xxx return codes to winlogon.
//
//  History:    2000-04-17  vtan        created
//              2001-06-12  vtan        added fLocked flag
//  --------------------------------------------------------------------------

EXTERN_C    int     _ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked)

{
    int                 iResult;
    CTokenInformation   tokenInformation;
    CUserSettings       userSettings;

    if ((uiEventType & (POWER_USER_NOTIFY_BUTTON | POWER_USER_NOTIFY_SHUTDOWN)) != 0)
    {

        //  This code should not be re-entrant for multiple ACPI power button
        //  presses while the dialog is up. Blow off any further requests.

        //  Conditions for the prompt:
        //      1) This session is the active console session
        //      2) Power button dialog not already displayed
        //      3) User is not restricted from closing the taskbar (shut down options)
        //      4) User has the privilege to shut down the machine or the friendly UI is NOT active
        //      5) User is not the system OR shut down without logon is allowed

        if (CSystemSettings::IsActiveConsoleSession() &&
            !userSettings.IsRestrictedNoClose() &&
            (tokenInformation.UserHasPrivilege(SE_SHUTDOWN_PRIVILEGE) || !CSystemSettings::IsFriendlyUIActive()) &&
            (!tokenInformation.IsUserTheSystem() || CSystemSettings::IsShutdownWithoutLogonAllowed()))
        {
            DWORD   dwExitWindowsFlags;

            if ((uiEventType & POWER_USER_NOTIFY_SHUTDOWN) != 0)
            {
                iResult = CTurnOffDialog::ShellCodeToGinaCode(SHTDN_SHUTDOWN);
            }
            else
            {
                DWORD           dwResult;
                CPowerButton    *pPowerButton;

                //  Create a thread to handle the dialog. This is required because
                //  the dialog must be put on the input desktop which isn't necessarily
                //  the same as this thread's desktop. Wait for its completion.

                pPowerButton = new CPowerButton(pWlxContext, hDllInstance);
                if (pPowerButton != NULL)
                {
                    (DWORD)pPowerButton->WaitForCompletion(INFINITE);

                    //  Get the dialog result and check its validity. Only execute
                    //  valid requests.

                    dwResult = pPowerButton->GetResult();
                    pPowerButton->Release();
                }
                else
                {
                    dwResult = MSGINA_DLG_FAILURE;
                }
                iResult = dwResult;
            }
            dwExitWindowsFlags = CTurnOffDialog::GinaCodeToExitWindowsFlags(iResult);

            //  If this is a restart or a shutdown then decide to display a warning.
            //  If the user is the system then use EWX_SYSTEM_CALLER.
            //  If the workstation is locked then use EWX_WINLOGON_CALLER.
            //  Otherwise use nothing but still possibly display a warning.

            if ((dwExitWindowsFlags != 0) && (DisplayExitWindowsWarnings((tokenInformation.IsUserTheSystem() ? EWX_SYSTEM_CALLER : fLocked ? EWX_WINLOGON_CALLER : 0) | dwExitWindowsFlags) == FALSE))
            {
                iResult = MSGINA_DLG_FAILURE;
            }
        }
        else
        {
            iResult = -1;
        }
    }
    else
    {
        WARNINGMSG("Unknown event type in _ShellACPIPowerButtonPressed.\r\n");
        iResult = MSGINA_DLG_FAILURE;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  ::ShellIsSuspendAllowed
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether suspend is allowed. This is important to
//              prevent the UI host from going into an uncertain state due to
//              the asynchronous nature of suspend and the WM_POWERBROADCAST
//              messages.
//
//              Suspend is allowed if ANY of these conditions are satisfied.
//
//                  1) Friendly UI is NOT active
//                  2) No UI Host exists
//                  3) UI Host exists and is active (not as status host)
//
//  History:    2000-07-27  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellIsSuspendAllowed (void)

{
    return(!CSystemSettings::IsFriendlyUIActive() || _Shell_LogonStatus_IsSuspendAllowed());
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostBegin
//
//  Arguments:  uiStartType     =   Mode to start UI host in.
//
//  Returns:    <none>
//
//  Purpose:    Starts the status UI host if specified.
//
//  History:    2000-05-03  vtan        created
//              2000-07-13  vtan        add shutdown parameter
//              2000-07-17  vtan        changed to start type parameter
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellStatusHostBegin (UINT uiStartType)

{
    _Shell_LogonStatus_Init(uiStartType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostEnd
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Terminates the status UI host if one was started.
//
//  History:    2000-05-03  vtan        created
//              2001-01-09  vtan        add end type parameter
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellStatusHostEnd (UINT uiEndType)

{
    _Shell_LogonStatus_Destroy(uiEndType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostShuttingDown
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tell the status UI host to display a title that the system is
//              shutting down.
//
//  History:    2000-07-14  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellStatusHostShuttingDown (void)

{
    _Shell_LogonStatus_NotifyWait();
    _Shell_LogonStatus_SetStateStatus(0);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostPowerEvent
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tell the status UI host to go into "Please Wait" mode in
//              preparation for a power event.
//
//  History:    2001-01-31  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellStatusHostPowerEvent (void)

{
    _Shell_LogonStatus_NotifyWait();
    _Shell_LogonStatus_SetStateStatus(SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchWhenInteractiveReady
//
//  Arguments:  eSwitchType     =   Switch type.
//              pWlxContext     =   PGLOBALS allocated at WlxInitialize.
//
//  Returns:    BOOL
//
//  Purpose:    Does one of three things.
//
//              1) Create the switch event and registers the wait on it.
//              2) Checks the switch event and switches now or when signaled.
//              3) Cancels any outstanding wait and clean up.
//
//  History:    2000-05-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext)

{
    NTSTATUS    status;

    switch (eSwitchType)
    {
        case SWITCHTYPE_CREATE:
            if (!CSystemSettings::IsSafeMode() && _Shell_LogonStatus_Exists() && CSystemSettings::IsFriendlyUIActive())
            {
                status = CWaitInteractiveReady::Create(pWlxContext);
            }
            else
            {
                status = STATUS_UNSUCCESSFUL;
            }
            break;
        case SWITCHTYPE_REGISTER:
            status = CWaitInteractiveReady::Register(pWlxContext);
            break;
        case SWITCHTYPE_CANCEL:
            status = CWaitInteractiveReady::Cancel();
            break;
        default:
            DISPLAYMSG("Unexpected switch type in _ShellSwitchWhenInteractiveReady");
            status = STATUS_UNSUCCESSFUL;
            break;
    }
    return(NT_SUCCESS(status));
}

//  --------------------------------------------------------------------------
//  ::ShellDimScreen
//
//  Arguments:  ppIUnknown      =   IUnknown returned for release.
//              phwndDimmed     =   HWND of the dimmed window for parenting.
//
//  Returns:    HRESULT
//
//  Purpose:    
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     _ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed)

{
    HRESULT         hr;
    CDimmedWindow   *pDimmedWindow;

    if (IsBadWritePtr(ppIUnknown, sizeof(*ppIUnknown)) || IsBadWritePtr(phwndDimmed, sizeof(*phwndDimmed)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppIUnknown = NULL;
        pDimmedWindow = new CDimmedWindow(hDllInstance);
        if (pDimmedWindow != NULL)
        {
            hr = pDimmedWindow->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(ppIUnknown));
            if (SUCCEEDED(hr))
            {
                pDimmedWindow->Release();
                *phwndDimmed = pDimmedWindow->Create();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  ::ShellInstallAccountFilterData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Called by shgina registration to install special accounts
//              that need to be filtered by name.
//
//  History:    2000-06-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellInstallAccountFilterData (void)

{
    CSpecialAccounts::Install();
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchUser
//
//  Arguments:  fWait   =   Wait for console disconnect to complete.
//
//  Returns:    DWORD
//
//  Purpose:    Checks for available memory before doing a disconnect. If the
//              disconnect succeeds the processes running in the session have
//              their working set dropped.
//
//  History:    2000-08-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   _ShellSwitchUser (BOOL fWait)

{
    static  BOOL    s_fIsServer = static_cast<BOOL>(-1);

    DWORD   dwErrorCode;

    dwErrorCode = ERROR_SUCCESS;
    if (s_fIsServer == static_cast<BOOL>(-1))
    {
        OSVERSIONINFOEX     osVersionInfoEx;

        ZeroMemory(&osVersionInfoEx, sizeof(osVersionInfoEx));
        osVersionInfoEx.dwOSVersionInfoSize = sizeof(osVersionInfoEx);
        if (GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&osVersionInfoEx)) != FALSE)
        {
            s_fIsServer = ((VER_NT_SERVER == osVersionInfoEx.wProductType) || (VER_NT_DOMAIN_CONTROLLER == osVersionInfoEx.wProductType));
        }
        else
        {
            dwErrorCode = GetLastError();
        }
    }
    if (dwErrorCode == ERROR_SUCCESS)
    {
        bool    fRemote;

        fRemote = (GetSystemMetrics(SM_REMOTESESSION) != 0);
        if (s_fIsServer)
        {

            //  Normal Server TS case (RemoteAdmin and TerminalServer)

            if (fRemote)
            {
                if (WinStationDisconnect(SERVERNAME_CURRENT, LOGONID_CURRENT, static_cast<BOOLEAN>(fWait)) == FALSE)
                {
                    dwErrorCode = GetLastError();
                }
            }
            else
            {
                dwErrorCode = ERROR_NOT_SUPPORTED;
            }
        }
        else if (ShellIsMultipleUsersEnabled() && !fRemote)
        {
            NTSTATUS    status;

            //  Fast user switching case - need to do some extra work
            //  FUS is always on the console. When the session is remoted
            //  fall thru to PTS.

            status = CCompatibility::TerminateNonCompliantApplications();
            if (status == STATUS_PORT_DISCONNECTED)
            {
                status = CCompatibility::TerminateNonCompliantApplications();
            }
            dwErrorCode = static_cast<DWORD>(CStatusCode::ErrorCodeOfStatusCode(status));
            if (dwErrorCode == ERROR_SUCCESS)
            {
                if (CCompatibility::HasEnoughMemoryForNewSession())
                {
                    HANDLE  hEvent;

                    TBOOL(_ShellSwitchWhenInteractiveReady(SWITCHTYPE_CANCEL, NULL));
                    hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, CReturnToWelcome::GetEventName());
                    if (hEvent != NULL)
                    {
                        TBOOL(SetEvent(hEvent));
                        TBOOL(CloseHandle(hEvent));
                    }
                }
                else
                {
                    dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
        else
        {

            //  Normal PTS case or FUS remoted, just call the api

            if (WinStationDisconnect(SERVERNAME_CURRENT, LOGONID_CURRENT, static_cast<BOOLEAN>(fWait)) == FALSE)
            {
                dwErrorCode = GetLastError();
            }
        }
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  ::ShellIsUserInteractiveLogonAllowed
//
//  Arguments:  pwszUsername    =   User name to check interactive logon.
//
//  Returns:    int
//
//  Purpose:    Checks whether the given user has interactive logon right to
//              the local system. The presence of SeDenyInteractiveLogonRight
//              determines this.
//
//              -1 = indeterminate state
//               0 = interactive logon not allowed
//               1 = interactive logon allowed.
//
//  History:    2000-08-14  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int     _ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername)

{
    return(CUserList::IsInteractiveLogonAllowed(pwszUsername));
}

//  --------------------------------------------------------------------------
//  ::ShellNotifyThemeUserChange
//
//  Arguments:  hToken          =   Token of user being logged on.
//              fUserLoggedOn   =   Indicates logon or logoff.
//
//  Returns:    <none>
//
//  Purpose:    Gives themes a chance to change the active theme based on a
//              user logging on or logging off. This may be required because
//              the default theme may be different from the user theme.
//
//  History:    2000-08-09  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken)

{
    static  HANDLE  s_hToken    =   NULL;

    switch (eUserLogType)
    {
        case ULT_LOGON:
            (BOOL)ThemeUserLogon(hToken);
            if (QueueUserWorkItem(CSystemSettings::AdjustFUSCompatibilityServiceState,
                                  NULL,
                                  WT_EXECUTELONGFUNCTION) == FALSE)
            {
                (DWORD)CSystemSettings::AdjustFUSCompatibilityServiceState(NULL);
            }
            s_hToken = hToken;
            break;
        case ULT_LOGOFF:
            if (s_hToken != NULL)
            {
                (DWORD)CSystemSettings::AdjustFUSCompatibilityServiceState(NULL);
                s_hToken = NULL;
            }
            (BOOL)ThemeUserLogoff();
            break;
        case ULT_TSRECONNECT:
            (BOOL)ThemeUserTSReconnect();
            break;
        case ULT_STARTSHELL:
            (BOOL)ThemeUserStartShell();
            break;
        default:
            DISPLAYMSG("Unexpected eUserLogType in ::_ShellNotifyThemeUserChange");
            break;
    }
}

//  --------------------------------------------------------------------------
//  ::_ShellReturnToWelcome
//
//  Arguments:  fUnlock     =   Unlock status mode required.
//
//  Returns:    int
//
//  Purpose:    Handles the dialog that is brought up behind the welcome
//              screen. This dialog is similar to WlxLoggedOutSAS but is
//              specific to return to welcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   _ShellReturnToWelcome (BOOL fUnlock)

{
    CReturnToWelcome    returnToWelcome;

    return(static_cast<DWORD>(returnToWelcome.Show(fUnlock != FALSE)));
}

//  --------------------------------------------------------------------------
//  ::_ShellStartCredentialServer
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   Domain.
//              pwszPassword    =   Password.
//              dwTimeout       =   Timeout.
//
//  Returns:    DWORD
//
//  Purpose:    Starts a credential transfer server in the host process. The
//              caller must have SE_TCB_PRIVILEGE to execute this function.
//
//  History:    2001-04-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD       _ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout)

{
    DWORD               dwErrorCode;
    CTokenInformation   tokenInformation;

    if (tokenInformation.UserHasPrivilege(SE_TCB_PRIVILEGE))
    {
        TSTATUS(CCredentials::StaticInitialize(false));
        dwErrorCode = CStatusCode::ErrorCodeOfStatusCode(CCredentialServer::Start(pwszUsername, pwszDomain, pwszPassword, dwTimeout));
    }
    else
    {
        dwErrorCode = ERROR_PRIVILEGE_NOT_HELD;
    }
    return(dwErrorCode);    
}

//  --------------------------------------------------------------------------
//  ::_ShellAcquireLogonMutex
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquire the logon mutex.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _ShellAcquireLogonMutex (void)

{
    CLogonMutex::Acquire();
}

//  --------------------------------------------------------------------------
//  ::_ShellReleaseLogonMutex
//
//  Arguments:  fSignalEvent    =   Signal completion event.
//
//  Returns:    <none>
//
//  Purpose:    Release the logon mutex. If required to signal the completion
//              event then signal it.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _ShellReleaseLogonMutex (BOOL fSignalEvent)

{
    if (fSignalEvent != FALSE)
    {
        CLogonMutex::SignalReply();
    }
    CLogonMutex::Release();
}

//  --------------------------------------------------------------------------
//  ::_ShellSignalShutdown
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Signal the shut down event to prevent further interactive
//              logon requeusts.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _ShellSignalShutdown (void)

{
    CLogonMutex::SignalShutdown();
}

//  --------------------------------------------------------------------------
//  ::_ShellStatusHostHide
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _ShellStatusHostHide (void)

{
    _Shell_LogonStatus_Hide();
}

//  --------------------------------------------------------------------------
//  ::_ShellStatusHostShow
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _ShellStatusHostShow (void)

{
    _Shell_LogonStatus_Show();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\dimmedwindow.h ===
//  --------------------------------------------------------------------------
//  Module Name: DimmedWindow.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements the dimmed window when displaying logoff / shut down
//  dialog.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _DimmedWindow_
#define     _DimmedWindow_

#include "unknwn.h"

//  --------------------------------------------------------------------------
//  CDimmedWindow::CDimmedWindow
//
//  Purpose:    Implements the dimmed window feature for the turn off dialog.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

class   CDimmedWindow : public IUnknown
{
    private:
                                            CDimmedWindow (void);
                                            CDimmedWindow (const CDimmedWindow& copyObject);
                const CDimmedWindow&        operator = (const CDimmedWindow& assignObject);
        virtual                             ~CDimmedWindow (void);
    public:
                                            CDimmedWindow (HINSTANCE hInstance);

    public:

        //  IUnknown methods

        virtual HRESULT STDMETHODCALLTYPE   QueryInterface (REFIID riid, void* *ppvObject);
        virtual ULONG   STDMETHODCALLTYPE   AddRef (void);
        virtual ULONG   STDMETHODCALLTYPE   Release (void);

                HWND                        Create (void);
                void                        SetupDim();
                BOOL                        StepDim();
                void                        Dither();
    private:
                int                         GetLowestScreenBitDepth (void)  const;
                bool                        IsForcedDimScreen (void)        const;
                bool                        IsDimScreen (void)              const;


        static  LRESULT     CALLBACK        WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    private:
                LONG                        _lReferenceCount;
                const HINSTANCE             _hInstance;
                ATOM                        _atom;
                HWND                        _hwnd;
                int                         _xVirtualScreen,
                                            _yVirtualScreen,
                                            _cxVirtualScreen,
                                            _cyVirtualScreen;
                bool                        _fDithered;
                HDC                         _hdcDimmed;
                HBITMAP                     _hbmOldDimmed;
                HBITMAP                     _hbmDimmed;
                void*                       _pvPixels;
                int                         _idxChunk;
                int                         _idxSaturation;
    private:
        static  const TCHAR                 s_szWindowClassName[];
        static  const TCHAR                 s_szExplorerKeyName[];
        static  const TCHAR                 s_szExplorerPolicyKeyName[];
        static  const TCHAR                 s_szForceDimValueName[];
};

#endif  /*  _DimmedWindow_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\externalprocess.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ExternalProcess.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle premature termination of external processes or signaling
//  of termination of an external process.
//
//  History:    1999-09-20  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2001-02-21  vtan        add PRERELEASE to DBG condition
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ExternalProcess.h"

#include "RegistryResources.h"
#include "StatusCode.h"
#include "Thread.h"
#include "TokenGroups.h"

#if         (defined(DBG) || defined(PRERELEASE))

static  const TCHAR     kNTSD[]     =   TEXT("ntsd");

#endif  /*  (defined(DBG) || defined(PRERELEASE))   */

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher
//
//  Purpose:    This is a private class (declared only by name in the header
//              file which implements the watcher thread) for the IO
//              completion port related to the job object for the external
//              process.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

class   CJobCompletionWatcher : public CThread
{
    private:
                                                CJobCompletionWatcher (void);
                                                CJobCompletionWatcher (const CJobCompletionWatcher& copyObject);
                const CJobCompletionWatcher&    operator = (const CJobCompletionWatcher& assignObject);
    public:
                                                CJobCompletionWatcher (CExternalProcess* pExternalProcess, CJob& job, HANDLE hEvent);
                                                ~CJobCompletionWatcher (void);

                void                            ForceExit (void);
    protected:
        virtual DWORD                           Entry (void);
        virtual void                            Exit (void);
    private:
                CExternalProcess                *_pExternalProcess;
                HANDLE                          _hEvent;
                HANDLE                          _hPortJobCompletion;
                bool                            _fExitLoop;
};

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher::CJobCompletionWatcher
//
//  Arguments:  pExternalProcess    =   CExternalProcess owner of this object.
//              job                 =   CJob containing the job object.
//
//  Returns:    <none>
//
//  Purpose:    Constructs the CJobCompletionWatcher object. Creates the IO
//              completion port and assigns the port into the job object.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJobCompletionWatcher::CJobCompletionWatcher (CExternalProcess *pExternalProcess, CJob& job, HANDLE hEvent) :
    CThread(),
    _pExternalProcess(pExternalProcess),
    _hEvent(hEvent),
    _hPortJobCompletion(CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 1)),
    _fExitLoop(false)

{
    pExternalProcess->AddRef();
    if (_hPortJobCompletion != NULL)
    {
        if (!NT_SUCCESS(job.SetCompletionPort(_hPortJobCompletion)))
        {
            ReleaseHandle(_hPortJobCompletion);
        }
    }
    Resume();
}

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher::~CJobCompletionWatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release the IO completion port used.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJobCompletionWatcher::~CJobCompletionWatcher (void)

{
    ReleaseHandle(_hPortJobCompletion);
}

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher::ForceExit
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Sets the internal member variable telling the watcher loop
//              to exit. This allows the context to be invalidated while the
//              thread is still active. When detected the thread will exit.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

void    CJobCompletionWatcher::ForceExit (void)

{
    _fExitLoop = true;
    if (_pExternalProcess != NULL)
    {
        _pExternalProcess->Release();
        _pExternalProcess = NULL;
    }
    TBOOL(PostQueuedCompletionStatus(_hPortJobCompletion,
                                     0,
                                     NULL,
                                     NULL));
}

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Continually poll the IO completion port waiting for process
//              exit messages. There are other messages that are ignored.
//              When the process has exited call the CExternalProcess which
//              allows it to make a decision and/or restart the external
//              process which will cause us to wait on that process.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CJobCompletionWatcher::Entry (void)

{

    //  Must have an IO completion port to work with.

    if (_hPortJobCompletion != NULL)
    {
        DWORD           dwCompletionCode;
        ULONG_PTR       pCompletionKey;
        LPOVERLAPPED    pOverlapped;

        do
        {
            if (_hEvent != NULL)
            {
                TBOOL(SetEvent(_hEvent));
                _hEvent = NULL;
            }

            //  Get the completion status on the IO waiting forever.
            //  Exit the loop if an error condition occurred.

            if ((GetQueuedCompletionStatus(_hPortJobCompletion,
                                          &dwCompletionCode,
                                          &pCompletionKey,
                                          &pOverlapped,
                                          INFINITE) != FALSE) &&
                !_fExitLoop)
            {
                switch (dwCompletionCode)
                {
                    case JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT:
                        DISPLAYMSG("JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT\r\n");
                        break;
                    case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
                        _fExitLoop = _pExternalProcess->HandleNoProcess();
                        break;
                    case JOB_OBJECT_MSG_NEW_PROCESS:
                        _pExternalProcess->HandleNewProcess(PtrToUlong(pOverlapped));
                        break;
                    case JOB_OBJECT_MSG_EXIT_PROCESS:
                    case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:
                        _pExternalProcess->HandleTermination(PtrToUlong(pOverlapped));
                        break;
                    default:
                        break;
                }
            }
            else
            {
                _fExitLoop = true;
            }
        } while (!_fExitLoop);
    }
    return(0);
}

//  --------------------------------------------------------------------------
//  CJobCompletionWatcher::Exit
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release the CExternalProcess given in the constructor so that
//              the object can actually be released (reference count drops to
//              zero).
//
//  History:    2000-05-01  vtan        created
//  --------------------------------------------------------------------------

void    CJobCompletionWatcher::Exit (void)

{
    if (_pExternalProcess != NULL)
    {
        _pExternalProcess->Release();
        _pExternalProcess = NULL;
    }
    CThread::Exit();
}

//  --------------------------------------------------------------------------
//  IExternalProcess::Start
//
//  Arguments:  pszCommandLine      =   Command line to process.
//              dwCreateFlags       =   Flags when creating process.
//              startupInfo         =   STARTUPINFO struct.
//              processInformation  =   PROCESS_INFORMATION struct.
//
//  Returns:    NTSTATUS
//
//  Purpose:    This function is the default implementation of
//              IExternalProcess::Start which starts the process in the SYSTEM
//              context of a restricted user.
//
//  History:    1999-09-20  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    IExternalProcess::Start (const TCHAR *pszCommandLine,
                                     DWORD dwCreateFlags,
                                     const STARTUPINFO& startupInfo,
                                     PROCESS_INFORMATION& processInformation)

{
    NTSTATUS    status;
    HANDLE      hTokenProcess;
    TCHAR       szCommandLine[MAX_PATH * 2];

    //  A user token is not allowed for this function. This function ALWAYS
    //  starts the process as a restricted SYSTEM context process. To start
    //  in a user context override this implementation with your own (or
    //  impersonate the user before instantiating CExternalProcess).

    lstrcpyn(szCommandLine, pszCommandLine, ARRAYSIZE(szCommandLine));
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY, &hTokenProcess) != FALSE)
    {
        HANDLE  hTokenRestricted;

        status = RemoveTokenSIDsAndPrivileges(hTokenProcess, hTokenRestricted);
        if (NT_SUCCESS(status))
        {
            TCHAR   szCommandLine[MAX_PATH];

            AllowSetForegroundWindow(ASFW_ANY);

            (TCHAR*)lstrcpyn(szCommandLine, pszCommandLine, ARRAYSIZE(szCommandLine));
            if (dwCreateFlags == 0)
            {
                dwCreateFlags = NORMAL_PRIORITY_CLASS;
            }
            if (CreateProcessAsUser(hTokenRestricted,
                                    NULL,
                                    szCommandLine,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    dwCreateFlags,
                                    NULL,
                                    NULL,
                                    const_cast<STARTUPINFO*>(&startupInfo),
                                    &processInformation) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            ReleaseHandle(hTokenRestricted);
        }
        ReleaseHandle(hTokenProcess);
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  IExternalProcess::AllowTermination
//
//  Arguments:  dwExitCode  =   Exit code of process.
//
//  Returns:    bool
//
//  Purpose:    This function returns whether external process termination is
//              allowed.
//
//  History:    2000-05-01  vtan        created
//  --------------------------------------------------------------------------

bool    IExternalProcess::AllowTermination (DWORD dwExitCode)

{
    UNREFERENCED_PARAMETER(dwExitCode);

    return(true);
}

//  --------------------------------------------------------------------------
//  IExternalProcess::SignalTermination
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    This function is invoked by the external process handler
//              when the external process terminates normally.
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    IExternalProcess::SignalTermination (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  IExternalProcess::SignalAbnormalTermination
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    This function is invoked by the external process handler
//              when the external process terminates and cannot be restarted.
//              This indicates a serious condition from which this function
//              can attempt to recover.
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    IExternalProcess::SignalAbnormalTermination (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  IExternalProcess::SignalRestart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals restart of the external process. This allows a derived
//              implementation to do something when this happens.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    IExternalProcess::SignalRestart (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  IExternalProcess::RemoveTokenSIDsAndPrivileges
//
//  Arguments:  hTokenIn    =   Token to remove SIDs and privileges from.
//              hTokenOut   =   Generated token returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Remove designated SIDs and privileges from the given token.
//              Currently this removes the local administrators SID and all
//              all privileges except SE_RESTORE_NAME. On checked builds
//              SE_DEBUG_NAME is also not removed.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    IExternalProcess::RemoveTokenSIDsAndPrivileges (HANDLE hTokenIn, HANDLE& hTokenOut)

{
    NTSTATUS            status;
    DWORD               dwFlags = 0, dwReturnLength;
    TOKEN_PRIVILEGES    *pTokenPrivileges;
    CTokenGroups        tokenGroup;

    hTokenOut = NULL;
    TSTATUS(tokenGroup.CreateAdministratorGroup());
    (BOOL)GetTokenInformation(hTokenIn, TokenPrivileges, NULL, 0, &dwReturnLength);
    pTokenPrivileges = static_cast<TOKEN_PRIVILEGES*>(LocalAlloc(LMEM_FIXED, dwReturnLength));
    if (pTokenPrivileges != NULL)
    {
        if (GetTokenInformation(hTokenIn, TokenPrivileges, pTokenPrivileges, dwReturnLength, &dwReturnLength) != FALSE)
        {
            bool    fKeepPrivilege;
            ULONG   ulCount;
            LUID    luidRestorePrivilege;
            LUID    luidChangeNotifyPrivilege;
#if         (defined(DBG) || defined(PRERELEASE))
            LUID    luidDebugPrivilege;
#endif  /*  (defined(DBG) || defined(PRERELEASE))   */

            luidRestorePrivilege.LowPart = SE_RESTORE_PRIVILEGE;
            luidRestorePrivilege.HighPart = 0;
            luidChangeNotifyPrivilege.LowPart = SE_CHANGE_NOTIFY_PRIVILEGE;
            luidChangeNotifyPrivilege.HighPart = 0;
#if         (defined(DBG) || defined(PRERELEASE))
            luidDebugPrivilege.LowPart = SE_DEBUG_PRIVILEGE;
            luidDebugPrivilege.HighPart = 0;
#endif  /*  (defined(DBG) || defined(PRERELEASE))   */

            //  Privileges kept are actually removed from the privilege array.
            //  This is because NtFilterToken will REMOVE the privileges passed
            //  in the array. Keep SE_DEBUG_NAME on checked builds.

            ulCount = 0;
            while (ulCount < pTokenPrivileges->PrivilegeCount)
            {
                fKeepPrivilege = ((RtlEqualLuid(&pTokenPrivileges->Privileges[ulCount].Luid, &luidRestorePrivilege) != FALSE) ||
                                  (RtlEqualLuid(&pTokenPrivileges->Privileges[ulCount].Luid, &luidChangeNotifyPrivilege) != FALSE));
#if         (defined(DBG) || defined(PRERELEASE))
                fKeepPrivilege = fKeepPrivilege || (RtlEqualLuid(&pTokenPrivileges->Privileges[ulCount].Luid, &luidDebugPrivilege) != FALSE);
#endif  /*  (defined(DBG) || defined(PRERELEASE))   */
                if (fKeepPrivilege)
                {
                    MoveMemory(&pTokenPrivileges->Privileges[ulCount], &pTokenPrivileges->Privileges[ulCount + 1], pTokenPrivileges->PrivilegeCount - ulCount - 1);
                    --pTokenPrivileges->PrivilegeCount;
                }
                else
                {
                    ++ulCount;
                }
            }
        }
        else
        {
            ReleaseMemory(pTokenPrivileges);
        }
    }

    if (pTokenPrivileges == NULL)
    {
        dwFlags = DISABLE_MAX_PRIVILEGE;
    }

    status = NtFilterToken(hTokenIn,
                           dwFlags,
                           const_cast<TOKEN_GROUPS*>(tokenGroup.Get()),
                           pTokenPrivileges,
                           NULL,
                           &hTokenOut);

    ReleaseMemory(pTokenPrivileges);
    return(status);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::CExternalProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CExternalProcess.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

CExternalProcess::CExternalProcess (void) :
    _hProcess(NULL),
    _dwProcessID(0),
    _dwProcessExitCode(STILL_ACTIVE),
    _dwCreateFlags(NORMAL_PRIORITY_CLASS),
    _dwStartFlags(STARTF_USESHOWWINDOW),
    _wShowFlags(SW_SHOW),
    _iRestartCount(0),
    _pIExternalProcess(NULL),
    _jobCompletionWatcher(NULL)

{
    _szCommandLine[0] = _szParameter[0] = TEXT('\0');

    //  Configure our job object. Only allow a single process to execute
    //  for this job. Restriction of UI is done by subclassing. The UIHost
    //  does not restrict UI but the screen saver does.

    TSTATUS(_job.SetActiveProcessLimit(1));
}

//  --------------------------------------------------------------------------
//  CExternalProcess::~CExternalProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CExternalProcess.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

CExternalProcess::~CExternalProcess (void)

{

    //  Force the watcher thread to exit regardless of any job object
    //  messages that come in. This will prevent it using its reference
    //  to CExternalProcess which is now being destructed. It will also
    //  prevent the external process from being started up again now
    //  that we know the external process should go away.

    if (_jobCompletionWatcher != NULL)
    {
        _jobCompletionWatcher->ForceExit();
    }

    //  If the process is still alive here then give it 100 milliseconds to
    //  terminate before forcibly terminating it.

    if (_hProcess != NULL)
    {
        DWORD   dwExitCode;

        if ((GetExitCodeProcess(_hProcess, &dwExitCode) == FALSE) || (STILL_ACTIVE == dwExitCode))
        {
            if (WaitForSingleObject(_hProcess, 100) == WAIT_TIMEOUT)
            {
                NTSTATUS    status;

                status = Terminate();

#if         (defined(DBG) || defined(PRERELEASE))

                if (ERROR_ACCESS_DENIED == GetLastError())
                {
                    status = NtCurrentTeb()->LastStatusValue;
                    if (STATUS_PROCESS_IS_TERMINATING == status)
                    {
                        status = STATUS_SUCCESS;
                    }
                }
                TSTATUS(status);

#endif  /*  (defined(DBG) || defined(PRERELEASE))   */

            }
        }
    }
    ReleaseHandle(_hProcess);
    _dwProcessID = 0;

    if (_jobCompletionWatcher != NULL)
    {
        _jobCompletionWatcher->Release();
        _jobCompletionWatcher = NULL;
    }
    if (_pIExternalProcess != NULL)
    {
        _pIExternalProcess->Release();
        _pIExternalProcess = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CExternalProcess::SetInterface
//
//  Arguments:  pIExternalProcess   =   IExternalProcess interface pointer.
//
//  Returns:    <none>
//
//  Purpose:    Store the IExternalProcess interface pointer.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

void    CExternalProcess::SetInterface (IExternalProcess *pIExternalProcess)

{
    if (_pIExternalProcess != NULL)
    {
        _pIExternalProcess->Release();
        _pIExternalProcess = NULL;
    }
    if (pIExternalProcess != NULL)
    {
        pIExternalProcess->AddRef();
    }
    _pIExternalProcess = pIExternalProcess;
}

//  --------------------------------------------------------------------------
//  CExternalProcess::GetInterface
//
//  Arguments:  <none>
//
//  Returns:    IExternalProcess*
//
//  Purpose:    Returns the IExternalProcess interface pointer. Not that the
//              caller gets a reference.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

IExternalProcess*   CExternalProcess::GetInterface (void)                     const

{
    IExternalProcess    *pIResult;

    if (_pIExternalProcess != NULL)
    {
        pIResult = _pIExternalProcess;
        pIResult->AddRef();
    }
    else
    {
        pIResult = NULL;
    }
    return(pIResult);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::SetParameter
//
//  Arguments:  pszParameter    =   String of parameter to append.
//
//  Returns:    <none>
//
//  Purpose:    Sets the parameter to append to each invokation of the
//              external process.
//
//  History:    1999-09-20  vtan        created
//  --------------------------------------------------------------------------

void    CExternalProcess::SetParameter (const TCHAR* pszParameter)

{
    if (pszParameter != NULL)
    {
        lstrcpyn(_szParameter, pszParameter, ARRAYSIZE(_szParameter));
    }
    else
    {
        _szParameter[0] = TEXT('\0');
    }
}

//  --------------------------------------------------------------------------
//  CExternalProcess::Start
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    If the external process is specified start it. If it starts
//              successfully then register a wait callback in case it
//              terminates unexpectedly so we can restart the process. This
//              ensures that the external process is always available if
//              required. If the external process cannot be started return
//              with an error.
//
//  History:    1999-09-20  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CExternalProcess::Start (void)

{
    NTSTATUS    status;

    ASSERTMSG(_pIExternalProcess != NULL, "Must call CExternalProcess::SetInterface before using CExternalProcess::Start");
    if (_szCommandLine[0] != TEXT('\0'))
    {
        STARTUPINFO             startupInfo;
        PROCESS_INFORMATION     processInformation;
        TCHAR                   szCommandLine[MAX_PATH * 2];

        lstrcpy(szCommandLine, _szCommandLine);
        lstrcat(szCommandLine, _szParameter);

        //  Start the process on Winlogon's desktop.

        ZeroMemory(&startupInfo, sizeof(startupInfo));
        startupInfo.cb = sizeof(startupInfo);
        startupInfo.lpDesktop = TEXT("WinSta0\\Winlogon");
        startupInfo.dwFlags = _dwStartFlags;
        startupInfo.wShowWindow = _wShowFlags;
        status = _pIExternalProcess->Start(szCommandLine, _dwCreateFlags | CREATE_SUSPENDED, startupInfo, processInformation);
        if (NT_SUCCESS(status))
        {

            //  The process is created suspended so that it can
            //  assigned to the job object for this object.

            TSTATUS(_job.AddProcess(processInformation.hProcess));

            //  The process is still suspended so resume the
            //  primary thread.

            if (processInformation.hThread != NULL)
            {
                (DWORD)ResumeThread(processInformation.hThread);
                TBOOL(CloseHandle(processInformation.hThread));
            }

            //  Keep the handle to the process so that we can kill
            //  it when our object goes out of scope.

            _hProcess = processInformation.hProcess;
            _dwProcessID  = processInformation.dwProcessId;

            //  Don't reallocate another CJobCompletionWatcher if
            //  one already exists. Just ignore this case.

            if (_jobCompletionWatcher == NULL)
            {
                HANDLE  hEvent;

                hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                _jobCompletionWatcher = new CJobCompletionWatcher(this, _job, hEvent);
                if ((_jobCompletionWatcher != NULL) && _jobCompletionWatcher->IsCreated() && (hEvent != NULL))
                {
                    (DWORD)WaitForSingleObject(hEvent, INFINITE);
                }
                if (hEvent != NULL)
                {
                    TBOOL(CloseHandle(hEvent));
                }
            }
        }
    }
    else
    {
        DISPLAYMSG("No external process to start in CExternalProcess::Start");
        status = STATUS_UNSUCCESSFUL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::End
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    End the process. Ends the watcher thread as well to release
//              all held references.
//
//  History:    2000-05-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CExternalProcess::End (void)

{
    if (_jobCompletionWatcher != NULL)
    {
        _jobCompletionWatcher->ForceExit();
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Terminate the process unconditionally.
//
//  History:    1999-10-14  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CExternalProcess::Terminate (void)

{
    NTSTATUS    status;

    if (TerminateProcess(_hProcess, 0) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::HandleNoProcess
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    This function restarts the external process if required. It
//              uses the IExternalProcess to communicate with the external
//              process controller to make the decisions. This function is
//              only called when the active process count drops to zero. If
//              the external process is being debugged then this will happen
//              when the debugger quits as well.
//
//  History:    1999-11-30  vtan        created
//  --------------------------------------------------------------------------

bool    CExternalProcess::HandleNoProcess (void)

{
    bool    fResult;

    fResult = true;
    NotifyNoProcess();
    if (_pIExternalProcess != NULL)
    {
        if (_pIExternalProcess->AllowTermination(_dwProcessExitCode))
        {
            TSTATUS(_pIExternalProcess->SignalTermination());
        }
        else
        {

            //  Only try to start the external process 10 times (restart
            //  it 9 times). Give up and signal abnormal termination if exceeded.

            if ((++_iRestartCount <= 9) && NT_SUCCESS(Start()))
            {
                TSTATUS(_pIExternalProcess->SignalRestart());
                fResult = false;
            }
            else
            {
                TSTATUS(_pIExternalProcess->SignalAbnormalTermination());
            }
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::HandleNewProcess
//
//  Arguments:  dwProcessID     =   Process ID of new process.
//
//  Returns:    <none>
//
//  Purpose:    This function is called by the Job object watcher when a new
//              process is added to the job. Normally this will fail because
//              of the quota limit. However, when debugging is enabled this
//              will be allowed.
//
//  History:    1999-10-27  vtan        created
//  --------------------------------------------------------------------------

void    CExternalProcess::HandleNewProcess (DWORD dwProcessID)

{
    if (_dwProcessID != dwProcessID)
    {
        ReleaseHandle(_hProcess);
        _hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
        _dwProcessID = dwProcessID;
    }
}

//  --------------------------------------------------------------------------
//  CExternalProcess::HandleTermination
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If the external process terminates unexpectedly this function
//              will be invoked by the wait callback when the process HANDLE
//              becomes signaled. It's acceptable for the process to terminate
//              if there is a dialog result so ignore this case. Otherwise
//              close the handle to the process that died and wait for the
//              job object signal that zero processes are actually running.
//              That signal will restart the process.
//
//  History:    1999-08-24  vtan        created
//              1999-09-14  vtan        factored
//  --------------------------------------------------------------------------

void    CExternalProcess::HandleTermination (DWORD dwProcessID)

{

    //  Make sure the process that is exiting is the process we are tracking.
    //  In every case other than debugging this will be true because the job
    //  object limits the active process count. In the case of debugging make
    //  sure we don't restart two processes because ntsd quit as well as the
    //  external process itself!

    if (_dwProcessID == dwProcessID)
    {
        if (GetExitCodeProcess(_hProcess, &_dwProcessExitCode) == FALSE)
        {
            _dwProcessExitCode = STILL_ACTIVE;
        }
        ReleaseHandle(_hProcess);
        _dwProcessID = 0;
    }
}

//  --------------------------------------------------------------------------
//  CExternalProcess::IsStarted
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether there is an external process that has been
//              started.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

bool    CExternalProcess::IsStarted (void)                                                                        const

{
    return(_hProcess != NULL);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::NotifyNoProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Derivable function for notification of process termination.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

void    CExternalProcess::NotifyNoProcess (void)

{
}

//  --------------------------------------------------------------------------
//  CExternalProcess::AdjustForDebugging
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Adjusts the job object to allow debugging of the external
//              process.
//
//  History:    1999-10-22  vtan        created
//  --------------------------------------------------------------------------

void    CExternalProcess::AdjustForDebugging (void)

{

#if         (defined(DBG) || defined(PRERELEASE))

    //  If it looks like the external process is being debugged
    //  then lift the process restriction to allow it to be debugged.

    if (IsBeingDebugged())
    {
        _job.SetActiveProcessLimit(0);
    }

#endif  /*  (defined(DBG) || defined(PRERELEASE))   */

}

#if         (defined(DBG) || defined(PRERELEASE))

//  --------------------------------------------------------------------------
//  CExternalProcess::IsBeingDebugged
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the external process will end up being started
//              under a debugger.
//
//  History:    2000-10-04  vtan        created
//  --------------------------------------------------------------------------

bool    CExternalProcess::IsBeingDebugged (void)                  const

{
    return(IsPrefixedWithNTSD() || IsImageFileExecutionDebugging());
}

//  --------------------------------------------------------------------------
//  CExternalProcess::IsPrefixedWithNTSD
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the command line starts with "ntsd".
//
//  History:    1999-10-25  vtan        created
//  --------------------------------------------------------------------------

bool    CExternalProcess::IsPrefixedWithNTSD (void)               const

{

    //  Is the command line prefixed with "ntsd"?

    return(CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, _szCommandLine, 4, kNTSD, 4) == CSTR_EQUAL);
}

//  --------------------------------------------------------------------------
//  CExternalProcess::IsImageFileExecutionDebugging
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the system is set to debug this particular
//              executable file via "Image File Execution Options".
//
//  History:    1999-10-25  vtan        created
//  --------------------------------------------------------------------------

bool    CExternalProcess::IsImageFileExecutionDebugging (void)    const

{
    bool    fResult;
    TCHAR   *pC, *pszFilePart;
    TCHAR   szCommandLine[MAX_PATH], szExecutablePath[MAX_PATH];

    fResult = false;

    //  Make a copy of the command line. Find the first space character
    //  or the end of the string and NULL terminate it. This does NOT
    //  check for quotes!

    lstrcpy(szCommandLine, _szCommandLine);
    pC = szCommandLine;
    while ((*pC != TEXT(' ')) && (*pC != TEXT('\0')))
    {
        ++pC;
    }
    *pC++ = TEXT('\0');
    if (SearchPath(NULL, szCommandLine, TEXT(".exe"), ARRAYSIZE(szExecutablePath), szExecutablePath, &pszFilePart) != 0)
    {
        LONG        errorCode;
        TCHAR       szImageKey[MAX_PATH];
        CRegKey     regKey;

        //  Open the associated "Image File Execution Options" key.

        lstrcpy(szImageKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\"));
        lstrcat(szImageKey, pszFilePart);
        errorCode = regKey.Open(HKEY_LOCAL_MACHINE, szImageKey, KEY_READ);
        if (ERROR_SUCCESS == errorCode)
        {

            //  Read the "Debugger" value.

            errorCode = regKey.GetString(TEXT("Debugger"), szCommandLine, ARRAYSIZE(szCommandLine));
            if (ERROR_SUCCESS == errorCode)
            {

                //  Look for "ntsd".

                fResult = (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szCommandLine, 4, kNTSD, 4) == CSTR_EQUAL);
            }
        }
    }
    return(fResult);
}

#endif  /*  (defined(DBG) || defined(PRERELEASE))   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logonstatus.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CWLogonStatus.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that contains implementation for status UI hosting by an external
//  process.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include <msginaexports.h>

#include "Access.h"
#include "GinaIPC.h"
#include "LogonWait.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "SystemSettings.h"
#include "UIHost.h"

//  --------------------------------------------------------------------------
//  CLogonStatus
//
//  Purpose:    C++ class to handle logon status external process for consumer
//              windows.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

class   CLogonStatus : public ILogonExternalProcess
{
    private:
                                    CLogonStatus (void);
    public:
                                    CLogonStatus (const TCHAR *pszParameter);
                                    ~CLogonStatus (void);

                NTSTATUS            Start (bool fWait);
                CUIHost*            GetUIHost (void);
        static  bool                IsStatusWindow (HWND hwnd);

                bool                WaitForUIHost (void);
                void                ShowStatusMessage (const WCHAR *pszMessage);
                void                SetStateStatus (int iCode);
                void                SetStateLogon (int iCode);
                void                SetStateLoggedOn (void);
                void                SetStateHide (void);
                void                SetStateEnd (bool fSendMessage);
                void                NotifyWait (void);
                void                NotifyNoAnimations (void);
                void                SelectUser (const WCHAR *pszUsername, const WCHAR *pszDomain);
                void                InteractiveLogon (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
                HANDLE              ResetReadyEvent (void);
                bool                IsSuspendAllowed (void)     const;
                void                ShowUIHost (void);
                void                HideUIHost (void);
                bool                IsUIHostHidden (void)   const;
    public:
        virtual bool                AllowTermination (DWORD dwExitCode);
        virtual NTSTATUS            SignalAbnormalTermination (void);
        virtual NTSTATUS            SignalRestart (void);
        virtual NTSTATUS            LogonRestart (void);
    private:
                bool                IsUIHostReady (void)    const;
                void                SendToUIHost (WPARAM wParam, LPARAM lParam);
                void                UIHostReadySignal (void);
        static  void    CALLBACK    CB_UIHostReadySignal (void *pV, BOOLEAN fTimerOrWaitFired);
        static  void    CALLBACK    CB_UIHostAbnormalTermination (ULONG_PTR dwParam);
    private:
                DWORD               _dwThreadID;
                bool                _fRegisteredWait;
                HANDLE              _hEvent;
                HANDLE              _hWait;
                int                 _iState,
                                    _iCode,
                                    _iStatePending;
                WPARAM              _waitWPARAM;
                LPARAM              _waitLPARAM;
                CUIHost*            _pUIHost;
                CLogonWait          _logonWait;
};

CCriticalSection*   g_pLogonStatusLock  =   NULL;
CLogonStatus*       g_pLogonStatus      =   NULL;

//  --------------------------------------------------------------------------
//  CLogonStatus::CLogonStatus
//
//  Arguments:  pszParameter    =   Parameter to pass to status UI host.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CLogonStatus. This gets the status UI host
//              from the registry and assigns the given parameter into the
//              object. Create a named event which SHGINA knows about and
//              will signal once the ILogonStatusHost class has been
//              instantiated.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

CLogonStatus::CLogonStatus (const TCHAR *pszParameter) :
    _dwThreadID(0),
    _fRegisteredWait(false),
    _hEvent(NULL),
    _hWait(NULL),
    _iState(UI_STATE_STATUS),
    _iCode(0),
    _iStatePending(0),
    _waitWPARAM(0),
    _waitLPARAM(0),
    _pUIHost(NULL)

{
    TCHAR   szRawHostCommandLine[MAX_PATH];

    if (ERROR_SUCCESS == CSystemSettings::GetUIHost(szRawHostCommandLine))
    {
        _pUIHost = new CUIHost(szRawHostCommandLine);
        if (_pUIHost != NULL)
        {
            _pUIHost->SetInterface(this);
            _pUIHost->SetParameter(pszParameter);
        }
    }

    SECURITY_ATTRIBUTES     securityAttributes;

    //  Build a security descriptor for the event that allows:
    //      S-1-5-18        EVENT_ALL_ACCESS
    //      S-1-5-32-544    SYNCHRONIZE | READ_CONTROL | EVENT_QUERY_STATE

    static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority       =   SECURITY_NT_AUTHORITY;

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            EVENT_ALL_ACCESS
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            SYNCHRONIZE | READ_CONTROL | EVENT_QUERY_STATE
        }
    };

    securityAttributes.nLength = sizeof(securityAttributes);
    securityAttributes.lpSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    securityAttributes.bInheritHandle = FALSE;
    _hEvent = CreateEvent(&securityAttributes, TRUE, FALSE, TEXT("msgina: StatusHostReadyEvent"));
    ReleaseMemory(securityAttributes.lpSecurityDescriptor);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::~CLogonStatus
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CLogonStatus. Releases references.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

CLogonStatus::~CLogonStatus (void)

{
    ASSERTMSG(_hWait == NULL, "Resend wait object not released in CLogonStatus::~CLogonStatus");
    ReleaseHandle(_hEvent);
    ASSERTMSG(_iState == UI_STATE_END, "State must be UI_STATE_END in CLogonStatus::~CLogonStatus");
    if (_pUIHost != NULL)
    {
        _pUIHost->Release();
        _pUIHost = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatus::Start
//
//  Arguments:  fWait   =   Wait for status host to signal ready.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Starts the status UI host. Don't wait for the UI host. There
//              is a mechanism that can queue a message if the UI host window
//              cannot be found.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonStatus::Start (bool fWait)

{
    NTSTATUS    status;

    if (_pUIHost != NULL)
    {
        (HANDLE)ResetReadyEvent();
        status = _pUIHost->Start();
        if (NT_SUCCESS(status))
        {
            _dwThreadID = GetCurrentThreadId();
            if (fWait || _pUIHost->WaitRequired())
            {
                if (!WaitForUIHost())
                {
                    status = STATUS_UNSUCCESSFUL;
                }
            }
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::GetUIHost
//
//  Arguments:  <none>
//
//  Returns:    CUIHost*
//
//  Purpose:    Returns a reference to the UIHost object held internally.
//              The reference belongs to the caller and must be released.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

CUIHost*    CLogonStatus::GetUIHost (void)

{
    if (_pUIHost != NULL)
    {
        _pUIHost->AddRef();
    }
    return(_pUIHost);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::IsStatusWindow
//
//  Arguments:  hwnd    =   HWND to check.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given HWND is the status window.
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::IsStatusWindow (HWND hwnd)

{
    TCHAR   szWindowClass[256];

    return((GetClassName(hwnd, szWindowClass, ARRAYSIZE(szWindowClass)) != 0) &&
           (lstrcmpi(STATUS_WINDOW_CLASS_NAME, szWindowClass) == 0));
}

//  --------------------------------------------------------------------------
//  CLogonStatus::WaitForUIHost
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Waits on the named event that the UI host signals when it's
//              initialized. Typically this happens very quickly but we don't
//              wait on it when starting up the UI host.
//
//  History:    2000-09-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::WaitForUIHost (void)

{
    bool    fResult;

    fResult = true;
    ASSERTMSG(_hEvent != NULL, "No UI host named event to wait on in CLogonStatus::WaitForUIHost");
    if (!IsUIHostReady())
    {
        DWORD   dwWaitResult;

#ifdef      DBG
        DWORD   dwWaitStart, dwWaitEnd;

        dwWaitStart = (WAIT_TIMEOUT == WaitForSingleObject(_hEvent, 0)) ? GetTickCount() : 0;
#endif  /*  DBG     */
        do
        {
            dwWaitResult = WaitForSingleObject(_hEvent, 0);
            if (dwWaitResult != WAIT_OBJECT_0)
            {
                dwWaitResult = MsgWaitForMultipleObjectsEx(1, &_hEvent, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE);
                if (dwWaitResult == WAIT_OBJECT_0 + 1)
                {
                    MSG     msg;

                    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
                    {
                        (BOOL)TranslateMessage(&msg);
                        (LRESULT)DispatchMessage(&msg);
                    }
                }
             }
        } while ((dwWaitResult == WAIT_OBJECT_0 + 1) && (dwWaitResult != WAIT_IO_COMPLETION));
#ifdef      DBG
        dwWaitEnd = GetTickCount();
        if ((dwWaitStart != 0) && ((dwWaitEnd - dwWaitStart) != 0))
        {
            char    szBuffer[256];

            wsprintfA(szBuffer, "waited %d ticks for UI host", dwWaitEnd - dwWaitStart);
            INFORMATIONMSG(szBuffer);
        }
#endif  /*  DBG     */
        fResult = (dwWaitResult != WAIT_IO_COMPLETION);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::ShowStatusMessage
//
//  Arguments:  pszMessage  =   Unicode string message to display.
//
//  Returns:    <none>
//
//  Purpose:    Tells the UI host to display the given string message. Puts
//              the string directly inside the status host process and tells
//              the process where in its address space to find the string.
//              The string is limited to 256 characters.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::ShowStatusMessage (const WCHAR *pszMessage)

{
    if (NT_SUCCESS(_pUIHost->PutString(pszMessage)))
    {
        SendToUIHost(UI_DISPLAY_STATUS, reinterpret_cast<LONG_PTR>(_pUIHost->GetDataAddress()));
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SetStateStatus
//
//  Arguments:  iCode   =   Magic code number for lock.
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to go into status state.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SetStateStatus (int iCode)

{
    _iStatePending = UI_STATE_STATUS;
    if (WaitForUIHost() && (_iState != UI_STATE_STATUS))
    {
        SendToUIHost(UI_STATE_STATUS, iCode);
        _iState = UI_STATE_STATUS;
        _iCode = iCode;
    }
    _iStatePending = UI_STATE_NONE;
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SetStateLogon
//
//  Arguments:  iCode   =   Magic code number for lock.
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to go into logon state.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SetStateLogon (int iCode)

{
    _iStatePending = UI_STATE_LOGON;
    if (WaitForUIHost() && (iCode == _iCode))
    {
        SendToUIHost(UI_STATE_LOGON, iCode);
        _iState = UI_STATE_LOGON;
        _iCode = 0;
    }
    _iStatePending = UI_STATE_NONE;
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SetStateLoggedOn
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to go into logged on state.
//
//  History:    2000-05-24  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SetStateLoggedOn (void)

{
    _iStatePending = UI_STATE_STATUS;
    if (WaitForUIHost())
    {
        SendToUIHost(UI_STATE_LOGGEDON, 0);
        _iState = UI_STATE_STATUS;
    }
    _iStatePending = UI_STATE_NONE;
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SetStateHide
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to hide itself.
//
//  History:    2001-01-08  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SetStateHide (void)

{
    _iStatePending = UI_STATE_HIDE;
    if (WaitForUIHost())
    {
        SendToUIHost(UI_STATE_HIDE, 0);
        _iState = UI_STATE_HIDE;
    }
    _iStatePending = UI_STATE_NONE;
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SetStateEnd
//
//  Arguments:  fSendMessage    =   Send message to UI host or not.
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to end and terminate itself.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SetStateEnd (bool fSendMessage)

{
    bool    fHostAlive;
    HANDLE  hWait;

    _iStatePending = UI_STATE_END;

    //  When going into end mode if there's a wait registered then
    //  unregister it. This will release an outstanding reference.
    //  A re-register should never happen but this is set just in case.

    _fRegisteredWait = true;
    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        if (UnregisterWait(hWait) != FALSE)
        {
            Release();
        }
    }
    if (fSendMessage)
    {
        fHostAlive = WaitForUIHost();
    }
    else
    {
        fHostAlive = true;
    }
    if (fHostAlive)
    {
        if (_pUIHost != NULL)
        {
            _pUIHost->SetInterface(NULL);
        }
        if (fSendMessage)
        {
            SendToUIHost(UI_STATE_END, 0);
        }
        _iState = UI_STATE_END;
    }
    _iStatePending = UI_STATE_NONE;
}

//  --------------------------------------------------------------------------
//  CLogonStatus::NotifyWait
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to display a title that the system
//              is shutting down.
//
//  History:    2000-07-14  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::NotifyWait (void)

{
    SendToUIHost(UI_NOTIFY_WAIT, 0);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::NotifyNoAnimations
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to no longer perform animations.
//
//  History:    2001-03-21  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::NotifyNoAnimations (void)

{
    SendToUIHost(UI_SET_ANIMATIONS, 0);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SelectUser
//
//  Arguments:  pszUsername     =   User name to select.
//
//  Returns:    <none>
//
//  Purpose:    Tells the status UI host to select the user by the given
//              logon name.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::SelectUser (const WCHAR *pszUsername, const WCHAR *pszDomain)

{
    LOGONIPC_USERID     logonIPC;

    (WCHAR*)lstrcpyW(logonIPC.wszUsername, pszUsername);
    (WCHAR*)lstrcpyW(logonIPC.wszDomain, pszDomain);
    if (NT_SUCCESS(_pUIHost->PutData(&logonIPC, sizeof(logonIPC))))
    {
        SendToUIHost(UI_SELECT_USER, reinterpret_cast<LONG_PTR>(_pUIHost->GetDataAddress()));
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatus::InteractiveLogon
//
//  Arguments:  pszUsername     =   Username to logon.
//              pszDomain       =   Domain to logon.
//              pszPassword     =   Password to use.
//
//  Returns:    <none>
//
//  Purpose:    Tell the status host to log the specified user on.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::InteractiveLogon (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    (WCHAR*)lstrcpyW(logonIPCCredentials.userID.wszUsername, pszUsername);
    (WCHAR*)lstrcpyW(logonIPCCredentials.userID.wszDomain, pszDomain);
    (WCHAR*)lstrcpyW(logonIPCCredentials.wszPassword, pszPassword);
    ZeroMemory(pszPassword, (lstrlenW(pszPassword) + sizeof('\0'))* sizeof(WCHAR));
    if (NT_SUCCESS(_pUIHost->PutData(&logonIPCCredentials, sizeof(logonIPCCredentials))))
    {
        SendToUIHost(UI_INTERACTIVE_LOGON, reinterpret_cast<LONG_PTR>(_pUIHost->GetDataAddress()));
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatus::ResetReadyEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Reset the UI host ready event. A new instance will set this
//              event. Use this in UI host failure.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonStatus::ResetReadyEvent (void)

{
    TBOOL(ResetEvent(_hEvent));
    return(_hEvent);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::IsSuspendAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the UI host allows suspending of the computer.
//              This is true if in the logon state or in the status (locked)
//              state.
//
//  History:    2000-08-21  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::IsSuspendAllowed (void)     const

{
    return(((_iState == UI_STATE_STATUS) && (_iCode != 0)) ||
           (_iStatePending == UI_STATE_LOGON) ||
           (_iState == UI_STATE_LOGON) ||
           (_iState == UI_STATE_HIDE));
}

//  --------------------------------------------------------------------------
//  CLogonStatus::ShowUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the UI host.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::ShowUIHost (void)

{
    _pUIHost->Show();
}

//  --------------------------------------------------------------------------
//  CLogonStatus::HideUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Hides the UI host.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::HideUIHost (void)

{
    _pUIHost->Hide();
}

//  --------------------------------------------------------------------------
//  CLogonStatus::IsUIHostHidden
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Returns whether the UI host is hidden.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::IsUIHostHidden (void)   const

{
    return(_pUIHost->IsHidden());
}

//  --------------------------------------------------------------------------
//  CLogonStatus::AllowTermination
//
//  Arguments:  dwExitCode  =   Exit code of host process.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the host process is allowed to terminate
//              given the exit code passed in.
//
//              Currently the host process is not allowed to terminate.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::AllowTermination (DWORD dwExitCode)

{
    UNREFERENCED_PARAMETER(dwExitCode);

    return(false);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SignalAbnormalTermination
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles abnormal termination of host process.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonStatus::SignalAbnormalTermination (void)

{
    HANDLE  hThread;

    TSTATUS(_logonWait.Cancel());
    hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, _dwThreadID);
    if (hThread != NULL)
    {
        (BOOL)QueueUserAPC(CB_UIHostAbnormalTermination, hThread, reinterpret_cast<ULONG_PTR>(this));
        TBOOL(CloseHandle(hThread));
    }
    _Shell_LogonStatus_Destroy(HOST_END_FAILURE);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SignalRestart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Function to reset the ready event and set the UI host into
//              status state. This is invoked when the UI host is restarted
//              after a failure.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonStatus::SignalRestart (void)

{
    (HANDLE)ResetReadyEvent();
    return(_logonWait.Register(_hEvent, this));
}

//  --------------------------------------------------------------------------
//  CLogonStatus::LogonRestart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    
//
//  History:    2001-02-21  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonStatus::LogonRestart (void)

{
    SetStateStatus(0);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::IsUIHostReady
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the UI host is ready.
//
//  History:    2000-09-11  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatus::IsUIHostReady (void)    const

{
    ASSERTMSG(_hEvent != NULL, "No UI host named event to wait on in CLogonStatus::IsUIHostReady");
    return(WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0));
}

//  --------------------------------------------------------------------------
//  CLogonStatus::SendToUIHost
//
//  Arguments:  wParam  =   WPARAM to send to UI host.
//              lParam  =   LPARAM to send to UI host.
//
//  Returns:    <none>
//
//  Purpose:    Finds the status window created by SHGINA and sends the
//              message to it. That window turns around and sends the message
//              to the UI host. This allows communication implemenation method
//              to change without forcing the UI host to be rebuilt.
//
//  History:    2000-05-11  vtan        created
//              2000-09-11  vtan        uses PostMessage not SendMessage
//  --------------------------------------------------------------------------

void    CLogonStatus::SendToUIHost (WPARAM wParam, LPARAM lParam)

{
    HWND hwnd;

    if (IsUIHostReady())
    {
        hwnd = FindWindow(STATUS_WINDOW_CLASS_NAME, NULL);
    }
    else
    {
        hwnd = NULL;
    }

    if (hwnd != NULL)
    {
        HANDLE  hWait;

        //  Don't allow any registrations if we've found it.

        _fRegisteredWait = true;
        hWait = InterlockedExchangePointer(&_hWait, NULL);
        if (hWait != NULL)
        {
            if (UnregisterWait(hWait) != FALSE)
            {

                //  If sucesssfully releasing the hWait we need to call release.

                Release();
            }
        }
        TBOOL(PostMessage(hwnd, WM_UISERVICEREQUEST, wParam, lParam));
    }
    else if (!_fRegisteredWait)
    {

        //  Cannot find the UI host window. It's probably still getting
        //  its act together. Queue this post message for a callback when
        //  the event is signaled if a register has not already been
        //  made. If one has then just change the parameters.
        //  Add a reference here. The callback will release it. If the
        //  register on the wait failed the release the reference.

        if (_hWait == NULL)
        {
            HANDLE  hWait;

            AddRef();
            if (RegisterWaitForSingleObject(&hWait,
                                            _hEvent,
                                            CB_UIHostReadySignal,
                                            this,
                                            INFINITE,
                                            WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE) != FALSE)
            {
                if (InterlockedCompareExchangePointer(&_hWait, hWait, NULL) == NULL)
                {
                    _fRegisteredWait = true;
                }
                else
                {

                    //  Someone else beat us to registering (should never happen)

                    (BOOL)UnregisterWait(hWait);
                    Release();
                }
            }
            else
            {
                Release();
            }
        }
        _waitWPARAM = wParam;
        _waitLPARAM = lParam;
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatus::UIHostReadySignal
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Callback invoked when the UI host signals it's ready. This
//              function unregisters the wait and resend the status message
//              to the UI host.
//
//  History:    2000-09-10  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatus::UIHostReadySignal (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        TBOOL(UnregisterWait(hWait));
    }
    SendToUIHost(_waitWPARAM, _waitLPARAM);
}

//  --------------------------------------------------------------------------
//  CLogonStatus::CB_UIHostReadySignal
//
//  Arguments:  See the platform SDK under WaitOrTimerCallback.
//
//  Returns:    <none>
//
//  Purpose:    Callback entry point for registered event wait.
//
//  History:    2000-09-10  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CLogonStatus::CB_UIHostReadySignal (void *pV, BOOLEAN fTimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(fTimerOrWaitFired);

    CLogonStatus    *pThis;

    pThis = reinterpret_cast<CLogonStatus*>(pV);
    if (pThis != NULL)
    {
        pThis->UIHostReadySignal();
    }
    pThis->Release();
}

//  --------------------------------------------------------------------------
//  CLogonStatus::CB_UIHostAbnormalTermination
//
//  Arguments:  See the platform SDK under APCProc.
//
//  Returns:    <none>
//
//  Purpose:    Callback entry point for queued APC on abnormal termination.
//
//  History:    2001-02-19  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CLogonStatus::CB_UIHostAbnormalTermination (ULONG_PTR dwParam)

{
    UNREFERENCED_PARAMETER(dwParam);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initialize the critical section for g_pLogonStatus.
//
//  History:    2001-06-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticInitialize (void)

{
    NTSTATUS    status;

    ASSERTMSG(g_pLogonStatusLock == NULL, "g_pLogonStatusLock already exists in _Shell_LogonStatus_StaticInitialize");
    g_pLogonStatusLock = new CCriticalSection;
    if (g_pLogonStatusLock != NULL)
    {
        status = g_pLogonStatusLock->Status();
        if (!NT_SUCCESS(status))
        {
            delete g_pLogonStatusLock;
            g_pLogonStatusLock = NULL;
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Delete the critical section for g_pLogonStatus.
//
//  History:    2001-06-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticTerminate (void)

{
    if (g_pLogonStatusLock != NULL)
    {
        delete g_pLogonStatusLock;
        g_pLogonStatusLock = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_Init
//
//  Arguments:  uiStartType     =   Start mode of status host.
//
//  Returns:    <none>
//
//  Purpose:    Creates the instance of CLogonStatus telling it to pass
//              "/status" as the parameter to the UI host. It then starts
//              the host if the object was created.
//
//              The object is held globally.
//
//  History:    2000-05-11  vtan        created
//              2000-07-13  vtan        add shutdown parameter.
//              2000-07-17  vtan        changed to start type parameter.
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_Init (UINT uiStartType)

{
    bool    fIsRemote, fIsSessionZero;

    fIsRemote = (GetSystemMetrics(SM_REMOTESESSION) != 0);
    fIsSessionZero = (NtCurrentPeb()->SessionId == 0);
    if ((!fIsRemote || fIsSessionZero || CSystemSettings::IsForceFriendlyUI()) && CSystemSettings::IsFriendlyUIActive())
    {
        bool    fWait;
        TCHAR   szParameter[256];

        if (g_pLogonStatusLock != NULL)
        {
            g_pLogonStatusLock->Acquire();
            if (g_pLogonStatus == NULL)
            {
                (TCHAR*)lstrcpy(szParameter, TEXT(" /status"));
                if (HOST_START_SHUTDOWN == uiStartType)
                {
                    (TCHAR*)lstrcat(szParameter, TEXT(" /shutdown"));
                    fWait = true;
                }
                else if (HOST_START_WAIT == uiStartType)
                {
                    (TCHAR*)lstrcat(szParameter, TEXT(" /wait"));
                    fWait = true;
                }
                else
                {
                    fWait = false;
                }
                g_pLogonStatus = new CLogonStatus(szParameter);
                if (g_pLogonStatus != NULL)
                {
                    NTSTATUS    status;

                    g_pLogonStatusLock->Release();
                    status = g_pLogonStatus->Start(fWait);
                    g_pLogonStatusLock->Acquire();
                    if (!NT_SUCCESS(status) && (g_pLogonStatus != NULL))
                    {
                        g_pLogonStatus->Release();
                        g_pLogonStatus = NULL;
                    }
                }
            }
            else
            {
                g_pLogonStatus->SetStateStatus(0);
                if ((HOST_START_SHUTDOWN == uiStartType) || (HOST_START_WAIT == uiStartType))
                {
                    g_pLogonStatus->NotifyWait();
                }
            }
            g_pLogonStatusLock->Release();
        }
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_Destroy
//
//  Arguments:  uiEndType   =   End mode of status host.
//
//  Returns:    <none>
//
//  Purpose:    If the end type is hide then tell the status host to hide.
//              Otherwise check the end type is terminate. In that case tell
//              the status host to go away.
//
//  History:    2000-05-11  vtan        created
//              2001-01-09  vtan        add end parameter
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_Destroy (UINT uiEndType)

{
    if (g_pLogonStatusLock != NULL)
    {
        CSingleThreadedExecution    lock(*g_pLogonStatusLock);

        if (g_pLogonStatus != NULL)
        {
            switch (uiEndType)
            {
                case HOST_END_HIDE:

                    //  HOST_END_HIDE: Is the UI host static? If so then hide it.
                    //  Otherwise revert to start/stop mode (dynamic) and force the
                    //  UI host to terminate.

                    if (CSystemSettings::IsUIHostStatic())
                    {
                        g_pLogonStatus->SetStateHide();
                        break;
                    }
                    uiEndType = HOST_END_TERMINATE;

                    //  If the the host is dynamic then set the type to
                    //  HOST_END_TERMINATE and fall thru to this case so that
                    //  the host is told to end.

                case HOST_END_TERMINATE:

                    //  HOST_END_TERMINATE: Force the UI host to terminate. This is
                    //  used in circumstances where it must terminate such as we
                    //  are terminating or the machine is shutting down.

                    g_pLogonStatus->SetStateEnd(true);
                    break;
                case HOST_END_FAILURE:

                    //  HOST_END_FAILURE: This is sent when the UI host failed to
                    //  start and will not be restarted. This allows the interface
                    //  reference to be deleted so that object reference count
                    //  will reach zero and the memory will be released.

                    g_pLogonStatus->SetStateEnd(false);
                    uiEndType = HOST_END_TERMINATE;
                    break;
                default:
                    DISPLAYMSG("Unknown uiEndType passed to _Shell_LogonStatus_Destroy");
                    break;
            }
            if (HOST_END_TERMINATE == uiEndType)
            {
                g_pLogonStatus->Release();
                g_pLogonStatus = NULL;
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_Exists
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether there is status host created.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonStatus_Exists (void)

{
    return(g_pLogonStatus != NULL);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_IsStatusWindow
//
//  Arguments:  hwnd    =   HWND to check.
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the given HWND is the status HWND.
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonStatus_IsStatusWindow (HWND hwnd)

{
    return(CLogonStatus::IsStatusWindow(hwnd));
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_IsSuspendAllowed
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Ask the status host (if present) if suspend is allowed.
//
//  History:    2000-08-18  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonStatus_IsSuspendAllowed (void)

{
    return((g_pLogonStatus == NULL) || g_pLogonStatus->IsSuspendAllowed());
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_WaitforUIHost
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to force the current thread to wait
//              until the UI host signals it's ready. Returns whether the
//              wait was successful or abandoned. Success is true. Abandoned
//              or non-existant is false.
//
//  History:    2000-09-10  vtan        created
//              2001-02-19  vtan        added return result
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonStatus_WaitForUIHost (void)

{
    return((g_pLogonStatus != NULL) && g_pLogonStatus->WaitForUIHost());
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_ShowStatusMessage
//
//  Arguments:  pszMessage  =   Unicode string to display.
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to pass display string to status host.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_ShowStatusMessage (const WCHAR *pszMessage)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->ShowStatusMessage(pszMessage);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SetStateStatus
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to go to status
//              state.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SetStateStatus (int iCode)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SetStateStatus(iCode);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SetStateLogon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to go to logon
//              state.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SetStateLogon (int iCode)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SetStateLogon(iCode);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SetStateLoggedOn
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to go to
//              logged on state.
//
//  History:    2000-05-24  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SetStateLoggedOn (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SetStateLoggedOn();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SetStateHide
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to hide itself.
//
//  History:    2001-01-08  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SetStateHide (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SetStateHide();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SetStateEnd
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to terminate.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SetStateEnd (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SetStateEnd(true);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_NotifyWait
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to display a
//              title stating the system is preparing to shut down.
//
//  History:    2000-07-14  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_NotifyWait (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->NotifyWait();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_NotifyNoAnimations
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to no longer
//              perform animations.
//
//  History:    2001-03-21  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_NotifyNoAnimations (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->NotifyNoAnimations();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_SelectUser
//
//  Arguments:  pszUsername     =   Username to select.
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to select a
//              specific user as being logged on.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_SelectUser (const WCHAR *pszUsername, const WCHAR *pszDomain)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->SelectUser(pszUsername, pszDomain);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_InteractiveLogon
//
//  Arguments:  pszUsername     =   Username to logon.
//              pszDomain       =   Domain to logon.
//              pszPassword     =   Password to use.
//
//  Returns:    <none>
//
//  Purpose:    External C entry point to tell the status host to log the
//              specified user on.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonStatus_InteractiveLogon (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->InteractiveLogon(pszUsername, pszDomain, pszPassword);
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_GetUIHost
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    External C entry point that returns a reference to the UI
//              host object. This is returned as a void* because C doesn't
//              understand C++ objects. The void* is cast to the appropriate
//              type for use in CWLogonDialog.cpp so that it doesn't go and
//              create a new instance of the object but increments the
//              reference to this already existing object.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void*   _Shell_LogonStatus_GetUIHost (void)

{
    void    *pResult;

    if (g_pLogonStatus != NULL)
    {
        pResult = g_pLogonStatus->GetUIHost();
    }
    else
    {
        pResult = NULL;
    }
    return(pResult);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_ResetReadyEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Resets the ready event in case of UI host failure.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HANDLE  _Shell_LogonStatus_ResetReadyEvent (void)

{
    HANDLE  hEvent;

    if (g_pLogonStatus != NULL)
    {
        hEvent = g_pLogonStatus->ResetReadyEvent();
    }
    else
    {
        hEvent = NULL;
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_Show
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the UI host.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Shell_LogonStatus_Show (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->ShowUIHost();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_Hide
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Hides the UI host.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Shell_LogonStatus_Hide (void)

{
    if (g_pLogonStatus != NULL)
    {
        g_pLogonStatus->HideUIHost();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonStatus_IsHidden
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Returns whether the UI host is hidden.
//
//  History:    2001-03-05  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        _Shell_LogonStatus_IsHidden (void)

{
    return((g_pLogonStatus != NULL) && g_pLogonStatus->IsUIHostHidden());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\init.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CWInit.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  C header file that contains function prototypes that contain
//  initialization for consumer windows functionality.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include <LPCFUS.h>
#include <LPCThemes.h>
#include <msginaexports.h>

#include "Compatibility.h"
#include "CredentialTransfer.h"
#include "Impersonation.h"
#include "LogonMutex.h"
#include "ReturnToWelcome.h"
#include "SpecialAccounts.h"
#include "SystemSettings.h"
#include "TokenGroups.h"

//  --------------------------------------------------------------------------
//  ::_Shell_DllMain
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initialize anything that needs initializing in DllMain.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_DllMain (HINSTANCE hInstance, DWORD dwReason)

{
    UNREFERENCED_PARAMETER(hInstance);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
#ifdef  DBG
            TSTATUS(CDebug::StaticInitialize());
#endif
            TSTATUS(CImpersonation::StaticInitialize());
            TSTATUS(CTokenGroups::StaticInitialize());
            break;
        case DLL_PROCESS_DETACH:
            TSTATUS(CTokenGroups::StaticTerminate());
            TSTATUS(CImpersonation::StaticTerminate());
#ifdef  DBG
            TSTATUS(CDebug::StaticTerminate());
            break;
#endif
        default:
            break;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_Initialize
//
//  Arguments:  pWlxContext     =   Winlogon's context for callbacks.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes any static information that needs to be to use
//              certain classes. These functions exist because of the need to
//              not depend on static object from being constructed.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_Initialize (void *pWlxContext)

{
    TSTATUS(CSystemSettings::CheckDomainMembership());
    TSTATUS(CCredentials::StaticInitialize(true));
    TSTATUS(CReturnToWelcome::StaticInitialize(pWlxContext));
    CLogonMutex::StaticInitialize();
    TSTATUS(_Shell_LogonStatus_StaticInitialize());
    TSTATUS(_Shell_LogonDialog_StaticInitialize());
    TSTATUS(CCompatibility::StaticInitialize());
    (DWORD)ThemeWaitForServiceReady(1000);
    (BOOL)ThemeWatchForStart();
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release any memory/resources used by the static initialization
//              of objects. This usually won't matter because this function
//              is called when the system or process is closing down.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_Terminate (void)

{
    TSTATUS(CCompatibility::StaticTerminate());
    TSTATUS(_Shell_LogonDialog_StaticTerminate());
    TSTATUS(_Shell_LogonStatus_StaticTerminate());
    CLogonMutex::StaticTerminate();
    TSTATUS(CReturnToWelcome::StaticTerminate());
    TSTATUS(CCredentials::StaticTerminate());
    TSTATUS(CSystemSettings::CheckDomainMembership());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_Reconnect
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Notification of session reconnect.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_Reconnect (void)

{
    CCompatibility::RestoreWindowsOnReconnect();
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_Disconnect
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Notification of session disconnect.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_Disconnect (void)

{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logonmutex.h ===
//  --------------------------------------------------------------------------
//  Module Name: LogonMutex.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File that implements a class that manages a single global logon mutex.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _LogonMutex_
#define     _LogonMutex_

//  --------------------------------------------------------------------------
//  CLogonMutex
//
//  Purpose:    This class encapsulates a logon mutex for exclusion to the
//              interactive logon interface offered by the friendly UI.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

class   CLogonMutex
{
    private:
                                            CLogonMutex (void);
                                            ~CLogonMutex (void);
    public:
        static  void                        Acquire (void);
        static  void                        Release (void);

        static  void                        SignalReply (void);
        static  void                        SignalShutdown (void);

        static  void                        StaticInitialize (void);
        static  void                        StaticTerminate (void);
    private:
        static  HANDLE                      CreateShutdownEvent (void);
        static  HANDLE                      CreateLogonMutex (void);
        static  HANDLE                      CreateLogonRequestMutex (void);
        static  HANDLE                      OpenShutdownEvent (void);
        static  HANDLE                      OpenLogonMutex (void);
    private:
        static  DWORD                       s_dwThreadID;
        static  LONG                        s_lAcquireCount;
        static  HANDLE                      s_hMutex;
        static  HANDLE                      s_hMutexRequest;
        static  HANDLE                      s_hEvent;
        static  const TCHAR                 s_szLogonMutexName[];
        static  const TCHAR                 s_szLogonRequestMutexName[];
        static  const TCHAR                 s_szLogonReplyEventName[];
        static  const TCHAR                 s_szShutdownEventName[];
        static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority;
        static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldSID;
};

#endif  /*  _LogonMutex_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logondialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CWLogonDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that contains an internal class to implement the logon dialog
//  additions for consumer windows. The C entry points allow the old Windows
//  2000 Win32 GINA dialog to call into this C++ code.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include <cfgmgr32.h>
#include <ginaIPC.h>
#include <ginarcid.h>
#include <msginaexports.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <winwlx.h>

#include "CredentialTransfer.h"
#include "LogonMutex.h"
#include "LogonWait.h"
#include "PrivilegeEnable.h"
#include "RegistryResources.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "StringConvert.h"
#include "SystemSettings.h"
#include "TokenInformation.h"
#include "TurnOffDialog.h"
#include "UIHost.h"
#include "UserList.h"

#define WM_HIDEOURSELVES    (WM_USER + 10000)
#define WM_SHOWOURSELVES    (WM_USER + 10001)

// Special logon substatus code from: ds\security\gina\msgina\stringid.h
#define IDS_LOGON_LOG_FULL              1702

//  --------------------------------------------------------------------------
//  CLogonDialog
//
//  Purpose:    C++ class to handle logon dialog additions for consumer
//              windows.
//
//  History:    2000-02-04  vtan        created from Neptune
//  --------------------------------------------------------------------------

class   CLogonDialog : public ILogonExternalProcess
{
    private:
                                        CLogonDialog (void);
                                        CLogonDialog (const CLogonDialog& copyObject);
                const CLogonDialog&     operator = (const CLogonDialog& assignObject);
    public:
                                        CLogonDialog (HWND hwndDialog, CUIHost *pUIHost, int iDialogType);
                                        ~CLogonDialog (void);

                NTSTATUS                StartUIHost (void);
                void                    EndUIHost (void);

                void                    ChangeWindowTitle (void);
                bool                    IsClassicLogonMode (void)   const;
                bool                    RevertClassicLogonMode (void);

                void                    Handle_WM_INITDIALOG (void);
                void                    Handle_WM_DESTROY (void);
                void                    Handle_WM_HIDEOURSELVES (void);
                void                    Handle_WM_SHOWOURSELVES (void);
                bool                    Handle_WM_LOGONSERVICEREQUEST (int iRequestType, void *pvInformation, int iDataSize);
                void                    Handle_WLX_WM_SAS (WPARAM wParam);
                bool                    Handle_WM_POWERBROADCAST (WPARAM wParam);
                bool                    Handle_LogonDisplayError (NTSTATUS status, NTSTATUS subStatus);
                void                    Handle_LogonCompleted (INT_PTR iDialogResult, const WCHAR *pszUsername, const WCHAR *pszDomain);
                void                    Handle_ShuttingDown (void);
                void                    Handle_LogonShowUI (void);
                void                    Handle_LogonHideUI (void);

        static  void                    SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword);
    public:
        virtual bool                    AllowTermination (DWORD dwExitCode);
        virtual NTSTATUS                SignalAbnormalTermination (void);
        virtual NTSTATUS                SignalRestart (void);
        virtual NTSTATUS                LogonRestart (void);
    private:
                bool                    Handle_LOGON_QUERY_LOGGED_ON (LOGONIPC_CREDENTIALS& logonIPCCredentials);
                bool                    Handle_LOGON_LOGON_USER (LOGONIPC_CREDENTIALS& logonIPCCredentials);
                bool                    Handle_LOGON_LOGOFF_USER (LOGONIPC_CREDENTIALS& logonIPCCredentials);
                bool                    Handle_LOGON_TEST_BLANK_PASSWORD (LOGONIPC_CREDENTIALS& logonIPCCredentials);
                bool                    Handle_LOGON_TEST_INTERACTIVE_LOGON_ALLOWED (LOGONIPC_CREDENTIALS& logonIPCCredentials);
                bool                    Handle_LOGON_TEST_EJECT_ALLOWED (void);
                bool                    Handle_LOGON_TEST_SHUTDOWN_ALLOWED (void);
                bool                    Handle_LOGON_TURN_OFF_COMPUTER (void);
                bool                    Handle_LOGON_EJECT_COMPUTER (void);
                bool                    Handle_LOGON_SIGNAL_UIHOST_FAILURE (void);
                bool                    Handle_LOGON_ALLOW_EXTERNAL_CREDENTIALS (void);
                bool                    Handle_LOGON_REQUEST_EXTERNAL_CREDENTIALS (void);
    private:
                HWND                    _hwndDialog;
                RECT                    _rcDialog;
                bool                    _fLogonSuccessful,
                                        _fFatalError,
                                        _fExternalCredentials,
                                        _fResumed,
                                        _fOldCancelButtonEnabled;
                int                     _iDialogType,
                                        _iCADCount;
                HANDLE                  _hEvent;
                IExternalProcess*       _pIExternalProcessOld;
                CEvent                  _eventLogonComplete;
                CLogonWait              _logonWait;
                CUIHost*                _pUIHost;
                TCHAR                   _szDomain[DNLEN + sizeof('\0')];
                TCHAR*                  _pszWindowTitle;

        static  bool                    s_fFirstLogon;
};

bool                    g_fFirstLogon       =   true;
CCriticalSection*       g_pLogonDialogLock  =   NULL;
CLogonDialog*           g_pLogonDialog      =   NULL;

//  --------------------------------------------------------------------------
//  CLogonDialog::CLogonDialog
//
//  Arguments:  hwndDialog  =   HWND to the Win32 GINA dialog.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CLogonDialog class. This stores the HWND
//              and creates an event that gets signaled when the attempt
//              logon thread completes and posts a message back to the Win32
//              dialog.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

CLogonDialog::CLogonDialog (HWND hwndDialog, CUIHost *pUIHost, int iDialogType) :
    _hwndDialog(hwndDialog),
    _fLogonSuccessful(false),
    _fFatalError(false),
    _fExternalCredentials(false),
    _fResumed(false),
    _iDialogType(iDialogType),
    _iCADCount(0),
    _hEvent(NULL),
    _pIExternalProcessOld(NULL),
    _eventLogonComplete(NULL),
    _pUIHost(NULL),
    _pszWindowTitle(NULL)

{
    pUIHost->AddRef();
    _pIExternalProcessOld = pUIHost->GetInterface();
    pUIHost->SetInterface(this);
    _pUIHost = pUIHost;
}

//  --------------------------------------------------------------------------
//  CLogonDialog::~CLogonDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CLogonDialog class.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

CLogonDialog::~CLogonDialog (void)

{
    ReleaseHandle(_hEvent);
    ReleaseMemory(_pszWindowTitle);
    ASSERTMSG(_hwndDialog == NULL, "CLogonDialog destroyed with WM_DESTROY being invoked in CLogonDialog::~CLogonDialog");
}

//  --------------------------------------------------------------------------
//  CLogonDialog::StartUIHost
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Start the external process that hosts the UI. This can be
//              anything but is presently logonui.exe. This is actually
//              determined in the CUIHost class.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonDialog::StartUIHost (void)

{
    NTSTATUS                status;
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    ASSERTMSG(_pUIHost->IsStarted(), "UI host must be started in CLogonDialog::StartUIHost");
    if (_pUIHost->IsHidden())
    {
        (NTSTATUS)_pUIHost->Show();
    }
    status = CCredentialClient::Get(&logonIPCCredentials);
    if (NT_SUCCESS(status))
    {
        _Shell_LogonStatus_NotifyNoAnimations();
    }
    _Shell_LogonStatus_SetStateLogon((_iDialogType != SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK) ? 0 : SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
    if (_iDialogType == SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK)
    {
        _iDialogType = SHELL_LOGONDIALOG_RETURNTOWELCOME;
    }
    if (NT_SUCCESS(status))
    {
        _Shell_LogonStatus_InteractiveLogon(logonIPCCredentials.userID.wszUsername,
                                            logonIPCCredentials.userID.wszDomain,
                                            logonIPCCredentials.wszPassword);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::EndUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    End the external UI host. Just release the reference to it.
//
//  History:    2000-05-01  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::EndUIHost (void)

{
    if (_pUIHost != NULL)
    {
        if (_pIExternalProcessOld != NULL)
        {
            _pUIHost->SetInterface(_pIExternalProcessOld);
            _pIExternalProcessOld->Release();
            _pIExternalProcessOld = NULL;
        }
        _pUIHost->Release();
        _pUIHost = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::ChangeWindowTitle
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Change the window title of the msgina dialog to something that
//              shgina can find.
//
//  History:    2000-06-02  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::ChangeWindowTitle (void)

{
    if (_pszWindowTitle == NULL)
    {
        int     iLength;

        //  Because the title of the dialog can be localized change the name to
        //  something that shgina expects that will NOT be localized. Don't forget
        //  to restore this if the dialog needs to be re-shown again. If the current
        //  value cannot be read slam the title anyway. Recovery from error will be
        //  less than optimal.

        iLength = GetWindowTextLength(_hwndDialog) + sizeof('\0');
        _pszWindowTitle = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, iLength * sizeof(TCHAR)));
        if (_pszWindowTitle != NULL)
        {
            (int)GetWindowText(_hwndDialog, _pszWindowTitle, iLength);
        }
        TBOOL(SetWindowText(_hwndDialog, TEXT("GINA Logon")));
        TBOOL(GetWindowRect(_hwndDialog, &_rcDialog));
        TBOOL(SetWindowPos(_hwndDialog, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER));
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::IsClassicLogonMode
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether classic logon has been externally requested
//              by the user (CTRL-ALT-DELETE x 2).
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::IsClassicLogonMode (void)   const

{
    return(_iCADCount >= 2);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::RevertClassicLogonMode
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether it handled the conversion back from classic
//              logon mode to the UI host.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::RevertClassicLogonMode (void)

{
    bool    fResult;

    fResult = IsClassicLogonMode();
    if (fResult)
    {
        _iCADCount = 0;
        _fExternalCredentials = false;
        (BOOL)EnableWindow(GetDlgItem(_hwndDialog, IDCANCEL), _fOldCancelButtonEnabled);
        TBOOL(PostMessage(_hwndDialog, WM_HIDEOURSELVES, 0, 0));
        Handle_LogonShowUI();
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_INITDIALOG
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function is invoked if the external UI host is being
//              used. In this case the GINA Win32 dialog size is saved and
//              then changed to an empty rectangle. The window is then hidden
//              using a posted message.
//
//              See CLogonDialog::Handle_WM_HIDEOURSELVES for the follow up.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_WM_INITDIALOG (void)

{
    if (!_fFatalError && !_fExternalCredentials)
    {
        TBOOL(PostMessage(_hwndDialog, WM_HIDEOURSELVES, 0, 0));
    }
    _ShellReleaseLogonMutex(FALSE);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_DESTROY
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function cleans up anything in the dialog before
//              destruction.
//
//  History:    2000-02-07  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_WM_DESTROY (void)

{
    _hwndDialog = NULL;
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_HIDEOURSELVES
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function is invoked after the dialog is asked to hide
//              itself. The user will not see anything because the size of
//              the dialog client rectangle is an empty rectangle.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_WM_HIDEOURSELVES (void)

{
    (BOOL)ShowWindow(_hwndDialog, SW_HIDE);
    ChangeWindowTitle();
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_SHOWOURSELVES
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    In case the Win32 dialog needs to be shown again this function
//              exists. It restores the size of the dialog and then shows the
//              dialog.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_WM_SHOWOURSELVES (void)

{
    if (_iDialogType == SHELL_LOGONDIALOG_LOGGEDOFF)
    {
        if (_pszWindowTitle != NULL)
        {

            //  If handling logged off welcome screen failure show WlxLoggedOutSAS.

            TBOOL(SetWindowText(_hwndDialog, _pszWindowTitle));
            ReleaseMemory(_pszWindowTitle);
            TBOOL(SetWindowPos(_hwndDialog, NULL, 0, 0, _rcDialog.right - _rcDialog.left, _rcDialog.bottom - _rcDialog.top, SWP_NOMOVE | SWP_NOZORDER));
            (BOOL)ShowWindow(_hwndDialog, SW_SHOW);
            (BOOL)SetForegroundWindow(_hwndDialog);
            (BOOL)_Gina_SetPasswordFocus(_hwndDialog);
        }
    }
    else
    {

        //  If handling return to welcome screen failure show WlxWkstaLockedSAS.

        TBOOL(EndDialog(_hwndDialog, MSGINA_DLG_LOCK_WORKSTATION));
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_LOGONSERVICEREQUEST
//
//  Arguments:  iRequestType    =   Request identifier.
//              pvInformation   =   Pointer to the information in the
//                                  requesting process address space.
//              iDataSize       =   Size of the data.
//
//  Returns:    bool
//
//  Purpose:    Handler for logon service requests made thru the logon IPC.
//              This specifically serves the UI host.
//
//  History:    1999-08-24  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_WM_LOGONSERVICEREQUEST (int iRequestType, void *pvInformation, int iDataSize)

{
    bool                    fResult, fHandled;
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    //  Clear out our memory and extract the information from the requesting
    //  process. This could be us if the internal logon dialog is used. The
    //  extractor knows how to handle this.

    ZeroMemory(&logonIPCCredentials, sizeof(logonIPCCredentials));
    if (NT_SUCCESS(_pUIHost->GetData(pvInformation, &logonIPCCredentials, iDataSize)))
    {
        switch (iRequestType)
        {
            case LOGON_QUERY_LOGGED_ON:
            {
                fResult = Handle_LOGON_QUERY_LOGGED_ON(logonIPCCredentials);
                break;
            }
            case LOGON_LOGON_USER:
            {
                fResult = Handle_LOGON_LOGON_USER(logonIPCCredentials);
                break;
            }
            case LOGON_LOGOFF_USER:
            {
                fResult = Handle_LOGON_LOGOFF_USER(logonIPCCredentials);
                break;
            }
            case LOGON_TEST_BLANK_PASSWORD:
            {
                fResult = Handle_LOGON_TEST_BLANK_PASSWORD(logonIPCCredentials);
                break;
            }
            case LOGON_TEST_INTERACTIVE_LOGON_ALLOWED:
            {
                fResult = Handle_LOGON_TEST_INTERACTIVE_LOGON_ALLOWED(logonIPCCredentials);
                break;
            }
            case LOGON_TEST_EJECT_ALLOWED:
            {
                fResult = Handle_LOGON_TEST_EJECT_ALLOWED();
                break;
            }
            case LOGON_TEST_SHUTDOWN_ALLOWED:
            {
                fResult = Handle_LOGON_TEST_SHUTDOWN_ALLOWED();
                break;
            }
            case LOGON_TURN_OFF_COMPUTER:
            {
                fResult = Handle_LOGON_TURN_OFF_COMPUTER();
                break;
            }
            case LOGON_EJECT_COMPUTER:
            {
                fResult = Handle_LOGON_EJECT_COMPUTER();
                break;
            }
            case LOGON_SIGNAL_UIHOST_FAILURE:
            {
                fResult = Handle_LOGON_SIGNAL_UIHOST_FAILURE();
                break;
            }
            case LOGON_ALLOW_EXTERNAL_CREDENTIALS:
            {
                fResult = Handle_LOGON_ALLOW_EXTERNAL_CREDENTIALS();
                break;
            }
            case LOGON_REQUEST_EXTERNAL_CREDENTIALS:
            {
                fResult = Handle_LOGON_REQUEST_EXTERNAL_CREDENTIALS();
                break;
            }
            default:
            {
                DISPLAYMSG("Invalid request sent to CLogonDialog::Handle_WM_LOGONSERVICEREQUEST");
                break;
            }
        }

        //  Put the result back in the UI host process' information block.

        fHandled = NT_SUCCESS(_pUIHost->PutData(pvInformation, &fResult, sizeof(fResult)));
    }
    else
    {
        fHandled = false;
    }
    return(fHandled);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WLX_WM_SAS
//
//  Arguments:  wParam  =   SAS type that occurred.
//
//  Returns:    <none>
//
//  Purpose:    Invoked when a SAS is delivered to the logon dialog. This can
//              be done by a remote shutdown invokation. In this case the UI
//              host should not be restarted. Make a note of this.
//
//  History:    2000-04-24  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_WLX_WM_SAS (WPARAM wParam)

{
    if ((wParam == WLX_SAS_TYPE_CTRL_ALT_DEL) && (_iDialogType == SHELL_LOGONDIALOG_LOGGEDOFF))
    {

        //  CONTROL-ALT-DELETE. If not in classic mode bump up the CAD count.
        //  If it reaches classic mode then switch. If in classic mode blow it off.

        if (!IsClassicLogonMode())
        {
            ++_iCADCount;
            if (IsClassicLogonMode())
            {
                _fExternalCredentials = true;
                _fOldCancelButtonEnabled = (EnableWindow(GetDlgItem(_hwndDialog, IDCANCEL), TRUE) == 0);
                TBOOL(PostMessage(_hwndDialog, WM_SHOWOURSELVES, 0, 0));
                Handle_LogonHideUI();
            }
        }
    }
    else
    {

        //  Reset the CAD count if some other SAS gets in the way.

        _iCADCount = 0;
        if (wParam == WLX_SAS_TYPE_USER_LOGOFF)
        {
            _fFatalError = true;
        }
        else if (wParam == WLX_SAS_TYPE_SCRNSVR_TIMEOUT)
        {
            _pUIHost->Hide();
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_WM_POWERBROADCAST
//
//  Arguments:  wParam  =   Powerbroadcast message.
//
//  Returns:    bool
//
//  Purpose:    Responds to APM messages. When suspend is issued it places
//              the UI host to status mode. When resume is received it places
//              the UI host in logon mode.
//
//              The UI host should have waited and blown off requests to
//              display the logon list and should be waiting for this call to
//              release it because we pass it the same magic number to lock
//              it.
//
//  History:    2000-06-30  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_WM_POWERBROADCAST (WPARAM wParam)

{
    bool    fResult;

    fResult = false;
    if (((PBT_APMRESUMEAUTOMATIC == wParam) || (PBT_APMRESUMECRITICAL == wParam) || (PBT_APMRESUMESUSPEND == wParam)) &&
        !_fResumed)
    {
        _fResumed = true;
        _Shell_LogonStatus_SetStateLogon(SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
        fResult = true;
    }
    else if (PBT_APMSUSPEND == wParam)
    {
        _Shell_LogonStatus_SetStateStatus(SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
        _fResumed = fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LogonDisplayError
//
//  Arguments:  status  =   NTSTATUS of logon request.
//
//  Returns:    bool
//
//  Purpose:    Under all cases other than a bad password a failure to logon
//              should be displayed by a standard Win32 error dialog that
//              is already handled by msgina. In the case of a bad password
//              let the UI host handle this.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LogonDisplayError (NTSTATUS status, NTSTATUS subStatus)

{
    return(IsClassicLogonMode() || (status != STATUS_LOGON_FAILURE) || (subStatus == IDS_LOGON_LOG_FULL));
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LogonCompleted
//
//  Arguments:  iDialogResult   =   Dialog result code.
//
//  Returns:    <none>
//
//  Purpose:    This function is called when the attempt logon thread has
//              completed and posted a message regarding its result. The
//              internal event is signaled to release the actual UI host
//              logon request in CLogonDialog::Handle_WM_LOGONSERVICEREQUEST
//              and the actual success of the logon request is stored.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_LogonCompleted (INT_PTR iDialogResult, const WCHAR *pszUsername, const WCHAR *pszDomain)

{
    if (MSGINA_DLG_SWITCH_CONSOLE == iDialogResult)
    {
        Handle_WM_SHOWOURSELVES();
        _Shell_LogonDialog_Destroy();
        _Shell_LogonStatus_Destroy(HOST_END_TERMINATE);
    }
    else
    {
        TSTATUS(_eventLogonComplete.Set());
        _fLogonSuccessful = (MSGINA_DLG_SUCCESS == iDialogResult);

        //  Always show the UI host unless double CONTROL-ALT-DELETE
        //  was enabled and the logon was unsuccessful.

        if (!IsClassicLogonMode() || _fLogonSuccessful)
        {
            Handle_WM_HIDEOURSELVES();
            Handle_LogonShowUI();
        }

        //  If successful and external credentials then instruct the UI host
        //  to animate to the actual person in the external credentials.
        //  Switch the UI host to logged on mode.

        if (_fLogonSuccessful && _fExternalCredentials)
        {
            _Shell_LogonStatus_SelectUser(pszUsername, pszDomain);
            _Shell_LogonStatus_SetStateLoggedOn();
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_ShuttingDown
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function handles the UI host in classic mode but was
//              given a request to shut down or restart.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_ShuttingDown (void)

{
    if (IsClassicLogonMode())
    {
        TBOOL(PostMessage(_hwndDialog, WM_HIDEOURSELVES, 0, 0));
        Handle_LogonShowUI();
        _Shell_LogonStatus_NotifyWait();
        _Shell_LogonStatus_SetStateStatus(SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
    }
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LogonShowUI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function is called after something that went wrong with
//              the logon process has been serviced. It is called it the UI
//              needs to be shown again to give the user the opportunity to
//              re-enter information.
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_LogonShowUI (void)

{
    TSTATUS(_pUIHost->Show());
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LogonHideUI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    This function is called when something goes wrong with a logon
//              event that can be serviced immediately to ensure the logon
//              process completes smoothly. Typically this is the user is
//              required to change their password at first logon. This
//              function asks the UI host to hide all its windows.
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

void    CLogonDialog::Handle_LogonHideUI (void)

{
    TSTATUS(_pUIHost->Hide());
}

//  --------------------------------------------------------------------------
//  CLogonDialog::SetTextFields
//
//  Arguments:  hwndDialog      =   HWND to the Win32 GINA dialog.
//              pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//              pwszPassword    =   User password.
//
//  Returns:    <none>
//
//  Purpose:    This function has great knowledge of the Win32 GINA
//              dialog and stores the parameters directly in the dialog to
//              simulate the actual typing of the information.
//
//              For the domain combobox first check that a domain has been
//              supplied. If not find the computer name and use that as the
//              domain. Send CB_SELECTSTRING to the combobox to select it.
//
//  History:    2000-02-04  vtan        created
//              2000-06-27  vtan        added domain combobox support
//  --------------------------------------------------------------------------

void    CLogonDialog::SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword)

{
    _Gina_SetTextFields(hwndDialog, pwszUsername, pwszDomain, pwszPassword);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::AllowTermination
//
//  Arguments:  dwExitCode  =   Exit code of the process that died.
//
//  Returns:    bool
//
//  Purpose:    This function is invoked by the UI host when the process
//              terminates and the UI host is asking whether the termination
//              is acceptable.
//
//  History:    1999-09-14  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-03-09  vtan        added magical exit code
//  --------------------------------------------------------------------------

bool    CLogonDialog::AllowTermination (DWORD dwExitCode)

{
    UNREFERENCED_PARAMETER(dwExitCode);

    return(false);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::SignalAbnormalTermination
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    This function is invoked by the UI host if the process
//              terminates and cannot be restarted. This indicates a serious
//              condition from which this function can attempt to recover.
//
//  History:    1999-09-14  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CLogonDialog::SignalAbnormalTermination (void)

{
    IExternalProcess    *pIExternalProcess;

    ASSERTMSG(_pIExternalProcessOld != NULL, "Expecting non NULL _pIExternalProcessOld in CLogonDialog::SignalAbnormalTermination");
    pIExternalProcess = _pIExternalProcessOld;
    pIExternalProcess->AddRef();
    TSTATUS(_logonWait.Cancel());
    Handle_WM_SHOWOURSELVES();
    _Shell_LogonDialog_Destroy();
    TSTATUS(pIExternalProcess->SignalAbnormalTermination());
    pIExternalProcess->Release();
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::SignalRestart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Function to reset the ready event and set the UI host into
//              logon state. This is invoked when the UI host is restarted
//              after a failure.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonDialog::SignalRestart (void)

{
    NTSTATUS    status;
    HANDLE      hEvent;

    hEvent = _Shell_LogonStatus_ResetReadyEvent();
    if (hEvent != NULL)
    {
        if (DuplicateHandle(GetCurrentProcess(),
                            hEvent,
                            GetCurrentProcess(),
                            &_hEvent,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    if (NT_SUCCESS(status))
    {
        status = _logonWait.Register(_hEvent, this);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::LogonRestart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    
//
//  History:    2001-02-21  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CLogonDialog::LogonRestart (void)

{
    _Shell_LogonStatus_SetStateLogon(0);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_QUERY_LOGGED_ON
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_QUERY_LOGGED_ON.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_QUERY_LOGGED_ON (LOGONIPC_CREDENTIALS& logonIPCCredentials)

{

    //  LOGON_QUERY_LOGGED_ON: Query if the user is contained in the
    //  logged on user list. Use terminal services API to do this.

    return(CUserList::IsUserLoggedOn(logonIPCCredentials.userID.wszUsername, logonIPCCredentials.wszPassword));
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_LOGON_USER
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_LOGON_USER.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_LOGON_USER (LOGONIPC_CREDENTIALS& logonIPCCredentials)

{
    UNICODE_STRING  passwordString;

    //  Take the run encoded password supplied and run decode using
    //  the provided seed. Set the password and then erase the clear
    //  text in memory when done. Both the logged on (switch) and
    //  NOT logged on case require the password.

    passwordString.Buffer = logonIPCCredentials.wszPassword;
    passwordString.Length = sizeof(logonIPCCredentials.wszPassword) - sizeof(L'\0');
    passwordString.MaximumLength = sizeof(logonIPCCredentials.wszPassword);
    RtlRunDecodeUnicodeString(logonIPCCredentials.ucPasswordSeed, &passwordString);
    logonIPCCredentials.wszPassword[logonIPCCredentials.iPasswordLength] = L'\0';

    //  When the dialog type is SHELL_LOGONDIALOG_LOGGEDOFF use the
    //  regular WlxLoggedOutSAS method. Filling in the underlying
    //  dialog and let msgina do the actual logon work.

    if (_iDialogType == SHELL_LOGONDIALOG_LOGGEDOFF)
    {

        //  LOGON_LOGON_USER: Use an event that will get signaled
        //  when logon is completed. Logon occurs on a different thread
        //  but this thread MUST be blocked to stop the UI host from
        //  sending multiple logon requests. Wait for the event to get
        //  signaled but do not block the message pump.

        //  Set the username and password (no domain) and then
        //  erase the password in memory.

        SetTextFields(_hwndDialog, logonIPCCredentials.userID.wszUsername, logonIPCCredentials.userID.wszDomain, logonIPCCredentials.wszPassword);
        RtlEraseUnicodeString(&passwordString);
    }
    else
    {

        //  Otherwise we expect the case to be
        //  SHELL_LOGONDIALOG_RETURNTOWELCOME. In this case authenticate
        //  by sending the struct address to the hosting window (a stripped
        //  down WlxLoggedOutSAS window for return to welcome) and then
        //  fall thru to the IDOK path just like the full dialog.
        //  This is accomplished with by sending a message to the return
        //  to welcome stub dialog WM_COMMAND/IDCANCEL.

        (LRESULT)SendMessage(_hwndDialog, WM_COMMAND, IDCANCEL, reinterpret_cast<LPARAM>(&logonIPCCredentials));
    }

    //  1) Reset the signal event.
    //  2) Simulate the "enter" key pressed (credentials filled in above).
    //  3) Wait for the signal event (keep the message pump going).
    //  4) Extract the result.

    TSTATUS(_eventLogonComplete.Reset());
    _ShellAcquireLogonMutex();
    (LRESULT)SendMessage(_hwndDialog, WM_COMMAND, IDOK, NULL);
    TSTATUS(_eventLogonComplete.WaitWithMessages(INFINITE, NULL));
    if (_iDialogType == SHELL_LOGONDIALOG_RETURNTOWELCOME)
    {
        RtlEraseUnicodeString(&passwordString);
    }

    //  On success tell the UI host to go to logon state.

    if (_fLogonSuccessful)
    {
        _Shell_LogonStatus_SetStateLoggedOn();
    }
    else
    {
        _ShellReleaseLogonMutex(FALSE);
    }
    return(_fLogonSuccessful);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_LOGOFF_USER
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_LOGOFF_USER.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_LOGOFF_USER (LOGONIPC_CREDENTIALS& logonIPCCredentials)

{
    UNREFERENCED_PARAMETER(logonIPCCredentials);

    //  LOGON_LOGOFF_USER: Log the logged on user off. They must be logged on
    //  or this will do nothing.

    return(false);    //UNIMPLEMENTED
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_TEST_BLANK_PASSWORD
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_TEST_BLANK_PASSWORD.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_TEST_BLANK_PASSWORD (LOGONIPC_CREDENTIALS& logonIPCCredentials)

{
    bool    fResult;
    HANDLE  hToken;

    //  LOGON_TEST_BLANK_PASSWORD: Attempt to the given user on the system
    //  with a blank password. If successful discard the token. Only return
    //  the result.

    fResult = (CTokenInformation::LogonUser(logonIPCCredentials.userID.wszUsername,
                                            logonIPCCredentials.userID.wszDomain,
                                            L"",
                                            &hToken) == ERROR_SUCCESS);
    if (fResult && (hToken != NULL))
    {
        ReleaseHandle(hToken);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_TEST_INTERACTIVE_LOGON_ALLOWED
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_TEST_INTERACTIVE_LOGON_ALLOWED.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_TEST_INTERACTIVE_LOGON_ALLOWED (LOGONIPC_CREDENTIALS& logonIPCCredentials)

{
    int     iResult;

    iResult = CUserList::IsInteractiveLogonAllowed(logonIPCCredentials.userID.wszUsername);
    return((iResult != -1) && (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_TEST_EJECT_ALLOWED
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_TEST_EJECT_ALLOWED.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_TEST_EJECT_ALLOWED (void)

{
    bool    fResult;
    HANDLE  hToken;

    //  Check the system setting and policy for undock without logon allowed.

    fResult = CSystemSettings::IsUndockWithoutLogonAllowed();
    if (fResult && (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) != FALSE))
    {
        DWORD               dwTokenPrivilegesSize;
        TOKEN_PRIVILEGES    *pTokenPrivileges;

        //  Then test the token privilege for SE_UNDOCK_NAME privilege.

        dwTokenPrivilegesSize = 0;
        (BOOL)GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwTokenPrivilegesSize);
        pTokenPrivileges = static_cast<TOKEN_PRIVILEGES*>(LocalAlloc(LMEM_FIXED, dwTokenPrivilegesSize));
        if (pTokenPrivileges != NULL)
        {
            DWORD dwReturnLength;

            if (GetTokenInformation(hToken, TokenPrivileges, pTokenPrivileges, dwTokenPrivilegesSize, &dwReturnLength) != FALSE)
            {
                DWORD   dwIndex;
                LUID    luidPrivilege;

                luidPrivilege.LowPart = SE_UNDOCK_PRIVILEGE;
                luidPrivilege.HighPart = 0;
                for (dwIndex = 0; !fResult && (dwIndex < pTokenPrivileges->PrivilegeCount); ++dwIndex)
                {
                    fResult = (RtlEqualLuid(&luidPrivilege, &pTokenPrivileges->Privileges[dwIndex].Luid) != FALSE);
                }

                //  Now check to see if a physical docking stations is present.
                //  Also check to see if the session is a remote session.

                if (fResult)
                {
                    BOOL    fIsDockStationPresent;

                    fIsDockStationPresent = FALSE;
                    (CONFIGRET)CM_Is_Dock_Station_Present(&fIsDockStationPresent);
                    fResult = ((fIsDockStationPresent != FALSE) && (GetSystemMetrics(SM_REMOTESESSION) == 0));
                }
            }
            (HLOCAL)LocalFree(pTokenPrivileges);
        }
        TBOOL(CloseHandle(hToken));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_TEST_SHUTDOWN_ALLOWED
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_TEST_SHUTDOWN_ALLOWED.
//
//  History:    2001-02-22  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_TEST_SHUTDOWN_ALLOWED (void)

{
    return((GetSystemMetrics(SM_REMOTESESSION) == FALSE) &&
           CSystemSettings::IsShutdownWithoutLogonAllowed());
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_TURN_OFF_COMPUTER
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_TURN_OFF_COMPUTER.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_TURN_OFF_COMPUTER (void)

{
    bool        fResult;
    INT_PTR     ipResult;

    //  LOGON_TURN_OFF_COMPUTER: Present the "Turn Off Computer" dialog
    //  and return an MSGINA_DLG_xxx code in response.

    ipResult = CTurnOffDialog::ShellCodeToGinaCode(ShellTurnOffDialog(NULL));
    if (ipResult != MSGINA_DLG_FAILURE)
    {
        DWORD   dwExitWindowsFlags;

        dwExitWindowsFlags = CTurnOffDialog::GinaCodeToExitWindowsFlags(static_cast<DWORD>(ipResult));
        if ((dwExitWindowsFlags != 0) && (DisplayExitWindowsWarnings(EWX_SYSTEM_CALLER | dwExitWindowsFlags) == FALSE))
        {
            ipResult = MSGINA_DLG_FAILURE;
        }
    }
    if (ipResult != MSGINA_DLG_FAILURE)
    {
        TBOOL(EndDialog(_hwndDialog, ipResult));
        _fLogonSuccessful = fResult = true;
        _Shell_LogonStatus_NotifyWait();
        _Shell_LogonStatus_SetStateStatus(SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER);
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_EJECT_COMPUTER
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_EJECT_COMPUTER.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_EJECT_COMPUTER (void)

{
    return(CM_Request_Eject_PC() == ERROR_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_SIGNAL_UIHOST_FAILURE
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_SIGNAL_UIHOST_FAILURE.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_SIGNAL_UIHOST_FAILURE (void)

{

    //  LOGON_SIGNAL_UIHOST_FAILURE: The UI host is signaling us
    //  that it has an error from which it cannot recover.

    _fFatalError = true;
    TBOOL(PostMessage(_hwndDialog, WM_SHOWOURSELVES, 0, 0));
    return(true);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_ALLOW_EXTERNAL_CREDENTIALS
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_ALLOW_EXTERNAL_CREDENTIALS.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_ALLOW_EXTERNAL_CREDENTIALS (void)

{

    //  LOGON_ALLOW_EXTERNAL_CREDENTIALS: Return whether external
    //  credentials are allowed. Requesting external credentials
    //  (below) will cause classic GINA to be shown for the input.

    return(CSystemSettings::IsDomainMember());
}

//  --------------------------------------------------------------------------
//  CLogonDialog::Handle_LOGON_REQUEST_EXTERNAL_CREDENTIALS
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Handles LOGON_REQUEST_EXTERNAL_CREDENTIALS.
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonDialog::Handle_LOGON_REQUEST_EXTERNAL_CREDENTIALS (void)

{

    //  LOGON_REQUEST_EXTERNAL_CREDENTIALS: The UI host is
    //  requesting credentials from an external source (namely)
    //  msgina. Hide the UI host and show the GINA dialog.

    _fExternalCredentials = true;
    TBOOL(PostMessage(_hwndDialog, WM_SHOWOURSELVES, 0, 0));
    Handle_LogonHideUI();
    return(true);
}

//  --------------------------------------------------------------------------
//  CreateLogonHost
//
//  Arguments:  hwndDialog      =   HWND to Win32 GINA dialog.
//              iDialogType     =   Type of dialog.
//
//  Returns:    int
//
//  Purpose:    This function handles the actual creation and allocation of
//              resources for handling the friendly UI dialog. It behaves
//              differently depending on whether the dialog is in
//              WlxLoggedOutSAS mode or return to welcome mode.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

int     CreateLogonHost (HWND hwndDialog, int iResult, int iDialogType)

{
    if (g_pLogonDialogLock != NULL)
    {
        CLogonDialog    *pLogonDialog;
        CUIHost         *pUIHost;

        g_pLogonDialogLock->Acquire();
        pUIHost = reinterpret_cast<CUIHost*>(_Shell_LogonStatus_GetUIHost());
        if (pUIHost != NULL)
        {
            ASSERTMSG(g_pLogonDialog == NULL, "static CLogonDialog already exists in _Shell_LogonDialog__Init");
            g_pLogonDialog = pLogonDialog = new CLogonDialog(hwndDialog, pUIHost, iDialogType);
            pUIHost->Release();
        }
        else
        {
            pLogonDialog = NULL;
        }
        if (pLogonDialog != NULL)
        {
            NTSTATUS    status;

            //  Add a reference to prevent the object from being destroyed.

            pLogonDialog->AddRef();
            pLogonDialog->ChangeWindowTitle();

            //  CLogonDialog::StartUIHost can enter a wait state. Release the lock to
            //  allow g_pLogonDialog to be modified externally by SignalAbnormalTermination
            //  should the UI host fail and the callback on the IOCompletion port be executed.

            g_pLogonDialogLock->Release();
            status = pLogonDialog->StartUIHost();
            g_pLogonDialogLock->Acquire();

            //  Make sure to re-acquire the lock so that reading from g_pLogonDialog
            //  is consistent. If failure happens after this then it'll just wait.
            //  Then check to see the result of CLogonDialog::StartUIHost and the
            //  global g_pLogonDialog. If both of these are valid then everything
            //  is set for the external host. Otherwise bail and show classic UI.

            if (NT_SUCCESS(status) && (g_pLogonDialog != NULL))
            {
                iResult = SHELL_LOGONDIALOG_EXTERNALHOST;
                pLogonDialog->Handle_WM_INITDIALOG();
            }
            else
            {
                pLogonDialog->Handle_WM_SHOWOURSELVES();
                _Shell_LogonDialog_Destroy();
            }
            pLogonDialog->Release();
        }
        g_pLogonDialogLock->Release();
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initialize the critical section for g_pLogonDialog.
//
//  History:    2001-04-27  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticInitialize (void)

{
    NTSTATUS    status;

    ASSERTMSG(g_pLogonDialogLock == NULL, "g_pLogonDialogLock already exists in _Shell_LogonDialog_StaticInitialize");
    g_pLogonDialogLock = new CCriticalSection;
    if (g_pLogonDialogLock != NULL)
    {
        status = g_pLogonDialogLock->Status();
        if (!NT_SUCCESS(status))
        {
            delete g_pLogonDialogLock;
            g_pLogonDialogLock = NULL;
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Delete the critical section for g_pLogonDialog.
//
//  History:    2001-04-27  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticTerminate (void)

{
    if (g_pLogonDialogLock != NULL)
    {
        delete g_pLogonDialogLock;
        g_pLogonDialogLock = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_Init
//
//  Arguments:  hwndDialog      =   HWND to Win32 GINA dialog.
//              iDialogType     =   Type of dialog.
//
//  Returns:    int
//
//  Purpose:    This function is invoked from the WM_INITDIALOG handler of
//              the Win32 dialog. It determines whether the consumer windows
//              UI host should handle the logon by checking a few settings.
//
//              If this is consumer windows then it checks for a single user
//              with no password (actually attempting to log them on). If this
//              succeeds then this information is set into the Win32 dialog
//              and the direction to go to logon is returned.
//
//              Otherwise it creates the required object to handle an external
//              UI host and starts it. If that succeeds then the UI host code
//              is returned.
//
//              This function is only invoked in the workgroup case.
//
//  History:    2000-02-04  vtan        created
//              2000-03-06  vtan        added safe mode handler
//  --------------------------------------------------------------------------

EXTERN_C    int     _Shell_LogonDialog_Init (HWND hwndDialog, int iDialogType)

{
    int     iResult;

    iResult = SHELL_LOGONDIALOG_NONE;
    if (iDialogType == SHELL_LOGONDIALOG_LOGGEDOFF)
    {
        bool    fIsRemote, fIsSessionZero;

        fIsRemote = (GetSystemMetrics(SM_REMOTESESSION) != 0);
        fIsSessionZero = (NtCurrentPeb()->SessionId == 0);
        if ((!fIsRemote || fIsSessionZero || CSystemSettings::IsForceFriendlyUI()) && CSystemSettings::IsFriendlyUIActive())
        {

            //  There was no wait for the UI host to signal it was ready.
            //  Before switching to logon mode wait for the host.

            if (_Shell_LogonStatus_WaitForUIHost() != FALSE)
            {

                //  If the wait succeeds then go and send the UI host to logon mode.

                if (g_fFirstLogon && fIsSessionZero)
                {
                    WCHAR   *pszUsername;

                    pszUsername = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (UNLEN + sizeof('\0')) * sizeof(WCHAR)));
                    if (pszUsername != NULL)
                    {
                        WCHAR   *pszDomain;

                        pszDomain = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (DNLEN + sizeof('\0')) * sizeof(WCHAR)));
                        if (pszDomain != NULL)
                        {
                            //  Check for single user with no password. Handle this
                            //  case by filling in the buffers passed to us and return
                            //  _Shell_LOGONDIALOG_LOGON directing a logon attempt.

                            if (ShellIsSingleUserNoPassword(pszUsername, pszDomain))
                            {
                                CLogonDialog::SetTextFields(hwndDialog, pszUsername, pszDomain, L"");
                                iResult = SHELL_LOGONDIALOG_LOGON;
                                _Shell_LogonStatus_SetStateLoggedOn();
                            }
                            (HLOCAL)LocalFree(pszDomain);
                        }
                        (HLOCAL)LocalFree(pszUsername);
                    }
                }

                //  Otherwise attempt to start the UI host. If this
                //  is successful then return the external host
                //  code back to the caller which will hide the dialog.

                if (iResult == SHELL_LOGONDIALOG_NONE)
                {
                    iResult = CreateLogonHost(hwndDialog, iResult, iDialogType);
                }
            }
        }

        //  Once this point is reached don't ever check again.

        g_fFirstLogon = false;
    }
    else if ((iDialogType == SHELL_LOGONDIALOG_RETURNTOWELCOME) || (iDialogType == SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK))
    {
        iResult = CreateLogonHost(hwndDialog, iResult, iDialogType);
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_Destroy
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release memory and/or resources occupied by the UI host
//              handling and reset it.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonDialog_Destroy (void)

{
    if (g_pLogonDialogLock != NULL)
    {
        CSingleThreadedExecution    lock(*g_pLogonDialogLock);

        if (g_pLogonDialog != NULL)
        {
            g_pLogonDialog->Handle_WM_DESTROY();
            g_pLogonDialog->EndUIHost();
            g_pLogonDialog->Release();
            g_pLogonDialog = NULL;
        }
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_UIHostActive
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the UI host has been activated. This will
//              prevent an incorrect password from stealing focus from the
//              UI host. The Win32 GINA dialog will try to set focus in that
//              case but this is not desired.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonDialog_UIHostActive (void)

{
    return((g_pLogonDialog != NULL) && !g_pLogonDialog->IsClassicLogonMode());
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_Cancel
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the cancel button was handled by the UI host.
//              This is used when CAD x 2 needs to be cancelled and the UI
//              host restored.
//
//  History:    2001-02-01  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonDialog_Cancel (void)

{
    return((g_pLogonDialog != NULL) && g_pLogonDialog->RevertClassicLogonMode());
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_DlgProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    BOOL
//
//  Purpose:    The Win32 GINA dialog code calls this function for uiMessage
//              parameters it doesn't understand. This gives us the chance to
//              add messages that only we understand and process them.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonDialog_DlgProc (HWND hwndDialog, UINT uiMessage, WPARAM wParam, LPARAM lParam)

{
    UNREFERENCED_PARAMETER(hwndDialog);

    BOOL    fResult;

    fResult = FALSE;
    if (g_pLogonDialog != NULL)
    {
        switch (uiMessage)
        {
            case WM_HIDEOURSELVES:
                g_pLogonDialog->Handle_WM_HIDEOURSELVES();
                fResult = TRUE;
                break;
            case WM_SHOWOURSELVES:
                g_pLogonDialog->Handle_WM_SHOWOURSELVES();
                fResult = TRUE;
                break;
            case WM_LOGONSERVICEREQUEST:
                fResult = g_pLogonDialog->Handle_WM_LOGONSERVICEREQUEST(HIWORD(wParam), reinterpret_cast<void*>(lParam), LOWORD(wParam));
                break;
            case WLX_WM_SAS:
                g_pLogonDialog->Handle_WLX_WM_SAS(wParam);
                fResult = TRUE;
                break;
            case WM_POWERBROADCAST:
                fResult = g_pLogonDialog->Handle_WM_POWERBROADCAST(wParam);
                break;
            default:
                break;
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_LogonDisplayError
//
//  Arguments:  status  =   NTSTATUS of logon request.
//
//  Returns:    BOOL
//
//  Purpose:    Passes the NTSTATUS onto the CLogonDialog handler if there is
//              one present.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    _Shell_LogonDialog_LogonDisplayError (NTSTATUS status, NTSTATUS subStatus)

{
    BOOL    fResult;

    fResult = TRUE;
    if (g_pLogonDialog != NULL)
    {
        fResult = g_pLogonDialog->Handle_LogonDisplayError(status, subStatus);
    }
    else
    {
        _Shell_LogonStatus_Hide();
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_LogonCompleted
//
//  Arguments:  iDialogResult   =   Dialog result code.
//              pszUsername     =   User name that tried to log on.
//              pszDomain       =   Domain of user.
//
//  Returns:    BOOL
//
//  Purpose:    Passes the dialog result code onto the CLogonDialog handler
//              if there is one present.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonDialog_LogonCompleted (INT_PTR iDialogResult, const WCHAR *pszUsername, const WCHAR *pszDomain)

{
    if (g_pLogonDialog != NULL)
    {
        g_pLogonDialog->Handle_LogonCompleted(iDialogResult, pszUsername, pszDomain);
    }
    else
    {
        _Shell_LogonStatus_Show();
    }
    g_fFirstLogon = false;
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_ShuttingDown
//
//  Arguments:  iDialogResult   =   Dialog result code.
//              pszUsername     =   User name that tried to log on.
//              pszDomain       =   Domain of user.
//
//  Returns:    BOOL
//
//  Purpose:    Passes the dialog result code onto the CLogonDialog handler
//              if there is one present.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonDialog_ShuttingDown (void)

{
    if (g_pLogonDialog != NULL)
    {
        g_pLogonDialog->Handle_ShuttingDown();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_ShowUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Show the external UI host if present. Otherwise do nothing.
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonDialog_ShowUIHost (void)

{
    if (g_pLogonDialog != NULL)
    {
        g_pLogonDialog->Handle_LogonShowUI();
    }
}

//  --------------------------------------------------------------------------
//  ::_Shell_LogonDialog_HideUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Hide the external UI host if present. Otherwise do nothing.
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    _Shell_LogonDialog_HideUIHost (void)

{
    if (g_pLogonDialog != NULL)
    {
        g_pLogonDialog->Handle_LogonHideUI();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\externalprocess.h ===
//  --------------------------------------------------------------------------
//  Module Name: ExternalProcess.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle premature termination of external processes or signaling
//  of termination of an external process.
//
//  History:    1999-09-20  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _ExternalProcess_
#define     _ExternalProcess_

#include "CountedObject.h"
#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  IExternalProcess
//
//  Purpose:    This interface defines functions that clients of
//              CExternalProcess must implement.
//
//  History:    1999-09-14  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-06-21  vtan        added RemoveTokenSIDsAndPrivileges
//  --------------------------------------------------------------------------

class   IExternalProcess : public CCountedObject
{
    public:
        virtual NTSTATUS    Start (const TCHAR *pszCommandLine,
                                   DWORD dwCreateFlags,
                                   const STARTUPINFO& startupInfo,
                                   PROCESS_INFORMATION& processInformation);
        virtual bool        AllowTermination (DWORD dwExitCode) = 0;
        virtual NTSTATUS    SignalTermination (void);
        virtual NTSTATUS    SignalAbnormalTermination (void);
        virtual NTSTATUS    SignalRestart (void);
    private:
                NTSTATUS    RemoveTokenSIDsAndPrivileges (HANDLE hTokenIn, HANDLE& hTokenOut);
};

//  --------------------------------------------------------------------------
//  CExternalProcess
//
//  Purpose:    This class handles the starting and monitoring the termination
//              of an external process.
//
//  History:    1999-09-14  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CJobCompletionWatcher;

class   CExternalProcess : public CCountedObject
{
    private:
                                            CExternalProcess (const CExternalProcess& copyObject);
                const CExternalProcess&     operator = (const CExternalProcess& assignObject);
    protected:
                                            CExternalProcess (void);
                                            ~CExternalProcess (void);
    public:
                void                        SetInterface (IExternalProcess *pIExternalProcess);
                IExternalProcess*           GetInterface (void)                     const;
                void                        SetParameter (const TCHAR* pszParameter);
                NTSTATUS                    Start (void);
                NTSTATUS                    End (void);
                NTSTATUS                    Terminate (void);
                bool                        HandleNoProcess (void);
                void                        HandleNewProcess (DWORD dwProcessID);
                void                        HandleTermination (DWORD dwProcessID);
                bool                        IsStarted (void)                                        const;
    protected:
        virtual void                        NotifyNoProcess (void);

                void                        AdjustForDebugging (void);
                bool                        IsBeingDebugged (void)                  const;
    private:
                bool                        IsPrefixedWithNTSD (void)               const;
                bool                        IsImageFileExecutionDebugging (void)    const;
    protected:
                HANDLE                      _hProcess;
                DWORD                       _dwProcessID,
                                            _dwProcessExitCode,
                                            _dwCreateFlags,
                                            _dwStartFlags;
                WORD                        _wShowFlags;
                int                         _iRestartCount;
                TCHAR                       _szCommandLine[MAX_PATH],
                                            _szParameter[MAX_PATH];
                CJob                        _job;
    private:
                IExternalProcess            *_pIExternalProcess;
                CJobCompletionWatcher       *_jobCompletionWatcher;
};

#endif  /*  _ExternalProcess_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logonwait.cpp ===
#include "StandardHeader.h"
#include "LogonWait.h"

#include "StatusCode.h"

CLogonWait::CLogonWait (void) :
    _hWait(NULL),
    _event(NULL),
    _pLogonExternalProcess(NULL)

{
}

CLogonWait::~CLogonWait (void)

{
    Cancel();
}

NTSTATUS    CLogonWait::Cancel (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        if (UnregisterWait(hWait) == FALSE)
        {
            TSTATUS(_event.Wait(INFINITE, NULL));
        }
        _pLogonExternalProcess->Release();
        _pLogonExternalProcess = NULL;
    }
    return(STATUS_SUCCESS);
}

NTSTATUS    CLogonWait::Register (HANDLE hObject, ILogonExternalProcess *pLogonExternalProcess)

{
    NTSTATUS    status;

    if (static_cast<HANDLE>(_event) != NULL)
    {
        status = Cancel();
        if (NT_SUCCESS(status))
        {
            pLogonExternalProcess->AddRef();
            TSTATUS(_event.Reset());
            if (RegisterWaitForSingleObject(&_hWait,
                                            hObject,
                                            CB_ObjectSignaled,
                                            this,
                                            INFINITE,
                                            WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) == FALSE)
            {
                pLogonExternalProcess->Release();
                status = CStatusCode::StatusCodeOfLastError();
            }
            else
            {
                _pLogonExternalProcess = pLogonExternalProcess;
                status = STATUS_SUCCESS;
            }
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

void    CLogonWait::ObjectSignaled (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    TSTATUS(_event.Set());
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
        TSTATUS(_pLogonExternalProcess->LogonRestart());
        _pLogonExternalProcess->Release();
        _pLogonExternalProcess = NULL;
    }
}

void    CALLBACK    CLogonWait::CB_ObjectSignaled (void *pV, BOOLEAN fTimedOut)

{
    UNREFERENCED_PARAMETER(fTimedOut);

    reinterpret_cast<CLogonWait*>(pV)->ObjectSignaled();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logonmutex.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: LogonMutex.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File that implements a class that manages a single global logon mutex.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "LogonMutex.h"

#include <msginaexports.h>

#include "Access.h"
#include "SystemSettings.h"

DWORD                       CLogonMutex::s_dwThreadID                   =   0;
LONG                        CLogonMutex::s_lAcquireCount                =   0;
HANDLE                      CLogonMutex::s_hMutex                       =   NULL;
HANDLE                      CLogonMutex::s_hMutexRequest                =   NULL;
HANDLE                      CLogonMutex::s_hEvent                       =   NULL;
const TCHAR                 CLogonMutex::s_szLogonMutexName[]           =   SZ_INTERACTIVE_LOGON_MUTEX_NAME;
const TCHAR                 CLogonMutex::s_szLogonRequestMutexName[]    =   SZ_INTERACTIVE_LOGON_REQUEST_MUTEX_NAME;
const TCHAR                 CLogonMutex::s_szLogonReplyEventName[]      =   SZ_INTERACTIVE_LOGON_REPLY_EVENT_NAME;
const TCHAR                 CLogonMutex::s_szShutdownEventName[]        =   SZ_SHUT_DOWN_EVENT_NAME;
SID_IDENTIFIER_AUTHORITY    CLogonMutex::s_SecurityNTAuthority          =   SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    CLogonMutex::s_SecurityWorldSID             =   SECURITY_WORLD_SID_AUTHORITY;

//  --------------------------------------------------------------------------
//  CLogonMutex::Acquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquires the mutex. Ensures that the mutex is only acquired
//              on the main thread of winlogon by an assert. The mutex should
//              never be abandoned within normal execution. However, a
//              process termination can cause this to happen.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::Acquire (void)

{
    DWORD   dwWaitResult;

    ASSERTMSG((s_dwThreadID == 0) || (s_dwThreadID == GetCurrentThreadId()), "Must acquire mutex on initializing thread in CLogonMutex::Acquire");
    if ((s_hMutex != NULL) && (WAIT_TIMEOUT == WaitForSingleObject(s_hEvent, 0)))
    {
        ASSERTMSG(s_lAcquireCount == 0, "Mutex already owned in CLogonMutex::Acquire");
        dwWaitResult = WaitForSingleObject(s_hMutex, INFINITE);
        ++s_lAcquireCount;
    }
}

//  --------------------------------------------------------------------------
//  CLogonMutex::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the mutex. Again makes sure the caller is the main
//              thread of winlogon. The acquisitions and releases are
//              reference counted to allow unbalanced release calls to be
//              made.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::Release (void)

{
    ASSERTMSG((s_dwThreadID == 0) || (s_dwThreadID == GetCurrentThreadId()), "Must acquire mutex on initializing thread in CLogonMutex::Release");
    if ((s_hMutex != NULL) && (s_lAcquireCount > 0))
    {
        TBOOL(ReleaseMutex(s_hMutex));
        --s_lAcquireCount;
    }
}

//  --------------------------------------------------------------------------
//  CLogonMutex::SignalReply
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Open the global logon reply event and signal it.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::SignalReply (void)

{
    HANDLE  hEvent;

    hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, s_szLogonReplyEventName);
    if (hEvent != NULL)
    {
        TBOOL(SetEvent(hEvent));
        TBOOL(CloseHandle(hEvent));
    }
}

//  --------------------------------------------------------------------------
//  CLogonMutex::SignalShutdown
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Signal the global shut down event. This will prevent further
//              interactive requests from being processed.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::SignalShutdown (void)

{
    if (s_hEvent != NULL)
    {
        TBOOL(SetEvent(s_hEvent));
    }
}

//  --------------------------------------------------------------------------
//  CLogonMutex::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the logon mutex objects based on whether this is
//              session 0 or higher and or what the product type is. Because
//              the initialization for session is done only the once this
//              requires a machine restart for the objects to be created.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::StaticInitialize (void)

{

    //  Check the machine settings. Must be friendly UI and PER/PRO (FUS).

    if (CSystemSettings::IsFriendlyUIActive() && CSystemSettings::IsMultipleUsersEnabled() && CSystemSettings::IsWorkStationProduct())
    {
        DWORD   dwErrorCode;

        s_dwThreadID = GetCurrentThreadId();
        s_lAcquireCount = 0;

        //  On session 0 create the objects and ACL them.

        if (NtCurrentPeb()->SessionId == 0)
        {
            s_hEvent = CreateShutdownEvent();
            if (s_hEvent != NULL)
            {
                s_hMutex = CreateLogonMutex();
                if (s_hMutex != NULL)
                {
                    s_hMutexRequest = CreateLogonRequestMutex();
                    if (s_hMutexRequest != NULL)
                    {
                        Acquire();
                        dwErrorCode = ERROR_SUCCESS;
                    }
                    else
                    {
                        dwErrorCode = GetLastError();
                    }
                }
                else
                {
                    dwErrorCode = GetLastError();
                }
            }
            else
            {
                dwErrorCode = GetLastError();
            }
        }
        else
        {

            //  For sessions other than 0 open the objects.

            s_hEvent = OpenShutdownEvent();
            if (s_hEvent != NULL)
            {
                if (WAIT_TIMEOUT == WaitForSingleObject(s_hEvent, 0))
                {
                    s_hMutex = OpenLogonMutex();
                    if (s_hMutex != NULL)
                    {
                        Acquire();
                        dwErrorCode = ERROR_SUCCESS;
                    }
                    else
                    {
                        dwErrorCode = GetLastError();
                    }
                }
                else
                {
                    dwErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
                }
            }
            else
            {
                dwErrorCode = GetLastError();
            }
        }
        if (ERROR_SUCCESS == dwErrorCode)
        {
            ASSERTMSG(s_hMutex != NULL, "NULL s_hMutex in CLogonMutex::StaticInitialize");
            ASSERTMSG(s_hEvent != NULL, "NULL s_hEvent in CLogonMutex::StaticInitialize");
        }
        else
        {
            ReleaseHandle(s_hEvent);
            ReleaseHandle(s_hMutex);
            s_dwThreadID = 0;
        }
    }
    else
    {
        s_dwThreadID = 0;
        s_lAcquireCount = 0;
        s_hMutex = NULL;
        s_hEvent = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CLogonMutex::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the mutex if held and closes the object handle.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CLogonMutex::StaticTerminate (void)

{
    Release();
    ASSERTMSG(s_lAcquireCount == 0, "Mutex not released in CLogonMutex::StaticTerminate");
    ReleaseHandle(s_hMutex);
}

//  --------------------------------------------------------------------------
//  CLogonMutex::CreateShutdownEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Creates the global shut down event. ACL'd so that anybody can
//              synchronize against it and therefore listen but only SYSTEM
//              can set it to indicate machine shut down has begun.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonMutex::CreateShutdownEvent (void)

{
    HANDLE                  hEvent;
    SECURITY_ATTRIBUTES     securityAttributes;

    //  Build a security descriptor for the event that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     EVENT_ALL_ACCESS
    //      S-1-5-32-544    <local administrators>  READ_CONTROL | SYNCHRONIZE
    //      S-1-1-0         <everybody>             SYNCHRONIZE

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            EVENT_ALL_ACCESS
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            READ_CONTROL | SYNCHRONIZE
        },
        {
            &s_SecurityWorldSID,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            SYNCHRONIZE
        }
    };

    securityAttributes.nLength = sizeof(securityAttributes);
    securityAttributes.lpSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    securityAttributes.bInheritHandle = FALSE;
    hEvent = CreateEvent(&securityAttributes, TRUE, FALSE, s_szShutdownEventName);
    if (securityAttributes.lpSecurityDescriptor != NULL)
    {
        (HLOCAL)LocalFree(securityAttributes.lpSecurityDescriptor);
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  CLogonMutex::CreateLogonMutex
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Creates the global logon mutex. ACL'd so that only SYSTEM can
//              acquire and release the mutex. This is not for user
//              consumption.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonMutex::CreateLogonMutex (void)

{
    HANDLE                  hMutex;
    SECURITY_ATTRIBUTES     securityAttributes;

    //  Build a security descriptor for the mutex that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     MUTEX_ALL_ACCESS

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            MUTEX_ALL_ACCESS
        }
    };

    securityAttributes.nLength = sizeof(securityAttributes);
    securityAttributes.lpSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    securityAttributes.bInheritHandle = FALSE;
    hMutex = CreateMutex(&securityAttributes, FALSE, s_szLogonMutexName);
    if (securityAttributes.lpSecurityDescriptor != NULL)
    {
        (HLOCAL)LocalFree(securityAttributes.lpSecurityDescriptor);
    }
    return(hMutex);
}

//  --------------------------------------------------------------------------
//  CLogonMutex::CreateLogonRequestMutex
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Creates the logon request mutex for interactive logon
//              requests. For a service to make this request it must acquire
//              the mutex and therefore only a single request can be made at
//              any one time. This is ACL'd so that only SYSTEM can gain
//              access to this object.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonMutex::CreateLogonRequestMutex (void)

{
    HANDLE                  hMutex;
    SECURITY_ATTRIBUTES     securityAttributes;

    //  Build a security descriptor for the mutex that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     MUTEX_ALL_ACCESS

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            MUTEX_ALL_ACCESS
        }
    };

    securityAttributes.nLength = sizeof(securityAttributes);
    securityAttributes.lpSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    securityAttributes.bInheritHandle = FALSE;
    
    if (securityAttributes.lpSecurityDescriptor)
    {
        hMutex = CreateMutex(&securityAttributes, FALSE, s_szLogonRequestMutexName);

        LocalFree(securityAttributes.lpSecurityDescriptor);
        securityAttributes.lpSecurityDescriptor = NULL;
    }
    else
    {
        hMutex = NULL;
    }

    return hMutex;
}

//  --------------------------------------------------------------------------
//  CLogonMutex::OpenShutdownEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens a handle to the global shut down event.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonMutex::OpenShutdownEvent (void)

{
    return(OpenEvent(SYNCHRONIZE | EVENT_MODIFY_STATE, FALSE, s_szShutdownEventName));
}

//  --------------------------------------------------------------------------
//  CLogonMutex::OpenLogonMutex
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens a handle to the global logon mutex.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CLogonMutex::OpenLogonMutex (void)

{
    return(OpenMutex(SYNCHRONIZE | MUTEX_MODIFY_STATE, FALSE, s_szLogonMutexName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\logonwait.h ===
#ifndef     _LogonWait_
#define     _LogonWait_

#include "ExternalProcess.h"
#include "KernelResources.h"

class   ILogonExternalProcess : public IExternalProcess
{
    public:
        virtual NTSTATUS    LogonRestart (void) = 0;
};

class   CLogonWait
{
    public:
        CLogonWait (void);
        virtual ~CLogonWait (void);

        NTSTATUS    Cancel (void);
        NTSTATUS    Register (HANDLE hObject, ILogonExternalProcess *pLogonExternalProcess);
    private:
                void                ObjectSignaled (void);
        static  void    CALLBACK    CB_ObjectSignaled (void *pV, BOOLEAN fTimedOut);
    private:
        HANDLE          _hWait;
        CEvent          _event;
        ILogonExternalProcess   *_pLogonExternalProcess;
};

#endif  /*  _LogonWait_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\powerbutton.h ===
//  --------------------------------------------------------------------------
//  Module Name: PowerButton.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Header file that declares the class that implements the ACPI power button
//  functionality.
//
//  History:    2000-04-17  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _PowerButton_
#define     _PowerButton_

#include "Thread.h"
#include "TurnOffDialog.h"

//  --------------------------------------------------------------------------
//  CPowerButton
//
//  Purpose:    A class to handle the power button being pressed. This is
//              implemented as a thread to allow the desktop to be changed so
//              interaction with the user is possible.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

class   CPowerButton : public CThread
{
    private:
                                        CPowerButton (void);
                const CPowerButton&     operator = (const CPowerButton& assignObject);
    public:
                                        CPowerButton (void *pWlxContext, HINSTANCE hDllInstance);
        virtual                         ~CPowerButton (void);

        static  bool                    IsValidExecutionCode (DWORD dwGinaCode);
    protected:
        virtual DWORD                   Entry (void);
    private:
                DWORD                   ShowDialog (void);

        static  INT_PTR     CALLBACK    DialogProc (HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam);
                INT_PTR                 Handle_WM_READY (HWND hwndDialog);
    private:
                void*                   _pWlxContext;
                const HINSTANCE         _hDllInstance;
                HANDLE                  _hToken;
                CTurnOffDialog*         _pTurnOffDialog;
                bool                    _fCleanCompletion;
};

//  --------------------------------------------------------------------------
//  CPowerButtonExecution
//
//  Purpose:    A class to execute the power button action in a separate
//              thread so the SASWndProc thread is not blocked.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

class   CPowerButtonExecution : public CThread
{
    private:
                                                CPowerButtonExecution (void);
                                                CPowerButtonExecution (const CPowerButtonExecution& copyObject);
                const CPowerButtonExecution&    operator = (const CPowerButtonExecution& assignObject);
    public:
                                                CPowerButtonExecution (DWORD dwShutdownRequest);
                                                ~CPowerButtonExecution (void);
    protected:
        virtual DWORD                           Entry (void);
    private:
                const DWORD                     _dwShutdownRequest;
                HANDLE                          _hToken;
};

#endif  /*  _PowerButton_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\privilegeenable.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: PrivilegeEnable.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "PrivilegeEnable.h"

//  --------------------------------------------------------------------------
//  CThreadToken::CThreadToken
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CThreadToken object. Try the thread token
//              first and if this fails try the process token.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CThreadToken::CThreadToken (DWORD dwDesiredAccess) :
    _hToken(NULL)

{
    if (OpenThreadToken(GetCurrentThread(), dwDesiredAccess, FALSE, &_hToken) == FALSE)
    {
        TBOOL(OpenProcessToken(GetCurrentProcess(), dwDesiredAccess, &_hToken));
    }
}

//  --------------------------------------------------------------------------
//  CThreadToken::~CThreadToken
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CThreadToken object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CThreadToken::~CThreadToken (void)

{
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CThreadToken::~CThreadToken
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CThreadToken to a HANDLE.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CThreadToken::operator HANDLE (void)                                const

{
    return(_hToken);
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::CPrivilegeEnable
//
//  Arguments:  pszName     =   Name of the privilege to enable.
//
//  Returns:    <none>
//
//  Purpose:    Gets the current state of the privilege and enables it. The
//              privilege is specified by name and looked up.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::CPrivilegeEnable (const TCHAR *pszName) :
    _fSet(false),
    _hToken(TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY)

{
    TOKEN_PRIVILEGES    newPrivilege;

    if (LookupPrivilegeValue(NULL, pszName, &newPrivilege.Privileges[0].Luid) != FALSE)
    {
        DWORD   dwReturnTokenPrivilegesSize;

        newPrivilege.PrivilegeCount = 1;
        newPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        _fSet = (AdjustTokenPrivileges(_hToken, FALSE, &newPrivilege, sizeof(newPrivilege), &_oldPrivilege, &dwReturnTokenPrivilegesSize) != FALSE);
    }
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::~CPrivilegeEnable
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Restores the previous state of the privilege prior to
//              instantiation of the object.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::~CPrivilegeEnable (void)

{
    if (_fSet)
    {
        TBOOL(AdjustTokenPrivileges(_hToken, FALSE, &_oldPrivilege, 0, NULL, NULL));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\privilegeenable.h ===
//  --------------------------------------------------------------------------
//  Module Name: PrivilegeEnable.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _PrivilegeEnable_
#define     _PrivilegeEnable_

//  --------------------------------------------------------------------------
//  CThreadToken
//
//  Purpose:    This class gets the current thread's token. If the thread is
//              not impersonating it gets the current process' token.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CThreadToken
{
    private:
                                CThreadToken (void);
                                CThreadToken (const CThreadToken& copyObject);
        bool                    operator == (const CThreadToken& compareObject)     const;
        const CThreadToken&     operator = (const CThreadToken& assignObject);
    public:
                                CThreadToken (DWORD dwDesiredAccess);
                                ~CThreadToken (void);

                                operator HANDLE (void)                              const;
    private:
        HANDLE                  _hToken;
};

//  --------------------------------------------------------------------------
//  CPrivilegeEnable
//
//  Purpose:    This class enables a privilege for the duration of its scope.
//              The privilege is restored to its original state on
//              destruction.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CPrivilegeEnable
{
    private:
                                    CPrivilegeEnable (void);
                                    CPrivilegeEnable (const CPrivilegeEnable& copyObject);
        const CPrivilegeEnable&     operator = (const CPrivilegeEnable& assignObject);
    public:
                                    CPrivilegeEnable (const TCHAR *pszName);
                                    ~CPrivilegeEnable (void);
    private:
        bool                        _fSet;
        CThreadToken                _hToken;
        TOKEN_PRIVILEGES            _oldPrivilege;
};

#endif  /*  _PrivilegeEnable_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\powerbutton.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: PowerButton.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Implementation file for CPowerButton class which handles the ACPI power
//  button.
//
//  History:    2000-04-17  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "PowerButton.h"

#include <msginaexports.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shellapi.h>
#include <shlapip.h>
#include <winsta.h>

#include <ginarcid.h>

#include "DimmedWindow.h"
#include "Impersonation.h"
#include "PrivilegeEnable.h"
#include "SystemSettings.h"

#define WM_HIDEOURSELVES    (WM_USER + 10000)
#define WM_READY            (WM_USER + 10001)

//  --------------------------------------------------------------------------
//  CPowerButton::CPowerButton
//
//  Arguments:  pWlxContext     =   PGLOBALS allocated at WlxInitialize.
//              hDllInstance    =   HINSTANCE of the hosting DLL or EXE.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CPowerButton class. It opens the effective
//              token of the caller (which is actually impersonating the
//              current user) for assignment in its thread token when
//              execution begins. The token cannot be assigned now because
//              the current thread is impersonating the user context and it
//              cannot assign the token to the newly created thread running in
//              the SYSTEM context.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

CPowerButton::CPowerButton (void *pWlxContext, HINSTANCE hDllInstance) :
    CThread(),
    _pWlxContext(pWlxContext),
    _hDllInstance(hDllInstance),
    _hToken(NULL),
    _pTurnOffDialog(NULL),
    _fCleanCompletion(true)

{
    (BOOL)OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, FALSE, &_hToken);
    Resume();
}

//  --------------------------------------------------------------------------
//  CPowerButton::~CPowerButton
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CPowerButton class. Cleans up resources
//              used by the class.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

CPowerButton::~CPowerButton (void)

{
    ASSERTMSG(_pTurnOffDialog == NULL, "_pTurnOffDialog is not NULL in CPowerButton::~CPowerButton");
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CPowerButton::IsValidExecutionCode
//
//  Arguments:  dwGinaCode
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given MSGINA_DLG_xxx code is valid. It
//              does fully verify the validity of the MSGINA_DLG_xxx_FLAG
//              options.
//
//  History:    2000-06-06  vtan        created
//  --------------------------------------------------------------------------

bool    CPowerButton::IsValidExecutionCode (DWORD dwGinaCode)

{
    DWORD   dwExecutionCode;

    dwExecutionCode = dwGinaCode & ~MSGINA_DLG_FLAG_MASK;
    return((dwExecutionCode == MSGINA_DLG_USER_LOGOFF) ||
           (dwExecutionCode == MSGINA_DLG_SHUTDOWN) ||
           (dwExecutionCode == MSGINA_DLG_DISCONNECT));
}

//  --------------------------------------------------------------------------
//  CPowerButton::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Main function of the thread. Change the thread's desktop first
//              in case the actual input desktop is Winlogon's which is the
//              secure desktop. Then change the thread's token so that the
//              user's privileges are respected in the action choices. This
//              actually isn't critical because the physical button on the
//              keyboard is pressed which means they can physically remove the
//              power also!
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

DWORD   CPowerButton::Entry (void)

{
    DWORD       dwResult;
    HDESK       hDeskInput;
    CDesktop    desktop;

    dwResult = MSGINA_DLG_FAILURE;

    //  Get the input desktop.

    hDeskInput = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (hDeskInput != NULL)
    {
        bool    fHandled;
        DWORD   dwLengthNeeded;
        TCHAR   szDesktopName[256];

        fHandled = false;

        //  Get the desktop's name.

        if (GetUserObjectInformation(hDeskInput,
                                     UOI_NAME,
                                     szDesktopName,
                                     sizeof(szDesktopName),
                                     &dwLengthNeeded) != FALSE)
        {

            //  If the desktop is "Winlogon" (case insensitive) then
            //  assume that the secure desktop is showing. It's safe
            //  to display the dialog and handle it inline.

            if (lstrcmpi(szDesktopName, TEXT("winlogon")) == 0)
            {
                dwResult = ShowDialog();
                fHandled = true;
            }
            else
            {
                CDesktop    desktopTemp;

                //  The input desktop is something else. Check the name.
                //  If it's "Default" (case insensitive) then assume that
                //  explorer is going to handle this message. Go find explorer's
                //  tray window. Check it's not hung by probing with a
                //  SendMessageTimeout. If that shows it's not hung then
                //  send it the real message. If it's hung then don't let
                //  explorer process this message. Instead handle it
                //  internally with the funky desktop switch stuff.

                if (NT_SUCCESS(desktopTemp.SetInput()))
                {
                    HWND    hwnd;

                    hwnd = FindWindow(TEXT("Shell_TrayWnd"), NULL);
                    if (hwnd != NULL)
                    {
                        DWORD   dwProcessID;

                        DWORD_PTR   dwUnused;

                        (DWORD)GetWindowThreadProcessId(hwnd, &dwProcessID);
                        if (SendMessageTimeout(hwnd, WM_NULL, 0, 0, SMTO_NORMAL, 500, &dwUnused) != 0)
                        {

                            //  Before asking explorer to bring up the dialog
                            //  allow it to set the foreground window. We have
                            //  this power because win32k gave it to us when
                            //  the ACPI power button message was sent to winlogon.

                            (BOOL)AllowSetForegroundWindow(dwProcessID);
                            (LRESULT)SendMessage(hwnd, WM_CLOSE, 0, 0);
                            fHandled = true;
                        }
                    }
                }
            }
        }

        //  If the request couldn't be handled then switch the desktop to
        //  winlogon's desktop and handle it here. This secures the dialog
        //  on the secure desktop from rogue processes sending bogus messages
        //  and crashing processes. The input desktop is required to be
        //  switched. If this fails there's little that can be done. Ignore
        //  this gracefully.

        if (!fHandled)
        {
            if (SwitchDesktop(GetThreadDesktop(GetCurrentThreadId())) != FALSE)
            {
                dwResult = ShowDialog();
                TBOOL(SwitchDesktop(hDeskInput));
            }
        }
    }
    (BOOL)CloseDesktop(hDeskInput);
    return(dwResult);
}

//  --------------------------------------------------------------------------
//  CPowerButton::ShowDialog
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Handles showing the dialog. This is called when the input
//              desktop is already winlogon's desktop or the desktop got
//              switched to winlogon's desktop. This should never be used on
//              WinSta0\Default in winlogon's process context.
//
//  History:    2001-02-14  vtan        created
//  --------------------------------------------------------------------------

DWORD   CPowerButton::ShowDialog (void)

{
    DWORD   dwResult;
    bool    fCorrectContext;

    dwResult = MSGINA_DLG_FAILURE;
    if (_hToken != NULL)
    {
        fCorrectContext = (ImpersonateLoggedOnUser(_hToken) != FALSE);
    }
    else
    {
        fCorrectContext = true;
    }
    if (fCorrectContext)
    {
        TBOOL(_Gina_SetTimeout(_pWlxContext, LOGON_TIMEOUT));

        //  In friendly UI bring up a Win32 dialog thru winlogon which
        //  will get SAS and timeout events. Use this dialog to control
        //  the lifetime of the friendly Turn Off Computer dialog.

        if (CSystemSettings::IsFriendlyUIActive())
        {
            dwResult = static_cast<DWORD>(_Gina_DialogBoxParam(_pWlxContext,
                                                               _hDllInstance,
                                                               MAKEINTRESOURCE(IDD_GINA_TURNOFFCOMPUTER),
                                                               NULL,
                                                               DialogProc,
                                                               reinterpret_cast<LPARAM>(this)));
        }

        //  In classic UI just bring up the classic UI dialog.
        //  Ensure that invalid options are not allowed in the
        //  combobox selections. This depends on whether a user
        //  is logged onto the window station or not.

        else
        {
            DWORD           dwExcludeOptions;
            HWND            hwndParent;
            CDimmedWindow   *pDimmedWindow;

            pDimmedWindow = new CDimmedWindow(_hDllInstance);
            if (pDimmedWindow != NULL)
            {
                hwndParent = pDimmedWindow->Create();
            }
            else
            {
                hwndParent = NULL;
            }
            if (_hToken != NULL)
            {
                dwExcludeOptions = SHTDN_RESTART_DOS | SHTDN_SLEEP2;
            }
            else
            {
                dwExcludeOptions = SHTDN_LOGOFF | SHTDN_RESTART_DOS | SHTDN_SLEEP2 | SHTDN_DISCONNECT;
            }
            dwResult = static_cast<DWORD>(_Gina_ShutdownDialog(_pWlxContext, hwndParent, dwExcludeOptions));
            if (pDimmedWindow != NULL)
            {
                pDimmedWindow->Release();
            }
        }
        TBOOL(_Gina_SetTimeout(_pWlxContext, 0));
    }
    if (fCorrectContext && (_hToken != NULL))
    {
        TBOOL(RevertToSelf());
    }
    return(dwResult);
}

//  --------------------------------------------------------------------------
//  CPowerButton::DialogProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    INT_PTR
//
//  Purpose:    Handles dialog messages from the dialog manager. In particular
//              this traps SAS messages from winlogon.
//
//  History:    2000-06-06  vtan        created
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CPowerButton::DialogProc (HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR         iResult;
    CPowerButton    *pThis;

    pThis = reinterpret_cast<CPowerButton*>(GetWindowLongPtr(hwndDialog, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            (LONG_PTR)SetWindowLongPtr(hwndDialog, GWLP_USERDATA, lParam);
            TBOOL(SetWindowPos(hwndDialog, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER));
            TBOOL(PostMessage(hwndDialog, WM_HIDEOURSELVES, 0, 0));
            iResult = TRUE;
            break;
        }
        case WM_HIDEOURSELVES:
        {
            (BOOL)ShowWindow(hwndDialog, SW_HIDE);
            TBOOL(PostMessage(hwndDialog, WM_READY, 0, 0));
            iResult = TRUE;
            break;
        }
        case WM_READY:
        {
            pThis->Handle_WM_READY(hwndDialog);
            iResult = TRUE;
            break;
        }
        case WLX_WM_SAS:
        {

            //  Blow off CONTROL-ALT-DELETE presses.

            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
            {
                iResult = TRUE;
            }
            else
            {

        //  This dialog gets a WM_NULL from the Win32 dialog manager
        //  when the dialog is ended from a timeout. This is input
        //  timeout and not a screen saver timeout. Screen saver
        //  timeouts will cause a WLX_SAS_TYPE_SCRNSVR_TIMEOUT to
        //  be generated which is handled by RootDlgProc in winlogon.
        //  The input timeout should be treated the same as the screen
        //  saver timeout and cause the Turn Off dialog to go away.

        case WM_NULL:
                if (pThis->_pTurnOffDialog != NULL)
                {
                    pThis->_pTurnOffDialog->Destroy();
                }
                pThis->_fCleanCompletion = false;
                iResult = FALSE;
            }
            break;
        }
        default:
        {
            iResult = FALSE;
            break;
        }
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CPowerButton::Handle_WM_READY
//
//  Arguments:  hwndDialog  =   HWND of the hosting dialog.
//
//  Returns:    <none>
//
//  Purpose:    Handles showing the Turn Off Computer dialog hosted under
//              another dialog to trap SAS messages. Only change the returned
//              code via user32!EndDialog if the dialog was ended normally.
//              In abnormal circumstances winlogon has ended the dialog for
//              us with a specific code (e.g. screen saver timeout).
//
//  History:    2000-06-06  vtan        created
//  --------------------------------------------------------------------------

INT_PTR     CPowerButton::Handle_WM_READY (HWND hwndDialog)

{
    INT_PTR     iResult;

    iResult = SHTDN_NONE;
    _pTurnOffDialog = new CTurnOffDialog(_hDllInstance);
    if (_pTurnOffDialog != NULL)
    {
        iResult = _pTurnOffDialog->Show(NULL);
        delete _pTurnOffDialog;
        _pTurnOffDialog = NULL;
        if (_fCleanCompletion)
        {
            TBOOL(EndDialog(hwndDialog, CTurnOffDialog::ShellCodeToGinaCode(static_cast<DWORD>(iResult))));
        }
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CPowerButtonExecution::CPowerButtonExecution
//
//  Arguments:  dwShutdownRequest   =   SHTDN_xxx request.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CPowerButtonExecution class. Invokes the
//              appropriate shutdown request on a different thread so the
//              SASWndProc thread is NOT blocked.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

CPowerButtonExecution::CPowerButtonExecution (DWORD dwShutdownRequest) :
    CThread(),
    _dwShutdownRequest(dwShutdownRequest),
    _hToken(NULL)

{
    (BOOL)OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, FALSE, &_hToken);
    Resume();
}

//  --------------------------------------------------------------------------
//  CPowerButtonExecution::~CPowerButtonExecution
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CPowerButtonExecution class. Releases
//              resources used by the class.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

CPowerButtonExecution::~CPowerButtonExecution (void)

{
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CPowerButtonExecution::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Main entry function. This performs the request and exits the
//              thread.
//
//  History:    2000-04-18  vtan        created
//  --------------------------------------------------------------------------

DWORD   CPowerButtonExecution::Entry (void)

{
    bool    fCorrectContext;

    if (_hToken != NULL)
    {
        fCorrectContext = (ImpersonateLoggedOnUser(_hToken) != FALSE);
    }
    else
    {
        fCorrectContext = true;
    }
    if (fCorrectContext)
    {
        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        switch (_dwShutdownRequest & ~MSGINA_DLG_FLAG_MASK)
        {
            case MSGINA_DLG_USER_LOGOFF:
            case MSGINA_DLG_SHUTDOWN:
            {
                DWORD   dwRequestFlags;

                dwRequestFlags = _dwShutdownRequest & MSGINA_DLG_FLAG_MASK;
                switch (dwRequestFlags)
                {
                    case 0:
                    case MSGINA_DLG_SHUTDOWN_FLAG:
                    case MSGINA_DLG_REBOOT_FLAG:
                    case MSGINA_DLG_POWEROFF_FLAG:
                    {
                        UINT    uiFlags;

                        if (dwRequestFlags == 0)
                        {
                            uiFlags = EWX_LOGOFF;
                        }
                        else if (dwRequestFlags == MSGINA_DLG_REBOOT_FLAG)
                        {
                            uiFlags = EWX_WINLOGON_OLD_REBOOT;
                        }
                        else
                        {
                            SYSTEM_POWER_CAPABILITIES   spc;

                            (NTSTATUS)NtPowerInformation(SystemPowerCapabilities,
                                                         NULL,
                                                         0,
                                                         &spc,
                                                         sizeof(spc));
                            if (spc.SystemS4)
                            {
                                uiFlags = EWX_WINLOGON_OLD_POWEROFF;
                            }
                            else
                            {
                                uiFlags = EWX_WINLOGON_OLD_SHUTDOWN;
                            }
                        }
                        TBOOL(ExitWindowsEx(uiFlags, 0));
                        break;
                    }
                    case MSGINA_DLG_SLEEP_FLAG:
                    case MSGINA_DLG_SLEEP2_FLAG:
                    case MSGINA_DLG_HIBERNATE_FLAG:
                    {
                        POWER_ACTION    pa;

                        if (dwRequestFlags == MSGINA_DLG_HIBERNATE_FLAG)
                        {
                            pa = PowerActionHibernate;
                        }
                        else
                        {
                            pa = PowerActionSleep;
                        }
                        (NTSTATUS)NtInitiatePowerAction(pa,
                                                        PowerSystemSleeping1,
                                                        POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED,
                                                        FALSE);
                        break;
                    }
                    default:
                    {
                        WARNINGMSG("Unknown MSGINA_DLG_xxx_FLAG used in CPowerButtonExecution::Entry");
                        break;
                    }
                }
                break;
            }
            case MSGINA_DLG_DISCONNECT:
            {
                (BOOLEAN)WinStationDisconnect(SERVERNAME_CURRENT, LOGONID_CURRENT, FALSE);
                break;
            }
            default:
            {
                WARNINGMSG("Unknown MSGINA_DLG_xxx_ used in CPowerButtonExecution::Entry");
                break;
            }
        }
    }
    if (fCorrectContext && (_hToken != NULL))
    {
        TBOOL(RevertToSelf());
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\returntowelcome.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ReturnToWelcome.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File to handle return to welcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ReturnToWelcome.h"

#include <ginaipc.h>
#include <ginarcid.h>
#include <msginaexports.h>
#include <winsta.h>
#include <winwlx.h>

#include "Access.h"
#include "Compatibility.h"
#include "CredentialTransfer.h"
#include "StatusCode.h"
#include "SystemSettings.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CReturnToWelcome::s_pWlxContext
//  CReturnToWelcome::s_hEventRequest
//  CReturnToWelcome::s_hEventShown
//  CReturnToWelcome::s_hWait
//  CReturnToWelcome::s_szEventName
//  CReturnToWelcome::s_dwSessionID
//
//  Purpose:    Static member variables.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

void*           CReturnToWelcome::s_pWlxContext     =   NULL;
HANDLE          CReturnToWelcome::s_hEventRequest   =   NULL;
HANDLE          CReturnToWelcome::s_hEventShown     =   NULL;
HANDLE          CReturnToWelcome::s_hWait           =   NULL;
const TCHAR     CReturnToWelcome::s_szEventName[]   =   TEXT("msgina: ReturnToWelcome");
DWORD           CReturnToWelcome::s_dwSessionID     =   static_cast<DWORD>(-1);

//  --------------------------------------------------------------------------
//  CReturnToWelcome::CReturnToWelcome
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CReturnToWelcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

CReturnToWelcome::CReturnToWelcome (void) :
    _hToken(NULL),
    _pLogonIPCCredentials(NULL),
    _fUnlock(false),
    _fDialogEnded(false)

{
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::~CReturnToWelcome
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CReturnToWelcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

CReturnToWelcome::~CReturnToWelcome (void)

{
    ReleaseMemory(_pLogonIPCCredentials);
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::Show
//
//  Arguments:  fUnlock     =   Required to unlock logon mode or not?
//
//  Returns:    INT_PTR
//
//  Purpose:    Presents the welcome screen with a logged on user. This is a
//              special case to increase performance by not performing
//              needless console disconnects and reconnects.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

INT_PTR     CReturnToWelcome::Show (bool fUnlock)

{
    INT_PTR     iResult;

    _fUnlock = fUnlock;

    //  If there was a reconnect failure then show it before showing the UI host.

    if (s_dwSessionID != static_cast<DWORD>(-1))
    {
        ShowReconnectFailure(s_dwSessionID);
        s_dwSessionID = static_cast<DWORD>(-1);
    }

    //  Start the status host.

    _Shell_LogonStatus_Init(HOST_START_NORMAL);

    //  Disable input timeouts on this dialog.

    TBOOL(_Gina_SetTimeout(s_pWlxContext, 0));

    //  Use the DS component of msgina to display the dialog. It's a stub
    //  dialog that pretends to be WlxLoggedOutSAS but really isn't.

    iResult = _Gina_DialogBoxParam(s_pWlxContext,
                                   hDllInstance,
                                   MAKEINTRESOURCE(IDD_GINA_RETURNTOWELCOME),
                                   NULL,
                                   CB_DialogProc,
                                   reinterpret_cast<LPARAM>(this));

    //  The dialog has been shown. Release the CB_Request thread to
    //  re-register the wait on the switch user event.

    if (s_hEventShown != NULL)
    {
        TBOOL(SetEvent(s_hEventShown));
    }

    //  Handle MSGINA_DLG_SWITCH_CONSOLE and map this to WLX_SAS_ACTION_LOGON.
    //  This is an authenticated logon from a different session causing
    //  this one to get disconnected.

    if (iResult == MSGINA_DLG_SWITCH_CONSOLE)
    {
        iResult = WLX_SAS_ACTION_LOGON;
    }

    //  Look at the return code and respond accordingly. Map power button
    //  actions to the appropriate WLX_SAS_ACTION_SHUTDOWN_xxx.

    else if (iResult == (MSGINA_DLG_SHUTDOWN | MSGINA_DLG_REBOOT_FLAG))
    {
        iResult = WLX_SAS_ACTION_SHUTDOWN_REBOOT;
    }
    else if (iResult == (MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SHUTDOWN_FLAG))
    {
        iResult = WLX_SAS_ACTION_SHUTDOWN;
    }
    else if (iResult == (MSGINA_DLG_SHUTDOWN | MSGINA_DLG_POWEROFF_FLAG))
    {
        iResult = WLX_SAS_ACTION_SHUTDOWN_POWER_OFF;
    }
    else if (iResult == (MSGINA_DLG_SHUTDOWN | MSGINA_DLG_HIBERNATE_FLAG))
    {
        iResult = WLX_SAS_ACTION_SHUTDOWN_HIBERNATE;
    }
    else if (iResult == (MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP_FLAG))
    {
        iResult = WLX_SAS_ACTION_SHUTDOWN_SLEEP;
    }
    else if (iResult == MSGINA_DLG_LOCK_WORKSTATION)
    {
        iResult = WLX_SAS_ACTION_LOCK_WKSTA;
    }
    else if (iResult == WLX_DLG_USER_LOGOFF)
    {
        iResult = WLX_SAS_ACTION_LOGOFF;
    }
    else if (iResult == MSGINA_DLG_SUCCESS)
    {
        PSID    pSIDNew;

        pSIDNew = NULL;
        if (_hToken != NULL)
        {
            PSID                pSID;
            CTokenInformation   tokenInformationNew(_hToken);

            pSID = tokenInformationNew.GetUserSID();
            if (pSID != NULL)
            {
                DWORD   dwSIDSize;

                dwSIDSize = GetLengthSid(pSID);
                pSIDNew = LocalAlloc(LMEM_FIXED, dwSIDSize);
                if (pSIDNew != NULL)
                {
                    TBOOL(CopySid(dwSIDSize, pSIDNew, pSID));
                }
            }
        }
        if (pSIDNew == NULL)
        {
            DWORD           dwSIDSize, dwDomainSize;
            SID_NAME_USE    sidNameUse;
            WCHAR           *pszDomain;

            dwSIDSize = dwDomainSize = 0;
            (BOOL)LookupAccountNameW(NULL,
                                     _pLogonIPCCredentials->userID.wszUsername,
                                     NULL,
                                     &dwSIDSize,
                                     NULL,
                                     &dwDomainSize,
                                     &sidNameUse);
            pszDomain = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwDomainSize * sizeof(WCHAR)));
            if (pszDomain != NULL)
            {
                pSIDNew = LocalAlloc(LMEM_FIXED, dwSIDSize);
                if (pSIDNew != NULL)
                {
                    if (LookupAccountNameW(NULL,
                                           _pLogonIPCCredentials->userID.wszUsername,
                                           pSIDNew,
                                           &dwSIDSize,
                                           pszDomain,
                                           &dwDomainSize,
                                           &sidNameUse) == FALSE)
                    {
                        (HLOCAL)LocalFree(pSIDNew);
                        pSIDNew = NULL;
                    }
                }
                (HLOCAL)LocalFree(pszDomain);
            }
        }
        if (pSIDNew != NULL)
        {

            //  If the dialog succeeded then a user was authenticated.

            if (IsSameUser(pSIDNew, _Gina_GetUserToken(s_pWlxContext)))
            {

                //  If it's the same user then there's no disconnect or reconnect
                //  required. We're done. Return back to the user's desktop.

                iResult = WLX_SAS_ACTION_LOGON;
            }
            else
            {
                DWORD   dwSessionID;

                //  Assume something will fail. The return code
                //  MSGINA_DLG_SWITCH_FAILURE is a special message back to
                //  winlogon!HandleSwitchUser to signal that a
                //  reconnect/disconnect of some kind failed and that the
                //  welcome screen needs to be re-displayed along with an
                //  appropriate error message.

                iResult = MSGINA_DLG_SWITCH_FAILURE;
                if (UserIsDisconnected(pSIDNew, &dwSessionID))
                {

                    //  If the user is a disconnected user then reconnect back to
                    //  their session. If this succeeds then we're done.

                    if (WinStationConnect(SERVERNAME_CURRENT,
                                          dwSessionID,
                                          NtCurrentPeb()->SessionId,
                                          L"",
                                          TRUE) != FALSE)
                    {
                        CCompatibility::MinimizeWindowsOnDisconnect();
                        CCompatibility::DropSessionProcessesWorkingSets();
                        iResult = WLX_SAS_ACTION_LOGON;
                    }
                    else
                    {

                        //  If it fails then stash this information globally.
                        //  The return code MSGINA_DLG_SWITCH_FAILURE will cause
                        //  us to get called again and this will be checked, used
                        //  and reset.

                        s_dwSessionID = dwSessionID;
                    }
                }
                else
                {

                    //  Otherwise credentials need to be transferred across sessions to
                    //  a newly created session. Start the credential transfer server.

                    if (NT_SUCCESS(CCredentialServer::Start(_pLogonIPCCredentials, 0)))
                    {
                        CCompatibility::MinimizeWindowsOnDisconnect();
                        CCompatibility::DropSessionProcessesWorkingSets();
                        iResult = WLX_SAS_ACTION_LOGON;
                    }
                }
            }
            (HLOCAL)LocalFree(pSIDNew);
        }
        else
        {
            iResult = MSGINA_DLG_SWITCH_FAILURE;
            s_dwSessionID = NtCurrentPeb()->SessionId;
        }
    }
    else
    {

        //  If the dialog failed then do nothing. This will force a loop back
        //  to the present the welcome screen again until authentication.

        iResult = WLX_SAS_ACTION_NONE;
    }
    if ((iResult == WLX_SAS_ACTION_LOGON) || (iResult == WLX_SAS_ACTION_NONE) || (iResult == MSGINA_DLG_SWITCH_FAILURE))
    {
        _Shell_LogonStatus_Destroy(HOST_END_HIDE);
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::GetEventName
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the name of the event to return to welcome. Signal
//              this event and you'll get a return to welcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CReturnToWelcome::GetEventName (void)

{
    return(s_szEventName);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::StaticInitialize
//
//  Arguments:  pWlxContext     =   PGLOBALS struct for msgina.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates a named event and ACL's it so that anybody can signal
//              it but only S-1-5-18 (NT AUTHORITY\SYSTEM) or S-1-5-32-544
//              (local administrators) can synchronize to it. Then register a
//              wait on this object.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CReturnToWelcome::StaticInitialize (void *pWlxContext)

{
    NTSTATUS                status;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
    SECURITY_ATTRIBUTES     securityAttributes;

    ASSERTMSG(s_pWlxContext == NULL, "Non NULL pWlxContext in CReturnToWelcome::StaticInitialize");
    ASSERTMSG(s_hEventRequest == NULL, "Non NULL request event in CReturnToWelcome::StaticInitialize");

    s_pWlxContext = pWlxContext;

    //  Build a security descriptor for the event that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     EVENT_ALL_ACCESS
    //      S-1-5-32-544    <local administrators>  READ_CONTROL | SYNCHRONIZE | EVENT_MODIFY_STATE
    //      S-1-1-0         <everybody>             EVENT_MODIFY_STATE

    static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority   =   SECURITY_NT_AUTHORITY;
    static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldSID      =   SECURITY_WORLD_SID_AUTHORITY;

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            EVENT_ALL_ACCESS
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            READ_CONTROL | SYNCHRONIZE | EVENT_MODIFY_STATE
        },
        {
            &s_SecurityWorldSID,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            EVENT_MODIFY_STATE
        }
    };

    //  Build a security descriptor that allows the described access above.

    pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);
    if (pSecurityDescriptor != NULL)
    {
        securityAttributes.nLength = sizeof(securityAttributes);
        securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
        securityAttributes.bInheritHandle = FALSE;
        s_hEventRequest = CreateEvent(&securityAttributes, TRUE, FALSE, GetEventName());
        if (s_hEventRequest != NULL)
        {
            s_hEventShown = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (s_hEventShown != NULL)
            {
                status = RegisterWaitForRequest();
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        ReleaseMemory(pSecurityDescriptor);
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }

    //  Initialize the last failed connect session ID.

    s_dwSessionID = static_cast<DWORD>(-1);
    return(status);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Unregisters the wait on the named event and releases
//              associated resources.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CReturnToWelcome::StaticTerminate (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&s_hWait, NULL);
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
    }
    ReleaseHandle(s_hEventShown);
    ReleaseHandle(s_hEventRequest);
    s_pWlxContext = NULL;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::IsSameUser
//
//  Arguments:  hToken  =   Token of the user for the current session.
//
//  Returns:    bool
//
//  Purpose:    Compares the token of the user for the current session with
//              the token of the user who just authenticated. If the user is
//              the same (compared by user SID not logon SID) then this is
//              effectively a re-authentication. This will switch back.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

bool    CReturnToWelcome::IsSameUser (PSID pSIDUser, HANDLE hToken)                   const

{
    bool    fResult;

    if (hToken != NULL)
    {
        PSID                pSIDCompare;
        CTokenInformation   tokenInformationCompare(hToken);

        pSIDCompare = tokenInformationCompare.GetUserSID();
        fResult = ((pSIDUser != NULL) &&
                   (pSIDCompare != NULL) &&
                   (EqualSid(pSIDUser, pSIDCompare) != FALSE));
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::UserIsDisconnected
//
//  Arguments:  pdwSessionID    =   Session ID returned of found user.
//
//  Returns:    bool
//
//  Purpose:    Searches the list of disconnected sessions for the given
//              matching user SID. Retrieve the user token for each
//              disconnected window station and when a match is found return
//              that session ID and a result back to the caller.
//
//  History:    2001-01-12  vtan        created
//  --------------------------------------------------------------------------

bool    CReturnToWelcome::UserIsDisconnected (PSID pSIDUser, DWORD *pdwSessionID)     const

{
    bool        fResult;
    PLOGONID    pLogonIDs;
    ULONG       ulEntries;

    fResult = false;
    if (WinStationEnumerate(SERVERNAME_CURRENT, &pLogonIDs, &ulEntries) != FALSE)
    {
        ULONG       ulIndex;
        PLOGONID    pLogonID;

        for (ulIndex = 0, pLogonID = pLogonIDs; !fResult && (ulIndex < ulEntries); ++ulIndex, ++pLogonID)
        {
            if (pLogonID->State == State_Disconnected)
            {
                ULONG                   ulReturnLength;
                WINSTATIONUSERTOKEN     winStationUserToken;

                winStationUserToken.ProcessId = ULongToHandle(GetCurrentProcessId());
                winStationUserToken.ThreadId = ULongToHandle(GetCurrentThreadId());
                winStationUserToken.UserToken = NULL;
                if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                               pLogonID->SessionId,
                                               WinStationUserToken,
                                               &winStationUserToken,
                                               sizeof(winStationUserToken),
                                               &ulReturnLength) != FALSE)
                {
                    fResult = IsSameUser(pSIDUser, winStationUserToken.UserToken);
                    if (fResult)
                    {
                        *pdwSessionID = pLogonID->SessionId;
                    }
                    TBOOL(CloseHandle(winStationUserToken.UserToken));
                }
            }
        }

        //  Free any resources used.

        (BOOLEAN)WinStationFreeMemory(pLogonIDs);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::GetSessionUserName
//
//  Arguments:  dwSessionID     =   Session ID of user name to get.
//              pszBuffer       =   UNLEN character buffer to use.
//
//  Returns:    <none>
//
//  Purpose:    Retrieves the display name of the user for the given session.
//              The buffer must be at least UNLEN + sizeof('\0') characters.
//
//  History:    2001-03-02  vtan        created
//  --------------------------------------------------------------------------

void    CReturnToWelcome::GetSessionUserName (DWORD dwSessionID, WCHAR *pszBuffer)

{
    ULONG                   ulReturnLength;
    WINSTATIONINFORMATIONW  winStationInformation;

    //  Ask terminal server for the user name of the session.

    if (WinStationQueryInformationW(SERVERNAME_CURRENT,
                                    dwSessionID,
                                    WinStationInformation,
                                    &winStationInformation,
                                    sizeof(winStationInformation),
                                    &ulReturnLength) != FALSE)
    {
        USER_INFO_2     *pUI2;

        //  Convert the user name to a display name.

        if (NERR_Success == NetUserGetInfo(NULL,
                                           winStationInformation.UserName,
                                           2,
                                           reinterpret_cast<LPBYTE*>(&pUI2)))
        {
            const WCHAR     *pszName;

            //  Use the display name if it exists and isn't empty.
            //  Otherwise use the logon name.

            if ((pUI2->usri2_full_name != NULL) && (pUI2->usri2_full_name[0] != L'\0'))
            {
                pszName = pUI2->usri2_full_name;
            }
            else
            {
                pszName = winStationInformation.UserName;
            }
            (WCHAR*)lstrcpyW(pszBuffer, pszName);
            (NET_API_STATUS)NetApiBufferFree(pUI2);
        }
    }
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::ShowReconnectFailure
//
//  Arguments:  dwSessionID     =   Session that failed reconnection.
//
//  Returns:    <none>
//
//  Purpose:    Shows a message box indicating that the reconnection failed.
//              The message box times out in 120 seconds.
//
//  History:    2001-03-02  vtan        created
//  --------------------------------------------------------------------------

void    CReturnToWelcome::ShowReconnectFailure (DWORD dwSessionID)

{
    static  const int   BUFFER_SIZE = 256;

    WCHAR *pszText;

    pszText = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, BUFFER_SIZE * sizeof(WCHAR)));
    if (pszText != NULL)
    {
        WCHAR   *pszCaption;

        pszCaption = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, BUFFER_SIZE * sizeof(WCHAR)));
        if (pszCaption != NULL)
        {
            WCHAR   *pszUsername;

            pszUsername = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (UNLEN + sizeof('\0')) * sizeof(WCHAR)));
            if (pszUsername != NULL)
            {
                GetSessionUserName(dwSessionID, pszUsername);
                if (LoadString(hDllInstance,
                               IDS_RECONNECT_FAILURE,
                               pszCaption,
                               BUFFER_SIZE) != 0)
                {
                    wsprintf(pszText, pszCaption, pszUsername);
                    if (LoadString(hDllInstance,
                                   IDS_GENERIC_CAPTION,
                                   pszCaption,
                                   BUFFER_SIZE) != 0)
                    {
                        TBOOL(_Gina_SetTimeout(s_pWlxContext, LOGON_TIMEOUT));
                        (int)_Gina_MessageBox(s_pWlxContext,
                                                   NULL,
                                                   pszText,
                                                   pszCaption,
                                                   MB_OK | MB_ICONHAND);
                    }
                }
                (HLOCAL)LocalFree(pszUsername);
            }
            (HLOCAL)LocalFree(pszCaption);
        }
        (HLOCAL)LocalFree(pszText);
    }
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::EndDialog
//
//  Arguments:  hwnd        =   HWND of dialog.
//              iResult     =   Result to end dialog with.
//
//  Returns:    <none>
//
//  Purpose:    Ends the dialog. Marks the member variable to prevent
//              re-entrancy.
//
//  History:    2001-03-04  vtan        created
//  --------------------------------------------------------------------------

void    CReturnToWelcome::EndDialog (HWND hwnd, INT_PTR iResult)

{
    _fDialogEnded = true;
    TBOOL(::EndDialog(hwnd, iResult));
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::Handle_WM_INITDIALOG
//
//  Arguments:  hwndDialog  =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_INITDIALOG. Brings up the friendly logon screen.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

void    CReturnToWelcome::Handle_WM_INITDIALOG (HWND hwndDialog)

{
    switch (_Shell_LogonDialog_Init(hwndDialog, _fUnlock ? SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK : SHELL_LOGONDIALOG_RETURNTOWELCOME))
    {
        case SHELL_LOGONDIALOG_LOGON:
        case SHELL_LOGONDIALOG_NONE:
        default:
        {

            //  If it's anything but external host then something went wrong.
            //  Return MSGINA_DLG_LOCK_WORKSTATION to use the old method.

            EndDialog(hwndDialog, MSGINA_DLG_LOCK_WORKSTATION);
            break;
        }
        case SHELL_LOGONDIALOG_EXTERNALHOST:
        {
            break;
        }
    }
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::Handle_WM_DESTROY
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_DESTROY. Destroys the welcome logon screen.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

void    CReturnToWelcome::Handle_WM_DESTROY (void)

{
    _ShellReleaseLogonMutex(FALSE);
    _Shell_LogonDialog_Destroy();
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::Handle_WM_COMMAND
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    bool
//
//  Purpose:    Handles WM_COMMAND. Handles IDOK and IDCANCEL. IDOK means a
//              logon request is made. IDCANCEL is special cased to take the
//              LPARAM and use it as a LOGONIPC_CREDENTIALS for IDOK.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

bool    CReturnToWelcome::Handle_WM_COMMAND (HWND hwndDialog, WPARAM wParam, LPARAM lParam)

{
    bool    fResult;

    switch (wParam)
    {
        case IDOK:
        {
            bool            fSuccessfulLogon;
            const WCHAR     *pszUsername, *pszDomain, *pszPassword;

            //  If credentials were successfully allocated then
            //  use them. Attempt to log the user on.

            if (_pLogonIPCCredentials != NULL)
            {
                pszUsername = _pLogonIPCCredentials->userID.wszUsername;
                pszDomain = _pLogonIPCCredentials->userID.wszDomain;
                pszPassword = _pLogonIPCCredentials->wszPassword;
                fSuccessfulLogon = (CTokenInformation::LogonUser(_pLogonIPCCredentials->userID.wszUsername,
                                                                 _pLogonIPCCredentials->userID.wszDomain,
                                                                 _pLogonIPCCredentials->wszPassword,
                                                                 &_hToken) == ERROR_SUCCESS);
            }
            else
            {

                //  Otherwise - no credentials - no logon.

                pszUsername = pszDomain = pszPassword = NULL;
                fSuccessfulLogon = false;
            }

            //  Tell the logon component the result.

            _Shell_LogonDialog_LogonCompleted(fSuccessfulLogon ? MSGINA_DLG_SUCCESS : MSGINA_DLG_FAILURE,
                                              pszUsername,
                                              pszDomain);

            //  And if successful then end the dialog with success code.

            if (fSuccessfulLogon)
            {
                EndDialog(hwndDialog, MSGINA_DLG_SUCCESS);
            }
            fResult = true;
            break;
        }
        case IDCANCEL:

            //  IDCANCEL: Take the LPARAM and treat it as a LOGONIPC_CREDENTIALS struct.
            //  Allocate memory for this and copy the structure.

            _pLogonIPCCredentials = static_cast<LOGONIPC_CREDENTIALS*>(LocalAlloc(LMEM_FIXED, sizeof(LOGONIPC_CREDENTIALS)));
            if ((_pLogonIPCCredentials != NULL) && (lParam != NULL))
            {
                *_pLogonIPCCredentials = *reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam);
            }
            fResult = true;
            break;
        default:
            fResult = false;
            break;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::CB_DialogProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    INT_PTR
//
//  Purpose:    DialogProc for the return to welcome stub dialog. This handles
//              WM_INITDIALOG, WM_DESTROY, WM_COMMAND and WLX_WM_SAS.
//              WM_COMMAND is a request from the logon host. WLX_WM_SAS is a
//              SAS from the logon process.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

INT_PTR     CReturnToWelcome::CB_DialogProc (HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR             iResult;
    CReturnToWelcome    *pThis;

    pThis = reinterpret_cast<CReturnToWelcome*>(GetWindowLongPtr(hwndDialog, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CReturnToWelcome*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwndDialog, GWLP_USERDATA, lParam);
            pThis->Handle_WM_INITDIALOG(hwndDialog);
            iResult = FALSE;
            break;
        case WM_DESTROY:
            pThis->Handle_WM_DESTROY();
            (LONG_PTR)SetWindowLongPtr(hwndDialog, GWLP_USERDATA, 0);
            iResult = TRUE;
            break;
        case WM_COMMAND:
            iResult = pThis->Handle_WM_COMMAND(hwndDialog, wParam, lParam);
            break;
        case WLX_WM_SAS:
            (BOOL)_Shell_LogonDialog_DlgProc(hwndDialog, uMsg, wParam, lParam);

            //  If the SAS type is authenticated then end the return to welcome
            //  dialog and return to the caller MSGINA_DLG_SWITCH_CONSOLE.

            if (wParam == WLX_SAS_TYPE_AUTHENTICATED)
            {
                pThis->EndDialog(hwndDialog, MSGINA_DLG_SWITCH_CONSOLE);
            }
            iResult = ((wParam != WLX_SAS_TYPE_TIMEOUT) && (wParam != WLX_SAS_TYPE_SCRNSVR_TIMEOUT));
            break;
        default:
            if ((pThis != NULL) && !pThis->_fDialogEnded && !CSystemSettings::IsActiveConsoleSession())
            {
                pThis->EndDialog(hwndDialog, MSGINA_DLG_SWITCH_CONSOLE);
                iResult = TRUE;
            }
            else
            {
                iResult = _Shell_LogonDialog_DlgProc(hwndDialog, uMsg, wParam, lParam);
            }
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::RegisterWaitForRequest
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Register a wait for the named event being signaled.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CReturnToWelcome::RegisterWaitForRequest (void)

{
    NTSTATUS    status;

    if (s_hEventRequest != NULL)
    {
        ASSERTMSG(s_hWait == NULL, "Non NULL wait in CReturnToWelcome::RegisterWaitForRequest");
        if (RegisterWaitForSingleObject(&s_hWait,
                                        s_hEventRequest,
                                        CB_Request,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CReturnToWelcome::CB_Request
//
//  Arguments:  pParameter          =   User parameter.
//              TimerOrWaitFired    =   Timer or wait fired.
//
//  Returns:    <none>
//
//  Purpose:    Callback invoked when ShellSwitchUser signals the named event.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CReturnToWelcome::CB_Request (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(pParameter);
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    HANDLE  hWait;

    //  Unregister the wait if we can grab the wait.

    hWait = InterlockedExchangePointer(&s_hWait, NULL);
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
    }

    //  Send the SAS type WLX_SAS_TYPE_SWITCHUSER only if the workstation
    //  is the active console session. This API won't be called on PTS.

    if (CSystemSettings::IsActiveConsoleSession() && CSystemSettings::IsFriendlyUIActive())
    {

        //  Reset the shown event. When CReturnToWelcome::Show has shown the
        //  dialog it will set this event which will allow us to re-register
        //  a wait on the switch user event. This prevents multiple SAS events
        //  of type WLX_SAS_TYPE_SWITCHUSER being posted to the SAS window.

        TBOOL(ResetEvent(s_hEventShown));
        _Gina_SasNotify(s_pWlxContext, WLX_SAS_TYPE_SWITCHUSER);
        (DWORD)WaitForSingleObject(s_hEventShown, INFINITE);
    }

    //  Reset the event.

    TBOOL(ResetEvent(s_hEventRequest));

    //  Reregister the wait.

    TSTATUS(RegisterWaitForRequest());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\returntowelcome.h ===
//  --------------------------------------------------------------------------
//  Module Name: ReturnToWelcome.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File to handle return to welcome.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ReturnToWelcome_
#define     _ReturnToWelcome_

#include <ginaipc.h>

//  --------------------------------------------------------------------------
//  CReturnToWelcome
//
//  Purpose:    Class that handles return to welcome with switching desktops.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

class   CReturnToWelcome
{
    public:
                                        CReturnToWelcome (void);
                                        ~CReturnToWelcome (void);

                INT_PTR                 Show (bool fUnlock);

        static  const WCHAR*            GetEventName (void);

        static  NTSTATUS                StaticInitialize (void *pWlxContext);
        static  NTSTATUS                StaticTerminate (void);
    private:
                bool                    IsSameUser (PSID pSIDUser, HANDLE hToken)                   const;
                bool                    UserIsDisconnected (PSID pSIDUser, DWORD *pdwSessionID)     const;
                void                    GetSessionUserName (DWORD dwSessionID, WCHAR *pszBuffer);
                void                    ShowReconnectFailure (DWORD dwSessionID);
                void                    EndDialog (HWND hwnd, INT_PTR iResult);

                void                    Handle_WM_INITDIALOG (HWND hwndDialog);
                void                    Handle_WM_DESTROY (void);
                bool                    Handle_WM_COMMAND (HWND hwndDialog, WPARAM wParam, LPARAM lParam);

        static  INT_PTR     CALLBACK    CB_DialogProc (HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  NTSTATUS                RegisterWaitForRequest (void);
        static  void        CALLBACK    CB_Request (void *pParameter, BOOLEAN TimerOrWaitFired);
    private:
                HANDLE                  _hToken;
                LOGONIPC_CREDENTIALS*   _pLogonIPCCredentials;
                bool                    _fUnlock;
                bool                    _fDialogEnded;

        static  void*                   s_pWlxContext;
        static  HANDLE                  s_hEventRequest;
        static  HANDLE                  s_hEventShown;
        static  HANDLE                  s_hWait;
        static  const TCHAR             s_szEventName[];
        static  DWORD                   s_dwSessionID;
};

#endif  /*  _ReturnToWelcome_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\specialaccounts.h ===
//  --------------------------------------------------------------------------
//  Module Name: SpecialAccounts.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements handling special account names for exclusion or
//  inclusion.
//
//  History:    1999-10-30  vtan        created
//              1999-11-26  vtan        moved from logonocx
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _SpecialAccounts_
#define     _SpecialAccounts_

//  --------------------------------------------------------------------------
//  CSpecialAccounts
//
//  Purpose:    A class to handle special case accounts. This knows where to
//              go in the registry for the information and how to interpret
//              the information.
//
//              The value name defines the string to compare to. The
//              enumeration in the class definition tells the iteration loop
//              how to perform the comparison and when the comparison is a
//              match whether to return a match result or not.
//
//  History:    1999-10-30  vtan        created
//              1999-11-26  vtan        moved from logonocx
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSpecialAccounts
{
    public:
        enum
        {
            RESULT_EXCLUDE          =   0x00000000,
            RESULT_INCLUDE          =   0x00000001,
            RESULT_MASK             =   0x0000FFFF,

            COMPARISON_EQUALS       =   0x00000000,
            COMPARISON_STARTSWITH   =   0x00010000,
            COMPARISON_MASK         =   0xFFFF0000
        };
    private:
        typedef struct
        {
            DWORD   dwAction;
            WCHAR   wszUsername[UNLEN + sizeof('\0')];
        } SPECIAL_ACCOUNTS, *PSPECIAL_ACCOUNTS;
    public:
                                    CSpecialAccounts (void);
                                    ~CSpecialAccounts (void);

                bool                AlwaysExclude (const WCHAR *pwszAccountName)                        const;
                bool                AlwaysInclude (const WCHAR *pwszAccountName)                        const;

        static  void                Install (void);
    private:
                bool                IterateAccounts (const WCHAR *pwszAccountName, DWORD dwResultType)  const;
    private:
                DWORD               _dwSpecialAccountsCount;
                PSPECIAL_ACCOUNTS   _pSpecialAccounts;

        static  const TCHAR         s_szUserListKeyName[];
};

#endif  /*  _SpecialAccounts_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\specialaccounts.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SpecialAccounts.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements handling special account names for exclusion or
//  inclusion.
//
//  History:    1999-10-30  vtan        created
//              1999-11-26  vtan        moved from logonocx
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "SpecialAccounts.h"

#include "RegistryResources.h"

//  --------------------------------------------------------------------------
//  CSpecialAccounts::s_szUserListKeyName
//
//  Purpose:    Static const member variable that holds the location of the
//              special accounts in the registry.
//
//  History:    2000-01-31  vtan        created
//  --------------------------------------------------------------------------

const TCHAR     CSpecialAccounts::s_szUserListKeyName[]   =   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList");

//  --------------------------------------------------------------------------
//  CSpecialAccounts::CSpecialAccounts
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Reads the registry to determine which accounts should be
//              filtered out and which should not be filtered out based on an
//              action code. The list is built up in memory so that each time
//              the class is invoked it adjusts live.
//
//  History:    1999-10-30  vtan        created
//  --------------------------------------------------------------------------

CSpecialAccounts::CSpecialAccounts (void) :
    _dwSpecialAccountsCount(0),
    _pSpecialAccounts(NULL)

{
    CRegKey     regKeyUserList;

    //  Open the key to where the information is stored.

    if (ERROR_SUCCESS == regKeyUserList.Open(HKEY_LOCAL_MACHINE, s_szUserListKeyName, KEY_READ))
    {
        DWORD   dwValueCount;

        //  Find out how many entries there are so an array of the correct
        //  size can be allocated.

        if (ERROR_SUCCESS == regKeyUserList.QueryInfoKey(NULL, NULL, NULL, NULL, NULL, &dwValueCount, NULL, NULL, NULL, NULL))
        {
            _pSpecialAccounts = static_cast<PSPECIAL_ACCOUNTS>(LocalAlloc(LPTR, dwValueCount * sizeof(SPECIAL_ACCOUNTS)));
            if (_pSpecialAccounts != NULL)
            {
                DWORD               dwIndex, dwType, dwValueNameSize, dwDataSize;
                PSPECIAL_ACCOUNTS   pSCA;

                //  If the memory was allocated then fill the array in.

                regKeyUserList.Reset();
                _dwSpecialAccountsCount = dwValueCount;
                pSCA = _pSpecialAccounts;
                for (dwIndex = 0; dwIndex < dwValueCount; ++dwIndex)
                {
                    dwValueNameSize = ARRAYSIZE(pSCA->wszUsername);
                    dwDataSize = sizeof(pSCA->dwAction);

                    //  Ensure that the entries are of type REG_DWORD. Ignore
                    //  any that are not.

                    if ((ERROR_SUCCESS == regKeyUserList.Next(pSCA->wszUsername,
                                                              &dwValueNameSize,
                                                              &dwType,
                                                              &pSCA->dwAction,
                                                              &dwDataSize)) &&
                        (REG_DWORD == dwType))
                    {
                        ++pSCA;
                    }
                }
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CSpecialAccounts::~CSpecialAccounts
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the memory allocated in the constructor.
//
//  History:    1999-10-30  vtan        created
//  --------------------------------------------------------------------------

CSpecialAccounts::~CSpecialAccounts (void)

{
    if (_pSpecialAccounts != NULL)
    {
        (HLOCAL)LocalFree(_pSpecialAccounts);
        _pSpecialAccounts = NULL;
        _dwSpecialAccountsCount = 0;
    }
}

//  --------------------------------------------------------------------------
//  CSpecialAccounts::AlwaysExclude
//
//  Arguments:  pwszAccountName     =   Account name to match.
//
//  Returns:    bool
//
//  Purpose:    Uses the iterate loop to find a match for exclusion accounts.
//
//  History:    1999-10-30  vtan        created
//  --------------------------------------------------------------------------

bool    CSpecialAccounts::AlwaysExclude (const WCHAR *pwszAccountName)                        const

{
    return(IterateAccounts(pwszAccountName, RESULT_EXCLUDE));
}

//  --------------------------------------------------------------------------
//  CSpecialAccounts::AlwaysInclude
//
//  Arguments:  pwszAccountName     =   Account name to match.
//
//  Returns:    bool
//
//  Purpose:    Uses the iterate loop to find a match for inclusion accounts.
//
//  History:    1999-10-30  vtan        created
//  --------------------------------------------------------------------------

bool    CSpecialAccounts::AlwaysInclude (const WCHAR *pwszAccountName)                        const

{
    return(IterateAccounts(pwszAccountName, RESULT_INCLUDE));
}

//  --------------------------------------------------------------------------
//  CSpecialAccounts::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Installs default user list for CSpecialAccounts to use.
//              CSpecialAccounts lives in specialaccounts.cpp and handles
//              exclusion or inclusion of special account names.
//
//  History:    1999-11-01  vtan        created
//              1999-11-26  vtan        moved from logonocx
//  --------------------------------------------------------------------------

void    CSpecialAccounts::Install (void)

{

    //  Some of these names can be localized. IWAM_ and IUSR_ are stored in
    //  resources in IIS. VUSR_ and SQLAgentCmdExec are of unknown origin.
    //  TsInternetUser is hard coded in TS component bits.

    static  const TCHAR     szTsInternetUserName[]          =   TEXT("TsInternetUser");
    static  const TCHAR     szSQLAgentUserName[]            =   TEXT("SQLAgentCmdExec");
    static  const TCHAR     szWebAccessUserName[]           =   TEXT("IWAM_");
    static  const TCHAR     szInternetUserName[]            =   TEXT("IUSR_");
    static  const TCHAR     szVisualStudioUserName[]        =   TEXT("VUSR_");
    static  const TCHAR     szNetShowServicesUserName[]     =   TEXT("NetShowServices");
    static  const TCHAR     szHelpAssistantUserName[]       =   TEXT("HelpAssistant");

    typedef struct
    {
        bool            fInstall;
        const TCHAR     *pszAccountName;
        DWORD           dwActionType;
    } tSpecialAccount, *pSpecialAccount;

    DWORD       dwDisposition;
    CRegKey     regKeyUserList;

    //  Open key to the user list.

    if (ERROR_SUCCESS == regKeyUserList.Create(HKEY_LOCAL_MACHINE,
                                               s_szUserListKeyName,
                                               REG_OPTION_NON_VOLATILE,
                                               KEY_READ | KEY_WRITE,
                                               &dwDisposition))
    {
        tSpecialAccount     *pSA;

        static  tSpecialAccount     sSpecialAccount[]   =   
        {
            {   true,   szTsInternetUserName,       COMPARISON_EQUALS     | RESULT_EXCLUDE  },
            {   true,   szSQLAgentUserName,         COMPARISON_EQUALS     | RESULT_EXCLUDE  },
            {   true,   szNetShowServicesUserName,  COMPARISON_EQUALS     | RESULT_EXCLUDE  },
            {   true,   szHelpAssistantUserName,    COMPARISON_EQUALS     | RESULT_EXCLUDE  },
            {   true,   szWebAccessUserName,        COMPARISON_STARTSWITH | RESULT_EXCLUDE  },
            {   true,   szInternetUserName,         COMPARISON_STARTSWITH | RESULT_EXCLUDE  },
            {   true,   szVisualStudioUserName,     COMPARISON_STARTSWITH | RESULT_EXCLUDE  },
            {   true,   NULL,                       0                                       },
        };

        pSA = sSpecialAccount;
        while (pSA->pszAccountName != NULL)
        {
            if (pSA->fInstall)
            {
                TW32(regKeyUserList.SetDWORD(pSA->pszAccountName, pSA->dwActionType));
            }
            else
            {
                TW32(regKeyUserList.DeleteValue(pSA->pszAccountName));
            }
            ++pSA;
        }
    }
}

//  --------------------------------------------------------------------------
//  CSpecialAccounts::IterateAccounts
//
//  Arguments:  pwszAccountName     =   Account name to match.
//              dwResultType        =   Result type to match.
//
//  Returns:    bool
//
//  Purpose:    Iterates thru the special case account name list from the
//              registry built in the constructor. Matches the given account
//              name based on the type of match specified for the special case
//              entry. If the account names match then match the result type.
//
//  History:    1999-10-30  vtan        created
//  --------------------------------------------------------------------------

bool    CSpecialAccounts::IterateAccounts (const WCHAR *pwszAccountName, DWORD dwResultType)    const

{
    bool                fResult;
    PSPECIAL_ACCOUNTS   pSCA;

    fResult = false;
    pSCA = _pSpecialAccounts;
    if (pSCA != NULL)
    {
        DWORD   dwIndex;

        for (dwIndex = 0; !fResult && (dwIndex < _dwSpecialAccountsCount); ++pSCA, ++dwIndex)
        {
            bool    fMatch;

            //  Perform the account name match based on the required type.
            //  Currently only "equals" and "starts with" are supported.

            switch (pSCA->dwAction & COMPARISON_MASK)
            {
                case COMPARISON_EQUALS:
                {
                    fMatch = (lstrcmpiW(pwszAccountName, pSCA->wszUsername) == 0);
                    break;
                }
                case COMPARISON_STARTSWITH:
                {
                    int     iLength;

                    iLength = lstrlenW(pSCA->wszUsername);
                    fMatch = (CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                             NORM_IGNORECASE,
                                             pwszAccountName,
                                             iLength,
                                             pSCA->wszUsername,
                                             iLength) == CSTR_EQUAL);
                    break;
                }
                default:
                {
                    fMatch = false;
                    break;
                }
            }
            if (fMatch)
            {

                //  If the name matches make sure the result type does as well.

                fResult = ((pSCA->dwAction & RESULT_MASK) == dwResultType);
            }
        }
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\systemsettings.h ===
//  --------------------------------------------------------------------------
//  Module Name: SystemSettings.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to handle opening and reading/writing from the Winlogon key.
//
//  History:    1999-09-09  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _SystemSettings_
#define     _SystemSettings_

//  --------------------------------------------------------------------------
//  CSystemSettings
//
//  Purpose:    This class deals with system settings typically found in
//              HKLM\System or HKLM\Software
//
//  History:    1999-09-09  vtan        created
//              2000-04-12  vtan        consolidation for policy checking
//  --------------------------------------------------------------------------

class   CSystemSettings
{
    public:
        static  bool            IsSafeMode (void);
        static  bool            IsSafeModeMinimal (void);
        static  bool            IsSafeModeNetwork (void);
        static  bool            IsNetwareActive (void);
        static  bool            IsWorkStationProduct (void);
        static  bool            IsDomainMember (void);
        static  bool            IsActiveConsoleSession (void);
        static  bool            IsTerminalServicesEnabled (void);
        static  bool            IsFriendlyUIActive (void);
        static  bool            IsMultipleUsersEnabled (void);
        static  bool            IsRemoteConnectionsEnabled (void);
        static  bool            IsRemoteConnectionPresent (void);
        static  bool            IsShutdownWithoutLogonAllowed (void);
        static  bool            IsUndockWithoutLogonAllowed (void);
        static  bool            IsForceFriendlyUI (void);
        static  LONG            GetUIHost (TCHAR *pszPath);
        static  bool            IsUIHostStatic (void);
        static  bool            EnableFriendlyUI (bool fEnable);
        static  bool            EnableMultipleUsers (bool fEnable);
        static  bool            EnableRemoteConnections (bool fEnable);
        static  int             GetLoggedOnUserCount (void);
        static  NTSTATUS        CheckDomainMembership (void);
        static  DWORD   WINAPI  AdjustFUSCompatibilityServiceState (void *pV);
    private:
        static  LONG            GetEffectiveInteger (HKEY hKey, const TCHAR *pszKeyName, const TCHAR *pszPolicyKeyName, const TCHAR *pszValueName, int& iResult);
        static  LONG            GetEffectivePath (HKEY hKey, const TCHAR *pszKeyName, const TCHAR *pszPolicyKeyName, const TCHAR *pszValueName, TCHAR *pszPath);
        static  bool            IsProfessionalTerminalServer (void);
        static  bool            IsMicrosoftGINA (void);
        static  bool            IsSCMTerminalServicesDisabled (void);

        static  const TCHAR     s_szSafeModeKeyName[];
        static  const TCHAR     s_szSafeModeOptionValueName[];
        static  const TCHAR     s_szWinlogonKeyName[];
        static  const TCHAR     s_szSystemPolicyKeyName[];
        static  const TCHAR     s_szTerminalServerKeyName[];
        static  const TCHAR     s_szTerminalServerPolicyKeyName[];
        static  const TCHAR     s_szNetwareClientKeyName[];
        static  const TCHAR     s_szLogonTypeValueName[];
        static  const TCHAR     s_szBackgroundValueName[];
        static  const TCHAR     s_szMultipleUsersValueName[];
        static  const TCHAR     s_szDenyRemoteConnectionsValueName[];
        static  int             s_iIsSafeModeMinimal;
        static  int             s_iIsSafeModeNetwork;
};

#endif  /*  _SystemSettings_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\tokengroups.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TokenGroups.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes related to authentication for use in neptune logon
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "TokenGroups.h"

//  --------------------------------------------------------------------------
//  CTokenGroups::sLocalSID
//
//  Purpose:    Static member variable for local authority (owner) SID.
//  --------------------------------------------------------------------------

PSID    CTokenGroups::s_localSID            =   NULL;
PSID    CTokenGroups::s_administratorSID    =   NULL;

//  --------------------------------------------------------------------------
//  CTokenGroups::CTokenGroups
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initialize CTokenGroups object.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CTokenGroups::CTokenGroups (void) :
    _pTokenGroups(NULL)

{
    ASSERTMSG((s_localSID != NULL) && (s_administratorSID != NULL), "Cannot use CTokenGroups with invoking CTokenGroups::StaticInitialize");
}

//  --------------------------------------------------------------------------
//  CTokenGroups::CTokenGroups
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destroys buffer used by CTokenGroups if created.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CTokenGroups::~CTokenGroups (void)

{
    ReleaseMemory(_pTokenGroups);
}

//  --------------------------------------------------------------------------
//  CTokenGroups::Get
//
//  Arguments:  <none>
//
//  Returns:    const TOKEN_GROUPS*     =   Pointer to the TOKEN_GROUPS
//                                          created in CTokenGroups::Create.
//
//  Purpose:    Returns the pointer to the TOKEN_GROUPS created in
//              CTokenGroups::Create for use with secur32!LsaLogonUser.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

const TOKEN_GROUPS*     CTokenGroups::Get (void)    const

{
    return(_pTokenGroups);
}

//  --------------------------------------------------------------------------
//  CTokenGroups::CreateLogonGroup
//
//  Arguments:  pLogonSID   =   logon SID to be used when create the token
//                              group for logon. This will include the local
//                              authority SID as well.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates the TOKEN_GROUP with logon SID and local authority
//              SID for use with secur32!LsaLogonUser.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CTokenGroups::CreateLogonGroup (PSID pLogonSID)

{
    static  const int       TOKEN_GROUP_COUNT   =   2;

    NTSTATUS    status;

    _pTokenGroups = static_cast<PTOKEN_GROUPS>(LocalAlloc(LPTR, sizeof(TOKEN_GROUPS) + (sizeof(SID_AND_ATTRIBUTES) * (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY))));
    if (_pTokenGroups != NULL)
    {
        _pTokenGroups->GroupCount = TOKEN_GROUP_COUNT;
        _pTokenGroups->Groups[0].Sid = pLogonSID;
        _pTokenGroups->Groups[0].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
        _pTokenGroups->Groups[1].Sid = s_localSID;
        _pTokenGroups->Groups[1].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CTokenGroups::CreateAdministratorGroup
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates a TOKEN_GROUP structure with the administrator's SID
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CTokenGroups::CreateAdministratorGroup (void)

{
    static  const int       TOKEN_GROUP_COUNT   =   1;

    NTSTATUS    status;

    _pTokenGroups = static_cast<PTOKEN_GROUPS>(LocalAlloc(LPTR, sizeof(TOKEN_GROUPS) + (sizeof(SID_AND_ATTRIBUTES) * (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY))));
    if (_pTokenGroups != NULL)
    {
        _pTokenGroups->GroupCount = TOKEN_GROUP_COUNT;
        _pTokenGroups->Groups[0].Sid = s_administratorSID;
        _pTokenGroups->Groups[0].Attributes = 0;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CTokenGroups::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Allocates a SID for the local authority which identifies the
//              owner.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CTokenGroups::StaticInitialize (void)

{
    static  SID_IDENTIFIER_AUTHORITY    localSIDAuthority   =   SECURITY_LOCAL_SID_AUTHORITY;
    static  SID_IDENTIFIER_AUTHORITY    systemSIDAuthority  =   SECURITY_NT_AUTHORITY;

    NTSTATUS    status;

    ASSERTMSG(s_localSID == NULL, "CTokenGroups::StaticInitialize already invoked");
    status = RtlAllocateAndInitializeSid(&localSIDAuthority,
                                         1,
                                         SECURITY_LOCAL_RID,
                                         0, 0, 0, 0, 0, 0, 0,
                                         &s_localSID);
    if (NT_SUCCESS(status))
    {
        status = RtlAllocateAndInitializeSid(&systemSIDAuthority,
                                             2,
                                             SECURITY_BUILTIN_DOMAIN_RID,
                                             DOMAIN_ALIAS_RID_ADMINS,
                                             0, 0, 0, 0, 0, 0,
                                             &s_administratorSID);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CTokenGroups::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Destroys memory allocated for the local authority SID.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CTokenGroups::StaticTerminate (void)

{
    if (s_administratorSID != NULL)
    {
        RtlFreeSid(s_administratorSID);
        s_administratorSID = NULL;
    }
    if (s_localSID != NULL)
    {
        RtlFreeSid(s_localSID);
        s_localSID = NULL;
    }
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\systemsettings.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SystemSettings.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to handle opening and reading/writing from the Winlogon key.
//
//  History:    1999-09-09  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "SystemSettings.h"

#include <regstr.h>
#include <safeboot.h>
#include <winsta.h>
#include <allproc.h>    // TS_COUNTER
#include <shlwapi.h>

#include "RegistryResources.h"

const TCHAR     CSystemSettings::s_szSafeModeKeyName[]                  =   TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option");
const TCHAR     CSystemSettings::s_szSafeModeOptionValueName[]          =   TEXT("OptionValue");
const TCHAR     CSystemSettings::s_szWinlogonKeyName[]                  =   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
const TCHAR     CSystemSettings::s_szSystemPolicyKeyName[]              =   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system");
const TCHAR     CSystemSettings::s_szTerminalServerKeyName[]            =   TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server");
const TCHAR     CSystemSettings::s_szTerminalServerPolicyKeyName[]      =   TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services");
const TCHAR     CSystemSettings::s_szNetwareClientKeyName[]             =   TEXT("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
const TCHAR     CSystemSettings::s_szLogonTypeValueName[]               =   TEXT("LogonType");
const TCHAR     CSystemSettings::s_szBackgroundValueName[]              =   TEXT("Background");
const TCHAR     CSystemSettings::s_szMultipleUsersValueName[]           =   TEXT("AllowMultipleTSSessions");
const TCHAR     CSystemSettings::s_szDenyRemoteConnectionsValueName[]   =   TEXT("fDenyTSConnections");

int             CSystemSettings::s_iIsSafeModeMinimal           =   -1;
int             CSystemSettings::s_iIsSafeModeNetwork           =   -1;

//  --------------------------------------------------------------------------
//  CSystemSettings::IsSafeMode
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Was the machine started in safe mode (minimal or network) ?
//
//  History:    2000-03-06  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsSafeMode (void)

{
    return(IsSafeModeMinimal() || IsSafeModeNetwork());
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsSafeModeMinimal
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Was the machine started in safe mode minimal?
//
//  History:    1999-09-13  vtan        created
//              2000-05-25  vtan        cache result in static member variable
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsSafeModeMinimal (void)

{
    if (-1 == s_iIsSafeModeMinimal)
    {
        bool        fResult;
        CRegKey     regKey;

        fResult = false;
        if (ERROR_SUCCESS == regKey.Open(HKEY_LOCAL_MACHINE,
                                         s_szSafeModeKeyName,
                                         KEY_QUERY_VALUE))
        {
            DWORD   dwValue, dwValueSize;

            dwValueSize = sizeof(dwValue);
            if (ERROR_SUCCESS == regKey.GetDWORD(s_szSafeModeOptionValueName,
                                                 dwValue))
            {
                fResult = (dwValue == SAFEBOOT_MINIMAL);
            }
        }
        s_iIsSafeModeMinimal = fResult;
    }
    return(s_iIsSafeModeMinimal != 0);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsSafeModeNetwork
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Was the machine started in safe mode with networking?
//
//  History:    1999-11-09  vtan        created
//              2000-05-25  vtan        cache result in static member variable
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsSafeModeNetwork (void)

{
    if (-1 == s_iIsSafeModeNetwork)
    {
        bool        fResult;
        CRegKey     regKey;

        fResult = false;
        if (ERROR_SUCCESS == regKey.Open(HKEY_LOCAL_MACHINE,
                                         s_szSafeModeKeyName,
                                         KEY_QUERY_VALUE))
        {
            DWORD   dwValue, dwValueSize;

            dwValueSize = sizeof(dwValue);
            if (ERROR_SUCCESS == regKey.GetDWORD(s_szSafeModeOptionValueName,
                                                 dwValue))
            {
                fResult = (dwValue == SAFEBOOT_NETWORK);
            }
        }
        s_iIsSafeModeNetwork = fResult;
    }
    return(s_iIsSafeModeNetwork != 0);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsNetwareActive
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this machine is a workstation running 
//              Netware client services or not.
//
//  History:    2001-05-16  cevans        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsNetwareActive (void)
{
    bool        fResult;
    LONG        lErrorCode;
    TCHAR       szProviders[MAX_PATH] = {0};
    CRegKey     regKey;

    fResult = false;
    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             s_szNetwareClientKeyName,
                             KEY_QUERY_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        if((regKey.GetString(TEXT("ProviderOrder"), szProviders, ARRAYSIZE(szProviders)) == ERROR_SUCCESS))
        {   
            if (StrStrI(szProviders, TEXT("NWCWorkstation")) != NULL)
            { 
                fResult = true;
            }
            else if (StrStrI(szProviders, TEXT("NetwareWorkstation")) != NULL)
            { 
                fResult = true;
            }
        }
    }
    return fResult;
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsWorkStationProduct
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this machine is a workstation product vs.
//              a server product.
//
//  History:    2000-08-30  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsWorkStationProduct (void)

{
    OSVERSIONINFOEXA    osVersionInfo;

    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    return((GetVersionExA(reinterpret_cast<OSVERSIONINFOA*>(&osVersionInfo)) != FALSE) &&
           (VER_NT_WORKSTATION == osVersionInfo.wProductType));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsDomainMember
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is this machine a member of a domain? Use the LSA to get this
//              information.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsDomainMember (void)

{
    bool                            fResult;
    int                             iCounter;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               objectAttributes;
    LSA_HANDLE                      lsaHandle;
    SECURITY_QUALITY_OF_SERVICE     securityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO         pDNSDomainInfo;

    fResult = false;
    securityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    securityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    securityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    securityQualityOfService.EffectiveOnly = FALSE;
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);
    objectAttributes.SecurityQualityOfService = &securityQualityOfService;
    iCounter = 0;
    do
    {
        status = LsaOpenPolicy(NULL, &objectAttributes, POLICY_VIEW_LOCAL_INFORMATION, &lsaHandle);
        if (RPC_NT_SERVER_TOO_BUSY == status)
        {
            Sleep(10);
        }
    } while ((RPC_NT_SERVER_TOO_BUSY == status) && (++iCounter < 10));
    if (NT_SUCCESS(status))
    {
        status = LsaQueryInformationPolicy(lsaHandle, PolicyDnsDomainInformation, reinterpret_cast<void**>(&pDNSDomainInfo));
        if (NT_SUCCESS(status) && (pDNSDomainInfo != NULL))
        {
            fResult = ((pDNSDomainInfo->DnsDomainName.Length != 0) ||
                       (pDNSDomainInfo->DnsForestName.Length != 0) ||
                       (pDNSDomainInfo->Sid != NULL));
            TSTATUS(LsaFreeMemory(pDNSDomainInfo));
        }
        TSTATUS(LsaClose(lsaHandle));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsActiveConsoleSession
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether current process session is the active console
//              session.
//
//  History:    2001-03-04  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsActiveConsoleSession (void)

{
    return(NtCurrentPeb()->SessionId == USER_SHARED_DATA->ActiveConsoleId);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsTerminalServicesEnabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Does this machine have an enabled terminal services service?
//              This function is for Windows 2000 and later ONLY.
//
//  History:    2000-03-02  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsTerminalServicesEnabled (void)

{
    OSVERSIONINFOEX     osVersionInfo;
    DWORDLONG           dwlConditionMask;

    dwlConditionMask = 0;
    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);
    return((VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask) != FALSE) &&
           !IsSCMTerminalServicesDisabled());
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsFriendlyUIActive
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\LogonType and if this value is 0x01
//              then activate the external UI host. This function returns the
//              setting. This can never be true for domain member machines.
//
//  History:    2000-02-04  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsFriendlyUIActive (void)

{
    int     iResult;

    return(IsWorkStationProduct() &&
           (!IsDomainMember() || IsForceFriendlyUI()) &&
           IsMicrosoftGINA() &&
           !IsNetwareActive() &&
           (ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 s_szLogonTypeValueName,
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsMultipleUsersEnabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\AllowMultipleTSSessions and if the
//              value is 0x01 *AND* terminal services is installed on this
//              machine then the conditions are satisfied.
//
//  History:    2000-03-02  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsMultipleUsersEnabled (void)

{
    int     iResult;

    return(IsTerminalServicesEnabled() &&
           !IsSafeMode() &&
           (ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 s_szMultipleUsersValueName,
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsRemoteConnectionsEnabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\System\CurrentControlSet\Control\
//              Terminal Server\fDenyTSConnections and returns the
//              value back to the caller.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsRemoteConnectionsEnabled (void)

{
    int         iResult;
    CRegKey     regKey;

    return(IsTerminalServicesEnabled() &&
           (ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szTerminalServerKeyName,
                                                 s_szTerminalServerPolicyKeyName,
                                                 s_szDenyRemoteConnectionsValueName,
                                                 iResult)) &&
           (iResult == 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsRemoteConnectionPresent
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether there is a remote connection active on the
//              current system.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsRemoteConnectionPresent (void)

{
    bool        fRemoteConnectionPresent;
    HANDLE      hServer;
    PLOGONID    pLogonID, pLogonIDs;
    ULONG       ul, ulEntries;

    fRemoteConnectionPresent = false;

    //  Open a connection to terminal services and get the number of sessions.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        if (WinStationEnumerate(hServer, &pLogonIDs, &ulEntries) != FALSE)
        {

            //  Iterate the sessions looking for active and shadow sessions only.

            for (ul = 0, pLogonID = pLogonIDs; !fRemoteConnectionPresent && (ul < ulEntries); ++ul, ++pLogonID)
            {
                if ((pLogonID->State == State_Active) || (pLogonID->State == State_Shadow))
                {
                    fRemoteConnectionPresent = (lstrcmpi(pLogonID->WinStationName, TEXT("console")) != 0);
                }
            }

            //  Free any resources used.

            (BOOLEAN)WinStationFreeMemory(pLogonIDs);
        }
        (BOOLEAN)WinStationCloseServer(hServer);
    }

    //  Return result.

    return(fRemoteConnectionPresent);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsShutdownWithoutLogonAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\ShutdownWithoutLogon and returns the
//              value back to the caller.
//
//  History:    2000-04-27  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsShutdownWithoutLogonAllowed (void)

{
    int     iResult;

    return((ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 TEXT("ShutdownWithoutLogon"),
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsUndockWithoutLogonAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\UndockWithoutLogon and returns the
//              value back to the caller.
//
//  History:    2001-03-17  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsUndockWithoutLogonAllowed (void)

{
    int     iResult;

    return((ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 REGSTR_VAL_UNDOCK_WITHOUT_LOGON,
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsForceFriendlyUI
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\ForceFriendlyUI and returns the
//              value back to the caller.
//
//  History:    2000-04-27  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsForceFriendlyUI (void)

{
    int     iResult;

    return((ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 TEXT("ForceFriendlyUI"),
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::GetUIHost
//
//  Arguments:  pszPath     =   TCHAR array to receive UI host path.
//
//  Returns:    LONG
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\UIHost and returns the value.
//
//  History:    2000-04-12  vtan        created
//  --------------------------------------------------------------------------

LONG    CSystemSettings::GetUIHost (TCHAR *pszPath)

{
    return(GetEffectivePath(HKEY_LOCAL_MACHINE,
                            s_szWinlogonKeyName,
                            s_szSystemPolicyKeyName,
                            TEXT("UIHost"),
                            pszPath));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsUIHostStatic
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Read the registry HKLM\Software\Microsoft\Windows NT\
//              CurrentVersion\Winlogon\UIHostStatic and returns the
//              value.
//
//  History:    2000-04-12  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsUIHostStatic (void)

{
    int     iResult;

    return((ERROR_SUCCESS == GetEffectiveInteger(HKEY_LOCAL_MACHINE,
                                                 s_szWinlogonKeyName,
                                                 s_szSystemPolicyKeyName,
                                                 TEXT("UIHostStatic"),
                                                 iResult)) &&
           (iResult != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::EnableFriendlyUI
//
//  Arguments:  fEnable     =   Enable friendly UI.
//
//  Returns:    bool
//
//  Purpose:    Enable friendly UI. This should only be allowed on workgroup
//              machines. Check the machine status to enforce this.
//
//              ERROR_NOT_SUPPORTED is returned when the machine is joined to
//              a domain.
//
//  History:    2000-08-01  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::EnableFriendlyUI (bool fEnable)

{
    LONG    lErrorCode;

    if (!IsDomainMember() || !fEnable)
    {
        CRegKey     regKey;

        lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                                 s_szWinlogonKeyName,
                                 KEY_SET_VALUE);
        if (ERROR_SUCCESS == lErrorCode)
        {
            lErrorCode = regKey.SetDWORD(s_szLogonTypeValueName,
                                         fEnable);
            if (fEnable)
            {
                lErrorCode = regKey.SetString(s_szBackgroundValueName,
                                              TEXT("0 0 0"));
            }
            else
            {
                (LONG)regKey.DeleteValue(s_szBackgroundValueName);
            }
        }
    }
    else
    {
        lErrorCode = ERROR_NOT_SUPPORTED;
    }
    SetLastError(static_cast<DWORD>(lErrorCode));
    return(ERROR_SUCCESS == lErrorCode);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::EnableMultipleUsers
//
//  Arguments:  fEnable     =   Enable multiple users.
//
//  Returns:    bool
//
//  Purpose:    Enable the multiple users feature. This sets
//              AllowMultipleTSSessions to 1 but only does so if remote
//              connections are disabled. This allows multiple console
//              sessions but no remote sessions. If there is a remote
//              connection active this call is rejected.
//
//              ERROR_ACCESS_DENIED is returned when there are more than one
//              users active and being disabled.
//
//              ERROR_CTX_NOT_CONSOLE is returned when being disabled from
//              a remote session (disabling only allowed from the console).
//
//              ERROR_NOT_SUPPORTED is returned when being disabled from
//              the console, remote connections are enabled, and the current
//              session is not session 0.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::EnableMultipleUsers (bool fEnable)

{
    LONG    lErrorCode;

    //  If disabling multiple users with more than one users active
    //  reject the call. Return ERROR_ACCESS_DENIED.

    if (!fEnable && (GetLoggedOnUserCount() > 1))
    {
        lErrorCode = ERROR_ACCESS_DENIED;
    }

    //  If disabling and not on the console, reject the call.
    //  Return ERROR_CTX_NOT_CONSOLE.

    else if (!fEnable && !IsActiveConsoleSession())
    {
        lErrorCode = ERROR_CTX_NOT_CONSOLE;
    }

    //  If disabling from the console and remote connections are enabled and
    //  the current session is not session 0, reject the call. Otherwise, a
    //  a remote connection with FUS disabled causes strange results because
    //  it expects to connect to session 0.
    //  Return ERROR_NOT_SUPPORTED.

    else if (!fEnable && IsRemoteConnectionsEnabled() && NtCurrentPeb()->SessionId != 0)
    {
        lErrorCode = ERROR_NOT_SUPPORTED;
    }
    else
    {
        CRegKey     regKey;
   
        lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                                 s_szWinlogonKeyName,
                                 KEY_SET_VALUE);
        if (ERROR_SUCCESS == lErrorCode)
        {
            lErrorCode = regKey.SetDWORD(s_szMultipleUsersValueName,
                                         fEnable);
            if (ERROR_SUCCESS == lErrorCode)
            {
                (DWORD)AdjustFUSCompatibilityServiceState(NULL);
            }
        }
    }
    SetLastError(static_cast<DWORD>(lErrorCode));
    return(ERROR_SUCCESS == lErrorCode);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::EnableRemoteConnections
//
//  Arguments:  fEnable     =   Enable remote connections.
//
//  Returns:    bool
//
//  Purpose:    Enable the remote connections feature. This sets
//              fDenyTSConnections to 0 but only does so if there is a one
//              user logged onto the system. This allows the single
//              connection to be remotely connected but not allow multiple
//              console sessions. This conforms to the single user per CPU
//              license of the workstation product. To get multiple users
//              you need the server product.
//
//              ERROR_NOT_SUPPORTED is returned when enabling remote
//              connections with FUS disabled and the current session != 0.
//
//  History:    2000-07-28  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::EnableRemoteConnections (bool fEnable)

{
    LONG    lErrorCode;

    //  If enabling remote connections, FUS is disabled, and we are not on
    //  session 0 (can happen immediately after disabling FUS), then a remote
    //  connection will fail.  With FUS disabled, the connection must go to
    //  session 0.  This is a fringe case, but disallow enabling remote
    //  connections if it happens.

    if (fEnable && !IsMultipleUsersEnabled() && NtCurrentPeb()->SessionId != 0)
    {
        lErrorCode = ERROR_NOT_SUPPORTED;
    }
    else
    {
        CRegKey     regKey;

        lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                                 s_szTerminalServerKeyName,
                                 KEY_SET_VALUE);
        if (ERROR_SUCCESS == lErrorCode)
        {
            lErrorCode = regKey.SetDWORD(s_szDenyRemoteConnectionsValueName,
                                         !fEnable);
        }
    }
    SetLastError(static_cast<DWORD>(lErrorCode));
    return(ERROR_SUCCESS == lErrorCode);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::GetLoggedOnUserCount
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the count of logged on users on this machine. Ripped
//              straight out of shtdndlg.c in msgina.
//
//  History:    2000-03-29  vtan        created
//              2000-04-21  vtan        copied from taskmgr
//              2000-07-28  vtan        moved from userlist.cpp
//  --------------------------------------------------------------------------

int     CSystemSettings::GetLoggedOnUserCount (void)

{
    int         iCount;
    HANDLE      hServer;

    iCount = 0;

    //  Open a connection to terminal services and get the number of sessions.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        TS_COUNTER tsCounters[2] = {0};

        tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
        tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

        if (WinStationGetTermSrvCountersValue(hServer, ARRAYSIZE(tsCounters), tsCounters))
        {
            int i;

            for (i = 0; i < ARRAYSIZE(tsCounters); i++)
            {
                if (tsCounters[i].counterHead.bResult)
                {
                    iCount += tsCounters[i].dwValue;
                }
            }
        }

        (BOOLEAN)WinStationCloseServer(hServer);
    }

    //  Return result.

    return(iCount);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::CheckDomainMembership
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks the consistency of domain membership and allowing
//              multiple TS sessions. The check is only for domain membership
//              true not false.
//
//  History:    2000-04-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSystemSettings::CheckDomainMembership (void)

{
    if (IsDomainMember() && !IsForceFriendlyUI() && IsProfessionalTerminalServer())
    {
        TBOOL(EnableFriendlyUI(false));
        (BOOL)EnableMultipleUsers(false);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::AdjustFUSCompatibilityServiceState
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Turns on or off the FUS compatbility service based on the
//              FUS configuration.
//
//  History:    2001-02-12  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CSystemSettings::AdjustFUSCompatibilityServiceState (void *pV)

{
    UNREFERENCED_PARAMETER(pV);

#ifdef      _X86_

    if (IsWorkStationProduct())
    {
        bool        fMultipleUsersEnabled;
        SC_HANDLE   hSCManager;

        fMultipleUsersEnabled = IsMultipleUsersEnabled();

        //  Connect to the service control manager.

        hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (hSCManager != NULL)
        {
            SC_HANDLE   hSCService;

            //  Open the "FastUserSwitchingCompatibility" service.

            hSCService = OpenService(hSCManager,
                                     TEXT("FastUserSwitchingCompatibility"),
                                     SERVICE_START | SERVICE_STOP | SERVICE_QUERY_STATUS);
            if (hSCService != NULL)
            {
                SERVICE_STATUS  serviceStatus;

                //  Find out the status of the service.

                if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
                {
                    if (fMultipleUsersEnabled && (serviceStatus.dwCurrentState == SERVICE_STOPPED))
                    {

                        //  If it's supposed to be started and it is not
                        //  running then start the service. This can fail
                        //  because the service is set to disabled. Ignore it.

                        (BOOL)StartService(hSCService, 0, NULL);
                    }
                    else if (!fMultipleUsersEnabled && (serviceStatus.dwCurrentState == SERVICE_RUNNING))
                    {

                        //  If it's supposed to be stopped and it is
                        //  running then stop the service.

                        TBOOL(ControlService(hSCService, SERVICE_CONTROL_STOP, &serviceStatus));
                    }
                }
                TBOOL(CloseServiceHandle(hSCService));
            }
            TBOOL(CloseServiceHandle(hSCManager));
        }
    }

#endif  /*  _X86_   */

    return(0);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::GetEffectiveInteger
//
//  Arguments:  hKey                =   HKEY to read.
//              pszKeyName          =   Subkey name to read.
//              pszPolicyKeyName    =   Policy subkey name to read.
//              pszValueName        =   Value name in subkey to read.
//              iResult             =   int result.
//
//  Returns:    LONG
//
//  Purpose:    Reads the effective setting from the registry. The effective
//              setting is whatever the user chooses as the regular setting
//              overriden by policy. The policy setting is always returned if
//              present.
//
//  History:    2000-04-12  vtan        created
//  --------------------------------------------------------------------------

LONG    CSystemSettings::GetEffectiveInteger (HKEY hKey, const TCHAR *pszKeyName, const TCHAR *pszPolicyKeyName, const TCHAR *pszValueName, int& iResult)

{
    CRegKey     regKey;

    //  Start with a typical initialized value.

    iResult = 0;

    //  First check the regular location.

    if (ERROR_SUCCESS == regKey.Open(hKey,
                                     pszKeyName,
                                     KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetInteger(pszValueName, iResult);
    }

    //  Then check the policy.

    if (ERROR_SUCCESS == regKey.Open(hKey,
                                     pszPolicyKeyName,
                                     KEY_QUERY_VALUE))
    {
        (LONG)regKey.GetInteger(pszValueName, iResult);
    }

    //  Always return ERROR_SUCCESS.

    return(ERROR_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::GetEffectivePath
//
//  Arguments:  hKey                =   HKEY to read.
//              pszKeyName          =   Subkey name to read.
//              pszPolicyKeyName    =   Policy subkey name to read.
//              pszValueName        =   Value name in subkey to read.
//              pszPath             =   TCHAR array to receive effect path.
//
//  Returns:    LONG
//
//  Purpose:    Reads the effective setting from the registry. The effective
//              setting is whatever the user chooses as the regular setting
//              overriden by policy. The policy setting is always returned if
//              present. The buffer must be at least MAX_PATH characters.
//
//  History:    2000-04-12  vtan        created
//  --------------------------------------------------------------------------

LONG    CSystemSettings::GetEffectivePath (HKEY hKey, const TCHAR *pszKeyName, const TCHAR *pszPolicyKeyName, const TCHAR *pszValueName, TCHAR *pszPath)

{
    LONG    lErrorCode;

    if (IsBadWritePtr(pszPath, MAX_PATH * sizeof(TCHAR)))
    {
        lErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        LONG        lPolicyErrorCode;
        CRegKey     regKey;

        //  Start with a typical initialized value.

        *pszPath = TEXT('\0');

        //  First check the regular location.

        lErrorCode = regKey.Open(hKey,
                                 pszKeyName,
                                 KEY_QUERY_VALUE);
        if (ERROR_SUCCESS == lErrorCode)
        {
            lErrorCode = regKey.GetPath(pszValueName,
                                        pszPath);
        }

        //  Then check the policy.

        lPolicyErrorCode = regKey.Open(hKey,
                                       pszPolicyKeyName,
                                       KEY_QUERY_VALUE);
        if (ERROR_SUCCESS == lPolicyErrorCode)
        {
            lPolicyErrorCode = regKey.GetPath(pszValueName,
                                              pszPath);
        }

        //  If either error code is ERROR_SUCCESS then return that
        //  error code. Otherwise return the non policy error code.

        if ((ERROR_SUCCESS == lErrorCode) || (ERROR_SUCCESS == lPolicyErrorCode))
        {
            lErrorCode = ERROR_SUCCESS;
        }
    }
    return(lErrorCode);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsProfessionalTerminalServer
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this machine is a personal terminal server.
//              That is workstation with single user TS.
//
//  History:    2000-08-09  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsProfessionalTerminalServer (void)

{
    OSVERSIONINFOEX     osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    return((GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&osVersion)) != FALSE) &&
           (osVersion.wProductType == VER_NT_WORKSTATION) &&
           ((osVersion.wSuiteMask & VER_SUITE_PERSONAL) == 0) &&
           ((osVersion.wSuiteMask & VER_SUITE_SINGLEUSERTS) != 0));
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsMicrosoftGINA
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the current GINA is the Microsoft GINA.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsMicrosoftGINA (void)

{
    bool        fResult;
    LONG        lErrorCode;
    TCHAR       szGinaDLL[MAX_PATH];
    CRegKey     regKey;

    fResult = true;
    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             s_szWinlogonKeyName,
                             KEY_QUERY_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        fResult = (regKey.GetString(TEXT("GinaDLL"), szGinaDLL, ARRAYSIZE(szGinaDLL)) != ERROR_SUCCESS);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CSystemSettings::IsSCMTerminalServicesDisabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether terminal services is disabled via the service
//              control manager.
//
//  History:    2001-04-13  vtan        created
//  --------------------------------------------------------------------------

bool    CSystemSettings::IsSCMTerminalServicesDisabled (void)

{
    bool        fResult;
    SC_HANDLE   hSCManager;

    fResult = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager,
                                 TEXT("TermService"),
                                 SERVICE_QUERY_CONFIG);
        if (hSCService != NULL)
        {
            DWORD                   dwBytesNeeded;
            QUERY_SERVICE_CONFIG    *pQueryServiceConfig;

            (BOOL)QueryServiceConfig(hSCService, NULL, 0, &dwBytesNeeded);
            pQueryServiceConfig = static_cast<QUERY_SERVICE_CONFIG*>(LocalAlloc(LMEM_FIXED, dwBytesNeeded));
            if (pQueryServiceConfig != NULL)
            {
                fResult = ((QueryServiceConfig(hSCService,
                                               pQueryServiceConfig,
                                               dwBytesNeeded,
                                               &dwBytesNeeded) != FALSE) &&
                           (pQueryServiceConfig->dwStartType == SERVICE_DISABLED));
                (HLOCAL)LocalFree(pQueryServiceConfig);
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\tokengroups.h ===
//  --------------------------------------------------------------------------
//  Module Name: TokenGroups.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes related to authentication for use in neptune logon
//
//  History:    1999-09-13  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _TokenGroups_
#define     _TokenGroups_

//  --------------------------------------------------------------------------
//  CTokenGroups
//
//  Purpose:    This class creates a TOKEN_GROUPS struct for use in several
//              different security related functions such as for
//              secur32!LsaLogonUser which includes the owner SID as
//              well as the logon SID passed in.
//
//  History:    1999-08-17  vtan        created
//              1999-09-13  vtan        increased functionality
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CTokenGroups
{
    public:
                                        CTokenGroups (void);
                                        ~CTokenGroups (void);

                const TOKEN_GROUPS*     Get (void)                                                  const;

                NTSTATUS                CreateLogonGroup (PSID pLogonSID);
                NTSTATUS                CreateAdministratorGroup (void);

        static  NTSTATUS                StaticInitialize (void);
        static  NTSTATUS                StaticTerminate (void);
    private:
        static  PSID                    s_localSID;
        static  PSID                    s_administratorSID;

                PTOKEN_GROUPS           _pTokenGroups;
};

#endif  /*  _TokenGroups_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\tooltip.h ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Tooltip_
#define     _Tooltip_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CTooltip
//
//  Purpose:    A class that displays a tool tip balloon. It does all the
//              creation and positioning work if required. Control the life
//              span of the balloon with the object's life span.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

class   CTooltip : public CCountedObject
{
    private:
                        CTooltip (void);
    public:
                        CTooltip (HINSTANCE hInstance, HWND hwndParent);
        virtual         ~CTooltip (void);

                void    SetPosition (LONG lPosX = LONG_MIN, LONG lPosY = LONG_MIN)  const;
                void    SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const;
                void    SetText (const TCHAR *pszText)                              const;
                void    Show (void)                                                 const;
    private:
                HWND    _hwnd;
                HWND    _hwndParent;
};

#endif  /*  _Tooltip_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\turnoffdialog.h ===
//  --------------------------------------------------------------------------
//  Module Name: TurnOffDialog.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Turn Off Computer dialog.
//
//  History:    2000-04-18  vtan        created
//              2000-05-17  vtan        updated with new dialog
//  --------------------------------------------------------------------------

#ifndef     _TurnOffDialog_
#define     _TurnOffDialog_

#include "Tooltip.h"

//  --------------------------------------------------------------------------
//  CTurnOffDialog::CTurnOffDialog
//
//  Purpose:    Implements the "Turn Off Dialog" feature.
//
//  History:    2000-04-18  vtan        created
//              2000-05-17  vtan        updated with new dialog
//              2001-01-19  vtan        updated with more new visuals
//  --------------------------------------------------------------------------

class   CTurnOffDialog
{
    private:
        enum
        {
            BUTTON_STATE_REST       =   0,
            BUTTON_STATE_DOWN,
            BUTTON_STATE_HOVER,
            BUTTON_STATE_MAX,

            BUTTON_GROUP_TURNOFF    =   0,
            BUTTON_GROUP_STANDBY,
            BUTTON_GROUP_RESTART,
            BUTTON_GROUP_MAX
        };
        static  const int   MAGIC_NUMBER    =   48517;
    private:
                                        CTurnOffDialog (void);
                                        CTurnOffDialog (const CTurnOffDialog& copyObject);
                const CTurnOffDialog&   operator = (const CTurnOffDialog& assignObject);
    public:
                                        CTurnOffDialog (HINSTANCE hInstance);
                                        ~CTurnOffDialog (void);

                DWORD                   Show (HWND hwndParent);
                void                    Destroy (void);

        static  DWORD                   ShellCodeToGinaCode (DWORD dwShellCode);
        static  DWORD                   GinaCodeToExitWindowsFlags (DWORD dwGinaCode);
    private:
                bool                    IsShiftKeyDown (void)   const;
                void                    PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource);
                bool                    IsStandByButtonEnabled (void)   const;
                void                    RemoveTooltip (void);
                void                    FilterMetaCharacters (TCHAR *pszText);
                void                    EndDialog (HWND hwnd, INT_PTR iResult);
                void                    Handle_BN_CLICKED (HWND hwnd, WORD wID);
                void                    Handle_WM_INITDIALOG (HWND hwnd);
                void                    Handle_WM_DESTROY (HWND hwnd);
                void                    Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase);
                void                    Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions);
                void                    Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState);
                void                    Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS);
                void                    Handle_WM_COMMAND (HWND hwnd, WPARAM wParam);
                void                    Handle_WM_TIMER (HWND hwnd);
                void                    Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID);
                void                    Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID);
                void                    Handle_WM_MOUSELEAVE (HWND hwnd);
        static  INT_PTR     CALLBACK    CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  LRESULT     CALLBACK    ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData);
    private:
                const HINSTANCE         _hInstance;
                HBITMAP                 _hbmBackground;
                HBITMAP                 _hbmFlag;
                HBITMAP                 _hbmButtons;
                HFONT                   _hfntTitle;
                HFONT                   _hfntButton;
                HPALETTE                _hpltShell;
                RECT                    _rcBackground;
                RECT                    _rcFlag;
                RECT                    _rcButtons;
                LONG                    _lButtonHeight;
                HWND                    _hwndDialog;
                INT_PTR                 _iStandByButtonResult;
                UINT                    _uiHoverID;
                UINT                    _uiFocusID;
                UINT                    _uiTimerID;
                bool                    _fSuccessfulInitialization;
                bool                    _fSupportsStandBy;
                bool                    _fSupportsHibernate;
                bool                    _fShiftKeyDown;
                bool                    _fDialogEnded;
                CTooltip*               _pTooltip;
};

#endif  /*  _TurnOffDialog_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\tooltip.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Tooltip.h"

#include <commctrl.h>

//---------------------------------------------------------------------------
// IsBiDiLocalizedSystem is taken from stockthk.lib and simplified
//  (it's only a wrapper for GetUserDefaultUILanguage and GetLocaleInfo)
//---------------------------------------------------------------------------
typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToIntW(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{
    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    EnumUILanguagesW(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    langID = GetUserDefaultUILanguage();

    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
            {
                bRet = TRUE;
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}
//---------------------------------------------------------------------------

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}


//  --------------------------------------------------------------------------
//  CTooltip::CTooltip
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//              hwndParent  =   HWND of the parenting window.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CTooltip. Creates a tooltip window and
//              prepares it for display.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::CTooltip (HINSTANCE hInstance, HWND hwndParent) :
    CCountedObject(),
    _hwnd(NULL),
    _hwndParent(hwndParent)

{
    DWORD dwExStyle = 0;

    if ( ((GetWindowLongA( hwndParent , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL) != 0) || IsBiDiLocalizedSystem() )
    {
        dwExStyle = WS_EX_LAYOUTRTL;
    }

    _hwnd = CreateWindowEx(dwExStyle,
                           TOOLTIPS_CLASS,
                           NULL,
                           WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           hwndParent,
                           NULL,
                           hInstance,
                           NULL);
    if (_hwnd != NULL)
    {
        TOOLINFO    toolInfo;

        TBOOL(SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE));
        (LRESULT)SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
        ZeroMemory(&toolInfo, sizeof(toolInfo));
        toolInfo.cbSize = sizeof(toolInfo);
        toolInfo.uFlags = TTF_TRANSPARENT | TTF_TRACK;
        toolInfo.uId = PtrToUint(_hwnd);
        (LRESULT)SendMessage(_hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(&toolInfo));
        (LRESULT)SendMessage(_hwnd, TTM_SETMAXTIPWIDTH, 0, 300);
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::~CTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CTooltip class. This destroys the tooltip
//              window created. If the parent of the tooltip window is
//              destroyed before this is invoked user32!DestroyWindow will
//              cause the trace to fire. The object's lifetime must be
//              carefully managed by the user of this class.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::~CTooltip (void)

{
    if (_hwnd != NULL)
    {
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::SetPosition
//
//  Arguments:  lPosX   =   X position of the balloon tip window (screen).
//              lPosY   =   Y position of the balloon tip window (screen).
//
//  Returns:    <none>
//
//  Purpose:    Positions the tooltip window at the given screen co-ordinates.
//              If the parameters are defaulted then this positions the
//              tooltip relative to the parent.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetPosition (LONG lPosX, LONG lPosY)  const

{
    if ((lPosX == LONG_MIN) && (lPosY == LONG_MIN))
    {
        RECT    rc;

        TBOOL(GetWindowRect(_hwndParent, &rc));
        lPosX = (rc.left + rc.right) / 2;
        lPosY = rc.bottom;
    }
    (LRESULT)SendMessage(_hwnd, TTM_TRACKPOSITION, 0, MAKELONG(lPosX, lPosY));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetCaption
//
//  Arguments:  dwIcon      =   Icon type to set for the tooltip caption.
//              pszCaption  =   Caption of the tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip caption.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const

{
    (LRESULT)SendMessage(_hwnd, TTM_SETTITLE, dwIcon, reinterpret_cast<LPARAM>(pszCaption));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetText
//
//  Arguments:  pszText     =   Content of the actual tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip text.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetText (const TCHAR *pszText)                              const

{
    TOOLINFO    toolInfo;

    ZeroMemory(&toolInfo, sizeof(toolInfo));
    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    toolInfo.lpszText = const_cast<TCHAR*>(pszText);
    (LRESULT)SendMessage(_hwnd, TTM_UPDATETIPTEXT, 0, reinterpret_cast<LPARAM>(&toolInfo));
}

//  --------------------------------------------------------------------------
//  CTooltip::Show
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the tooltip window.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::Show (void)                                                 const

{
    TOOLINFO    toolInfo;

    ZeroMemory(&toolInfo, sizeof(toolInfo));
    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    (LRESULT)SendMessage(_hwnd, TTM_TRACKACTIVATE, TRUE, reinterpret_cast<LPARAM>(&toolInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\turnoffdialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TurnOffDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Turn Off Computer dialog.
//
//  History:    2000-04-18  vtan        created
//              2000-05-17  vtan        updated with new dialog
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "TurnOffDialog.h"

#include <ginarcid.h>
#include <msginaexports.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>

#include "DimmedWindow.h"
#include "PrivilegeEnable.h"

//  --------------------------------------------------------------------------
//  CTurnOffDialog::CTurnOffDialog
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CTurnOffDialog. This initializes member
//              variables and loads resources used by the dialog.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

CTurnOffDialog::CTurnOffDialog (HINSTANCE hInstance) :
    _hInstance(hInstance),
    _hbmBackground(NULL),
    _hbmFlag(NULL),
    _hbmButtons(NULL),
    _hfntTitle(NULL),
    _hfntButton(NULL),
    _hpltShell(NULL),
    _lButtonHeight(0),
    _hwndDialog(NULL),
    _uiHoverID(0),
    _uiFocusID(0),
    _iStandByButtonResult(SHTDN_NONE),
    _fSuccessfulInitialization(false),
    _fSupportsStandBy(false),
    _fSupportsHibernate(false),
    _fShiftKeyDown(false),
    _fDialogEnded(false),
    _pTooltip(NULL)

{
    bool        fUse8BitDepth;
    HDC         hdcScreen;
    LOGFONT     logFont;
    char        szPixelSize[10];
    BITMAP      bitmap;

    TBOOL(SetRect(&_rcBackground, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcFlag, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcButtons, 0, 0, 0, 0));

    hdcScreen = GetDC(NULL);

    //  8-bit color?

    fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);

    //  Load the bitmaps.

    _hbmBackground = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                    MAKEINTRESOURCE(fUse8BitDepth ? IDB_BACKGROUND_8 : IDB_BACKGROUND_24),
                                                    IMAGE_BITMAP,
                                                    0,
                                                    0,
                                                    LR_CREATEDIBSECTION));
    if ((_hbmBackground != NULL) && (GetObject(_hbmBackground, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcBackground, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmFlag = static_cast<HBITMAP>(LoadImage(_hInstance,
                                              MAKEINTRESOURCE(fUse8BitDepth ? IDB_FLAG_8 : IDB_FLAG_24),
                                              IMAGE_BITMAP,
                                              0,
                                              0,
                                              LR_CREATEDIBSECTION));
    if ((_hbmFlag != NULL) && (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcFlag, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmButtons = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                 MAKEINTRESOURCE(IDB_BUTTONS),
                                                 IMAGE_BITMAP,
                                                 0,
                                                 0,
                                                 LR_CREATEDIBSECTION));
    if ((_hbmButtons != NULL) && (GetObject(_hbmButtons, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcButtons, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
        _lButtonHeight = bitmap.bmHeight / ((BUTTON_GROUP_MAX * BUTTON_STATE_MAX) + 1);
    }

    //  Create fonts. Load the font name and size from resources.

    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_TURNOFF_TITLE_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_TURNOFF_TITLE_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_MEDIUM;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntTitle = CreateFontIndirect(&logFont);
        }
    }
    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_TURNOFF_BUTTON_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_TURNOFF_BUTTON_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_BOLD;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntButton = CreateFontIndirect(&logFont);
        }
    }

    //  Load the shell palette.

    _hpltShell = SHCreateShellPalette(hdcScreen);

    TBOOL(ReleaseDC(NULL, hdcScreen));

    //  Check for presence of all required resources.

    _fSuccessfulInitialization = ((_hfntTitle != NULL) &&
                                  (_hfntButton != NULL) &&
                                  (_hpltShell != NULL) &&
                                  (_hbmButtons != NULL) &&
                                  (_hbmFlag != NULL) &&
                                  (_hbmBackground != NULL));
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::~CTurnOffDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CTurnOffDialog. Release used resources and
//              unregister the window class.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

CTurnOffDialog::~CTurnOffDialog (void)

{
    ASSERTMSG(_pTooltip == NULL, "_pTooltip not released in CTurnOffDialog::~CTurnOffDialog");

    //  Release everything we allocated/loaded.

    ReleaseGDIObject(_hpltShell);
    ReleaseGDIObject(_hfntButton);
    ReleaseGDIObject(_hfntTitle);
    ReleaseGDIObject(_hbmButtons);
    ReleaseGDIObject(_hbmFlag);
    ReleaseGDIObject(_hbmBackground);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Show
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Presents the "Turn Off Computer" dialog to the user and
//              returns the result of the dialog back to the caller.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

DWORD   CTurnOffDialog::Show (HWND hwndParent)

{
    INT_PTR     iResult;

    if (_fSuccessfulInitialization)
    {
        CDimmedWindow   *pDimmedWindow;

        //  If no parent was given the create our own dimmed window.

        if (hwndParent == NULL)
        {
            pDimmedWindow = new CDimmedWindow(_hInstance);
            if (pDimmedWindow != NULL)
            {
                hwndParent = pDimmedWindow->Create();
            }
            else
            {
                hwndParent = NULL;
            }
        }
        else
        {
            pDimmedWindow = NULL;
        }

        //  Show the dialog and get a result.

        iResult = DialogBoxParam(_hInstance,
                                 MAKEINTRESOURCE(IDD_TURNOFFCOMPUTER),
                                 hwndParent,
                                 CB_DialogProc,
                                 reinterpret_cast<LPARAM>(this));
        if (pDimmedWindow != NULL)
        {
            pDimmedWindow->Release();
        }
    }
    else
    {
        iResult = SHTDN_NONE;
    }
    return(static_cast<DWORD>(iResult));
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Destroy
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Force destroys the Turn Off Computer dialog. This is done in
//              cases such as a screen saver is becoming active.
//
//  History:    2000-06-06  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Destroy (void)

{
    if (_hwndDialog != NULL)
    {
        EndDialog(_hwndDialog, SHTDN_NONE);
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::ShellCodeToGinaCode
//
//  Arguments:  dwShellCode     =   SHTDN_xxx result code.
//
//  Returns:    DWORD
//
//  Purpose:    Converts SHTDN_xxx dialog result code back to a GINA
//              MSGINA_DLG_xxx code so that it's consistent for both the
//              classic UI and friendly UI functionality.
//
//  History:    2000-06-05  vtan        created
//              2001-04-10  vtan        moved from CPowerButton
//  --------------------------------------------------------------------------

DWORD   CTurnOffDialog::ShellCodeToGinaCode (DWORD dwShellCode)

{
    DWORD   dwGinaCode = 0;

    switch (dwShellCode)
    {
        case SHTDN_NONE:
            dwGinaCode = MSGINA_DLG_FAILURE;
            break;
        case SHTDN_LOGOFF:
            dwGinaCode = MSGINA_DLG_USER_LOGOFF;
            break;
        case SHTDN_SHUTDOWN:
        {
            SYSTEM_POWER_CAPABILITIES   spc;

            CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

            (NTSTATUS)NtPowerInformation(SystemPowerCapabilities,
                                         NULL,
                                         0,
                                         &spc,
                                         sizeof(spc));
            dwGinaCode = MSGINA_DLG_SHUTDOWN | (spc.SystemS5 ? MSGINA_DLG_POWEROFF_FLAG : MSGINA_DLG_SHUTDOWN_FLAG);
            break;
        }
        case SHTDN_RESTART:
            dwGinaCode = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_REBOOT_FLAG;
            break;
        case SHTDN_SLEEP:
            dwGinaCode = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP_FLAG;
            break;
        case SHTDN_HIBERNATE:
            dwGinaCode = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_HIBERNATE_FLAG;
            break;
        case SHTDN_DISCONNECT:
            dwGinaCode = MSGINA_DLG_DISCONNECT;
            break;
        default:
            WARNINGMSG("Unexpected (ignored) shell code passed to CTurnOffDialog::ShellCodeToGinaCode");
            dwGinaCode = MSGINA_DLG_FAILURE;
            break;
    }
    return(dwGinaCode);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::GinaCodeToExitWindowsFlags
//
//  Arguments:  dwGinaCode  =   GINA dialog return code.
//
//  Returns:    DWORD
//
//  Purpose:    Converts internal MSGINA dialog return code to standard
//              ExitWindowsEx flags.
//
//  History:    2001-05-23  vtan        created
//  --------------------------------------------------------------------------

DWORD   CTurnOffDialog::GinaCodeToExitWindowsFlags (DWORD dwGinaCode)

{
    DWORD   dwResult;

    dwResult = 0;
    if ((dwGinaCode & ~MSGINA_DLG_FLAG_MASK) == MSGINA_DLG_SHUTDOWN)
    {
        switch (dwGinaCode & MSGINA_DLG_FLAG_MASK)
        {
            case MSGINA_DLG_REBOOT_FLAG:
                dwResult = EWX_REBOOT;
                break;
            case MSGINA_DLG_POWEROFF_FLAG:
                dwResult = EWX_POWEROFF;
                break;
            case MSGINA_DLG_SHUTDOWN_FLAG:
                dwResult = EWX_SHUTDOWN;
                break;
            default:
                break;
        }
    }
    return(dwResult);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::IsShiftKeyDown
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the shift key is down for input on this
//              thread.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

bool    CTurnOffDialog::IsShiftKeyDown (void)   const

{
    return((GetKeyState(VK_SHIFT) & 0x8000) != 0);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::PaintBitmap
//
//  Arguments:  hdcDestination  =   HDC to paint into.
//              prcDestination  =   RECT in HDC to paint into.
//              hbmSource       =   HBITMAP to paint.
//              prcSource       =   RECT from HBITMAP to paint from.
//
//  Returns:    <none>
//
//  Purpose:    Wraps blitting a bitmap.
//
//  History:    2001-01-19  vtan        created
//              2001-03-17  vtan        added source RECT for strip blitting
//  --------------------------------------------------------------------------

void    CTurnOffDialog::PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource)

{
    HDC     hdcBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap != NULL)
    {
        bool        fEqualWidthAndHeight;
        int         iWidthSource, iHeightSource, iWidthDestination, iHeightDestination;
        int         iStretchBltMode;
        DWORD       dwLayout;
        HBITMAP     hbmSelected;
        RECT        rcSource;
        BITMAP      bitmap;

        if (prcSource == NULL)
        {
            if (GetObject(hbmSource, sizeof(bitmap), &bitmap) == 0)
            {
                bitmap.bmWidth = prcDestination->right - prcDestination->left;
                bitmap.bmHeight = prcDestination->bottom - prcDestination->top;
            }
            TBOOL(SetRect(&rcSource, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
            prcSource = &rcSource;
        }
        hbmSelected = static_cast<HBITMAP>(SelectObject(hdcBitmap, hbmSource));
        iWidthSource = prcSource->right - prcSource->left;
        iHeightSource = prcSource->bottom - prcSource->top;
        iWidthDestination = prcDestination->right - prcDestination->left;
        iHeightDestination = prcDestination->bottom - prcDestination->top;
        fEqualWidthAndHeight = (iWidthSource == iWidthDestination) && (iHeightSource == iHeightDestination);
        if (!fEqualWidthAndHeight)
        {
            iStretchBltMode = SetStretchBltMode(hdcDestination, HALFTONE);
        }
        else
        {
            iStretchBltMode = 0;
        }
        dwLayout = SetLayout(hdcDestination, LAYOUT_BITMAPORIENTATIONPRESERVED);
        TBOOL(TransparentBlt(hdcDestination,
                             prcDestination->left,
                             prcDestination->top,
                             iWidthDestination,
                             iHeightDestination,
                             hdcBitmap,
                             prcSource->left,
                             prcSource->top,
                             iWidthSource,
                             iHeightSource,
                             RGB(255, 0, 255)));
        (DWORD)SetLayout(hdcDestination, dwLayout);
        if (!fEqualWidthAndHeight)
        {
            (int)SetStretchBltMode(hdcDestination, iStretchBltMode);
        }
        (HGDIOBJ)SelectObject(hdcBitmap, hbmSelected);
        TBOOL(DeleteDC(hdcBitmap));
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::IsStandByButtonEnabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the Stand By button is enabled.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

bool    CTurnOffDialog::IsStandByButtonEnabled (void)   const

{
    return(_iStandByButtonResult != SHTDN_NONE);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::RemoveTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip if present. This can be accessed from two
//              different threads so make sure that it's serialized.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::RemoveTooltip (void)

{
    CTooltip    *pTooltip;

    pTooltip = static_cast<CTooltip*>(InterlockedExchangePointer(reinterpret_cast<void**>(&_pTooltip), NULL));
    if (pTooltip != NULL)
    {
        pTooltip->Release();
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::FilterMetaCharacters
//
//  Arguments:  pszText     =   String to filter.
//
//  Returns:    <none>
//
//  Purpose:    Filters meta-characters from the given string.
//
//  History:    2000-06-13  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::FilterMetaCharacters (TCHAR *pszText)

{
    TCHAR   *pTC;

    pTC = pszText;
    while (*pTC != TEXT('\0'))
    {
        if (*pTC == TEXT('&'))
        {
            (TCHAR*)lstrcpy(pTC, pTC + 1);
        }
        else
        {
            ++pTC;
        }
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::EndDialog
//
//  Arguments:  hwnd        =   HWND of dialog.
//              iResult     =   Result to end dialog with.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tool tip if present. Ends the dialog.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::EndDialog (HWND hwnd, INT_PTR iResult)

{
    RemoveTooltip();

    //  Set the dialog end member variable here. This will cause the WM_ACTIVATE
    //  handler to ignore the deactivation associated with ending the dialog. If
    //  it doesn't ignore it then it thinks the dialog is being deactivated
    //  because another dialog is activating and ends the dialog with SHTDN_NONE.

    _fDialogEnded = true;
    TBOOL(::EndDialog(hwnd, iResult));
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_BN_CLICKED
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wID     =   ID of control.
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_BN_CLICKED (HWND hwnd, WORD wID)

{
    switch (wID)
    {
        case IDCANCEL:
            EndDialog(hwnd, SHTDN_NONE);
            break;
        case IDC_BUTTON_TURNOFF:
            EndDialog(hwnd, SHTDN_SHUTDOWN);
            break;
        case IDC_BUTTON_STANDBY:

            //  IDC_BUTTON_STANDBY is the visual button. Return whatever the current
            //  result is back (this could be SHTDN_SLEEP or SHTDN_HIBERNATE.

            ASSERTMSG(_iStandByButtonResult != SHTDN_NONE, "No result for Stand By button in CTurnOffDialog::Handle_BN_CLICKED");
            EndDialog(hwnd, _iStandByButtonResult);
            break;
        case IDC_BUTTON_RESTART:
            EndDialog(hwnd, SHTDN_RESTART);
            break;
        case IDC_BUTTON_HIBERNATE:

            //  IDC_BUTTON_HIBERNATE is the regular button that is 30000+ pixels to
            //  the right of the dialog and not visible. It's present to allow the
            //  "&Hibernate" accelerator to work when hibernate is supported.

            EndDialog(hwnd, SHTDN_HIBERNATE);
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of this window.
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_INITDIALOG message. Centre the dialog on the main
//              monitor. Subclass the buttons so that we can get hover state
//              correctly implemented. Correctly set up whether the Stand By
//              button is allowed and what the action of the button is.
//
//              If the machine supports S1-S3 then S1 is the default action.
//              Holding down the shift key will convert this to S4. If the
//              machine does not support S1-S3 but supports S4 then S4 is the
//              default action and the shift key feature is disabled.
//              Otherwise the machine doesn't support any lower power state
//              at which case we disable the button entirely.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//              2001-01-19  vtan        rework for shift behavior
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_INITDIALOG (HWND hwnd)

{
    HWND    hwndButtonStandBy, hwndButtonHibernate;
    RECT    rc;

    _hwndDialog = hwnd;

    //  Center the dialog on the main monitor.

    TBOOL(GetClientRect(hwnd, &rc));
    TBOOL(SetWindowPos(hwnd,
                       HWND_TOP,
                       (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
                       (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3,
                       0,
                       0,
                       SWP_NOSIZE));

    //  Subclass buttons for tooltips and cursor control.

    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_TURNOFF), ButtonSubClassProc, IDC_BUTTON_TURNOFF, reinterpret_cast<DWORD_PTR>(this)));
    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_STANDBY), ButtonSubClassProc, IDC_BUTTON_STANDBY, reinterpret_cast<DWORD_PTR>(this)));
    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_RESTART), ButtonSubClassProc, IDC_BUTTON_RESTART, reinterpret_cast<DWORD_PTR>(this)));

    //  What does this machine support?

    {
        SYSTEM_POWER_CAPABILITIES   spc;

        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        (NTSTATUS)NtPowerInformation(SystemPowerCapabilities,
                                     NULL,
                                     0,
                                     &spc,
                                     sizeof(spc));
        _fSupportsHibernate = (spc.SystemS4 && spc.HiberFilePresent);
        _fSupportsStandBy = (spc.SystemS1 || spc.SystemS2 || spc.SystemS3);
    }

    hwndButtonStandBy = GetDlgItem(hwnd, IDC_BUTTON_STANDBY);
    hwndButtonHibernate = GetDlgItem(hwnd, IDC_BUTTON_HIBERNATE);
    if (_fSupportsStandBy)
    {
        _iStandByButtonResult = SHTDN_SLEEP;
        if (_fSupportsHibernate)
        {

            //  Machine supports Stand By AND Hibernate.

            _fShiftKeyDown = false;
            _uiTimerID = static_cast<UINT>(SetTimer(hwnd, MAGIC_NUMBER, 50, NULL));
        }
        else
        {

            //  Machine supports Stand By ONLY.

            (BOOL)EnableWindow(hwndButtonHibernate, FALSE);
        }
    }
    else if (_fSupportsHibernate)
    {
        int     iCaptionLength;
        TCHAR   *pszCaption;

        //  Machine supports Hibernate ONLY.

        _iStandByButtonResult = SHTDN_HIBERNATE;

        //  Replace the text on IDC_BUTTON_STANDBY with the text from
        //  IDC_BUTTON_HIBERNATE. This will allow the dialog to keep
        //  the visual button enabled and behave just like the button
        //  should in the Stand By case but results in hibernate.
        //  Once the text has been transferred disable IDC_BUTTON_HIBERNATE.

        iCaptionLength = GetWindowTextLength(hwndButtonHibernate) + sizeof('\0');
        pszCaption = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, iCaptionLength * sizeof(TCHAR)));
        if (pszCaption != NULL)
        {
            if (GetWindowText(hwndButtonHibernate, pszCaption, iCaptionLength) != 0)
            {
                TBOOL(SetWindowText(hwndButtonStandBy, pszCaption));
                (BOOL)EnableWindow(hwndButtonHibernate, FALSE);
            }
            (HLOCAL)LocalFree(pszCaption);
        }
    }
    else
    {

        //  Machine does NOT support Stand By NOR Hibernate.

        (BOOL)EnableWindow(hwndButtonStandBy, FALSE);
        (BOOL)EnableWindow(hwndButtonHibernate, FALSE);
        _iStandByButtonResult = SHTDN_NONE;
    }
    if (_fSupportsStandBy || _fSupportsHibernate)
    {

        //  Set the focus to the "Stand By" button.

        (HWND)SetFocus(GetDlgItem(hwnd, IDC_BUTTON_STANDBY));
        _uiFocusID = IDC_BUTTON_STANDBY;
    }
    else
    {

        //  If that button isn' available set to "Turn Off" button.

        (HWND)SetFocus(GetDlgItem(hwnd, IDC_BUTTON_TURNOFF));
        _uiFocusID = IDC_BUTTON_TURNOFF;
    }
    (LRESULT)SendMessage(hwnd, DM_SETDEFID, _uiFocusID, 0);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_DESTROY
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Removes the subclassing of the button windows and can do any
//              other clean up required in WM_DESTROY.
//
//  History:    2000-05-18  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_DESTROY (HWND hwnd)

{
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_RESTART), ButtonSubClassProc, IDC_BUTTON_RESTART));
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_STANDBY), ButtonSubClassProc, IDC_BUTTON_STANDBY));
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_TURNOFF), ButtonSubClassProc, IDC_BUTTON_TURNOFF));
    _hwndDialog = NULL;
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_ERASEBKGND
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//
//  Returns:    <none>
//
//  Purpose:    Erases the background.
//
//  History:    2001-01-19  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase)

{
    RECT    rc;

    TBOOL(GetClientRect(hwnd, &rc));
    PaintBitmap(hdcErase, &rc, _hbmBackground, &_rcBackground);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_PRINTCLIENT
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//              dwOptions   =   Options for drawing.
//
//  Returns:    <none>
//
//  Purpose:    Handles painting the client area for WM_PRINTCLIENT.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions)

{
    if ((dwOptions & (PRF_ERASEBKGND | PRF_CLIENT)) != 0)
    {
        Handle_WM_ERASEBKGND(hwnd, hdcPrint);
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_ACTIVATE
//
//  Arguments:  hwnd        =   HWND to erase.
//              dwState     =   Activate state.
//
//  Returns:    <none>
//
//  Purpose:    Detects if this window is becoming inactive. In this case
//              end the dialog.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState)

{
    if ((WA_INACTIVE == dwState) && !_fDialogEnded)
    {
        EndDialog(hwnd, SHTDN_NONE);
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_DRAWITEM
//
//  Arguments:  hwnd    =   HWND of the parent window.
//              pDIS    =   DRAWITEMSTRUCT defining what to draw.
//
//  Returns:    <none>
//
//  Purpose:    Draws several aspects of the turn off dialog. It handles the
//              title text, the owner draw bitmap buttons, the text for the
//              bitmap buttons and the separator line.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS)

{
    HPALETTE    hPaletteOld;
    HFONT       hfntSelected;
    int         iBkMode;
    COLORREF    colorText;
    RECT        rc;
    SIZE        size;
    TCHAR       szText[256];

    hPaletteOld = SelectPalette(pDIS->hDC, _hpltShell, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
    switch (pDIS->CtlID)
    {
        case IDC_BUTTON_TURNOFF:
        case IDC_BUTTON_STANDBY:
        case IDC_BUTTON_RESTART:
        {
            int     iState, iGroup;

            //  Select the correct state index to use. Check for ODS_SELECTED first.
            //  Then check for hover or ODS_FOCUS. Otherwise use the rest state.

            if ((pDIS->itemState & ODS_SELECTED) != 0)
            {
                iState = BUTTON_STATE_DOWN;
            }
            else if ((_uiHoverID == pDIS->CtlID) || ((pDIS->itemState & ODS_FOCUS) != 0))
            {
                iState = BUTTON_STATE_HOVER;
            }
            else
            {
                iState = BUTTON_STATE_REST;
            }

            //  Now select the correct bitmap based on the state index. Special case
            //  IDC_BUTTON_STANDBY because if it's disabled then select the special
            //  disabled button.

            switch (pDIS->CtlID)
            {
                case IDC_BUTTON_TURNOFF:
                    iGroup = BUTTON_GROUP_TURNOFF;
                    break;
                case IDC_BUTTON_STANDBY:
                    if (IsStandByButtonEnabled())
                    {
                        iGroup = BUTTON_GROUP_STANDBY;
                    }
                    else
                    {
                        iGroup = BUTTON_GROUP_MAX;
                        iState = 0;
                    }
                    break;
                case IDC_BUTTON_RESTART:
                    iGroup = BUTTON_GROUP_RESTART;
                    break;
                default:
                    iGroup = -1;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            if (iGroup >= 0)
            {
                RECT    rc;

                //  Calculate which part of the background to blit into the DC.
                //  Only blit the amount that's necessary to avoid excessive
                //  blitting. Once blitted then blit the button BMP. The blit
                //  uses msimg32!TransparentBlt with the magical magenta color.

                TBOOL(CopyRect(&rc, &_rcBackground));
                (int)MapWindowPoints(pDIS->hwndItem, hwnd, reinterpret_cast<POINT*>(&rc), sizeof(RECT) / sizeof(POINT));
                rc.right = rc.left + (_rcButtons.right - _rcButtons.left);
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmBackground, &rc);
                TBOOL(CopyRect(&rc, &_rcButtons));
                rc.top = ((iGroup * BUTTON_STATE_MAX) + iState) * _lButtonHeight;
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmButtons, &rc);
            }
            break;
        }
        case IDC_TITLE_FLAG:
        {
            BITMAP      bitmap;

            GetClientRect(pDIS->hwndItem, &rc);
            if (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) != 0)
            {
                rc.left += ((rc.right - rc.left) - bitmap.bmWidth) / 2;
                rc.right = rc.left + bitmap.bmWidth;
                rc.top += ((rc.bottom - rc.top) - bitmap.bmHeight) / 2;
                rc.bottom = rc.top + bitmap.bmHeight;
            }
            PaintBitmap(pDIS->hDC, &rc, _hbmFlag, &_rcFlag);
            break;
        }
        case IDC_TITLE_TURNOFF:
        {

            //  Draw the title of the dialog "Turn Off Computer".

            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntTitle));
            colorText = SetTextColor(pDIS->hDC, 0x00FFFFFF);
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, pDIS->CtlID), szText, ARRAYSIZE(szText));
            TBOOL(GetTextExtentPoint(pDIS->hDC, szText, lstrlen(szText), &size));
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, 0, -((rc.bottom - rc.top - size.cy) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        case IDC_TEXT_TURNOFF:
        case IDC_TEXT_STANDBY:
        case IDC_TEXT_RESTART:
        {
            int         iPixelHeight, iButtonID;
            COLORREF    colorButtonText;
            RECT        rcText;

            //  The text to display is based on the button title. Map the static
            //  text ID to a "parent" button ID. Special case IDC_TEXT_STANDBY.

            switch (pDIS->CtlID)
            {
                case IDC_TEXT_TURNOFF:
                    iButtonID = IDC_BUTTON_TURNOFF;
                    break;
                case IDC_TEXT_STANDBY:

                    //  For Stand By base it on the button result.

                    switch (_iStandByButtonResult)
                    {
                        case SHTDN_HIBERNATE:
                            iButtonID = IDC_BUTTON_HIBERNATE;
                            break;
                        case SHTDN_SLEEP:
                        default:
                            iButtonID = IDC_BUTTON_STANDBY;
                            break;
                    }
                    break;
                case IDC_TEXT_RESTART:
                    iButtonID = IDC_BUTTON_RESTART;
                    break;
                default:
                    iButtonID = 0;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntButton));

            //  If the text field is not Stand By or supports S1-S3 or supports S4
            //  use the regular text color. Otherwise the button is disabled.

            if ((pDIS->CtlID != IDC_TEXT_STANDBY) || _fSupportsStandBy || _fSupportsHibernate)
            {
                colorButtonText = RGB(255, 255, 255);
            }
            else
            {
                colorButtonText = RGB(160, 160, 160);
            }
            colorText = SetTextColor(pDIS->hDC, colorButtonText);
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, iButtonID), szText, ARRAYSIZE(szText));
            TBOOL(CopyRect(&rcText, &pDIS->rcItem));
            iPixelHeight = DrawText(pDIS->hDC, szText, -1, &rcText, DT_CALCRECT);
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, -((rc.right - rc.left - (rcText.right - rcText.left)) / 2), -((rc.bottom - rc.top - iPixelHeight) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, ((pDIS->itemState & ODS_NOACCEL ) != 0) ? DT_HIDEPREFIX : 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        default:
        {
            DISPLAYMSG("Unknown control ID passed to CTurnOffDialog::Handle_WM_DRAWITEM");
            break;
        }
    }
    (HGDIOBJ)SelectPalette(pDIS->hDC, hPaletteOld, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_COMMAND
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wParam  =   WPARAM (see platform SDK under WM_COMMAND).
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2000-05-17  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_COMMAND (HWND hwnd, WPARAM wParam)

{
    switch (HIWORD(wParam))
    {
        case BN_CLICKED:
            Handle_BN_CLICKED(hwnd, LOWORD(wParam));
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_TIMER
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_TIMER. This periodically checks for the state of
//              shift key. The dialog manager doesn't give the DialogProc
//              events for the shift key. This appears to be the only way to
//              accomplish this for Win32 dialogs.
//
//  History:    2001-01-20  vtan        created
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_TIMER (HWND hwnd)

{
    bool    fShiftKeyDown;

    fShiftKeyDown = IsShiftKeyDown();

    //  Has the shift key state changed since the last time?

    if (_fShiftKeyDown != fShiftKeyDown)
    {
        HWND    hwndText;
        RECT    rc;

        //  Save the shift key state.

        _fShiftKeyDown = fShiftKeyDown;

        //  Toggle the result.

        switch (_iStandByButtonResult)
        {
            case SHTDN_SLEEP:
                _iStandByButtonResult = SHTDN_HIBERNATE;
                break;
            case SHTDN_HIBERNATE:
                _iStandByButtonResult = SHTDN_SLEEP;
                break;
            default:
                DISPLAYMSG("Unexpect _iStandByButtonResult in CTurnOffDialog::Handle_WM_TIMER");
                break;
        }

        //  Get the client rectangle of the text for the button (IDC_TEXT_STANDBY).
        //  Map the rectangle to co-ordinates in the parent HWND. Invalidate that
        //  rectangle for the parent HWND. It's important to invalidate the parent
        //  so that the background for the text is also drawn by sending a
        //  WM_ERASEBKGND to the parent of the button.

        hwndText = GetDlgItem(hwnd, IDC_TEXT_STANDBY);
        TBOOL(GetClientRect(hwndText, &rc));
        (int)MapWindowPoints(hwndText, hwnd, reinterpret_cast<POINT*>(&rc), sizeof(rc) / sizeof(POINT));
        TBOOL(InvalidateRect(hwnd, &rc, TRUE));

        //  If there was a tooltip for the Stand By button then
        //  remove it and reshow it. Only do this for Stand By.

        if ((_pTooltip != NULL) && (_uiHoverID == IDC_BUTTON_STANDBY))
        {
            RemoveTooltip();
            _uiHoverID = 0;
        }
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_MOUSEMOVE
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Sets the cursor to a hand and tracks mouse movement in the
//              control. Refresh the control to show the hover state.
//
//  History:    2000-06-09  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID)

{
    (HCURSOR)SetCursor(LoadCursor(NULL, IDC_HAND));
    if (uiID != _uiHoverID)
    {
        TRACKMOUSEEVENT     tme;

        _uiHoverID = uiID;
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_HOVER | TME_LEAVE;
        tme.hwndTrack = hwnd;
        tme.dwHoverTime = HOVER_DEFAULT;
        TBOOL(TrackMouseEvent(&tme));
        TBOOL(InvalidateRect(hwnd, NULL, FALSE));
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_MOUSEHOVER
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Handles hovering over the control. Determine which tooltip to
//              bring up and show it.
//
//  History:    2000-06-09  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID)

{
    int     iTextID;
    HWND    hwndCaption;

    hwndCaption = hwnd;

    //  The tooltip is based on the button being hovered over. Special case
    //  IDC_BUTTON_STANDBY. Based on the intended result if clicked bring
    //  up the appropriate tooltip text. This will be one of three states:
    //      1) Stand By (with shift key toggling).
    //      2) Stand By (shift key is disabled - nothing extra).
    //      3) Hibernate.
    //  In the case of hibernate make sure to use IDC_BUTTON_HIBERNATE as the
    //  button for the tooltip caption. In the case of hibernate only even
    //  though the button is disabled the text is still correct.

    switch (uiID)
    {
        case IDC_BUTTON_TURNOFF:
            iTextID = IDS_TURNOFF_TOOLTIP_TEXT_TURNOFF;
            break;
        case IDC_BUTTON_STANDBY:
            switch (_iStandByButtonResult)
            {
                case SHTDN_SLEEP:
                    if (_fSupportsHibernate)
                    {
                        iTextID = IDS_TURNOFF_TOOLTIP_TEXT_STANDBY_HIBERNATE;
                    }
                    else
                    {
                        iTextID = IDS_TURNOFF_TOOLTIP_TEXT_STANDBY;
                    }
                    break;
                case SHTDN_HIBERNATE:
                    hwndCaption = GetDlgItem(GetParent(hwnd), IDC_BUTTON_HIBERNATE);
                    iTextID = IDS_TURNOFF_TOOLTIP_TEXT_HIBERNATE;
                    break;
                default:
                    iTextID = 0;
                    DISPLAYMSG("Unexpected _iStandByButtonResult in CTurnOffDialog::Handle_WM_MOUSEHOVER");
                    break;
            }
            break;
        case IDC_BUTTON_RESTART:
            iTextID = IDS_TURNOFF_TOOLTIP_TEXT_RESTART;
            break;
        default:
            iTextID = 0;
            break;
    }

    //  Construct the tooltip and show it.

    if (iTextID != 0)
    {
        int     iCaptionLength;
        TCHAR   *pszCaption;

        iCaptionLength = GetWindowTextLength(hwndCaption) + sizeof('\0');
        pszCaption = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, iCaptionLength * sizeof(TCHAR)));
        if (pszCaption != NULL)
        {
            if (GetWindowText(hwndCaption, pszCaption, iCaptionLength) != 0)
            {
                _pTooltip = new CTooltip(_hInstance, hwnd);
                if (_pTooltip != NULL)
                {
                    TCHAR   szText[256];

                    if (LoadString(_hInstance, iTextID, szText + sizeof('\r') + sizeof('\n'), ARRAYSIZE(szText) - sizeof('\r') - sizeof('\n')) != 0)
                    {
                        FilterMetaCharacters(pszCaption);
                        szText[0] = TEXT('\r');
                        szText[1] = TEXT('\n');
                        _pTooltip->SetPosition();
                        _pTooltip->SetCaption(0, pszCaption);
                        _pTooltip->SetText(szText);
                        _pTooltip->Show();
                    }
                }
            }
            (HLOCAL)LocalFree(pszCaption);
        }
    }
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::Handle_WM_MOUSELEAVE
//
//  Arguments:  hwnd    =   HWND of the control.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip and clears the hover ID.
//
//  History:    2000-06-09  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

void    CTurnOffDialog::Handle_WM_MOUSELEAVE (HWND hwnd)

{
    RemoveTooltip();
    _uiHoverID = 0;
    TBOOL(InvalidateRect(hwnd, NULL, FALSE));
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::CB_DialogProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    See the platform SDK under DialogProc.
//
//  Purpose:    Main DialogProc dispatch entry point for the turn off dialog.
//              To keep this simple it calls member functions.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CTurnOffDialog::CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR         iResult;
    CTurnOffDialog  *pThis;

    pThis = reinterpret_cast<CTurnOffDialog*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CTurnOffDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
            pThis->Handle_WM_INITDIALOG(hwnd);
            iResult = FALSE;
            break;
        case WM_DESTROY:
            pThis->Handle_WM_DESTROY(hwnd);
            iResult = 0;
            break;
        case WM_ERASEBKGND:
            pThis->Handle_WM_ERASEBKGND(hwnd, reinterpret_cast<HDC>(wParam));
            iResult = 1;
            break;
        case WM_PRINTCLIENT:
            pThis->Handle_WM_PRINTCLIENT(hwnd, reinterpret_cast<HDC>(wParam), static_cast<DWORD>(lParam));
            iResult = 1;        //  This tells the button that it was handled.
            break;
        case WM_ACTIVATE:
            pThis->Handle_WM_ACTIVATE(hwnd, static_cast<DWORD>(wParam));
            iResult = 1;
            break;
        case WM_DRAWITEM:
            pThis->Handle_WM_DRAWITEM(hwnd, reinterpret_cast<DRAWITEMSTRUCT*>(lParam));
            iResult = TRUE;
            break;
        case WM_COMMAND:
            pThis->Handle_WM_COMMAND(hwnd, wParam);
            iResult = 0;
            break;
        case WM_TIMER:
            ASSERTMSG(static_cast<UINT>(wParam) == pThis->_uiTimerID, "Unexpected timer ID mismatch in CTurnOffDialog::CB_DialogProc");
            pThis->Handle_WM_TIMER(hwnd);
            iResult = 0;
            break;
        default:
            iResult = 0;
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CTurnOffDialog::ButtonSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows the bitmap
//              buttons to hover and track accordingly. This also allows our
//              BS_OWNERDRAW buttons to be pushed when the keyboard is used.
//
//  History:    2000-05-17  vtan        created
//              2001-01-18  vtan        update with new visuals
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    CTurnOffDialog::ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT         lResult;
    CTurnOffDialog  *pThis;

    pThis = reinterpret_cast<CTurnOffDialog*>(dwRefData);
    switch (uMsg)
    {

        //  Do NOT allow BM_SETSTYLE to go thru to the default handler. This is
        //  because DLGC_UNDEFPUSHBUTTON is returned for WM_GETDLGCODE. When the
        //  dialog manager sees this it tries to set the focus style on the button.
        //  Even though it's owner drawn the button window proc still draws the
        //  focus state (because we returned DLGC_UNDEFPUSHBUTTON). Therefore to
        //  ensure the bitmap isn't over-painted by the button window proc blow off
        //  the BM_SETSTYLE and don't let it get to the button window proc.

        case BM_SETSTYLE:
            if (wParam == BS_DEFPUSHBUTTON)
            {
                pThis->_uiFocusID = static_cast<UINT>(uiID);
            }
            if (uiID != IDCANCEL)
            {
                lResult = 0;
                break;
            }
            //  Fall thru
        default:

            //  Otherwise in the default case let the default handler at the message
            //  first. This implements tail-patching.

            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            switch (uMsg)
            {
                case DM_GETDEFID:
                    lResult = (DC_HASDEFID << 16) | static_cast<WORD>(pThis->_uiFocusID);
                    break;
                case WM_GETDLGCODE:
                    if (uiID == pThis->_uiFocusID)
                    {
                        lResult |= DLGC_DEFPUSHBUTTON;
                    }
                    else
                    {
                        lResult |= DLGC_UNDEFPUSHBUTTON;
                    }
                    break;
                case WM_MOUSEMOVE:
                    pThis->Handle_WM_MOUSEMOVE(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSEHOVER:
                    pThis->Handle_WM_MOUSEHOVER(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSELEAVE:
                    pThis->Handle_WM_MOUSELEAVE(hwnd);
                    break;
                default:
                    break;
            }
    }
    return(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\userlist.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: UserList.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the user list filtering algorithm shared by winlogon
//  calling into msgina and shgina (the logonocx) calling into msgina.
//
//  History:    1999-10-30  vtan        created
//              1999-11-26  vtan        moved from logonocx
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "UserList.h"

#include <shlwapi.h>
#include <shlwapip.h>
#include <winsta.h>

#include "RegistryResources.h"
#include "SpecialAccounts.h"
#include "SystemSettings.h"

//  --------------------------------------------------------------------------
//  CUserList::s_SIDAdministrator
//  CUserList::s_SIDGuest
//  CUserList::s_szAdministratorsGroupName
//  CUserList::s_szPowerUsersGroupName
//  CUserList::s_szUsersGroupName
//  CUserList::s_szGuestsGroupName
//
//  Purpose:    Stores the localized name of the well known accounts
//              "Administrator" and "Guest". These accounts are determined
//              by SID. Also stores the localized name of the local
//              "Administrators" group.
//
//  History:    2000-02-15  vtan        created
//              2000-03-06  vtan        added Administrators group
//              2001-05-10  vtan        changed user strings to SID
//  --------------------------------------------------------------------------

unsigned char   CUserList::s_SIDAdministrator[256]                              =   {   0       };
unsigned char   CUserList::s_SIDGuest[256]                                      =   {   0       };
WCHAR           CUserList::s_szAdministratorsGroupName[GNLEN + sizeof('\0')]    =   {   L'\0'   };
WCHAR           CUserList::s_szPowerUsersGroupName[GNLEN + sizeof('\0')]        =   {   L'\0'   };
WCHAR           CUserList::s_szUsersGroupName[GNLEN + sizeof('\0')]             =   {   L'\0'   };
WCHAR           CUserList::s_szGuestsGroupName[GNLEN + sizeof('\0')]            =   {   L'\0'   };

//  --------------------------------------------------------------------------
//  CUserList::Get
//
//  Arguments:  fRemoveGuest            =   Always remove the "Guest" account.
//              pdwReturnEntryCount     =   Returned number of entries. This
//                                          may be NULL.
//              pUserList               =   Buffer containing user data. This
//                                          may be NULL.
//
//  Returns:    LONG
//
//  Purpose:    Returns a filtered array of user entries from the given
//              server SAM. Filtering is performed here so that a common
//              algorithm can be applied to the list of users such that the
//              logon UI host can display the correct user information and
//              msgina can return the same number of users on the system.
//
//  History:    1999-10-15  vtan        created
//              1999-10-30  vtan        uses CSpecialAccounts
//              1999-11-26  vtan        moved from logonocx
//  --------------------------------------------------------------------------

LONG    CUserList::Get (bool fRemoveGuest, DWORD *pdwReturnedEntryCount, GINA_USER_INFORMATION* *pReturnedUserList)

{
    LONG                    lError;
    DWORD                   dwPreferredSize, dwEntryCount, dwEntriesRead;
    GINA_USER_INFORMATION   *pUserList;
    NET_DISPLAY_USER        *pNDU;
    CSpecialAccounts        SpecialAccounts;

    pUserList = NULL;
    dwEntryCount = 0;

    //  Determine the well known account names.

    DetermineWellKnownAccountNames();

    //  Allow a buffer for 100 users including their name, comments and full name.
    //  This should be sufficient for home consumers. If the need to extend this
    //  arises make this dynamic!

    dwPreferredSize = (sizeof(NET_DISPLAY_USER) + (3 * UNLEN) * s_iMaximumUserCount);
    pNDU = NULL;
    lError = NetQueryDisplayInformation(NULL,                  // NULL means LocalMachine
                                        1,                     // query User information
                                        0,                     // starting with the first user
                                        s_iMaximumUserCount,   // return a max of 100 users
                                        dwPreferredSize,       // preferred buffer size
                                        &dwEntriesRead,
                                        reinterpret_cast<void**>(&pNDU));
    if ((ERROR_SUCCESS == lError) || (ERROR_MORE_DATA == lError))
    {
        bool                    fHasCreatedAccount, fFound;
        DWORD                   dwUsernameSize;
        int                     iIndex, iAdministratorIndex;
        WCHAR                   wszUsername[UNLEN + sizeof('\0')];

        //  Get the current user name.

        dwUsernameSize = ARRAYSIZE(wszUsername);
        if (GetUserNameW(wszUsername, &dwUsernameSize) == FALSE)
        {
            wszUsername[0] = L'\0';
        }
        fHasCreatedAccount = false;
        iAdministratorIndex = -1;
        for (iIndex = static_cast<int>(dwEntriesRead - 1); iIndex >= 0; --iIndex)
        {
            PSID    pSID;

            pSID = ConvertNameToSID(pNDU[iIndex].usri1_name);
            if (pSID != NULL)
            {

                //  Never filter the current user.

                if (lstrcmpiW(pNDU[iIndex].usri1_name, wszUsername) == 0)
                {

                    //  If this is executed in the current user context and
                    //  that user isn't "Administrator", but is a member of
                    //  the local administrators group, then a user created
                    //  administrator account exists even though it isn't
                    //  filtered. The "Administrator" account can be removed.

                    if ((EqualSid(pSID, s_SIDAdministrator) == FALSE) &&
                        IsUserMemberOfLocalAdministrators(pNDU[iIndex].usri1_name))
                    {
                        fHasCreatedAccount = true;
                        if (iAdministratorIndex >= 0)
                        {
                            DeleteEnumerateUsers(pNDU, dwEntriesRead, iAdministratorIndex);
                            iAdministratorIndex = -1;
                        }
                    }
                }
                else
                {

                    //  If the account is
                    //      1) disabled
                    //      2) locked out
                    //      3) a special account (see CSpecialAccounts)
                    //      4) "Guest" and fRemoveGuest is true 
                    //      5) "Administrator" and has created another account
                    //          and does not always include "Administrator" and
                    //          "Administrator is not logged on
                    //  Then filter the account out.

                    if (((pNDU[iIndex].usri1_flags & UF_ACCOUNTDISABLE) != 0) ||
                        ((pNDU[iIndex].usri1_flags & UF_LOCKOUT) != 0) ||
                        SpecialAccounts.AlwaysExclude(pNDU[iIndex].usri1_name) ||
                        (fRemoveGuest && (EqualSid(pSID, s_SIDGuest) != FALSE)) ||
                        ((EqualSid(pSID, s_SIDAdministrator) != FALSE) &&
                         fHasCreatedAccount &&
                         !SpecialAccounts.AlwaysInclude(pNDU[iIndex].usri1_name) &&
                         !IsUserLoggedOn(pNDU[iIndex].usri1_name, NULL)))
                    {
                        DeleteEnumerateUsers(pNDU, dwEntriesRead, iIndex);

                        //  Account for indices being changed.
                        //  If this index wasn't set previously it just goes more negative.
                        //  If it was set we know it can never be below zero.

                        --iAdministratorIndex;
                    }

                    //  If the account should always be included then do it.

                    //  Guest is not a user created account so fHasCreatedAccount
                    //  must not be set if this account is seen.

                    else if (!SpecialAccounts.AlwaysInclude(pNDU[iIndex].usri1_name))
                    {

                        //  If safe mode then filter accounts that are not members of the
                        //  local administrators group.

                        if (CSystemSettings::IsSafeMode())
                        {
                            if (!IsUserMemberOfLocalAdministrators(pNDU[iIndex].usri1_name))
                            {
                                DeleteEnumerateUsers(pNDU, dwEntriesRead, iIndex);
                                --iAdministratorIndex;
                            }
                        }
                        else if (EqualSid(pSID, s_SIDAdministrator) != FALSE)
                        {
                            if (!IsUserLoggedOn(pNDU[iIndex].usri1_name, NULL))
                            {

                                //  Otherwise if the account name is "Administrator" and another
                                //  account has been created then this account needs to be removed
                                //  from the list. If another account has not been seen then
                                //  remember this index so that if another account is seen this
                                //  account can be removed.

                                if (fHasCreatedAccount)
                                {
                                    DeleteEnumerateUsers(pNDU, dwEntriesRead, iIndex);
                                    --iAdministratorIndex;
                                }
                                else
                                {
                                    iAdministratorIndex = iIndex;
                                }
                            }
                        }
                        else if (EqualSid(pSID, s_SIDGuest) == FALSE)
                        {

                            //  If the account name is NOT "Administrator" then check the
                            //  account group membership. If the account is a member of the
                            //  local administrators group then the "Administrator" account
                            //  can be removed.

                            if (IsUserMemberOfLocalAdministrators(pNDU[iIndex].usri1_name))
                            {
                                fHasCreatedAccount = true;
                                if (iAdministratorIndex >= 0)
                                {
                                    DeleteEnumerateUsers(pNDU, dwEntriesRead, iAdministratorIndex);
                                    iAdministratorIndex = -1;
                                }
                            }
                            if (!IsUserMemberOfLocalKnownGroup(pNDU[iIndex].usri1_name))
                            {
                                DeleteEnumerateUsers(pNDU, dwEntriesRead, iIndex);
                                --iAdministratorIndex;
                            }
                        }
                    }
                }
                (HLOCAL)LocalFree(pSID);
            }
        }

        if (!ParseDisplayInformation(pNDU, dwEntriesRead, pUserList, dwEntryCount))
        {
            lError = ERROR_OUTOFMEMORY;
            pUserList = NULL;
            dwEntryCount = 0;
        }
        (NET_API_STATUS)NetApiBufferFree(pNDU);

        if (ERROR_SUCCESS == lError)
        {

            //  Sort the user list. Typically this has come back alphabetized by the
            //  SAM. However, the SAM sorts by logon name and not by display name.
            //  This needs to be sorted by display name. 

            Sort(pUserList, dwEntryCount);

            //  The guest account should be put at the end of this list. This
            //  is a simple case of find the guest account (by localized name) and
            //  sliding all the entries down and inserting the guest at the end.

            for (fFound = false, iIndex = 0; !fFound && (iIndex < static_cast<int>(dwEntryCount)); ++iIndex)
            {
                PSID    pSID;

                pSID = ConvertNameToSID(pUserList[iIndex].pszName);
                if (pSID != NULL)
                {
                    fFound = (EqualSid(pSID, s_SIDGuest) != FALSE);
                    if (fFound)
                    {
                        GINA_USER_INFORMATION   gui;

                        MoveMemory(&gui, &pUserList[iIndex], sizeof(gui));
                        MoveMemory(&pUserList[iIndex], &pUserList[iIndex + 1], (dwEntryCount - iIndex - 1) * sizeof(pUserList[0]));
                        MoveMemory(&pUserList[dwEntryCount - 1], &gui, sizeof(gui));
                    }
                    (HLOCAL)LocalFree(pSID);
                }
            }
        }
    }
    if (pReturnedUserList != NULL)
    {
        *pReturnedUserList = pUserList;
    }
    else
    {
        ReleaseMemory(pUserList);
    }
    if (pdwReturnedEntryCount != NULL)
    {
        *pdwReturnedEntryCount = dwEntryCount;
    }
    return(lError);
}

//  --------------------------------------------------------------------------
//  CLogonDialog::IsUserLoggedOn
//
//  Arguments:  pszUsername     =   User name.
//              pszDomain       =   User domain.
//
//  Returns:    bool
//
//  Purpose:    Use WindowStation APIs in terminal services to determine if
//              a given user is logged onto this machine. It will not query
//              remote terminal servers.
//
//              Windowstations must be in the active or disconnected state.
//
//  History:    2000-02-28  vtan        created
//              2000-05-30  vtan        moved from CWLogonDialog.cpp
//  --------------------------------------------------------------------------

bool    CUserList::IsUserLoggedOn (const WCHAR *pszUsername, const WCHAR *pszDomain)

{
    bool    fResult;
    WCHAR   szDomain[DNLEN + sizeof('\0')];

    fResult = false;

    //  If no domain is supplied then use the computer's name.

    if ((pszDomain == NULL) || (pszDomain[0] == L'\0'))
    {
        DWORD   dwDomainSize;

        dwDomainSize = ARRAYSIZE(szDomain);
        if (GetComputerNameW(szDomain, &dwDomainSize) != FALSE)
        {
            pszDomain = szDomain;
        }
    }

    //  If no domain is supplied and the computer's name cannot be determined
    //  then this API fails. A user name must also be supplied.

    if ((pszUsername != NULL) && (pszDomain != NULL))
    {
        HANDLE      hServer;
        PLOGONID    pLogonID, pLogonIDs;
        ULONG       ul, ulEntries;

        //  Open a connection to terminal services and get the number of sessions.

        hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
        if (hServer != NULL)
        {
            if (WinStationEnumerate(hServer, &pLogonIDs, &ulEntries) != FALSE)
            {

                //  Iterate the sessions looking for active and disconnected sessions only.
                //  Then match the user name and domain (case INsensitive) for a result.

                for (ul = 0, pLogonID = pLogonIDs; !fResult && (ul < ulEntries); ++ul, ++pLogonID)
                {
                    if ((pLogonID->State == State_Active) || (pLogonID->State == State_Disconnected))
                    {
                        ULONG                   ulReturnLength;
                        WINSTATIONINFORMATIONW  winStationInformation;

                        if (WinStationQueryInformationW(hServer,
                                                        pLogonID->LogonId,
                                                        WinStationInformation,
                                                        &winStationInformation,
                                                        sizeof(winStationInformation),
                                                        &ulReturnLength) != FALSE)
                        {
                            fResult = ((lstrcmpiW(pszUsername, winStationInformation.UserName) == 0) &&
                                       (lstrcmpiW(pszDomain, winStationInformation.Domain) == 0));
                        }
                    }
                }

                //  Free any resources used.

                (BOOLEAN)WinStationFreeMemory(pLogonIDs);
            }
            (BOOLEAN)WinStationCloseServer(hServer);
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CUserList::IsInteractiveLogonAllowed
//
//  Arguments:  pszUsername     =   User name.
//
//  Returns:    int
//
//  Purpose:    Determines whether the SeDenyInteractiveLogonRight is
//              assigned into the given user. Returns -1 if the state cannot
//              be determined due to some error. Otherwise returns 0 if the
//              the right is assigned and != 0 && != -1 if not.
//
//              One final check is made on personal for a user name that
//              matches DOMAIN_USER_RID_ADMIN. 
//
//  History:    2000-08-15  vtan        created
//  --------------------------------------------------------------------------

int     CUserList::IsInteractiveLogonAllowed (const WCHAR *pszUsername)

{
    int                 iResult;
    LSA_HANDLE          hLSA;
    UNICODE_STRING      strDenyInteractiveLogonRight;
    OBJECT_ATTRIBUTES   objectAttributes;

    iResult = -1;
    RtlInitUnicodeString(&strDenyInteractiveLogonRight, SE_DENY_INTERACTIVE_LOGON_NAME);
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    if (NT_SUCCESS(LsaOpenPolicy(NULL,
                                 &objectAttributes,
                                 POLICY_LOOKUP_NAMES,
                                 &hLSA)))
    {
        SID_NAME_USE    eUse;
        DWORD           dwSIDSize, dwReferencedDomainSize;
        PSID            pSID;
        WCHAR           szReferencedDomain[CNLEN + sizeof('\0')];

        dwSIDSize = 0;
        dwReferencedDomainSize = ARRAYSIZE(szReferencedDomain);
        (BOOL)LookupAccountNameW(NULL,
                                 pszUsername,
                                 NULL,
                                 &dwSIDSize,
                                 szReferencedDomain,
                                 &dwReferencedDomainSize,
                                 &eUse);
        pSID = static_cast<PSID>(LocalAlloc(LMEM_FIXED, dwSIDSize));
        if (pSID != NULL)
        {
            if (LookupAccountNameW(NULL,
                                   pszUsername,
                                   pSID,
                                   &dwSIDSize,
                                   szReferencedDomain,
                                   &dwReferencedDomainSize,
                                   &eUse) != FALSE)
            {
                NTSTATUS                status;
                ULONG                   ulIndex, ulCountOfRights;
                PLSA_UNICODE_STRING     pUserRights;

                status = LsaEnumerateAccountRights(hLSA,
                                                   pSID,
                                                   &pUserRights,
                                                   &ulCountOfRights);
                if (NT_SUCCESS(status))
                {
                    bool    fFound;

                    for (fFound = false, ulIndex = 0; !fFound && (ulIndex < ulCountOfRights); ++ulIndex)
                    {
                        fFound = (RtlEqualUnicodeString(&strDenyInteractiveLogonRight, pUserRights + ulIndex, TRUE) != FALSE);
                    }
                    iResult = fFound ? 0 : 1;
                    TSTATUS(LsaFreeMemory(pUserRights));
                }
                else if (STATUS_OBJECT_NAME_NOT_FOUND == status)
                {
                    iResult = 1;
                }
            }
            (HLOCAL)LocalFree(pSID);
        }
        TSTATUS(LsaClose(hLSA));
    }
    if (IsOS(OS_PERSONAL) && !CSystemSettings::IsSafeMode())
    {
        PSID    pSID;

        pSID = ConvertNameToSID(pszUsername);
        if (pSID != NULL)
        {
            if (EqualSid(pSID, s_SIDAdministrator) != FALSE)
            {
                iResult = 0;
            }
            (HLOCAL)LocalFree(pSID);
        }
    }
    return(iResult);
}

PSID    CUserList::ConvertNameToSID (const WCHAR *pszUsername)

{
    PSID            pSID;
    DWORD           dwSIDSize, dwDomainSize;
    SID_NAME_USE    eUse;

    pSID = NULL;
    dwSIDSize = dwDomainSize = 0;
    (BOOL)LookupAccountNameW(NULL,
                             pszUsername,
                             NULL,
                             &dwSIDSize,
                             NULL,
                             &dwDomainSize,
                             NULL);
    if ((dwSIDSize != 0) && (dwDomainSize != 0))
    {
        WCHAR   *pszDomain;

        pszDomain = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwDomainSize * sizeof(WCHAR)));
        if (pszDomain != NULL)
        {
            pSID = static_cast<PSID>(LocalAlloc(LMEM_FIXED, dwSIDSize));
            if (pSID != NULL)
            {
                if (LookupAccountName(NULL,
                                      pszUsername,
                                      pSID,
                                      &dwSIDSize,
                                      pszDomain,
                                      &dwDomainSize,
                                      &eUse) == FALSE)
                {
                    (HLOCAL)LocalFree(pSID);
                    pSID = NULL;
                }
            }
            (HLOCAL)LocalFree(pszDomain);
        }
    }
    return(pSID);
}

//  --------------------------------------------------------------------------
//  CUserList::IsUserMemberOfLocalAdministrators
//
//  Arguments:  pszName     =   User name to test.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given user is a member of the local
//              Administrators group.
//
//  History:    2000-03-28  vtan        created
//  --------------------------------------------------------------------------

bool    CUserList::IsUserMemberOfLocalAdministrators (const WCHAR *pszName)

{
    bool                        fIsAnAdministrator;
    DWORD                       dwGroupEntriesRead, dwGroupTotalEntries;
    LOCALGROUP_USERS_INFO_0     *pLocalGroupUsersInfo;

    fIsAnAdministrator = false;
    pLocalGroupUsersInfo = NULL;
    if (NetUserGetLocalGroups(NULL,
                              pszName,
                              0,
                              LG_INCLUDE_INDIRECT,
                              (LPBYTE*)&pLocalGroupUsersInfo,
                              MAX_PREFERRED_LENGTH,
                              &dwGroupEntriesRead,
                              &dwGroupTotalEntries) == NERR_Success)
    {
        int                         iIndexGroup;
        LOCALGROUP_USERS_INFO_0     *pLGUI;

        for (iIndexGroup = 0, pLGUI = pLocalGroupUsersInfo; !fIsAnAdministrator && (iIndexGroup < static_cast<int>(dwGroupEntriesRead)); ++iIndexGroup, ++pLGUI)
        {
            fIsAnAdministrator = (lstrcmpiW(pLGUI->lgrui0_name, s_szAdministratorsGroupName) == 0);
        }
    }
    else
    {
        fIsAnAdministrator = true;
    }
    if (pLocalGroupUsersInfo != NULL)
    {
        TW32(NetApiBufferFree(pLocalGroupUsersInfo));
    }
    return(fIsAnAdministrator);
}

//  --------------------------------------------------------------------------
//  CUserList::IsUserMemberOfLocalKnownGroup
//
//  Arguments:  pszName     =   User name to test.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given user is a member of a local known
//              group. Membership of a known group returns true. Membership
//              of only groups that are not known returns false.
//
//  History:    2000-06-29  vtan        created
//  --------------------------------------------------------------------------

bool    CUserList::IsUserMemberOfLocalKnownGroup (const WCHAR *pszName)

{
    bool                        fIsMember;
    DWORD                       dwGroupEntriesRead, dwGroupTotalEntries;
    LOCALGROUP_USERS_INFO_0     *pLocalGroupUsersInfo;

    fIsMember = true;
    pLocalGroupUsersInfo = NULL;
    if (NetUserGetLocalGroups(NULL,
                              pszName,
                              0,
                              LG_INCLUDE_INDIRECT,
                              (LPBYTE*)&pLocalGroupUsersInfo,
                              MAX_PREFERRED_LENGTH,
                              &dwGroupEntriesRead,
                              &dwGroupTotalEntries) == NERR_Success)
    {
        int                         iIndexGroup;
        LOCALGROUP_USERS_INFO_0     *pLGUI;

        //  Assume the worst. As soon as a known group is found this will terminate the loop.

        fIsMember = false;
        for (iIndexGroup = 0, pLGUI = pLocalGroupUsersInfo; !fIsMember && (iIndexGroup < static_cast<int>(dwGroupEntriesRead)); ++iIndexGroup, ++pLGUI)
        {
            fIsMember = ((lstrcmpiW(pLGUI->lgrui0_name, s_szAdministratorsGroupName) == 0) ||
                         (lstrcmpiW(pLGUI->lgrui0_name, s_szPowerUsersGroupName) == 0) ||
                         (lstrcmpiW(pLGUI->lgrui0_name, s_szUsersGroupName) == 0) ||
                         (lstrcmpiW(pLGUI->lgrui0_name, s_szGuestsGroupName) == 0));
        }
    }
    if (pLocalGroupUsersInfo != NULL)
    {
        TW32(NetApiBufferFree(pLocalGroupUsersInfo));
    }
    return(fIsMember);
}

//  --------------------------------------------------------------------------
//  CUserList::DeleteEnumerateUsers
//
//  Arguments:  pNDU            =   NET_DISPLAY_USER array to delete from.
//              dwEntriesRead   =   Number of entries in the array.
//              iIndex          =   Index to delete.
//
//  Returns:    <none>
//
//  Purpose:    Deletes the given array index contents from the array by
//              sliding down the elements and zeroing the last entry.
//
//  History:    1999-10-16  vtan        created
//              1999-11-26  vtan        moved from logonocx
//  --------------------------------------------------------------------------

void    CUserList::DeleteEnumerateUsers (NET_DISPLAY_USER *pNDU, DWORD& dwEntriesRead, int iIndex)

{
    int     iIndiciesToMove;

    iIndiciesToMove = static_cast<int>(dwEntriesRead - 1) - iIndex;
    if (iIndiciesToMove != 0)
    {
        MoveMemory(&pNDU[iIndex], &pNDU[iIndex + 1], iIndiciesToMove * sizeof(*pNDU));
    }
    ZeroMemory(&pNDU[--dwEntriesRead], sizeof(*pNDU));
}

//  --------------------------------------------------------------------------
//  CUserList::DetermineWellKnownAccountNames
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Determines the string for the local Administrator and Guest
//              accounts by getting the user list from the local SAM and
//              looking up the SID corresponding with the iterated user names
//              and checking the SID for the RID that is desired.
//
//              The main loop structure mimics the filter function.
//
//  History:    2000-02-15  vtan        created
//  --------------------------------------------------------------------------

void    CUserList::DetermineWellKnownAccountNames (void)

{
    static  bool        s_fCachedWellKnownAccountNames  =   false;

    //  If the well known account names haven't been determined yet
    //  then do this. But only do this once.

    if (!s_fCachedWellKnownAccountNames)
    {
        USER_MODALS_INFO_2  *pUMI;
        PSID                pSID;
        DWORD               dwNameSize, dwDomainSize;
        SID_NAME_USE        eUse;
        WCHAR               szDomain[DNLEN + sizeof('\0')];

        //  Build the SID for the built-in local administrator
        //  and built-in local guest accounts.

        if (NetUserModalsGet(NULL, 2, (LPBYTE*)&pUMI) == NERR_Success)
        {
            unsigned char   ucSubAuthorityCount;

            ucSubAuthorityCount = *GetSidSubAuthorityCount(pUMI->usrmod2_domain_id);
            if (GetSidLengthRequired(ucSubAuthorityCount + 1) <= sizeof(s_SIDAdministrator))
            {
                if (CopySid(GetSidLengthRequired(ucSubAuthorityCount + 1), s_SIDAdministrator, pUMI->usrmod2_domain_id) != FALSE)
                {
                    *GetSidSubAuthority(s_SIDAdministrator, ucSubAuthorityCount) = DOMAIN_USER_RID_ADMIN;
                    *GetSidSubAuthorityCount(s_SIDAdministrator) = ucSubAuthorityCount + 1;
                }
            }
            else
            {
                ZeroMemory(s_SIDAdministrator, sizeof(s_SIDAdministrator));
            }
            if (GetSidLengthRequired(ucSubAuthorityCount + 1) <= sizeof(s_SIDGuest))
            {
                if (CopySid(GetSidLengthRequired(ucSubAuthorityCount + 1), s_SIDGuest, pUMI->usrmod2_domain_id) != FALSE)
                {
                    *GetSidSubAuthority(s_SIDGuest, ucSubAuthorityCount) = DOMAIN_USER_RID_GUEST;
                    *GetSidSubAuthorityCount(s_SIDGuest) = ucSubAuthorityCount + 1;
                }
            }
            else
            {
                ZeroMemory(s_SIDAdministrator, sizeof(s_SIDAdministrator));
            }
            (NET_API_STATUS)NetApiBufferFree(pUMI);
        }

        //  Now determine the local administrators group name.

        static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

        if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                                   2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_ADMINS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &pSID)))
        {

            dwNameSize = ARRAYSIZE(s_szAdministratorsGroupName);
            dwDomainSize = ARRAYSIZE(szDomain);
            TBOOL(LookupAccountSidW(NULL,
                                    pSID,
                                    s_szAdministratorsGroupName,
                                    &dwNameSize,
                                    szDomain,
                                    &dwDomainSize,
                                    &eUse));
            (void*)RtlFreeSid(pSID);
        }

        //  Power Users

        if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                                   2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_POWER_USERS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &pSID)))
        {
            dwNameSize = ARRAYSIZE(s_szPowerUsersGroupName);
            dwDomainSize = ARRAYSIZE(szDomain);
            (BOOL)LookupAccountSidW(NULL,
                                    pSID,
                                    s_szPowerUsersGroupName,
                                    &dwNameSize,
                                    szDomain,
                                    &dwDomainSize,
                                    &eUse);
            (void*)RtlFreeSid(pSID);
        }

        //  Users

        if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                                   2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_USERS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &pSID)))
        {
            dwNameSize = ARRAYSIZE(s_szUsersGroupName);
            dwDomainSize = ARRAYSIZE(szDomain);
            TBOOL(LookupAccountSidW(NULL,
                                    pSID,
                                    s_szUsersGroupName,
                                    &dwNameSize,
                                    szDomain,
                                    &dwDomainSize,
                                    &eUse));
            (void*)RtlFreeSid(pSID);
        }

        //  Guests

        if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                                   2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_GUESTS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &pSID)))
        {
            dwNameSize = ARRAYSIZE(s_szGuestsGroupName);
            dwDomainSize = ARRAYSIZE(szDomain);
            TBOOL(LookupAccountSidW(NULL,
                                    pSID,
                                    s_szGuestsGroupName,
                                    &dwNameSize,
                                    szDomain,
                                    &dwDomainSize,
                                    &eUse));
            (void*)RtlFreeSid(pSID);
        }

        //  Don't do this again.

        s_fCachedWellKnownAccountNames = true;
    }
}

//  --------------------------------------------------------------------------
//  CUserList::ParseDisplayInformation
//
//  Arguments:  pNDU            =   NET_DISPLAY_USER list to parse.
//              dwEntriesRead   =   Number of entries in NDU list.
//              pUserList       =   GINA_USER_INFORMATION pointer returned.
//              dwEntryCount    =   Number of entries in GUI list.
//
//  Returns:    bool
//
//  Purpose:    Converts NET_DISPLAY_USER array to GINA_USER_INFORMATION
//              array so that information can be added or removed as desired
//              from the final information returned to the caller.
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CUserList::ParseDisplayInformation (NET_DISPLAY_USER *pNDU, DWORD dwEntriesRead, GINA_USER_INFORMATION*& pUserList, DWORD& dwEntryCount)

{
    bool            fResult;
    DWORD           dwBufferSize, dwComputerNameSize;
    int             iIndex;
    unsigned char   *pBuffer;
    WCHAR           *pWC;
    WCHAR           szComputerName[CNLEN + sizeof('\0')];

    //  Get the local computer name. This is the local domain.

    dwComputerNameSize = ARRAYSIZE(szComputerName);
    if (GetComputerNameW(szComputerName, &dwComputerNameSize) == FALSE)
    {
        szComputerName[0] = L'\0';
    }

    //  Calculate the total size of the buffer required based on the number of
    //  entries and the size of a struct and the length of the strings required.

    //  Append any additions to the below this loop.

    dwBufferSize = 0;
    for (iIndex = static_cast<int>(dwEntriesRead - 1); iIndex >= 0; --iIndex)
    {
        dwBufferSize += sizeof(GINA_USER_INFORMATION);
        dwBufferSize += (lstrlenW(pNDU[iIndex].usri1_name) + sizeof('\0')) * sizeof(WCHAR);
        dwBufferSize += (lstrlenW(szComputerName) + sizeof('\0')) * sizeof(WCHAR);
        dwBufferSize += (lstrlenW(pNDU[iIndex].usri1_full_name) + sizeof('\0')) * sizeof(WCHAR);
    }

    //  Allocate the buffer. Start allocating structs from the start of the
    //  buffer and allocate strings from the end of the buffer. Uses pUserList
    //  to allocate structs and pWC to allocate strings.

    pBuffer = static_cast<unsigned char*>(LocalAlloc(LMEM_FIXED, dwBufferSize));
    pUserList = reinterpret_cast<GINA_USER_INFORMATION*>(pBuffer);
    pWC = reinterpret_cast<WCHAR*>(pBuffer + dwBufferSize);
    if (pBuffer != NULL)
    {
        int     iStringCount;

        //  Walk thru the NET_DISPLAY_USER array and convert/copy the
        //  struct and strings to GINA_USER_INFORMATION and allocate the
        //  space from the buffer we just allocated.

        for (iIndex = 0; iIndex < static_cast<int>(dwEntriesRead); ++iIndex)
        {
            iStringCount = lstrlenW(pNDU[iIndex].usri1_name) + sizeof('\0');
            pWC -= iStringCount;
            CopyMemory(pWC, pNDU[iIndex].usri1_name, iStringCount * sizeof(WCHAR));
            pUserList[iIndex].pszName = pWC;

            iStringCount = lstrlenW(szComputerName) + sizeof('\0');
            pWC -= iStringCount;
            CopyMemory(pWC, szComputerName, iStringCount * sizeof(WCHAR));
            pUserList[iIndex].pszDomain = pWC;

            iStringCount = lstrlenW(pNDU[iIndex].usri1_full_name) + sizeof('\0');
            pWC -= iStringCount;
            CopyMemory(pWC, pNDU[iIndex].usri1_full_name, iStringCount * sizeof(WCHAR));
            pUserList[iIndex].pszFullName = pWC;

            pUserList[iIndex].dwFlags = pNDU[iIndex].usri1_flags;
        }

        //  Return the count of entries.

        dwEntryCount = dwEntriesRead;

        //  And a success.

        fResult = true;
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CUserList::Sort
//
//  Arguments:  pNDU            =   GINA_USER_INFORMATION list to sort.
//              dwEntriesRead   =   Number of entries in the list.
//
//  Returns:    <none>
//
//  Purpose:    Sorts the GINA_USER_INFORMATION array by display name NOT
//              logon name as the SAM returns the data. This is a lame n^2
//              algorithm that won't scale well but it's for a very limited
//              usage scenario. If need be this will be revised.
//
//  History:    2000-06-08  vtan        created
//              2000-06-26  vtan        converted to GINA_USER_INFORMATION
//  --------------------------------------------------------------------------

void    CUserList::Sort (GINA_USER_INFORMATION *pUserList, DWORD dwEntryCount)

{
    GINA_USER_INFORMATION   *pSortedList;

    pSortedList = static_cast<GINA_USER_INFORMATION*>(LocalAlloc(LMEM_FIXED, dwEntryCount * sizeof(GINA_USER_INFORMATION)));
    if (pSortedList != NULL)
    {
        int     iOuter;

        for (iOuter = 0; iOuter < static_cast<int>(dwEntryCount); ++iOuter)
        {
            int             iInner, iItem;
            const WCHAR     *pszItem;

            for (iItem = -1, pszItem = NULL, iInner = 0; iInner < static_cast<int>(dwEntryCount); ++iInner)
            {
                const WCHAR     *psz;

                psz = pUserList[iInner].pszFullName;
                if ((psz == NULL) || (psz[0] == L'\0'))
                {
                    psz = pUserList[iInner].pszName;
                }
                if (psz != NULL)
                {
                    if ((iItem == -1) || (lstrcmpiW(pszItem, psz) > 0))
                    {
                        iItem = iInner;
                        pszItem = psz;
                    }
                }
            }
            pSortedList[iOuter] = pUserList[iItem];
            pUserList[iItem].pszFullName = pUserList[iItem].pszName = NULL;
        }
        CopyMemory(pUserList, pSortedList, dwEntryCount * sizeof(GINA_USER_INFORMATION));
        ReleaseMemory(pSortedList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\userlist.h ===
//  --------------------------------------------------------------------------
//  Module Name: UserList.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the user list filtering algorithm shared by winlogon
//  calling into msgina and shgina (the logonocx) calling into msgina.
//
//  History:    1999-10-30  vtan        created
//              1999-11-26  vtan        moved from logonocx
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-05-30  vtan        moved IsUserLoggedOn to this file
//  --------------------------------------------------------------------------

#ifndef     _UserList_
#define     _UserList_

#include "GinaIPC.h"

//  --------------------------------------------------------------------------
//  CUserList
//
//  Purpose:    A class that knows how to filter the user list from the net
//              APIs using a common algorithm. This allows a focal point for
//              the filter where a change here can affect all components.
//
//  History:    1999-11-26  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CUserList
{
    public:
        static  LONG            Get (bool fRemoveGuest, DWORD *pdwReturnedEntryCount, GINA_USER_INFORMATION* *pReturnedUserList);

        static  bool            IsUserLoggedOn (const WCHAR *pszUsername, const WCHAR *pszDomain);
        static  int             IsInteractiveLogonAllowed (const WCHAR *pszUserame);
    private:
        static  PSID            ConvertNameToSID (const WCHAR *pszUsername);
        static  bool            IsUserMemberOfLocalAdministrators (const WCHAR *pszName);
        static  bool            IsUserMemberOfLocalKnownGroup (const WCHAR *pszName);
        static  void            DeleteEnumerateUsers (NET_DISPLAY_USER *pNDU, DWORD& dwEntriesRead, int iIndex);
        static  void            DetermineWellKnownAccountNames (void);
        static  bool            ParseDisplayInformation (NET_DISPLAY_USER *pNDU, DWORD dwEntriesRead, GINA_USER_INFORMATION*& pUserList, DWORD& dwEntryCount);
        static  void            Sort (GINA_USER_INFORMATION *pUserList, DWORD dwEntryCount);

        static  unsigned char   s_SIDAdministrator[];
        static  unsigned char   s_SIDGuest[];
        static  WCHAR           s_szAdministratorsGroupName[];
        static  WCHAR           s_szPowerUsersGroupName[];
        static  WCHAR           s_szUsersGroupName[];
        static  WCHAR           s_szGuestsGroupName[];

        static  const int   s_iMaximumUserCount     =   100;
};

#endif  /*  _UserList_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\uihost.h ===
//  --------------------------------------------------------------------------
//  Module Name: UIHost.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle the UI host for the logon process. This handles the IPC
//  as well as the creation and monitoring of process death. The process is
//  a restricted SYSTEM context process.
//
//  History:    1999-09-14  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _UIHost_
#define     _UIHost_

#include "DynamicArray.h"
#include "ExternalProcess.h"

//  --------------------------------------------------------------------------
//  CUIHost
//
//  Purpose:    This class handles the starting and monitoring the termination
//              of the UI host process. It actually can implement the host in
//              whatever way it chooses.
//
//  History:    1999-09-14  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CUIHost : public CExternalProcess
{
    private:
                                    CUIHost (void);
                                    CUIHost (const CUIHost& copyObject);
                const CUIHost&      operator = (const CUIHost& assignObject);
    public:
                                    CUIHost (const TCHAR *pszCommandLine);
                                    ~CUIHost (void);

                bool                WaitRequired (void)         const;

                NTSTATUS            GetData (const void *pUIHostProcessAddress, void *pLogonProcessAddress, int iDataSize)  const;
                NTSTATUS            PutData (void *pUIHostProcessAddress, const void *pLogonProcessAddress, int iDataSize)  const;

                NTSTATUS            Show (void);
                NTSTATUS            Hide (void);
                bool                IsHidden (void)     const;

                void*               GetDataAddress (void)       const;
                NTSTATUS            PutData (const void *pvData, DWORD dwDataSize);
                NTSTATUS            PutString (const WCHAR *pszString);
    protected:
        virtual void                NotifyNoProcess (void);
    private:
                void                ExpandCommandLine (const TCHAR *pszCommandLine);

        static  BOOL    CALLBACK    EnumWindowsProc (HWND hwnd, LPARAM lParam);
    private:
                CDynamicArray       _hwndArray;
                void                *_pBufferAddress;
};

#endif  /*  _UIHost_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\uihost.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: UIHost.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle the UI host for the logon process. This handles the IPC
//  as well as the creation and monitoring of process death. The process is
//  a restricted SYSTEM context process.
//
//  History:    1999-09-14  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "UIHost.h"

#include "RegistryResources.h"
#include "StatusCode.h"
#include "SystemSettings.h"

//  --------------------------------------------------------------------------
//  CUIHost::CUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CUIHost. Determine UI host process. If none
//              exists then indicate it.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

CUIHost::CUIHost (const TCHAR *pszCommandLine) :
    CExternalProcess(),
    _hwndArray(sizeof(HWND)),
    _pBufferAddress(NULL)

{
    ExpandCommandLine(pszCommandLine);
    AdjustForDebugging();
}

//  --------------------------------------------------------------------------
//  CUIHost::~CUIHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CUIHost.
//
//  History:    1999-09-14  vtan        created
//  --------------------------------------------------------------------------

CUIHost::~CUIHost (void)

{
    if (_pBufferAddress != NULL)
    {
        (BOOL)VirtualFreeEx(_hProcess, _pBufferAddress, 0, MEM_DECOMMIT);
        _pBufferAddress = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CUIHost::WaitRequired
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether a wait is required for the UI host. This is
//              important when communication with the UI host is required or
//              if the UI host is being debugged.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

bool    CUIHost::WaitRequired (void)         const

{

#ifdef      DBG

    return(IsBeingDebugged());

#else   /*  DBG     */

    return(false);

#endif  /*  DBG     */

}

//  --------------------------------------------------------------------------
//  CUIHost::GetData
//
//  Arguments:  pUIHostProcessAddress   =   Address in the UI host.
//              pLogonProcessAddress    =   Address in the logon process.
//              iDataSize               =   Size of the data.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Extracts the data from the UI host. This could be another
//              process that we started or it could be in process if we
//              failed to start the UI host. This function deals with it
//              either way.
//
//  History:    1999-08-24  vtan        created
//              1999-09-14  vtan        factored
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::GetData (const void *pUIHostProcessAddress, void *pLogonProcessAddress, int iDataSize)  const

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_hProcess == NULL)
    {
        CopyMemory(pLogonProcessAddress, pUIHostProcessAddress, iDataSize);
    }
    else
    {
        if (ReadProcessMemory(_hProcess, pUIHostProcessAddress, pLogonProcessAddress, iDataSize, NULL) == FALSE)
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CUIHost::PutData
//
//  Arguments:  pUIHostProcessAddress   =   Address in the UI host.
//              pLogonProcessAddress    =   Address in the logon process.
//              iDataSize               =   Size of the data.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Puts data into the UI host. This could be another process that
//              we started or it could be in process if we failed to start the
//              UI host. This function deals with it either way.
//
//  History:    1999-08-24  vtan        created
//              1999-09-14  vtan        factored
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::PutData (void *pUIHostProcessAddress, const void *pLogonProcessAddress, int iDataSize)  const

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_hProcess == NULL)
    {
        CopyMemory(pUIHostProcessAddress, pLogonProcessAddress, iDataSize);
    }
    else
    {
        if (WriteProcessMemory(_hProcess, pUIHostProcessAddress, const_cast<void*>(pLogonProcessAddress), iDataSize, NULL) == FALSE)
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CUIHost::Show
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Iterate the top level windows on this desktop and for any that
//              correspond to the UI host - show them!
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::Show (void)

{
    int     i;

    i = _hwndArray.GetCount();
    if (i > 0)
    {
        for (--i; i >= 0; --i)
        {
            HWND    hwnd;

            if (NT_SUCCESS(_hwndArray.Get(&hwnd, i)) && (hwnd != NULL))
            {
                (BOOL)ShowWindow(hwnd, SW_SHOW);
            }
            TSTATUS(_hwndArray.Remove(i));
        }
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CUIHost::Hide
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Iterate the top level windows on this desktop and for any that
//              correspond to the UI host - hide them!
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::Hide (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_hwndArray.GetCount() == 0)
    {
        if (EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(this)) == FALSE)
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CUIHost::IsHidden
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the UI host is currently hidden or not.
//
//  History:    2000-07-05  vtan        created
//  --------------------------------------------------------------------------

bool    CUIHost::IsHidden (void)     const

{
    return(_hwndArray.GetCount() != 0);
}

//  --------------------------------------------------------------------------
//  CUIHost::GetDataAddress
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    Returns the address of the buffer valid in the UI host process
//              context.
//
//  History:    2000-05-05  vtan        created
//  --------------------------------------------------------------------------

void*   CUIHost::GetDataAddress (void)       const

{
    return(_pBufferAddress);
}

//  --------------------------------------------------------------------------
//  CUIHost::PutData
//
//  Arguments:  pvData      =   Pointer to data.
//              dwDataSize  =   Size of data (in bytes).
//
//  Returns:    NTSTATUS
//
//  Purpose:    Writes the data to the UI host process at an allocated
//              address. If the address has not been allocated then it's
//              allocated and cached. It's released when this object goes
//              out of scope.
//
//  History:    2000-05-05  vtan        created
//              2001-01-10  vtan        changed to generic data placement
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::PutData (const void *pvData, DWORD dwDataSize)

{
    NTSTATUS    status;

    if (_pBufferAddress == NULL)
    {
        _pBufferAddress = VirtualAllocEx(_hProcess,
                                         0,
                                         2048,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
    }
    if (_pBufferAddress != NULL)
    {
        ASSERTMSG(dwDataSize < 2048, "Impending kernel32!WriteProcessMemory failure in CUIHost::PutData");
        if (WriteProcessMemory(_hProcess,
                               _pBufferAddress,
                               const_cast<void*>(pvData),
                               dwDataSize,
                               NULL) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CUIHost::PutString
//
//  Arguments:  pszString   =   String to put into UI host process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Writes the string to the UI host process at an allocated
//              address. If the address has not been allocated then it's
//              allocated and cached. It's released when this object goes
//              out of scope.
//
//  History:    2000-05-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CUIHost::PutString (const WCHAR *pszString)

{
    ASSERTMSG(lstrlenW(pszString) < 256, "Too many characters in string passed to CUIHost::PutString");
    return(PutData(pszString, (lstrlenW(pszString) + sizeof('\0')) * sizeof(WCHAR)));
}

//  --------------------------------------------------------------------------
//  CUIHost::NotifyNoProcess
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Clears the string address associated with the process that
//              has now died.
//
//  History:    2001-01-09  vtan        created
//  --------------------------------------------------------------------------

void    CUIHost::NotifyNoProcess (void)

{
    _pBufferAddress = NULL;
}

//  --------------------------------------------------------------------------
//  CUIHost::ExpandCommandLine
//
//  Arguments:  pszCommandLine  =   Command line of UI host
//
//  Returns:    <none>
//
//  Purpose:    Find out which UI host we should use for the logon UI. This
//              is specified in registry at the moment but should be a less
//              accessible place to prevent tampering. An error is returned
//              if no host is specified.
//
//  History:    1999-08-24  vtan        created
//              1999-09-14  vtan        factored
//  --------------------------------------------------------------------------

void    CUIHost::ExpandCommandLine (const TCHAR *pszCommandLine)

{
    if (ExpandEnvironmentStrings(pszCommandLine, _szCommandLine, ARRAYSIZE(_szCommandLine)) == 0)
    {
        lstrcpy(_szCommandLine, pszCommandLine);
    }
}

//  --------------------------------------------------------------------------
//  CUIHost::EnumWindowsProc
//
//  Arguments:  hwnd    =   HWND from user32
//              lParam  =   this object.
//
//  Returns:    BOOL
//
//  Purpose:    Determines if the given HWND in the iteration belongs to the
//              UI host process.
//
//  History:    2000-03-08  vtan        created
//  --------------------------------------------------------------------------

BOOL    CALLBACK    CUIHost::EnumWindowsProc (HWND hwnd, LPARAM lParam)

{
    DWORD       dwThreadID, dwProcessID;
    CUIHost     *pUIHost;

    pUIHost = reinterpret_cast<CUIHost*>(lParam);
    dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
    if ((dwProcessID == pUIHost->_dwProcessID) && IsWindowVisible(hwnd))
    {
        (NTSTATUS)pUIHost->_hwndArray.Add(&hwnd);
        (BOOL)ShowWindow(hwnd, SW_HIDE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\usersettings.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: UserSettings.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle opening and reading/writing from the HKCU key in either
//  an impersonation context or not.
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "UserSettings.h"

#include <sddl.h>
#include "RegistryResources.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CUserSettings::CUserSettings
//
//  Arguments:  
//
//  Returns:    <none>
//
//  Purpose:    
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

CUserSettings::CUserSettings (void) :
    _hKeyCurrentUser(HKEY_CURRENT_USER)

{
    HANDLE  hToken;

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken) != FALSE)
    {
        PSID                pSID;
        CTokenInformation   tokenInformation(hToken);

        pSID = tokenInformation.GetUserSID();
        if (pSID != NULL)
        {
            LPTSTR  pszSIDString;

            if (ConvertSidToStringSid(pSID, &pszSIDString) != FALSE)
            {
                TW32(RegOpenKeyEx(HKEY_USERS,
                                  pszSIDString,
                                  0,
                                  KEY_READ,
                                  &_hKeyCurrentUser));
                ReleaseMemory(pszSIDString);
            }
        }
        TBOOL(CloseHandle(hToken));
    }
}

//  --------------------------------------------------------------------------
//  CUserSettings::~CUserSettings
//
//  Arguments:  
//
//  Returns:    <none>
//
//  Purpose:    
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

CUserSettings::~CUserSettings (void)

{
    if (HKEY_CURRENT_USER != _hKeyCurrentUser)
    {
        TW32(RegCloseKey(_hKeyCurrentUser));
        _hKeyCurrentUser = HKEY_CURRENT_USER;
    }
}

//  --------------------------------------------------------------------------
//  CUserSettings::IsRestrictedNoClose
//
//  Arguments:  
//
//  Returns:    bool
//
//  Purpose:    
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

bool    CUserSettings::IsRestrictedNoClose (void)

{
    bool        fIsRestrictedNoClose;
    CRegKey     regKey;

    fIsRestrictedNoClose = false;
    if (ERROR_SUCCESS == regKey.Open(_hKeyCurrentUser,
                                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                                     KEY_QUERY_VALUE))
    {
        DWORD   dwValue;

        if (ERROR_SUCCESS == regKey.GetDWORD(TEXT("NoClose"),
                                             dwValue))
        {
            fIsRestrictedNoClose = (dwValue != 0);
        }
    }
    return(fIsRestrictedNoClose);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\usersettings.h ===
//  --------------------------------------------------------------------------
//  Module Name: UserSettings.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle opening and reading/writing from the HKCU key in either
//  an impersonation context or not.
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _UserSettings_
#define     _UserSettings_

//  --------------------------------------------------------------------------
//  CUserSettings
//
//  Purpose:    This class deals with user settings typically found in HKCU
//
//  History:    2000-04-26  vtan        created
//  --------------------------------------------------------------------------

class   CUserSettings
{
    public:
        CUserSettings (void);
        ~CUserSettings (void);

        bool    IsRestrictedNoClose (void);
    private:
        HKEY    _hKeyCurrentUser;
};

#endif  /*  _UserSettings_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\waitinteractiveready.h ===
//  --------------------------------------------------------------------------
//  Module Name: WaitInteractiveReady.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Class to handle waiting on the shell signal the desktop switch.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _WaitInteractiveReady_
#define     _WaitInteractiveReady_

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady
//
//  Purpose:    Class to manage the wait on the shell signal to switch
//              desktop.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

class   CWaitInteractiveReady
{
    private:
                                        CWaitInteractiveReady (void);
                                        CWaitInteractiveReady (void *pWlxContext);
                                        ~CWaitInteractiveReady (void);
    public:
        static  NTSTATUS                Create (void *pWlxContext);
        static  NTSTATUS                Register (void *pWlxContext);
        static  NTSTATUS                Cancel (void);
    private:
                bool                    IsCreated (void)    const;
        static  NTSTATUS                ReleaseEvent (void);
        static  void    CALLBACK        CB_ShellReady (void *pParameter, BOOLEAN TimerOrWaitFired);
    private:
                void*                   _pWlxContext;
                HANDLE                  _hEvent;

        static  HANDLE                  s_hWait;
        static  CWaitInteractiveReady*  s_pWaitInteractiveReady;
        static  HANDLE                  s_hEventShellReady;
        static  const TCHAR             s_szEventName[];
};

#endif  /*  _WaitInteractiveReady_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\gina\waitinteractiveready.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: WaitInteractiveReady.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Class to handle waiting on the shell signal the desktop switch.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "WaitInteractiveReady.h"

#include <ginaipc.h>
#include <msginaexports.h>

#include "Impersonation.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::s_pWlxContext
//  CWaitInteractiveReady::s_hWait
//  CWaitInteractiveReady::s_hEvent
//  CWaitInteractiveReady::s_hEventShellReady
//  CWaitInteractiveReady::s_szEventName
//
//  Purpose:    Static member variables.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

HANDLE                  CWaitInteractiveReady::s_hWait                  =   NULL;
CWaitInteractiveReady*  CWaitInteractiveReady::s_pWaitInteractiveReady  =   NULL;
HANDLE                  CWaitInteractiveReady::s_hEventShellReady       =   NULL;
const TCHAR             CWaitInteractiveReady::s_szEventName[]          =   TEXT("msgina: ShellReadyEvent");

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::CWaitInteractiveReady
//
//  Arguments:  pWlxContext     =   PGLOBALS struct for msgina.
//
//  Returns:    <none>
//
//  Purpose:    Private constructor for this class. Create a synchronization
//              event for callback state determination.
//
//  History:    2001-07-17  vtan        created
//  --------------------------------------------------------------------------

CWaitInteractiveReady::CWaitInteractiveReady (void *pWlxContext) :
    _pWlxContext(pWlxContext),
    _hEvent(CreateEvent(NULL, TRUE, FALSE, NULL))

{
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::~CWaitInteractiveReady
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor. Clears member variables.
//
//  History:    2001-07-17  vtan        created
//  --------------------------------------------------------------------------

CWaitInteractiveReady::~CWaitInteractiveReady (void)

{
    ReleaseHandle(_hEvent);
    _pWlxContext = NULL;
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::Create
//
//  Arguments:  pWlxContext     =   PGLOBALS struct for msgina.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates resources required to manage switching desktops when
//              the shell signals the interactive ready event. This allows
//              the shell to be brought up in an interactive state.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CWaitInteractiveReady::Create (void *pWlxContext)

{
    NTSTATUS    status;
    HANDLE      hToken;

    ASSERTMSG(s_hWait == NULL, "Wait already registered in CWaitInteractiveReady::Start");
    ASSERTMSG(s_hEventShellReady == NULL, "Named event already exists in CWaitInteractiveReady::Start");
    hToken = _Gina_GetUserToken(pWlxContext);
    if (hToken != NULL)
    {
        CImpersonation  impersonation(hToken);

        if (impersonation.IsImpersonating())
        {
            s_hEventShellReady = CreateEvent(NULL, TRUE, FALSE, s_szEventName);
            if (s_hEventShellReady != NULL)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
                TSTATUS(ReleaseEvent());
            }
        }
        else
        {
            status = STATUS_BAD_IMPERSONATION_LEVEL;
        }
    }
    else
    {
        status = STATUS_NO_TOKEN;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::Register
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks the state of the event being waited on. It's possible
//              that explorer may have already signaled this event before this
//              code is executed. If the event is signaled then CB_ShellReady
//              has already been called.
//              
//  History:    2001-07-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CWaitInteractiveReady::Register (void *pWlxContext)

{
    NTSTATUS    status;

    ASSERTMSG(s_hWait == NULL, "Wait already registered in CWaitInteractiveReady::Check");

    //  Check and Stop should not be called from any thread other than
    //  the main thread of winlogon. It's called in only a few places.

    //  Firstly check the named event (msgina: ShellReadyEvent).

    if (s_hEventShellReady != NULL)
    {

        //  If it exists then check to see if it's signaled.

        if (WaitForSingleObject(s_hEventShellReady, 0) == WAIT_OBJECT_0)
        {

            //  If it's signaled then release the resources and return
            //  a failure code (force it down the classic UI path).

            TSTATUS(ReleaseEvent());
            status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            CWaitInteractiveReady   *pWaitInteractiveReady;

            pWaitInteractiveReady = new CWaitInteractiveReady(pWlxContext);
            if (pWaitInteractiveReady != NULL)
            {
                if (pWaitInteractiveReady->IsCreated())
                {

                    //  Otherwise if it's not signaled then register a wait on
                    //  the named object for 30 seconds.

                    if (RegisterWaitForSingleObject(&s_hWait,
                                                    s_hEventShellReady,
                                                    CB_ShellReady,
                                                    pWaitInteractiveReady,
                                                    30000,
                                                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) == FALSE)
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                        delete pWaitInteractiveReady;
                        TSTATUS(ReleaseEvent());
                    }
                    else
                    {
                        s_pWaitInteractiveReady = pWaitInteractiveReady;
                        status = STATUS_SUCCESS;
                    }
                }
                else
                {
                    delete pWaitInteractiveReady;
                    TSTATUS(ReleaseEvent());
                    status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                TSTATUS(ReleaseEvent());
                status = STATUS_NO_MEMORY;
            }
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::Cancel
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes the wait on the interactive ready object. This is
//              done when a user causes a return to welcome. This is
//              necessary because if the callback fires AFTER the return to
//              welcome we will switch to the user's desktop which violates
//              security.
//              
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CWaitInteractiveReady::Cancel (void)

{
    HANDLE  hWait;

    //  Grab the global hWait. If somebody beat us to this or it
    //  didn't exist then there's nothing to do.

    hWait = InterlockedExchangePointer(&s_hWait, NULL);
    if (hWait != NULL)
    {
        CWaitInteractiveReady   *pThis;

        //  Grab the s_pWaitInteractiveReady. This is a pointer to the callback
        //  memory. It will be valid unless the callback has already interlocked
        //  the variable itself which means the callback has reached the determined
        //  p0int already anyway and no wait is necessary.

        pThis = static_cast<CWaitInteractiveReady*>(InterlockedExchangePointer(reinterpret_cast<void**>(&s_pWaitInteractiveReady), NULL));

        //  Try to unregister the wait. If this fails then the callback
        //  is being executed. Wait until the callback reaches a determined
        //  point (it will signal the internal event). Wait TWO minutes for
        //  this. We cannot block the main thread of winlogon. If everything
        //  is working nicely then this will be a no-brainer wait.

        if (UnregisterWait(hWait) == FALSE)
        {

            //  If the unregister fails then wait if there's a valid event
            //  to wait on - reasons explained above.

            if (pThis != NULL)
            {
                (DWORD)WaitForSingleObject(pThis->_hEvent, 120000);
            }
        }
        else
        {

            //  Otherwise the wait was successfully unregistered indicating the
            //  callback is not executing. Release the memory that was allocated
            //  for it because it's not going to execute now.

            if (pThis != NULL)
            {
                delete pThis;
            }
        }
    }

    //  Always release the wait handle. This is valid because if the callback
    //  is executing and it grabbed the s_hWait then it will be NULL and it will
    //  also try to release the event handle. If there was no s_hWait then we
    //  just release the event handle anyway. Otherwise we grabbed the s_hWait
    //  above and can release the event handle as well.

    TSTATUS(ReleaseEvent());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::IsCreated
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the object is successfully created.
//
//  History:    2001-07-17  vtan        created
//  --------------------------------------------------------------------------

bool    CWaitInteractiveReady::IsCreated (void)    const

{
    return(_hEvent != NULL);
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::ReleaseEvent
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Resets the static member variables to the uninitialized
//              state.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CWaitInteractiveReady::ReleaseEvent (void)

{
    HANDLE  h;

    h = InterlockedExchangePointer(&s_hEventShellReady, NULL);
    if (h != NULL)
    {
        TBOOL(CloseHandle(h));
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CWaitInteractiveReady::CB_ShellReady
//
//  Arguments:  pParameter          =   User callback parameter.
//              TimerOrWaitFired    =   Timer or wait fired.
//
//  Returns:    <none>
//
//  Purpose:    Invoked when the interactive ready event is signaled by the
//              shell. Switch the desktop to the user's desktop.
//
//  History:    2001-01-15  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CWaitInteractiveReady::CB_ShellReady (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    HANDLE                  hWait;
    CWaitInteractiveReady   *pThis;

    pThis = static_cast<CWaitInteractiveReady*>(pParameter);

    //  Wrap the desktop manipulation around a scope which saves and restores
    //  the desktop. _Gina_SwitchDesktopToUser will set the thread's desktop
    //  to \Default and will NOT restore it. This scoped object will restore it.

    if (pThis->_pWlxContext != NULL)
    {
        CDesktop    desktop;

        //  Hide the status host. Switch the desktops.

        _ShellStatusHostEnd(HOST_END_HIDE);
        (int)_Gina_SwitchDesktopToUser(pThis->_pWlxContext);
    }

    //  Signal the internal event.

    TBOOL(SetEvent(pThis->_hEvent));

    //  Grab the global hWait. If somebody beat us to it then they're trying
    //  to stop this from happening. They could beat us to it at any time from
    //  the invokation of the callback to here. That thread will wait for this
    //  one to signal the internal event. In that case there's no work for this
    //  thread. The owner of the hWait has to clean up. If this thread gets the
    //  hWait then unregister the wait and release the resources.

    hWait = InterlockedExchangePointer(&s_hWait, NULL);
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
        TSTATUS(ReleaseEvent());
    }

    //  Interlock the s_pWaitInteractiveReady variable which is also an
    //  indicator of having reached the determined point in the callback.

    (CWaitInteractiveReady*)InterlockedExchangePointer(reinterpret_cast<void**>(&s_pWaitInteractiveReady), NULL);

    //  Delete our blob of data.

    delete pThis;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\hnw.inc ===
TARGET_BOTH    = 1

INCLUDES = $(INCLUDES);\
           $(CCSHELL_DIR)\ext\hnw\shared;\
           $(CCSHELL_DIR)\ext\hnw\win95;
#           $(SDK_INC_PATH)\mfc42;

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn16\makefile.inc ===
#
# Custom build file for 16-bit build.
#

buildall:
    nmake -nologo -fmakefile.sub
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hmmapi\resource.h ===
#define IDI_MAIL 1
#define IDS_DEFAULTPOSTURL 200
#define IDS_DEFAULTINBOXURL 201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hmmapi\hotmail.inc ===
#  HOTMAIL.INC
#
#  -- root include file for the hotmail project.  should be !included
#     before any macros are set, etc, with the exception of HMROOT,
#     which is required here
#
#  History:
#     22-March-98  Created by Shayne Bradley (shayneb)

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
!ifndef WIN16
WINVER_VERSION=0x0400
!endif

#ALT_PROJECT_TARGET=hotmail
#BINPLACE_PLACEFILE=$(HMROOT)\placefil.txt

INCLUDES=$(HMROOT)\external\inc;$(HMROOT)\inc

# treat warnings as errors
MSC_WARNING_LEVEL=/W3 /WX

# NOTE: the NT_BUILD below is a temp hack to allow old headers
# to function correctly with split windows headers

C_DEFINES=-DSTRICT -DNT_BUILD -DNASHVILLE -DWINVER=0x0400

!ifdef HMBROWSE
BROWSER_INFO=1
BSCMAKE_FLAGS=/n /nologo
!endif

!if !$(FREEBUILD)
LINKER_NOICF=1
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hmmapi\inc\bmapi.h ===
#include <wtypes.h>
//#include <oaidl.h>
#include <oleauto.h>
#include <mapi.h>

// Structures and Functions used by BMAPI and VB2C

#define RECIPIENT   	((USHORT)0x0001)
#define FILE        	((USHORT)0x0002)
#define MESSAGE     	((USHORT)0x0004)
#define USESAFEARRAY	((USHORT)0x1000)

#if defined (WIN32)
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#else
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG __export FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#endif

#ifndef LHANDLE
  #define LHANDLE ULONG
#endif

#ifndef ERR
  #define ERR 	USHORT
#endif


//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface function support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG	ulReserved;
	BSTR 	bstrSubject;
	BSTR 	bstrNoteText;
	BSTR 	bstrMessageType;
	BSTR 	bstrDate;
	BSTR 	bstrConversationID;
	ULONG 	flFlags;
	ULONG 	nRecipCount;
	ULONG 	nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	ulRecipClass;
	BSTR 	bstrName;
	BSTR 	bstrAddress;
	ULONG 	ulEIDSize;
	BSTR 	bstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	flFlags;
	ULONG 	nPosition;
	BSTR 	bstrPathName;
	BSTR 	bstrFileName;
	BSTR 	bstrFileType;
} VB_File, FAR *lpVB_File;

/*

// OLEAUT32.DLL loadlib and getprocaddress support

// WINOLEAUTAPI_(void) SysFreeString(BSTR);
typedef VOID (STDAPICALLTYPE *LPFNSYSFREESTRING)
	( BSTR bstr );

// WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGBYTELEN)
	(BSTR bstr);

// WINOLEAUTAPI_(BSTR) SysAllocStringByteLen(const char FAR* psz, unsigned int len);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRINGBYTELEN)
	(const char *psz, UINT len );

// WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRING)
	(const OLECHAR * szwString);

// WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
typedef INT (STDAPICALLTYPE *LPFNSYSREALLOCSTRING)
	(BSTR * lpBstr, const OLECHAR * szwString);

// WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGLEN)
	(BSTR bstr);

// WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYACCESSDATA)
	(struct tagSAFEARRAY *psa, void **ppvData);

// WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYUNACCESSDATA)
	(struct tagSAFEARRAY *psa);

extern LPFNSYSFREESTRING 			lpfnSysFreeString;
extern LPFNSYSSTRINGBYTELEN 		lpfnSysStringByteLen;
extern LPFNSYSALLOCSTRINGBYTELEN	lpfnSysAllocStringByteLen;
extern LPFNSYSALLOCSTRING			lpfnSysAllocString;
extern LPFNSYSREALLOCSTRING			lpfnSysReAllocString;
extern LPFNSYSSTRINGLEN				lpfnSysStringLen;
extern LPFNSAFEARRAYACCESSDATA		lpfnSafeArrayAccessData;
extern LPFNSAFEARRAYUNACCESSDATA	lpfnSafeArrayUnaccessData;

#undef SysFreeString
#undef SysStringByteLen
#undef SysAllocStringByteLen
#undef SysAllocString
#undef SysReAllocString
#undef SysStringLen
#undef SafeArrayAccessData
#undef SafeArrayUnaccessData
  

#define SysFreeString			(*lpfnSysFreeString)
#define SysStringByteLen 		(*lpfnSysStringByteLen)
#define SysAllocStringByteLen	(*lpfnSysAllocStringByteLen)
#define SysAllocString			(*lpfnSysAllocString)
#define SysReAllocString		(*lpfnSysReAllocString)
#define SysStringLen			(*lpfnSysStringLen)
#define SafeArrayAccessData		(*lpfnSafeArrayAccessData)
#define SafeArrayUnaccessData	(*lpfnSafeArrayUnaccessData)
  
    */



typedef VB_File 			VB_FILE;
typedef VB_File FAR *		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;

typedef VB_File 			VB_FILE;
typedef VB_File FAR * 		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;
typedef LPHANDLE FAR *		LPPHANDLE;

/*
#if defined WIN32




//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface functions
//-----------------------------------------------------------------------
BMAPI_ENTRY BMAPISendMail (LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY *    lppsaRecips,
                           LPSAFEARRAY * 	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved);

BMAPI_ENTRY BMAPIFindNext(LHANDLE 	hSession,
                          ULONG 	ulUIParam,
                          BSTR * 	bstrType,
                          BSTR * 	bstrSeed,
                          ULONG 	flFlags,
                          ULONG 	ulReserved,
                          BSTR * 	lpbstrId);

BMAPI_ENTRY BMAPIReadMail (LPULONG 	lpulMessage,
                           LPULONG 	nRecips,
                           LPULONG 	nFiles,
                           LHANDLE 	hSession,
                           ULONG 	ulUIParam,
                           BSTR * 	lpbstrID,
                           ULONG 	flFlags,
                           ULONG 	ulReserved);

BMAPI_ENTRY BMAPIGetReadMail(ULONG 			lpMessage,
                             LPVB_MESSAGE 	lpvbMessage,
                             LPSAFEARRAY *  lppsaRecips,
                             LPSAFEARRAY *	lppsaFiles,
                             LPVB_RECIPIENT	lpvbOrig);

BMAPI_ENTRY BMAPISaveMail( LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY * 	lppsaRecips,
                           LPSAFEARRAY *	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved,
                           BSTR * 			lpbstrID);

BMAPI_ENTRY BMAPIAddress (LPULONG 			lpulRecip,
                          LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          BSTR * 			lpbstrCaption,
                          ULONG 			ulEditFields,
                          BSTR * 			lpbstrLabel,
                          LPULONG 			lpulRecipients,
                          LPSAFEARRAY * 	lppsaRecip,		// LPVB_RECIPIENT
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIGetAddress (ULONG			ulRecipientData,
                             ULONG 			count,
                             LPSAFEARRAY *	lppsaRecips);

BMAPI_ENTRY BMAPIDetails (LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          LPVB_RECIPIENT	lpVB,
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIResolveName (LHANDLE			hSession,
                              ULONG 			ulUIParam,
                              BSTR  			bstrMapiName,
                              ULONG 			ulFlags,
                              ULONG 			ulReserved,
                              LPVB_RECIPIENT 	lpVB);
*/

typedef ULONG (FAR PASCAL BMAPISENDMAIL)(
    LHANDLE 		hSession,
    ULONG 			ulUIParam,
    LPVB_MESSAGE 	lpM,
    LPSAFEARRAY *    lppsaRecips,
    LPSAFEARRAY * 	lppsaFiles,
    ULONG 			flFlags,
    ULONG 			ulReserved
);
typedef BMAPISENDMAIL FAR *LPBMAPISENDMAIL;
BMAPISENDMAIL BMAPISendMail;


typedef ULONG (FAR PASCAL BMAPIFINDNEXT)(
    LHANDLE hSession,
    ULONG 	ulUIParam,
    BSTR * 	bstrType,
    BSTR * 	bstrSeed,
    ULONG 	flFlags,
    ULONG 	ulReserved,
    BSTR * 	lpbstrId
);
typedef BMAPIFINDNEXT FAR *LPBMAPIFINDNEXT;
BMAPIFINDNEXT BMAPIFindNext;


typedef ULONG (FAR PASCAL BMAPIREADMAIL)(
    LPULONG     lpulMessage,
    LPULONG     nRecips,
    LPULONG     nFiles,
    LHANDLE     hSession,
    ULONG 	    ulUIParam,
    BSTR * 	    lpbstrID,
    ULONG 	    flFlags,
    ULONG 	    ulReserved
);
typedef BMAPIREADMAIL FAR *LPBMAPIREADMAIL;
BMAPIREADMAIL BMAPIReadMail;


typedef ULONG (FAR PASCAL BMAPIGETREADMAIL)(
    ULONG 			lpMessage,
    LPVB_MESSAGE 	lpvbMessage,
    LPSAFEARRAY *  lppsaRecips,
    LPSAFEARRAY *	lppsaFiles,
    LPVB_RECIPIENT	lpvbOrig    
);
typedef BMAPIGETREADMAIL FAR *LPBMAPIGETREADMAIL;
BMAPIGETREADMAIL BMAPIGetReadMail;


typedef ULONG (FAR PASCAL BMAPISAVEMAIL)(
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    LPVB_MESSAGE 	    lpM,
    LPSAFEARRAY * 	    lppsaRecips,
    LPSAFEARRAY *	    lppsaFiles,
    ULONG 			    flFlags,
    ULONG 			    ulReserved,
    BSTR * 			    lpbstrID
);
typedef BMAPISAVEMAIL FAR *LPBMAPISAVEMAIL;
BMAPISAVEMAIL BMAPISaveMail;


typedef ULONG (FAR PASCAL BMAPIADDRESS)(
    LPULONG 			lpulRecip,
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    BSTR * 			    lpbstrCaption,
    ULONG 			    ulEditFields,
    BSTR * 			    lpbstrLabel,
    LPULONG 			lpulRecipients,
    LPSAFEARRAY * 	    lppsaRecip,		// LPVB_RECIPIENT
    ULONG 			    ulFlags,
    ULONG 			    ulReserved
);
typedef BMAPIADDRESS FAR *LPBMAPIADDRESS;
BMAPIADDRESS BMAPIAddress;


typedef ULONG (FAR PASCAL BMAPIGETADDRESS)(
    ULONG			ulRecipientData,
    ULONG 			count,
    LPSAFEARRAY *	lppsaRecips
);
typedef BMAPIGETADDRESS FAR *LPBMAPIGETADDRESS;
BMAPIGETADDRESS BMAPIGetAddress;


typedef ULONG (FAR PASCAL BMAPIDETAILS)(
    LHANDLE 			hSession,
    ULONG 			ulUIParam,
    LPVB_RECIPIENT	lpVB,
    ULONG 			ulFlags,
    ULONG 			ulReserved
);
typedef BMAPIDETAILS FAR *LPBMAPIDETAILS;
BMAPIDETAILS BMAPIDetails;


typedef ULONG (FAR PASCAL BMAPIRESOLVENAME)(
    LHANDLE			hSession,
    ULONG 			ulUIParam,
    BSTR  			bstrMapiName,
    ULONG 			ulFlags,
    ULONG 			ulReserved,
    LPVB_RECIPIENT 	lpVB
);
typedef BMAPIRESOLVENAME FAR *LPBMAPIRESOLVENAME;
BMAPIRESOLVENAME BMAPIResolveName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hmmapi\hmmapi.cpp ===
#include "pch.hxx"
#include <winuser.h>
#include <hlink.h>
#include <shellapi.h>
#define INITGUID
#include <initguid.h>
#include <exdisp.h>
#include <tchar.h>

BOOL IsNtSetupRunning()
{
    BOOL fSetupRunning = FALSE;
    DWORD dwSetupRunning;
    DWORD cbValue = sizeof(dwSetupRunning);
    long lResult = SHGetValue(HKEY_LOCAL_MACHINE, "system\\Setup", "SystemSetupInProgress", NULL, &dwSetupRunning, &cbValue);

    if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
    {
        fSetupRunning = TRUE;
    }
    else
    {
        cbValue = sizeof(dwSetupRunning);
        lResult = SHGetValue(HKEY_LOCAL_MACHINE, "system\\Setup", "UpgradeInProgress", NULL, &dwSetupRunning, &cbValue);

        if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
        {
            fSetupRunning = TRUE;
        }
    }

    return fSetupRunning;
}

#define ARRAYSIZE(buf) (sizeof(buf) / sizeof(buf[0]))

HINSTANCE       g_hInstMAPI = NULL;

////////////////////////////////////////////////////////////////////////
//
//  dll entry point
//
////////////////////////////////////////////////////////////////////////
STDAPI_(BOOL) APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpRsrvd)
{
    switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			g_hInstMAPI = hDll;
			break;

		case DLL_PROCESS_DETACH:
			break;
	} // switch
    return(TRUE);
}

BOOL FRunningOnNTEx(LPDWORD pdwVersion)
{
    static BOOL fIsNT = 2 ;
    static DWORD dwVersion = (DWORD)0;
    OSVERSIONINFO VerInfo;
    
    // If we have calculated this before just pass that back.
    // else find it now.
    //
    if (fIsNT == 2)
    {
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        GetVersionEx(&VerInfo);
        // Also, we don't check for failure on the above call as it
        // should succeed if we are on NT 4.0 or Win 9X!
        //
        fIsNT = (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
        if (fIsNT)
            dwVersion = VerInfo.dwMajorVersion;
    }
    if (pdwVersion)
        *pdwVersion = dwVersion;
    
    return fIsNT;
}
// Then next 2 functions are stollen from shlwapi. Needed to modiy them, because
// we had to handle SFN.
// Also there is a bug in the Ansi versin of ExpandEnvironmentStrings, where the
// function returns the number of bytes the string would have if it would be
// UNICODE. Since we have to convert the string anyway to SFN I use lstrlen to 
// get the real length.
//
//  If the given environment variable exists as the first part of the path,
//  then the environment variable is inserted into the output buffer.
//
//  Returns TRUE if pszResult is filled in.
//
//  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SYSTEMROOT%
//            Output -- %SYSTEMROOT%\SYSTEM32\FOO.TXT
//
BOOL MyUnExpandEnvironmentString(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
    DWORD dwEnvVar = SHExpandEnvironmentStrings(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar));

    if (dwEnvVar)
    {
        // Convert the string to short file name
        GetShortPathName(szEnvVar, szEnvVar, ARRAYSIZE(szEnvVar));
        dwEnvVar = lstrlen(szEnvVar);
        if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2)
        {
            if (lstrlen(pszPath) - (int)dwEnvVar + lstrlen(pszEnvVar) < (int)cbResult)
            {
                lstrcpy(pszResult, pszEnvVar);
                lstrcat(pszResult, pszPath + dwEnvVar);
                return TRUE;
            }
        }
    }
    return FALSE;
}


// note: %USERPROFILE% is relative to the user making the call, so this does
// not work if we are being impresonated from a service, for example
// dawrin installs apps from the system process this way
STDAPI_(BOOL) MyPathUnExpandEnvStrings(LPCTSTR pszPath, LPTSTR pszBuf, UINT cchBuf)
{
    if (pszPath && pszBuf)
    {
        return (MyUnExpandEnvironmentString(pszPath, TEXT("%USERPROFILE%"), pszBuf, cchBuf)       ||
                MyUnExpandEnvironmentString(pszPath, TEXT("%ALLUSERSPROFILE%"), pszBuf, cchBuf)   ||
                MyUnExpandEnvironmentString(pszPath, TEXT("%ProgramFiles%"), pszBuf, cchBuf)      ||
                MyUnExpandEnvironmentString(pszPath, TEXT("%SystemRoot%"), pszBuf, cchBuf)        ||
                MyUnExpandEnvironmentString(pszPath, TEXT("%SystemDrive%"), pszBuf, cchBuf));
    }
    else
    {
        return FALSE;
    }
}


#define POST_URL 0
#define INBOX_URL 1
// Return either the PostURL or the InboxURL depending on the value of nURL
//
static void GetPostUrl(int nURL, LPSTR lpszData, DWORD dwSize)
{
	HKEY hkDefClient;
	HKEY hkClient;
	TCHAR szClient[64];
	DWORD type;
	DWORD dwClientSize = sizeof(TCHAR) * 64;

	LONG err = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Clients\\Mail"), &hkClient);
	if (err == ERROR_SUCCESS)
	{
		err = RegQueryValueEx(hkClient, NULL, 0, &type, (LPBYTE)szClient, &dwClientSize);
		if (err == ERROR_SUCCESS)
		{
			err = RegOpenKey(hkClient, szClient, &hkDefClient);
			if (err == ERROR_SUCCESS)
			{
				DWORD type;
				err = RegQueryValueEx(hkDefClient, 
									  nURL == POST_URL ? TEXT("posturl") : TEXT("inboxurl"), 
									  0, &type, (LPBYTE)lpszData, &dwSize);
				RegCloseKey(hkDefClient);
			}
		}
		RegCloseKey(hkClient);
	}
	if (err != ERROR_SUCCESS)
    {
        LoadString(g_hInstMAPI, 
                   nURL == POST_URL ? IDS_DEFAULTPOSTURL : IDS_DEFAULTINBOXURL, 
                   lpszData, dwSize);
    }
}


typedef HRESULT (STDAPICALLTYPE DynNavigate)(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc,
							 LPCWSTR pszTargetFrame, LPCWSTR pszUrl, LPCWSTR pszLocation);
typedef DynNavigate FAR *LPDynNavigate;

STDAPI HlinkFrameNavigateNHL(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc,
							 LPCWSTR pszTargetFrame, LPCWSTR pszUrl, LPCWSTR pszLocation)
{
	HRESULT hr;
    HINSTANCE   hinst;
	LPDynNavigate fpNavigate = NULL;

	hinst = LoadLibraryA("SHDOCVW.DLL");

    // If that failed because the module was not be found,
    // then try to find the module in the directory we were
    // loaded from.

    if (!hinst)
	goto Error;

    fpNavigate = (LPDynNavigate)GetProcAddress(hinst, "HlinkFrameNavigateNHL");
    if (!fpNavigate)
	goto Error;

    hr = fpNavigate(grfHLNF, pbc, pibsc, pszTargetFrame, pszUrl, pszLocation);

	FreeLibrary(hinst);
	return hr;

Error:
    return GetLastError();
}

static void SimpleNavigate(LPTSTR lpszUrl, BOOL bUseFrame = false)
{
    DWORD cch = (lstrlen(lpszUrl) + 1);
	LPWSTR pwszData = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cch * sizeof(WCHAR));
    if (pwszData)
    {
        SHTCharToUnicode(lpszUrl, pwszData, cch);
        if (bUseFrame)
            HlinkFrameNavigateNHL(HLNF_OPENINNEWWINDOW, NULL, NULL, NULL, pwszData, NULL);
        else
            HlinkSimpleNavigateToString(pwszData, NULL, NULL, NULL, NULL, NULL, 0, 0);
        HeapFree(GetProcessHeap(), 0, (LPVOID)pwszData);
    }
}

// Pack some data into a SAFEARRAY of BYTEs. Return in a VARIANT
static HRESULT GetPostData(LPVARIANT pvPostData, LPTSTR lpszData)
{
	HRESULT hr;
	LPSAFEARRAY psa;
	UINT cElems = lstrlen(lpszData);
	LPSTR pPostData;

	if (!pvPostData)
		return E_POINTER;

	VariantInit(pvPostData);

	psa = SafeArrayCreateVector(VT_UI1, 0, cElems);
	if (!psa)
		return E_OUTOFMEMORY;

	hr = SafeArrayAccessData(psa, (LPVOID*)&pPostData);
	memcpy(pPostData, lpszData, cElems);
	hr = SafeArrayUnaccessData(psa);

	V_VT(pvPostData) = VT_ARRAY | VT_UI1;
	V_ARRAY(pvPostData) = psa;
	return NOERROR;
}

static void DoNavigate(LPTSTR lpszUrl, LPTSTR lpszData, BOOL bPlainIntf = TRUE)
{
	HRESULT hr;
	IWebBrowser2* pWBApp = NULL; // Derived from IWebBrowser
	BSTR bstrURL = NULL, bstrHeaders = NULL;
	VARIANT vFlags = {0};
	VARIANT vTargetFrameName = {0};
	VARIANT vPostData = {0};
	VARIANT vHeaders = {0};
	LPWSTR pwszData = NULL;
	LPTSTR pszUrl = NULL;
    DWORD cch;

	if (FAILED(hr = CoInitialize(NULL)))
		return;

	if (FAILED(hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_SERVER, IID_IWebBrowser2, (LPVOID*)&pWBApp)))
		goto Error;

    cch = lstrlen(lpszUrl) + lstrlen(lpszData) + 2;
	pszUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cch * sizeof(TCHAR));
	if (!pszUrl)
		goto Error;
	lstrcpy(pszUrl, lpszUrl);
	lstrcat(pszUrl, "?");
	lstrcat(pszUrl, lpszData);
	cch = lstrlen(pszUrl) + 1;
	pwszData = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cch * sizeof(WCHAR));
	if (!pwszData)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)pszUrl);
		goto Error;
	}

    SHTCharToUnicode(pszUrl, pwszData, cch);
	HeapFree(GetProcessHeap(), 0, (LPVOID)pszUrl);
	bstrURL = SysAllocString(pwszData);
	HeapFree(GetProcessHeap(), 0, (LPVOID)pwszData);
	if (!bstrURL)
		goto Error;

	hr = pWBApp->Navigate(bstrURL, &vFlags, &vTargetFrameName, &vPostData, &vHeaders);
	if (bPlainIntf)
	{
		pWBApp->put_AddressBar(VARIANT_FALSE);
		pWBApp->put_MenuBar(VARIANT_FALSE);
		pWBApp->put_ToolBar(VARIANT_FALSE);
	}
	pWBApp->put_Visible(VARIANT_TRUE);

Error:
	if (bstrURL)
		SysFreeString(bstrURL);
	if (bstrHeaders)
		SysFreeString(bstrHeaders);
	VariantClear(&vPostData);
	if (pWBApp)
		pWBApp->Release();
	CoUninitialize();
}

// Helpers for Form Submit - copied from IE3 and modified approriately
//
static char x_hex_digit(int c)
{
    if (c >= 0 && c <= 9)
    {
	return c + '0';
    }
    if (c >= 10 && c <= 15)
    {
	return c - 10 + 'A';
    }
    return '0';
}

static const unsigned char isAcceptable[96] =
/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,    /* 2x   !"#$%&'()*+,-./  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,    /* 3x  0123456789:;<=>?  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,    /* 5x  PQRSTUVWXYZ[\]^_  */
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};   /* 7x  pqrstuvwxyz{\}~  DEL */

// Performs URL-encoding of null-terminated strings. Pass NULL in pbOut
// to find buffer length required. Note that '\0' is not written out.

// 2/9/99  cchLimit param added for safety -- no more than cchLimit chars are
// written out.  If pbOut is NULL then cchLimit is ignored.  If the caller uses 
// the style Buffer[URLEncode(Buffer, ...)] = 0, then cchLimit should be the 
// buffer size minus one.
   
int
URLEncode(LPTSTR pbOut, const char * pchIn, const int cchLimit)
{
    int     lenOut = 0;
    char *  pchOut = (char *)pbOut;

    for (; *pchIn && (!pchOut || lenOut < cchLimit); pchIn++, lenOut++)
    {
        if (*pchIn == ' ')
        {
            if (pchOut)
                *pchOut++ = '+';
        }
        else if (*pchIn >= 32 && *pchIn <= 127 && isAcceptable[*pchIn - 32])
        {
            if (pchOut)
                *pchOut++ = (TCHAR)*pchIn;
        }
        else
        {
            if (pchOut) 
            {
                if (lenOut <= cchLimit - 3)
                {
                    // enough room for this encoding
                    *pchOut++ = '%';
                    *pchOut++ = x_hex_digit((*pchIn >> 4) & 0xf);
                    *pchOut++ = x_hex_digit(*pchIn & 0xf);
                    lenOut += 2; 
                }
                else
                    return lenOut;
            }
            else
                lenOut += 2; // for expression handles 3rd inc  
        }
    }

    return lenOut;
}


///////////////////////////////////////////////////////////////////////
//
// MAPILogon
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogon(ULONG ulUIParam,
			   LPSTR lpszProfileName,
			   LPSTR lpszPassword,
			   FLAGS flFlags,
			   ULONG ulReserved,
			   LPLHANDLE lplhSession)
{
	*lplhSession = 1;
	return SUCCESS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
//
// MAPILogoff
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession,
			    ULONG ulUIParam,
			    FLAGS flFlags,
			    ULONG ulReserved)
{
	return SUCCESS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIFreeBuffer
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID lpv)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// MAPISendMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession,          
                  ULONG ulUIParam,
                  lpMapiMessage lpMessage,
                  FLAGS flFlags,
                  ULONG ulReserved)
{
    TCHAR szUrl[256];

    GetPostUrl(POST_URL, szUrl, sizeof(TCHAR) * 256);
    
    // Calculate the buffer size needed to create the url
    ULONG i;
    DWORD dwUrlSize = 32; // "?action=compose" + slop
    DWORD dwMaxSize = 0;
    DWORD dwSize;
    DWORD dwFileSizes = 0;
    HANDLE hFile;

    if (lpMessage->lpszSubject)
    {
        dwSize = URLEncode(NULL, lpMessage->lpszSubject, 0);
        dwMaxSize = max(dwMaxSize, dwSize + 1);
        dwUrlSize += dwMaxSize + 9; // "&subject=%s"
    }
    if (lpMessage->lpszNoteText)
    {
        dwSize = URLEncode(NULL, lpMessage->lpszNoteText, 0);
        dwMaxSize = max(dwMaxSize, dwSize + 1);
        dwUrlSize += dwSize + 6; // "&body=%s"
    }

    for (i = 0; i < lpMessage->nRecipCount; i++)
    {
        dwSize = URLEncode(NULL, lpMessage->lpRecips[i].lpszName, 0);
        dwMaxSize = max(dwMaxSize, dwSize + 1);
        dwUrlSize += dwSize + 4; // "&to=%s" || "&cc=%s"
        if (lpMessage->lpRecips[i].ulRecipClass == MAPI_BCC)
            dwUrlSize++; // extra character for bcc
    }

    if (lpMessage->nFileCount)
    {
        dwUrlSize += 14; // "&filecount=xxx"
        for (i = 0; i < lpMessage->nFileCount; i++)
        {
            if (!lpMessage->lpFiles[i].lpszPathName)
                continue;

            TCHAR szFileSize[32];

            hFile = CreateFile(lpMessage->lpFiles[i].lpszPathName, 0 /*GENERIC_READ*/, 0 /*FILE_SHARE_READ*/, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile == INVALID_HANDLE_VALUE)
            {
                LPVOID lpMsgBuf = NULL;
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0, NULL);
                if (lpMsgBuf)
                {
                    MessageBox(NULL, (char*)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION);
                    LocalFree(lpMsgBuf);
                }
                continue;
            }
            dwSize = GetFileSize(hFile, NULL);
            CloseHandle(hFile);
            if (dwSize == -1)
                continue;
            dwFileSizes += dwSize;
            wnsprintf(szFileSize, ARRAYSIZE(szFileSize), "&size%d=%d", i, dwSize);
            dwSize = lstrlen(szFileSize);
            dwMaxSize = max(dwMaxSize, dwSize + 1);
            dwUrlSize += dwSize;


            dwSize = URLEncode(NULL, lpMessage->lpFiles[i].lpszPathName, 0) + 4;    // in case we need to append a ^
            dwMaxSize = max(dwMaxSize, dwSize + 1);
            dwUrlSize += dwSize + 9; // "&pathxxx=%s"

            if (lpMessage->lpFiles[i].lpszFileName)
            {
                dwSize = URLEncode(NULL, lpMessage->lpFiles[i].lpszFileName, 0);
                dwMaxSize = max(dwMaxSize, dwSize + 1);
                dwUrlSize += dwSize + 9; // "&filexxx=%s"
            }
            else 
            {
                // ATTFILE code further down just tacks on the path when lpszFileName is NULL
                dwUrlSize += URLEncode(NULL, lpMessage->lpFiles[i].lpszPathName, 0) + 4;
            }
        }
    }

    dwSize = ARRAYSIZE("&attfile=") + (URLEncode(NULL, "::", 0) * lpMessage->nFileCount * 3);
    dwMaxSize = max(dwMaxSize, dwSize + 1);
    dwUrlSize += dwSize;

    LPTSTR pszData = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwUrlSize * sizeof(TCHAR));

    if (!pszData)
        return MAPI_E_FAILURE;

    LPTSTR pszBuf = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwMaxSize * sizeof(TCHAR));

    if (!pszBuf) 
    {
        HeapFree(GetProcessHeap(), 0, (LPVOID) pszData);
        return MAPI_E_FAILURE;
    }

    // Build the URL
    lstrcpyn(pszData, "action=compose", dwUrlSize);

    for (i = 0; i < lpMessage->nRecipCount; i++)
    {
        switch (lpMessage->lpRecips[i].ulRecipClass)
        {
            case MAPI_TO:
                StrCatBuff(pszData, "&to=", dwUrlSize);
                break;
            case MAPI_CC:
                StrCatBuff(pszData, "&cc=", dwUrlSize);
                break;
            case MAPI_BCC:
                StrCatBuff(pszData, "&bcc=", dwUrlSize);
                break;
        }
        pszBuf[URLEncode(pszBuf, lpMessage->lpRecips[i].lpszName, dwMaxSize-1)] = 0;
        StrCatBuff(pszData, pszBuf, dwUrlSize);
    }
    if (lpMessage->lpszSubject)
    {
        StrCatBuff(pszData, "&subject=", dwUrlSize);
        pszBuf[URLEncode(pszBuf, lpMessage->lpszSubject, dwMaxSize-1)] = 0;
        StrCatBuff(pszData, pszBuf, dwUrlSize);
    }
    if (lpMessage->lpszNoteText)
    {
        StrCatBuff(pszData, "&body=", dwUrlSize);
        pszBuf[URLEncode(pszBuf, lpMessage->lpszNoteText, dwMaxSize-1)] = 0;
        StrCatBuff(pszData, pszBuf, dwUrlSize);
    }
    if (lpMessage->nFileCount)
    {
        TCHAR szSep[32];
        TCHAR szPath[MAX_PATH];
        TCHAR szTemp[MAX_PATH];
        GetTempPath(MAX_PATH - 1, szTemp);
        BOOL bIsTemp;

        StrCatBuff(pszData, "&attfile=", dwUrlSize);
        for (i = 0; i < lpMessage->nFileCount; i++)
        {
            if (!lpMessage->lpFiles[i].lpszPathName)
                continue;

            bIsTemp = FALSE;
            lstrcpyn(szPath, lpMessage->lpFiles[i].lpszPathName, ARRAYSIZE(szPath));
            hFile = CreateFile(szPath, 0, 0 /*GENERIC_READ, FILE_SHARE_READ*/, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile == INVALID_HANDLE_VALUE)
                continue;
            dwSize = GetFileSize(hFile, NULL);
            // Handle the case where this is a temporary file
            if (CompareString(LOCALE_SYSTEM_DEFAULT, 0, szTemp, lstrlen(szTemp), szPath, lstrlen(szTemp)) == CSTR_EQUAL)
            {
                // If the file was created in the last 2 seconds assume that it is really temporary
                FILETIME ftLastWrite, ftSystem;
                LARGE_INTEGER liLastWrite, liSystem;
                if (GetFileTime(hFile, NULL, NULL, &ftLastWrite))
                {
                    GetSystemTimeAsFileTime(&ftSystem);
                    liLastWrite.LowPart = ftLastWrite.dwLowDateTime;
                    liLastWrite.HighPart = ftLastWrite.dwHighDateTime;
                    liSystem.LowPart = ftSystem.dwLowDateTime;
                    liSystem.HighPart = ftSystem.dwHighDateTime;
                    //jeffif (liLastWrite.QuadPart - liSystem.QuadPart < 30000000L)
                        bIsTemp = TRUE;
                }
            }
            CloseHandle(hFile);
            if (dwSize == -1)
                continue;
            if (bIsTemp)
            {
                StrCatBuff(szPath, "^", ARRAYSIZE(szPath));
                MoveFile(lpMessage->lpFiles[i].lpszPathName, szPath);
                SetFileAttributes(szPath, FILE_ATTRIBUTE_READONLY);
            }
            szSep[URLEncode(szSep, "::", ARRAYSIZE(szSep)-1)] = 0;
            pszBuf[URLEncode(pszBuf, szPath, dwMaxSize-1)] = 0;
            StrCatBuff(pszData, pszBuf, dwUrlSize);
            StrCatBuff(pszData, szSep, dwUrlSize);
            if (lpMessage->lpFiles[i].lpszFileName)
            {
                pszBuf[URLEncode(pszBuf, lpMessage->lpFiles[i].lpszFileName, dwMaxSize-1)] = 0;
                StrCatBuff(pszData, pszBuf, dwUrlSize);
            }
            else
                StrCatBuff(pszData, pszBuf, dwUrlSize);
            StrCatBuff(pszData, szSep, dwUrlSize);
            wnsprintf(szSep, ARRAYSIZE(szSep), "^%d;", dwSize);
            pszBuf[URLEncode(pszBuf, szSep, dwMaxSize-1)] = 0;
            StrCatBuff(pszData, pszBuf, dwUrlSize);
        }
    }
    HeapFree(GetProcessHeap(), 0, (LPVOID)pszBuf);

    DoNavigate(szUrl, pszData, FALSE);
    HeapFree(GetProcessHeap(), 0, (LPVOID)pszData);

    return SUCCESS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
//
// MAPISendDocuments
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendDocuments(ULONG ulUIParam,
				   LPSTR lpszDelimChar,
				   LPSTR lpszFullPaths,
				   LPSTR lpszFileNames,
				   ULONG ulReserved)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIAddress
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession,
			     ULONG ulUIParam,
			     LPTSTR lpszCaption,
			     ULONG nEditFields,
			     LPTSTR lpszLabels,
			     ULONG nRecips,
			     lpMapiRecipDesc lpRecips,
			     FLAGS flFlags,
			     ULONG ulReserved,
			     LPULONG lpnNewRecips,
			     lpMapiRecipDesc FAR * lppNewRecips)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIDetails
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession,
			     ULONG ulUIParam,
			     lpMapiRecipDesc lpRecip,
			     FLAGS flFlags,
			     ULONG ulReserved)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIResolveName
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession,
				 ULONG ulUIParam,
				 LPSTR lpszName,
				 FLAGS flFlags,
				 ULONG ulReserved,
				 lpMapiRecipDesc FAR *lppRecip)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIFindNext
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession,
			      ULONG ulUIParam,
			      LPSTR lpszMessageType,
			      LPSTR lpszSeedMessageID,
			      FLAGS flFlags,
			      ULONG ulReserved,
			      LPSTR lpszMessageID)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIReadMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession,
			      ULONG ulUIParam,
			      LPSTR lpszMessageID,
			      FLAGS flFlags,
			      ULONG ulReserved,
			      lpMapiMessage FAR *lppMessage)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// MAPISaveMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession,
			      ULONG ulUIParam,
			      lpMapiMessage lpMessage,
			      FLAGS flFlags,
			      ULONG ulReserved,
			      LPSTR lpszMessageID)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIDeleteMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession,
				ULONG ulUIParam,
				LPSTR lpszMessageID,
				FLAGS flFlags,
				ULONG ulReserved)
{
	return MAPI_E_FAILURE;
}


///////////////////////////////////////////////////////////////////////
//
// BMAPISendMail
//
///////////////////////////////////////////////////////////////////////

BMAPI_ENTRY BMAPISendMail (LHANDLE                      hSession,
			   ULONG                        ulUIParam,
			   LPVB_MESSAGE         lpM,
			   LPSAFEARRAY *        lppsaRecips,
			   LPSAFEARRAY *        lppsaFiles,
			   ULONG                        flFlags,
			   ULONG                        ulReserved)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIFindNext
//
///////////////////////////////////////////////////////////////////////
BMAPI_ENTRY BMAPIFindNext( LHANDLE      hSession,       // Session
			   ULONG        ulUIParam,      // UIParam
			   BSTR *       lpbstrType,     // MessageType
			   BSTR *       lpbstrSeed,     // Seed message Id
			   ULONG        flFlags,        // Flags
			   ULONG        ulReserved,     // Reserved
			   BSTR *       lpbstrId) 
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIReadMail
//
///////////////////////////////////////////////////////////////////////
BMAPI_ENTRY BMAPIReadMail( LPULONG      lpulMessage,    // pointer to output data (out)
			   LPULONG      nRecips,        // number of recipients (out)
			   LPULONG      nFiles,         // number of file attachments (out)
			   LHANDLE      hSession,       // Session
			   ULONG        ulUIParam,      // UIParam
			   BSTR *       lpbstrID,       // Message Id
			   ULONG        flFlags,        // Flags
			   ULONG        ulReserved )    // Reserved
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIGetReadMail
//
///////////////////////////////////////////////////////////////////////
BMAPI_ENTRY BMAPIGetReadMail( ULONG             lpMessage,       // Pointer to MAPI Mail
			      LPVB_MESSAGE      lpvbMessage, // Pointer to VB Message Buffer (out)
			      LPSAFEARRAY * lppsaRecips, // Pointer to VB Recipient Buffer (out)
			      LPSAFEARRAY * lppsaFiles,  // Pointer to VB File attachment Buffer (out)
			      LPVB_RECIPIENT lpvbOrig)   // Pointer to VB Originator Buffer (out)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPISaveMail
//
///////////////////////////////////////////////////////////////////////
BMAPI_ENTRY BMAPISaveMail( LHANDLE                      hSession,       // Session
			   ULONG                        ulUIParam,      // UIParam
			   LPVB_MESSAGE         lpM,            // Pointer to VB Message Buffer
			   LPSAFEARRAY *        lppsaRecips,    // Pointer to VB Recipient Buffer
			   LPSAFEARRAY *        lppsaFiles,     // Pointer to VB File Attacment Buffer
			   ULONG                        flFlags,        // Flags
			   ULONG                        ulReserved,     // Reserved
			   BSTR *                       lpbstrID)       // Message ID
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIAddress
//
///////////////////////////////////////////////////////////////////////

BMAPI_ENTRY BMAPIAddress( LPULONG                       lpulRecip,       // Pointer to New Recipient Buffer (out)
			  LHANDLE                       hSession,        // Session
			  ULONG                         ulUIParam,       // UIParam
			  BSTR *                        lpbstrCaption,   // Caption string
			  ULONG                         ulEditFields,    // Number of Edit Controls
			  BSTR *                        lpbstrLabel,     // Label string
			  LPULONG                       lpulRecipients,  // Pointer to number of Recipients (in/out)
			  LPSAFEARRAY *         lppsaRecip,      // Pointer to Initial Recipients VB_RECIPIENT
			  ULONG                         ulFlags,         // Flags
			  ULONG                         ulReserved )     // Reserved
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIGetAddress
//
///////////////////////////////////////////////////////////////////////

BMAPI_ENTRY BMAPIGetAddress (ULONG                      ulRecipientData, // Pointer to recipient data
			     ULONG                      cRecipients,     // Number of recipients
							 LPSAFEARRAY *  lppsaRecips )    // VB recipient array
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIDetails
//
///////////////////////////////////////////////////////////////////////

BMAPI_ENTRY BMAPIDetails (LHANDLE                       hSession,   // Session
			  ULONG                         ulUIParam,      // UIParam
			  LPVB_RECIPIENT        lpVB,           // Pointer to VB recipient stucture
			  ULONG                         ulFlags,    // Flags
			  ULONG                         ulReserved) // Reserved

{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// BMAPIResolveName
//
///////////////////////////////////////////////////////////////////////

BMAPI_ENTRY BMAPIResolveName (LHANDLE                   hSession,     // Session
			      ULONG                     ulUIParam,    // UIParam
			      BSTR                              bstrMapiName, // Name to be resolved
			      ULONG                     ulFlags,      // Flags
			      ULONG                     ulReserved,   // Reserved
			      LPVB_RECIPIENT    lpVB)             // Pointer to VB recipient structure (out)
{
	return MAPI_E_FAILURE;
}

///////////////////////////////////////////////////////////////////////
//
// MailToProtocolHandler
//
///////////////////////////////////////////////////////////////////////

void CALLBACK MailToProtocolHandler(HWND      hwnd,
				    HINSTANCE hinst,
									LPSTR     lpszCmdLine,
									int       nCmdShow)
{
	TCHAR pszUrl[256];

	GetPostUrl(POST_URL, pszUrl, sizeof(TCHAR) * 256);
	LPTSTR pszData = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lstrlen(lpszCmdLine) + 32) * sizeof(TCHAR));

    if (pszData)
    {
	    wsprintf(pszData, "action=compose&to=%s", &lpszCmdLine[7]);
	    // Convert the extraneous '?' to '&'
	    for (LPTSTR p = pszData; *p; p++)
		    if (*p == '?')
			    *p = '&';

	    DoNavigate(pszUrl, pszData, FALSE);

	    HeapFree(GetProcessHeap(), 0, (LPVOID)pszData);
    }
}

///////////////////////////////////////////////////////////////////////
//
// OpenInboxHandler
//
///////////////////////////////////////////////////////////////////////

void CALLBACK OpenInboxHandler(HWND      hwnd,
			       HINSTANCE hinst,
							   LPSTR     lpszCmdLine,
							   int       nCmdShow)
{
	TCHAR pszUrl[256];

	GetPostUrl(INBOX_URL, pszUrl, sizeof(TCHAR) * 256);

	DoNavigate(pszUrl, "action=inbox", FALSE);
}

///////////////////////////////////////////////////////////////////////
//
// Layout of Registry Usage
//
//
// HKEY_CLASSES_ROOT\mailto
// HKEY_CLASSES_ROOT\mailto\DefaultIcon
// HKEY_CLASSES_ROOT\mailto\shell\open\command
//
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail\Protocols\mailto
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail\Protocols\mailto\DefaultIcon
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail\Protocols\mailto\shell\open\command
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail\shell\open\command
// HKEY_LOCAL_MACHINE\SOFTWARE\Clients\Mail\Hotmail\backup
//
///////////////////////////////////////////////////////////////////////

#define MAILTO          TEXT("mailto")
#define PROTOCOLS       TEXT("Protocols")
#define DEFAULTICON     TEXT("DefaultIcon")
#define COMMAND         TEXT("shell\\open\\command")
#define MAIL            TEXT("SOFTWARE\\Clients\\Mail")
#define POSTURL         TEXT("posturl")
#define BACKUP          TEXT("backup")


///////////////////////////////////////////////////////////////////////
//
// SetRegStringValue
//
///////////////////////////////////////////////////////////////////////

static LONG SetRegStringValue(HKEY hkKey, LPTSTR lpszKey, LPTSTR lpszValue, LPTSTR lpszPath, DWORD dwType)
{
    if (!(dwType == REG_SZ) && !(dwType == REG_EXPAND_SZ))
        return ERROR_INVALID_PARAMETER;

	if (lpszPath)
	{
		TCHAR szValue[MAX_PATH + 32];
		wsprintf(szValue, lpszValue, lpszPath);
		return RegSetValueEx(hkKey, lpszKey, 0, dwType, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR));
	}

	return RegSetValueEx(hkKey, lpszKey, 0, dwType, (LPBYTE)lpszValue, (lstrlen(lpszValue) + 1) * sizeof(TCHAR));
}

///////////////////////////////////////////////////////////////////////
//
// CreateMailToEntries
//
///////////////////////////////////////////////////////////////////////

static LONG CreateMailToEntries(HKEY hkKey, TCHAR* lpszPath, BOOL fRegExpandSz)
{
	LONG err;
	HKEY hkMailToProt;
	HKEY hkDefaultIcon;
	HKEY hkCommand;

	err = RegCreateKey(hkKey, MAILTO, &hkMailToProt);
	if (err == ERROR_SUCCESS)
	{
		err = SetRegStringValue(hkMailToProt, NULL, TEXT("URL:MailTo Protocol"), NULL, REG_SZ);
		if (err == ERROR_SUCCESS)
		{
			DWORD editFlags = 2; 
			err = RegSetValueEx(hkMailToProt, TEXT("EditFlags"), 0, REG_BINARY, (LPBYTE)&editFlags, sizeof(DWORD));
		}
		if (err == ERROR_SUCCESS)
			err = SetRegStringValue(hkMailToProt, TEXT("URL Protocol"), TEXT(""), NULL, REG_SZ);

		if (err == ERROR_SUCCESS)
			err = RegCreateKey(hkMailToProt, DEFAULTICON, &hkDefaultIcon);
		if (err == ERROR_SUCCESS)
		{
			err = SetRegStringValue(hkDefaultIcon, NULL, "%s,1", lpszPath, fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
			RegCloseKey(hkDefaultIcon);
		}

		if (err == ERROR_SUCCESS)
			err = RegCreateKey(hkMailToProt, COMMAND, &hkCommand);
		if (err == ERROR_SUCCESS)
		{
            DWORD dwNTVer = 0;
            // APPCOMPAT: Only the rundll32 on NT5 can handle double quotes around the path
            // Lucky on Win9x and NT4 the epand sz path will never be a long file name and the old
            // rundll32 works, but we cannot have double quotes
            if (FRunningOnNTEx(&dwNTVer) && (dwNTVer >= 5))
            {
                err = SetRegStringValue(hkCommand, NULL, "rundll32.exe \"%s\",MailToProtocolHandler %%1", lpszPath, fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
            }
            else
            {
                err = SetRegStringValue(hkCommand, NULL, "rundll32.exe %s,MailToProtocolHandler %%1", lpszPath, fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
            }
			RegCloseKey(hkCommand);
		}
		RegCloseKey(hkMailToProt);
	}
	return err;
}

///////////////////////////////////////////////////////////////////////
//
// DoAddService
//
///////////////////////////////////////////////////////////////////////

STDAPI DoAddService(LPSTR lpszService, LPSTR lpszPostURL)
{
	LONG err;
    TCHAR szLongPath[MAX_PATH];
    TCHAR szPath[MAX_PATH];
	HKEY hkClientsMail;
	HKEY hkService;
	HKEY hkProtocols;
	HKEY hkCommand;
	HKEY hkBackup;
    BOOL fExistingMailClient = FALSE;
    BOOL fRegExpandSz = FALSE;

    GetModuleFileName(g_hInstMAPI, szLongPath, MAX_PATH);  // get path to this DLL
    GetShortPathName(szLongPath, szPath, MAX_PATH);

	// First setup the info for the protocol in clients section
	err = RegCreateKey(HKEY_LOCAL_MACHINE, MAIL, &hkClientsMail);
	if (err == ERROR_SUCCESS)
	{
        fRegExpandSz = MyPathUnExpandEnvStrings(szPath, szLongPath, ARRAYSIZE(szLongPath));
        if (fRegExpandSz)
            lstrcpy(szPath, szLongPath);
		err = RegCreateKey(hkClientsMail, lpszService, &hkService);
		if (err == ERROR_SUCCESS)
		{
			err = SetRegStringValue(hkService, NULL, lpszService, NULL, REG_SZ);
			if (err == ERROR_SUCCESS)
            {
                err = SetRegStringValue(hkService, TEXT("DLLPath"), szPath, NULL,
                                          fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
            }
			if (err == ERROR_SUCCESS && lpszPostURL && lstrlen(lpszPostURL))
				err = SetRegStringValue(hkService, TEXT("posturl"), lpszPostURL, NULL, REG_SZ);
			if (err == ERROR_SUCCESS)
				err = RegCreateKey(hkService, PROTOCOLS, &hkProtocols);
			if (err == ERROR_SUCCESS)
			{
				err = CreateMailToEntries(hkProtocols, szPath, fRegExpandSz);
				RegCloseKey(hkProtocols);
			}
			if (err == ERROR_SUCCESS)
				err = RegCreateKey(hkService, COMMAND, &hkCommand);
			if (err == ERROR_SUCCESS)
			{
                DWORD dwNTVer = 0;
                // APPCOMPAT: Only the rundll32 on NT5 can handle double quotes around the path
                // Lucky on Win9x and NT4 the epand sz path will never be a long file name and the old
                // rundll32 works, but we cannot have double quotes
                if (FRunningOnNTEx(&dwNTVer) && (dwNTVer >= 5))
                {
				    err = SetRegStringValue(hkCommand, NULL, "rundll32.exe \"%s\",OpenInboxHandler", szPath,
                                            fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
                }
                else
                {
				    err = SetRegStringValue(hkCommand, NULL, "rundll32.exe %s,OpenInboxHandler", szPath,
                                            fRegExpandSz?REG_EXPAND_SZ:REG_SZ);
                }
				RegCloseKey(hkCommand);
			}
			if (err == ERROR_SUCCESS)
				err = RegCreateKey(hkService, BACKUP, &hkBackup);
			if (err == ERROR_SUCCESS)
			{
				TCHAR szValue[MAX_PATH];
				DWORD size;
				DWORD type;
				HKEY hkDefaultIcon;
				HKEY hkCommand;

				err = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("mailto\\DefaultIcon"), &hkDefaultIcon);
				if (err == ERROR_SUCCESS)
				{
					size = sizeof(TCHAR) * MAX_PATH;
					err = RegQueryValueEx(hkDefaultIcon, NULL, 0, &type, (LPBYTE)szValue, &size);
					if (err == ERROR_SUCCESS)
						err = RegSetValueEx(hkBackup, DEFAULTICON, 0, type, (LPBYTE)szValue, size);
					RegCloseKey(hkDefaultIcon);
				}

				err = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("mailto\\shell\\open\\command"), &hkCommand);
				if (err == ERROR_SUCCESS)
				{
					size = sizeof(TCHAR) * MAX_PATH;
					err = RegQueryValueEx(hkCommand, NULL, 0, &type, (LPBYTE)szValue, &size);
					if (err == ERROR_SUCCESS)
                    {
                        fExistingMailClient = TRUE;
						err = RegSetValueEx(hkBackup, TEXT("command"), 0, type, (LPBYTE)szValue, size);
                    }
					RegCloseKey(hkCommand);
				}

				size = sizeof(TCHAR) * MAX_PATH;
				err = RegQueryValueEx(hkClientsMail, NULL, 0, &type, (LPBYTE)szValue, &size);
				if (err == ERROR_SUCCESS)
					err = RegSetValueEx(hkBackup, TEXT("mail"), 0, type, (LPBYTE)szValue, size);

				RegCloseKey(hkBackup);
			}
		    RegCloseKey(hkService);
		}
		if (err == ERROR_SUCCESS && !fExistingMailClient && !IsNtSetupRunning())
			SetRegStringValue(hkClientsMail, NULL, lpszService, NULL, REG_SZ);
	    RegCloseKey(hkClientsMail);
	}
	if (err == ERROR_SUCCESS && !fExistingMailClient && !IsNtSetupRunning())
		err = CreateMailToEntries(HKEY_CLASSES_ROOT, szPath, fRegExpandSz);

    //
    // REVIEW Backup fails sometimes. Need to clean up registry changes and 
    // probably remove all backup registry entirely.
    // For now just safe to return S_OK
    // 
#if 0
    if (err != ERROR_SUCCESS)
	return HRESULT_FROM_WIN32(err);
#else
    return S_OK;
#endif
}

///////////////////////////////////////////////////////////////////////
//
// DeleteKeyAndSubKeys
//
///////////////////////////////////////////////////////////////////////

static LONG DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    int   x;

	l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
	if (l != ERROR_SUCCESS) 
		return l;

    // loop through all subkeys, blowing them away.
    //
    x = 0;
    while (l == ERROR_SUCCESS)
	{
	dwTmpSize = MAX_PATH;
	l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
	if (l != ERROR_SUCCESS)
	    break;

	l = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
	RegCloseKey(hk);
    return RegDeleteKey(hkIn, pszSubKey);
}

///////////////////////////////////////////////////////////////////////
//
// DoRemoveService
//
///////////////////////////////////////////////////////////////////////

STDAPI DoRemoveService(LPSTR lpszService)
{
	TCHAR szValue[MAX_PATH];
	DWORD size;
	LONG err;
	DWORD type;
	HKEY hkDefaultIcon;
	HKEY hkCommand;
	HKEY hkBackup;
	HKEY hkService;
	HKEY hkClientsMail;

    //
	// Restore the previous values if HMMAPI is the current provider
    //
	err = RegOpenKey(HKEY_LOCAL_MACHINE, MAIL, &hkClientsMail);
	if (err == ERROR_SUCCESS)
	{
        //
        // Find the name of the current provider
        //
        TCHAR szCurrent[MAX_PATH];
        DWORD cb = sizeof(szCurrent);
        err = RegQueryValueEx(hkClientsMail, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb);
        if (err == ERROR_SUCCESS)
        {
            //
            // Check if it is HMMAPI
            //
            if (StrCmp(szCurrent, lpszService) == 0)
            {
		        err = RegOpenKey(hkClientsMail, lpszService, &hkService);
		        if (err == ERROR_SUCCESS)
		        {
			        err = RegOpenKey(hkService, BACKUP, &hkBackup);
			        if (err == ERROR_SUCCESS)
			        {
				        err = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("mailto\\DefaultIcon"), &hkDefaultIcon);
				        if (err == ERROR_SUCCESS)
				        {
                            size = sizeof(TCHAR) * MAX_PATH;
					        err = RegQueryValueEx(hkBackup, DEFAULTICON, 0, &type, (LPBYTE)szValue, &size);
					        if (err == ERROR_SUCCESS)
						        err = RegSetValueEx(hkDefaultIcon, NULL, 0, type, (LPBYTE)szValue, size);
					        RegCloseKey(hkDefaultIcon);
				        }

				        err = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("mailto\\shell\\open\\command"), &hkCommand);
				        if (err == ERROR_SUCCESS)
				        {
					        size = sizeof(TCHAR) * MAX_PATH;
					        err = RegQueryValueEx(hkBackup, TEXT("command"), 0, &type, (LPBYTE)szValue, &size);
					        if (err == ERROR_SUCCESS)
						        err = RegSetValueEx(hkCommand, NULL, 0, type, (LPBYTE)szValue, size);
					        RegCloseKey(hkCommand);
				        }

				        size = sizeof(TCHAR) * MAX_PATH;
				        err = RegQueryValueEx(hkBackup, TEXT("mail"), 0, &type, (LPBYTE)szValue, &size);
				        if (err == ERROR_SUCCESS)
					        err = RegSetValueEx(hkClientsMail, NULL, 0, type, (LPBYTE)szValue, size);

				        RegCloseKey(hkBackup);
			        }
			        RegCloseKey(hkService);
		        }
            }
            err = DeleteKeyAndSubKeys(hkClientsMail, lpszService);
        }
        RegCloseKey(hkClientsMail);
	}

    //
    // REVIEW Backup fails sometimes. Need to clean up registry changes and 
    // probably remove all backup registry entirely.
    // For now just safe to return S_OK
    // 
#if 0
    if (err != ERROR_SUCCESS)
	return HRESULT_FROM_WIN32(err);
#else
    return S_OK;
#endif
}

///////////////////////////////////////////////////////////////////////
//
// AddService
//
///////////////////////////////////////////////////////////////////////

void CALLBACK AddService(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
	LPSTR lpszService = lpszCmdLine;
	LPSTR lpszPostUrl = NULL;

	if (*lpszService == '"')
	{
		lpszService++;
		lpszPostUrl = StrChr(lpszService, '"');
		if (lpszPostUrl)
		{
			*lpszPostUrl = 0;
			lpszPostUrl++;
			while (*lpszPostUrl && *lpszPostUrl == ' ')
				lpszPostUrl++;
			if (*lpszPostUrl == 0)
				lpszPostUrl = NULL;
		}
	}
	else
	{
		lpszPostUrl = StrChr(lpszService, ' ');
		if (lpszPostUrl)
		{
			*lpszPostUrl = 0;
			lpszPostUrl++;
		}
	}
	DoAddService(lpszService, lpszPostUrl);
}

///////////////////////////////////////////////////////////////////////
//
// RemoveService
//
///////////////////////////////////////////////////////////////////////

void CALLBACK RemoveService(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
	DWORD dwLen = (lpszCmdLine) ? lstrlen(lpszCmdLine) : 0;

	if (dwLen)
	{
		if (*lpszCmdLine == '"' && lpszCmdLine[dwLen - 1] == '"')
		{
			lpszCmdLine[dwLen - 1] = 0;
			lpszCmdLine++;
		}
		DoRemoveService(lpszCmdLine);
	}
}

///////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
///////////////////////////////////////////////////////////////////////

STDAPI DllRegisterServer(void)
{
    return DoAddService(TEXT("Hotmail"), NULL);
}

///////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
///////////////////////////////////////////////////////////////////////

STDAPI DllUnregisterServer(void)
{
    return DoRemoveService(TEXT("Hotmail"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn16\stdafx.h ===
//
// stdafx.h
//

#define NOWINDOWSX

#include <windows.h>
#include <winerror.h>

//
// The definitions below where included to make win9x port build in the NT tree
//

typedef DWORD HKEY;

typedef unsigned short WCHAR;
typedef const WCHAR FAR *LPCWSTR;

typedef int INT_PTR;
typedef unsigned int UINT_PTR;

#define TEXT(a) a


typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)

#define IN

//#define WINAPI      _loadds _far _pascal

extern "C" LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
extern "C" LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
                            LPBYTE, LONG FAR *);
extern "C" LONG    WINAPI RegCloseKey(HKEY);


#define REG_SZ                      ( 1 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn16\nconn16.h ===
//
// NConn16.h
//

#ifndef __NCONN16_H__
#define __NCONN16_H__


#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

typedef DWORD DEVNODE, DEVINST;


#ifndef WIN32
	typedef LONG HRESULT;
	#define S_OK                               ((HRESULT)0x00000000L)
	#define S_FALSE                            ((HRESULT)0x00000001L)
	//#define E_FAIL                             ((HRESULT)0x80004005L)
	//#define E_POINTER                          ((HRESULT)0x80004003L)
	//#define E_INVALIDARG                       ((HRESULT)0x80000003L)
#else
	#define VCP_ERROR                          300
	enum _ERR_VCP
	{
		ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
		ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
		ERR_VCP_NOMEM,                          // Insufficient memory to comply
		ERR_VCP_QUEUEFULL,                      // Trying to add a node to a maxed-out queue
		ERR_VCP_NOVHSTR,                        // No string handles available
		ERR_VCP_OVERFLOW,                       // Reference count would overflow
		ERR_VCP_BADARG,                         // Invalid argument to function
		ERR_VCP_UNINIT,                         // String library not initialized
		ERR_VCP_NOTFOUND ,                      // String not found in string table
		ERR_VCP_BUSY,                           // Can't do that now
		ERR_VCP_INTERRUPTED,                    // User interrupted operation
		ERR_VCP_BADDEST,                        // Invalid destination directory
		ERR_VCP_SKIPPED,                        // User skipped operation
		ERR_VCP_IO,                             // Hardware error encountered
		ERR_VCP_LOCKED,                         // List is locked
		ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
		ERR_VCP_CHANGEMODE,                     //
		ERR_VCP_LDDINVALID,                     // Logical Disk ID Invalid.
		ERR_VCP_LDDFIND,                        // Logical Disk ID not found.
		ERR_VCP_LDDUNINIT,                      // Logical Disk Descriptor Uninitialized.
		ERR_VCP_LDDPATH_INVALID,
		ERR_VCP_NOEXPANSION,                    // Failed to load expansion dll
		ERR_VCP_NOTOPEN,                        // Copy session not open
		ERR_VCP_NO_DIGITAL_SIGNATURE_CATALOG,   // Catalog is not digitally signed
		ERR_VCP_NO_DIGITAL_SIGNATURE_FILE,      // A file is not digitally signed
	};

	// Return error codes for NDI_ messages.
	#define NDI_ERROR           (1200)  
	enum _ERR_NET_DEVICE_INSTALL
	{
		ERR_NDI_ERROR               = NDI_ERROR,  // generic failure
		ERR_NDI_INVALID_HNDI,
		ERR_NDI_INVALID_DEVICE_INFO,
		ERR_NDI_INVALID_DRIVER_PROC,
		ERR_NDI_LOW_MEM,
		ERR_NDI_REG_API,
		ERR_NDI_NOTBOUND,
		ERR_NDI_NO_MATCH,
		ERR_NDI_INVALID_NETCLASS,
		ERR_NDI_INSTANCE_ONCE,
		ERR_NDI_CANCEL,
		ERR_NDI_NO_DEFAULT,
	};
#endif


//
// Exported functions
//

EXTERN_C BOOL WINAPI RestartWindowsQuickly16(VOID);
EXTERN_C DWORD WINAPI CallClassInstaller16(HWND hwndParent, LPCSTR lpszClassName, LPCSTR lpszDeviceID);
EXTERN_C DWORD WINAPI InstallAdapter(HWND hwndParent, LPCSTR lpszClassName, LPCSTR szDeviceID, LPCSTR szDriverPath);
EXTERN_C HRESULT WINAPI FindClassDev16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszDeviceID);
EXTERN_C HRESULT WINAPI LookupDevNode16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszEnumKey, DEVNODE FAR* pDevNode, DWORD FAR* pdwFreePointer);
EXTERN_C HRESULT WINAPI FreeDevNode16(DWORD dwFreePointer);
EXTERN_C HRESULT WINAPI IcsUninstall16(void);



//
// CallClassInstaller16 (a.k.a. InstallComponent) return codes
//

#define ICERR_ERROR					0x80000000 // High bit indicates error condition
#define ICERR_DI_ERROR				0xC0000000 // These bits are set on DI errors

// Custom status return values (no error)
#define ICERR_OK					0x00000000
#define ICERR_NEED_RESTART			0x00000001
#define ICERR_NEED_REBOOT			0x00000002

// Custom error return values
#define ICERR_INVALID_PARAMETER		0x80000001


#endif // !__NCONN16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\debug.cpp ===
#include "..\shared\debug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn16\i386\thunk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Mon May 21 15:57:59 2001

;Command Line: thunk.exe -t thk NCXP.thk -o Thunk.asm 

	TITLE	$Thunk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	043a5h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public FindClassDev16@12
FindClassDev16@12:
	mov	cl,3
	jmp	IIFindClassDev16@12
public CallClassInstaller16@12
CallClassInstaller16@12:
	mov	cl,4
; FindClassDev16(16) = FindClassDev16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszClassName
; dword ptr [ebp+16]:  szDeviceID
;
public IIFindClassDev16@12
IIFindClassDev16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public LookupDevNode16@20
LookupDevNode16@20:
	mov	cl,2
; LookupDevNode16(16) = LookupDevNode16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  pszClass
; dword ptr [ebp+16]:  pszEnumKey
; dword ptr [ebp+20]:  pDevNode
; dword ptr [ebp+24]:  pdwFreePointer
;
public IILookupDevNode16@20
IILookupDevNode16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	leave
	retn	20





;
public FreeDevNode16@4
FreeDevNode16@4:
	mov	cl,1
; FreeDevNode16(16) = FreeDevNode16(32) {}
;
; dword ptr [ebp+8]:  dwFreePointer
;
public IIFreeDevNode16@4
IIFreeDevNode16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwFreePointer: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public IcsUninstall16@0
IcsUninstall16@0:
	mov	cl,0
; IcsUninstall16(16) = IcsUninstall16(32) {}
;
;
public IIIcsUninstall16@0
IIIcsUninstall16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef IcsUninstall16:far16
externDef FreeDevNode16:far16
externDef LookupDevNode16:far16
externDef FindClassDev16:far16
externDef CallClassInstaller16:far16


FT_thkTargetTable label word
	dw	offset IcsUninstall16
	dw	   seg IcsUninstall16
	dw	offset FreeDevNode16
	dw	   seg FreeDevNode16
	dw	offset LookupDevNode16
	dw	   seg LookupDevNode16
	dw	offset FindClassDev16
	dw	   seg FindClassDev16
	dw	offset CallClassInstaller16
	dw	   seg CallClassInstaller16




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	043a5h	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn16\theapp.cpp ===
//
// TheApp.cpp
//
//		16-bit code to install network components such as TCP/IP.
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet, largely from Internet Connection Wizard
//		 9/29/1999  KenSh     Adapterd for Home Networking Wizard
//

#include "stdafx.h"
#include <string.h>
#include <regstr.h>
#include "NConn16.h"
#include "strstri.h"

extern "C"
{
// Define missing decs so it builds.
typedef HKEY*         LPHKEY;
typedef const BYTE*   LPCBYTE;
#define WINCAPI
// missing

	#include <setupx.h>
	#include <netdi.h>
}

#ifndef _countof
#define _countof(ar) (sizeof(ar) / sizeof((ar)[0]))
#endif


extern "C" BOOL FAR PASCAL thk_ThunkConnect16(LPSTR pszDll16,
                                              LPSTR pszDll32,
                                              WORD  hInst,
                                              DWORD dwReason);

//
// SetupX function prototypes
//
typedef RETERR (WINAPI PASCAL FAR * PROC_DiOpenDevRegKey)(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);
typedef DWORD (WINAPI FAR * PROC_SURegSetValueEx)(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
typedef RETERR (WINAPI FAR * PROC_DiCreateDeviceInfo)(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // ISSUE-2002/01/16-roelfc: -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent
typedef RETERR (WINAPI FAR * PROC_DiDestroyDeviceInfoList)(LPDEVICE_INFO lpdi);
typedef RETERR (WINAPI FAR * PROC_DiCallClassInstaller)(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
typedef DWORD (WINAPI FAR * PROC_SURegCloseKey)(HKEY hKey);
typedef RETERR (WINAPI FAR * PROC_DiGetClassDevs)(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options
typedef RETERR (WINAPI FAR * PROC_DiSelectDevice)( LPDEVICE_INFO lpdi );
typedef RETERR (WINAPI FAR * PROC_DiBuildCompatDrvList)(LPDEVICE_INFO lpdi);
typedef RETERR (WINAPI FAR * PASCAL PROC_DiCreateDevRegKey)(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
typedef RETERR (WINAPI FAR * PASCAL PROC_DiDeleteDevRegKey)(LPDEVICE_INFO lpdi, int  iFlags);

PROC_DiOpenDevRegKey			_pfnDiOpenDevRegKey;
PROC_SURegSetValueEx			_pfnSURegSetValueEx;
PROC_DiCreateDeviceInfo			_pfnDiCreateDeviceInfo;
PROC_DiDestroyDeviceInfoList	_pfnDiDestroyDeviceInfoList;
PROC_DiCallClassInstaller		_pfnDiCallClassInstaller;
PROC_SURegCloseKey				_pfnSURegCloseKey;
PROC_DiGetClassDevs				_pfnDiGetClassDevs;
PROC_DiSelectDevice				_pfnDiSelectDevice;
PROC_DiBuildCompatDrvList		_pfnDiBuildCompatDrvList;
PROC_DiCreateDevRegKey			_pfnDiCreateDevRegKey;
PROC_DiDeleteDevRegKey			_pfnDiDeleteDevRegKey;


int g_cSetupxInit = 0;
HINSTANCE g_hInstSetupx = NULL;

BOOL InitSetupx()
{
	if (g_hInstSetupx == NULL)
	{
		g_hInstSetupx = LoadLibrary("setupx.dll");
		if (g_hInstSetupx < (HINSTANCE)HINSTANCE_ERROR)
			return FALSE;

		_pfnDiOpenDevRegKey = (PROC_DiOpenDevRegKey)GetProcAddress(g_hInstSetupx, "DiOpenDevRegKey");
		_pfnSURegSetValueEx = (PROC_SURegSetValueEx)GetProcAddress(g_hInstSetupx, "SURegSetValueEx");
		_pfnDiCreateDeviceInfo = (PROC_DiCreateDeviceInfo)GetProcAddress(g_hInstSetupx, "DiCreateDeviceInfo");
		_pfnDiDestroyDeviceInfoList = (PROC_DiDestroyDeviceInfoList)GetProcAddress(g_hInstSetupx, "DiDestroyDeviceInfoList");
		_pfnDiCallClassInstaller = (PROC_DiCallClassInstaller)GetProcAddress(g_hInstSetupx, "DiCallClassInstaller");
		_pfnSURegCloseKey = (PROC_SURegCloseKey)GetProcAddress(g_hInstSetupx, "SURegCloseKey");
		_pfnDiGetClassDevs = (PROC_DiGetClassDevs)GetProcAddress(g_hInstSetupx, "DiGetClassDevs");
		_pfnDiSelectDevice = (PROC_DiSelectDevice)GetProcAddress(g_hInstSetupx, "DiSelectDevice");
		_pfnDiBuildCompatDrvList = (PROC_DiBuildCompatDrvList)GetProcAddress(g_hInstSetupx, "DiBuildCompatDrvList");
		_pfnDiCreateDevRegKey = (PROC_DiCreateDevRegKey)GetProcAddress(g_hInstSetupx, "DiCreateDevRegKey");
		_pfnDiDeleteDevRegKey = (PROC_DiDeleteDevRegKey)GetProcAddress(g_hInstSetupx, "DiDeleteDevRegKey");
	}

	g_cSetupxInit++;
	return TRUE;
}

void UninitSetupx()
{
	if (g_cSetupxInit > 0)
		g_cSetupxInit--;

	if (g_cSetupxInit == 0)
	{
		if (g_hInstSetupx != NULL)
		{
			FreeLibrary(g_hInstSetupx);
			g_hInstSetupx = NULL;
		}
	}
}

extern "C" int FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpszCmdLine)
{
	if (wHeapSize != 0)
	{
	    // UnlockData is no longer #defined to UnlockSegment(-1) in windows.h,
	    // so do it manually here:
	    //
		//UnlockData(0);
	    UnlockSegment(-1);
	}

	return 1;
}

extern "C" BOOL FAR PASCAL __export DllEntryPoint(DWORD dwReason, WORD hInstance, WORD wDS, WORD wHeapSize, DWORD dwReserved1, WORD wReserved2)
{
	if (!thk_ThunkConnect16(
			"NCXP16.DLL", 
			"NCXP32.DLL", 
			hInstance, dwReason))
	{
		return FALSE;
	}

	return TRUE;
}

extern "C" int CALLBACK WEP(int nExitType)
{
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#define ASSERT(x)

// Local function declarations
DWORD CallClassInstaller(HWND hwndParent, LPCSTR lpszClassName, LPCSTR lpszDeviceID);
DWORD BindProtocolToAdapters(HWND hwndParent, LPCSTR lpszClassName, LPCSTR lpszDeviceID);


//////////////////////////////////////////////////////////////////////////////
// String constants
// TODO: clean these up... most of them aren't used any more

// Device Manager class names
const char szClassNetCard[] = 		"Net";
const char szClassNetClient[] = 	"NetClient";
const char szClassNetProtocol[] = 	"NetTrans";
const char szClassModem[] = 		"Modem";

// Device ID string constants
const char szMSTCPIP_ID[] = 		"MSTCP";
const char szPPPMAC_ID[] =			"*PNP8387";
const char szVREDIR_ID[] = 			"VREDIR";
const char szNWREDIR_ID[] = 		"NWREDIR";
const char szIPX_ID[] = 			"NWLINK";
const char szNETBEUI_ID[] = 		"NETBEUI";

// Registry string constants
const char szRegValSlowNet[] = 		"SLOWNET";
const char szRegKeyNdi[] = 			"Ndi";
const char szRegValDeviceID[] = 	"DeviceID";
const char szRegKeyBindings[] =		"Bindings";
const char szRegPathOptComponents[]=REGSTR_PATH_SETUP REGSTR_KEY_SETUP "\\OptionalComponents";
const char szRegValInstalled[] =	"Installed";
const char szRegPathNetwork[] =		"Enum\\Network";
const char szRegPathTemp[] = 		"\\Temp";
const char szRegValCompatibleIDs[]=	REGSTR_VAL_COMPATIBLEIDS;
const char szRegValDeviceType[] =	REGSTR_VAL_DEVTYPE;
const char szRegValConfigFlags[] =	REGSTR_VAL_CONFIGFLAGS;
const char szRegPathPlusSetup[] =   "Software\\Microsoft\\Plus!\\Setup";
const char szRegValSourcePath[]	=   "SourcePath";
const char szRegValHardwareID[] =   "HardwareID";

// component string constants
const char szCompRNA[] =			"RNA";
const char szCompMail[] =			"MAPI";
const char szCompMSN[] =			"MSNetwork";
const char szCompMSN105[] =			"MSNetwork105";
const char szCompInetMail[] =		"InternetMail";
const char szINF[] =				"INF";
const char szSection[] =			"Section";

// INF string constants
const char szValSignature[] =  		"$CHICAGO$";
const char szKeySignature[] = 		"signature";
const char szSectVersion[] =		"version";

// other strings
const char szNull[] = 				"";
const char sz1[] =					"1";
const char szSlash[] =				"\\";



//////////////////////////////////////////////////////////////////////////////


// CreateTempDevRegKey
//
//		Creates a temporary registry key for the device installer.
//
// History:
//
//		 2/02/1999  KenSh    Borrowed from ICW, which borrowed it from net setup
//
RETERR CreateTempDevRegKey(LPDEVICE_INFO lpdi,LPHKEY lphk)
{
	lpdi->hRegKey = HKEY_LOCAL_MACHINE;
	lstrcpy(lpdi->szRegSubkey, szRegPathNetwork);
	lstrcat(lpdi->szRegSubkey, szSlash);
	lstrcat(lpdi->szRegSubkey, lpdi->szClassName);
	lstrcat(lpdi->szRegSubkey, szRegPathTemp);

	InitSetupx();
	RETERR err = (*_pfnDiCreateDevRegKey)(lpdi, lphk, NULL, NULL, DIREG_DEV);
	UninitSetupx();

	return err;
}


// CallClassInstaller
//
//		Calls DiCallClassInstaller for the specified class to install
//		the specified device ID
//
//		Returns ICERR_xxx return value, defined in NetSetup.h
//
// Parameters:
//
//		hwndParent - parent window handle
//		lpszClassName - name of device class (e.g. "NetTrans" or "Net")
//		lpszDeviceID - unique device ID to install (e.g. "MSTCP" or "PCI\VEN_10b7&DEV_5950"
//
// History:
//
//		 2/02/1999  KenSh    Borrowed from ICW, changed return codes for JetNet
//		 3/18/1999  KenSh    Cleaned up
//
extern "C" DWORD WINAPI __export CallClassInstaller16(HWND hwndParent, LPCSTR lpszClassName, LPCSTR lpszDeviceID)
{
	RETERR err;
	DWORD dwResult = ICERR_OK;
	LPDEVICE_INFO lpdi;
	HKEY hKeyTmp;
	LONG uErr;

	ASSERT(lpszClassName != NULL);
	ASSERT(lpszDeviceID != NULL);

	if (!InitSetupx())
		return ICERR_DI_ERROR;

	// allocate a DEVICE_INFO struct
	err = (*_pfnDiCreateDeviceInfo)(&lpdi, NULL, 0, NULL, NULL, lpszClassName, hwndParent);

	ASSERT(err == OK);
	if (err != OK)
	{
		lpdi = NULL;
		goto exit;
	}

	// since the device manager APIs are not very good, to communicate the
	// device ID to it we have to create a temporary registry key and
	// store the device ID there.  This code borrowed from net setup
	// which has to do the same thing (fill out an LPDEVICE_INFO based
	// on a device ID)
	err = CreateTempDevRegKey(lpdi, &hKeyTmp);
	ASSERT (err == OK);
	if (err != OK)
		goto exit;

	// set the device ID in the registry
	uErr = RegSetValueEx(hKeyTmp, szRegValCompatibleIDs,
				0, REG_SZ, (LPBYTE)lpszDeviceID, lstrlen(lpszDeviceID)+1);
	ASSERT(uErr == ERROR_SUCCESS);

	// now call device mgr API to add driver node lists and fill out structure,
	// it will use the device ID we stuffed in registry. 
	err = (*_pfnDiBuildCompatDrvList)(lpdi);
	ASSERT(err == OK);

	RegCloseKey(hKeyTmp);

	// need to delete temp key, set handle to null, set subkey name to
	// null or else net setup thinks this device already exists and
	// zany hijinks ensue
	(*_pfnDiDeleteDevRegKey)(lpdi, DIREG_DEV);
	lpdi->hRegKey = NULL;
	lstrcpy(lpdi->szRegSubkey, szNull);

	if (err == OK)
	{
	 	lpdi->lpSelectedDriver = lpdi->lpCompatDrvList;
		ASSERT(lpdi->lpSelectedDriver);

		err = (*_pfnDiCallClassInstaller)(DIF_INSTALLDEVICE, lpdi);
		ASSERT(err == OK);

		if (err == OK)
		{
			// if we need to reboot, set a special return code NEED_RESTART
			// (which also implies success)
			if (lpdi->Flags & DI_NEEDREBOOT)
			{
				// REVIEW: does this need to reboot, or is restart sufficient?
//				err = NEED_RESTART;
				dwResult = ICERR_NEED_RESTART;
			}
		}
	}

exit:
	if (lpdi != NULL)
		(*_pfnDiDestroyDeviceInfoList)(lpdi);

	if (err != OK)
		dwResult = ICERR_DI_ERROR | (DWORD)err;

	UninitSetupx();
	return dwResult;
}

extern "C" HRESULT WINAPI __export FindClassDev16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszDeviceID)
{
    DWORD hr = S_FALSE;
    LPDEVICE_INFO lpdi;
    RETERR err;

    if (!InitSetupx())
        return E_FAIL;

    if (OK != (err = (*_pfnDiGetClassDevs)(&lpdi, pszClass, NULL, DIGCF_PRESENT)))
    {
        UninitSetupx();
        return E_FAIL;
    }

    // This is 16-bit code, so these pnp ids are ANSI only
    //
    LPSTR pszAlternateDeviceID = new char[lstrlen(pszDeviceID) + 1];
    if (pszAlternateDeviceID)
    {
        lstrcpy(pszAlternateDeviceID, pszDeviceID);

        LPCSTR szSubsysString = "SUBSYS_";
        const int nSubsysIDLength = 8;
        LPSTR pszSubsys = strstri(pszAlternateDeviceID, szSubsysString);
        if(NULL != pszSubsys)
        {
            pszSubsys += _countof("SUBSYS_") - 1;
            if(nSubsysIDLength <= lstrlen(pszSubsys)) 
            {
                for(int i = 0; i < nSubsysIDLength; i++)
                {
                    pszSubsys[i] = '0';
                }
            }
        }

        for (LPDEVICE_INFO lpdiCur = lpdi; lpdiCur != NULL; lpdiCur = lpdiCur->lpNextDi)
        {
            char szBuf[1024];
    //        wsprintf(szBuf, "System\\CurrentControlSet\\Services\\Class\\%s\\%04d", pszClass, (int)lpdiCur->dnDevnode);
    //        MessageBox(NULL, szBuf, "RegKey", MB_OK);

            HKEY hKey;
            if (OK == (*_pfnDiOpenDevRegKey)(lpdiCur, &hKey, DIREG_DEV))
            {
                static const LPCSTR c_rgRegEntries[] = { "HardwareID", "CompatibleIDs" };

                for (int i = 0; i < _countof(c_rgRegEntries); i++)
                {
                    LONG cbBuf = sizeof(szBuf);
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_rgRegEntries[i], NULL, NULL, (LPBYTE)szBuf, &cbBuf))
                    {
    //                    char szBuf2[1600];
    //                    wsprintf(szBuf2, "Looking for: %s\n\n%s", pszDeviceID, szBuf);
    //                    MessageBox(NULL, szBuf2, c_rgRegEntries[i], MB_OK);

                        // aslo check with SUBSYS 00000000 for bug 124967
                        if (NULL != strstri(szBuf, pszDeviceID) || NULL != strstri(szBuf, pszAlternateDeviceID))
                        {
                            hr = S_OK;
                            break;
                        }
                    }
                }
                RegCloseKey(hKey);
            }

            if (hr == S_OK)
                break;
        }

        delete [] pszAlternateDeviceID;
    }
    
    (*_pfnDiDestroyDeviceInfoList)(lpdi);

    UninitSetupx();
    return hr;
}

extern "C" HRESULT WINAPI __export LookupDevNode16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszEnumKey, DEVNODE FAR* pDevNode, DWORD FAR* pdwFreePointer)
{
	DWORD hr = S_FALSE;
	LPDEVICE_INFO lpdi;
	RETERR err;

//	MessageBox(hwndParent, "LookupDevNode16", "Debug", MB_ICONINFORMATION);

	if (pDevNode == NULL || pdwFreePointer == NULL)
	{
//		MessageBox(hwndParent, "Returning failure 0", "Debug", 0);
		return E_POINTER;
	}

	*pDevNode = 0;
	*pdwFreePointer = 0;

	if (!InitSetupx())
	{
//		MessageBox(hwndParent, "Returning failure 1", "Debug", 0);
		return E_FAIL;
	}

	if (OK != (err = (*_pfnDiGetClassDevs)(&lpdi, pszClass, NULL, DIGCF_PRESENT)))
	{
//		MessageBox(hwndParent, "Returning failure 2", "Debug", 0);
		UninitSetupx();
		return E_FAIL;
	}

	for (LPDEVICE_INFO lpdiCur = lpdi; lpdiCur != NULL; lpdiCur = lpdiCur->lpNextDi)
	{
//		char szBuf[1024];
//		wsprintf(szBuf, "comparing:\nlpdiCur->pszRegSubkey = \"%s\"\npszEnumKey = \"%s\"",
//					(LPSTR)lpdiCur->szRegSubkey, (LPSTR)pszEnumKey);
//		MessageBox(hwndParent, szBuf, "Debug", MB_ICONINFORMATION);

		if (0 == lstrcmpi(lpdiCur->szRegSubkey, pszEnumKey))
		{
//			wsprintf(szBuf, "found devnode 0x%08lX, pvFreePointer = 0x%08lX", (DWORD)lpdiCur->dnDevnode, (DWORD)lpdi);
//			MessageBox(hwndParent, szBuf, "Debug", MB_ICONINFORMATION);

			*pDevNode = lpdiCur->dnDevnode;
			*pdwFreePointer = (DWORD)lpdi;
			return S_OK;
		}
	}

	(*_pfnDiDestroyDeviceInfoList)(lpdi);

	UninitSetupx();

//	MessageBox(hwndParent, "returning failure", "Debug", MB_ICONINFORMATION);

	return E_FAIL; // not found
}

extern "C" HRESULT WINAPI __export FreeDevNode16(DWORD dwFreePointer)
{
	LPDEVICE_INFO lpdi = (LPDEVICE_INFO)dwFreePointer;
	if (lpdi == NULL)
	{
		return E_INVALIDARG;
	}

	if (g_hInstSetupx == NULL)
	{
		return E_FAIL;
	}

//	char szBuf[1024];
//	wsprintf(szBuf, "FreeDevNode16 - freeing lpdi 0x%08lX - continue?", dwFreePointer);
//	if (IDYES == MessageBox(NULL, szBuf, "Debug", MB_YESNO | MB_ICONEXCLAMATION))
	{
		(*_pfnDiDestroyDeviceInfoList)(lpdi);
	}

	UninitSetupx();
	return S_OK;
}

extern "C" HRESULT WINAPI __export IcsUninstall16(void)
{
    typedef void (WINAPI *RUNDLLPROC)(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
    
    HINSTANCE hInstance = LoadLibrary("issetup.dll");
    if(hInstance > 32)
    {
        RUNDLLPROC pExtUninstall = (RUNDLLPROC) GetProcAddress(hInstance, "ExtUninstall");
        if(NULL != pExtUninstall)
        {
            pExtUninstall(NULL, NULL, NULL, 0);
        }

        FreeLibrary(hInstance);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\broadbnd.cpp ===
//
// Broadbnd.cpp
//
//		Code for keeping track of which NIC is the user's broadband NIC.
//		NOTE: this may be replaced by standard ICS APIs.
//
// History:
//
//		 9/29/1999  KenSh     Created from JetNet sources
//		11/03/1999  KenSh     Fixed so it uses proper registry keys
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"

static const TCHAR c_szAppRegKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetWizard");
static const TCHAR c_szRegVal_Broadband[] = _T("BroadbandAdapter");


// Did the user pick this adapter as their broadband connection either in Setup
// or in the diagnostic app?
BOOL WINAPI IsAdapterBroadband(const NETADAPTER* pAdapter)
{
	CRegistry reg;
	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, c_szAppRegKey, KEY_READ))
	{
		return (pAdapter->bIcsStatus == ICS_EXTERNAL);
	}

	if (pAdapter->bNicType == NIC_VIRTUAL || pAdapter->bNetType != NETTYPE_LAN)
		return FALSE; // not an ethernet NIC, therefore not broadband

	TCHAR szAdapterNumber[20];
	if (reg.QueryStringValue(c_szRegVal_Broadband, szAdapterNumber, _countof(szAdapterNumber)))
	{
		return (0 == lstrcmpi(FindFileTitle(pAdapter->szClassKey), szAdapterNumber));
	}
	else
	{
		return FALSE;
	}
}

// Saves info about the user's broadband selection into the registry
// Adapter number is FindFileTitle(pAdapter->szClassKey)
void WINAPI SaveBroadbandSettings(LPCSTR pszBroadbandAdapterNumber)
{
	CRegistry reg;
	if (reg.CreateKey(HKEY_LOCAL_MACHINE, c_szAppRegKey))
	{
		// No high speed connection? then don't save one.
		if (pszBroadbandAdapterNumber == NULL || *pszBroadbandAdapterNumber == _T('\0'))
		{
			reg.DeleteValue(c_szRegVal_Broadband);
		}
		else
		{
			// Save the enum key of the NIC we want to use
			reg.SetStringValue(c_szRegVal_Broadband, pszBroadbandAdapterNumber);
		}
	}
}


#if 0 // old JetNet function not used by Home Networking Wizard

// Loads current broadband settings from the registry, and updates the registry
// if we now have more information about a recently installed broadband NIC
BOOL WINAPI UpdateBroadbandSettings(LPTSTR pszEnumKeyBuf, int cchEnumKeyBuf)
{
	ASSERT(pszEnumKeyBuf != NULL);
	*pszEnumKeyBuf = '\0';

	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szBroadbandRegKey))
	{
		if (reg.QueryStringValue("BroadbandYes", pszEnumKeyBuf, cchEnumKeyBuf))
			goto done; // we already have a particular broadband NIC selected

		NETADAPTER* prgAdapters;
		int cAdapters = EnumNetAdapters(&prgAdapters);
		NETADAPTER* pBroadbandAdapter = NULL;
		for (int iAdapter = 0; iAdapter < cAdapters; iAdapter++)
		{
			NETADAPTER* pAdapter = &prgAdapters[iAdapter];
			if (IsAdapterBroadband(pAdapter))
			{
				pBroadbandAdapter = pAdapter;
				break;
			}
		}
		if (pBroadbandAdapter != NULL)
		{
			SaveBroadbandSettings(pBroadbandAdapter->szEnumKey);
			lstrcpyn(pszEnumKeyBuf, pBroadbandAdapter->szEnumKey, cchEnumKeyBuf);
		}
		NetConnFree(prgAdapters);
	}

done:
	return (*pszEnumKeyBuf != '\0');
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\binding.cpp ===
//
// Binding.cpp
//
//		Shared code for enumerating and modifying network bindings, used for
//		protocols, clients, and services.
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "TheApp.h"


// Given a string such as "MSTCP\0000" or "Network\MSTCP\0000", returns a 
// string such as "Enum\Network\MSTCP\0000".
//
// Input string will copied without modification if it starts with "Enum\".
//
void WINAPI FullEnumKeyFromBinding(LPCSTR pszBinding, LPSTR pszBuf, int cchBuf)
{
	LPCSTR pszStatic = "";
	int cchStatic = 0;

	int cSlashes = CountChars(pszBinding, '\\');
	if (cSlashes == 1)
	{
		pszStatic = "Enum\\Network\\";
		cchStatic = _countof("Enum\\Network\\") - 1;
	}
	else if (cSlashes == 2)
	{
		pszStatic = "Enum\\";
		cchStatic = _countof("Enum\\") - 1;
	}

	int cchBinding = lstrlen(pszBinding);
	if (cchBuf < cchBinding + cchStatic + 1)
	{
		*pszBuf = '\0';
	}
	else
	{
		lstrcpy(pszBuf, pszStatic);
		lstrcpy(pszBuf + cchStatic, pszBinding);
	}
}


// Given a full or partial enum key, allocates and returns an array of string
// pointers, one pointer for each binding.
//
// Examples of valid input:
//		"MSTCP\0000"
//		"Network\MSTCP\0000"
//		"Enum\Network\MSTCP\0000"
//		"Enum\PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00\407000"
//
// Each output string is in the short format ("MSTCP\0000").
//
// pprgBindings may be NULL, in which case only the count is returned.
//
int WINAPI EnumNetBindings(LPCSTR pszParentBinding, LPSTR** pprgBindings)
{
	TCHAR szFullParent[200];
	FullEnumKeyFromBinding(pszParentBinding, szFullParent, _countof(szFullParent));

	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szFullParent, KEY_READ))
	{
		if (reg.OpenSubKey("Bindings", KEY_READ))
		{
			DWORD cBindings;
			DWORD cbMaxValueNameLen;
			if (ERROR_SUCCESS == RegQueryInfoKey(reg.m_hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cBindings, &cbMaxValueNameLen, NULL, NULL, NULL))
			{
				if (pprgBindings == NULL)
				{
					return (int)cBindings;
				}
				else
				{
					int cEnum = 0;

					LPTSTR* prgBindings = (LPTSTR*)NetConnAlloc(cBindings * (cbMaxValueNameLen + 1 + sizeof(LPTSTR)));
					LPTSTR pch = (LPTSTR)(prgBindings + cBindings);
					for (DWORD iBinding = 0; iBinding < cBindings; iBinding++)
					{
						DWORD cchValueName = cbMaxValueNameLen+1;
						prgBindings[iBinding] = pch;
						if (ERROR_SUCCESS == RegEnumValue(reg.m_hKey, iBinding, pch, &cchValueName, NULL, NULL, NULL, NULL))
						{
							pch += (cchValueName + 1);
							cEnum += 1;
						}
					}

					*pprgBindings = prgBindings;
					return cEnum;
				}
			}
		}
	}

	if (pprgBindings != NULL)
	{
		*pprgBindings = NULL;
	}

	return 0;
}

// Same as EnumNetBindings, except it filters out bindings that don't
// match the given device ID (e.g. "MSTCP").
// pprgBindings may be NULL, in which case only the count is returned.
int WINAPI EnumMatchingNetBindings(LPCSTR pszParentBinding, LPCSTR pszDeviceID, LPSTR** pprgBindings)
{
	LPSTR* prgBindings;
	int cBindings = EnumNetBindings(pszParentBinding, &prgBindings);
	for (int iBinding = 0; iBinding < cBindings; iBinding++)
	{
		if (!DoesBindingMatchDeviceID(prgBindings[iBinding], pszDeviceID))
		{
			for (int iBinding2 = iBinding+1; iBinding2 < cBindings; iBinding2++)
			{
				prgBindings[iBinding2-1] = prgBindings[iBinding2];
			}
			cBindings--;
			iBinding--;
		}
	}

	if (cBindings == 0 || pprgBindings == NULL)
	{
		NetConnFree(prgBindings);
		prgBindings = NULL;
	}

	if (pprgBindings != NULL)
	{
		*pprgBindings = prgBindings;
	}

	return cBindings;
}


// RemoveBinding
//
//		Removes a specific instance of a protocol, client, or service from the registry.
//		Any cascading dependencies are removed as well.
//
//		pszNetEnumKey - partial Enum key of the binding to be removed, e.g. "MSTCP\0000"
//				or "VSERVER\0000".  Assumed to live under HKLM\Enum\Network.
//
// History:
//
//		 3/25/1999  KenSh     Created
//
VOID RemoveBinding(LPCSTR pszBinding)
{
	ASSERT(pszBinding != NULL);

	CHAR szRegKey[MAX_PATH];
	static const CHAR szEnumString[] = "Enum\\Network\\";
	static const CHAR szBindingsString[] = "\\Bindings";
	int cRemaining = sizeof(szRegKey) - (sizeof(szEnumString) + sizeof(szBindingsString));

	if (lstrlen(pszBinding) >= cRemaining)
		return; // Bail out 
	lstrcpy(szRegKey, szEnumString);
	lstrcat(szRegKey, pszBinding);
	int cchMainEnumKey = lstrlen(szRegKey);
	lstrcat(szRegKey, szBindingsString);

	// Enumerate and delete all binding keys referred to by current binding key
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS)) // e.g. "Enum\Network\MSTCP\0000\Bindings"
	{
		for (;;) // Loop until we've deleted all the subkeys
		{
			CHAR szValueName[60];
			DWORD cbValueName = _countof(szValueName);
			if (ERROR_SUCCESS != RegEnumValue(reg.m_hKey, 0, szValueName, &cbValueName, NULL, NULL, NULL, NULL))
				break;

			// Remove the client or service
			RemoveBindingFromParent(reg.m_hKey, szValueName);
		}
	}

	// Open the main node, and get values we'll need later
	TCHAR szMasterCopy[60];
	CHAR szClassKey[40];
	szMasterCopy[0] = '\0';
	szRegKey[cchMainEnumKey] = '\0';
	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_READ)) // e.g. "Enum\Network\MSTCP\0000"
		return; // it's already been deleted

	reg.QueryStringValue("MasterCopy", szMasterCopy, _countof(szMasterCopy));
	reg.QueryStringValue("Driver", szClassKey, _countof(szClassKey)); // e.g. "NetClient\0000"

	// Remove this binding's node from the registry (and its sub-keys)
	LPSTR pchSubKey = FindFileTitle(szRegKey);
	*(pchSubKey-1) = '\0';
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS))  // e.g. "Enum\Network\MSTCP"
	{
		// Main purpose of this function: delete the requested binding key
		RegDeleteKeyAndSubKeys(reg.m_hKey, pchSubKey);

		// Was this a "MasterCopy" binding?
		static const int cchEnumNet = _countof("Enum\\Network\\") - 1;
		BOOL bMasterCopy = (0 == lstrcmpi(szMasterCopy + cchEnumNet, pszBinding));

		// Check for siblings which might be referencing the same class key
		BOOL bClassKeyReferenced = FALSE;
		CHAR szAlternateMaster[60];
		szAlternateMaster[0] = '\0';
		for (DWORD iSibling = 0; ; iSibling++)
		{
			CHAR szSiblingKey[60];
			DWORD cbSiblingKey = _countof(szSiblingKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iSibling, szSiblingKey, &cbSiblingKey, NULL, NULL, NULL, NULL))
				break;

			CRegistry regSibling;
			if (regSibling.OpenKey(reg.m_hKey, szSiblingKey, KEY_ALL_ACCESS))
			{
				CHAR szSiblingDriver[60];
				if (regSibling.QueryStringValue("Driver", szSiblingDriver, _countof(szSiblingDriver)))
				{
					if (0 == lstrcmpi(szSiblingDriver, szClassKey))
					{
						bClassKeyReferenced = TRUE;

						if (!bMasterCopy)
							break;

						// Check if this sib's mastercopy points to the key being deleted
						if (bMasterCopy)
						{
							CHAR szSibMaster[60];
							if (regSibling.QueryStringValue("MasterCopy", szSibMaster, _countof(szSibMaster))
								&& !lstrcmpi(szSibMaster, szMasterCopy))
							{
								if (szAlternateMaster[0] == '\0') // first match, make it the new master
								{
									wsprintf(szAlternateMaster, "%s\\%s", szRegKey, szSiblingKey);
								}

								regSibling.SetStringValue("MasterCopy", szAlternateMaster);
							}
						}
					}
				}
			}
		}

		if (!bClassKeyReferenced)
		{
			// No more references to the class key, so delete it
			lstrcpy(szRegKey, "System\\CurrentControlSet\\Services\\Class\\");
			lstrcat(szRegKey, szClassKey);
			pchSubKey = FindFileTitle(szRegKey);
			*(pchSubKey-1) = '\0';
			if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS))
			{
				RegDeleteKeyAndSubKeys(reg.m_hKey, pchSubKey);
			}
		}
	}
}


// RemoveBindingFromParent
//
//		Given an open Bindings key, and a string representing one of the bindings
//		listed in it, this function deletes the value, then calls RemoveBinding()
//		to delete the binding and all of its cascading dependencies.
//
// History:
//
//		 3/25/1999  KenSh     Created
//		 4/30/1999  KenSh     Got rid of unnecessary code to delete empty parent
//
VOID RemoveBindingFromParent(HKEY hkeyParentBindingsKey, LPCSTR pszBinding)
{
	// Delete the binding from the Bindings key of the person bound to us
	VERIFY(ERROR_SUCCESS == RegDeleteValue(hkeyParentBindingsKey, pszBinding));
	RemoveBinding(pszBinding);
}

// pszClassKey is of the form "NetService\0000"
BOOL WINAPI DoesClassKeyExist(LPCSTR pszClassKey)
{
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class"))
	{
		if (reg.OpenSubKey(pszClassKey))
		{
			// REVIEW: could check for presence of certain entries
			return TRUE;
		}
	}

	return FALSE;
}

// pszClass = "NetService"
// pszDevice = "VSERVER"
// pszEnumSubKey = "0000"
BOOL WINAPI IsValidNetEnumKey(LPCSTR pszClass, LPCSTR pszDevice, LPCSTR pszEnumSubKey)
{
	CRegistry reg;
	TCHAR szRegKey[260];
	wsprintf(szRegKey, "Enum\\Network\\%s\\%s", pszDevice, pszEnumSubKey);

	BOOL bResult = FALSE;

	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_READ))
		goto done;

	TCHAR szBuf[100];

	// Check a few values
	if (!reg.QueryStringValue("Class", szBuf, _countof(szBuf)))
		goto done;
	if (0 != lstrcmpi(szBuf, pszClass))
		goto done;
	if (!reg.QueryStringValue("Driver", szBuf, _countof(szBuf)))
		goto done;
	if (!DoesClassKeyExist(szBuf))
		goto done;

	bResult = TRUE;

done:
	return bResult;
}

// pszClass is of the form "NetService"
// pszDevice is of the form "VSERVER"
// pszBuf may be NULL if you don't need a copy of the string
BOOL WINAPI FindValidNetEnumKey(LPCSTR pszClass, LPCSTR pszDevice, LPSTR pszBuf, int cchBuf)
{
	CRegistry reg;
	TCHAR szRegKey[200];
	wsprintf(szRegKey, "Enum\\Network\\%s", pszDevice);

	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_READ))
	{
		DWORD dwIndex;
		TCHAR szSubKey[50];

		for (dwIndex = 0; ; dwIndex++)
		{
			DWORD cchSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, dwIndex, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				break;

			if (!IsValidNetEnumKey(pszClass, pszDevice, szSubKey))
				continue;

			// Found a valid entry; copy it to pszBuf and return TRUE
			//
			if (pszBuf != NULL)
			{
				ASSERT(cchBuf > lstrlen(szRegKey) + lstrlen(szSubKey) + 1);
				wsprintf(pszBuf, "%s\\%s", szRegKey, szSubKey);
			}

			return TRUE;
		}
	}

	return FALSE;
}

// pszClass = "NetService", etc.
// pszDeviceID = "VSERVER", etc.
// returns TRUE if anything was removed
BOOL WINAPI RemoveBrokenNetItems(LPCSTR pszClass, LPCSTR pszDeviceID)
{
	CRegistry reg;
	TCHAR szRegKey[200];
	BOOL bResult = FALSE;

delete_enum_keys:
	//
	// Find and remove any broken Enum keys
	//
	wsprintf(szRegKey, "Enum\\Network\\%s", pszDeviceID);
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey))
	{
		TCHAR szSubKey[50];

		DWORD dwIndex = 0;
		for (;;)
		{
			DWORD cchSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, dwIndex, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				break;

			if (!IsValidNetEnumKey(pszClass, pszDeviceID, szSubKey))
			{
				// Delete the key
				// REVIEW: should delete all references to the key
				RegDeleteKeyAndSubKeys(reg.m_hKey, szSubKey);
				bResult = TRUE;

				// Restart the search to ensure we find all broken items
				dwIndex = 0;
				continue;
			}

			dwIndex++;
		}
	}

	//
	// Find and remove any unreferenced Class keys
	//
	wsprintf(szRegKey, "System\\CurrentControlSet\\Services\\Class\\%s", pszClass);
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey))
	{
		TCHAR szSubKey[50];
		int cClassKeysRemoved = 0;

		DWORD dwIndex = 0;
		for (;;)
		{
			DWORD cchSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, dwIndex, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				break;

			wsprintf(szRegKey, "%s\\%s", pszClass, szSubKey);
			if (!IsNetClassKeyReferenced(szRegKey))
			{
				// Delete the key
				RegDeleteKeyAndSubKeys(reg.m_hKey, szSubKey);
				bResult = TRUE;
				cClassKeysRemoved++;

				// Restart the search to ensure we find all broken items
				dwIndex = 0;
				continue;
			}

			dwIndex++;
		}

		// If we removed any class keys, check the Enum keys again
		if (cClassKeysRemoved != 0)
			goto delete_enum_keys;
	}

	return bResult;
}

BOOL GetDeviceInterfaceList(LPCSTR pszClass, LPCSTR pszDeviceID, LPCSTR pszInterfaceType, LPSTR pszBuf, int cchBuf)
{
	ASSERT(pszClass != NULL);

	CRegistry regClassRoot;
	CHAR szRegClassRoot[260];
	static const CHAR szClassString[] = "System\\CurrentControlSet\\Services\\Class\\";
	int cRemaining = sizeof(szRegClassRoot) - sizeof(szClassString);

	if (lstrlen(pszClass) >= cRemaining)
		return FALSE; // Bail out 
	lstrcpy(szRegClassRoot, szClassString);
	lstrcat(szRegClassRoot, pszClass);
	if (regClassRoot.OpenKey(HKEY_LOCAL_MACHINE, szRegClassRoot, KEY_READ))
	{
		for (DWORD iAdapter = 0; ; iAdapter++)
		{
			CHAR szSubKey[15];
			DWORD cchSubKey = _countof(szSubKey) - 4; // -4 to allow "\\Ndi"
			if (ERROR_SUCCESS != RegEnumKeyEx(regClassRoot.m_hKey, iAdapter, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				break;

			CRegistry regNdi;
			lstrcat(szSubKey, "\\Ndi");
			if (regNdi.OpenKey(regClassRoot.m_hKey, szSubKey, KEY_READ))
			{
				CHAR szCurDeviceID[200];
				if (regNdi.QueryStringValue("DeviceID", szCurDeviceID, _countof(szCurDeviceID)) &&
					0 == lstrcmpi(szCurDeviceID, pszDeviceID))
				{
					BOOL bResult = FALSE;

					if (regNdi.OpenSubKey("Interfaces", KEY_READ))
					{
						bResult = regNdi.QueryStringValue(pszInterfaceType, pszBuf, cchBuf);
					}

					return bResult;
				}
			}
		}
	}

	return FALSE;
}

BOOL CheckMatchingInterface(LPCSTR pszList1, LPCSTR pszList2)
{
	CHAR szInterface1[40];
	CHAR szInterface2[40];

	while (GetFirstToken(pszList1, ',', szInterface1, _countof(szInterface1)))
	{
		LPCSTR pszTemp2 = pszList2;
		while (GetFirstToken(pszTemp2, ',', szInterface2, _countof(szInterface2)))
		{
			if (0 == lstrcmpi(szInterface1, szInterface2))
				return TRUE;
		}
	}

	return FALSE;
}

BOOL GetDeviceLowerRange(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf)
{
	return GetDeviceInterfaceList(pszClass, pszDeviceID, "LowerRange", pszBuf, cchBuf);
}

BOOL GetDeviceUpperRange(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf)
{
	return GetDeviceInterfaceList(pszClass, pszDeviceID, "UpperRange", pszBuf, cchBuf);
}

// class is "Net", "NetTrans", "NetClient", or "NetService"
HRESULT OpenNetClassKey(CRegistry& reg, LPCSTR pszClass, LPCSTR pszSubKey, REGSAM dwAccess)
{
	ASSERT(pszClass != NULL);

	CHAR szRegKey[MAX_PATH];
	static const CHAR szClassString[] = "System\\CurrentControlSet\\Services\\Class\\";
	int cRemaining = sizeof(szRegKey) - 
	    (sizeof(szClassString) + ((pszSubKey)?(lstrlen(pszSubKey) + 1):(0)));

	if (lstrlen(pszClass) >= cRemaining)
		return NETCONN_INVALID_ARGUMENT; // Bail out 
	lstrcpy(szRegKey, szClassString);
	lstrcat(szRegKey, pszClass);

	if (pszSubKey != NULL)
	{
		lstrcat(szRegKey, "\\");
		lstrcat(szRegKey, pszSubKey);
	}

	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, dwAccess))
		return NETCONN_UNKNOWN_ERROR;

	return NETCONN_SUCCESS;
}

VOID FindUnusedDeviceIdNumber(CRegistry& reg, LPSTR pszBuf, int cchBuf)
{
	for (DWORD dwDeviceNumber = 0; ; dwDeviceNumber++)
	{
		CRegistry regTemp;
		wsprintf(pszBuf, "%04lu", dwDeviceNumber);
		if (!regTemp.OpenKey(reg.m_hKey, pszBuf, KEY_READ))
			break;
	}
}

// Given a network device ID, such as "MSTCP", creates a new instance
// of it by copying an existing instance.
// pszClass = "NetTrans"
// pszDeviceID = "MSTCP"
// pszBuf is filled with the new device binding ID, e.g. "MSTCP\0000"
HRESULT FindAndCloneNetEnumKey(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf)
{
	CRegistry reg;

	TCHAR szExistingEnumKey[260];
	if (!FindValidNetEnumKey(pszClass, pszDeviceID, szExistingEnumKey, _countof(szExistingEnumKey)))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR; // the device is not installed properly!
	}

	TCHAR szRegKey[200];
	wsprintf(szRegKey, "Enum\\Network\\%s", pszDeviceID);
	if (!reg.CreateKey(HKEY_LOCAL_MACHINE, szRegKey))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	// Find the next unused device ID number
	TCHAR szNewNumber[10];
	FindUnusedDeviceIdNumber(reg, szNewNumber, _countof(szNewNumber));

	// Make a copy of the key (recursive)
	LPCTSTR pszExistingNumber = FindFileTitle(szExistingEnumKey);
	if (!reg.CloneSubKey(pszExistingNumber, szNewNumber, TRUE))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	wsprintf(pszBuf, "%s\\%s", pszDeviceID, szNewNumber);
	return NETCONN_SUCCESS;
}

// existing driver is of the form "NetTrans\0000"
// new driver will be of the form "NetTrans\0001"
HRESULT CloneNetClassKey(LPCSTR pszExistingDriver, LPSTR pszNewDriverBuf, int cchNewDriverBuf)
{
	HRESULT hr;

	LPSTR pchSlash = strchr(pszExistingDriver, '\\');
	if (pchSlash == NULL)
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	// Extract just the class portion of the driver name, e.g. "NetTrans"
	CHAR szClass[30];
	int cchClass = (int)(pchSlash - pszExistingDriver);
	ASSERT(cchClass < _countof(szClass));
	lstrcpyn(szClass, pszExistingDriver, cchClass+1);

	CRegistry regClassKey;
	if (FAILED(hr = OpenNetClassKey(regClassKey, szClass, NULL, KEY_ALL_ACCESS)))
		return hr;

	// Find the next unused driver number
	CHAR szDriverNumber[5];
	FindUnusedDeviceIdNumber(regClassKey, szDriverNumber, _countof(szDriverNumber));

	// Make a copy of the key (recursive)
	if (!regClassKey.CloneSubKey(pchSlash+1, szDriverNumber, TRUE))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	wsprintf(pszNewDriverBuf, "%s\\%s", szClass, szDriverNumber);

	// Remove the "default" subkey if we just copied it (can't have 2 defaults)
	if (regClassKey.OpenSubKey(szDriverNumber))
	{
		if (regClassKey.OpenSubKey("Ndi"))
		{
			RegDeleteKey(regClassKey.m_hKey, "Default");
		}
	}

	return NETCONN_SUCCESS;
}


// pszSubKey == "MSTCP", "VREDIR", "MSTCP\0000", etc.
HRESULT OpenNetEnumKey(CRegistry& reg, LPCSTR pszSubKey, REGSAM dwAccess)
{
	ASSERT(pszSubKey != NULL);

	CHAR szRegKey[MAX_PATH];
	static const CHAR szEnumString[] = "Enum\\Network\\";
	int cRemaining = sizeof(szRegKey) - sizeof(szEnumString);

	if (lstrlen(pszSubKey) >= cRemaining)
		return NETCONN_INVALID_ARGUMENT; // Bail out 
	lstrcpy(szRegKey, szEnumString);
	lstrcat(szRegKey, pszSubKey);

	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, dwAccess))
		return NETCONN_UNKNOWN_ERROR;

	return NETCONN_SUCCESS;
}

// pszClass = "NetClient"
// pszDeviceID = "NWREDIR"
HRESULT DeleteClassKeyReferences(LPCSTR pszClass, LPCSTR pszDeviceID)
{
	HRESULT hr = NETCONN_SUCCESS;

	// Delete the class key(s)
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class") &&
		reg.OpenSubKey(pszClass))
	{
		TCHAR szNumber[20];
		DWORD iClassItem = 0;
		for (;;)
		{
			DWORD cchNumber = _countof(szNumber);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iClassItem, szNumber, &cchNumber, NULL, NULL, NULL, NULL))
				break;

			CRegistry regNumber;
			if (regNumber.OpenKey(reg.m_hKey, szNumber))
			{
				CRegistry regNdi;
				if (regNdi.OpenKey(regNumber.m_hKey, "Ndi"))
				{
					TCHAR szDeviceID[50];
					if (regNdi.QueryStringValue("DeviceID", szDeviceID, _countof(szDeviceID)) &&
						!lstrcmpi(szDeviceID, pszDeviceID))
					{
						regNdi.CloseKey();
						regNumber.CloseKey();
						RegDeleteKeyAndSubKeys(reg.m_hKey, szNumber);
						hr = NETCONN_NEED_RESTART;

						// Restart the search
						iClassItem = 0;
						continue;
					}
				}
			}

			iClassItem++;
		}
	}

	return hr;
}

// pszClassKey is of the form "NetService\0000"
BOOL IsNetClassKeyReferenced(LPCSTR pszClassKey)
{
	CRegistry reg;
	CHAR szDeviceID[200];
	DWORD iKey;

	// Get the device ID
	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class", KEY_READ))
		goto done;
	if (!reg.OpenSubKey(pszClassKey, KEY_READ))
		goto done;
	if (!reg.OpenSubKey("Ndi", KEY_READ))
		goto done;

	if (!reg.QueryStringValue("DeviceID", szDeviceID, _countof(szDeviceID)))
		goto done;

	if (!reg.OpenKey(HKEY_LOCAL_MACHINE, "Enum\\Network", KEY_READ))
		goto done;
	if (!reg.OpenSubKey(szDeviceID, KEY_READ))
		goto done;

	for (iKey = 0; ; iKey++)
	{
		CHAR szSubKey[60];
		DWORD cbSubKey = _countof(szSubKey);
		if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iKey, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL))
			break;

		CRegistry regSubKey;
		if (regSubKey.OpenKey(reg.m_hKey, szSubKey, KEY_READ))
		{
			CHAR szDriver[60];
			if (regSubKey.QueryStringValue("Driver", szDriver, _countof(szDriver)))
			{
				if (0 == lstrcmpi(szDriver, pszClassKey))
					return TRUE;
			}
		}
	}

done:
	return FALSE;
}

// Given a binding of one of the two following forms
//		"MSTCP\0000"
//		"Enum\Network\MSTCP\0000"
// and a device ID such as "MSTCP", returns TRUE if the binding is a binding
// of the given device, or FALSE if not.
BOOL WINAPI DoesBindingMatchDeviceID(LPCSTR pszBinding, LPCSTR pszDeviceID)
{
	CHAR szTemp[40];
	LPCSTR pszBoundDevice = FindPartialPath(pszBinding, 1); // skip "Enum\..." if present
	lstrcpyn(szTemp, pszBoundDevice, _countof(szTemp));
	LPSTR pchSlash = strchr(szTemp, '\\');
	if (pchSlash != NULL)
		*pchSlash = '\0';
	return !lstrcmpi(szTemp, pszDeviceID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\dhcp.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    Functions to get information from VDHCP.VXD

    Contents:
        (OpenDhcpVxdHandle)
        (DhcpVxdRequest)
        DhcpReleaseAdapterIpAddress
        DhcpRenewAdapterIpAddress
        (ReleaseOrRenewAddress)
        IsMediaDisconnected

Author:

    Richard L Firth (rfirth) 30-Nov-1994

Revision History:

    30-Nov-1994 rfirth
        Created

--*/

#include "stdafx.h"
#include "NetConn.h"
#include "w9xdhcp.h"
#include "vxd32.h"


#ifdef __cplusplus
extern "C" {
#endif


//
//  Private constants.
//

#define DHCP_IS_MEDIA_DISCONNECTED 5

#define PRIVATE static


//
// private prototypes
//

PRIVATE
DWORD
OpenDhcpVxdHandle(
    void
    );

PRIVATE
WORD
DhcpVxdRequest(
    IN DWORD Handle,
    IN WORD Request,
    IN WORD BufferLength,
    OUT LPVOID Buffer
    );

PRIVATE
WORD
ReleaseOrRenewAddress(
    UINT Request,
    UINT AddressLength,
    LPBYTE Address
    );

//
// data
//

//
// functions
//

BOOL
IsMediaDisconnected(
    IN OUT DWORD iae_context
    )
{
    DWORD handle;

    handle = OpenDhcpVxdHandle();
    if( handle ) {
        WORD result;
        DWORD MediaStatus = iae_context;

        result = DhcpVxdRequest( handle,
                                 DHCP_IS_MEDIA_DISCONNECTED,
                                 sizeof(MediaStatus),
                                 &MediaStatus
            );

        OsCloseVxdHandle( handle );

        if( result == 0 && MediaStatus == TRUE ) return TRUE;
    }

    return FALSE;
}


/*******************************************************************************
 *
 *  OpenDhcpVxdHandle
 *
 *  On Snowball, just retrieves the (real-mode) entry point address to the VxD
 *
 *  ENTRY   nothing
 *
 *  EXIT    DhcpVxdEntryPoint set
 *
 *  RETURNS DhcpVxdEntryPoint
 *
 *  ASSUMES 1. We are running in V86 mode
 *
 ******************************************************************************/

PRIVATE DWORD
OpenDhcpVxdHandle()
{
    return OsOpenVxdHandle("VDHCP", VDHCP_Device_ID);
}


/*******************************************************************************
 *
 *  DhcpVxdRequest
 *
 *  Makes a DHCP VxD request - passes a function code, parameter buffer and
 *  length to the (real-mode/V86) VxD entry-point
 *
 *  ENTRY   Handle          - handle for Win32 call
 *          Request         - DHCP VxD request
 *          BufferLength    - length of Buffer
 *          Buffer          - pointer to request-specific parameters
 *
 *  EXIT    depends on request
 *
 *  RETURNS Success - 0
 *          Failure - ERROR_PATH_NOT_FOUND
 *                      Returned if a specified adapter address could not be
 *                      found
 *
 *                    ERROR_BUFFER_OVERFLOW
 *                      Returned if the supplied buffer is too small to contain
 *                      the requested information
 *
 *  ASSUMES
 *
 ******************************************************************************/

PRIVATE WORD
DhcpVxdRequest(DWORD Handle, WORD Request, WORD BufferLength, LPVOID Buffer)
{
    return (WORD) OsSubmitVxdRequest( Handle,
                                      (INT)Request,
                                      (LPVOID)Buffer,
                                      (INT)BufferLength );
}

/*******************************************************************************
 *
 *  DhcpReleaseAdapterIpAddress
 *
 *  Attempts to release the IP address for an adapter
 *
 *  ENTRY   AdapterInfo - describing adapter to release address for
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - TRUE
 *          Failure - FALSE
 *
 ******************************************************************************/

DWORD
DhcpReleaseAdapterIpAddress(PADAPTER_INFO AdapterInfo)
{

    WORD result;

    result = ReleaseOrRenewAddress(DHCP_RELEASE_IPADDRESS,
                                   AdapterInfo->AddressLength,
                                   AdapterInfo->Address
                                   );
    return (DWORD)result;
}

/*******************************************************************************
 *
 *  DhcpRenewAdapterIpAddress
 *
 *  Attempts to renew the IP address for an adapter
 *
 *  ENTRY   AdapterInfo - describing adapter to renew address for
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - TRUE
 *          Failure - FALSE
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
DhcpRenewAdapterIpAddress(PADAPTER_INFO AdapterInfo)
{

    WORD result;

    result = ReleaseOrRenewAddress(DHCP_RENEW_IPADDRESS,
                                   AdapterInfo->AddressLength,
                                   AdapterInfo->Address
                                   );
    return (DWORD)result;
}

/*******************************************************************************
 *
 *  ReleaseOrRenewAddress
 *
 *  Given a physical adapter address and length, renews or releases the IP
 *  address lease for this adapter
 *
 *  ENTRY   Request         - DHCP_RELEASE_IPADDRESS or DHCP_RENEW_IPADDRESS
 *          AddressLength   - length of Address
 *          Address         - pointer to byte array which is physical adapter
 *                            address
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - ERROR_SUCCESS
 *          Failure - ERROR_NOT_ENOUGH_MEMORY
 *                    ERROR_FILE_NOT_FOUND
 *                    ERROR_PATH_NOT_FOUND
 *                    ERROR_BUFFER_OVERFLOW
 *
 *  ASSUMES
 *
 ******************************************************************************/

PRIVATE WORD
ReleaseOrRenewAddress(UINT Request, UINT AddressLength, LPBYTE Address)
{
    DWORD handle;

    handle = OpenDhcpVxdHandle();
    
    if (handle) 
    {
        LPDHCP_HW_INFO info;
        WORD result;
        WORD length;

        length = sizeof(DHCP_HW_INFO) + AddressLength;
        info = (LPDHCP_HW_INFO)LocalAlloc(LPTR, length);
        
        if (!info) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        info->OffsetHardwareAddress = sizeof(*info);
        info->HardwareLength = AddressLength;
        memcpy(info + 1, Address, AddressLength);
        result = DhcpVxdRequest(handle, (WORD)Request, length, (LPVOID)info);
        
        OsCloseVxdHandle(handle);
        LocalFree(info);
        return result;
    } 
    
    return ERROR_FILE_NOT_FOUND;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\fauxmfc.cpp ===
#include "..\shared\fauxmfc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\hookui.h ===
//
// HookUI.h
//

#pragma once


VOID BeginSuppressNetdiUI(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam);
VOID EndSuppressNetdiUI();
HRESULT HresultFromCCI(DWORD dwErr);

extern BOOL g_bUserAbort;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\defconn.cpp ===
//
// DefConn.cpp
//

#include "stdafx.h"
#include "Registry.h"
#include "DefConn.h"
#include "nconnwrap.h"

static const TCHAR c_szInternetSettings[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
static const TCHAR c_szProfile[] = "RemoteAccess\\Profile\\";
static const TCHAR c_szEnableAutodial[] = "EnableAutodial";
static const TCHAR c_szNoNetAutodial[] = "NoNetAutodial";
static const TCHAR c_szRemoteAccess[] = "RemoteAccess";
static const TCHAR c_szInternetProfile[] = "InternetProfile";
static const TCHAR c_szAutoConnect[] = "AutoConnect";


/////////////////////////////////////////////////////////////////////////////
// EnableAutodial

void WINAPI EnableAutodial(BOOL bAutodial, LPCSTR szConnection)
{
    if (bAutodial)
    {
        // Ensure that "1" is written
        bAutodial = 1;
    }
	CRegistry regInternetHKCU(HKEY_CURRENT_USER, c_szInternetSettings, KEY_SET_VALUE);
	CRegistry regInternetHKLM(HKEY_LOCAL_MACHINE, c_szInternetSettings, KEY_SET_VALUE);

	regInternetHKCU.SetDwordValue(c_szEnableAutodial, bAutodial);
	regInternetHKCU.SetDwordValue(c_szNoNetAutodial, bAutodial);
	regInternetHKLM.SetBinaryValue(c_szEnableAutodial, (LPBYTE)&bAutodial, sizeof(bAutodial));
	if (szConnection != NULL)
	{
		TCHAR szTemp[MAX_PATH];
		lstrcpy(szTemp, c_szProfile);
		lstrcat(szTemp, szConnection);
		CRegistry regProfile(HKEY_CURRENT_USER, szTemp, KEY_SET_VALUE);
		regProfile.SetDwordValue(c_szAutoConnect, bAutodial);
	}

}

/////////////////////////////////////////////////////////////////////////////
// BOOL IsAutodialEnabled()

BOOL WINAPI IsAutodialEnabled()
{
	CRegistry regInternetHKCU;
	return regInternetHKCU.OpenKey(HKEY_CURRENT_USER, c_szInternetSettings, KEY_QUERY_VALUE) &&
		regInternetHKCU.QueryDwordValue(c_szEnableAutodial) != 0;
}

/////////////////////////////////////////////////////////////////////////////
// SetDefaultDialupConnection
//
// Empty (or NULL) string indicates no default connection, or shared connection (if ICS client).

void WINAPI SetDefaultDialupConnection(LPCTSTR pszConnectionName)
{
	CRegistry regRAS(HKEY_CURRENT_USER, c_szRemoteAccess, KEY_SET_VALUE);

	if (pszConnectionName != NULL && *pszConnectionName != '\0')
	{
		regRAS.SetStringValue(c_szInternetProfile, pszConnectionName);
		// Don't automatically autodial anymore
		// EnableAutodial(TRUE);
	}
	else
	{
		regRAS.DeleteValue(c_szInternetProfile);
		EnableAutodial(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// GetDefaultDialupConnection
//
// Empty string returned indicates no default connection, or shared connection (if ICS client).

void WINAPI GetDefaultDialupConnection(LPTSTR pszConnectionName, int cchMax)
{
	pszConnectionName[0] = '\0';
	CRegistry regRAS(HKEY_CURRENT_USER, c_szRemoteAccess, KEY_QUERY_VALUE);
	regRAS.QueryStringValue(c_szInternetProfile, pszConnectionName, cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\hookui.cpp ===
//
// HookUI.cpp
//
//		Code to hook the standard NetDI UI, so we can get progress
//		notifications and warn the user if he clicks Cancel.
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "TheApp.h"
#include "../NConn16/NConn16.h"

// Global data
//
BOOL g_bUserAbort;


// Local data
//
static HHOOK g_hHook;
static HWND g_hwndParent;
static HWND g_hwndCopyFiles;
static PROGRESS_CALLBACK g_pfnProgress;
static LPVOID g_pvProgressParam;
static WNDPROC g_pfnPrevCopyFilesWndProc;
static WNDPROC g_pfnPrevProgressWndProc;


// Local functions
//
LRESULT CALLBACK SubclassCopyFilesWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SubclassProgressWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WindowCreateHook(int nCode, WPARAM wParam, LPARAM lParam);



VOID BeginSuppressNetdiUI(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	g_hwndParent = hwndParent;
	g_pfnProgress = pfnProgress;
	g_pvProgressParam = pvProgressParam;
	g_hHook = SetWindowsHookEx(WH_CBT, WindowCreateHook, NULL, GetCurrentThreadId());
	g_bUserAbort = FALSE;
}

VOID EndSuppressNetdiUI()
{
	UnhookWindowsHookEx(g_hHook);
}

LRESULT CALLBACK SubclassCopyFilesWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_CREATE:
		{
#if 0 // Code like this would help hide the progress bar from the user
			LONG dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
			dwExStyle |= WS_EX_TOOLWINDOW;
			SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);
			SetParent(hwnd, NULL);
#endif
		}
		break;

#if 0 // Code like this would help hide the progress bar from the user
	case WM_WINDOWPOSCHANGING:
		{
			LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
			RECT rcParent;
			GetWindowRect(g_hwndParent, &rcParent);
			lpwp->x = rcParent.left + 50;
			lpwp->y = rcParent.top + 30;
			lpwp->hwndInsertAfter = g_hwndParent;
			lpwp->flags &= ~SWP_NOZORDER;
		}
		break;
#endif

	case WM_COMMAND:
		{
			UINT uNotifyCode = HIWORD(wParam);
			int idCtrl = (int)(UINT)LOWORD(wParam);

			if (idCtrl == IDCANCEL)
			{
				// Check for a Cancel button with an "OK" label (yes, this happens)
				// TODO: check if this is correct even in localized Windows
				TCHAR szMsg[256];
				GetDlgItemText(hwnd, IDCANCEL, szMsg, _countof(szMsg));
				if (0 != lstrcmpi(szMsg, "OK"))
				{
					LoadString(g_hInstance, IDS_ASKCANCEL_NOTSAFE, szMsg, _countof(szMsg));
					TCHAR szTitle[100];
					LoadString(g_hInstance, IDS_APPTITLE, szTitle, _countof(szTitle));
					int nResult = MessageBox(hwnd, szMsg, szTitle, MB_OKCANCEL | MB_ICONEXCLAMATION);
					if (nResult == IDCANCEL)
						return 0;

					// Set a global (yuck) so we know for sure if the user clicked the
					// Cancel button, rather than some other error
					g_bUserAbort = TRUE;
				}
			}
		}
		break;
	}

	LRESULT lResult = CallWindowProc(g_pfnPrevCopyFilesWndProc, hwnd, message, wParam, lParam);
	return lResult;
}


LRESULT CALLBACK SubclassProgressWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
//	TCHAR szBuf[512];
//	wsprintf(szBuf, "Message %u, wParam = 0x%08x, lParam = 0x%08x\r\n", message, wParam, lParam);
//	OutputDebugString(szBuf);

	static DWORD dwMin = 0;
	static DWORD dwMax = 0;

	switch (message)
	{
	case (WM_USER+1):
		dwMin = LOWORD(lParam);
		dwMax = HIWORD(lParam);
		break;

	case (WM_USER+2):
		{
			DWORD dwCur = wParam;
			if (g_pfnProgress != NULL)
			{
				if (!(*g_pfnProgress)(g_pvProgressParam, dwCur - dwMin, dwMax - dwMin))
				{
					// TODO: try to abort somehow - press the cancel button?
				}
			}
		}
		break;
	}

	return CallWindowProc(g_pfnPrevProgressWndProc, hwnd, message, wParam, lParam);
}


LRESULT CALLBACK WindowCreateHook(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode == HCBT_CREATEWND)
	{
		HWND hwnd = (HWND)wParam;
		CBT_CREATEWND* pCW = (CBT_CREATEWND*)lParam;

		if (g_hwndParent == pCW->lpcs->hwndParent)
		{
			g_hwndCopyFiles = hwnd;
//			OutputDebugString("Found a copy-files window window, looking for progress bar...\r\n");

			g_pfnPrevCopyFilesWndProc = (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (LONG)SubclassCopyFilesWndProc);

			// TODO: remove this test-only code
//			if (cWindows < _countof(rgWindowTitles))
//			{
//				lstrcpyn(rgWindowTitles[cWindows], pCW->lpcs->lpszName, _countof(rgWindowTitles[cWindows]));
//				cWindows += 1;
//			}
		}
		else if (g_hwndCopyFiles != NULL && g_hwndCopyFiles == pCW->lpcs->hwndParent)
		{
			if (!lstrcmp(pCW->lpcs->lpszClass, "setupx_progress"))
			{
//				OutputDebugString("Found a progress bar!\r\n");

				if (g_pfnProgress != NULL)
				{
					g_pfnPrevProgressWndProc = (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (LONG)SubclassProgressWndProc);
				}
			}
		}
	}

	return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}


// HresultFromCCI
//
//		Given a return code from CallClassInstaller16, converts to a JetNet
//		HRESULT return code.
//
HRESULT HresultFromCCI(DWORD dwErr)
{
	HRESULT hr = NETCONN_SUCCESS;

	if (dwErr == ICERR_NEED_RESTART || dwErr == ICERR_NEED_REBOOT)
	{
		hr = NETCONN_NEED_RESTART;
	}
	else if ((dwErr & ICERR_DI_ERROR) == ICERR_DI_ERROR)
	{
		dwErr &= ~ICERR_DI_ERROR;

// ks 8/4/99: we now use global g_bUserAbort to detect abort conditions
#if 0
		// NetDI returns ERR_VCP_IOFAIL if the user clicks Cancel.  Go figure.
		// Or sometimes it returns ERR_NDI_INVALID_DRIVER_PROC.  Really go figure.
		if (dwErr == ERR_VCP_INTERRUPTED || dwErr == ERR_VCP_IOFAIL || dwErr == ERR_NDI_INVALID_DRIVER_PROC)
		{
			hr = JETNET_USER_ABORT;
		}
		else
#endif // 0
		{
			hr = NETCONN_UNKNOWN_ERROR;
		}
	}
	else if ((LONG)dwErr < 0)
	{
		hr = NETCONN_UNKNOWN_ERROR;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\mycfgmgr.cpp ===
//
// MyCfgMgr.cpp
// 
//        Config Manager functions, and simulations of config manager functions
//
// History:
//
//         1/13/2000  KenSh     Created
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "TheApp.h"


// Define this if you want to use CFGMGR32.DLL (requires Win98 or later)
//
#define USE_CFGMGR32

// Definitions used by config manager API's
//
//   (Taken from Millennium\root\dev\ddk\inc\cfgmgr32.h  -ks 1/13/2000)
//
#define CMAPI     // DECLSPEC_IMPORT
typedef DWORD        RETURN_TYPE;
typedef RETURN_TYPE  CONFIGRET;
#define CR_SUCCESS                  (0x00000000)
#define CR_FAILURE                  (0x00000013)


#ifndef USE_CFGMGR32

// Internal Config Manager definitions
//
//   (Taken from Millennium\root\pnp\dll\cfgmgr32\cm32api.h  -ks 1/13/2000)
//
#define CM32_WARNS(_x_)

#define CONFIGMG_W32IOCTL_RANGE         0x80000000
#define CONFIGMG_DEVICE_ID              0x00033 /* Configuration manager (Plug&Play) */
#define GetVxDServiceOrdinal(service)   __##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define    CONFIGMG_Service    Declare_Service

Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service    (_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
//
// 4.0 OPK2 Services
//
CONFIGMG_Service    (_CONFIGMG_Change_DevNode_Status, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Reprocess_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Assert_Structure, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Discard_Boot_Log_Conf, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Refilter_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Merge_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Substract_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Read_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Write_Range_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Log_Conf_Priority, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Support_Share_Irq, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Parent_Structure, VxD_CODE)
//
// 4.1 Services
//
CONFIGMG_Service    (_CONFIGMG_Register_DevNode_For_Idle_Detection, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_CM_To_ISAPNP, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_DevNode_Handler, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Detect_Resource_Conflict, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_Interface_List, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_Interface_List_Size, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Conflict_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Add_Remove_DevNode_Property, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_CallBack_At_Appy_Time, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Register_Device_Interface, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_System_Device_Power_State_Mapping, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Arbitrator_Info, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Waking_Up_From_DevNode, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Set_DevNode_Problem, VxD_CODE)
CONFIGMG_Service    (_CONFIGMG_Get_Device_Interface_Alias, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)


//
// struct pass to ConfigMG DeviceIOCTLs
//
//   (Taken from Millennium\root\pnp\dll\cfgmgr32\cm32api.h  -ks 1/13/2000)
//
struct    _WIN32CMIOCTLPACKET {
    DWORD    dwStack;
    DWORD    dwServiceNumber;
};

typedef struct _WIN32CMIOCTLPACKET  WIN32CMIOCTLPACKET;
typedef WIN32CMIOCTLPACKET         *PWIN32CMIOCTLPACKET;



// call into ConfigMG using the handle we obtained at process_attach
//
//   (Taken from Millennium\root\pnp\dll\cfgmgr32\cfgmgr32.c  -ks 1/13/2000)
//
CONFIGRET static WINAPI WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket)
{
    CONFIGRET   crReturnValue = CR_FAILURE;
    DWORD       dwReturnSize = 0;
    HANDLE      hCONFIGMG;

    hCONFIGMG = CreateFile("\\\\.\\CONFIGMG",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, NULL);
                            
    if (INVALID_HANDLE_VALUE == hCONFIGMG)
    {
//        MessageBox(NULL, "Could not get a handle to CONFIGMG.VXD returning CR_FAILURE!\n", "DEBUG", 0);
        CM32_WARNS(("Could not get a handle to CONFIGMG.VXD returning CR_FAILURE!\n"));
        return CR_FAILURE;
    }

    if (!DeviceIoControl(hCONFIGMG, pPacket->dwServiceNumber,
                &(pPacket->dwStack), sizeof(pPacket->dwStack),
                &crReturnValue, sizeof(crReturnValue), &dwReturnSize, NULL))
    {
//        char szDebug[1024];
//        wsprintf(szDebug, "ERROR: DeviceIoControl() failed with error 0x%X on service 0x%X\n",
//            GetLastError(), pPacket->dwServiceNumber);
//        MessageBox(NULL, szDebug, "DEBUG", 0);

        CM32_WARNS(("ERROR: DeviceIoControl() failed with error 0x%X on service 0x%X\n",
            GetLastError(), pPacket->dwServiceNumber));
        crReturnValue = CR_FAILURE;
    }        

    if (dwReturnSize != sizeof(crReturnValue))
    {
//        char szDebug[1024];
//        wsprintf(szDebug, "ERROR: DeviceIoControl() only returned %d bytes, expected %d!\n",
//            dwReturnSize, sizeof(crReturnValue));
//        MessageBox(NULL, szDebug, "DEBUG", 0);

        CM32_WARNS(("ERROR: DeviceIoControl() only returned %d bytes, expected %d!\n",
            dwReturnSize, sizeof(crReturnValue)));
        crReturnValue = CR_FAILURE;
    }        

    CloseHandle(hCONFIGMG);

//    {
//        char szDebug[1024];
//        wsprintf(szDebug, "WIN32CMIOCTLHandler returning with code 0x%08X", (LONG)crReturnValue);
//        MessageBox(NULL, szDebug, "DEBUG", 0);
//    }

    return(crReturnValue);
}


// CMWorker call ConfigMG on the original thread.
//
//   (Taken from Millennium\root\pnp\dll\cfgmgr32\cfgmgr32.c  -ks 1/13/2000)
//
CONFIGRET WINAPI CMWorker(DWORD dwStack, DWORD dwServiceNumber) 
{ 
    WIN32CMIOCTLPACKET Packet;

    Packet.dwStack = dwStack;
    Packet.dwServiceNumber = dwServiceNumber;

    return(WIN32CMIOCTLHandler(&Packet));
}

//
// WORKER will call ConfigMG on the original thread which is much faster but cannot be used for services which require
// configmg to do a system broadcast.
//
//   (Taken from Millennium\root\pnp\dll\cfgmgr32\cfgmgr32.c  -ks 1/13/2000)
//
#define WORKER(NAME)    \
            \
    DWORD   dwStack;        \
    _asm    {mov    dwStack, ebp};  \
    dwStack+=8;         \
    return(CMWorker(dwStack, CONFIGMG_W32IOCTL_RANGE+(GetVxDServiceOrdinal(_CONFIGMG_##NAME) & 0xFFFF)));

#endif // !defined(USE_CFGMGR32)


//////////////////////////////////////////////////////////////////////////////


#define CM_DISABLE_POLITE           (0x00000000)    // Ask the driver
#define CM_DISABLE_ABSOLUTE         (0x00000001)    // Don't ask the driver
#define CM_DISABLE_HARDWARE         (0x00000002)    // Don't ask the driver, and won't be restarteable
#define CM_DISABLE_BITS             (0x00000003)    // The bits for the disable function

#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be rebalanced
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed

#define CM_PROB_NOT_CONFIGURED       0x00000001
#define CM_PROB_DEVLOADER_FAILED     0x00000002
#define CM_PROB_OUT_OF_MEMORY        0x00000003
#define CM_PROB_ENTRY_IS_WRONG_TYPE  0x00000004
#define CM_PROB_LACKED_ARBITRATOR    0x00000005
#define CM_PROB_BOOT_CONFIG_CONFLICT 0x00000006
#define CM_PROB_FAILED_FILTER        0x00000007
#define CM_PROB_DEVLOADER_NOT_FOUND  0x00000008
#define CM_PROB_INVALID_DATA         0x00000009
#define CM_PROB_FAILED_START         0x0000000A
#define CM_PROB_LIAR                 0x0000000B
#define CM_PROB_NORMAL_CONFLICT      0x0000000C
#define CM_PROB_NOT_VERIFIED         0x0000000D
#define CM_PROB_NEED_RESTART         0x0000000E
#define CM_PROB_REENUMERATION        0x0000000F
#define CM_PROB_PARTIAL_LOG_CONF     0x00000010
#define CM_PROB_UNKNOWN_RESOURCE     0x00000011
#define CM_PROB_REINSTALL            0x00000012
#define CM_PROB_REGISTRY             0x00000013
#define CM_PROB_VXDLDR               0x00000014
#define CM_PROB_WILL_BE_REMOVED      0x00000015
#define CM_PROB_DISABLED             0x00000016
#define CM_PROB_DEVLOADER_NOT_READY  0x00000017
#define CM_PROB_DEVICE_NOT_THERE     0x00000018
#define CM_PROB_MOVED                0x00000019
#define CM_PROB_TOO_EARLY            0x0000001A
#define CM_PROB_NO_VALID_LOG_CONF    0x0000001B
#define CM_PROB_FAILED_INSTALL       0x0000001C
#define CM_PROB_HARDWARE_DISABLED    0x0000001D
#define CM_PROB_CANT_SHARE_IRQ       0x0000001E
#define NUM_CM_PROB                  0x0000001F


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


extern "C" CMAPI CONFIGRET WINAPI CM_Get_DevNode_Status(
        OUT PULONG   pulStatus,
        OUT PULONG   pulProblemNumber,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        )
{
#ifdef USE_CFGMGR32

    typedef CMAPI CONFIGRET (WINAPI * PROC_GetDevNodeStatus)(PULONG, PULONG, DEVINST, ULONG);
    CONFIGRET retval = CR_FAILURE;

    HINSTANCE hInstCfgMgr = LoadLibrary("cfgmgr32");
    if (hInstCfgMgr != NULL)
    {
        PROC_GetDevNodeStatus pfn = (PROC_GetDevNodeStatus)GetProcAddress(hInstCfgMgr, "CM_Get_DevNode_Status");
        if (pfn != NULL)
        {
            retval = (*pfn)(pulStatus, pulProblemNumber, dnDevInst, ulFlags);
        }
        FreeLibrary(hInstCfgMgr);
    }

    return retval;

#else // !defined(USE_CFGMGR32)

    WORKER(Get_DevNode_Status)

#endif
}


DWORD GetChildDevice( 
    OUT DWORD*        pdnChildInst,
    IN  DWORD         dnDevInst,
    IN OUT HINSTANCE* phInstance,
    IN  ULONG         ulFlags
    )
{
    typedef CMAPI CONFIGRET (WINAPI * PFNGETCHILD)(DEVINST*, DEVINST, ULONG);
    CONFIGRET retval = CR_FAILURE;
    
    if ( NULL == *phInstance )
    {
        *phInstance = LoadLibrary("cfgmgr32");
    }
    
    if ( NULL != *phInstance )
    {
        PFNGETCHILD pfn = (PFNGETCHILD)GetProcAddress(*phInstance, "CM_Get_Child");
        if (pfn != NULL)
        {
            retval = (*pfn)(pdnChildInst, dnDevInst, ulFlags);
        }
    }

    return retval;
}


DWORD GetSiblingDevice(
    OUT DWORD*     pdnChildInst,
    IN  DWORD      dnDevInst,
    IN  HINSTANCE  hInstance,
    IN  ULONG      ulFlags
    )
{
    typedef CMAPI CONFIGRET (WINAPI * PFNGETSIBLING)(DEVINST*, DEVINST, ULONG);
    CONFIGRET retval = CR_FAILURE;
    
    if ( NULL != hInstance )
    {
        PFNGETSIBLING pfn = (PFNGETSIBLING)GetProcAddress(hInstance, "CM_Get_Sibling");
        if (pfn != NULL)
        {
            retval = (*pfn)(pdnChildInst, dnDevInst, ulFlags);
        }
    }

    return retval;
}



DWORD GetDevNodeRegistryPropertyA(
    IN  DWORD       dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,
    OUT PVOID       Buffer,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    typedef CMAPI CONFIGRET (WINAPI * PFNGetDevNodeRegistryPropertyA)(DEVINST, ULONG, PULONG, PVOID, PULONG, ULONG);
    CONFIGRET retval = CR_FAILURE;

    HINSTANCE hInstCfgMgr = LoadLibrary("cfgmgr32");
    if (hInstCfgMgr != NULL)
    {
        PFNGetDevNodeRegistryPropertyA pfn = (PFNGetDevNodeRegistryPropertyA)GetProcAddress(hInstCfgMgr, "CM_Get_DevNode_Registry_PropertyA");
        if (pfn != NULL)
        {
            retval = (*pfn)(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags);
        }
        FreeLibrary(hInstCfgMgr);
    }

    return retval;
}


DWORD GetDeviceIdA(
    IN  DWORD   dnDevInst,
    OUT char**  Buffer,
    OUT ULONG*  pLength,
    IN  ULONG   ulFlags
    )
{    
    typedef CMAPI CONFIGRET (WINAPI * PFNGETDEVICEIDSIZE)(ULONG*, DEVINST, ULONG);
    typedef CMAPI CONFIGRET (WINAPI * PFNGETDEVICEID)(DEVINST, TCHAR*, ULONG, ULONG);

    CONFIGRET retval = CR_FAILURE;
    
    if ( Buffer )  *Buffer  = NULL;
    if ( pLength ) *pLength = 0L;
    
    if ( Buffer && pLength )
    {
        HINSTANCE hInstCfgMgr = LoadLibrary("cfgmgr32");
        
        if (hInstCfgMgr != NULL)
        {
            PFNGETDEVICEIDSIZE pfn = (PFNGETDEVICEIDSIZE)GetProcAddress(hInstCfgMgr, "CM_Get_Device_ID_Size");
            
            if ( pfn )
            {
                ULONG ulLen = 0;
            
                retval = (*pfn)(&ulLen, dnDevInst, 0);
                
                if ( CR_SUCCESS == retval )
                {
                    TCHAR* DeviceIdBuffer = new TCHAR[ ulLen ];
                    
                    retval = CR_FAILURE;
                    
                    if ( DeviceIdBuffer )
                    {
                        PFNGETDEVICEID pfnGet = (PFNGETDEVICEID)GetProcAddress(hInstCfgMgr, "CM_Get_Device_IDA");
                        
                        if ( pfnGet )
                        {
                            retval = (*pfnGet)(dnDevInst, DeviceIdBuffer, ulLen, ulFlags);
                            
                            if ( CR_SUCCESS == retval )
                            {
                                *Buffer  = DeviceIdBuffer;
                                *pLength = ulLen;
                            }
                        }
                        
                        if ( CR_SUCCESS != retval )
                        {
                            delete [] DeviceIdBuffer;
                        }
                    }
                }
            }

            FreeLibrary(hInstCfgMgr);
        }
    }

    return retval;
}


BOOL WINAPI IsNetAdapterBroken(const NETADAPTER* pAdapter)
{
    BOOL bBroken = FALSE;

    DWORD dwStatus, dwProblemNumber;
    if (GetNetAdapterStatus(pAdapter, &dwStatus, &dwProblemNumber))
    {
        UINT nProblem = LOWORD(dwProblemNumber);
        if (nProblem != 0)
            bBroken = TRUE;
    }

    return bBroken;
}

BOOL WINAPI GetNetAdapterStatus(const NETADAPTER* pAdapter, DWORD* pdwStatus, DWORD* pdwProblemNumber)
{
    BOOL    bGotStatus = FALSE;
    DEVNODE dn         = pAdapter->devnode;
    ULONG   Status     = 0L;
    ULONG   Problem    = 0L;
    
    if ( NULL != dn )
    {
        if ( CM_Get_DevNode_Status(&Status, &Problem, dn, 0) == CR_SUCCESS )
        {
            bGotStatus = TRUE;
        }
        else
        {
            Status     = 0L;
            Problem    = 0L;
        }
    }
    
    if ( pdwStatus )        *pdwStatus        = Status;
    if ( pdwProblemNumber ) *pdwProblemNumber = Problem;

    return bGotStatus;
}


DWORD WINAPI GetNetAdapterDevNode(NETADAPTER* pAdapter)
{
    HRESULT hr;
    DEVNODE dn;
    DWORD   dwFreePointer;

    // REVIEW: this is not robust if there is more than one matching device
    hr = LookupDevNode16(NULL, _T("Net"), pAdapter->szEnumKey, &dn, &dwFreePointer);
    
    if ( SUCCEEDED(hr) )
    {
        pAdapter->devnode = dn;
    
        FreeDevNode16(dwFreePointer);
    }

    return dn;
}


HRESULT WINAPI RestartNetAdapter(DWORD devnode)
{
    HRESULT hr = E_FAIL;
    
    typedef CMAPI CONFIGRET (WINAPI* PFNDISABLEDEVNODE)(DEVINST, ULONG);
    typedef CMAPI CONFIGRET (WINAPI* PFNENABLEDEVNODE)(DEVINST, ULONG);
    typedef CMAPI CONFIGRET (WINAPI* PFNGETDEVNODESTATUS)(PULONG, PULONG, DEVINST, ULONG);
    typedef CMAPI CONFIGRET (WINAPI* PFNGETGLOBALSTATE)(PULONG, ULONG);

    HINSTANCE hInstCfgMgr = LoadLibrary("cfgmgr32");
    
    if ( hInstCfgMgr )
    {
        PFNDISABLEDEVNODE   pfnDisableDevnode = 
            (PFNDISABLEDEVNODE)GetProcAddress(hInstCfgMgr, "CM_Disable_DevNode");
        PFNENABLEDEVNODE    pfnEnableDevnode =
            (PFNDISABLEDEVNODE)GetProcAddress(hInstCfgMgr, "CM_Enable_DevNode");
        PFNGETDEVNODESTATUS pfnGetDevNodeStatus =
            (PFNGETDEVNODESTATUS)GetProcAddress(hInstCfgMgr, "CM_Get_DevNode_Status");
        PFNGETGLOBALSTATE pfnGetGlobalState =
            (PFNGETGLOBALSTATE)GetProcAddress(hInstCfgMgr, "CM_Get_Global_State");
    
        if ( pfnDisableDevnode && pfnEnableDevnode && pfnGetDevNodeStatus )
        {
            CONFIGRET retval;
        
            retval = (*pfnDisableDevnode)( devnode, CM_DISABLE_ABSOLUTE );
            
            if ( CR_SUCCESS == retval )
            {
                ULONG Status     = 0L;
                ULONG Problem    = 0L;
                ULONG TimeToWait = 60L;

                do
                {
                    Sleep( 1000 );
                    
                    retval = (*pfnGetDevNodeStatus)( &Status, &Problem, devnode, 0 );
                }
                while ( (CR_SUCCESS == retval) && (CM_PROB_DISABLED != Problem) && (--TimeToWait) );
                
                if ( CR_SUCCESS == retval )
                {
                    retval = pfnEnableDevnode( devnode, 0 );
                    
                    if ( CR_SUCCESS == retval )
                    {
                        TimeToWait = 60L;
                        
                        do
                        {
                            Sleep( 1000 );
                            
                            if ( pfnGetGlobalState )
                            {
                                retval = pfnGetGlobalState( &Status, 0 );
                            }
                            else
                            {
                                retval = (*pfnGetDevNodeStatus)( &Status, &Problem, devnode, 0 );
                            }
                        }
                        while ( (CR_SUCCESS == retval) && (DN_HAS_PROBLEM & Status) && (--TimeToWait) );
                            
                        if ( CR_SUCCESS == retval )
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
        }
        
        FreeLibrary( hInstCfgMgr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\nconnwrap.h ===
#define SZ_CLASS_CLIENT         SZ_CLASS_CLIENTA
#define SZ_CLIENT_MICROSOFT     SZ_CLIENT_MICROSOFTA
#define SZ_CLASS_PROTOCOL       SZ_CLASS_PROTOCOLA
#define SZ_CLASS_ADAPTER        SZ_CLASS_ADAPTERA
#define SZ_PROTOCOL_IPXSPX      SZ_PROTOCOL_IPXSPXA
#define SZ_PROTOCOL_TCPIP       SZ_PROTOCOL_TCPIPA
#define SZ_CLASS_SERVICE        SZ_CLASS_SERVICEA
#define SZ_SERVICE_VSERVER      SZ_SERVICE_VSERVERA



typedef struct tagNETADAPTERA {
	CHAR szDisplayName[260];		// so-called friendly name of adapter
	CHAR szDeviceID[260];			// e.g. "PCI\VEN_10b7&DEV_9050"
	CHAR szEnumKey[260];			// e.g. "Enum\PCI\VEN_10b7&DEV_9050&SUBSYS_00000000&REV_00\407000"
	CHAR szClassKey[40];			// PnP-assigned class name + ID, e.g. "Net\0000"
	CHAR szManufacturer[60];		// Company that manufactured the card, e.g. "3Com"
	CHAR szInfFileName[50];			// File title of INF file, e.g. "NETEL90X.INF"
	BYTE bNicType;					// a NIC_xxx constant, defined above
	BYTE bNetType;					// a NETTYPE_xxx constant, defined above
	BYTE bNetSubType;				// a SUBTYPE_xxx constant, defined above
	BYTE bIcsStatus;				// an ICS_xxx constant, defined above
	BYTE bError;					// a NICERR_xxx constant, defined above
	BYTE bWarning;					// a NICWARN_xxx constant, defined above
	DWORD devnode;                  // configmg device node
} NETADAPTERA;

typedef struct tagNETSERVICEA {
	CHAR szDisplayName[260];		// (supposedly) friendly name of service
	CHAR szDeviceID[260];			// e.g. "VSERVER"
	CHAR szClassKey[40];			// PnP-assigned class name + ID, e.g. "NetService\0000"
} NETSERVICEA;

#define NETADAPTER              NETADAPTERA
#define NETSERVICE              NETSERVICEA




#define SZ_CLASS_ADAPTERA	 "Net"
#define SZ_CLASS_CLIENTA	 "NetClient"
#define SZ_CLASS_PROTOCOLA	 "NetTrans"
#define SZ_CLASS_SERVICEA	 "NetService"

#define SZ_PROTOCOL_TCPIPA	 "MSTCP"
#define SZ_PROTOCOL_NETBEUIA "NETBEUI"
#define SZ_PROTOCOL_IPXSPXA	 "NWLINK"

#define SZ_SERVICE_VSERVERA	 "VSERVER"
#define SZ_CLIENT_MICROSOFTA "VREDIR"
#define SZ_CLIENT_NETWAREA	 "NWREDIR"




#define EnumNetAdapters             EnumNetAdaptersA
#define IsProtocolBoundToAdapter    IsProtocolBoundToAdapterA
#define IsAdapterBroadband          IsAdapterBroadbandA

int WINAPI EnumNetAdaptersA(NETADAPTERA FAR** pprgNetAdapters);
BOOL WINAPI IsProtocolBoundToAdapterA(LPCSTR pszProtocolID, const NETADAPTERA* pAdapter);
BOOL WINAPI IsAdapterBroadbandA(const NETADAPTERA* pAdapter);
//HRESULT WINAPI InstallNetAdapterA(LPCSTR pszDeviceID, LPCSTR pszInfPath, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvCallbackParam);
BOOL WINAPI IsClientInstalledA(LPCSTR pszClientDeviceID, BOOL bExhaustive);
void WINAPI SaveBroadbandSettingsA(LPCSTR pszBroadbandAdapterNumber);
HRESULT WINAPI DetectHardwareA(LPCSTR pszDeviceID);
void WINAPI EnableAutodialA(BOOL bAutodial, LPCSTR szConnection = NULL);
void WINAPI SetDefaultDialupConnectionA(LPCSTR pszConnectionName);
void WINAPI GetDefaultDialupConnectionA(LPSTR pszConnectionName, int cchMax);
int WINAPI EnumMatchingNetBindingsA(LPCSTR pszParentBinding, LPCSTR pszDeviceID, LPSTR** pprgBindings);



#define IsProtocolInstalled         IsProtocolInstalledA
#define InstallProtocol             InstallProtocolA
#define RemoveProtocol              RemoveProtocolA
#define FindConflictingService      FindConflictingServiceA
//#define EnumNetAdapters             EnumNetAdaptersA
#define InstallNetAdapter           InstallNetAdapterA
//#define IsProtocolBoundToAdapter    IsProtocolBoundToAdapterA
#define EnableNetAdapter            EnableNetAdapterA
#define IsClientInstalled           IsClientInstalledA
#define RemoveClient                RemoveClientA
#define RemoveGhostedAdapters       RemoveGhostedAdaptersA
#define RemoveUnknownAdapters       RemoveUnknownAdaptersA
#define DoesAdapterMatchDeviceID    DoesAdapterMatchDeviceIDA
//#define IsAdapterBroadband          IsAdapterBroadbandA
#define SaveBroadbandSettings       SaveBroadbandSettingsA
#define UpdateBroadbandSettings     UpdateBroadbandSettingsA
#define DetectHardware              DetectHardwareA
#define EnumMatchingNetBindings     EnumMatchingNetBindingsA
#define EnableAutodial              EnableAutodialA
#define SetDefaultDialupConnection  SetDefaultDialupConnectionA
#define GetDefaultDialupConnection  GetDefaultDialupConnectionA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\nconnwrap.cpp ===
#include <windows.h>

#include "netconn.h"
#include "nconnwrap.h"


#pragma warning(disable:4100)  // unreferenced formal parameter

#define ARRAYSIZE(a)  (sizeof(a) / sizeof((a)[0]))
#define ASSERT(a)

BOOL WINAPI IsProtocolInstalledA(LPCSTR pszProtocolDeviceID, BOOL bExhaustive);
HRESULT WINAPI InstallProtocolA(LPCSTR pszProtocol, HWND hwndParent, PROGRESS_CALLBACK pfnCallback, LPVOID pvCallbackParam);
HRESULT WINAPI RemoveProtocolA(LPCSTR pszProtocol);
BOOL WINAPI FindConflictingServiceA(LPCSTR pszWantService, NETSERVICE* pConflict);


//
// String helper class.  Takes in a WCHAR string and converts it to multibyte.
// Allocates and frees space if the string is long.
//

class CStrIn
{
public:
    CStrIn(LPCWSTR pwsz);
    ~CStrIn();
    operator char*() {return _psz;};

private:
    LPSTR  _psz;
    char   _sz[128];
};

CStrIn::CStrIn(LPCWSTR pwsz)
{
    if (pwsz)
    {
        //
        // If a string was passed in always return a string  - even if it's
        // the empty string.
        //

        _psz = _sz;

        int cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, _sz, ARRAYSIZE(_sz),
                                      NULL, NULL);

        //
        // If the conversion failed try to allocate a buffer to hold the
        // multibyte version of the string.
        //

        if (0 == cch)
        {
            *_sz = '\0';

            cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);

            if (cch)
            {
                _psz = new char[cch];

                if (_psz)
                {
                    cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, _psz, cch,
                                              NULL, NULL);

                    if (0 == cch)
                    {
                        delete [] _psz;
                        _psz = _sz;
                    }
                }
                else
                {
                    _psz = _sz;
                }
            }
        }
    }
    else
    {
        _psz = NULL;
    }
}

CStrIn::~CStrIn()
{
    if (_psz != _sz && _psz)
    {
        delete [] _psz;
    }
}


//
//
//

class CStrOut
{
public:
    CStrOut(LPWSTR psz, int cch);
    operator LPSTR() { return _sz;}
    operator int()    { return ARRAYSIZE(_sz);}
    void Convert();

private:
    LPWSTR  _psz;
    int     _cch;
    char    _sz[MAX_PATH];
};

CStrOut::CStrOut(LPWSTR psz, int cch)
{
    ASSERT(cch <= ARRAYSIZE(_sz));

    _psz = psz;
    _cch = cch;
}

void CStrOut::Convert()
{
    if (_psz)
    {
        MultiByteToWideChar(CP_ACP, 0, _sz, -1, _psz, _cch);
    }
}

//
//
//

class CStrsOut
{
public:
    CStrsOut(LPWSTR** pppsz) {_pStructW = pppsz;};

    operator LPSTR**() {return _pStructW ? &_pStructA : NULL;};
    int Convert(int cStrs);

private:
    int   ConvertStruct(LPSTR* pStructA, int nStrs, LPWSTR* pStructW, LPWSTR pszLast);
    DWORD SizeOfWideCharStruct(LPSTR* pStructA, int cStrs);
    DWORD SizeOfPointerArea(int cStrs);
    DWORD SizeOfWideCharStringArea(LPSTR* pStruct, int cStrs);
    LPSTR EndOfLastString(LPSTR* pStruct, int cStrs);
    LPSTR StartOfFirstString(LPSTR* pStruct);

private:
    LPWSTR** _pStructW;
    LPSTR*   _pStructA;

};

int CStrsOut::ConvertStruct(LPSTR* pStructA, int nStrs, LPWSTR* pStructW, LPWSTR pszLast)
{
    ASSERT(pStructA);
    ASSERT(nStrs);
    ASSERT(pStructW);

    int nRet;

    LPWSTR pszCurrent = (LPWSTR)&pStructW[nStrs];

    for (nRet = 0; nRet < nStrs; nRet++)
    {
        pStructW[nRet] = pszCurrent;

        pszCurrent += MultiByteToWideChar(CP_ACP, 0, pStructA[nRet], -1,
                                          pszCurrent, pszLast - pszCurrent);
    }

    return nRet;
}

int CStrsOut::Convert(int cStrs)
{
    int nRet;

    if (_pStructW)
    {
        nRet = 0;

        if (_pStructA)
        {
            DWORD cbStruct = SizeOfWideCharStruct(_pStructA, cStrs);

            *_pStructW = (LPWSTR*)NetConnAlloc(cbStruct);

            if (*_pStructW)
            {
                nRet = ConvertStruct(_pStructA, cStrs, *_pStructW,
                                     (LPWSTR)((BYTE*)*_pStructW + cbStruct));
            }

            NetConnFree(_pStructA);
        }
        else
        {
            *_pStructW = NULL;
        }
    }
    else
    {
        nRet = cStrs;
    }

    return nRet;
}

inline LPSTR CStrsOut::EndOfLastString(LPSTR* pStructA, int nStrs)
{
    return pStructA[nStrs - 1] + lstrlenA(pStructA[nStrs - 1]);
}

inline LPSTR CStrsOut::StartOfFirstString(LPSTR* pStructA)
{
    return *pStructA;
}

inline DWORD CStrsOut::SizeOfWideCharStringArea(LPSTR* pStructA, int nStrs)
{
    return ((EndOfLastString(pStructA, nStrs) + 1) - StartOfFirstString(pStructA))
            * sizeof(WCHAR);
}

inline DWORD CStrsOut::SizeOfPointerArea(int nStrs)
{
    return nStrs * sizeof(LPWSTR);
}

DWORD CStrsOut::SizeOfWideCharStruct(LPSTR* pStructA, int nStrs)
{
    return SizeOfPointerArea(nStrs) + SizeOfWideCharStringArea(pStructA, nStrs);
}


//
// Netservice helper class.  Passes in an ansi NETSERVICE structure when
// cast to NETSERVICEA.  Copies the ansi structure to a unicode structure
// coverting the strings.
//

#undef NETSERVICE

class CNetServiceOut
{

public:
    CNetServiceOut(NETSERVICE* pNS) {_pNS = pNS;};

    operator NETSERVICEA*() {return _pNS ? &_NSA : NULL;};
    void Convert();


private:
    NETSERVICEA _NSA;
    NETSERVICE* _pNS;
};

void CNetServiceOut::Convert()
{
    if (_pNS)
    {
        MultiByteToWideChar(CP_ACP, 0, _NSA.szClassKey, -1, _pNS->szClassKey,
                            ARRAYSIZE(_pNS->szClassKey));

        MultiByteToWideChar(CP_ACP, 0, _NSA.szDeviceID, -1, _pNS->szDeviceID,
                            ARRAYSIZE(_pNS->szDeviceID));

        MultiByteToWideChar(CP_ACP, 0, _NSA.szDisplayName, -1, _pNS->szDisplayName,
                            ARRAYSIZE(_pNS->szDisplayName));
    }
}


//
//
//

#undef NETADAPTER

class CNetAdaptersOut
{
public:
    CNetAdaptersOut(NETADAPTER** ppNA) {_ppNA = ppNA;};

    operator NETADAPTERA**(){return _ppNA ? &_pNAA : NULL;};
    int Convert(int cNAA);

private:
    void ConvertNA(NETADAPTERA* pNAA, NETADAPTER* pNA);

private:
    NETADAPTERA* _pNAA;
    NETADAPTER** _ppNA;
};

int CNetAdaptersOut::Convert(int cNAA)
{
    int nRet = 0;

    *_ppNA = NULL;

    if (cNAA > 0)
    {
        if (_pNAA)
        {
            *_ppNA = (NETADAPTER*)NetConnAlloc(sizeof(NETADAPTER) * cNAA);

            if (*_ppNA)
            {
                for (nRet = 0; nRet < cNAA; nRet++)
                {
                    ConvertNA(&_pNAA[nRet], &(*_ppNA)[nRet]);
                }

                NetConnFree(_pNAA);
            }
        }
    }

    return nRet;
}

void CNetAdaptersOut::ConvertNA(NETADAPTERA* pNAA, NETADAPTER* pNA)
{
    ASSERT(pNAA);
    ASSERT(pNA);

    MultiByteToWideChar(CP_ACP, 0, pNAA->szDisplayName, -1, pNA->szDisplayName,
                        ARRAYSIZE(pNA->szDisplayName));

    MultiByteToWideChar(CP_ACP, 0, pNAA->szDeviceID, -1, pNA->szDeviceID,
                        ARRAYSIZE(pNA->szDeviceID));

    MultiByteToWideChar(CP_ACP, 0, pNAA->szEnumKey, -1, pNA->szEnumKey,
                        ARRAYSIZE(pNA->szEnumKey));

    MultiByteToWideChar(CP_ACP, 0, pNAA->szClassKey, -1, pNA->szClassKey,
                        ARRAYSIZE(pNA->szClassKey));

    MultiByteToWideChar(CP_ACP, 0, pNAA->szManufacturer, -1, pNA->szManufacturer,
                        ARRAYSIZE(pNA->szManufacturer));

    MultiByteToWideChar(CP_ACP, 0, pNAA->szInfFileName, -1, pNA->szInfFileName,
                        ARRAYSIZE(pNA->szInfFileName));

    pNA->bNicType    = pNAA->bNicType;
    pNA->bNetType    = pNAA->bNetType;
    pNA->bNetSubType = pNAA->bNetSubType;
    pNA->bIcsStatus  = pNAA->bIcsStatus;
    pNA->bError      = pNAA->bError;
    pNA->bWarning    = pNAA->bWarning;
    pNA->devnode     = pNAA->devnode;
}


//
//
//

class CNetAdapterIn
{
public:
    CNetAdapterIn(const NETADAPTER* pNA);

    operator NETADAPTERA*() {return _pNA ? &_NAA : NULL;};

private:
    const NETADAPTER* _pNA;
    NETADAPTERA       _NAA;
};

CNetAdapterIn::CNetAdapterIn(const NETADAPTER* pNA)
{
    _pNA = pNA;

    if (pNA)
    {
        WideCharToMultiByte(CP_ACP, 0, pNA->szDisplayName, -1, _NAA.szDisplayName,
                            ARRAYSIZE(_NAA.szDisplayName), NULL, NULL);

        WideCharToMultiByte(CP_ACP, 0, pNA->szDeviceID, -1, _NAA.szDeviceID,
                            ARRAYSIZE(_NAA.szDeviceID), NULL, NULL);

        WideCharToMultiByte(CP_ACP, 0, pNA->szEnumKey, -1, _NAA.szEnumKey,
                            ARRAYSIZE(_NAA.szEnumKey), NULL, NULL);

        WideCharToMultiByte(CP_ACP, 0, pNA->szClassKey, -1, _NAA.szClassKey,
                            ARRAYSIZE(_NAA.szClassKey), NULL, NULL);

        WideCharToMultiByte(CP_ACP, 0, pNA->szManufacturer, -1, _NAA.szManufacturer,
                            ARRAYSIZE(_NAA.szManufacturer), NULL, NULL);

        WideCharToMultiByte(CP_ACP, 0, pNA->szInfFileName, -1, _NAA.szInfFileName,
                            ARRAYSIZE(_NAA.szInfFileName), NULL, NULL);

        _NAA.bNicType    = pNA->bNicType;
        _NAA.bNetType    = pNA->bNetType;
        _NAA.bNetSubType = pNA->bNetSubType;
        _NAA.bIcsStatus  = pNA->bIcsStatus;
        _NAA.bError      = pNA->bError;
        _NAA.bWarning    = pNA->bWarning;
    }
}

//
//
//


#undef IsProtocolInstalled

BOOL WINAPI IsProtocolInstalled(LPCWSTR pszProtocolDeviceID, BOOL bExhaustive)
{
    CStrIn CStrProtocolDeviceID(pszProtocolDeviceID);

    return IsProtocolInstalledA(CStrProtocolDeviceID, bExhaustive);
}

#undef InstallProtocol

HRESULT WINAPI InstallProtocol(LPCWSTR pszProtocol, HWND hwndParent, PROGRESS_CALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    CStrIn CStrProtocol(pszProtocol);

    return InstallProtocolA(CStrProtocol, hwndParent, pfnCallback, pvCallbackParam);
}

#undef RemoveProtocol

HRESULT WINAPI RemoveProtocol(LPCWSTR pszProtocol)
{
    CStrIn CStrProtocol(pszProtocol);

    return RemoveProtocolA(CStrProtocol);
}

#undef FindConflictingService

BOOL WINAPI FindConflictingService(LPCWSTR pszWantService, NETSERVICE* pConflict)
{
    BOOL fRet;

    CStrIn         CStrWantService(pszWantService);
    CNetServiceOut CNSConflict(pConflict);

    fRet = FindConflictingServiceA(CStrWantService, CNSConflict);

    if (fRet)
    {
        CNSConflict.Convert();
    }

    return fRet;
}

#undef EnumNetAdapters

int WINAPI EnumNetAdapters(NETADAPTER FAR** pprgNetAdapters)
{
    int nRet;

    CNetAdaptersOut CNANetAdapters(pprgNetAdapters);

    nRet = EnumNetAdaptersA(CNANetAdapters);

    nRet = CNANetAdapters.Convert(nRet);

    return nRet;
}

/*
#undef InstallNetAdapters

HRESULT WINAPI InstallNetAdapter(LPCWSTR pszDeviceID, LPCWSTR pszInfPath, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvCallbackParam)
{
    CStrIn CStrDeviceID(pszDeviceID);
    CStrIn CStrInfPath(pszInfPath);

    return InstallNetAdapterA(CStrDeviceID, CStrInfPath, hwndParent, pfnProgress, pvCallbackParam);
}
*/

#undef IsProtocolBoundToAdapter

BOOL WINAPI IsProtocolBoundToAdapter(LPCWSTR pszProtocolID, const NETADAPTER* pAdapter)
{
    CStrIn        CStrProtocolID(pszProtocolID);
    CNetAdapterIn CNAAdapter(pAdapter);

    return IsProtocolBoundToAdapterA(CStrProtocolID, CNAAdapter);
}

/*
#undef ENableNetAdapter

HRESULT WINAPI EnableNetAdapter(const NETADAPTER* pAdapter)
{
    CNetAdapterIn CNAAdapter(pAdapter);

    return EnableNetAdapterA(CNAAdapter);
}
*/

#undef IsClientInstalled

BOOL WINAPI IsClientInstalled(LPCWSTR pszClient, BOOL bExhaustive)
{
    CStrIn CStrClient(pszClient);

    return IsClientInstalledA(CStrClient, bExhaustive);
}

/*
#undef RemoveClient

HRESULT WINAPI RemoveClient(LPCWSTR pszClient)
{
    CStrIn CStrClient(pszClient);

    return RemoveClientA(pszClient);
}
*/

/*
#undef RemoveGhostedAdapters

HRESULT WINAPI RemoveGhostedAdapters(LPCWSTR pszDeviceID)
{
    CStrIn CStrDeviceID(pszDeviceID);

    return RemoveGhostedAdaptersA(CStrDeviceID);
}
*/

/*
#undef RemoveUnknownAdapters

HRESULT WINAPI RemoveUnknownAdapters(LPCWSTR pszDeviceID)
{
    CStrIn CStrDeviceID(pszDeviceID);

    return RemoveUnknownAdaptersA(CStrDeviceID);
}
*/

/*
#undef DoesAdapterMatchDeviceID

BOOL WINAPI DoesAdapterMatchDeviceID(const NETADAPTER* pAdapter, LPCWSTR pszDeviceID)
{
    CNetAdapterIn CNAAdapter(pAdapter);
    CStrIn        CStrDeviceID(pszDeviceID);

    return DoesAdapterMatchDeviceIDA(CNAAdapter, CStrDeviceID);
}
*/

#undef IsAdapterBroadband

BOOL WINAPI IsAdapterBroadband(const NETADAPTER* pAdapter)
{
    CNetAdapterIn CNAAdapter(pAdapter);

    return IsAdapterBroadbandA(CNAAdapter);
}

#undef SaveBroadbandSettings

void WINAPI SaveBroadbandSettings(LPCWSTR pszBroadbandAdapterNumber)
{
    CStrIn CStrBroadbandAdapterNumber(pszBroadbandAdapterNumber);

    SaveBroadbandSettingsA(CStrBroadbandAdapterNumber);
}

/*
#undef UpdateBroadbandSettings

BOOL WINAPI UpdateBroadbandSettings(LPWSTR pszEnumKeyBuf, int cchEnumKeyBuf)
{
    return FALSE;
}
*/

#undef DetectHardware

HRESULT WINAPI DetectHardware(LPCWSTR pszDeviceID)
{
    CStrIn CStrDeviceID(pszDeviceID);

    return DetectHardwareA(CStrDeviceID);
}

#undef EnableAutodial

void WINAPI EnableAutodial(BOOL bAutodial, LPCWSTR pszConnection)
{
    CStrIn CStrConnection(pszConnection);

    EnableAutodialA(bAutodial, CStrConnection);
}

#undef SetDefaultDialupConnection

void WINAPI SetDefaultDialupConnection(LPCWSTR pszConnectionName)
{
    CStrIn CStrConnectionName(pszConnectionName);

    SetDefaultDialupConnectionA(CStrConnectionName);
}

#undef GetDefaultDialupConnection

void WINAPI GetDefaultDialupConnection(LPWSTR pszConnectionName, int cchMax)
{
    CStrOut CStrConnectionName(pszConnectionName, cchMax);

    GetDefaultDialupConnectionA(CStrConnectionName, CStrConnectionName);

    CStrConnectionName.Convert();
}

#undef EnumMatchingNetBindings

int WINAPI EnumMatchingNetBindings(LPCWSTR pszParentBinding, LPCWSTR pszDeviceID, LPWSTR** pprgBindings)
{
    int nRet;

    CStrIn   CStrParentBinding(pszParentBinding);
    CStrIn   CStrDeviceID(pszDeviceID);
    CStrsOut CStrsBindings(pprgBindings);

    nRet = EnumMatchingNetBindingsA(CStrParentBinding, CStrDeviceID, CStrsBindings);

    nRet = CStrsBindings.Convert(nRet);

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\netcli.h ===
//
// NetCli.h
//

#pragma once

HRESULT CreateNewClientForMSNet(LPSTR pszBuf, int cchBuf, LPCSTR pszServiceBinding);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\netmisc.cpp ===
//
// NetMisc.cpp
//
//		Networking APIs that don't fit into any of the other big buckets
//
// History:
//
//		10/21/1999  KenSh     Created (adapted from JetNet source code)
//

#include "stdafx.h"
#include "NetConn.h"
#include "theapp.h"



static const LPCTSTR c_rgUserLevelVxD[] = { _T("FILESEC"), _T("MSSP") };

BOOL WINAPI IsAccessControlUserLevel()
{
	CRegistry reg;

	for (int i = 0; i < _countof(c_rgUserLevelVxD); i++)
	{
		if (reg.OpenKey(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\VxD"), KEY_READ))
		{
			if (reg.OpenSubKey(c_rgUserLevelVxD[i]))
				return TRUE;
		}
	}

	if (reg.OpenKey(HKEY_LOCAL_MACHINE, _T("Security\\Provider"), KEY_QUERY_VALUE))
	{
		DWORD dwPlatformType;
		if (reg.QueryDwordValue(_T("Platform_Type"), &dwPlatformType))
		{
			if (dwPlatformType != 0)
				return TRUE;
		}
	}

	return FALSE;
}

HRESULT WINAPI DisableUserLevelAccessControl()
{
	HRESULT hr = NETCONN_SUCCESS;

	CRegistry reg;

	for (int i = 0; i < _countof(c_rgUserLevelVxD); i++)
	{
		reg.OpenKey(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\VxD"));
		if (ERROR_SUCCESS == RegDeleteKeyAndSubKeys(reg.m_hKey, c_rgUserLevelVxD[i]))
			hr = NETCONN_NEED_RESTART;
	}

	reg.OpenKey(HKEY_LOCAL_MACHINE, _T("Security\\Provider"), KEY_SET_VALUE);
	DWORD dwPlatformType = 0;
	reg.SetBinaryValue(_T("Platform_Type"), &dwPlatformType, sizeof(DWORD));

	return hr;
}

HRESULT WINAPI IcsUninstall(void)
{
    return IcsUninstall16();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\registry.cpp ===
#include "..\shared\registry.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\netip.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T I P. C P P
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <devguid.h>
#include <objbase.h>
#include <setupapi.h>
#include <stdio.h>

#include "netconn.h"
#include "nconnwrap.h"
#include "debug.h"
#include "NetIp.h"
#include "w9xdhcp.h"
#include "netip.h"
#include "util.h"
#include "registry.h"
#include "theapp.h"

//#define INITGUID
//#include <guiddef.h>
//DEFINE_GUID( GUID_DEVCLASS_NET, 0x4d36e972L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );


#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)


#undef NETADAPTER


// Prototype for iphlpapi routine. For some reason, this isn't defined
// in any header.

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD (APIENTRY *LPFNSETADAPTERIPADDRESS)( 
    LPSTR AdapterName,
    BOOL EnableDHCP,
    ULONG IPAddress,
    ULONG SubnetMask,
    ULONG DefaultGateway
    );
    
#ifdef __cplusplus
}
#endif



HRESULT HrInternalGetAdapterInfo(
    PIP_ADAPTER_INFO*  ppAdapter
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrInternalGetAdapterInfo
//
//  Purpose:    
//
//  Arguments:  PIP_ADAPTER_INFO*  ppAdapter
//
//  Returns:    HRESULT
//
//  Author:     billi  12/02/01
//
//  Notes:      
//
{
    HRESULT          hr;
    PIP_ADAPTER_INFO paAdapterInfo = NULL;
    
    ASSERT( ppAdapter );
    
    if ( NULL == ppAdapter )
    {
        ppAdapter = &paAdapterInfo;
        hr        = E_POINTER;
    }
    else
    {
        ULONG uLen = 1024;
    
        *ppAdapter = NULL;
        hr         = E_FAIL;

        for ( int i=0; i<2; i++ )
        {
            PIP_ADAPTER_INFO pInfo = (PIP_ADAPTER_INFO)new BYTE[ uLen ];
            
            ZeroMemory( pInfo, uLen );
            
            if ( NULL != pInfo )
            {
                DWORD dwErr = GetAdaptersInfo( pInfo, &uLen );
                
                if ( ERROR_SUCCESS == dwErr )
                {
                    hr         = S_OK;
                    *ppAdapter = pInfo;
                    break;
                }

                delete [] (BYTE *)pInfo;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    
    return hr;
}

/*

HRESULT HrOpenDevRegKey( 
    const GUID* lpGuid,
    DWORD   Node,
    DWORD   Scope,
    DWORD   HwProfile,
    DWORD   KeyType,
    REGSAM  samDesired,
    HKEY*   phKey
    )
//+---------------------------------------------------------------------------
//
//  Function:   Hr
//
//  Purpose:    
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//  Author:     billi  12/02/01
//
//  Notes:      
//
{
    HRESULT hr = E_INVALIDARG;
    
    ASSERT( lpGuid );
    
    if ( lpGuid )
    {
        hr = E_POINTER;
    
        ASSERT( phKey );
        
        if ( phKey )
        {
            // The only way to open a specific device is to get the list of Class "Net" devices
            // and search the list for one with a matching devnode
        
            HDEVINFO hDevInfo;
            
            *phKey   = (HKEY)INVALID_HANDLE_VALUE;
            hr       = E_FAIL;
            hDevInfo = SetupDiGetClassDevs( lpGuid, NULL, NULL, DIGCF_DEVICEINTERFACE );
            
            if ( INVALID_HANDLE_VALUE != hDevInfo )
            {
                SP_DEVINFO_DATA SpData;
                DWORD           i = 0;
                
                // Here we walk the list of devices and try to match the devnode handles
                
                ZeroMemory( &SpData, sizeof(SP_DEVINFO_DATA) );
                SpData.cbSize = sizeof(SP_DEVINFO_DATA);
                
                while ( SetupDiEnumDeviceInfo( hDevInfo, i, &SpData ) )
                {
                    if ( Node == SpData.DevInst )
                    {
                        // Got it!
                
                        HKEY hKey = 
                            SetupDiOpenDevRegKey( hDevInfo, &SpData, Scope, HwProfile, KeyType, samDesired );
                            
                        if ( INVALID_HANDLE_VALUE != hKey )
                        {
                            *phKey = hKey;
                            hr     = S_OK;
                        }
                    }
                    
                    i++;
                    ZeroMemory( &SpData, sizeof(SP_DEVINFO_DATA) );
                    SpData.cbSize = sizeof(SP_DEVINFO_DATA);
                }
            
                SetupDiDestroyDeviceInfoList( hDevInfo );
            }
        }
    }    
    
    return hr;
}
*/


#ifdef __cplusplus
extern "C" {
#endif



char*
HostAddrToIpPsz(
    DWORD   dwAddress
    )

// Converts IP Address from host by order to string

{
    char *pszNewStr = new char[16];

    if ( pszNewStr )
    {
        sprintf( pszNewStr,
                 "%u.%u.%u.%u",
                 (dwAddress&0xff),
                 ((dwAddress>>8)&0x0ff),
                 ((dwAddress>>16)&0x0ff),
                 ((dwAddress>>24)&0x0ff) );
    }

    return pszNewStr;
}



BOOLEAN WINAPI IsAdapterDisconnected(
    VOID *pContext
    )
//+---------------------------------------------------------------------------
//
//  Function:   IsAdapterDisconnected
//
//  Purpose:    
//
//  Arguments:  const NETADAPTER*  pNA
//
//  Returns:    HRESULT
//
//  Author:     billi  11/04/01
//
//  Notes:      
//
{
    const NETADAPTER* pAdapter      = (const NETADAPTER*)pContext;
    BOOLEAN           bDisconnected = FALSE;

    ASSERT( pAdapter );    
    
    if ( NULL != pAdapter )
    {
        HRESULT          hr;
        PIP_ADAPTER_INFO pInfo;
        
        hr = HrInternalGetAdapterInfo( &pInfo );
        
        if ( SUCCEEDED(hr) )
        {
            char* pszName;
            
            hr = HrWideCharToMultiByte( pAdapter->szDisplayName, &pszName );
            
            if ( SUCCEEDED(hr) )
            {
                PIP_ADAPTER_INFO pAdapter = pInfo;
                
                while ( pAdapter )
                {
                    if ( ( strcmp( pAdapter->AdapterName, pszName ) == 0 ) || 
                         ( strcmp( pAdapter->Description, pszName ) == 0 ) )
                    {
                        // If a single matching card returns TRUE then we return TRUE
                    
                        bDisconnected = bDisconnected || IsMediaDisconnected( pAdapter->Index );
                    }
                
                    pAdapter = pAdapter->Next;
                    
                }    //    while ( pAdapter )
                
                delete [] pszName;
                
            }    //    if ( SUCCEEDED(hr) )
        
            delete pInfo;
            
        }    //    if ( SUCCEEDED(hr) )
        
    }    //    if ( NULL != pNA )
    
    return bDisconnected;
}



HRESULT HrSetAdapterIpAddress(  
    const NETADAPTER* pNA,
    ULONG IPAddress,
    ULONG SubnetMask
    )
//+---------------------------------------------------------------------------
//
// Function:  HrSetAdapterIpAddress
//
// Purpose:   
//
// Arguments: 
//      const NETADAPTER* pNA,
//      BOOL  EnableDHCP,
//      ULONG IPAddress,
//      ULONG SubnetMask,
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT hr = E_INVALIDARG;
    
    ASSERT( pNA );
    
    if ( pNA )
    {
        TCHAR* pszAddress = HostAddrToIpPsz( IPAddress );
        TCHAR* pszSubnet  = HostAddrToIpPsz( SubnetMask );
        
        hr = E_OUTOFMEMORY;
        
        if ( pszAddress && pszSubnet )
        {
            HINSTANCE hLibInstance = NULL;
            DWORD     dnParent     = pNA->devnode;
            DWORD     dnChild;   
            DWORD     cRet         = GetChildDevice( &dnChild, dnParent, &hLibInstance, 0 );
            
            do
            {
                TCHAR* Buffer = NULL;
                ULONG  Length = 0L;
            
                if ( STATUS_SUCCESS == cRet )
                    cRet = GetDeviceIdA( dnChild, &Buffer, &Length, 0);
            
                if ( (STATUS_SUCCESS == cRet) && Buffer && Length && (strstr( Buffer, SZ_PROTOCOL_TCPIPA ) != NULL) )
                {
                    char pszSubkey[ MAX_PATH ];
                    
                    Length = MAX_PATH;
                
                    cRet = GetDevNodeRegistryPropertyA( dnChild, CM_DRP_DRIVER, NULL, pszSubkey, &Length, 0);

                    if ( STATUS_SUCCESS == cRet )
                    {
                        CRegistry reg;
                        char      pszDriverKey[ MAX_PATH ];
                        
                        lstrcpy( pszDriverKey, "System\\CurrentControlSet\\Services\\Class\\" );
                        lstrcat( pszDriverKey, pszSubkey );
                        
                        if ( reg.OpenKey( HKEY_LOCAL_MACHINE, pszDriverKey, KEY_ALL_ACCESS) )
                        {
                            if ( reg.SetStringValue( "IPAddress", pszAddress ) &&
                                 reg.SetStringValue( "IPMask", pszSubnet ) )
                            {
                                hr = S_OK;
                            }
                            
                            reg.CloseKey();
                        }
                        
                    }   //  if ( STATUS_SUCCESS == cRet )
                    
                }   //  if ( Buffer && Length && (strcmp( Buffer, SZ_PROTOCOL_TCPIPA ) == 0) )
                
                if ( Buffer )
                    delete [] Buffer;
                    
                dnParent = dnChild;    
                cRet     = GetSiblingDevice( &dnChild, dnParent, hLibInstance, 0 );
            }
            while ( STATUS_SUCCESS == cRet );
            
            if ( hLibInstance )
            {
                FreeLibrary( hLibInstance );
            }
            
        }   //  if ( pszAddress && pszSubnet )
        
        if ( pszAddress )
            delete [] pszAddress;
            
        if ( pszSubnet )
            delete [] pszSubnet;
            
    }   //  if ( pNA )
    
    return hr;
}



HRESULT HrEnableDhcp( VOID* pContext, DWORD dwFlags )
//+---------------------------------------------------------------------------
//
//  Function:   HrEnableDhcpIfLAN
//
//  Purpose:    
//
//  Arguments:  NETADAPTER* pNA
//              DWORD       dwFlags
//
//  Returns:    HRESULT
//
//  Author:     billi  29/04/01
//
//  Notes:      
//
{
    HRESULT           hr  = E_INVALIDARG;
    const NETADAPTER* pNA = (const NETADAPTER*)pContext;

    ASSERT( pNA );

    if ( NULL != pNA )
    {
        hr = HrSetAdapterIpAddress( pNA, 0, 0 );

        if ( SUCCEEDED(hr) )
        {
            hr = RestartNetAdapter( pNA->devnode );
        }
        
    }    //    if ( NULL != pNA )
    
    return hr;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\nicenum.cpp ===
//
// NicEnum.cpp
//
//		NIC enumeration code, taken from JetNet (hardware group) and repurposed
//		for the Home Networking Wizard.
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/28/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "TheApp.h"


// Local functions
//
HRESULT WINAPI DetectHardwareEx(const NETADAPTER* pAdapter);
BOOL WINAPI IsNetAdapterEnabled(LPCSTR pszEnumKey);


// EnumNetAdapters (public)
//
//		Enumerates all network adapters installed on the system, allocates a structure
//		big enough to hold the information, and returns the number of adapters found.
//		Use NetConnFree() to free the allocated memory.
//
// History:
//
//		 3/15/1999  KenSh     Created
//		 3/25/1999  KenSh     Added code to get Enum key for each adapter
//		 9/29/1999  KenSh     Changed JetNetAlloc to NetConnAlloc
//
int WINAPI EnumNetAdapters(NETADAPTER** pprgNetAdapters)
{
	CRegistry reg(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\Class\\Net"), KEY_READ, FALSE);

	DWORD cAdapters = 0;
	DWORD iKey;

	RegQueryInfoKey(reg.m_hKey, NULL, NULL, NULL, &cAdapters, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	NETADAPTER* prgNetAdapters = (NETADAPTER*)NetConnAlloc(sizeof(NETADAPTER) * cAdapters);
	if (prgNetAdapters == NULL)
    {
        cAdapters = 0;
		goto done;
    }

	ZeroMemory(prgNetAdapters, sizeof(NETADAPTER) * cAdapters);

	for (iKey = 0; iKey < cAdapters; iKey++)
	{
		NETADAPTER* pAdapter = &prgNetAdapters[iKey];
		pAdapter->bError = NICERR_NONE;
		pAdapter->bWarning = NICWARN_NONE;
		pAdapter->bNetSubType = SUBTYPE_NONE;

		lstrcpy(pAdapter->szClassKey, _T("Net\\"));
		static const int cchNet = _countof(_T("Net\\")) - 1;
		DWORD cbPnpID = _countof(pAdapter->szClassKey) - cchNet;
		if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iKey, pAdapter->szClassKey + cchNet, &cbPnpID, NULL, NULL, NULL, NULL))
		{
			pAdapter->bError = NICERR_BANGED;
			continue;
		}

		CRegistry reg2;
		if (!reg2.OpenKey(reg.m_hKey, pAdapter->szClassKey + cchNet, KEY_READ))
		{
			pAdapter->bError = NICERR_BANGED;
			continue;
		}

		// VERIFIED: Win95 gold, Win98 gold
		reg2.QueryStringValue(_T("DriverDesc"), pAdapter->szDisplayName, _countof(pAdapter->szDisplayName));

		CRegistry reg3;
		if (!reg3.OpenKey(reg2.m_hKey, _T("Ndi"), KEY_READ))
		{
			pAdapter->bError = NICERR_BANGED;
			continue;
		}

		if (reg2.QueryStringValue(_T("DisableWarning"), NULL, NULL))
		{
			pAdapter->bWarning = NICWARN_WARNING;
		}

		// VERIFIED: Win95 gold, Win98 gold
		reg2.QueryStringValue(_T("InfPath"), pAdapter->szInfFileName, _countof(pAdapter->szInfFileName));

		// VERIFIED: Win95 gold, Win98 gold
		reg3.QueryStringValue(_T("DeviceId"), pAdapter->szDeviceID, _countof(pAdapter->szDeviceID));

		// Get the name of the driver provider, not the manufacturer
		// We will replace with actual mfr name, if any, when we open the enum key
		reg2.QueryStringValue(_T("ProviderName"), pAdapter->szManufacturer, _countof(pAdapter->szManufacturer));

		// Check for supported interfaces to determine the network type
		CRegistry reg4;
		TCHAR szLower[60];
		szLower[0] = _T('\0');
		if (reg4.OpenKey(reg3.m_hKey, _T("Interfaces"), KEY_READ))
		{
			// REVIEW: should we check LowerRange instead?
			reg4.QueryStringValue(_T("Lower"), szLower, _countof(szLower));
		}

		// Figure out the network adapter type (NIC, Dial-Up, etc.)
		// Default is NETTYPE_LAN (which is automatically set since it's 0)
		if (strstr(szLower, _T("vcomm")))
		{
			pAdapter->bNetType = NETTYPE_DIALUP;
		}
		else if (strstr(szLower, _T("pptp")))
		{
			pAdapter->bNetType = NETTYPE_PPTP;
		}
        else if (strstr(szLower, _T("isdn")))
        {
            pAdapter->bNetType = NETTYPE_ISDN;
        }
        else if (strstr(szLower, _T("NabtsIp")) || strstr(szLower, _T("nabtsip")))
        {
            pAdapter->bNetType = NETTYPE_TV;
			pAdapter->bNicType = NIC_VIRTUAL;
        }
		else
		{
			TCHAR szBuf[80];

			// Check for IrDA adapter
			// VERIFIED: Win98 OSR1
			if (reg3.QueryStringValue(_T("NdiInstaller"), szBuf, _countof(szBuf)))
			{
				LPTSTR pchComma = strchr(szBuf, ',');
				if (pchComma != NULL)
				{
					*pchComma = _T('\0');
					if (!lstrcmpi(szBuf, _T("ir_ndi.dll")))
					{
						pAdapter->bNetType = NETTYPE_IRDA;
					}
				}
			}
		}

		// Determine if card is ISA, PCI, PCMCIA, etc.
		if (pAdapter->szDeviceID[0] == _T('*'))
		{
			if (strstr(szLower, _T("ethernet")))
			{
				if (0 == memcmp(pAdapter->szDeviceID, _T("*AOL"), 4))
				{
					pAdapter->bNicType = NIC_VIRTUAL;
					pAdapter->bNetSubType = SUBTYPE_AOL;
				}
				else
				{
					pAdapter->bNicType = NIC_UNKNOWN;
				}
			}
			else
			{
				pAdapter->bNicType = NIC_VIRTUAL;
			}
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("PCMCIA\\"), _lengthof("PCMCIA\\")))
		{
			pAdapter->bNicType = NIC_PCMCIA;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("PCI\\"), _lengthof("PCI\\")))
		{
			pAdapter->bNicType = NIC_PCI;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("ISAPNP\\"), _lengthof("ISAPNP\\")))
		{
			pAdapter->bNicType = NIC_ISA;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("USB\\"), _lengthof("USB\\")))
		{
			pAdapter->bNicType = NIC_USB;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("LPTENUM\\"), _lengthof("LPTENUM\\")))
		{
			pAdapter->bNicType = NIC_PARALLEL;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("MF\\"), _lengthof("MF\\")))
		{
			pAdapter->bNicType = NIC_MF;
		}
		else if (0 == memcmp(pAdapter->szDeviceID, _T("V1394\\"), _lengthof("V1394\\")))
		{
			pAdapter->bNicType = NIC_1394;
		}
		else if (0 == lstrcmpi(pAdapter->szDeviceID, _T("ICSHARE")))
		{
			pAdapter->bNicType = NIC_VIRTUAL;
			pAdapter->bNetSubType = SUBTYPE_ICS;
		}

		// TODO: remove this code, replace with IcsIsExternalAdapter and IcsIsInternalAdapter
		// Check if this adapter is used by ICS
		{
			pAdapter->bIcsStatus = ICS_NONE;
			LPCSTR pszAdapterNumber = pAdapter->szClassKey + cchNet;

			TCHAR szBuf[10];
			CRegistry regIcs;

			if (regIcs.OpenKey(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General"), KEY_QUERY_VALUE))
			{
				if (regIcs.QueryStringValue(_T("ExternalAdapterReg"), szBuf, _countof(szBuf)))
				{
					if (0 == lstrcmp(szBuf, pszAdapterNumber))
					{
						pAdapter->bIcsStatus = ICS_EXTERNAL;
					}
				}

				// TODO: allow > 1 internal adapter
				if (regIcs.QueryStringValue(_T("InternalAdapterReg"), szBuf, _countof(szBuf)))
				{
					if (0 == lstrcmp(szBuf, pszAdapterNumber))
					{
						pAdapter->bIcsStatus = ICS_INTERNAL;
					}
				}
			}
		}
	}

	// Snip out any adapters that turned out to be invalid
	cAdapters = iKey;
	if (cAdapters == 0)
	{
		NetConnFree(prgNetAdapters);
		prgNetAdapters = NULL;
		goto done;
	}


	//
	// Walk the registry Enum key to find full enum key for each adapter
	//
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, _T("Enum"), KEY_READ))
	{
		TCHAR szSubKey[MAX_PATH];
		DWORD cbSubKey;
		TCHAR szDevEnumKey[MAX_PATH];
		int cchDevEnumKey1; // length of "PCI\"
		int cchDevEnumKey2; // length of "PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00\"

		for (DWORD iEnumKey = 0; ; iEnumKey++)
		{
			cbSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iEnumKey, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL))
				break;

			// Start building DevEnumKey e.g. "PCI\"
			lstrcpy(szDevEnumKey, szSubKey);
			cchDevEnumKey1 = (int)cbSubKey;
			szDevEnumKey[cchDevEnumKey1++] = _T('\\');

			CRegistry reg2;
			if (!reg2.OpenKey(reg.m_hKey, szSubKey, KEY_READ)) // e.g. "Enum\PCI"
				continue;

			for (DWORD iEnumKey2 = 0; ; iEnumKey2++)
			{
				cbSubKey = _countof(szSubKey);
				if (ERROR_SUCCESS != RegEnumKeyEx(reg2.m_hKey, iEnumKey2, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL))
					break;

				// Continue building DevEnumKey e.g. "PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00\"
				lstrcpy(szDevEnumKey + cchDevEnumKey1, szSubKey);
				cchDevEnumKey2 = cchDevEnumKey1 + (int)cbSubKey;
				szDevEnumKey[cchDevEnumKey2++] = _T('\\');

				CRegistry reg3;
				if (!reg3.OpenKey(reg2.m_hKey, szSubKey, KEY_READ)) // e.g. "Enum\PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00"
					continue;

				for (DWORD iEnumKey3 = 0; ; iEnumKey3++)
				{
					cbSubKey = _countof(szSubKey);
					if (ERROR_SUCCESS != RegEnumKeyEx(reg3.m_hKey, iEnumKey3, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL))
						break;

					// Finish building DevEnumKey e.g. "PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00\407000"
					lstrcpy(szDevEnumKey + cchDevEnumKey2, szSubKey);

					CRegistry regLeaf;
					if (!regLeaf.OpenKey(reg3.m_hKey, szSubKey, KEY_READ)) // e.g. "Enum\PCI\VEN_10B7&DEV_9050&SUBSYS_00000000&REV_00\407000"
						continue;

					if (!regLeaf.QueryStringValue(_T("Driver"), szSubKey, _countof(szSubKey)))
						continue;

					//
					// See if the device matches one of our NICs
					//
					for (DWORD iAdapter = 0; iAdapter < cAdapters; iAdapter++)
					{
						NETADAPTER* pAdapter = &prgNetAdapters[iAdapter];
						if (0 != lstrcmpi(szSubKey, pAdapter->szClassKey))
							continue; // doesn't match

						lstrcpy(pAdapter->szEnumKey, _T("Enum\\"));
						lstrcpyn(pAdapter->szEnumKey + 5, szDevEnumKey, _countof(pAdapter->szEnumKey) - 5);

						if (regLeaf.QueryStringValue(_T("Mfg"), szSubKey, _countof(szSubKey)))
							lstrcpyn(pAdapter->szManufacturer, szSubKey, _countof(pAdapter->szManufacturer));

						if (regLeaf.QueryStringValue(_T("DeviceDesc"), szSubKey, _countof(szSubKey)))
						{
							lstrcpyn(pAdapter->szDisplayName, szSubKey, _countof(pAdapter->szDisplayName));
							
							// Detect more special types of adapters here
							if (pAdapter->bNetType == NETTYPE_DIALUP)
							{
								if (strstr(pAdapter->szDisplayName, _T("VPN")) ||
									 strstr(pAdapter->szDisplayName, _T("#2")))
								{
									pAdapter->bNetSubType = SUBTYPE_VPN;
								}
							}
						}
						break;  // found a match, so stop looking
					}
				}
			}
		}
	}

	// For all adapters that we think are present, check to see if they're
	// actually present
	DWORD iAdapter;
	for (iAdapter = 0; iAdapter < cAdapters; iAdapter++)
	{
		NETADAPTER* pAdapter = &prgNetAdapters[iAdapter];
        
        GetNetAdapterDevNode(pAdapter);

		// No enum key -> bad (JetNet bug 1234)
		if (pAdapter->szEnumKey[0] == _T('\0'))
		{
			pAdapter->bError = NICERR_CORRUPT;
		}

		// REVIEW: could still check if "broken" adapters are present
		if (pAdapter->bNicType != NIC_VIRTUAL && pAdapter->bError == NICERR_NONE)
		{
			HRESULT hrDetect = DetectHardwareEx(pAdapter);

			if (hrDetect == S_FALSE)
			{
				pAdapter->bError = NICERR_MISSING;
			}
			else if (hrDetect == S_OK)
			{
				// Is the adapter disabled?
				if (!IsNetAdapterEnabled(pAdapter->szEnumKey))
				{
					pAdapter->bError = NICERR_DISABLED;
				}
				else if (IsNetAdapterBroken(pAdapter))
				{
					pAdapter->bError = NICERR_BANGED;
				}
			}
		}
    }

done:
    *pprgNetAdapters = prgNetAdapters;
    return (int)cAdapters;
}

// Gets the name of the VxD from the registry, e.g. "3c19250.sys".
// Returns S_OK if the name was retrieved.
// Returns E_FAIL if the name was not retrieved, and sets pszBuf to an empty string.
HRESULT WINAPI GetNetAdapterDeviceVxDs(const NETADAPTER* pAdapter, LPSTR pszBuf, int cchBuf)
{
    CRegistry reg(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\Class"), KEY_READ, FALSE);
    if (reg.OpenSubKey(pAdapter->szClassKey, KEY_READ))
    {
        if (reg.QueryStringValue(_T("DeviceVxDs"), pszBuf, cchBuf))
        {
            return S_OK;
        }
    }

    *pszBuf = '\0';
    return E_FAIL;
}

// Returns S_OK if the NIC is present, S_FALSE if not, or an error code if the test failed
HRESULT WINAPI DetectHardware(LPCSTR pszDeviceID)
{
    // Just thunk down to the 16-bit version which uses DiGetClassDevs
    HRESULT hr = FindClassDev16(NULL, _T("Net"), pszDeviceID);
    return hr;
}

HRESULT WINAPI DetectHardwareEx(const NETADAPTER* pAdapter)
{
    // Hack: always assume IRDA adapters are present, since HW detection doesn't
    // work on them -ks 8/8/99
    // TODO: see if this is fixed in the updated DetectHardware()  -ks 9/28/1999
//    if (pAdapter->bNetType == NETTYPE_IRDA)
//        return S_OK;

    // Hack: always assume unknown NIC types are present, since HW detection
    // doesn't work on them (JetNet bug 1264 - Intel AnyPoint Parallel Port Adapter)
    // TODO: see if this is fixed in the updated DetectHardware()  -ks 9/28/1999
//    if (pAdapter->bNicType == NIC_UNKNOWN)
//        return S_OK;

    // Hack: work around Millennium bug 123237, which says that hardware detection
    // fails for NICs using the Dc21x4.sys driver. I never got a chance to track
    // down the cause of the failure, so I'm cheating instead.  -ks 1/13/2000
    TCHAR szBuf[100];
    GetNetAdapterDeviceVxDs(pAdapter, szBuf, _countof(szBuf));
    if (0 == lstrcmpi(szBuf, _T("dc21x4.sys")))
        return S_OK;

    return DetectHardware(pAdapter->szDeviceID);
}

BOOL OpenConfigKey(CRegistry& reg, LPCSTR pszSubKey, REGSAM dwAccess)
{
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\IDConfigDB", KEY_QUERY_VALUE))
    {
        TCHAR szConfigNumber[20];
        if (reg.QueryStringValue("CurrentConfig", szConfigNumber, _countof(szConfigNumber)))
        {
            TCHAR szRegKey[300];
            wsprintf(szRegKey, "Config\\%s\\%s", szConfigNumber, pszSubKey);
            if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, dwAccess))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL WINAPI IsNetAdapterEnabled(LPCSTR pszEnumKey)
{
    BOOL bEnabled = TRUE;  // assume enabled if reg keys are missing

    CRegistry reg;
    if (OpenConfigKey(reg, pszEnumKey, KEY_QUERY_VALUE))
    {
        DWORD dwDisabled;
        if (reg.QueryDwordValue("CSConfigFlags", &dwDisabled))
        {
            bEnabled = (dwDisabled == 0);
        }
    }

    return bEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\parseinf.cpp ===
#include "..\shared\parseinf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\netcli.cpp ===
//
// NetCli.cpp
//
//		Code to install, uninstall, and bind clients such as Client for
//		Microsoft Networks (VREDIR).
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "TheApp.h"
#include "ParseInf.h"
#include "HookUI.h"


// IsClientInstalled
//
//		Returns TRUE if the given client (e.g. "VREDIR") is currently installed.
//
BOOL WINAPI IsClientInstalled(LPCSTR pszClientDeviceID, BOOL bExhaustive)
{
	BOOL bResult = FALSE;

	TCHAR szRegKey[50];
	wsprintf(szRegKey, "Enum\\Network\\%s", pszClientDeviceID);
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_READ))
	{
		DWORD cSubKeys;
		if (ERROR_SUCCESS == RegQueryInfoKey(reg.m_hKey, NULL, NULL, NULL, &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
		{
			if (cSubKeys != 0)
				bResult = TRUE;
		}
	}

	if (bResult && bExhaustive)
	{
		TCHAR szInfSection[50];
		wsprintf(szInfSection, "%s.Install", pszClientDeviceID);
		if (!CheckInfSectionInstallation("netcli.inf", szInfSection))
			bResult = FALSE;
	}

	return bResult;
}

BOOL WINAPI IsMSClientInstalled(BOOL bExhaustive)
{
	if (!FindValidNetEnumKey(SZ_CLASS_CLIENT, SZ_CLIENT_MICROSOFT, NULL, 0))
		return FALSE;

	if (bExhaustive)
	{
		if (!CheckInfSectionInstallation("netcli.inf", "VREDIR.Install"))
			return FALSE;
	}

	return TRUE;
}

// Installs Client for Microsoft Networking, or fixes a broken installation
HRESULT WINAPI InstallMSClient(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	HRESULT hr = NETCONN_SUCCESS;

	// Remove any broken bindings
	RemoveBrokenNetItems(SZ_CLASS_CLIENT, SZ_CLIENT_MICROSOFT);

	if (IsMSClientInstalled(FALSE))
	{
		// Client is set up in registry, but check for missing files
		if (!CheckInfSectionInstallation("netcli.inf", "VREDIR.Install"))
		{
			if (InstallInfSection("netcli.inf", "VREDIR.Install", TRUE))
			{
				hr = NETCONN_NEED_RESTART;
			}
		}
	}
	else
	{
		BeginSuppressNetdiUI(hwndParent, pfnProgress, pvProgressParam);
		DWORD dwResult = CallClassInstaller16(hwndParent, SZ_CLASS_CLIENT, SZ_CLIENT_MICROSOFT);
		EndSuppressNetdiUI();

		hr = HresultFromCCI(dwResult);
		if (g_bUserAbort)
		{
			hr = NETCONN_USER_ABORT;
		}
		else if (SUCCEEDED(hr))
		{
			hr = NETCONN_NEED_RESTART;
		}
	}

	return hr;
}


// pszServiceBinding contains a service to list in the new client's Bindings subkey
// pszBuf is filled with the new binding's enum key, e.g. "VREDIR\0001"
HRESULT CreateNewClientForMSNet(LPSTR pszBuf, int cchBuf, LPCSTR pszServiceBinding)
{
	HRESULT hr;

	if (FAILED(hr = FindAndCloneNetEnumKey(SZ_CLASS_CLIENT, SZ_CLIENT_MICROSOFT, pszBuf, cchBuf)))
	{
		ASSERT(FALSE);
		return hr;
	}

	// Now pszBuf contains a string of the form "VREDIR\0001"

	CRegistry regBindings;
	TCHAR szBindingsKey[200];
	wsprintf(szBindingsKey, "Enum\\Network\\%s\\Bindings", pszBuf);
	if (!regBindings.CreateKey(HKEY_LOCAL_MACHINE, szBindingsKey, KEY_ALL_ACCESS))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	// Delete existing bindings
	regBindings.DeleteAllValues();

	// Add the service binding
	if (pszServiceBinding != NULL && *pszServiceBinding != '\0')
		regBindings.SetStringValue(pszServiceBinding, "");

	return NETCONN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\protocol.cpp ===
//
// Protocol.cpp
//
//		Install, uninstall, and related code for protocols such as TCP/IP.
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "ParseInf.h"
#include "TheApp.h"
#include "HookUI.h"
#include "NetCli.h"


// Local functions
//
VOID RemoveOrphanedProtocol(LPCSTR pszProtocolID);
HRESULT CreateNewProtocolBinding(LPCSTR pszProtocolDeviceID, LPSTR pszBuf, int cchBuf, LPCSTR pszClientBinding, LPCSTR pszServiceBinding);


// IsProtocolInstalled
//
//		Returns TRUE if one or more instances of the given protocol
//		(e.g. "MSTCP") is bound to a network adapter.
//
BOOL WINAPI IsProtocolInstalled(LPCTSTR pszProtocolDeviceID, BOOL bExhaustive)
{
	if (!IsProtocolBoundToAnyAdapter(pszProtocolDeviceID))
		return FALSE;

	if (bExhaustive)
	{
		TCHAR szInfSection[50];
		wsprintf(szInfSection, "%s.Install", pszProtocolDeviceID);
		if (!CheckInfSectionInstallation("nettrans.inf", szInfSection))
			return FALSE;
	}

	return TRUE;
}


// InstallProtocol (public)
//
//		Installs the given protocol via NETDI, and binds it to all adapters.
//		The standard progress UI is (mostly) suppressed, and instead the given
//		callback function is called so a custom progress UI can be implemented.
//
//		Returns a NETCONN_xxx result, defined in NetConn.h
//
// Parameters:
//
//		hwndParent			parent window helpful to use in NETDI call
//		pfnProgress			function to call with install progress reports
//		pvProgressParam		user-supplied parameter to pass to pfnProgress
//
// History:
//
//		 2/23/1999  KenSh     Created
//		 3/26/1999  KenSh     Check if already installed before reinstalling
//
HRESULT WINAPI InstallProtocol(LPCSTR pszProtocolID, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	HRESULT hr = NETCONN_SUCCESS;

	if (!IsProtocolBoundToAnyAdapter(pszProtocolID))
	{
		RemoveOrphanedProtocol(pszProtocolID);

		BeginSuppressNetdiUI(hwndParent, pfnProgress, pvProgressParam);
		DWORD dwResult = CallClassInstaller16(hwndParent, SZ_CLASS_PROTOCOL, pszProtocolID);
		EndSuppressNetdiUI();

		if (g_bUserAbort)
		{
			hr = NETCONN_USER_ABORT;
		}
		else if (SUCCEEDED(HresultFromCCI(dwResult)))
		{
			hr = NETCONN_NEED_RESTART;
		}

		// Total hack to work around JetNet bug 1193
//		DoDummyDialog(hwndParent);
	}

	if (SUCCEEDED(hr))
	{
		// Ensure the protocol is bound exactly once to every NIC
		HRESULT hr2 = BindProtocolToAllAdapters(pszProtocolID);
		if (hr2 != NETCONN_SUCCESS)
			hr = hr2;
	}

	return hr;
}


// InstallTCPIP (public)
//
//		Installs TCP/IP via NETDI.  See InstallProtocol for details.
//
HRESULT WINAPI InstallTCPIP(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	return InstallProtocol(SZ_PROTOCOL_TCPIP, hwndParent, pfnProgress, pvProgressParam);
}

HRESULT WINAPI RemoveProtocol(LPCSTR pszProtocol)
{
	HRESULT hr = NETCONN_SUCCESS;

	// Remove all pointers to the protocol from net adapters
	NETADAPTER* prgAdapters;
	int cAdapters = EnumNetAdapters(&prgAdapters);
	for (int iAdapter = 0; iAdapter < cAdapters; iAdapter++)
	{
		NETADAPTER* pAdapter = &prgAdapters[iAdapter];

		LPTSTR* prgBindings;
		int cBindings = EnumMatchingNetBindings(pAdapter->szEnumKey, pszProtocol, &prgBindings);
		if (cBindings > 0)
		{
			CRegistry regBindings;
			if (regBindings.OpenKey(HKEY_LOCAL_MACHINE, pAdapter->szEnumKey) &&
				regBindings.OpenSubKey("Bindings"))
			{
				for (int iBinding = 0; iBinding < cBindings; iBinding++)
				{
					regBindings.DeleteValue(prgBindings[iBinding]);
					hr = NETCONN_NEED_RESTART;
				}
			}
		}
		NetConnFree(prgBindings);
	}
	NetConnFree(prgAdapters);

	// Remove the protocol's enum key
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "Enum\\Network"))
	{
		RegDeleteKeyAndSubKeys(reg.m_hKey, pszProtocol);
	}

	// Remove the protocol's class key(s)
	DeleteClassKeyReferences(SZ_CLASS_PROTOCOL, pszProtocol);

	return hr;
}

// IsProtocolBoundToAnyAdapter (public)
//
//		Given a protocol ID, such as "MSTCP", returns TRUE if the protocol
//		is bound to any adapter, or FALSE if not.
//
// History:
//
//		 3/26/1999  KenSh     Created
//
BOOL WINAPI IsProtocolBoundToAnyAdapter(LPCSTR pszProtocolID)
{
	BOOL bResult = FALSE;

	NETADAPTER* prgAdapters;
	int cAdapters = EnumNetAdapters(&prgAdapters);
	for (int i = 0; i < cAdapters; i++)
	{
		if (IsProtocolBoundToAdapter(pszProtocolID, &prgAdapters[i]))
		{
			bResult = TRUE;
			goto done;
		}
	}

done:
	NetConnFree(prgAdapters);
	return bResult;
}


// Given a protocol ID, such as "MSTCP", and an adapter struct, determines
// whether the protocol is bound to the adapter.
BOOL WINAPI IsProtocolBoundToAdapter(LPCSTR pszProtocolID, const NETADAPTER* pAdapter)
{
	LPSTR* prgBindings;
	int cBindings = EnumMatchingNetBindings(pAdapter->szEnumKey, pszProtocolID, &prgBindings);
	NetConnFree(prgBindings);

	return (BOOL)cBindings;
}


// Checks to see whether any instances of this protocol in the Class branch of
// the registry are unreferenced, and deletes them if so.
// pszProtocolID is the generic device ID of the protocol, e.g. "MSTCP"
VOID RemoveOrphanedProtocol(LPCSTR pszProtocolID)
{
	// REVIEW: Should we first delete references in Enum that are not in use?
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class\\NetTrans", KEY_ALL_ACCESS))
	{
		//
		// Enumerate the various protocols, e.g. "NetTrans\0000"
		//
		for (DWORD iKey = 0; ; iKey++)
		{
			CHAR szSubKey[MAX_PATH];
			DWORD cbSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iKey, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL))
				break;

			//
			// Open the "Ndi" subkey so we can see what kind of protocol this is
			//
			lstrcpy(szSubKey + cbSubKey, "\\Ndi");
			CRegistry regNode;
			if (regNode.OpenKey(reg.m_hKey, szSubKey, KEY_ALL_ACCESS))
			{
				CHAR szDeviceID[40];
				if (regNode.QueryStringValue("DeviceID", szDeviceID, _countof(szDeviceID)))
				{
					regNode.CloseKey(); // close the key before we try to delete it

					if (0 == lstrcmpi(szDeviceID, pszProtocolID))
					{
						//
						// Found the right protocol, now check if it's referenced
						//
						if (!IsNetClassKeyReferenced(szSubKey))
						{
							// Not referenced, so delete it
							szSubKey[cbSubKey] = '\0'; // back up to just "NetTrans"
							RegDeleteKeyAndSubKeys(reg.m_hKey, szSubKey);
						}
					}
				}
			}
		}
	}
}


// BindProtocolToAdapter
//
//		pszProtocolEnumKey is the top-level Enum key for the protocol, e.g. "MSTCP"
//
//		pszAdapterEnumKey is the first part of the top-level Enum key for the adapter,
//		e.g. "PCI\\VEN_10B7&DEV_9050" or "Root\\Net\\0000" (dial-up adapter)
//
//		bEnableSharing determines whether file and printer sharing will be bound
//		to the protocol when running through the given adapter.
//
// History:
//
//		 3/26/1999  KenSh     Created
//		 4/09/1999  KenSh     Added bEnableSharing flag
//
HRESULT BindProtocolToAdapter(HKEY hkeyAdapterBindings, LPCSTR pszProtocolDeviceID, BOOL bEnableSharing)
{
	HRESULT hr;

	//  NetTrans seems to always clone the Enum key, and also clone the Class key.
	//     (the new clone of the Enum key points to the new clone of the Class key;
	//     each new Enum's MasterCopy points to itself)
	//  NetService and NetClient seem to clone the Enum key, but not the Class key.

	CHAR szClient[MAX_PATH];
	CHAR szService1[MAX_PATH];
	CHAR szService2[MAX_PATH];
	CHAR szProtocol[MAX_PATH];

	if (bEnableSharing)
	{
		if (FAILED(hr = CreateNewFilePrintSharing(szService1, _countof(szService1))))
			return hr;

		if (FAILED(hr = CreateNewFilePrintSharing(szService2, _countof(szService2))))
			return hr;
	}
	else
	{
		szService1[0] = '\0';
		szService2[0] = '\0';
	}

	if (FAILED(hr = CreateNewClientForMSNet(szClient, _countof(szClient), szService1)))
		return hr;

	if (FAILED(hr = CreateNewProtocolBinding(pszProtocolDeviceID, szProtocol, _countof(szProtocol), szClient, szService2)))
		return hr;

	// Bind the new protocol to the adapter
	if (ERROR_SUCCESS != RegSetValueEx(hkeyAdapterBindings, szProtocol, 0, REG_SZ, (CONST BYTE*)"", 1))
		return NETCONN_UNKNOWN_ERROR;

	return NETCONN_NEED_RESTART;
}


HRESULT BindProtocolToAllAdapters_Helper(LPCSTR pszProtocolDeviceID, LPCSTR pszAdapterKey, BOOL bIgnoreVirtualNics)
{
	HRESULT hr = NETCONN_SUCCESS;

	// Get LowerRange interfaces for protocol
	CHAR szProtocolLower[100];
	GetDeviceLowerRange(SZ_CLASS_PROTOCOL, pszProtocolDeviceID, szProtocolLower, _countof(szProtocolLower));

	// For each adapter, ensure the protocol is bound exactly once
	//

	NETADAPTER* prgAdapters;
	int cAdapters = EnumNetAdapters(&prgAdapters);

	// Pass 0: add new bindings
	// Pass 1: delete inappropriate bindings
	for (int iPass = 0; iPass <= 1; iPass++)
	{
		for (int iAdapter = 0; iAdapter < cAdapters; iAdapter++)
		{
			NETADAPTER* pAdapter = &prgAdapters[iAdapter];
			CRegistry regAdapter;

			// Get UpperRange interfaces for adapter
			CHAR szAdapterUpper[100];
			GetDeviceUpperRange(SZ_CLASS_ADAPTER, pAdapter->szDeviceID, szAdapterUpper, _countof(szAdapterUpper));

			// Check for a match between the protocol and the adapter
			BOOL bMatchingInterface = CheckMatchingInterface(szProtocolLower, szAdapterUpper);

			CHAR szRegKey[MAX_PATH];
			wsprintf(szRegKey, "%s\\Bindings", pAdapter->szEnumKey);

			BOOL bCorrectNic = (NULL == pszAdapterKey) || (0 == lstrcmpi(pAdapter->szEnumKey, pszAdapterKey));

			if (!lstrcmpi(pszProtocolDeviceID, SZ_PROTOCOL_IPXSPX))
			{
				// Bind IPX/SPX to all non-broadband NICs by default (usually a max of 1)
				if (pszAdapterKey == NULL)
				{
					if (IsAdapterBroadband(pAdapter))
						bCorrectNic = FALSE;
				}

				// Don't bind IPX/SPX to Dial-Up (or other virtual) adapters (bugs 1163, 1164)
				if (pAdapter->bNicType == NIC_VIRTUAL)
					bCorrectNic = FALSE;
			}

			//
			// Check the bindings of the current adapter, looking for this protocol
			//
			if (regAdapter.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS))
			{
				TCHAR szValueName[60];
				int cFound = 0;
				DWORD iValue = 0;
				for (;;)
				{
					DWORD cbValueName = _countof(szValueName);
					if (ERROR_SUCCESS != RegEnumValue(regAdapter.m_hKey, iValue, szValueName, &cbValueName, NULL, NULL, NULL, NULL))
						break;

					LPSTR pchSlash = strchr(szValueName, '\\');
					if (pchSlash == NULL)
						break;

					*pchSlash = '\0';

					if (0 == lstrcmpi(szValueName, pszProtocolDeviceID))
					{
						*pchSlash = '\\';

						// If this isn't the right NIC, or if there's not a matching
						// interface, or (optionally) if the NIC is virtual, then
						// unbind the protocol.
						BOOL bUnbindFromNic = !bCorrectNic || !bMatchingInterface;
						if (bIgnoreVirtualNics && (pAdapter->bNicType == NIC_VIRTUAL))
							bUnbindFromNic = FALSE;

						if (bUnbindFromNic ||		// bound to the wrong adapter!
							cFound != 0)			// bound more than once to this NIC!
						{
							if (iPass == 1) // unbind on second pass only
							{
								// Remove the binding, then restart our search
								// for matching protocols
								RemoveBindingFromParent(regAdapter.m_hKey, szValueName);
								iValue = 0;
								cFound = 0;
								hr = NETCONN_NEED_RESTART;
								continue;
							}
						}

						cFound += 1;
					}

					iValue += 1;
				}

				if (bCorrectNic && iPass == 0)
				{
					if (cFound == 0) 
					// Protocol is not yet bound to the correct adapter
					{
						if (bMatchingInterface) // There's an interface in common
						{
							BOOL bExternalNic = IsAdapterBroadband(pAdapter);

							// Enable file/printer sharing if:
							//	 * Adapter is an ethernet or IRDA adapter
							//   * Adapter is not a broadband NIC
							BOOL bEnableSharing = FALSE;
							if ((pAdapter->bNetType == NETTYPE_LAN ||
								 pAdapter->bNetType == NETTYPE_IRDA) &&
								!bExternalNic)
							{
								bEnableSharing = TRUE;
							}

							HRESULT hr2 = BindProtocolToAdapter(regAdapter.m_hKey, pszProtocolDeviceID, bEnableSharing);
							if (hr2 != NETCONN_SUCCESS)
								hr = hr2;
						}
					}
				}
			}
		}
	}

	NetConnFree(prgAdapters);

	return hr;
}

// BindProtocolToOnlyOneAdapter (public)
HRESULT WINAPI BindProtocolToOnlyOneAdapter(LPCSTR pszProtocolDeviceID, LPCSTR pszAdapterKey, BOOL bIgnoreVirtualNics)
{
	return BindProtocolToAllAdapters_Helper(pszProtocolDeviceID, pszAdapterKey, bIgnoreVirtualNics);
}

// BindProtocolToAllAdapters (public)
//
//		Given the device ID ("MSTCP") of a protocol which is already installed,
//		binds that protocol to all adapters, as well as to client for Microsoft
//		Networks and File and Printer sharing.
//
// History:
//
//		 3/26/1999  KenSh     Created
//		 4/23/1999  KenSh     Enable file sharing only on real NICs
//
HRESULT WINAPI BindProtocolToAllAdapters(LPCSTR pszProtocolDeviceID)
{
	return BindProtocolToAllAdapters_Helper(pszProtocolDeviceID, NULL, FALSE);
}


// Given a protocol ID such as "MSTCP", an optional client binding string
// such as "VREDIR\0000", and an optional service binding string such as
// "VSERVER\0000", creates a new protocol binding, and copies the name of
// the new binding into the buffer provided (e.g. "MSTCP\0001").
HRESULT CreateNewProtocolBinding(LPCSTR pszProtocolDeviceID, LPSTR pszBuf, int cchBuf, LPCSTR pszClientBinding, LPCSTR pszServiceBinding)
{
	HRESULT hr;

	if (FAILED(hr = FindAndCloneNetEnumKey(SZ_CLASS_PROTOCOL, pszProtocolDeviceID, pszBuf, cchBuf)))
	{
		ASSERT(FALSE);
		return hr;
	}

	// Now pszBuf contains a string of the form "MSTCP\0001"

	CHAR szBindings[60];
	CRegistry regBindings;
	lstrcpy(szBindings, pszBuf);		// "MSTCP\0001"
	lstrcat(szBindings, "\\Bindings");	// "MSTCP\0001\Bindings"

	if (FAILED(hr = OpenNetEnumKey(regBindings, szBindings, KEY_ALL_ACCESS)))
	{
		ASSERT(FALSE);
		return hr;
	}

	// Delete existing bindings
	regBindings.DeleteAllValues();

	// Add the client and server bindings
	if (pszClientBinding != NULL && *pszClientBinding != '\0')
		regBindings.SetStringValue(pszClientBinding, "");
	if (pszServiceBinding != NULL && *pszServiceBinding != '\0')
		regBindings.SetStringValue(pszServiceBinding, "");

	// Change the MasterCopy to point to correct place
	CHAR szMasterCopy[MAX_PATH];
	wsprintf(szMasterCopy, "Enum\\Network\\%s", pszBuf);
	if (regBindings.OpenKey(HKEY_LOCAL_MACHINE, szMasterCopy, KEY_ALL_ACCESS))
	{
		regBindings.SetStringValue("MasterCopy", szMasterCopy);
	}

	// Create a clone of the driver (a.k.a. class key)
	CHAR szExistingDriver[60];
	CHAR szNewDriver[60];
	regBindings.QueryStringValue("Driver", szExistingDriver, _countof(szExistingDriver));
	CloneNetClassKey(szExistingDriver, szNewDriver, _countof(szNewDriver));

	// Change the Driver to point to the new class key
	CRegistry regEnumSubKey;
	VERIFY(SUCCEEDED(OpenNetEnumKey(regEnumSubKey, pszBuf, KEY_ALL_ACCESS)));
	regEnumSubKey.SetStringValue("Driver", szNewDriver);

	// If this is a new TCP/IP binding, ensure we don't have a static IP address
	if (0 == lstrcmpi(pszProtocolDeviceID, SZ_PROTOCOL_TCPIP))
	{
		CHAR szFullClassKey[100];
		wsprintf(szFullClassKey, "System\\CurrentControlSet\\Services\\Class\\%s", szNewDriver);

		CRegistry regClassKey;
		VERIFY(regClassKey.OpenKey(HKEY_LOCAL_MACHINE, szFullClassKey));
		if (regClassKey.QueryStringValue("IPAddress", szFullClassKey, _countof(szFullClassKey)))
			regClassKey.SetStringValue("IPAddress", "0.0.0.0");
		if (regClassKey.QueryStringValue("IPMask", szFullClassKey, _countof(szFullClassKey)))
			regClassKey.SetStringValue("IPMask", "0.0.0.0");
	}

	return NETCONN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\stdafx.cpp ===
//
// StdAfx.cpp
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NConn32.rc
//
#define IDS_APPTITLE                    128
#define IDS_ASKCANCEL_NOTSAFE           388

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\stdafx.h ===
//
// StdAfx.h
//

#define STRICT
#define VC_EXTRALEAN

#include <windows.h>
#include <tchar.h>
#include <stdarg.h>

// fauxmfc.cpp needs these
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include "Debug.h"

#define _FAUXMFC_NO_SYNCOBJ
#include "FauxMFC.h"

#include "Util.h"

#define _REG_ALLOCMEM 0
#include "Registry.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\sortstr.cpp ===
#include "..\shared\sortstr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\sharing.cpp ===
//
// Sharing.cpp
//
//		Code to install, enable, disable, and bind File and Printer sharing
//		for Microsoft networks (VSERVER).
//
// History:
//
//		 2/02/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "NetConn.h"
#include "nconnwrap.h"
#include "Registry.h"
#include "TheApp.h"
#include "ParseInf.h"
#include "HookUI.h"


// Local functions
//
BOOL WINAPI FindValidSharingEnumKey(LPSTR pszBuf, int cchBuf);


// Check the registry to see if file/printer sharing is installed.
BOOL WINAPI IsSharingInstalled(BOOL bExhaustive)
{
	if (!FindValidSharingEnumKey(NULL, 0))
		return FALSE;

	if (bExhaustive)
	{
		if (!CheckInfSectionInstallation("netservr.inf", "VSERVER.Install"))
			return FALSE;
	}

	return TRUE;
}

BOOL WINAPI FindValidSharingEnumKey(LPSTR pszBuf, int cchBuf)
{
	return FindValidNetEnumKey(SZ_CLASS_SERVICE, SZ_SERVICE_VSERVER, pszBuf, cchBuf);
}

// Enables file/printer sharing on local NICs, disables it on Internet connections
HRESULT WINAPI EnableProtocolSharingAppropriately(LPCTSTR pszProtocolDeviceID)
{
	HRESULT hr = EnableDisableProtocolSharing(pszProtocolDeviceID, TRUE, FALSE);
	HRESULT hr2 = EnableDisableProtocolSharing(pszProtocolDeviceID, FALSE, TRUE);
	if (hr2 != NETCONN_SUCCESS)
		hr = hr2;
	return hr;
}

// Enables or disables file/printer sharing for either Dial-Up or non-Dial-Up connections,
// but not both.
HRESULT WINAPI EnableDisableProtocolSharing(LPCTSTR pszProtocolDeviceID, BOOL bEnable, BOOL bDialUp)
{
	HRESULT hr = NETCONN_SUCCESS;

	NETADAPTER* prgAdapters;
	int cAdapters = EnumNetAdapters(&prgAdapters);
	for (int iAdapter = 0; iAdapter < cAdapters; iAdapter++)
	{
		NETADAPTER* pAdapter = &prgAdapters[iAdapter];

		BOOL bExternalNic = IsAdapterBroadband(pAdapter);

		if (bDialUp)
		{
			if (!bExternalNic && pAdapter->bNetType != NETTYPE_DIALUP)
				continue;
		}
		else
		{
			if (bExternalNic || pAdapter->bNetType == NETTYPE_DIALUP)
				continue;
		}

		LPTSTR* prgBindings;
		int cBindings = EnumMatchingNetBindings(pAdapter->szEnumKey, pszProtocolDeviceID, &prgBindings);
		for (int iBinding = 0; iBinding < cBindings; iBinding++)
		{
			HRESULT hr2;
			if (bEnable)
			{
				hr2 = EnableSharingOnNetBinding(prgBindings[iBinding]);
			}
			else
			{
				hr2 = DisableSharingOnNetBinding(prgBindings[iBinding]);
			}

			if (hr2 != NETCONN_SUCCESS)
				hr = hr2;
		}
		NetConnFree(prgBindings);
	}
	NetConnFree(prgAdapters);

	return hr;
}

// pszNetBinding is of the form "MSTCP\0000"
HRESULT WINAPI DisableSharingOnNetBinding(LPCSTR pszNetBinding)
{
	HRESULT hr = NETCONN_SUCCESS;

	CRegistry regBindings;
	TCHAR szRegKey[MAX_PATH];
	wsprintf(szRegKey, "Enum\\Network\\%s\\Bindings", pszNetBinding);
	if (regBindings.OpenKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS))
	{
		for (DWORD iBinding = 0; ; )
		{
			CHAR szBinding[64];
			DWORD cchBinding = _countof(szBinding);
			if (ERROR_SUCCESS != RegEnumValue(regBindings.m_hKey, iBinding, szBinding, &cchBinding, NULL, NULL, NULL, NULL))
				break;

			CHAR chSave = szBinding[8];
			szBinding[8] = '\0';
			BOOL bSharing = !lstrcmpi(szBinding, "VSERVER\\");
			szBinding[8] = chSave;

			if (bSharing)
			{
				RemoveBindingFromParent(regBindings.m_hKey, szBinding);
				hr = NETCONN_NEED_RESTART;

				// Restart the enumeration, since we've changed the key
				iBinding = 0;
				continue;
			}
			else
			{
				// Note: Sharing may still be bound to the client (VREDIR), but we
				// don't remove that binding because Network Control Panel doesn't.
				// (Verified on Win98 gold.)
				//	HRESULT hr2 = DisableSharingOnNetBinding(szBinding);
				//	if (hr2 != NETCONN_SUCCESS)
				//		hr = hr2;
			}

			iBinding += 1; // advance to next binding
		}
	}

	return hr;
}

// pszNetBinding is of the form "MSTCP\0000"
HRESULT WINAPI EnableSharingOnNetBinding(LPCSTR pszNetBinding)
{
	HRESULT hr = NETCONN_SUCCESS;
	BOOL bFoundSharing = FALSE;

	CRegistry regBindings;
	TCHAR szRegKey[MAX_PATH];
	wsprintf(szRegKey, "Enum\\Network\\%s\\Bindings", pszNetBinding);
	if (!regBindings.CreateKey(HKEY_LOCAL_MACHINE, szRegKey, KEY_ALL_ACCESS))
	{
		ASSERT(FALSE);
		return NETCONN_UNKNOWN_ERROR;
	}

	DWORD iBinding = 0;
	for (;;)
	{
		CHAR szBinding[64];
		DWORD cchBinding = _countof(szBinding);
		if (ERROR_SUCCESS != RegEnumValue(regBindings.m_hKey, iBinding, szBinding, &cchBinding, NULL, NULL, NULL, NULL))
			break;

		CHAR chSave = szBinding[8];
		szBinding[8] = '\0';
		BOOL bSharing = !lstrcmpi(szBinding, "VSERVER\\");
		szBinding[8] = chSave;

		chSave = szBinding[7];
		szBinding[7] = '\0';
		BOOL bClient = !lstrcmpi(szBinding, "VREDIR\\");
		szBinding[7] = chSave;

		if (bSharing)
		{
			if (!IsValidNetEnumKey(SZ_CLASS_SERVICE, SZ_SERVICE_VSERVER, szBinding + _lengthof("VSERVER\\")))
			{
				// Found a dead link to nonexistent Enum item; delete it and restart search
				regBindings.DeleteValue(szBinding);
				iBinding = 0;
				continue;
			}
			else
			{
				bFoundSharing = TRUE;
			}
		}
		else if (bClient)
		{
			HRESULT hr2 = EnableSharingOnNetBinding(szBinding);
			if (hr2 != NETCONN_SUCCESS)
				hr = hr2;
		}

		iBinding++;
	}

	if (!bFoundSharing)
	{
		CHAR szBinding[64];
		HRESULT hr2 = CreateNewFilePrintSharing(szBinding, _countof(szBinding));
		if (hr2 != NETCONN_SUCCESS)
			hr = hr2;

		if (SUCCEEDED(hr2))
		{
			regBindings.SetStringValue(szBinding, "");
			hr = NETCONN_NEED_RESTART;
		}
	}

	return hr;
}

HRESULT WINAPI EnableSharingAppropriately()
{
	HRESULT hr = NETCONN_SUCCESS;

	NETADAPTER* prgAdapters;
	int cAdapters = EnumNetAdapters(&prgAdapters);
	for (int iAdapter = 0; iAdapter < cAdapters; iAdapter++)
	{
		NETADAPTER* pAdapter = &prgAdapters[iAdapter];

		// Walk through each protocol bound to the adapter
		LPTSTR* prgBindings;
		int cBindings = EnumNetBindings(pAdapter->szEnumKey, &prgBindings);
		for (int iBinding = 0; iBinding < cBindings; iBinding++)
		{
			LPTSTR pszBinding = prgBindings[iBinding];
			HRESULT hr2 = NETCONN_SUCCESS;

			BOOL bExternalNic = IsAdapterBroadband(pAdapter);

			// Disable file/printer sharing on:
			//	 * Dial-Up Adapters
			//	 * PPTP connections
			//	 * NIC used by ICS to connect to the Internet
			if (pAdapter->bNetType == NETTYPE_DIALUP ||
				pAdapter->bNetType == NETTYPE_PPTP ||
				bExternalNic)
			{
				hr2 = DisableSharingOnNetBinding(pszBinding);
			}
			// Enable file/printer sharing on:
			//	 * Ethernet adapters
			//   * IRDA adapters
			else if (pAdapter->bNetType == NETTYPE_LAN || 
					 pAdapter->bNetType == NETTYPE_IRDA)
			{
				hr2 = EnableSharingOnNetBinding(pszBinding);
			}

			if (hr2 != NETCONN_SUCCESS)
				hr = hr2;
		}
		NetConnFree(prgBindings);

	}
	NetConnFree(prgAdapters);

	return hr;
}

// InstallSharing (public)
//
//		Installs VSERVER, a.k.a. File and Printer sharing for Microsoft networks.
//		The standard progress UI is (mostly) suppressed, and instead the given
//		callback function is called so a custom progress UI can be implemented.
//
//		Returns a NETCONN_xxx result, defined in NetConn.h
//
// History:
//
//		 4/09/1999  KenSh     Created
//		 4/22/1999  KenSh     Remove file-sharing on Dial-Up connections
//		
HRESULT WINAPI InstallSharing(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	HRESULT hr = NETCONN_SUCCESS;
	BOOL bInstall = FALSE;

	// Remove any broken bindings
	RemoveBrokenNetItems(SZ_CLASS_SERVICE, SZ_SERVICE_VSERVER);

	if (IsSharingInstalled(FALSE))
	{
		// Sharing is set up in registry, but check for missing files
		if (!CheckInfSectionInstallation("netservr.inf", "VSERVER.Install"))
		{
			if (InstallInfSection("netservr.inf", "VSERVER.Install", TRUE))
			{
				hr = NETCONN_NEED_RESTART;
			}
		}
	}
	else
	{
		BeginSuppressNetdiUI(hwndParent, pfnProgress, pvProgressParam);
		DWORD dwResult = CallClassInstaller16(hwndParent, SZ_CLASS_SERVICE, SZ_SERVICE_VSERVER);
		EndSuppressNetdiUI();

		hr = HresultFromCCI(dwResult);
		if (g_bUserAbort)
		{
			hr = NETCONN_USER_ABORT;
		}
		else if (SUCCEEDED(hr))
		{
			hr = NETCONN_NEED_RESTART;
		}

		// Total hack to work around JetNet bug 1193
//		DoDummyDialog(hwndParent);
	}

//	if (SUCCEEDED(hr))
//	{
//		HRESULT hr2 = EnableSharingAppropriately();
//		if (hr2 != NETCONN_SUCCESS)
//			hr = hr2;
//	}

	HRESULT hr2 = EnableFileSharing();
	if (hr2 != NETCONN_SUCCESS)
		hr = hr2;

	hr2 = EnablePrinterSharing();
	if (hr2 != NETCONN_SUCCESS)
		hr = hr2;

	return hr;
}

// pConflict may be NULL if you don't need the details
BOOL WINAPI FindConflictingService(LPCSTR pszWantService, NETSERVICE* pConflict)
{
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class\\NetService", KEY_READ))
	{
		TCHAR szSubKey[80];

		for (DWORD iService = 0; ; iService++)
		{
			DWORD cchSubKey = _countof(szSubKey);
			if (ERROR_SUCCESS != RegEnumKeyEx(reg.m_hKey, iService, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				break;

			CRegistry regSubKey;
			if (regSubKey.OpenKey(reg.m_hKey, szSubKey, KEY_READ))
			{
				CRegistry regNdi;
				if (regNdi.OpenKey(regSubKey.m_hKey, "Ndi", KEY_READ))
				{
					CRegistry regCompat;
					if (regCompat.OpenKey(regNdi.m_hKey, "Compatibility", KEY_READ))
					{
						CString strExclude;
						if (regCompat.QueryStringValue("ExcludeAll", strExclude))
						{
							if (CheckMatchingInterface(pszWantService, strExclude))
							{
								if (pConflict != NULL)
								{
									regNdi.QueryStringValue("DeviceID", pConflict->szDeviceID, _countof(pConflict->szDeviceID));
									regSubKey.QueryStringValue("DriverDesc", pConflict->szDisplayName, _countof(pConflict->szDisplayName));
									wsprintf(pConflict->szClassKey, "NetService\\%s", szSubKey);
								}
								return TRUE;
							}
						}
					}
				}
			}
		}
	}

	return FALSE;
}

// pszBuf is filled with the new binding's enum key, e.g. "VSERVER\0001"
HRESULT CreateNewFilePrintSharing(LPSTR pszBuf, int cchBuf)
{
	HRESULT hr;

	if (FAILED(hr = FindAndCloneNetEnumKey(SZ_CLASS_SERVICE, SZ_SERVICE_VSERVER, pszBuf, cchBuf)))
	{
		ASSERT(FALSE);
		return hr;
	}

	// Now pszBuf contains a string of the form "VSERVER\0001"

	CHAR szBindings[60];
	CRegistry regBindings;
	lstrcpy(szBindings, pszBuf);		// "VSERVER\0001"
	lstrcat(szBindings, "\\Bindings");	// "VSERVER\0001\Bindings"


	if (FAILED(hr = OpenNetEnumKey(regBindings, szBindings, KEY_ALL_ACCESS)))
	{
		ASSERT(FALSE);
		return hr;
	}

	// Delete existing bindings (shouldn't be any, right?)
	regBindings.DeleteAllValues();

	return NETCONN_SUCCESS;
}

BOOL IsSharingEnabledHelper(LPCTSTR pszThis)
{
	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\VNETSUP", KEY_READ))
	{
		// If the value is missing or says "Yes", then sharing is enabled
		char szBuf[10];
		return (!reg.QueryStringValue(pszThis, szBuf, _countof(szBuf)) || 0 == lstrcmpi(szBuf, "Yes"));
	}

	return FALSE;
}

BOOL WINAPI IsFileSharingEnabled()
{
	return IsSharingEnabledHelper("FileSharing");
}

BOOL WINAPI IsPrinterSharingEnabled()
{
	return IsSharingEnabledHelper("PrintSharing");
}

HRESULT WINAPI EnableSharingHelper(LPCTSTR pszThis, LPCTSTR pszOther)
{
	HRESULT hr = NETCONN_SUCCESS;

	CRegistry reg;
	if (reg.OpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\VNETSUP"))
	{
		// If Printer sharing is "No", then set File sharing to "Yes".
		// If Printer sharing is missing or is "Yes", delete both values (enables both).

		char szBuf[10];
		if (reg.QueryStringValue(pszOther, szBuf, _countof(szBuf)) &&
			0 != lstrcmpi(szBuf, "Yes"))
		{
			// Set file sharing value to "Yes" (if it's not already set)
			if (!reg.QueryStringValue(pszThis, szBuf, _countof(szBuf)) ||
				0 != lstrcmpi(szBuf, "Yes"))
			{
				reg.SetStringValue(pszThis, "Yes");
				hr = NETCONN_NEED_RESTART;
			}
		}
		else
		{
			// Delete file-sharing and printer-sharing entries (enables both).
			if (reg.QueryStringValue(pszThis, szBuf, _countof(szBuf)) &&
				0 != lstrcmpi(szBuf, "Yes"))
			{
				reg.DeleteValue(pszThis);
				reg.DeleteValue(pszOther);
				hr = NETCONN_NEED_RESTART;
			}
		}
	}

	return hr;
}

HRESULT WINAPI EnableFileSharing()
{
	return EnableSharingHelper("FileSharing", "PrintSharing");
}

HRESULT WINAPI EnablePrinterSharing()
{
	return EnableSharingHelper("PrintSharing", "FileSharing");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\theapp.cpp ===
//
// TheApp.cpp
//
//		Main entry point for NCXP32.DLL, part of the Home Networking Wizard.
//
// History:
//
//		 9/28/1999  KenSh     Created
//

#include "stdafx.h"
#include "NetConn.h"
#include "TheApp.h"


// Global data
//
HINSTANCE g_hInstance;


extern "C" int WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
	g_hInstance = hInstance;

	DisableThreadLibraryCalls(hInstance);

	TCHAR szDll32Path[MAX_PATH];
	if (!GetModuleFileName(g_hInstance, szDll32Path, _countof(szDll32Path)))
	    return FALSE;
	    
	TCHAR szDll16Path[MAX_PATH];
	lstrcpy(szDll16Path, szDll32Path);
	lstrcpy(FindFileTitle(szDll16Path), _T("NCXP16.DLL"));

	// Initialize thunk to NCxp16.dll, fail if not found
	if (!thk_ThunkConnect32(
			szDll16Path,
			szDll32Path,
			hInstance, dwReason))
	{
		return FALSE;
	}

	return TRUE;
}


LPVOID WINAPI NetConnAlloc(DWORD cbAlloc)
{
	return HeapAlloc(GetProcessHeap(), 0, cbAlloc);
}

VOID WINAPI NetConnFree(LPVOID pMem)
{
	if (pMem != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pMem);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\i386\thunk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Mon May 21 15:57:59 2001

;Command Line: thunk.exe -t thk NCXP.thk -o Thunk.asm 

	TITLE	$Thunk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	043a5h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public FindClassDev16@12
FindClassDev16@12:
	mov	cl,3
	jmp	IIFindClassDev16@12
public CallClassInstaller16@12
CallClassInstaller16@12:
	mov	cl,4
; FindClassDev16(16) = FindClassDev16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszClassName
; dword ptr [ebp+16]:  szDeviceID
;
public IIFindClassDev16@12
IIFindClassDev16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public LookupDevNode16@20
LookupDevNode16@20:
	mov	cl,2
; LookupDevNode16(16) = LookupDevNode16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  pszClass
; dword ptr [ebp+16]:  pszEnumKey
; dword ptr [ebp+20]:  pDevNode
; dword ptr [ebp+24]:  pdwFreePointer
;
public IILookupDevNode16@20
IILookupDevNode16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	leave
	retn	20





;
public FreeDevNode16@4
FreeDevNode16@4:
	mov	cl,1
; FreeDevNode16(16) = FreeDevNode16(32) {}
;
; dword ptr [ebp+8]:  dwFreePointer
;
public IIFreeDevNode16@4
IIFreeDevNode16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwFreePointer: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public IcsUninstall16@0
IcsUninstall16@0:
	mov	cl,0
; IcsUninstall16(16) = IcsUninstall16(32) {}
;
;
public IIIcsUninstall16@0
IIIcsUninstall16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef IcsUninstall16:far16
externDef FreeDevNode16:far16
externDef LookupDevNode16:far16
externDef FindClassDev16:far16
externDef CallClassInstaller16:far16


FT_thkTargetTable label word
	dw	offset IcsUninstall16
	dw	   seg IcsUninstall16
	dw	offset FreeDevNode16
	dw	   seg FreeDevNode16
	dw	offset LookupDevNode16
	dw	   seg LookupDevNode16
	dw	offset FindClassDev16
	dw	   seg FindClassDev16
	dw	offset CallClassInstaller16
	dw	   seg CallClassInstaller16




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	043a5h	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\theapp.h ===
//
// TheApp.h
//
//		Application header for NCONN32.DLL
//

#pragma once


#include "resource.h"

extern HINSTANCE g_hInstance;

typedef DWORD DEVINST;
typedef DWORD DEVNODE;

// 16-bit function prototypes, including thunk connection point
//
extern "C" BOOL WINAPI thk_ThunkConnect32(LPCSTR lpDll16, LPCSTR lpDll32, HINSTANCE hDllInst, DWORD dwReason);
extern "C" DWORD WINAPI CallClassInstaller16(HWND hwndParent, LPCSTR lpszClassName, LPCSTR lpszDeviceID);
extern "C" HRESULT WINAPI FindClassDev16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszDeviceID);
extern "C" HRESULT WINAPI LookupDevNode16(HWND hwndParent, LPCSTR pszClass, LPCSTR pszEnumKey, DEVNODE FAR* pDevNode, DWORD FAR* pdwFreePointer);
extern "C" HRESULT WINAPI FreeDevNode16(DWORD dwFreePointer);
extern "C" HRESULT WINAPI IcsUninstall16(void);

// Binding functions
//
int  WINAPI EnumMatchingNetBindings(LPCSTR pszParentBinding, LPCSTR pszDeviceID, LPSTR** pprgBindings);
VOID RemoveBindingFromParent(HKEY hkeyParentBindingsKey, LPCSTR pszBinding);
BOOL WINAPI IsValidNetEnumKey(LPCSTR pszClass, LPCSTR pszDevice, LPCSTR pszEnumSubKey);
BOOL WINAPI FindValidNetEnumKey(LPCSTR pszClass, LPCSTR pszDevice, LPSTR pszBuf, int cchBuf);
int  WINAPI EnumNetBindings(LPCSTR pszParentBinding, LPSTR** pprgBindings);
int  WINAPI EnumMatchingNetBindings(LPCSTR pszParentBinding, LPCSTR pszDeviceID, LPSTR** pprgBindings);
BOOL WINAPI RemoveBrokenNetItems(LPCSTR pszClass, LPCSTR pszDeviceID);
BOOL GetDeviceInterfaceList(LPCSTR pszClass, LPCSTR pszDeviceID, LPCSTR pszInterfaceType, LPSTR pszBuf, int cchBuf);
BOOL CheckMatchingInterface(LPCSTR pszList1, LPCSTR pszList2);
BOOL GetDeviceLowerRange(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf);
BOOL GetDeviceUpperRange(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf);
HRESULT FindAndCloneNetEnumKey(LPCSTR pszClass, LPCSTR pszDeviceID, LPSTR pszBuf, int cchBuf);
HRESULT CloneNetClassKey(LPCSTR pszExistingDriver, LPSTR pszNewDriverBuf, int cchNewDriverBuf);
HRESULT OpenNetEnumKey(CRegistry& reg, LPCSTR pszSubKey, REGSAM dwAccess);
HRESULT DeleteClassKeyReferences(LPCSTR pszClass, LPCSTR pszDeviceID);
BOOL IsNetClassKeyReferenced(LPCSTR pszClassKey);
BOOL WINAPI DoesBindingMatchDeviceID(LPCSTR pszBinding, LPCSTR pszDeviceID);

// Protocol functions
//
BOOL    WINAPI IsProtocolBoundToAnyAdapter(LPCSTR pszProtocolID);
HRESULT WINAPI BindProtocolToOnlyOneAdapter(LPCSTR pszProtocolDeviceID, LPCSTR pszAdapterKey, BOOL bIgnoreVirtualNics);
HRESULT WINAPI BindProtocolToAllAdapters(LPCSTR pszProtocolDeviceID);
HRESULT BindProtocolToAdapter(HKEY hkeyAdapterBindings, LPCSTR pszProtocolDeviceID, BOOL bEnableSharing);

// Sharing functions
//
HRESULT WINAPI EnableDisableProtocolSharing(LPCTSTR pszProtocolDeviceID, BOOL bEnable, BOOL bDialUp);
HRESULT WINAPI EnableSharingOnNetBinding(LPCSTR pszNetBinding);
HRESULT WINAPI DisableSharingOnNetBinding(LPCSTR pszNetBinding);
HRESULT CreateNewFilePrintSharing(LPSTR pszBuf, int cchBuf);
HRESULT WINAPI EnableFileSharing();
HRESULT WINAPI EnablePrinterSharing();

// Config manager functions
//
BOOL  WINAPI IsNetAdapterBroken(const NETADAPTER* pAdapter);
BOOL  WINAPI GetNetAdapterStatus(const NETADAPTER* pAdapter, DWORD* pdwStatus, DWORD* pdwProblemNumber);
DWORD WINAPI GetNetAdapterDevNode(NETADAPTER* pAdapter);

DWORD GetChildDevice(OUT DWORD* pdnChildInst, IN DWORD dnDevInst, IN OUT HINSTANCE *phInstance, IN ULONG ulFlags);
DWORD GetSiblingDevice(OUT DWORD* pdnChildInst, IN DWORD dnDevInst, IN HINSTANCE hInstance, IN ULONG ulFlags);
DWORD GetDeviceIdA(IN DWORD dnDevInst, OUT char** Buffer, OUT ULONG* pLength, IN ULONG ulFlags);
DWORD GetDevNodeRegistryPropertyA(IN DWORD dnDevInst, IN ULONG ulProperty, OUT PULONG pulRegDataType, OUT PVOID Buffer, IN OUT PULONG pulLength, IN ULONG ulFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\util.cpp ===
#include "stdafx.h"
#include "nconnwrap.h"

#define NO_MAKELNKFILE
#include "..\shared\util.cpp"
#include "..\shared\netutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\vxd32.cpp ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    vxd32.c

    This module contains the Win32-dependent VxD interface.

    The following functions are exported by this module:

        OsOpenVxdHandle
        OsCloseVxdHandle
        OsSubmitVxdRequest


    FILE HISTORY:
        KeithMo     16-Jan-1994 Created.

*/

#include "stdafx.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//  Private constants.
//

#define DLL_ASSERT          ASSERT


//
//  Private types.
//


//
//  Private globals.
//

#ifdef DEBUG

DWORD   LastVxdOpcode;
LPVOID  LastVxdParam;
DWORD   LastVxdParamLength;

#endif  // DEBUG


//
//  Private prototypes.
//


//
//  Public functions.
//

/*******************************************************************

    NAME:       OsOpenVxdHandle

    SYNOPSIS:   Opens a handle to the specified VxD.

    ENTRY:      VxdName - The ASCII name of the target VxD.

                VxdId - The unique ID of the target VxD.

    RETURNS:    DWORD - A handle to the target VxD if successful,
                    0 if not.

    HISTORY:
        KeithMo     16-Jan-1994 Created.
        DavidKa     18-Apr-1994 Dynamic load.

********************************************************************/
DWORD
OsOpenVxdHandle(
    CHAR* VxdName,
    WORD  VxdId
    )
{
    HANDLE  VxdHandle;
    CHAR    VxdPath[MAX_PATH];
    static  CONST CHAR VxDPathString[] = "\\\\.\\";
    static  CONST CHAR VxDExtString[] = ".VXD";
    CONST   SIZE_T  Remaining = sizeof( VxdPath ) - 
                                sizeof( VxDPathString ) - 
                                sizeof( VxDExtString ) + 
                                1;

    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdName != NULL );
    DLL_ASSERT( VxdId != 0 );
    if ( strlen( VxdName ) >= Remaining )
        return 0; 

    //
    //  Build the VxD path.
    //

    strcpy( VxdPath, VxDPathString);
    strcat( VxdPath, VxdName);

    //
    //  Open the device.
    //
    //  First try the name without the .VXD extension.  This will
    //  cause CreateFile to connect with the VxD if it is already
    //  loaded (CreateFile will not load the VxD in this case).
    //

    VxdHandle = CreateFileA( VxdPath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if( VxdHandle == INVALID_HANDLE_VALUE )
    {
        //
        //  Not found.  Append the .VXD extension and try again.
        //  This will cause CreateFile to load the VxD.
        //

        strcat( VxdPath, VxDExtString );
        VxdHandle = CreateFileA( VxdPath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_DELETE_ON_CLOSE,
                                 NULL );
    }

    if( VxdHandle != INVALID_HANDLE_VALUE )
    {
        return (DWORD)VxdHandle;
    }

    return 0;

}   // OsOpenVxdHandle

/*******************************************************************

    NAME:       OsCloseVxdHandle

    SYNOPSIS:   Closes an open VxD handle.

    ENTRY:      VxdHandle - The open VxD handle to close.

    HISTORY:
        KeithMo     16-Jan-1994 Created.

********************************************************************/
VOID
OsCloseVxdHandle(
    DWORD VxdHandle
    )
{
    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdHandle != 0 );

    CloseHandle( (HANDLE)VxdHandle );

}   // OsCloseVxdHandle

/*******************************************************************

    NAME:       OsSubmitVxdRequest

    SYNOPSIS:   Submits a request to the specified VxD.

    ENTRY:      VxdHandle - An open VxD handle.

                OpCode - Specifies the operation to perform.

                Param - Points to operation-specific parameters.

                ParamLength - The size (in BYTEs) of *Param.

    RETURNS:    INT - Result code.  0 if successful, !0 if not.

    HISTORY:
        KeithMo     16-Jan-1994 Created.

********************************************************************/
INT
OsSubmitVxdRequest(
    DWORD  VxdHandle,
    INT    OpCode,
    LPVOID Param,
    INT    ParamLength
    )
{
    DWORD BytesRead;
    INT   Result = 0;

    //
    //  Sanity check.
    //

    DLL_ASSERT( VxdHandle != 0 );
    DLL_ASSERT( ( Param != NULL ) || ( ParamLength == 0 ) );

#ifdef DEBUG

    LastVxdOpcode      = (DWORD)OpCode;
    LastVxdParam       = Param;
    LastVxdParamLength = (DWORD)ParamLength;

#endif  // DEBUG

    //
    //  Just do it.
    //

    if( !DeviceIoControl( (HANDLE)VxdHandle,
                          OpCode,
                          Param,
                          ParamLength,
                          Param,
                          ParamLength,
                          &BytesRead,
                          NULL ) )
    {
        Result = GetLastError();
    }

    return Result;

}   // OsSubmitVxdRequest


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\vxd32.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vxd32.h

Abstract:


Author:

    William Ingle (bukku) 04-Apr-2001

Revision History:

    04-Apr-2001  billi  Created

--*/

#pragma once

#define VDHCP_Device_ID     0x049A

#ifdef __cplusplus
extern "C" {
#endif

DWORD OsOpenVxdHandle( CHAR* VxdName, WORD VxdId );
VOID  OsCloseVxdHandle( DWORD VxdHandle );
INT   OsSubmitVxdRequest( DWORD VxdHandle, INT OpCode, LPVOID Param, INT ParamLength );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\dllmain.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "globals.h"


BOOL DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID /*fProcessUnload*/)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        DisableThreadLibraryCalls(hinstDll);

        g_hinst = hinstDll;
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\globals.cpp ===
#include <windows.h>

HINSTANCE g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconn32\w9xdhcp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       W 9 X D H C P . H
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   04 04 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IP_TYPES_INCLUDED
#include <iptypes.h>
#endif

//
// defines
//

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3
#define DHCP_CLIENT_API             4
#define DHCP_IS_MEDIA_DISCONNECTED  5


//
// types
//

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

//
// IP_ADDRESS - access an IP address as a single DWORD or 4 BYTEs
//

typedef union {
    DWORD d;
    BYTE b[4];
} IP_ADDRESS, *PIP_ADDRESS, IP_MASK, *PIP_MASK;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//

typedef struct _ADAPTER_INFO 
{
    struct _ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 1];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    UINT Index;
    UINT Type;
    UINT DhcpEnabled;
    PIP_ADDR_STRING CurrentIpAddress;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
    BOOL fMediaDisconnected;
} 
ADAPTER_INFO, *PADAPTER_INFO;


BOOL  IsMediaDisconnected( IN OUT DWORD iae_context );
DWORD DhcpReleaseAdapterIpAddress( PADAPTER_INFO AdapterInfo );
DWORD DhcpRenewAdapterIpAddress( PADAPTER_INFO AdapterInfo );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\debug.c ===
#include <windows.h>

#pragma warning(disable:4115)  // named type definition in parentheses
#pragma warning(disable:4201)  // nonstandard extension used : nameless struct/union

#include <ccstock.h>

#pragma warning(disable:4096)  // '__cdecl' must be used with '...'
#pragma warning(disable:4057)  // 'function' : '__int64 *' differs in indirection to slightly different base types from 'unsigned __int64 *'
#pragma warning(disable:4127)  // conditional expression is constant
#pragma warning(disable:4214)  // nonstandard extension used : bit field types other than int
#pragma warning(disable:4505)  // 'MyStrToIntExW' : unreferenced local function has been removed
#pragma warning(disable:4706)  // assignment within conditional expresion


//
// Here's some build hokiness. First include debug.h to get the standard debug include file.
// Then define DECLARE_DEBUG and let ..\..\..\lib\debug.c include debug.h so the appropriate
// debug variables are declared.
//

#include <debug.h>
#define DECLARE_DEBUG

#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "ncxpnt"
#define SZ_MODULE           "NCXPNT"



#include "..\..\..\lib\debug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\globals.h ===
extern HINSTANCE g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\nconnnt.cpp ===
#include <windows.h>

#include "netconn.h"
#include "globals.h"
#include "localstr.h"

#include <netcfgx.h>
#include <devguid.h>
#include <shlwapi.h>

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

#pragma warning(disable:4100)  // unreferenced formal parameter

enum NetApplyChanges
{
    Apply,
    Cancel,
    Nothing
};

HRESULT UninitNetCfg(INetCfg* pnetcfg, INetCfgLock* pnetcfglock, NetApplyChanges applychanges)
{
    HRESULT hr = S_OK;

    if (Apply == applychanges)
    {
        hr = pnetcfg->Apply();
    }
    else if (Cancel == applychanges)
    {
        hr = pnetcfg->Cancel();
    }

    // Note: Don't set hr to anything after this point. We want to preserve the value from Apply
    // or Cancel - especially Apply which may signal a reboot is necessary.

    // Release even if this stuff above fails. Caller probably won't check return.
    
    pnetcfg->Uninitialize();

    if (pnetcfglock)
    {
        pnetcfglock->ReleaseWriteLock();
        pnetcfglock->Release();
    }

    pnetcfg->Release();

    CoUninitialize();

    return hr;
}

HRESULT InitNetCfg(INetCfg** ppnetcfg, INetCfgLock** ppnetcfglock)
{
    BOOL fLockAquired = FALSE;

    *ppnetcfg = NULL;
    
    if (ppnetcfglock)
    {
        *ppnetcfglock = NULL;
    }

    HRESULT hr = CoInitialize(NULL);
    
    if (SUCCEEDED(hr))
    {

        hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_SERVER, 
                               IID_INetCfg, (void**) ppnetcfg);

        if (SUCCEEDED(hr))
        {
            if (ppnetcfglock)
            {
                hr = (*ppnetcfg)->QueryInterface(IID_INetCfgLock, (void**) ppnetcfglock);

                if (SUCCEEDED(hr))
                {
                    LPWSTR pszCurrentLockHolder;
                    hr = (*ppnetcfglock)->AcquireWriteLock(5, WIZARDNAME, &pszCurrentLockHolder);
                    
                    if (S_OK == hr)
                    {
                        fLockAquired = TRUE;
                    }
                    else
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }
                
            if (SUCCEEDED(hr))
            {
                hr = (*ppnetcfg)->Initialize(NULL);
            }
        }

        // Clean up our mess if we failed
        if (FAILED(hr))
        {
            if (ppnetcfglock)
            {
                if (*ppnetcfglock)
                {
                    if (fLockAquired)
                    {
                        (*ppnetcfglock)->ReleaseWriteLock();
                    }

                    (*ppnetcfglock)->Release();
                    *ppnetcfglock = NULL;
                }
            }

            if (*ppnetcfg)
            {
                (*ppnetcfg)->Release();
                *ppnetcfg = NULL;
            }
        }
    }

    return hr;
}

LPWSTR NineXIdToComponentId(LPCWSTR psz9xid)
{
    LPWSTR pszComponentId = NULL;

    if (0 == StrCmpI(psz9xid, SZ_PROTOCOL_TCPIP))
    {
        pszComponentId = &NETCFG_TRANS_CID_MS_TCPIP;
    } else if (0 == StrCmpI(psz9xid, SZ_CLIENT_MICROSOFT))
    {
        pszComponentId = &NETCFG_CLIENT_CID_MS_MSClient;
    }

    return pszComponentId;
}

// EnumComponents and TestRunDll are test-only stuff and should be removed - TODO
void EnumComponents(INetCfg* pnetcfg, const GUID* pguid)
{
    IEnumNetCfgComponent* penum;

    HRESULT hr = pnetcfg->EnumComponents(pguid, &penum);

    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pcomponent;

        while (S_OK == (hr = penum->Next(1, &pcomponent, NULL)))
        {
            LPWSTR pszId;
            LPWSTR pszName;

            hr = pcomponent->GetId(&pszId);
            if (SUCCEEDED(hr))
            {
                OutputDebugString(pszId);
                CoTaskMemFree(pszId);
            }

            hr = pcomponent->GetDisplayName(&pszName);
            if (SUCCEEDED(hr))
            {
                OutputDebugString(L" - ");
                OutputDebugString(pszName);
                CoTaskMemFree(pszName);
            }

            OutputDebugString(L"\n");

            pcomponent->Release();
        }

        penum->Release();
    }
}

void APIENTRY TestRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);

    INetCfg *pnetcfg = NULL;

    hr = CoCreateInstance( CLSID_CNetCfg, NULL, CLSCTX_SERVER, 
                           IID_INetCfg, (LPVOID*)&pnetcfg);

    if (SUCCEEDED(hr))
    {
        hr = pnetcfg->Initialize(NULL);

        if (SUCCEEDED(hr))
        {
            OutputDebugString(L"GUID_DEVCLASS_NET\n");
            EnumComponents(pnetcfg, &GUID_DEVCLASS_NET);
            
            OutputDebugString(L"\nGUID_DEVCLASS_NETTRANS\n");
            EnumComponents(pnetcfg, &GUID_DEVCLASS_NETTRANS);

            OutputDebugString(L"\nGUID_DEVCLASS_NETCLIENT\n");
            EnumComponents(pnetcfg, &GUID_DEVCLASS_NETCLIENT);

            OutputDebugString(L"\nGUID_DEVCLASS_NETSERVICE\n");
            EnumComponents(pnetcfg, &GUID_DEVCLASS_NETSERVICE);

            pnetcfg->Uninitialize();
        }

        pnetcfg->Release();
    }

    CoUninitialize();
}


BOOL IsComponentInstalled(LPCWSTR pszId)
{
    BOOL fInstalled = FALSE;
    INetCfg* pnetcfg;
    
    HRESULT hr = InitNetCfg(&pnetcfg, NULL);

    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pcomponent;

        HRESULT hr = pnetcfg->FindComponent(pszId, &pcomponent);

        if (S_OK == hr)
        {
            // Component found
            pcomponent->Release();
            fInstalled = TRUE;
        }

        hr = UninitNetCfg(pnetcfg, NULL, Nothing);
    }

    return fInstalled;
}


HRESULT InstallComponent(const GUID* pguidType, LPCWSTR pszId)
{
    INetCfg* pnetcfg;
    INetCfgLock* pnetcfglock;

    // Init & aquire a write lock
    HRESULT hr = InitNetCfg(&pnetcfg, &pnetcfglock);

    if (SUCCEEDED(hr))
    {
        INetCfgClassSetup* pnetcfgclasssetup;

        hr = pnetcfg->QueryNetCfgClass(pguidType, IID_INetCfgClassSetup, (void**) &pnetcfgclasssetup);

        if (SUCCEEDED(hr))
        {
            INetCfgComponent* pNewComp;
            OBO_TOKEN obotoken;
            ZeroMemory(&obotoken, sizeof(OBO_TOKEN));
            obotoken.Type = OBO_USER;

            hr = pnetcfgclasssetup->Install(
                pszId,
                &obotoken,
                0, /* NSF_POSTSYSINSTALL ? */
                0,
                NULL,
                NULL,
                &pNewComp);

            if (SUCCEEDED(hr))
            {
                pNewComp->Release();
            }

            pnetcfgclasssetup->Release();
        }

        // Free our mess and apply changes if we succeeded in installing our component
        hr = UninitNetCfg(pnetcfg, pnetcfglock, (SUCCEEDED(hr)) ? Apply : Cancel);
    }

    return hr;
}



// NOT USED.  But keep around since NetConnFree is used.
//
LPVOID WINAPI NetConnAlloc(DWORD cbAlloc)
{
    return LocalAlloc(LMEM_FIXED, cbAlloc);
}

// USED.
//
VOID WINAPI NetConnFree(LPVOID pMem)
{
    if (pMem)
        LocalFree(pMem);
}

// USED.  Only one call with (SZ_PROTOCOL_TCPIP, TRUE).
//
BOOL WINAPI IsProtocolInstalled(LPCWSTR pszProtocolDeviceID, BOOL bExhaustive)
{
    BOOL fSuccess = FALSE;
    LPCWSTR pszTransportId = NineXIdToComponentId(pszProtocolDeviceID);

    if (pszTransportId)
    {
        fSuccess = IsComponentInstalled(pszTransportId);
    }

    return fSuccess;
}

// USED.  Called once with (FALSE)
//
BOOL WINAPI IsMSClientInstalled(BOOL bExhaustive)
{
    return IsComponentInstalled(NETCFG_CLIENT_CID_MS_MSClient);
}

// USED.  Only one call with (hwnd, NULL, NULL)
//
HRESULT WINAPI InstallTCPIP(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
    HRESULT hr =  InstallComponent(&GUID_DEVCLASS_NETTRANS, NETCFG_TRANS_CID_MS_TCPIP);

    // Map the reboot result code
    if (NETCFG_S_REBOOT == hr)
    {
        hr = NETCONN_NEED_RESTART;
    }

    return hr;
}

// USED.  Called once with (hwnd, NULL, NULL)
//
HRESULT WINAPI InstallMSClient(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
    HRESULT hr =  InstallComponent(&GUID_DEVCLASS_NETCLIENT, NETCFG_CLIENT_CID_MS_MSClient);

    // Map the reboot result code
    if (NETCFG_S_REBOOT == hr)
    {
        hr = NETCONN_NEED_RESTART;
    }

    return hr;
}

// USED.  Called once with (hwnd, NULL, NULL).
//
HRESULT WINAPI InstallSharing(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
    HRESULT hr = InstallComponent(&GUID_DEVCLASS_NETSERVICE, NETCFG_SERVICE_CID_MS_SERVER);

    // Map the reboot result code
    if (NETCFG_S_REBOOT == hr)
    {
        hr = NETCONN_NEED_RESTART;
    }

    return hr;
}

// USED.  Called once with (TRUE)
//
BOOL WINAPI IsSharingInstalled(BOOL bExhaustive)
{
    return IsComponentInstalled(NETCFG_SERVICE_CID_MS_SERVER);
}

// USED.  Called once with (SZ_CLIENT_MICROSOFT, TRUE).
//
BOOL WINAPI IsClientInstalled(LPCWSTR pszClient, BOOL bExhaustive)
{
    BOOL fSuccess = FALSE;
    LPCWSTR pszClientId = NineXIdToComponentId(pszClient);

    if (pszClientId)
    {
        fSuccess = IsComponentInstalled(pszClientId);
    }

    return fSuccess;
}

// USED.  Called four times.
// This is always TRUE on NT?
BOOL WINAPI IsAccessControlUserLevel()
{
    return TRUE;
}

// USED.  Called once.
// This can't be disabled on NT
HRESULT WINAPI DisableUserLevelAccessControl()
{
    return E_NOTIMPL;
}

#define CopyStrMacro(Dest) if (SUCCEEDED(hr)) {StrCpyNW((Dest), pszTemp, ARRAYSIZE((Dest))); CoTaskMemFree(pszTemp);}

HRESULT FillAdapterInfo(INetCfgComponent* pcomponent, NETADAPTER* pNetAdapter)
{
    HRESULT hr = S_OK;

    LPWSTR pszTemp;
    DWORD dwCharacteristics;

    // szDisplayName
    hr = pcomponent->GetDisplayName(&pszTemp);
    if (SUCCEEDED(hr))
    {
        OutputDebugString(L"\n\nDisplayName:");
        OutputDebugString(pszTemp);

        StrCpyNW(pNetAdapter->szDisplayName, pszTemp, ARRAYSIZE(pNetAdapter->szDisplayName));
        CoTaskMemFree(pszTemp);
    }

    // szDeviceID
    hr = pcomponent->GetId(&pszTemp);
    if (SUCCEEDED(hr))
    {
        OutputDebugString(L"\nId:");
        OutputDebugString(pszTemp);

        StrCpyNW(pNetAdapter->szDeviceID, pszTemp, ARRAYSIZE(pNetAdapter->szDeviceID));
        CoTaskMemFree(pszTemp);
    }

    // review - unused as of now - maybe remove
    hr = pcomponent->GetPnpDevNodeId(&pszTemp);
    if (SUCCEEDED(hr))
    {
        OutputDebugString(L"\nPnpDevNodeId:");
        OutputDebugString(pszTemp);
    }

    // review - assuming szEnumKey is actually the BindName since it is used in EnumMatchingNetBindings.
    hr = pcomponent->GetBindName(&pszTemp);
    if (SUCCEEDED(hr))
    {
        OutputDebugString(L"\nBindName:");
        OutputDebugString(pszTemp);

        StrCpyNW(pNetAdapter->szEnumKey, pszTemp, ARRAYSIZE(pNetAdapter->szEnumKey));
        CoTaskMemFree(pszTemp);
    }

    // Also usused
    DWORD dwStatus;
    hr = pcomponent->GetDeviceStatus(&dwStatus);
    if (SUCCEEDED(hr))
    {
        WCHAR szTemp[20];
        wnsprintf(szTemp, ARRAYSIZE(szTemp), L"%x", dwStatus);
        OutputDebugString(L"\nDeviceStatus:");
        OutputDebugString(szTemp);
    }

    hr = pcomponent->GetCharacteristics(&dwCharacteristics);
    if (SUCCEEDED(hr))
    {
        WCHAR szTemp[20];
        wnsprintf(szTemp, ARRAYSIZE(szTemp), L"%x", dwCharacteristics);
        OutputDebugString(L"\nCharacteristics:");
        OutputDebugString(szTemp);
    }

    // szClassKey ??

    // szManufacturer - don't care
    pNetAdapter->szManufacturer[0] = 0;

    // szInfFileName - don't care
    pNetAdapter->szInfFileName[0] = 0;

    // bNicType - review
    pNetAdapter->bNicType = (BYTE)((dwCharacteristics & NCF_VIRTUAL) ? NIC_VIRTUAL : NIC_UNKNOWN);
    
    // bNetType - review
    pNetAdapter->bNetType = (BYTE)((dwCharacteristics & NCF_PHYSICAL) ? NETTYPE_LAN : NETTYPE_PPTP);

    // bNetSubType - review
    pNetAdapter->bNetSubType = SUBTYPE_NONE;

    // bIcsStatus (internet connection sharing??)- review
    pNetAdapter->bIcsStatus = ICS_NONE;

    // bError - review
    pNetAdapter->bError = NICERR_NONE;

    // bWarning - review
    pNetAdapter->bWarning = NICWARN_NONE;

    return S_OK;
}

#define ALLOCGROWBY 10
int AllocAndGetAdapterInfo(IEnumNetCfgComponent* penum, NETADAPTER** pprgNetAdapters)
{
    *pprgNetAdapters = NULL;

    UINT iMaxItems = 0;
    UINT iCurrentItem = 0;

    HRESULT hr = S_OK;

    while (S_OK == hr)
    {
        INetCfgComponent* pnetadapter;

        hr = penum->Next(1, &pnetadapter, NULL);

        if (S_OK == hr)
        {
            if (iCurrentItem == iMaxItems)
            {
                // Time to allocate some memory
                iMaxItems += ALLOCGROWBY;

                if (*pprgNetAdapters)
                {
                    NETADAPTER* pTemp = (NETADAPTER*) LocalReAlloc(*pprgNetAdapters, sizeof(NETADAPTER) * iMaxItems, LMEM_ZEROINIT);
                    if (!pTemp)
                    {
                        hr = E_OUTOFMEMORY;
                        LocalFree(*pprgNetAdapters);
                        *pprgNetAdapters = NULL;
                    }
                    else
                    {
                        *pprgNetAdapters = pTemp;
                    }
                }
                else
                {
                    *pprgNetAdapters = (NETADAPTER*) LocalAlloc(LMEM_ZEROINIT, sizeof(NETADAPTER) * iMaxItems);

                    if (!*pprgNetAdapters)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = FillAdapterInfo(pnetadapter, (*pprgNetAdapters) + iCurrentItem);
            }

            pnetadapter->Release();
            iCurrentItem ++;
        }
        else
        {
            // We've got as many as we can; we're done
        }
    }

    return iCurrentItem;
}

// USED.  Called four times - out parameter is never NULL.
//
int WINAPI EnumNetAdapters(NETADAPTER FAR** pprgNetAdapters)
{
    *pprgNetAdapters = NULL;

    int iAdapters = 0;
    INetCfg* pnetcfg;
    HRESULT hr = InitNetCfg(&pnetcfg, NULL);

    if (SUCCEEDED(hr))
    {
        IEnumNetCfgComponent* penum;

        hr = pnetcfg->EnumComponents(&GUID_DEVCLASS_NET, &penum);

        if (SUCCEEDED(hr))
        {
            iAdapters = AllocAndGetAdapterInfo(penum, pprgNetAdapters);
        }

        hr = UninitNetCfg(pnetcfg, NULL, Nothing);
    }

    return iAdapters;
}

// USED.  Called once with bAutodial TRUE or FALSE and szConnection not used.
//
void WINAPI EnableAutodial(BOOL bAutodial, LPCWSTR szConnection = NULL)
{

}

// USED.  Called twice.
//
BOOL WINAPI IsAutodialEnabled()
{
    return FALSE;
}

// USED.  Called once.
//
void WINAPI SetDefaultDialupConnection(LPCWSTR pszConnectionName)
{
}

// Used.  Called once.
//
void WINAPI GetDefaultDialupConnection(LPWSTR pszConnectionName, int cchMax)
{
}

// Used.  Called four times.  Second parameter is always SZ_PROTOCOL_TCPIP.
// Update: Actually only called once from SetHomeConnection. The other three are #if 0'd.
// Update2: SetHomeConnection needs to have a different implementation for NT, so this is never really called.
//
int WINAPI EnumMatchingNetBindings(LPCWSTR pszParentBinding, LPCWSTR pszDeviceID, LPWSTR** pprgBindings)
{
    return 0;
}

HRESULT WINAPI RestartNetAdapter(DWORD devnode)
{
    return E_NOTIMPL;
}

// NOT USED.
//
/*
HRESULT WINAPI InstallProtocol(LPCWSTR pszProtocol, HWND hwndParent, PROGRESS_CALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
// 
/*
HRESULT WINAPI RemoveProtocol(LPCWSTR pszProtocol)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI EnableBrowseMaster()
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
BOOL WINAPI IsFileSharingEnabled()
{
    return FALSE;
}
*/

// NOT USED.
//
/*
BOOL WINAPI IsPrinterSharingEnabled()
{
    return FALSE;
}
*/

// NOT USED.
//
/*
BOOL WINAPI FindConflictingService(LPCWSTR pszWantService, NETSERVICE* pConflict)
{
    return FALSE;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI EnableSharingAppropriately()
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI InstallNetAdapter(LPCWSTR pszDeviceID, LPCWSTR pszInfPath, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvCallbackParam)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI EnableQuickLogon()
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI DetectHardware(LPCWSTR pszDeviceID)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
BOOL WINAPI IsProtocolBoundToAdapter(LPCWSTR pszProtocolID, const NETADAPTER* pAdapter)
{
    return FALSE;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI EnableNetAdapter(const NETADAPTER* pAdapter)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI RemoveClient(LPCWSTR pszClient)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI RemoveGhostedAdapters(LPCWSTR pszDeviceID)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
HRESULT WINAPI RemoveUnknownAdapters(LPCWSTR pszDeviceID)
{
    return E_NOTIMPL;
}
*/

// NOT USED.
//
/*
BOOL WINAPI DoesAdapterMatchDeviceID(const NETADAPTER* pAdapter, LPCWSTR pszDeviceID)
{
    return FALSE;
}
*/

// NOT USED.
//
/*
BOOL WINAPI IsAdapterBroadband(const NETADAPTER* pAdapter)
{
    return FALSE;
}
*/

// NOT USED.
//
/*
void WINAPI SaveBroadbandSettings(LPCWSTR pszBroadbandAdapterNumber)
{
}
*/

// NOT USED.
//
/*
BOOL WINAPI UpdateBroadbandSettings(LPWSTR pszEnumKeyBuf, int cchEnumKeyBuf)
{
    return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\setup\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\netutil.cpp ===
//
// NetUtil.cpp
//

#include <windows.h>

#include "netconn.h"
#include "globals.h"
#include "localstr.h"

#include "..\shared\netutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\setup\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WinXPChk.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\nconnnt\netip.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T I P. C P P
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#include <windows.h>
#include <devguid.h>
#include <netcon.h>
          
#include "netconn.h"
#include "NetIp.h"
#include "debug.h"
#include "util.h"


// Prototype for iphlpapi routine. For some reason, this isn't defined
// in any header.

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD (APIENTRY *LPFNSETADAPTERIPADDRESS)( 
    LPSTR AdapterName,
    BOOL EnableDHCP,
    ULONG IPAddress,
    ULONG SubnetMask,
    ULONG DefaultGateway
    );

#ifdef __cplusplus
}
#endif



HRESULT HrSetAdapterIpAddress(  
    LPSTR AdapterName,
    BOOL  EnableDHCP,
    ULONG IPAddress,
    ULONG SubnetMask,
    ULONG DefaultGateway )
//+---------------------------------------------------------------------------
//
// Function:  HrSetAdapterIpAddress
//
// Purpose:   
//
// Arguments: 
//      LPSTR AdapterName,
//      BOOL  EnableDHCP,
//      ULONG IPAddress,
//      ULONG SubnetMask,
//      ULONG DefaultGateway
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT hr = E_INVALIDARG;
    
    ASSERT( AdapterName );
    
    if ( AdapterName )
    {
        HMODULE hIpHlpApi = LoadLibrary(L"iphlpapi.dll");
        
        hr = E_FAIL;
        
        if ( hIpHlpApi )
        {        
            LPFNSETADAPTERIPADDRESS pfnSetAdapterIpAddress = 
                reinterpret_cast<LPFNSETADAPTERIPADDRESS>
                (GetProcAddress( hIpHlpApi, "SetAdapterIpAddress" ));
                
            if ( pfnSetAdapterIpAddress )
            {
                DWORD dwStatus = (*pfnSetAdapterIpAddress)( 
                
                    AdapterName, EnableDHCP, IPAddress, SubnetMask, DefaultGateway );

                hr = ( dwStatus ) ? HrFromWin32Error( dwStatus ) : S_OK;

                TraceMsg(TF_ALWAYS, "SetAdapterIpAddress = %lx  hr = %lx", dwStatus, hr );
            }
            else
            {
                TraceMsg(TF_ALWAYS, "GetProcAddress( hIpHlpApi, SetAdapterIpAddress ) FAILED!" );
            }
        }
        else
        {
            TraceMsg(TF_ALWAYS, "LoadLibrary( iphlpapi.dll ) FAILED!" );
        }
    }
    
    TraceMsg(TF_ALWAYS, "HrSetAdapterIpAddress = %lx", hr );
    return hr;
}



DWORD GetInterfaceInformation( OUT PIP_INTERFACE_INFO * ppInterfaceInfo )
//+---------------------------------------------------------------------------
//
// Function:  GetInterfaceInformation
//
// Purpose:   
//
// Arguments: PIP_INTERFACE_INFO * ppInterfaceInfo
//
// Returns:   Status
//
// Notes: 
//
{
    ASSERT( NULL != ppInterfaceInfo );

    LPBYTE  pBuffer      = NULL;
    DWORD   dwBufferSize = 2048;
    DWORD   dwStatus     = 0;
    
    for ( int i=0; i<2; i++ )
    {
        pBuffer = new BYTE[ dwBufferSize ];

        if ( NULL != pBuffer )
        {
             dwStatus = GetInterfaceInfo( (PIP_INTERFACE_INFO) pBuffer, &dwBufferSize );

            if ( ERROR_INSUFFICIENT_BUFFER == dwStatus )
            {
                if ( NULL != pBuffer ) 
                {
                    delete [] pBuffer;
                    pBuffer = NULL;
                }
            }
            else
            {
                break;
            }
        }
        else
        {
            dwStatus = ERROR_OUTOFMEMORY;
            break;
        }
    }
        
    if ( STATUS_SUCCESS == dwStatus )
    {
        *ppInterfaceInfo = (PIP_INTERFACE_INFO) pBuffer;
    }
    
    TraceMsg(TF_ALWAYS, "GetInterfaceInformation = %lx", dwStatus );
    return dwStatus;
}



HRESULT EnableDhcpByGuid( LPOLESTR szwGuid )
//+---------------------------------------------------------------------------
//
// Function:  EnableDhcp
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT hr = E_INVALIDARG;

    ASSERT( szwGuid );
    
    if ( szwGuid )
    {
        char* pszName = NULL;
    
        hr = HrWideCharToMultiByte( szwGuid, &pszName );
        
        if ( SUCCEEDED(hr) )
        {
            hr = HrSetAdapterIpAddress( pszName, TRUE, 0, 0, 0 );
            
	       	delete [] pszName;
    	}
        else
        {
            TraceMsg(TF_ALWAYS, "HrWideCharToMultiByte( %s, &pszName ) FAILED!", szwGuid );
        }
    }

    TraceMsg(TF_ALWAYS, "EnableDhcp = %lx", hr );
    
    return hr;
}



HRESULT HrFindAndConfigureIp( LPOLESTR szwGuid, PIP_INTERFACE_INFO pInterfaceInfo, DWORD dwFlags )
//+---------------------------------------------------------------------------
//
// Function:  HrFindAndConfigureIp
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    ASSERT( szwGuid );
    ASSERT( pInterfaceInfo );
    
       HRESULT hr = E_FAIL;

    for ( LONG i=0L; i<pInterfaceInfo->NumAdapters; i++ )
    {
        WCHAR* szwName = (pInterfaceInfo->Adapter)[i].Name;
        
        // The Interface Info device name includes the full device name
        // prefix appended to the device guid.  To solve this we move
        // the WCHAR pointer past the prefix using the length of the
        // the guid string from the INetConnection*
        
        szwName += ( wcslen( szwName ) - wcslen( szwGuid ) );

        TraceMsg( TF_ALWAYS, "    %s", szwName );
        
        if ( wcscmp( szwGuid, szwName ) == 0 )
        {
            DWORD dwStatus = STATUS_SUCCESS;
        
            if ( HNW_ED_RELEASE & dwFlags )
            {
                dwStatus = IpReleaseAddress( &((pInterfaceInfo->Adapter)[i]) );
            }
            
            if ( ( HNW_ED_RENEW & dwFlags ) &&
                 ( STATUS_SUCCESS == dwStatus ) )
            {
                dwStatus = IpRenewAddress( &((pInterfaceInfo->Adapter)[i]) );
            }
            
            if ( STATUS_SUCCESS == dwStatus )
            {
                hr = S_OK;
                break;
            }                                    
        }
    }

    TraceMsg( TF_ALWAYS, "HrFindAndConfigureIp = %lx", hr );

    return hr;
}



HRESULT ConfigureIp( LPOLESTR szwGuid, DWORD dwFlags )
//+---------------------------------------------------------------------------
//
// Function:  ConfigureIp
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    ASSERT( szwGuid );
                    
    PIP_INTERFACE_INFO pInterfaceInfo;

    HRESULT  hr       = E_FAIL;
    DWORD    dwStatus = GetInterfaceInformation( &pInterfaceInfo );
    
    if ( STATUS_SUCCESS == dwStatus )
    {
        hr = HrFindAndConfigureIp( szwGuid, pInterfaceInfo, dwFlags );

        delete pInterfaceInfo;
    }
                        
    TraceMsg(TF_ALWAYS, "ConfigureIp = %lx", hr );

    return hr;
}


#ifdef __cplusplus
extern "C" {
#endif


HRESULT WINAPI HrEnableDhcp( VOID* pContext, DWORD dwFlags )
//+---------------------------------------------------------------------------
//
//  Function:   HrEnableDhcpIfLAN
//
//  Purpose:    
//
//  Arguments:  INetConnection* pConnection
//              DWORD           dwFlags
//
//  Returns:    HRESULT
//
//  Author:     billi  26/01/01
//
//  Notes:      
//
{
    HRESULT         hr          = E_INVALIDARG;
	INetConnection* pConnection = (INetConnection *)pContext;
    
    ASSERT( pConnection );
    
    if ( NULL != pConnection )
    {
        NETCON_PROPERTIES*  pProps;

        hr = pConnection->GetProperties( &pProps );
        
        if ( SUCCEEDED(hr) )
        {
            ASSERT( pProps );
            
            if ( NCM_LAN == pProps->MediaType )
            {
                OLECHAR szwGuid[ GUID_LENGTH + 1 ];
                
                if ( StringFromGUID2( pProps->guidId, szwGuid, GUID_LENGTH+1 ) )
                {
                    hr = EnableDhcpByGuid( szwGuid );
                
                    if ( SUCCEEDED(hr) && dwFlags )
                    {
                        hr = ConfigureIp( szwGuid, dwFlags );
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            
            NcFreeNetconProperties( pProps );
        }
    }
    
    TraceMsg(TF_ALWAYS, "HrEnableDhcp = %lx", hr);
    return hr;
}



BOOLEAN WINAPI IsAdapterDisconnected(
    VOID* pContext
    )
//+---------------------------------------------------------------------------
//
//  Function:   IsAdapterDisconnected
//
//  Purpose:    
//
//  Arguments:  VOID* pNA
//
//  Returns:    HRESULT
//
//  Author:     billi  11/04/01
//
//  Notes:      
//
{
	INetConnection*    pConnection = (INetConnection *)pContext;
    BOOLEAN            fUnplugged = FALSE;
    HRESULT            hr;
    NETCON_PROPERTIES* pncprops;
    
    ASSERT(pConnection);
    
    if ( pConnection )
    {
        hr = pConnection->GetProperties(&pncprops);
     
        if (SUCCEEDED(hr))
        {
            ASSERT(pncprops);
        
            fUnplugged = (NCS_MEDIA_DISCONNECTED == pncprops->Status);

            NcFreeNetconProperties(pncprops);
        }
    }

    return fUnplugged;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\setup\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Windows XP Version Checking Program"
#define VER_INTERNALNAME_STR            "WINXPCHK.EXE"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\defconn.h ===
//
// DefConn.h
//
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI EnableAutodial(BOOL bAutodial, LPCWSTR szConnection = NULL);
BOOL WINAPI IsAutodialEnabled();
void WINAPI SetDefaultDialupConnection(LPCWSTR pszConnectionName);
void WINAPI GetDefaultDialupConnection(LPWSTR pszConnectionName, int cchMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\debug.h ===
//
// Debug.h
//
//		Debug stuff for non-MFC projects.
//
// History:
//
//	 3/??/96	KenSh		Copied from InetSDK sample, added AfxTrace from MFC
//	 4/10/96	KenSh		Renamed AfxTrace to MyTrace to avoid conflicts
//							in projects that use MFC
//

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _DEBUG

	void __cdecl MyTrace(const char* lpszFormat, ...);
//	void DisplayAssert(char* pszMsg, char* pszAssert, char* pszFile, unsigned line);
	BOOL DisplayAssert(LPCSTR pszMessage, LPCSTR pszFile, unsigned line);

//	#define SZTHISFILE	static char _szThisFile[] = __FILE__;
	#define SZTHISFILE

	#define VERIFY(f)          ASSERT(f)
	#define DEBUG_ONLY(f)      (f)

	#ifndef TRACE
	#define TRACE              ::MyTrace
	#endif

	#define THIS_FILE          __FILE__

	#ifndef AfxDebugBreak
	#define AfxDebugBreak() _asm { int 3 }
	#endif

	#define ASSERTSZ(f, pszMsg) \
		do \
		{ \
		if (!(f) && DisplayAssert(pszMsg, THIS_FILE, __LINE__)) \
			AfxDebugBreak(); \
		} while (0) \

	#ifndef ASSERT
	#define ASSERT(f) \
		do \
		{ \
		if (!(f) && DisplayAssert(NULL, THIS_FILE, __LINE__)) \
			AfxDebugBreak(); \
		} while (0) \

	#endif

//	#define FAIL(szMsg)                                         \
//			{ static char szMsgCode[] = szMsg;                  \
//			DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }

//	// macro that checks a pointer for validity on input
//	//
//	#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else // _DEBUG

	#define SZTHISFILE

	#define VERIFY(f)          ((void)(f))
	#define DEBUG_ONLY(f)      ((void)0)

    inline void __cdecl MyTrace(const char* /*lpszFormat*/, ...) { }
	#define TRACE 1 ? (void)0 : ::MyTrace

	#define ASSERTSZ(fTest, err)
	#define ASSERT(fTest)
	#define FAIL(err)
	#define CHECK_POINTER(val)

#endif // !_DEBUG

#ifdef __cplusplus
}
#endif

#endif // !__DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\setup\winxpchk.cpp ===
// WinXPChk.cpp : A small program runs inside IExpress package to check if the current
// platform is Windows XP.   If so, run home network wizard directly.  If not, continue 
// the rest of IExpress installation by installing the specified INF file.
//
// Usage:  WinXPChk hnwcli.inf,DefaultInstall

#include "stdafx.h"
#include <shlwapi.h>

typedef UINT (CALLBACK* LPFNDLLFUNC1)(HWND,HINSTANCE, LPSTR, int);

void ShowErrMsg(LPSTR msg)
{
	LPVOID lpMsgBuf;   

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		 0, 
		 NULL 
		 );
			   
	// Process any inserts in lpMsgBuf.
	
	// Display the string.
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );
	// Free the buffer.
	LocalFree( lpMsgBuf );
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
   DWORD dwVersion;

   dwVersion = GetVersion();
	  
   HINSTANCE hDLL;               // Handle to DLL
   LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
   UINT  uReturnVal = 0;

   
   if (LOBYTE(LOWORD(dwVersion)) == 5 && HIBYTE(LOWORD(dwVersion)) >= 1)
   //if (IsOS(OS_WHISTLERORGREATER))
   {
	   // It is an XP box, run home network wizard directly.    

	   hDLL = LoadLibrary("hnetwiz.dll");
	   if (hDLL != NULL)
	   {
		   lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "HomeNetWizardRunDll");

		   if (!lpfnDllFunc1)
		   {
			   // handle the error
			   ShowErrMsg("HomeNetWizardRunDll");
			   FreeLibrary(hDLL);
			   return -1;
		   }
		   else
		   {
			   // call the function
			   uReturnVal = lpfnDllFunc1(NULL, hInstance, lpCmdLine, nCmdShow);
			   FreeLibrary(hDLL);
			   return uReturnVal;
		   }
	   }
	   else
	   {
		 ShowErrMsg("hnetwiz.dll");
		 return -1;
	   }
   } 
   else
   {
	   // check to see if upnpui.dll is installed.  Use different INF files depending on its
	   // presence in the system.
	   TCHAR szDllPath[MAX_PATH];
	   LPSTR szParam = TEXT("NoUPnP.inf,DefaultInstall");;  

	   if (GetSystemDirectory(szDllPath, MAX_PATH) != 0)
	   {
			
		   PathAppend(szDllPath, TEXT("upnpui.dll"));
		   if (PathFileExists(szDllPath))
		   {
		   
			   szParam = TEXT("HasUPnP.inf,DefaultInstall");
		   }
	   }
	
	   hDLL = LoadLibrary("advpack.dll");
	   if (hDLL != NULL)
	   {
		   lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "LaunchINFSection");

		   if (!lpfnDllFunc1)
		   {
			   // handle the error
			   ShowErrMsg("LaunchINFSection");

			   FreeLibrary(hDLL);
			   return -1;
		   }
		   else
		   {
			   // call the function
			   uReturnVal = lpfnDllFunc1(NULL, hInstance, szParam, nCmdShow);
			   FreeLibrary(hDLL);
			   return uReturnVal;
		   }
	   }
	   else
	   {
		   ShowErrMsg("advpack.dll");
		   return -1;
	   }
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\debug.cpp ===
//
// Debug.cpp
//
//	  Debug functionality shared between different projects (for use in 
//    non-MFC projects).
//
// History:
//
//	 3/??/96	KenSh		Copied from InetSDK sample, added AfxTrace from MFC
//	 4/10/96	KenSh		Renamed AfxTrace to MyTrace (to avoid linking conflicts
//							when linking with MFC).
//	11/15/96	KenSh		Automatically break on assert within assert
//

#include "stdafx.h"

#ifdef _DEBUG

#include "Debug.h"
#include <stdlib.h>

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;


// determine number of elements in an array (not bytes)
#ifndef _countof
#define _countof(array) (sizeof(array)/sizeof((array)[0]))
#endif

//*** Globals
//
static BOOL g_bInAssert = FALSE;


// DisplayAssert
//
//		Given a file and line number, displays an Assertion dialog box with
//		Abort/Retry/Ignore choices.
//
//		Returns TRUE if the program should break into the debugger, else FALSE.
//
extern "C" BOOL DisplayAssert(LPCSTR pszMessage, LPCSTR pszFile, UINT nLine)
{
	char	szMsg[250];

	if (!pszFile)
		pszFile = _T("Unknown file");

	if (!pszMessage)
		pszMessage = _T("");

	// Break on assert within assert
	if (g_bInAssert)
	{
		AfxDebugBreak();
		return FALSE;
	}

	wnsprintf(szMsg, ARRAYSIZE(szMsg), _T("Assertion Failed!  Abort, Break, or Ignore?\n\nFile: %s\nLine: %d\n\n%s"),
				pszFile, nLine, pszMessage);

	HWND hwndActive = GetActiveWindow();

	// Put up a dialog box
	//
	g_bInAssert = TRUE;
	int nResult = MessageBox(hwndActive, szMsg, _T("Assertion failed!"), 
					MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);
	g_bInAssert = FALSE;

	switch(nResult)
	{
		case IDABORT:
			FatalAppExit(0, _T("Bye"));
			return FALSE;

		case IDRETRY:
			return TRUE;	// Need to break into debugger

		default:
			return FALSE;	// continue.
	}
}


void __cdecl MyTrace(const char* lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = wvnsprintf(szBuffer, ARRAYSIZE(szBuffer), lpszFormat, args);
	ASSERT(nBuf < _countof(szBuffer));

	OutputDebugString(szBuffer);

	va_end(args);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\localstr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       L O C A L S T R . H
//
//  Contents:   
//
//  Notes:
//
//  Author:     billi   05 10 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once


#define WIZARDNAME      TEXT("Network Setup Wizard")
#define LOGNAMESTRA     "Network Setup Wizard Log\r\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\fauxmfc.cpp ===
// FauxMFC.cpp
#include "stdafx.h"
#include "FauxMFC.h"
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

const TCHAR afxChNil = '\0';
const /*AFX_STATIC_DATA*/ int _afxInitData[] = { -1, 0, 0, 0 };
const /*AFX_STATIC_DATA*/ CStringData* _afxDataNil = (CStringData*)&_afxInitData;
const LPCTSTR _afxPchNil = (LPCTSTR)(((BYTE*)&_afxInitData)+sizeof(CStringData));

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#define DOUBLE_ARG  _AFX_DOUBLE

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64     0x40000

#define IS_DIGIT(c)  ((UINT)(c) - (UINT)('0') <= 9)


//////////////////////////////////////////////////////////////////////////////
// Global MFC stuff

HINSTANCE AFXAPI AfxGetResourceHandle(void)
{
	return GetModuleHandle(NULL);
}

BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1)
{
	if (lpsz == NULL)
		return FALSE;
	return ::IsBadStringPtrA(lpsz, nLength) == 0;
}


//////////////////////////////////////////////////////////////////////////////
// CString

CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		ASSERT(FALSE);
		//UINT nID = LOWORD((DWORD)lpsz);
		//LoadString(nID);
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

CString::CString(const CString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CString::CString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
//		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

CString::~CString()
//  free any attached data
{
	if (GetData() != _afxDataNil)
	{
        ASSERT( 0 != GetData()->nRefs );
		if (InterlockedDecrement(&GetData()->nRefs) == 0)
        {
			FreeData(GetData());
        }
	}
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

BOOL CString::LoadString(UINT nID)
{
	HINSTANCE hInst = AfxGetResourceHandle();
	int cch;
	if (!FindResourceString(hInst, nID, &cch, 0))
		return FALSE;

	AllocBuffer(cch);
	if (cch != 0)
		::LoadString(hInst, nID, this->m_pchData, cch+1);

	return TRUE;
}

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
//	ASSERT(AfxIsValidString(lpszFormat));

	va_list argListSave = argList;
	int nMaxLen = 0;

	// make a guess at the maximum length of the resulting string
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; ++lpsz)
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(++lpsz) == '%')
		{
			nMaxLen += 2; //_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = CharNext(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = MyAtoi(lpsz); //_ttoi(lpsz);
			for (; *lpsz != '\0' && IS_DIGIT(*lpsz); lpsz = CharNext(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = CharNext(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = CharNext(lpsz);
			}
			else
			{
				nPrecision = MyAtoi(lpsz); //_ttoi(lpsz);
				for (; *lpsz != '\0' && IS_DIGIT(*lpsz); lpsz = CharNext(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
#if 0 // we don't need this code  -ks 7/26/1999
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
#endif
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = CharNext(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = CharNext(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = CharNext(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128; // width isn't truncated
				// 312 == strlen("-1+(309 zeroes).")
				// 309 zeroes == max precision of a double
				nItemLen = max(nItemLen, 312+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
#ifdef UNICODE
	wvnsprintf(m_pchData, ARRAYSIZE(m_pchData), lpszFormat, argListSave);
#else
	wvsprintf(m_pchData, lpszFormat, argListSave);
#endif
	ReleaseBuffer();

	va_end(argListSave);
}

void AFX_CDECL CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	strFormat.LoadString(nFormatID);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(AfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}

CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(AfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
//	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);
	LPTSTR lpsz = strstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CString::Release()
{
	if (GetData() != _afxDataNil)
	{
        ASSERT( 0 != GetData()->nRefs );
		if (InterlockedDecrement(&GetData()->nRefs) == 0)
        {
			FreeData(GetData());
        }
		Init();
	}
}

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if (nSrcLen)
	{
		AllocBeforeWrite(nSrcLen);
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);
    ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

    if (nLen == 0)
        Init();
    else
    {
        CStringData* pData;
        pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
        if (pData)
        {
            pData->nAllocLength = nLen;
            pData->nRefs = 1;
            pData->data()[nLen] = '\0';
            pData->nDataLength = nLen;
            m_pchData = pData->data();
        }
    }
}

void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}


void CString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

void PASCAL CString::Release(CStringData* pData)
{
	if (pData != _afxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) == 0)
        {
			FreeData(pData);
        }
	}
}

void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

void FASTCALL CString::FreeData(CStringData* pData)
{
//#ifndef _DEBUG
#ifdef TEST
	int nLen = pData->nAllocLength;
	if (nLen == 64)
		_afxAlloc64.Free(pData);
	else if (nLen == 128)
		_afxAlloc128.Free(pData);
	else if (nLen == 256)
		_afxAlloc256.Free(pData);
	else  if (nLen == 512)
		_afxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}


//////////////////////////////////////////////////////////////////////////////
// CWinThread

CWinThread::CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam)
{
	m_pfnThreadProc = pfnThreadProc;
	m_pThreadParams = pParam;

	CommonConstruct();
}

CWinThread::CWinThread()
{
	m_pThreadParams = NULL;
	m_pfnThreadProc = NULL;

	CommonConstruct();
}

void CWinThread::CommonConstruct()
{
	// no HTHREAD until it is created
	m_hThread = NULL;
	m_nThreadID = 0;
}

CWinThread::~CWinThread()
{
	// free thread object
	if (m_hThread != NULL)
		CloseHandle(m_hThread);
//TODO:fix
	// cleanup module state
//	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
//	if (pState->m_pCurrentWinThread == this)
//		pState->m_pCurrentWinThread = NULL;
}

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
    int nPriority, UINT nStackSize, DWORD dwCreateFlags,
    LPSECURITY_ATTRIBUTES lpSecurityAttrs)
{
    ASSERT(pfnThreadProc != NULL);

    CWinThread* pThread = new CWinThread(pfnThreadProc, pParam);
    if (pThread)
    {
        if (!pThread->CreateThread(dwCreateFlags|CREATE_SUSPENDED, nStackSize, lpSecurityAttrs))
        {
            pThread->Delete();
            return NULL;
        }
        pThread->SetThreadPriority(nPriority);
        if (!(dwCreateFlags & CREATE_SUSPENDED))
            pThread->ResumeThread();
    }

    return pThread;
}

BOOL CWinThread::SetThreadPriority(int nPriority)
	{ ASSERT(m_hThread != NULL); return ::SetThreadPriority(m_hThread, nPriority); }

BOOL CWinThread::CreateThread(DWORD dwCreateFlags, UINT nStackSize,
	LPSECURITY_ATTRIBUTES lpSecurityAttrs)
{
	ASSERT(m_hThread == NULL);  // already created?

	m_hThread = ::CreateThread(lpSecurityAttrs, nStackSize, m_pfnThreadProc, 
							m_pThreadParams, dwCreateFlags, &m_nThreadID);
 
	if (m_hThread == NULL)
		return FALSE;

	return TRUE;
}

DWORD CWinThread::ResumeThread()
	{ ASSERT(m_hThread != NULL); return ::ResumeThread(m_hThread); }

void CWinThread::Delete()
{
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// CWinThread default implementation

BOOL CWinThread::InitInstance()
{
//	ASSERT_VALID(this);

	return FALSE;   // by default don't enter run loop
}
int CWinThread::ExitInstance()
{
//	ASSERT_VALID(this);
//	ASSERT(AfxGetApp() != this);

//	int nResult = m_msgCur.wParam;  // returns the value from PostQuitMessage
	return 0;
}



//////////////////////////////////////////////////////////////////////////////
// CStringArray

static inline void ConstructElement(CString* pNewData)
{
	memcpy(pNewData, &afxEmptyString, sizeof(CString));
}

static inline void DestructElement(CString* pOldData)
{
	pOldData->~CString();
}

static inline void CopyElement(CString* pSrc, CString* pDest)
{
	*pSrc = *pDest;
}

static void ConstructElements(CString* pNewData, int nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		ConstructElement(pNewData);
		pNewData++;
	}
}

static void DestructElements(CString* pOldData, int nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		DestructElement(pOldData);
		pOldData++;
	}
}

static void CopyElements(CString* pDest, CString* pSrc, int nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		*pDest = *pSrc;
		++pDest;
		++pSrc;
	}
}

/////////////////////////////////////////////////////////////////////////////

CStringArray::CStringArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CStringArray::~CStringArray()
{
//	ASSERT_VALID(this);

	DestructElements(m_pData, m_nSize);
	delete[] (BYTE*)m_pData;
}

void CStringArray::SetSize(int nNewSize, int nGrowBy)
{
//  ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing

        DestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT(nNewSize <= SIZE_T_MAX/sizeof(CString));    // no overflow
#endif
        m_pData = (CString*) new BYTE[nNewSize * sizeof(CString)];
        if (m_pData)
        {
            ConstructElements(m_pData, nNewSize);

            m_nSize = m_nMaxSize = nNewSize;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

        }

        else if (m_nSize > nNewSize)  // destroy the old elements
            DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT(nNewMax <= SIZE_T_MAX/sizeof(CString)); // no overflow
#endif
        CString* pNewData = (CString*) new BYTE[nNewMax * sizeof(CString)];
        if (pNewData)
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CString));

            // construct remaining elements
            ASSERT(nNewSize > m_nSize);

            ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);


            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
    }
}

int CStringArray::Append(const CStringArray& src)
{
//	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);

	return nOldSize;
}

void CStringArray::Copy(const CStringArray& src)
{
//	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);

	CopyElements(m_pData, src.m_pData, src.m_nSize);

}

void CStringArray::FreeExtra()
{
//  ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT(m_nSize <= SIZE_T_MAX/sizeof(CString)); // no overflow
#endif
        CString* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CString*) new BYTE[m_nSize * sizeof(CString)];
            if (pNewData)
            {
                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(CString));
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

void CStringArray::SetAtGrow(int nIndex, LPCTSTR newElement)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}


void CStringArray::SetAtGrow(int nIndex, const CString& newElement)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}

void CStringArray::InsertEmpty(int nIndex, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(CString));

		// re-init slots we copied from
		ConstructElements(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
}

void CStringArray::InsertAt(int nIndex, LPCTSTR newElement, int nCount)
{
	// make room for new elements
	InsertEmpty(nIndex, nCount);

	// copy elements into the empty space
	CString temp = newElement;
	while (nCount--)
		m_pData[nIndex++] = temp;
}

void CStringArray::InsertAt(int nIndex, const CString& newElement, int nCount)
{
	// make room for new elements
	InsertEmpty(nIndex, nCount);

	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

void CStringArray::RemoveAt(int nIndex, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	DestructElements(&m_pData[nIndex], nCount);

	if (nMoveCount)
		memmove(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(CString));
	m_nSize -= nCount;
}

void CStringArray::InsertAt(int nStartIndex, CStringArray* pNewArray)
{
//	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
//	ASSERT_KINDOF(CStringArray, pNewArray);
//	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}


//////////////////////////////////////////////////////////////////////////////
// CPtrArray

/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
//	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy)
{
//  ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
        m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];
        if (m_pData)
        {
            memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill
            m_nSize = m_nMaxSize = nNewSize;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
        void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];
        if (pNewData)
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

            // construct remaining elements
            ASSERT(nNewSize > m_nSize);

            memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
    }
}

int CPtrArray::Append(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);

	memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*));

}

void CPtrArray::FreeExtra()
{
//  ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
            if (pNewData)
            {
                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);

	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	if (nMoveCount)
		memmove(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(void*));
	m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
//	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
//	ASSERT_KINDOF(CPtrArray, pNewArray);
//	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\netconn.h ===
//
// NetConn.h
//
//		Header file for APIs exported by NConn32.dll
//
// History:
//
//		 3/12/1999  KenSh     Created
//		 9/29/1999  KenSh     Changed JetNet stuff to NetConn for HNW
//

#ifndef __NETCONN_H__
#define __NETCONN_H__



// Callback procedure - return TRUE to continue, FALSE to abort
typedef BOOL (CALLBACK FAR* PROGRESS_CALLBACK)(LPVOID pvParam, DWORD dwCurrent, DWORD dwTotal);


// NetConn return values
//
#define FACILITY_NETCONN 0x0177
#define NETCONN_SUCCESS				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NETCONN, 0x0000)
#define NETCONN_NEED_RESTART		MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NETCONN, 0x0001)
#define NETCONN_ALREADY_INSTALLED	MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NETCONN, 0x0002)
#define NETCONN_NIC_INSTALLED		MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NETCONN, 0x0003)
#define NETCONN_NIC_INSTALLED_OTHER	MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NETCONN, 0x0004)
#define NETCONN_UNKNOWN_ERROR		MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0000)
#define NETCONN_USER_ABORT			MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0001)
#define NETCONN_PROTOCOL_NOT_FOUND	MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0002)
#define NETCONN_NOT_IMPLEMENTED		MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0003)
#define NETCONN_WRONG_PLATFORM		MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0004)
#define NETCONN_MISSING_DLL			MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0005)
#define NETCONN_OS_NOT_SUPPORTED	MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0006)
#define NETCONN_INVALID_ARGUMENT	MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NETCONN, 0x0007)

#define SZ_CLASS_ADAPTER	L"Net"
#define SZ_CLASS_CLIENT		L"NetClient"
#define SZ_CLASS_PROTOCOL	L"NetTrans"
#define SZ_CLASS_SERVICE	L"NetService"

#define SZ_PROTOCOL_TCPIP	L"MSTCP"
#define SZ_PROTOCOL_NETBEUI	L"NETBEUI"
#define SZ_PROTOCOL_IPXSPX	L"NWLINK"

#define SZ_SERVICE_VSERVER	L"VSERVER"
#define SZ_CLIENT_MICROSOFT	L"VREDIR"
#define SZ_CLIENT_NETWARE	L"NWREDIR"

#define NIC_UNKNOWN			0x00
#define NIC_VIRTUAL			0x01
#define NIC_ISA				0x02
#define NIC_PCI				0x03
#define NIC_PCMCIA			0x04
#define NIC_USB				0x05
#define NIC_PARALLEL		0x06
#define NIC_MF      		0x07
#define NIC_1394			0x08	// NDIS 1394 Net Adapter

#define NETTYPE_LAN			0x00	// a network card
#define NETTYPE_DIALUP		0x01	// a Dial-Up Networking adapter
#define NETTYPE_IRDA		0x02	// an IrDA connection
#define NETTYPE_PPTP		0x03	// a virtual private networking adapter for PPTP
#define NETTYPE_TV          0x04    // a TV adapter
#define NETTYPE_ISDN        0x05    // ISDN adapter

#define SUBTYPE_NONE		0x00	// nothing special
#define SUBTYPE_ICS			0x01	// ICS adapter (NIC_VIRTUAL, NETTYPE_LAN)
#define SUBTYPE_AOL			0x02	// AOL adapter (NIC_VIRTUAL, NETTYPE_LAN)
#define SUBTYPE_VPN			0x03	// VPN support (NETTYPE_DIALUP)

#define ICS_NONE			0x00	// NIC has no connection to ICS
#define ICS_EXTERNAL		0x01	// NIC is ICS's external adapter
#define ICS_INTERNAL		0x02	// NIC is ICS's internal adapter

#define NICERR_NONE			0x00	// no error
#define NICERR_MISSING		0x01	// device is in registry but not physically present
#define NICERR_DISABLED		0x02	// device exists but has been disabled (red X in devmgr)
#define NICERR_BANGED		0x03	// device has a problem (yellow ! in devmgr)
#define NICERR_CORRUPT		0x04	// NIC has class key but no enum key

#define NICWARN_NONE		0x00	// no warning
#define NICWARN_WARNING		0x01	// yellow ! in devmgr, otherwise everything looks ok


#include <pshpack1.h>

typedef struct tagNETADAPTER {
	WCHAR szDisplayName[260];		// so-called friendly name of adapter
	WCHAR szDeviceID[260];			// e.g. "PCI\VEN_10b7&DEV_9050"
	WCHAR szEnumKey[260];			// e.g. "Enum\PCI\VEN_10b7&DEV_9050&SUBSYS_00000000&REV_00\407000"
	WCHAR szClassKey[40];			// PnP-assigned class name + ID, e.g. "Net\0000"
	WCHAR szManufacturer[60];		// Company that manufactured the card, e.g. "3Com"
	WCHAR szInfFileName[50];			// File title of INF file, e.g. "NETEL90X.INF"
	BYTE  bNicType;					// a NIC_xxx constant, defined above
	BYTE  bNetType;					// a NETTYPE_xxx constant, defined above
	BYTE  bNetSubType;				// a SUBTYPE_xxx constant, defined above
	BYTE  bIcsStatus;				// an ICS_xxx constant, defined above
	BYTE  bError;					// a NICERR_xxx constant, defined above
	BYTE  bWarning;					// a NICWARN_xxx constant, defined above
	DWORD devnode;                  // configmg device node
} NETADAPTER;

typedef struct tagNETSERVICE {
	WCHAR szDisplayName[260];		// (supposedly) friendly name of service
	WCHAR szDeviceID[260];			// e.g. "VSERVER"
	WCHAR szClassKey[40];			// PnP-assigned class name + ID, e.g. "NetService\0000"
} NETSERVICE;

#include <poppack.h>

#ifdef __cplusplus
extern "C" {
#endif

// NCONN32.DLL exported functions
//
//  NOTE: if you change anything here, change NConn32.cpp also!!
//
LPVOID  WINAPI NetConnAlloc(DWORD cbAlloc);
VOID    WINAPI NetConnFree(LPVOID pMem);
BOOL    WINAPI IsProtocolInstalled(LPCWSTR pszProtocolDeviceID, BOOL bExhaustive);
HRESULT WINAPI InstallProtocol(LPCWSTR pszProtocol, HWND hwndParent, PROGRESS_CALLBACK pfnCallback, LPVOID pvCallbackParam);
HRESULT WINAPI InstallTCPIP(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam);
HRESULT WINAPI RemoveProtocol(LPCWSTR pszProtocol);
BOOL    WINAPI IsMSClientInstalled(BOOL bExhaustive);
HRESULT WINAPI InstallMSClient(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam);
HRESULT WINAPI EnableBrowseMaster();
BOOL    WINAPI IsSharingInstalled(BOOL bExhaustive);
BOOL    WINAPI IsFileSharingEnabled();
BOOL    WINAPI IsPrinterSharingEnabled();
HRESULT WINAPI InstallSharing(HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam);
BOOL    WINAPI FindConflictingService(LPCWSTR pszWantService, NETSERVICE* pConflict);
HRESULT WINAPI EnableSharingAppropriately();
int     WINAPI EnumNetAdapters(NETADAPTER FAR** pprgNetAdapters);
HRESULT WINAPI InstallNetAdapter(LPCWSTR pszDeviceID, LPCWSTR pszInfPath, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvCallbackParam);
BOOL    WINAPI IsAccessControlUserLevel();
HRESULT WINAPI DisableUserLevelAccessControl();
HRESULT WINAPI EnableQuickLogon();
BOOL    WINAPI IsProtocolBoundToAdapter(LPCWSTR pszProtocolID, const NETADAPTER* pAdapter);
HRESULT WINAPI EnableNetAdapter(const NETADAPTER* pAdapter);
BOOL    WINAPI IsClientInstalled(LPCWSTR pszClient, BOOL bExhaustive);
HRESULT WINAPI RemoveClient(LPCWSTR pszClient);
HRESULT WINAPI RemoveGhostedAdapters(LPCWSTR pszDeviceID);
HRESULT WINAPI RemoveUnknownAdapters(LPCWSTR pszDeviceID);
BOOL    WINAPI DoesAdapterMatchDeviceID(const NETADAPTER* pAdapter, LPCWSTR pszDeviceID);
BOOL    WINAPI IsAdapterBroadband(const NETADAPTER* pAdapter);
void    WINAPI SaveBroadbandSettings(LPCWSTR pszBroadbandAdapterNumber);
BOOL    WINAPI UpdateBroadbandSettings(LPWSTR pszEnumKeyBuf, int cchEnumKeyBuf);
HRESULT WINAPI DetectHardware(LPCWSTR pszDeviceID);
int     WINAPI EnumMatchingNetBindings(LPCWSTR pszParentBinding, LPCWSTR pszDeviceID, LPWSTR** pprgBindings);
HRESULT WINAPI RestartNetAdapter(DWORD devnode);
HRESULT WINAPI HrFromLastWin32Error();
HRESULT WINAPI HrWideCharToMultiByte( const WCHAR* szwString, char** ppszString );
HRESULT WINAPI HrEnableDhcp( VOID* pContext, DWORD dwFlags );
BOOLEAN WINAPI IsAdapterDisconnected( VOID* pContext );
HRESULT WINAPI IcsUninstall(void);


#ifdef __cplusplus
}
#endif

#endif // !__NETCONN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\fauxmfc.h ===
//
// FauxMFC.h
//

#pragma once

#define _FAUXMFC // so we can distinguish between MFC and Faux MFC


#ifndef _FAUXMFC_NO_SYNCOBJ
#include "SyncObj.h"
#endif

#ifndef PRINTACTION_NETINSTALL
#define PRINTACTION_NETINSTALL     2
#endif

#ifndef _MAX_PATH
#define _MAX_PATH   260 /* max. length of full pathname */
#endif

#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall
#endif

#ifndef AFX_STATIC
	#define AFX_STATIC extern
	#define AFX_STATIC_DATA extern __declspec(selectany)
#endif

#ifndef _AFX
#define _AFX
#endif

#ifndef _AFX_INLINE
#define _AFX_INLINE inline
#endif

extern const LPCTSTR _afxPchNil;
#define afxEmptyString ((CString&)*(CString*)&_afxPchNil)

HINSTANCE AFXAPI AfxGetResourceHandle(void);

struct CStringData
{
	long nRefs;             // reference count
	int nDataLength;        // length of data (including terminator)
	int nAllocLength;       // length of allocation
	// TCHAR data[nAllocLength]

	TCHAR* data()           // TCHAR* to managed data
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors

	// constructs empty CString
	CString();
	// copy constructor
	CString(const CString& stringSrc);
	// from a single character
	CString(TCHAR ch, int nRepeat = 1);
	// from an ANSI string (converts to TCHAR)
	CString(LPCSTR lpsz);
	// from a UNICODE string (converts to TCHAR)
	CString(LPCWSTR lpsz);
	// subset of characters from an ANSI string (converts to TCHAR)
	CString(LPCSTR lpch, int nLength);
	// subset of characters from a UNICODE string (converts to TCHAR)
	CString(LPCWSTR lpch, int nLength);
	// from unsigned characters
	CString(const unsigned char* psz);

// Attributes & Operations

	// get data length
	int GetLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();

	// return single character at zero-based index
	TCHAR GetAt(int nIndex) const;
	// return single character at zero-based index
	TCHAR operator[](int nIndex) const;
	// set a single character at zero-based index
	void SetAt(int nIndex, TCHAR ch);
	// return pointer to const string
	operator LPCTSTR() const;

	// overloaded assignment

	// ref-counted copy from another CString
	const CString& operator=(const CString& stringSrc);
	// set string content to single character
//	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	// copy string content from ANSI string (converts to TCHAR)
	const CString& operator=(LPCSTR lpsz);
	// copy string content from UNICODE string (converts to TCHAR)
	const CString& operator=(LPCWSTR lpsz);
	// copy string content from unsigned chars
	const CString& operator=(const unsigned char* psz);

	// string concatenation

	// concatenate from another CString
	const CString& operator+=(const CString& string);

	// concatenate a single character
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	// concatenate an ANSI character after converting it to TCHAR
	const CString& operator+=(char ch);
#endif
	// concatenate a UNICODE character after converting it to TCHAR
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
	// compare ignoring case
	int CompareNoCase(LPCTSTR lpsz) const;
	// NLS aware comparison, case sensitive
	int Collate(LPCTSTR lpsz) const;
	// NLS aware comparison, case insensitive
	int CollateNoCase(LPCTSTR lpsz) const;

	// simple sub-string extraction

	// return nCount characters starting at zero-based nFirst
	CString Mid(int nFirst, int nCount) const;
	// return all characters starting at zero-based nFirst
	CString Mid(int nFirst) const;
	// return first nCount characters in string
	CString Left(int nCount) const;
	// return nCount characters from end of string
	CString Right(int nCount) const;

	//  characters from beginning that are also in passed string
	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	// characters from beginning that are not also in passed string
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion

	// NLS aware conversion to uppercase
	void MakeUpper();
	// NLS aware conversion to lowercase
	void MakeLower();
	// reverse string right-to-left
	void MakeReverse();

	// trimming whitespace (either side)

	// remove whitespace starting from right edge
	void TrimRight();
	// remove whitespace starting from left side
	void TrimLeft();

	// trimming anything (either side)

	// remove continuous occurrences of chTarget starting from right
	void TrimRight(TCHAR chTarget);
	// remove continuous occcurrences of characters in passed string,
	// starting from right
	void TrimRight(LPCTSTR lpszTargets);
	// remove continuous occurrences of chTarget starting from left
	void TrimLeft(TCHAR chTarget);
	// remove continuous occcurrences of characters in
	// passed string, starting from left
	void TrimLeft(LPCTSTR lpszTargets);

	// advanced manipulation

	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching

	// find character starting at left, -1 if not found
	int Find(TCHAR ch) const;
	// find character starting at right
	int ReverseFind(TCHAR ch) const;
	// find character starting at zero-based index and going right
	int Find(TCHAR ch, int nStart) const;
	// find first instance of any character in passed string
	int FindOneOf(LPCTSTR lpszCharSet) const;
	// find first instance of substring
	int Find(LPCTSTR lpszSub) const;
	// find first instance of substring starting at zero-based index
	int Find(LPCTSTR lpszSub, int nStart) const;

	// simple formatting

	// printf-like formatting using passed string
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
	// printf-like formatting using referenced string resource
	void AFX_CDECL Format(UINT nFormatID, ...);
	// printf-like formatting using variable arguments parameter
	void FormatV(LPCTSTR lpszFormat, va_list argList);

	// formatting for localization (uses FormatMessage API)

	// format using FormatMessage API on passed string
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	// format using FormatMessage API on referenced string resource
	void AFX_CDECL FormatMessage(UINT nFormatID, ...);

	// input and output
//#ifdef _DEBUG
//	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
//				const CString& string);
//#endif
//	friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
//	friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

	// load from string resource
	BOOL LoadString(UINT nID);

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)

	// convert string from ANSI to OEM in-place
	void AnsiToOem();
	// convert string from OEM to ANSI in-place
	void OemToAnsi();
#endif

//#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)

	// return a BSTR initialized with this CString's data
//	BSTR AllocSysString() const;
	// reallocates the passed BSTR, copies content of this CString to it
//	BSTR SetSysString(BSTR* pbstr) const;
//#endif

	// Access to string implementation buffer as "C" character array

	// get pointer to modifiable buffer at least as long as nMinBufLength
	LPTSTR GetBuffer(int nMinBufLength);
	// release buffer, setting length to nNewLength (or to first nul if -1)
	void ReleaseBuffer(int nNewLength = -1);
	// get pointer to modifiable buffer exactly as long as nNewLength
	LPTSTR GetBufferSetLength(int nNewLength);
	// release memory allocated to but unused by string
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off

	// turn refcounting back on
	LPTSTR LockBuffer();
	// turn refcounting off
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
	static void FASTCALL FreeData(CStringData* pData);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

//////////////////////////////////////////////////////////////////////////////
// CString inline functions

_AFX_INLINE CStringData* CString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString()
	{ m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
_AFX_INLINE int CString::GetLength() const
	{ return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
	{ return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
	{ return lstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return lstrcmpi(m_pchData, lpsz); }   // MBCS/Unicode aware
_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE bool AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }


//////////////////////////////////////////////////////////////////////////////
// CWinThread

typedef DWORD (WINAPI *AFX_THREADPROC)(LPVOID);

class CWinThread
{
//	DECLARE_DYNAMIC(CWinThread)

public:
// Constructors
	CWinThread();
	BOOL CreateThread(DWORD dwCreateFlags = 0, UINT nStackSize = 0,
		LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

// Attributes
	// only valid while running
	HANDLE m_hThread;       // this thread's HANDLE
	operator HANDLE() const;
	DWORD m_nThreadID;      // this thread's ID

	int GetThreadPriority();
	BOOL SetThreadPriority(int nPriority);

// Operations
	DWORD SuspendThread();
	DWORD ResumeThread();
	BOOL PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam);

// Overridables
	// thread initialization
	virtual BOOL InitInstance();

	// thread termination
	virtual int ExitInstance(); // default will 'delete this'


// Implementation
public:
	virtual ~CWinThread();
	void CommonConstruct();
	virtual void Delete();

public:
	// constructor used by implementation of AfxBeginThread
	CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam);

	// valid after construction
	LPVOID m_pThreadParams; // generic parameters passed to starting function
	AFX_THREADPROC m_pfnThreadProc;
};

// global helpers for threads

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
//CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
//	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
//	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AFXAPI AfxGetThread();
void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete = TRUE);

void AFXAPI AfxInitThread();
void AFXAPI AfxTermThread(HINSTANCE hInstTerm = NULL);



//////////////////////////////////////////////////////////////////////////////
// CStringArray

class CStringArray // : public CObject
{

//	DECLARE_SERIAL(CStringArray)
public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CString GetAt(int nIndex) const;
	void SetAt(int nIndex, LPCTSTR newElement);

	void SetAt(int nIndex, const CString& newElement);

	CString& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const CString* GetData() const;
	CString* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, LPCTSTR newElement);

	void SetAtGrow(int nIndex, const CString& newElement);

	int Add(LPCTSTR newElement);

	int Add(const CString& newElement);

	int Append(const CStringArray& src);
	void Copy(const CStringArray& src);

	// overloaded operator helpers
	CString operator[](int nIndex) const;
	CString& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, LPCTSTR newElement, int nCount = 1);

	void InsertAt(int nIndex, const CString& newElement, int nCount = 1);

	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

	void InsertEmpty(int nIndex, int nCount);


public:
	~CStringArray();

//	void Serialize(CArchive&);
#ifdef _DEBUG
//	void Dump(CDumpContext&) const;
//	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef CString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};

////////////////////////////////////////////////////////////////////////////

#ifndef _AFXCOLL_INLINE
#define _AFXCOLL_INLINE inline
#endif

_AFXCOLL_INLINE int CStringArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE CString CStringArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CStringArray::SetAt(int nIndex, LPCTSTR newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void CStringArray::SetAt(int nIndex, const CString& newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE CString& CStringArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const CString* CStringArray::GetData() const
	{ return (const CString*)m_pData; }
_AFXCOLL_INLINE CString* CStringArray::GetData()
	{ return (CString*)m_pData; }
_AFXCOLL_INLINE int CStringArray::Add(LPCTSTR newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE int CStringArray::Add(const CString& newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE CString CStringArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CString& CStringArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


/////////////////////////////////////////////////////////////////////////////
// CPtrArray

class CPtrArray // : public CObject
{
//	DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);

	void*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, void* newElement);

	int Add(void* newElement);

	int Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);

	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount


public:
	~CPtrArray();
#ifdef _DEBUG
//	void Dump(CDumpContext&) const;
//	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void* CPtrArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CPtrArray::SetAt(int nIndex, void* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
_AFXCOLL_INLINE void** CPtrArray::GetData()
	{ return (void**)m_pData; }
_AFXCOLL_INLINE int CPtrArray::Add(void* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }



/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\netutil.cpp ===
//
// NetUtil.cpp
//

#include "Util.h"
#include "debug.h"

#include <devguid.h>


#ifdef __cplusplus
extern "C" {
#endif



HRESULT	WINAPI HrFromLastWin32Error()
//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HrFromWin32Error(dwError);
    }

    return hr;
}



HRESULT WINAPI HrWideCharToMultiByte( const WCHAR* szwString, char** ppszString )
//+---------------------------------------------------------------------------
//
// Function:  HrWideCharToMultiByte
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT hr = E_POINTER;
    
    ASSERT( szwString );
    ASSERT( ppszString );
    
    if ( ppszString )
    {
        *ppszString = NULL;
        hr          = E_INVALIDARG;
        
        if ( szwString )
        {
            int iLen = 0;

            iLen = WideCharToMultiByte( CP_ACP, 0, szwString, -1, NULL, NULL, NULL, NULL );
                
            if ( 0 < iLen )
            {
                char* pszName = new char[ iLen ];
                    
                if ( NULL != pszName )
                {
                    if ( WideCharToMultiByte( CP_ACP, 0, szwString, -1, pszName, iLen, NULL, NULL ) )
                    {
                        hr          = S_OK;
                        *ppszString = pszName;
                    }
                    else
                    {
                        hr = HrFromLastWin32Error( );
                        delete [] pszName;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HrFromLastWin32Error( );
            }
        }
    }
    
    return hr;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\netip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T R I P . H
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once


#include <iphlpapi.h>


#define HNW_ED_NONE 	    0x0
#define HNW_ED_RELEASE      0x1
#define HNW_ED_RENEW    	0x2

#define DEFAULT_SCOPE_ADDRESS   0x0100a8c0
#define DEFAULT_SCOPE_MASK      0x00ffffff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\parseinf.h ===
//
// ParseInf.h
//
//		Code that parses network INF files
//

#pragma once

#ifndef _FAUXMFC
#pragma message("error --- The Millennium depgen can't deal with this")
//#include <afxtempl.h>
#endif

#include "SortStr.h"
#include "NetConn.h"


#include <pshpack1.h>
struct INF_LAYOUT_FILE
{
	DWORD dwNameOffset; // byte offset of filename from beginning of string data
	BYTE iDisk;			// disk number within layout
	BYTE iLayout;		// layout file number
};
#include <poppack.h>

struct SOURCE_DISK_INFO
{
	WORD wDiskID;		// loword = disk number, hiword = layout file number
	CString strCabFile;
	CString strDescription;
};

struct DRIVER_FILE_INFO
{
	BYTE nTargetDir;      // LDID_* value for target directory, e.g. LDID_WIN
	CHAR szFileTitle[1];  // file name, followed by target subdirectory
};

#define MAKE_DISK_ID(iDiskNumber, iLayoutFile) MAKEWORD(iDiskNumber, iLayoutFile)


typedef CTypedPtrArray<CPtrArray, SOURCE_DISK_INFO*> CSourceDiskArray;
//typedef CTypedPtrArray<CPtrArray, DRIVER_FILE_INFO*> CDriverFileArray;
class CDriverFileArray : public CTypedPtrArray<CPtrArray, DRIVER_FILE_INFO*>
{
public:
	~CDriverFileArray();
};


//////////////////////////////////////////////////////////////////////////////
// Utility functions

int GetFullInfPath(LPCTSTR pszPartialPath, LPTSTR pszBuf, int cchBuf);
BOOL ModifyInf_NoVersionConflict(LPCTSTR pszInfFile);
BOOL ModifyInf_NoCopyFiles(LPCTSTR pszInfFile);
BOOL ModifyInf_RequireExclude(LPCTSTR pszInfFile, LPCTSTR pszRequire, LPCTSTR pszExclude);
BOOL ModifyInf_NoCopyAndRequireExclude(LPCTSTR pszInfFile, LPCTSTR pszRequire, LPCTSTR pszExclude);
BOOL RestoreInfBackup(LPCTSTR pszInfFile);
BOOL GetDeviceCopyFiles(LPCTSTR pszInfFileName, LPCTSTR pszDeviceID, CDriverFileArray& rgDriverFiles);
int GetStandardTargetPath(int iDirNumber, LPCTSTR pszTargetSubDir, LPTSTR pszBuf);
int GetDriverTargetPath(const DRIVER_FILE_INFO* pFileInfo, LPTSTR pszBuf);

BOOL CheckInfSectionInstallation(LPCTSTR pszInfFile, LPCTSTR pszInfSection);
BOOL InstallInfSection(LPCTSTR pszInfFile, LPCTSTR pszInfSection, BOOL bWait);



//////////////////////////////////////////////////////////////////////////////

class CInfParser
{
public:
	CInfParser();
	~CInfParser();

	BOOL LoadInfFile(LPCTSTR pszInfFile, LPCTSTR pszSeparators = ",;=");
	BOOL Rewind();
	BOOL GotoNextLine();
	BOOL GetToken(CString& strTok);
	BOOL GetLineTokens(CStringArray& sa);
	BOOL GetSectionLineTokens(CStringArray& sa);
	BOOL GotoSection(LPCTSTR pszSection);
	int GetProfileInt(LPCTSTR pszSection, LPCSTR pszKey, int nDefault = 0);
	BOOL GetDestinationDir(LPCTSTR pszSectionName, BYTE* pbDirNumber, LPTSTR pszSubDir, UINT cchSubDir);
	BOOL GetFilesFromInstallSection(LPCTSTR pszSection, CDriverFileArray& rgAllFiles);
	void GetFilesFromCopyFilesSections(const CStringArray& rgCopyFiles, CDriverFileArray& rgAllFiles);
	int GetNextSourceFile(LPTSTR pszBuf, BYTE* pDiskNumber);
	void ReadSourceFilesSection(INF_LAYOUT_FILE* prgFiles, int cFiles);
	void ScanSourceFileList(int* pcFiles, int* pcchAllFileNames);
	void AddLayoutFiles(LPCTSTR pszInfFile, CInfParser& parser);

	CString	m_strFileName;

protected:
	LPTSTR	m_pszFileData;
	DWORD	m_cbFile;
	DWORD	m_iPos;
	CString	m_strSeparators;
	CString m_strExtSeparators;
};


class CInfLayoutFiles
{
public:
	CInfLayoutFiles();
	~CInfLayoutFiles();

	BOOL Add(LPCTSTR pszInfFile, BOOL bLayoutFile = FALSE);
	BOOL Add(CInfParser& parser, BOOL bLayoutFile = FALSE);
	void Sort();

	SOURCE_DISK_INFO* FindDriverFileSourceDisk(LPCTSTR pszDriverFileTitle);

#ifdef _DEBUG
	void Dump();
#endif

protected:
	static int __cdecl CompareInfLayoutFiles(const void* pEl1, const void* pEl2);
	static LPTSTR s_pStringData;

protected:
	INF_LAYOUT_FILE*	m_prgFiles;
	LPTSTR				m_pStringData;
	int					m_cFiles;
	int					m_cbStringData;

	CSortedStringArray	m_rgLayoutFileNames;

	// List of source disks generated from all layout files
	CSourceDiskArray	m_rgSourceDisks;

#ifdef _DEBUG
	BOOL				m_bSorted;
#endif
};


class CInfFileList
{
public:
	CInfFileList();
	~CInfFileList();

	BOOL AddBaseFiles(LPCTSTR pszInfFile);
	BOOL AddDeviceFiles(LPCTSTR pszInfFile, LPCTSTR pszDeviceID);
	int BuildSourceFileList();
	void SetDriverSourceDir(LPCTSTR pszSourceDir);

	BOOL FindWindowsCD(HWND hwndParent);
	BOOL CopySourceFiles(HWND hwndParent, LPCTSTR pszDestDir, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam);

protected:
	BOOL CheckWindowsCD(LPCTSTR pszDirectory);
	BOOL PromptWindowsCD(HWND hwndParent, LPCTSTR pszInitialDir, LPTSTR pszResultDir);

protected:
	// List of all files listed in [SourceDisksFiles] of all INFs and related layouts
	CInfLayoutFiles m_rgLayoutFiles;

	// List of all files that are required for the device to function
	CDriverFileArray m_rgDriverFiles;

	// Files that need to be present for windows installer to complete installation
	CSortedStringArray m_rgCabFiles;	// cab files from Windows CD
	CSortedStringArray m_rgSourceFiles;	// source files needed from driver dir

	// Where we'll look first for system files, before prompting user for Windows CD
	CString m_strDriverSourceDir;

	// Where we look for Windows files
	CString m_strWindowsCD;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\parseinf.cpp ===
//
// ParseInf.cpp
//
//		Code that parses network INF files
//
// History:
//
//		 ?/??/1999  KenSh     Created for JetNet
//		 9/29/1999  KenSh     Repurposed for Home Networking Wizard
//

#include "stdafx.h"
#include "ParseInf.h"
#include "SortStr.h"
#include "Registry.h"


#define SECTION_BUFFER_SIZE		(32 * 1024)

// Non-localized strings
#define SZ_INF_BACKUP_SUFFIX ".inf (HNW backup)"
#define SZ_MODIFIED_INF_HEADER "; Modified by Home Networking Wizard\r\n" \
							   "; Original version backed up to \""
#define SZ_MODIFIED_INF_HEADER2 "\"\r\n"
#define SZ_CHECK_MODIFIED_HEADER "; Modified by Home Networking Wizard"


//////////////////////////////////////////////////////////////////////////////
// Utility functions

int GetInfDirectory(LPTSTR pszBuf, int cchBuf, BOOL bAppendBackslash)
{
    CRegistry regWindows;
    int cch = 0;
    if (regWindows.OpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", KEY_QUERY_VALUE))
    {
        cch = regWindows.QueryStringValue("DevicePath", pszBuf, cchBuf);
    }

    // Fill in a default if the reg key is missing
    // REVIEW: Is this likely enough that we should even bother?
    if (cch == 0)
    {
        ASSERT(cchBuf > 8);
        cch = GetWindowsDirectory(pszBuf, cchBuf - 4);
        if (0!=cch)
        {
            if (pszBuf[cch-1] != '\\')
                pszBuf[cch++] = '\\';
        }
        lstrcpy(pszBuf + cch, "INF");
        cch += 3;
    }

    if (bAppendBackslash)
    {
        if (pszBuf[cch-1] != '\\')
        {
            pszBuf[cch++] = '\\';
            pszBuf[cch] = '\0';
        }
    }

    return cch;
}

int GetFullInfPath(LPCTSTR pszPartialPath, LPTSTR pszBuf, int cchBuf)
{
	if (IsFullPath(pszPartialPath))
	{
		lstrcpyn(pszBuf, pszPartialPath, cchBuf);
	}
	else
	{
		int cch = GetInfDirectory(pszBuf, cchBuf, TRUE);
		lstrcpyn(pszBuf + cch, pszPartialPath, cchBuf - cch);
	}

	return lstrlen(pszBuf);
}

int AddCommaSeparatedValues(const CStringArray& rgTokens, CStringArray& rgValues, BOOL bIgnoreInfSections)
{
	int cAdded = 0;

	for (int iToken = 2; iToken < rgTokens.GetSize(); iToken++)
	{
		CString& strTok = ((CStringArray&)rgTokens).ElementAt(iToken);
		if (strTok.Compare(",") == 0)
			continue;
		if (strTok.Compare(";") == 0)
			break;

		// Hack: ignore sections whose name ends in ".inf"
		if (bIgnoreInfSections)
		{
			if (0 == lstrcmpi(FindExtension(strTok), "inf"))
				continue;
		}

		rgValues.Add(strTok);
		cAdded++;
	}

	return cAdded;
}

// Builds a list of all files that need to be copied for the device
BOOL GetDeviceCopyFiles(CInfParser& parser, LPCTSTR pszDeviceID, CDriverFileArray& rgDriverFiles)
{
	if (!parser.GotoSection("Manufacturer"))
		return FALSE;

	CStringArray rgMfr;
	CStringArray rgLineTokens;
	while (parser.GetSectionLineTokens(rgLineTokens))
	{
		if (rgLineTokens.GetSize() >= 3 && rgLineTokens.ElementAt(1).Compare("=") == 0)
			rgMfr.Add(rgLineTokens.ElementAt(2));
	}

	CString strNdiSection;

	// Look in each manufacturer section (e.g. "[3COM]") for the given DeviceID
	for (int iMfr = 0; iMfr < rgMfr.GetSize(); iMfr++)
	{
		if (!parser.GotoSection(rgMfr[iMfr]))
			continue;

		while (parser.GetSectionLineTokens(rgLineTokens))
		{
			if (rgLineTokens.GetSize() >= 5 && 
				rgLineTokens.ElementAt(1).Compare("=") == 0 &&
				rgLineTokens.ElementAt(3).Compare(",") == 0)
			{
				if (rgLineTokens.ElementAt(4).CompareNoCase(pszDeviceID) == 0)
				{
					strNdiSection = rgLineTokens.ElementAt(2);
					break;
				}
			}
		}

		if (!strNdiSection.IsEmpty())
			break;
	}

	if (strNdiSection.IsEmpty())
		return FALSE;

	CStringArray rgCopySections;
	CStringArray rgAddRegSections;

	// Look in [DeviceID.ndi] section for AddReg= and CopyFiles=
	if (!parser.GotoSection(strNdiSection))
		return FALSE;
	while (parser.GetSectionLineTokens(rgLineTokens))
	{
		if (rgLineTokens.GetSize() >= 3 &&
			rgLineTokens.ElementAt(1).Compare("=") == 0)
		{
			CString& strKey = rgLineTokens.ElementAt(0);
			CString& strValue = rgLineTokens.ElementAt(2);
			if (strKey.CompareNoCase("AddReg") == 0)
			{
				AddCommaSeparatedValues(rgLineTokens, rgAddRegSections, FALSE);
			}
			else if (strKey.CompareNoCase("CopyFiles") == 0)
			{
				AddCommaSeparatedValues(rgLineTokens, rgCopySections, FALSE);
			}
		}
	}

	// Look through AddReg sections for HKR,Ndi\Install,,,"DeviceID.Install"
	for (int iAddReg = 0; iAddReg < rgAddRegSections.GetSize(); iAddReg++)
	{
		if (!parser.GotoSection(rgAddRegSections[iAddReg]))
			continue;

		while (parser.GetSectionLineTokens(rgLineTokens))
		{
			if (rgLineTokens.GetSize() >= 7 &&
				rgLineTokens.ElementAt(0).CompareNoCase("HKR") == 0 &&
				rgLineTokens.ElementAt(1).Compare(",") == 0 &&
				rgLineTokens.ElementAt(2).CompareNoCase("Ndi\\Install") == 0 &&
				rgLineTokens.ElementAt(3).Compare(",") == 0)
			{
				// Pull out the 5th comma-separated string, and pull the quotes off
				int iSection = 2;
				for (int iToken = 4; iToken < rgLineTokens.GetSize(); iToken++)
				{
					CString& strTok = rgLineTokens.ElementAt(iToken);
					if (strTok.Compare(";") == 0)
						break;

					if (strTok.Compare(",") == 0)
					{
						iSection++;
						continue;
					}

					if (iSection == 4)
					{
						CString strSection = strTok;
						if (strSection[0] == '\"')
							strSection = strSection.Mid(1, strSection.GetLength() - 2);
						rgCopySections.Add(strSection);
						break;
					}
				}
			}
		}
	}

	// Look in [DeviceID.Install], etc., sections for CopyFiles= lines
	for (int iCopyFiles = 0; iCopyFiles < rgCopySections.GetSize(); iCopyFiles++)
	{
		parser.GetFilesFromInstallSection(rgCopySections[iCopyFiles], rgDriverFiles);
	}

	parser.GetFilesFromCopyFilesSections(rgCopySections, rgDriverFiles);

	return TRUE;
}

BOOL GetDeviceCopyFiles(LPCTSTR pszInfFileName, LPCTSTR pszDeviceID, CDriverFileArray& rgDriverFiles)
{
	CInfParser parser;
	if (!parser.LoadInfFile(pszInfFileName))
		return FALSE;
	return GetDeviceCopyFiles(parser, pszDeviceID, rgDriverFiles);
}

CDriverFileArray::~CDriverFileArray()
{
	for (int i = 0; i < GetSize(); i++)
	{
		free((DRIVER_FILE_INFO*)GetAt(i));
	}
}


//////////////////////////////////////////////////////////////////////////////
// CInfParser

CInfParser::CInfParser()
{
	m_pszFileData = NULL;
}

CInfParser::~CInfParser()
{
	free(m_pszFileData);
}

BOOL CInfParser::LoadInfFile(LPCTSTR pszInfFile, LPCTSTR pszSeparators)
{
	TCHAR szInfFile[MAX_PATH];
	GetFullInfPath(pszInfFile, szInfFile, _countof(szInfFile));

	free(m_pszFileData);
	m_pszFileData = (LPSTR)LoadFile(szInfFile, &m_cbFile);
	m_iPos = 0;

	m_strSeparators = pszSeparators;
	m_strExtSeparators = pszSeparators;
	m_strExtSeparators += " \t\r\n";

	m_strFileName = pszInfFile;

	return (BOOL)m_pszFileData;
}

BOOL CInfParser::Rewind()
{
	ASSERT(m_pszFileData != NULL);
	m_iPos = 0;
	return (BOOL)m_pszFileData;
}

BOOL CInfParser::GotoNextLine()
{
	ASSERT(m_pszFileData != NULL);

	for (LPTSTR pch = m_pszFileData + m_iPos; *pch != '\0' && *pch != '\r' && *pch != '\n'; pch++)
		NULL;

	if (*pch == '\r')
		pch++;
	if (*pch == '\n')
		pch++;

	DWORD iPos = (DWORD)(pch - m_pszFileData);
	if (iPos == m_iPos)
		return FALSE; // we were already at EOF

	m_iPos = iPos;
	return TRUE;
}

BOOL CInfParser::GetToken(CString& strTok)
{
	strTok.Empty();

	if (m_pszFileData == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	LPTSTR pch = m_pszFileData + m_iPos;
	TCHAR ch;
	BOOL bQuoted = FALSE;

	// Skip whitespace
	while ((ch = *pch) == ' ' || ch == '\t')
		pch++;

	if (ch == '\0')
		goto done;

	// Check for linebreak
	if (ch == '\r' || ch == '\n')
	{
		strTok = ch;
		pch++;
		if (ch == '\r' && *pch == '\n')
		{
			strTok += '\n';
			pch++;
		}
		goto done;
	}

	// Check for separator
	if (NULL != strchr(m_strSeparators, ch))
	{
		strTok = ch;
		pch++;
		goto done;
	}

	LPTSTR pszStart;
	for (pszStart = pch; (ch = *pch) != '\0'; pch++)
	{
		if (!bQuoted && NULL != strchr(m_strExtSeparators, ch))
		{
			break;
		}
		else if (ch == '\"')
		{
			bQuoted = !bQuoted;
		}
	}

	if (pch != pszStart)
	{
		DWORD cch = (DWORD)(pch - pszStart);
		LPTSTR pszToken = strTok.GetBufferSetLength(cch);
		lstrcpyn(pszToken, pszStart, cch+1);
	}

done:
	m_iPos = (DWORD)(pch - m_pszFileData);
	return (BOOL)strTok.GetLength();
}

BOOL CInfParser::GetLineTokens(CStringArray& sa)
{
	CString strToken;
	BOOL bResult = FALSE;

	sa.RemoveAll();
	while (GetToken(strToken))
	{
		bResult = TRUE; // not at EOF
		if (strToken[0] == '\r' || strToken[0] == '\n')
			break;
		sa.Add(strToken);
	}

	return bResult;
}

BOOL CInfParser::GetSectionLineTokens(CStringArray& sa)
{
begin:
	if (!GetLineTokens(sa))
		return FALSE;

	if (sa.GetSize() == 0)
		goto begin;

	CString& strFirst = sa.ElementAt(0);

	if (strFirst[0] == '[')			// end of section
		return FALSE;

	if (strFirst.Compare(";") == 0)	// comment
	{
		sa.RemoveAll();
		goto begin;
	}

	return TRUE;
}

BOOL CInfParser::GotoSection(LPCTSTR pszSection)
{
	CString strSection;
	CString strToken;

	if (!Rewind())
		return FALSE;

	TCHAR ch;
	BOOL bStartOfLine = TRUE;
	int cchSection = lstrlen(pszSection) + 1;
	for (LPTSTR pch = m_pszFileData; (ch = *pch) != '\0'; pch++)
	{
		if (ch == '\r' || ch == '\n')
		{
			bStartOfLine = TRUE;
		}
		else if (bStartOfLine)
		{
			if (ch == '[')
			{
				LPTSTR pchCloseBracket = strchr(pch+1, ']');
				if ((int)(pchCloseBracket - pch) == cchSection)
				{
					CString str(pch+1, cchSection-1);
					if (str.CompareNoCase(pszSection) == 0)
					{
						pch = pchCloseBracket+1;
						if (*pch == '\r')
							pch++;
						if (*pch == '\n')
							pch++;
						m_iPos = (DWORD)(pch - m_pszFileData);
						return TRUE;
					}
				}
			}

			bStartOfLine = FALSE;
		}
	}

	return FALSE;
}

int CInfParser::GetProfileInt(LPCTSTR pszSection, LPCTSTR pszKey, int nDefault)
{
	DWORD iPos = m_iPos;

	if (GotoSection(pszSection))
	{
		CStringArray rgTokens;
		while (GetSectionLineTokens(rgTokens))
		{
			if (rgTokens.GetSize() >= 3 &&
				rgTokens.ElementAt(0).CompareNoCase(pszKey) == 0&&
				rgTokens.ElementAt(1).Compare("=") == 0)
			{
				nDefault = MyAtoi(rgTokens.ElementAt(2));
				break;
			}
		}
	}

	m_iPos = iPos;
	return nDefault;
}

BOOL CInfParser::GetFilesFromInstallSection(LPCTSTR pszSection, CDriverFileArray& rgAllFiles)
{
	CStringArray rgLineTokens;
	CStringArray rgCopyFilesSections;

	if (!GotoSection(pszSection))
		return FALSE;

	while (GetSectionLineTokens(rgLineTokens))
	{
		if (rgLineTokens.GetSize() >= 3 &&
			rgLineTokens.ElementAt(0).CompareNoCase("CopyFiles") == 0 &&
			rgLineTokens.ElementAt(1).Compare("=") == 0)
		{

			AddCommaSeparatedValues(rgLineTokens, rgCopyFilesSections, FALSE);

			// REVIEW: There can be AddReg= lines here.  Do we need to 
			// check the referenced sections for more CopyFiles= lines?
		}
	}

	GetFilesFromCopyFilesSections(rgCopyFilesSections, rgAllFiles);
	return TRUE;
}

// Looks in [DestinationDirs] for pszSectionName, fills pbDirNumber and pszSubDir with
// the matching target directory and (optional) subdirectory.
BOOL CInfParser::GetDestinationDir(LPCTSTR pszSectionName, BYTE* pbDirNumber, LPTSTR pszSubDir, UINT cchSubDir)
{
	DWORD iSavedPos = m_iPos;
	BOOL bSuccess = FALSE;

	*pbDirNumber = 0;
	pszSubDir[0] = '\0';

	if (GotoSection("DestinationDirs"))
	{
		CStringArray rgTokens;
		while (GetSectionLineTokens(rgTokens))
		{
			if (rgTokens.GetSize() >= 3 &&
				rgTokens.ElementAt(0).CompareNoCase(pszSectionName) == 0 &&
				rgTokens.ElementAt(1).Compare("=") == 0)
			{
				*pbDirNumber = (BYTE)MyAtoi(rgTokens.ElementAt(2));

				if (rgTokens.GetSize() >= 5 && rgTokens.ElementAt(3).Compare(",") == 0)
				{
					lstrcpyn(pszSubDir, rgTokens.ElementAt(4), cchSubDir);
				}

				bSuccess = TRUE;
				break;
			}
		}
	}

	m_iPos = iSavedPos;
	return bSuccess;
}

void CInfParser::GetFilesFromCopyFilesSections(const CStringArray& rgCopyFiles, CDriverFileArray& rgAllFiles)
{
	CStringArray rgLineTokens;

	for (int iSection = 0; iSection < rgCopyFiles.GetSize(); iSection++)
	{
		TCHAR szTargetSubDir[MAX_PATH];
		BYTE nTargetDir;
		GetDestinationDir(rgCopyFiles[iSection], &nTargetDir, szTargetSubDir, _countof(szTargetSubDir));

//		BYTE nTargetDir = (BYTE)GetProfileInt("DestinationDirs", rgCopyFiles[iSection], 0);

#ifdef _DEBUG
		if (nTargetDir == 0)
			TRACE("Warning: CopyFiles section [%s] has no destination directory.\r\n", rgCopyFiles[iSection]);
#endif

		if (!GotoSection(rgCopyFiles[iSection]))
			continue;

		// Get the first item from each line
		while (GetSectionLineTokens(rgLineTokens))
		{
			if (rgLineTokens.GetSize() == 1 ||
				(rgLineTokens.GetSize() >= 2 &&
				 (rgLineTokens.ElementAt(1).Compare(",") == 0 ||
				  rgLineTokens.ElementAt(1).Compare(";") == 0)))
			{
				CString& strFileName = rgLineTokens.ElementAt(0);

				// Don't install this INF file
				// REVIEW: might want to allow this based on a flag or something
				if (0 != lstrcmpi(FindFileTitle(strFileName), FindFileTitle(m_strFileName)))
				{
					UINT cbFileInfo = sizeof(DRIVER_FILE_INFO) + strFileName.GetLength() + lstrlen(szTargetSubDir) + 1;
					DRIVER_FILE_INFO* pFileInfo = (DRIVER_FILE_INFO*)malloc(cbFileInfo);
					TRACE("Error: Malloc failed on DRIVER_FILE_INFO.\r\n");
					if (pFileInfo)
					{
						pFileInfo->nTargetDir = nTargetDir;
						lstrcpy(pFileInfo->szFileTitle, strFileName);
						lstrcpy(pFileInfo->szFileTitle + strFileName.GetLength() + 1, szTargetSubDir);
						rgAllFiles.Add(pFileInfo);
					}
				}
			}
		}
	}

	// TODO: Remove duplicate files (maybe here, maybe not)
}

int CInfParser::GetNextSourceFile(LPTSTR pszBuf, BYTE* pDiskNumber)
{
	LPTSTR pch = m_pszFileData + m_iPos;
	int cch = 0;
	BYTE bDiskNumber = 0;

	for (;;)
	{
		TCHAR ch;

		while ((ch = *pch) == '\r' || ch == '\n')
			pch++;

		if (ch == '\0' || ch == '[' || cch != 0)
			break;

		if (ch != ';')
		{
			LPTSTR pchStart = pch;
			while ((UCHAR)(ch = *pch) > 32 && ch != '=')
				pch++;
			cch = (int)(pch - pchStart);
			lstrcpyn(pszBuf, pchStart, cch+1);

			// skip whitespace while avoiding '\0'
			while ((UCHAR)(*pch-1) < 32)
				pch++;

			if (*pch == '=')
			{
				pch++;

				// skip whitespace while avoiding '\0'
				while ((UCHAR)(*pch-1) < 32)
					pch++;

				bDiskNumber = (BYTE)MyAtoi(pch);

#if 1 // ignore files with disk number of 0
				if (bDiskNumber == 0)
					cch = 0;
#endif
			}
		}

		// skip text up to newline
		while ((ch = *pch) != '\0' && ch != '\r' && ch != '\n')
			pch++;
	}

	*pDiskNumber = bDiskNumber;

	m_iPos = (DWORD)(pch - m_pszFileData);
	return cch;
}

/*
int CInfParser::ReadSourceFilesSection(INF_LAYOUT_FILE* prgFiles, int cFiles)
{
	WORD wOffset = (WORD)(cFiles * sizeof(INF_LAYOUT_FILE));
	LPTSTR pchDest = (LPTSTR)((LPBYTE)m_prgFiles + wOffset);
	INF_LAYOUT_FILE* pFile = prgFiles;
	INF_LAYOUT_FILE* pFileEnd = pFile + cFiles;

	while (pFile < pFileEnd)
	{
		pFile->wNameOffset = (WORD)((LPBYTE)pchDest - (LPBYTE)prgFiles);

		int cch = parser.GetNextSourceFile(pchDest, &pFile->iDisk);
		wOffset += cch+1;
		pchDest += cch+1;
		pFile++;
	}

	LPTSTR pch = m_pszFileData + m_iPos;
	int cch = 0;
	*pDiskNumber = 0;

	for (;;)
	{
		TCHAR ch;

		while ((ch = *pch) == '\r' || ch == '\n')
			pch++;

		if (ch == '\0' || ch == '[' || cch != 0)
			break;

		if (ch != ';')
		{
			LPTSTR pchStart = pch;
			while ((UCHAR)(ch = *pch) > 32 && ch != '=')
				pch++;
			cch = (int)(pch - pchStart);
			lstrcpyn(pszBuf, pchStart, cch+1);

			// skip whitespace while avoiding '\0'
			while ((UCHAR)(*pch-1) < 32)
				pch++;

			if (*pch == '=')
			{
				pch++;

				// skip whitespace while avoiding '\0'
				while ((UCHAR)(*pch-1) < 32)
					pch++;

				*pDiskNumber = (BYTE)atoi(pch);
			}
		}

		// skip text up to newline
		while ((ch = *pch) != '\0' && ch != '\r' && ch != '\n')
			pch++;
	}

	m_iPos = (DWORD)(pch - m_pszFileData);
	return cch;
}
*/

void CInfParser::ScanSourceFileList(int* pcFiles, int* pcchAllFileNames)
{
	int cFiles = 0;
	int cchAllFileNames = 0;

	LPTSTR pch = m_pszFileData + m_iPos;
	for (;;)
	{
		TCHAR ch;

		while ((ch = *pch) == '\r' || ch == '\n')
			pch++;

		if (ch == '\0' || ch == '[')
			break;

		if (ch != ';')
		{
			cFiles += 1;
			LPTSTR pchStart = pch;
			while ((UCHAR)(ch = *pch) >= 32 && ch != '=')
				pch++;
			cchAllFileNames += (int)(pch - pchStart);
		}

		// skip text up to newline
		while ((ch = *pch) != '\0' && ch != '\r' && ch != '\n')
			pch++;
	}

	*pcFiles = cFiles;
	*pcchAllFileNames = cchAllFileNames;
}

//////////////////////////////////////////////////////////////////////////////
// CInfLayoutFiles

#define INF_LAYOUT_FILE_PADDING 40 // extra bytes at end of string data

CInfLayoutFiles::CInfLayoutFiles()
{
	m_prgFiles = NULL;
	m_pStringData = NULL;
	m_cFiles = 0;
	m_cbStringData = 0;

#ifdef _DEBUG
	m_bSorted = FALSE;
#endif
}

CInfLayoutFiles::~CInfLayoutFiles()
{
	free(m_prgFiles);
	free(m_pStringData);

	for (int i = m_rgSourceDisks.GetSize()-1; i >= 0; i--)
	{
		delete m_rgSourceDisks[i];
	}
}

LPTSTR CInfLayoutFiles::s_pStringData;

int __cdecl CInfLayoutFiles::CompareInfLayoutFiles(const void* pEl1, const void* pEl2)
{
	LPCTSTR psz1 = s_pStringData + ((INF_LAYOUT_FILE*)pEl1)->dwNameOffset;
	LPCTSTR psz2 = s_pStringData + ((INF_LAYOUT_FILE*)pEl2)->dwNameOffset;
	return lstrcmpi(psz1, psz2);
}

BOOL CInfLayoutFiles::Add(CInfParser& parser, BOOL bLayoutFile)
{
	// Check if we've already added this layout file
	if (-1 != m_rgLayoutFileNames.Find(parser.m_strFileName))
		return TRUE;

	BYTE iLayoutFile = (BYTE)m_rgLayoutFileNames.GetSize();

	if (parser.GotoSection("SourceDisksFiles"))
	{
		DWORD dwTicks1 = GetTickCount();

		int cFiles;
		int cchAllFileNames;
		parser.ScanSourceFileList(&cFiles, &cchAllFileNames);

		DWORD dwTicks2 = GetTickCount();

		DWORD dwOffset = (DWORD)m_cbStringData;
		int iFile = m_cFiles;

		cchAllFileNames += m_cbStringData + cFiles;
		cFiles += m_cFiles;
		INF_LAYOUT_FILE* pFile = (INF_LAYOUT_FILE*)realloc(m_prgFiles, cFiles * sizeof(INF_LAYOUT_FILE));
		LPTSTR pchDest = (LPTSTR)realloc(m_pStringData, cchAllFileNames + INF_LAYOUT_FILE_PADDING);

		if (pchDest)
		{
			m_pStringData = pchDest;
		}
		if (pFile)
		{
			m_prgFiles = pFile;
		}

		if (pchDest && pFile)
		{
			m_cFiles = cFiles;
			m_cbStringData = cchAllFileNames;
			pchDest += dwOffset;
			pFile += iFile;

			for ( ; iFile < m_cFiles; iFile++)
			{
				pFile->dwNameOffset = dwOffset;
				pFile->iLayout = iLayoutFile;
				int cch = parser.GetNextSourceFile(pchDest, &pFile->iDisk);
				dwOffset += cch+1;
				pchDest += cch+1;
				pFile++;
			}
		}
		else
		{
			return FALSE;
		}

		DWORD dwTicks3 = GetTickCount();

		CString str;
		str.Format("LoadLayout(%s) timings: %d ms, %d ms.  Total time: %d ms", 
			parser.m_strFileName, dwTicks2-dwTicks1, dwTicks3-dwTicks2, dwTicks3-dwTicks1);
		TRACE("%s\r\n", str);
	//	AfxMessageBox(str);

	//	for (int i = 0; i < cFiles; i++)
	//	{
	//		INF_LAYOUT_FILE* pFile = &m_prgFiles[i];
	//		TRACE("File %d: %s=%d\r\n", i, m_pStringData + pFile->dwNameOffset), pFile->iDisk);
	//	}

		#ifdef _DEBUG
			m_bSorted = FALSE;
		#endif
	}

	if (parser.GotoSection("SourceDisksNames"))
	{
		CStringArray rgTokens;
		while (parser.GetSectionLineTokens(rgTokens))
		{
			if (rgTokens.GetSize() >= 3)
			{
				BYTE iDiskNumber = (BYTE)MyAtoi(rgTokens.ElementAt(0));
				if (iDiskNumber != 0)
				{
					SOURCE_DISK_INFO* pDiskInfo = new SOURCE_DISK_INFO;
					pDiskInfo->wDiskID = MAKE_DISK_ID(iDiskNumber, iLayoutFile);

					// Get disk description, pull off quotes
					CString& strDesc = rgTokens.ElementAt(2);
					if (strDesc[0] == '\"')
						pDiskInfo->strDescription = strDesc.Mid(1, strDesc.GetLength()-2);
					else
						pDiskInfo->strDescription = strDesc;

					// If this is Layout*.inf, Get CAB filename, pull off quotes
					if (bLayoutFile && rgTokens.GetSize() >= 5)
					{
						CString& strCab = rgTokens.ElementAt(4);
						if (strCab[0] == '\"')
							pDiskInfo->strCabFile = strCab.Mid(1, strCab.GetLength()-2);
						else
							pDiskInfo->strCabFile = strCab;
					}

					m_rgSourceDisks.Add(pDiskInfo);
				}
			}
		}
	}

	//
	// Now add any referenced layout files
	//

	if (parser.GotoSection("version"))
	{
		CStringArray rgLayoutFiles;
		CStringArray rgLineTokens;

		while (parser.GetSectionLineTokens(rgLineTokens))
		{
			if (rgLineTokens.GetSize() >= 3 &&
				rgLineTokens.ElementAt(0).CompareNoCase("LayoutFile") == 0 &&
				rgLineTokens.ElementAt(1).Compare("=") == 0)
			{
				AddCommaSeparatedValues(rgLineTokens, rgLayoutFiles, FALSE);
				break;
			}
		}

		for (int i = 0; i < rgLayoutFiles.GetSize(); i++)
		{
			Add(rgLayoutFiles.ElementAt(i), TRUE);
		}
	}

	m_rgLayoutFileNames.Add(parser.m_strFileName, 0);
	return TRUE;
}

BOOL CInfLayoutFiles::Add(LPCTSTR pszInfFile, BOOL bLayoutFile)
{
	CInfParser parser;
	if (!parser.LoadInfFile(pszInfFile))
		return FALSE;
	return Add(parser, bLayoutFile);
}

void CInfLayoutFiles::Sort()
{
	s_pStringData = m_pStringData;
	qsort(m_prgFiles, m_cFiles, sizeof(INF_LAYOUT_FILE), CompareInfLayoutFiles);

#ifdef _DEBUG
	m_bSorted = TRUE;
#endif
}

SOURCE_DISK_INFO* CInfLayoutFiles::FindDriverFileSourceDisk(LPCTSTR pszDriverFileTitle)
{
	ASSERT(m_bSorted);

	// Build a dummy layout-file key to allow the standard binary search to work
	// (Note that we've left INF_LAYOUT_FILE_PADDING chars at the end of the string data)
	ASSERT(lstrlen(pszDriverFileTitle) + 1 < INF_LAYOUT_FILE_PADDING);
	INF_LAYOUT_FILE key;
	key.dwNameOffset = m_cbStringData;
	lstrcpy(m_pStringData + m_cbStringData, pszDriverFileTitle);

	s_pStringData = m_pStringData;
	INF_LAYOUT_FILE* pResult = (INF_LAYOUT_FILE*)bsearch(
			&key, m_prgFiles, m_cFiles, sizeof(INF_LAYOUT_FILE), CompareInfLayoutFiles);

	if (pResult == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	// REVIEW: Is it worth making this a binary search?
	WORD wDiskID = MAKE_DISK_ID(pResult->iDisk, pResult->iLayout);
	for (int iDisk = 0; iDisk < m_rgSourceDisks.GetSize(); iDisk++)
	{
		SOURCE_DISK_INFO* pDiskInfo = m_rgSourceDisks[iDisk];
		if (pDiskInfo->wDiskID == wDiskID)
			return pDiskInfo;
	}

	ASSERT(FALSE);
	return NULL;
}

#ifdef _DEBUG
void CInfLayoutFiles::Dump()
{
	TRACE("CInfLayoutFiles (0x%08x)\r\n", (int)this);
	for (int i = 0; i < m_cFiles; i++)
	{
		INF_LAYOUT_FILE* pFile = &m_prgFiles[i];
		TRACE("  File %d: %s, layout %d, disk %d\r\n", i, m_pStringData + pFile->dwNameOffset, (int)pFile->iLayout, (int)pFile->iDisk);
	}
}
#endif // _DEBUG


//////////////////////////////////////////////////////////////////////////////
// CInfFileList

CInfFileList::CInfFileList()
{
}

CInfFileList::~CInfFileList()
{
	for (int i = m_rgDriverFiles.GetSize()-1; i >= 0; i--)
	{
		free(m_rgDriverFiles[i]);
	}

	for (i = m_rgCabFiles.GetSize() - 1; i >= 0; i--)
	{
		free((LPTSTR)m_rgCabFiles.GetItemData(i));
	}
}

void CInfFileList::SetDriverSourceDir(LPCTSTR pszSourceDir)
{
	m_strDriverSourceDir = pszSourceDir;
}

BOOL CInfFileList::AddBaseFiles(LPCTSTR pszInfFile)
{
	CInfParser parser;
	if (!parser.LoadInfFile(pszInfFile))
		return FALSE;

	if (!parser.GotoSection("BaseWinOptions"))
		return FALSE;

	CStringArray rgSections;
	CStringArray rgLineTokens;
	while (parser.GetSectionLineTokens(rgLineTokens))
	{
		if (rgLineTokens.GetSize() >= 1)
			rgSections.Add(rgLineTokens.ElementAt(0));
	}

	int cSections = rgSections.GetSize();
	if (cSections == 0)
		return FALSE;

	// Walk through each major section, grabbing section names from CopyFiles= lines
	CStringArray rgCopyFiles;
	for (int iSection = 0; iSection < cSections; iSection++)
	{
		if (!parser.GotoSection(rgSections[iSection]))
			continue;

		// Look for "CopyFiles="
		while (parser.GetSectionLineTokens(rgLineTokens))
		{
			if (rgLineTokens.GetSize() >= 3 && 
				rgLineTokens.ElementAt(0).CompareNoCase("CopyFiles") == 0 &&
				rgLineTokens.ElementAt(1).Compare("=") == 0)
			{
				AddCommaSeparatedValues(rgLineTokens, rgCopyFiles, TRUE);
			}
		}
	}

	// Walk through each CopyFiles section, grabbing the names of files to copy
	parser.GetFilesFromCopyFilesSections(rgCopyFiles, m_rgDriverFiles);

	m_rgLayoutFiles.Add(parser);

//	for (int i = 0; i < rgAllFiles.GetSize(); i++)
//	{
//		TRACE("File %d: %s\r\n", i, rgAllFiles[i]);
//	}

	return TRUE;
}

BOOL CInfFileList::AddDeviceFiles(LPCTSTR pszInfFile, LPCTSTR pszDeviceID)
{
	CInfParser parser;
	if (!parser.LoadInfFile(pszInfFile))
		return FALSE;

	if (!GetDeviceCopyFiles(parser, pszDeviceID, m_rgDriverFiles))
		return FALSE;

	// Build a list of all layout files, including current file
	m_rgLayoutFiles.Add(parser);

	return TRUE;
}

// Retrieves one of the standard setupx destination directories.
// Always appends a backslash to the name.
// Returns number of characters copied.
//
//    See setupx.h for a list of valid LDID_ values.
//
int GetStandardTargetPath(int iDirNumber, LPCTSTR pszTargetSubDir, LPTSTR pszBuf)
{
	int cch = GetWindowsDirectory(pszBuf, MAX_PATH);
	if (pszBuf[cch-1] != '\\')
		pszBuf[cch++] = '\\';

	switch (iDirNumber)
	{
	case 10: // LDID_WIN
		break;

	case 11: // LDID_SYS
		cch = GetSystemDirectory(pszBuf, MAX_PATH);
		if (pszBuf[cch-1] != '\\')
			pszBuf[cch++] = '\\';
		break;

	case 17: // LDID_INF
		lstrcpy(pszBuf + cch, "INF\\");
		cch += 4;
		break;

	case 18: // LDID_HELP
		lstrcpy(pszBuf + cch, "HELP\\");
		cch += 5;
		break;

	case 25: // LDID_SHARED (windows dir)
		break;

	case 26: // LDID_WINBOOT (windows dir)
		break;

	default:
		ASSERT(FALSE);
		cch = 0;
		break;
	}

	if (pszTargetSubDir != NULL && *pszTargetSubDir != '\0')
	{
		lstrcpy(pszBuf + cch, pszTargetSubDir);
		cch += lstrlen(pszTargetSubDir);
		if (pszBuf[cch-1] != '\\')
			pszBuf[cch++] = '\\';
	}

	pszBuf[cch] = '\0';
	return cch;
}


int GetDriverTargetPath(const DRIVER_FILE_INFO* pFileInfo, LPTSTR pszBuf)
{
	LPCTSTR pszTargetSubDir = pFileInfo->szFileTitle + lstrlen(pFileInfo->szFileTitle) + 1;
	return GetStandardTargetPath(pFileInfo->nTargetDir, pszTargetSubDir, pszBuf);
}


// Returns number of CAB files (from Windows CD) that need to be copied.
// Note that other files may still need to be copied from the driver source directory.
int CInfFileList::BuildSourceFileList()
{
	TCHAR szPath[MAX_PATH];

	CSortedStringArray& rgCabFiles = m_rgCabFiles;
	CSortedStringArray& rgSourceFiles = m_rgSourceFiles;

	m_rgLayoutFiles.Sort();

#ifdef _DEBUG
//	m_rgLayoutFiles.Dump();
#endif

	for (int iDriverFile = 0; iDriverFile < m_rgDriverFiles.GetSize(); iDriverFile++)
	{
		DRIVER_FILE_INFO* pDriverFileInfo = m_rgDriverFiles[iDriverFile];

		// Check if file is already installed
//		GetStandardTargetPath(pDriverFileInfo->nTargetDir, szPath);
//		MakePath(szPath, szPath, pDriverFileInfo->szFileTitle);
//		if (DoesFileExist(szPath))
//			continue; // skip this file

		if (!m_strDriverSourceDir.IsEmpty())
		{
			// Check if file exists in source directory
			MakePath(szPath, m_strDriverSourceDir, pDriverFileInfo->szFileTitle);
			if (DoesFileExist(szPath))
			{
				if (-1 == rgSourceFiles.Find(pDriverFileInfo->szFileTitle))
				{
					rgSourceFiles.Add(pDriverFileInfo->szFileTitle, 0);
				}
				continue;
			}
		}

		SOURCE_DISK_INFO* pSourceDiskInfo = m_rgLayoutFiles.FindDriverFileSourceDisk(pDriverFileInfo->szFileTitle);
		if (pSourceDiskInfo != NULL && !pSourceDiskInfo->strCabFile.IsEmpty())
		{
			if (-1 == rgCabFiles.Find(pSourceDiskInfo->strCabFile))
			{
				LPTSTR pszDiskName = lstrdup(pSourceDiskInfo->strDescription);
				rgCabFiles.Add(pSourceDiskInfo->strCabFile, (DWORD)pszDiskName);
			}
			continue;
		}
	}

	for (int i = 0; i < rgCabFiles.GetSize(); i++)
	{
		TRACE("%s\r\n", rgCabFiles[i]);
	}

	return rgCabFiles.GetSize();
}

#if NOT_FINISHED
BOOL CInfFileList::CheckWindowsCD(LPCTSTR pszDirectory)
{
	if (m_rgCabFiles.GetSize() == 0)
		return TRUE; // no files to copy

	UINT uPrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

	// Check for existence of one of the cabs on the CD
	// REVIEW: if it's a fixed disk, should check for all files
	// REVIEW: if it's a network share, this could take a long time

	TCHAR szPath[MAX_PATH];
	BOOL bResult = FALSE;
	MakePath(szPath, pszDirectory, ".");
	if (DoesFileExist(szPath))
	{
		MakePath(szPath, pszDirectory, m_rgCabFiles[0]);
		bResult = DoesFileExist(szPath);

		if (!bResult)
		{
			// Search one level of subdirectories starting with "W"
			WIN32_FIND_DATA Find;
			HANDLE hFind;
			MakePath(szPath, pszDirectory, "W*.*");
			if (INVALID_HANDLE_VALUE != (hFind = FindFirstFile(szPath, &Find)))
			{
				do
				{
					MakePath(szPath, pszDirectory, Find.cFileName);
					MakePath(szPath, szPath, m_rgCabFiles[0]);
					if (DoesFileExist(szPath))
					{
						bResult = TRUE;
						break;
					}
				}
				while (FindNextFile(hFind, &Find));
				FindClose(hFind);
			}
		}
	}

	SetErrorMode(uPrevErrorMode);
	return bResult;
}

BOOL CInfFileList::FindWindowsCD(HWND hwndParent)
{
	TCHAR szPath[MAX_PATH];

	// check the version of the Windows source path that we've saved
	if (theApp.GetProfileString(c_szRegVal_PrevSourcePath, szPath, _countof(szPath)))
	{
		if (CheckWindowsCD(szPath))
		{
//			goto success;
		}
	}
	else
	{
		// Check the current Windows source path
		CRegistry reg;
		if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szSetupKey) &&
			reg.QueryStringValue(c_szRegVal_SourcePath, szPath, _countof(szPath)))
		{
			if (CheckWindowsCD(szPath))
			{
				goto success;
			}
		}
	}

	if (!PromptWindowsCD(hwndParent, szPath, szPath))
		return FALSE;

success:
	m_strWindowsCD = szPath;
	return TRUE;
}

BOOL CInfFileList::PromptWindowsCD(HWND hwndParent, LPCTSTR pszInitialDir, LPTSTR pszResultDir)
{
	LPCTSTR pszDiskName = (LPCTSTR)m_rgCabFiles.GetItemData(0);
	CWinPathDlg dlg(pszInitialDir, pszDiskName, CWnd::FromHandle(hwndParent));

	// Loop until user types a path to a valid CD, or clicks Cancel
	for (;;)
	{
		if (IDOK != dlg.DoModal())
			return FALSE;

		if (CheckWindowsCD(dlg.m_strPath))
		{
			lstrcpy(pszResultDir, dlg.m_strPath);
			return TRUE;
		}
	}
}

BOOL CInfFileList::CopySourceFiles(HWND hwndParent, LPCTSTR pszDestDir, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam)
{
	int cFiles = m_rgCabFiles.GetSize() + m_rgSourceFiles.GetSize();

	if (m_rgCabFiles.GetSize() > 0)
	{
	}

	return TRUE;
}
#endif

//////////////////////////////////////////////////////////////////////////////
// Modify system INF

class CInfUpdater : public CInfParser
{
public:
	CInfUpdater(LPCTSTR pszRequire = NULL, LPCTSTR pszExclude = NULL);
	~CInfUpdater();

	enum eUpdateType {
		update_NoVersionConflict	= 0x01,
		update_NoCopyFiles			= 0x02,
		update_RequireExclude		= 0x04,
	};

	BOOL IsModified();
	BOOL UpdateInfFile(LPCTSTR pszBackupLocation, UINT updateType);

	LPCTSTR m_pszRequire;
	LPCTSTR m_pszExclude;

protected:

	void WriteToCurPos();
	void Write(LPCTSTR pszString);
	void Write(const void* pvData, UINT cbData);
	BOOL OpenTempFile();
	BOOL CloseTempFile();
	BOOL RenameTempFile();

protected:
	CString	m_strTempFile;
	HANDLE	m_hTempFile;
	BOOL	m_bWriteSuccess;
	DWORD	m_iWritePos;
};

CInfUpdater::CInfUpdater(LPCTSTR pszRequire /*=NULL*/, LPCTSTR pszExclude /*=NULL*/)
{
	m_hTempFile = INVALID_HANDLE_VALUE;
	m_pszRequire = pszRequire;
	m_pszExclude = pszExclude;
}

CInfUpdater::~CInfUpdater()
{
	CloseTempFile();
	if (!m_strTempFile.IsEmpty())
	{
		DeleteFile(m_strTempFile);
	}
}

BOOL CInfUpdater::IsModified()
{
	ASSERT(m_pszFileData != NULL);
	return !memcmp(SZ_CHECK_MODIFIED_HEADER, m_pszFileData, _lengthof(SZ_CHECK_MODIFIED_HEADER));
}

BOOL CInfUpdater::UpdateInfFile(LPCTSTR pszBackupLocation, UINT updateType)
{
	ASSERT(m_pszFileData != NULL);
	if (m_pszFileData == NULL)
		return FALSE;

	Rewind();

	if (!OpenTempFile())
		return FALSE;

	Write(SZ_MODIFIED_INF_HEADER);
	Write(pszBackupLocation);
	Write(SZ_MODIFIED_INF_HEADER2);

	BOOL bInSection = FALSE;
	for (;;)
	{
		// Skip whitespace
		while (m_pszFileData[m_iPos] == ' ' || m_pszFileData[m_iPos] == '\t')
			m_iPos++;

		// Note: we're always at the beginning of a line here.
		TCHAR ch = m_pszFileData[m_iPos];

		if (ch == '\0')
			break;

		if (updateType & update_NoVersionConflict)
		{
			if (ch != '[' && ch != ';' && (UINT)ch > ' ')
			{
				// Look for lines w/ just a filename, and append ",,,32" to them

				LPTSTR pszLine = m_pszFileData + m_iPos;
				LPTSTR pchEnd = pszLine;
				while (*pchEnd != '\0' && *pchEnd != '\r' && *pchEnd != '\n' &&
					   *pchEnd != ';' && *pchEnd != '=' && *pchEnd != ',')
				{
					pchEnd++;
				}

				// don't change lines that already have ,,,16 or something
				// also don't change lines like CatalogFile=nettrans.cat
				if (*pchEnd != ',' && *pchEnd != '=') 
				{
					// Backup over whitespace
					while (*(pchEnd-1) == ' ' || *(pchEnd-1) == '\t')
						pchEnd--;

					// Is it a filename? Note that some filenames will be missed here, but
					// we really only care about .dll, .386, .vxd, and a few others
					CString str(pszLine, (int)(pchEnd - pszLine));
					if (lstrlen(FindExtension(str)) == 3)
					{
						m_iPos = (DWORD)(pchEnd - m_pszFileData);
						WriteToCurPos();
						Write(",,,32");
					}
				}
			}
		}
		if (updateType & update_NoCopyFiles)
		{
			if (0 == memcmp(m_pszFileData + m_iPos, "CopyFiles", _lengthof("CopyFiles")))
			{
				// Comment out the reference to the CopyFiles section
				WriteToCurPos();
				Write(";hc ");
			}
		}
		if (updateType & update_RequireExclude)
		{
			ASSERT(m_pszRequire != NULL);
			ASSERT(m_pszExclude != NULL);

			const TCHAR c_szRequireAll[] = _T("HKR,Ndi\\Compatibility,RequireAll,,\"");
			const TCHAR c_szExcludeAll[] = _T("HKR,Ndi\\Compatibility,ExcludeAll,,\"");
			LPCTSTR pszInsert = NULL;

			if (0 == memcmp(m_pszFileData + m_iPos, c_szRequireAll, _lengthof(c_szRequireAll)))
				pszInsert = m_pszRequire;
			else if (0 == memcmp(m_pszFileData + m_iPos, c_szExcludeAll, _lengthof(c_szExcludeAll)))
				pszInsert = m_pszExclude;

			if (pszInsert != NULL)
			{
				// Insert the appropriate string between the double-quotes
				ASSERT(_lengthof(c_szRequireAll) == _lengthof(c_szExcludeAll));
				m_iPos += _lengthof(c_szRequireAll);
				WriteToCurPos();
				Write(pszInsert);

				// Skip to closing quote
				while (m_pszFileData[m_iPos] != '\"' && m_pszFileData[m_iPos] != '\0')
					m_iPos += 1;
				m_iWritePos = m_iPos;
			}
		}

		GotoNextLine();
	}

	WriteToCurPos();

	if (!CloseTempFile())
		return FALSE;

	if (!RenameTempFile())
		return FALSE;

	return TRUE;
}

void CInfUpdater::WriteToCurPos()
{
	ASSERT(m_iPos >= m_iWritePos);
	Write(m_pszFileData + m_iWritePos, m_iPos - m_iWritePos);
	m_iWritePos = m_iPos;
}

void CInfUpdater::Write(LPCTSTR pszString)
{
	Write(pszString, lstrlen(pszString));
}

void CInfUpdater::Write(const void* pvData, UINT cbData)
{
	DWORD cbWritten;
	if (!WriteFile(m_hTempFile, pvData, cbData, &cbWritten, NULL) || cbData != cbWritten)
		m_bWriteSuccess = FALSE;
}

BOOL CInfUpdater::OpenTempFile()
{
	TCHAR szDirectory[MAX_PATH];
	GetFullInfPath(m_strFileName, szDirectory, _countof(szDirectory));
	*(FindFileTitle(szDirectory)) = '\0';

	LPTSTR pszBuf = m_strTempFile.GetBuffer(MAX_PATH);
	GetTempFileName(szDirectory, "inf", 0, pszBuf);
	m_strTempFile.ReleaseBuffer();

	ASSERT(m_hTempFile == INVALID_HANDLE_VALUE);
	m_hTempFile = CreateFile(m_strTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (m_hTempFile == INVALID_HANDLE_VALUE)
		return FALSE;

	m_iWritePos = 0;
	m_bWriteSuccess = TRUE;

	return TRUE;
}

BOOL CInfUpdater::CloseTempFile()
{
	if (m_hTempFile == INVALID_HANDLE_VALUE)
		return FALSE;

	BOOL bResult = CloseHandle(m_hTempFile);
	m_hTempFile = INVALID_HANDLE_VALUE;
	if (m_bWriteSuccess)
		m_bWriteSuccess = bResult;
	return m_bWriteSuccess;
}

BOOL CInfUpdater::RenameTempFile()
{
	TCHAR szInfPath[MAX_PATH];
	GetFullInfPath(m_strFileName, szInfPath, _countof(szInfPath));
	if (!DeleteFile(szInfPath))
		return FALSE;
	if (!MoveFile(m_strTempFile, szInfPath))
		return FALSE;

	return TRUE;
}

// Modifies the given INF file to avoid the Version Conflict dialog.
// Backs up original version in same directory, e.g. "Net (HomeClick backup).inf"
BOOL ModifyInf_Helper(LPCTSTR pszInfFile, UINT updateType, LPCTSTR pszRequire = NULL, LPCTSTR pszExclude = NULL)
{
	CInfUpdater infUpdate(pszRequire, pszExclude);
	if (!infUpdate.LoadInfFile(pszInfFile))
		return FALSE;

	// Already updated?
	if (infUpdate.IsModified())
		return FALSE;	// already modified, don't modify again

	TCHAR szInfPath[MAX_PATH];
	GetFullInfPath(pszInfFile, szInfPath, _countof(szInfPath));

	TCHAR szBackup[MAX_PATH];
	lstrcpy(szBackup, szInfPath);
	lstrcpy(FindExtension(szBackup)-1, SZ_INF_BACKUP_SUFFIX);

	FILETIME ftSrcCreated;
	FILETIME ftSrcModified;
	HANDLE hFile = CreateFile(szInfPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	GetFileTime(hFile, &ftSrcCreated, NULL, &ftSrcModified);
	CloseHandle(hFile);

	if (!CopyFile(szInfPath, szBackup, FALSE))
		return FALSE;

	BOOL bResult = infUpdate.UpdateInfFile(szBackup, updateType);

	hFile = CreateFile(szInfPath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DWORD dwFileSize = GetFileSize(hFile, NULL);
	SetFileTime(hFile, &ftSrcCreated, NULL, &ftSrcModified);
	CloseHandle(hFile);

	return bResult;
}

BOOL ModifyInf_NoVersionConflict(LPCTSTR pszInfFile)
{
	return ModifyInf_Helper(pszInfFile, CInfUpdater::update_NoVersionConflict);
}

BOOL ModifyInf_NoCopyFiles(LPCTSTR pszInfFile)
{
	return ModifyInf_Helper(pszInfFile, CInfUpdater::update_NoCopyFiles);
}

BOOL ModifyInf_RequireExclude(LPCTSTR pszInfFile, LPCTSTR pszRequire, LPCTSTR pszExclude)
{
	return ModifyInf_Helper(pszInfFile, CInfUpdater::update_RequireExclude, pszRequire, pszExclude);
}

BOOL ModifyInf_NoCopyAndRequireExclude(LPCTSTR pszInfFile, LPCTSTR pszRequire, LPCTSTR pszExclude)
{
	return ModifyInf_Helper(pszInfFile, 
							CInfUpdater::update_NoCopyFiles | CInfUpdater::update_RequireExclude, 
							pszRequire, pszExclude);
}

BOOL RestoreInfBackup(LPCTSTR pszInfFile)
{
	TCHAR szInfPath[MAX_PATH];
	GetFullInfPath(pszInfFile, szInfPath, _countof(szInfPath));

	TCHAR szBackup[MAX_PATH];
	lstrcpy(szBackup, szInfPath);
	lstrcpy(FindExtension(szBackup)-1, SZ_INF_BACKUP_SUFFIX);

	/*
	FILETIME ftSrcCreated;
	FILETIME ftSrcModified;
	HANDLE hFile = CreateFile(szInfPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	GetFileTime(hFile, &ftSrcCreated, NULL, &ftSrcModified);
	CloseHandle(hFile);
	*/

	if (!DoesFileExist(szBackup))
		return FALSE;

	if (!DeleteFile(szInfPath))
		return FALSE;

	if (!MoveFile(szBackup, szInfPath))
		return FALSE;

	/*
	hFile = CreateFile(szInfPath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	GetFileTime(hFile, &ftSrcCreated, NULL, &ftSrcModified);
	CloseHandle(hFile);
	*/

	return TRUE;
}

BOOL CheckInfSectionInstallation(LPCTSTR pszInfFile, LPCTSTR pszInfSection)
{
	CInfParser parser;
	if (!parser.LoadInfFile(pszInfFile))
	{
		ASSERT(FALSE);
		return TRUE; // all known files are present even though it's an error
	}

	CDriverFileArray rgFiles;
	if (!parser.GetFilesFromInstallSection(pszInfSection, rgFiles))
	{
		ASSERT(FALSE);
		return TRUE; // all known files are present even though it's an error
	}

	TCHAR szPath[MAX_PATH];
	int cFiles = rgFiles.GetSize();
	for (int iFile = 0; iFile < cFiles; iFile++)
	{
		int cch = GetDriverTargetPath(rgFiles[iFile], szPath);
		if (cch != 0)
		{
			lstrcpy(szPath + cch, rgFiles[iFile]->szFileTitle);
			if (!DoesFileExist(szPath))
				return FALSE;
		}
	}

	return TRUE;
}

BOOL InstallInfSection(LPCTSTR pszInfFile, LPCTSTR pszInfSection, BOOL bWait)
{
	// Make a modified copy of the INF
	BOOL bModifiedInf = ModifyInf_NoVersionConflict(pszInfFile);

	TCHAR szPath[MAX_PATH + 200];
	int cch = GetWindowsDirectory(szPath, _countof(szPath));
#ifdef UNICODE
	wnsprintf(szPath + cch, ARRAYSIZE(szPath) - cch, L"\\RunDll.exe setupx.dll,InstallHinfSection %s 0 %s", pszInfSection, pszInfFile);
#else
	wsprintf(szPath + cch, "\\RunDll.exe setupx.dll,InstallHinfSection %s 0 %s", pszInfSection, pszInfFile);
#endif
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	PROCESS_INFORMATION pi;
	BOOL bResult = CreateProcess(NULL, szPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
	if (bResult)
	{
		if (bWait)
		{
			WaitForSingleObject(pi.hProcess, INFINITE);
		}
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}

	if (bModifiedInf)
	{
		RestoreInfBackup(pszInfFile);
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\registry.h ===
//
// Registry.h
//

#pragma once

#ifdef __cplusplus

// Note: For strong type checking in the Query functions, #define _REG_STRONGTYPES
#ifndef _REG_STRONGTYPES
#define _REG_STRONGTYPES 1
#endif

// Set _REG_ALLOCMEM to 0 to disable functions which allocate memory
#ifndef _REG_ALLOCMEM
#define _REG_ALLOCMEM 1
#endif


class CRegistry
{
public:
	CRegistry();
	CRegistry(HKEY hkeyParent, LPCTSTR pszKey, DWORD dwAccessFlags = KEY_ALL_ACCESS, BOOL bCreateIfMissing = TRUE);
	~CRegistry();

	void CloseKey();
	BOOL OpenKey(HKEY hkeyParent, LPCTSTR pszKey, REGSAM dwAccessFlags = KEY_ALL_ACCESS);
	BOOL CreateKey(HKEY hkeyParent, LPCTSTR pszKey, REGSAM dwAccessFlags = KEY_ALL_ACCESS);
	BOOL OpenSubKey(LPCTSTR pszKey, REGSAM dwAccessFlags = KEY_ALL_ACCESS);
	BOOL CreateSubKey(LPCTSTR pszKey, REGSAM dwAccessFlags = KEY_ALL_ACCESS);
	BOOL DeleteSubKey(LPCTSTR pszKey);

	DWORD GetValueSize(LPCTSTR pszValueName);
	BOOL DoesValueExist(LPCTSTR pszValueName);

	BOOL DeleteValue(LPCTSTR pszValueName);

#ifdef _AFX
	BOOL QueryStringValue(LPCTSTR pszValueName, CString& strResult);
	CString QueryStringValue(LPCTSTR pszValueName);
	BOOL SetStringValue(LPCTSTR pszValueName, const CString& strData);
#endif

	BOOL QueryStringValue(LPCTSTR pszValueName, LPTSTR pszBuf, int cchBuf, int* pNumCharsWritten);
	int QueryStringValue(LPCTSTR pszValueName, LPTSTR pszBuf, int cchBuf);
	BOOL SetStringValue(LPCTSTR pszValueName, LPCTSTR pszData);
	LPTSTR QueryStringValue(LPCTSTR pszValueName, int* pNumCharsWritten);

	DWORD QueryDwordValue(LPCTSTR pszValueName, DWORD dwDefault = 0);
	BOOL QueryDwordValue(LPCTSTR pszValueName, DWORD* pVal);
	BOOL SetDwordValue(LPCTSTR pszValueName, DWORD dwVal);

	BOOL SetBinaryValue(LPCTSTR pszValueName, LPCVOID pvData, DWORD cbData);

	int QueryIntValue(LPCTSTR pszValueName);
	BOOL QueryIntValue(LPCTSTR pszValueName, int* pVal);
	BOOL SetIntValue(LPCTSTR pszValueName, int nVal);

	BOOL DeleteAllValues();
    BOOL CloneSubKey(LPCTSTR pszExistingSubKey, CRegistry& regDest, BOOL bRecursive);
    BOOL CloneSubKey(LPCTSTR pszExistingSubKey, LPCTSTR pszNewSubKey, BOOL bRecursive);

public:
	HKEY m_hKey;
};


//
// Inline functions
//

inline CRegistry::CRegistry()
{
	m_hKey = NULL;
}

inline BOOL CRegistry::DoesValueExist(LPCTSTR pszValueName)
{
	return (BOOL)GetValueSize(pszValueName);
}

inline BOOL CRegistry::DeleteValue(LPCTSTR pszValueName)
{
    if (m_hKey)
        return (ERROR_SUCCESS == RegDeleteValue(m_hKey, pszValueName));
    else
        return FALSE;
}

inline int CRegistry::QueryStringValue(LPCTSTR pszValueName, LPTSTR pszBuf, int cchBuf)
{
    if (QueryStringValue(pszValueName, pszBuf, cchBuf, &cchBuf))
        return cchBuf;
    else
        return 0;
}

inline DWORD CRegistry::QueryDwordValue(LPCTSTR pszValueName, DWORD dwDefault /*=0*/)
{
	DWORD dwVal = dwDefault;
	QueryDwordValue(pszValueName, &dwVal);
	return dwVal;
}

inline int CRegistry::QueryIntValue(LPCTSTR pszValueName)
{
	return (int)QueryDwordValue(pszValueName);
}

inline BOOL CRegistry::QueryIntValue(LPCTSTR pszValueName, int* pVal)
{
	return QueryDwordValue(pszValueName, (DWORD*)pVal);
}

inline BOOL CRegistry::SetIntValue(LPCTSTR pszValueName, int nVal)
{
	return SetDwordValue(pszValueName, (DWORD)nVal);
}

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\sortstr.cpp ===
//
// SortString.cpp
//

#include "stdafx.h"
#include "SortStr.h"

#define ISDIGIT(ch) ((UINT)((char)(ch) - '0') <= 9)
#define ROUND_UP(val, quantum) ((val) + (((quantum) - ((val) % (quantum))) % (quantum)))

extern "C" BOOL SafeRealloc(LPVOID FAR* ppv, UINT cb)
{
	LPVOID pv2;

	if (*ppv == NULL)
	{
		pv2 = malloc(cb);
	}
	else
	{
		pv2 = realloc(*ppv, cb);
	}

	if (pv2 == NULL)
	{
		return FALSE;
	}
	else
	{
		*ppv = pv2;
		return TRUE;
	}
}

extern "C" void SafeFree(LPVOID FAR* ppv)
{
	if (*ppv)
	{
		free(*ppv);
		*ppv = NULL;
	}
}

extern "C" BOOL SafeGrowArray(LPVOID FAR* ppv, UINT FAR* pArrayMax, UINT nSizeWanted, UINT nGrowBy, UINT cbElement)
{
	// Round up to next multiple of nGrowBy
	UINT newMax = ROUND_UP(nSizeWanted, nGrowBy);
	if (newMax > *pArrayMax)
	{
		if (!SafeRealloc(ppv, newMax * cbElement))
			return FALSE;
		*pArrayMax = newMax;
	}
	return TRUE;
}

// A custom compare routine that will put strings like "100+" after "9"
int WINAPI CompareStringsWithNumbers(LPCTSTR psz1, LPCTSTR psz2)
{
	if (ISDIGIT(*psz1) && ISDIGIT(*psz2))
	{
		int nVal1 = MyAtoi(psz1);
		int nVal2 = MyAtoi(psz2);

		if (nVal1 < nVal2)
			return -1;
		else if (nVal1 > nVal2)
			return 1;
		else
		{
			while (ISDIGIT(*psz1))
				psz1++;
			while (ISDIGIT(*psz2))
				psz2++;
		}
	}

	return lstrcmpi(psz1, psz2);
}


CSortedStringArray::CSortedStringArray(SORTSTRING_COMPARE_PROC pfnCustomCompare /*=NULL*/)
{
	m_prgStrings = NULL;
	m_cStrings = 0;
	m_maxStrings = 0;

	if (pfnCustomCompare == NULL)
		pfnCustomCompare = lstrcmpi;
	m_pfnCompare = pfnCustomCompare;
}

CSortedStringArray::~CSortedStringArray()
{
	for (int iString = m_cStrings-1; iString >= 0; iString--)
	{
		delete [] ((LPBYTE)m_prgStrings[iString] - sizeof(DWORD));
	}
	SafeFree((void**)&m_prgStrings);
}

int CSortedStringArray::Add(LPCTSTR psz, DWORD dwData)
{
    for (int iItem = 0; iItem < m_cStrings; iItem++)
    {
        if ((*m_pfnCompare)(psz, m_prgStrings[iItem]) < 0)
            break;
    }

    if (SafeGrowArray((void**)&m_prgStrings, (UINT*)&m_maxStrings, (UINT)m_cStrings+1, 40, sizeof(LPTSTR)))
    {
        int cch = lstrlen(psz);
        LPTSTR pszNew = new TCHAR[ (cch+1)*sizeof(TCHAR) + sizeof(DWORD) ];
        if (pszNew)
        {
            memmove(&m_prgStrings[iItem+1], &m_prgStrings[iItem], (m_cStrings - iItem) * sizeof(LPTSTR));
            *((DWORD*)pszNew) = dwData;
            pszNew += sizeof(DWORD) / sizeof(TCHAR);
            lstrcpy(pszNew, psz);
            m_prgStrings[iItem] = pszNew;

            m_cStrings++;
            return iItem;
        }
    }

    return -1;
}

SORTSTRING_COMPARE_PROC CSortedStringArray::_pfnCompare;

int __cdecl CSortedStringArray::_crtCompareHelper(const void* elem1, const void* elem2)
{
	return _pfnCompare(*((LPCTSTR*)elem1), *((LPCTSTR*)elem2));
}

int CSortedStringArray::Find(LPCTSTR pszString) const
{
	// REVIEW: This isn't safe if this function is called on multiple threads
	_pfnCompare = m_pfnCompare;
	LPTSTR* pResult = (LPTSTR*)bsearch(&pszString, m_prgStrings, m_cStrings, sizeof(LPTSTR), _crtCompareHelper);
	if (pResult == NULL)
		return -1;
	else
		return (int)(pResult - m_prgStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\registry.cpp ===
//
// Registry.cpp
//
//      Wrapper class to make the registry less painful.
//
//       3/04/1998  KenSh     Created
//       3/28/1999  KenSh     Added DeleteAllValues, CloneSubKey
//

#include "stdafx.h"
#include "Registry.h"

#ifdef _DEBUG
#ifdef DEBUG_NEW
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifndef ASSERT
#define ASSERT(x)
#endif

#ifndef _countof
#define _countof(ar) (sizeof(ar) / sizeof((ar)[0]))
#endif


CRegistry::CRegistry(HKEY hkeyParent, LPCTSTR pszKey, REGSAM dwAccessFlags /*=KEY_ALL_ACCESS*/, BOOL bCreateIfMissing /*=TRUE*/)
{
    m_hKey = NULL;

    ASSERT(hkeyParent != NULL);
    ASSERT(pszKey != NULL);

    if (bCreateIfMissing)
        CreateKey(hkeyParent, pszKey, dwAccessFlags);
    else
        OpenKey(hkeyParent, pszKey, dwAccessFlags);
}

CRegistry::~CRegistry()
{
    CloseKey();
}

void CRegistry::CloseKey()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CRegistry::OpenKey(HKEY hkeyParent, LPCTSTR pszKey, REGSAM dwAccessFlags /*=KEY_ALL_ACCESS*/)
{
    CloseKey();
    return (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, pszKey, 0, dwAccessFlags, &m_hKey));
}

BOOL CRegistry::CreateKey(HKEY hkeyParent, LPCTSTR pszKey, REGSAM dwAccessFlags /*=KEY_ALL_ACCESS*/)
{
    DWORD dwDisposition;
    CloseKey();
    return (ERROR_SUCCESS == RegCreateKeyEx(hkeyParent, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                            dwAccessFlags, NULL, &m_hKey, &dwDisposition));
}

BOOL CRegistry::OpenSubKey(LPCTSTR pszKey, REGSAM dwAccessFlags /*=KEY_ALL_ACCESS*/)
{
    BOOL bResult = FALSE;

    if (m_hKey)
    {
        HKEY hkey = m_hKey;
        m_hKey = NULL;
        bResult = OpenKey(hkey, pszKey, dwAccessFlags);
        RegCloseKey(hkey);
    }

    return bResult;
}

BOOL CRegistry::CreateSubKey(LPCTSTR pszKey, REGSAM dwAccessFlags /*=KEY_ALL_ACCESS*/)
{
    BOOL bResult = FALSE;

    if (m_hKey)
    {
        HKEY hkey = m_hKey;
        m_hKey = NULL;
        bResult = CreateKey(hkey, pszKey, dwAccessFlags);
        RegCloseKey(hkey);
    }

    return bResult;
}

DWORD RegDeleteSubKey(HKEY hkey, LPCTSTR pszSubKey)
{
    {
        HKEY hSubKey;
        LONG err = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
        if (ERROR_SUCCESS == err)
        {
            DWORD dwNumSubKeys;
            RegQueryInfoKey(hSubKey, NULL, NULL, NULL, &dwNumSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            for (DWORD iSubKey = dwNumSubKeys; iSubKey > 0; iSubKey--)
            {
                TCHAR szSubKey[260];
                DWORD cchSubKey = _countof(szSubKey);
                if (ERROR_SUCCESS == RegEnumKeyEx(hSubKey, iSubKey-1, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
                {
                    RegDeleteSubKey(hSubKey, szSubKey);
                }
            }
            RegCloseKey(hSubKey);
        }
    }

    return RegDeleteKey(hkey, pszSubKey);
}

BOOL CRegistry::DeleteSubKey(LPCTSTR pszKey)
{
    if (m_hKey && RegDeleteSubKey(m_hKey, pszKey) == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// Zero is returned if and only if the value does not exist.
DWORD CRegistry::GetValueSize(LPCTSTR pszValueName)
{
    DWORD dwSize = 0;
    if (m_hKey)
        RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, NULL, &dwSize);
    return dwSize;
}

#ifdef _AFX
BOOL CRegistry::QueryStringValue(LPCTSTR pszValueName, CString& strResult)
{
    BOOL bSuccess = FALSE;

    if (m_hKey)
    {
        TCHAR szBuf[50]; // default buffer for short strings
        DWORD dwSize = sizeof(szBuf);
        LONG lResult;

#if _REG_STRONGTYPES
        DWORD dwType;
        lResult = RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
        if ((lResult == ERROR_SUCCESS || lResult == ERROR_MORE_DATA) && dwType == REG_SZ)
#else
        lResult = RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)szBuf, &dwSize);
        if (lResult == ERROR_SUCCESS || lResult == ERROR_MORE_DATA)
#endif
        {
            if (lResult == ERROR_SUCCESS)
            {
                strResult = szBuf;
                bSuccess = TRUE;
            }
            else
            {
                int cch = (dwSize / sizeof(TCHAR)) - 1;
                LPTSTR psz = strResult.GetBufferSetLength(cch);
                bSuccess = (ERROR_SUCCESS == RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)psz, &dwSize));
                strResult.ReleaseBuffer(cch);
            }
        }
    }

    if (!bSuccess)
    {
        strResult.Empty();
    }

    return bSuccess;
}
#endif // _AFX

#ifdef _AFX
CString CRegistry::QueryStringValue(LPCTSTR pszValueName)
{
    CString str;
    QueryStringValue(pszValueName, str);
    return str;
}
#endif // _AFX

#ifdef _AFX
BOOL CRegistry::SetStringValue(LPCTSTR pszValueName, const CString& strData)
{
    return m_hKey && (ERROR_SUCCESS == RegSetValueEx(m_hKey, pszValueName, 0, REG_SZ, (LPBYTE)(LPCTSTR)strData, (DWORD)strData.GetLength() + 1));
}
#endif // _AFX

BOOL CRegistry::QueryStringValue(LPCTSTR pszValueName, LPTSTR pszBuf, int cchBuf, int* pNumCharsWritten)
{
    BOOL bSuccess = FALSE;
    if (m_hKey)
    {
#if _REG_STRONGTYPES
        DWORD dwType;
        bSuccess = (ERROR_SUCCESS == RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pszBuf, (DWORD*)&cchBuf)
                            && dwType == REG_SZ);
#else
        bSuccess = (ERROR_SUCCESS == RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)pszBuf, (DWORD*)&cchBuf));
#endif
        if (pNumCharsWritten != NULL)
        {
            if (!bSuccess)
                *pNumCharsWritten = 0;
            else
                *pNumCharsWritten = (int)((DWORD)cchBuf / sizeof(TCHAR)) - 1;
        }
    }

    return bSuccess;
}

// string is allocated with new TCHAR[], use delete[] to delete it.
#if _REG_ALLOCMEM
LPTSTR CRegistry::QueryStringValue(LPCTSTR pszValueName, int* pNumCharsWritten /*=NULL*/)
{
    LPTSTR pszResult = NULL;
    int cch = 0;

    if (m_hKey)
    {
        TCHAR szBuf[50]; // default buffer for short strings
        DWORD dwSize = sizeof(szBuf);
        LONG lResult;

#if _REG_STRONGTYPES
        DWORD dwType;
        lResult = RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
        if ((lResult == ERROR_SUCCESS || lResult == ERROR_MORE_DATA) && dwType == REG_SZ)
#else
        lResult = RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)szBuf, &dwSize);
        if (lResult == ERROR_SUCCESS || lResult == ERROR_MORE_DATA)
#endif
        {
            cch = (dwSize / sizeof(TCHAR)) - 1;
            pszResult = new TCHAR[cch+1];

            if (pszResult != NULL)
            {
                if (lResult == ERROR_SUCCESS)
                {
                    memcpy(pszResult, szBuf, dwSize);
                }
                else
                {
                    if (ERROR_SUCCESS != RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)pszResult, &dwSize))
                    {
                        delete [] pszResult;
                        pszResult = NULL;
                        cch = 0;
                    }
                }
            }
        }
    }
    
    if (pNumCharsWritten != NULL)
        *pNumCharsWritten = cch;

    return pszResult;
}
#endif // _REG_ALLOCMEM

BOOL CRegistry::SetStringValue(LPCTSTR pszValueName, LPCTSTR pszData)
{
    return m_hKey && (ERROR_SUCCESS == RegSetValueEx(m_hKey, pszValueName, 0, REG_SZ, (LPBYTE)pszData, (DWORD)(lstrlen(pszData)+1) * sizeof(TCHAR)));
}

BOOL CRegistry::QueryDwordValue(LPCTSTR pszValueName, DWORD* pVal)
{
    BOOL bSuccess = FALSE;

    if (m_hKey)
    {
        DWORD dwSize = sizeof(DWORD);

#if _REG_STRONGTYPES
        DWORD dwType;
        if (ERROR_SUCCESS == RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pVal, &dwSize))
        {
            if (dwType == REG_DWORD || (dwType == REG_BINARY && dwSize == sizeof(DWORD)))
                bSuccess = TRUE;
        }
#else
        bSuccess = (ERROR_SUCCESS == RegQueryValueEx(m_hKey, pszValueName, NULL, NULL, (LPBYTE)pVal, &dwSize));
#endif
    }

    return bSuccess;
}

BOOL CRegistry::SetDwordValue(LPCTSTR pszValueName, DWORD dwVal)
{
    return m_hKey && (ERROR_SUCCESS == RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD)));
}

BOOL CRegistry::SetBinaryValue(LPCTSTR pszValueName, LPCVOID pvData, DWORD cbData)
{
    return m_hKey && (ERROR_SUCCESS == RegSetValueEx(m_hKey, pszValueName, 0, REG_BINARY, (LPBYTE)pvData, cbData));
}

BOOL CRegistry::DeleteAllValues()
{
    if (m_hKey)
    {
        TCHAR szValueName[MAX_PATH];
        for (;;)
        {
            DWORD cbValueName = _countof(szValueName);
            if (ERROR_SUCCESS != RegEnumValue(m_hKey, 0, szValueName, &cbValueName, NULL, NULL, NULL, NULL))
                return TRUE;
            if (!DeleteValue(szValueName))
                return FALSE;
        }
    }
    return TRUE;
}

// Copies the named subkey from this registry key to the named subkey in the target registry key.
BOOL CRegistry::CloneSubKey(LPCTSTR pszExistingSubKey, CRegistry& regDest, BOOL bRecursive)
{
    ASSERT(pszExistingSubKey != NULL);

    if (!m_hKey || !regDest.m_hKey)
        return FALSE;

    CRegistry regSrc;
    if (!regSrc.OpenKey(m_hKey, pszExistingSubKey, KEY_READ))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    DWORD cbAlloc = 256;
    HANDLE hHeap = GetProcessHeap();
    BYTE* pbData = (BYTE*)HeapAlloc(hHeap, 0, cbAlloc);
    if (pbData)
    {
        // Copy values first
        for (DWORD iValue = 0; ; iValue++)
        {
            TCHAR szValueName[MAX_PATH];
            DWORD cbValueName = _countof(szValueName);
            DWORD dwType;
            DWORD cbData;

            if (ERROR_SUCCESS != RegEnumValue(regSrc.m_hKey, iValue, szValueName, &cbValueName, NULL, &dwType, NULL, &cbData))
                break;

            if (cbData > cbAlloc)
            {
                BYTE* pbDataNew = (BYTE*)HeapReAlloc(hHeap, 0, pbData, cbData + 256);
                if (pbDataNew == NULL)
                {
                    HeapFree(hHeap, 0, pbData);
                    return FALSE;
                }
                pbData = pbDataNew;
                cbAlloc = cbData + 256;
            }

            if (ERROR_SUCCESS != RegQueryValueEx(regSrc.m_hKey, szValueName, NULL, NULL, pbData, &cbData))
                break; // REVIEW: return FALSE?

            if (ERROR_SUCCESS != RegSetValueEx(regDest.m_hKey, szValueName, 0, dwType, pbData, cbData))
                break; // REVIEW: return FALSE? (need to free memory)
        }

        HeapFree(hHeap, 0, pbData);
    }

    // Copy subkeys
    if (bRecursive)
    {
        for (DWORD iSubKey = 0; ; iSubKey++)
        {
            TCHAR szKeyName[MAX_PATH];
            DWORD cbKeyName = _countof(szKeyName);
            if (ERROR_SUCCESS != RegEnumKeyEx(regSrc.m_hKey, iSubKey, szKeyName, &cbKeyName, NULL, NULL, NULL, NULL))
                break;

            CRegistry regDest2;
            if (!regDest2.CreateKey(regDest.m_hKey, szKeyName, KEY_ALL_ACCESS))
                return FALSE;

            if (!regSrc.CloneSubKey(szKeyName, regDest2, TRUE))
                return FALSE;
        }
    }

    return TRUE;
}

// Copies the named subkey to a new subkey of this registry class, with a new name.
BOOL CRegistry::CloneSubKey(LPCTSTR pszExistingSubKey, LPCTSTR pszNewSubKey, BOOL bRecursive)
{
    ASSERT(pszExistingSubKey != NULL);
    ASSERT(pszNewSubKey != NULL);
    ASSERT(0 != lstrcmpi(pszExistingSubKey, pszNewSubKey)); // names can't be the same

    CRegistry regDest;
    if (!m_hKey || !regDest.CreateKey(m_hKey, pszNewSubKey, KEY_ALL_ACCESS))
    {
        return FALSE;
    }

    return CloneSubKey(pszExistingSubKey, regDest, bRecursive);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\strarray.cpp ===
//
// StrArray.cpp
//
//		A very simple string array implementation, intended to be small
//		rather than scalable or particularly fast.
//
// History:
//
//		10/05/1999  KenSh     Created
//

#include "stdafx.h"
#include "StrArray.h"
#include "Util.h"


CStringArray::CStringArray()
{
	m_prgpStrings = NULL;
	m_prgItemData = NULL;
	m_cStrings = 0;
}

CStringArray::~CStringArray()
{
	RemoveAll();
}

void CStringArray::RemoveAll()
{
	for (int i = 0; i < m_cStrings; i++)
		free(m_prgpStrings[i]);
	free(m_prgpStrings);
	free(m_prgItemData);
	m_prgpStrings = NULL;
	m_prgItemData = NULL;
	m_cStrings = 0;
}

int CStringArray::Add(LPCTSTR pszNewElement)
{
    LPTSTR* ppsz = (LPTSTR*)realloc(m_prgpStrings, (1+m_cStrings) * sizeof(LPTSTR));
    DWORD* pdw = (DWORD*)realloc(m_prgItemData, (1+m_cStrings) * sizeof(DWORD));

    // update whatever was successfully reallocated
    if (ppsz)
        m_prgpStrings = ppsz;
    if (pdw)
        m_prgItemData = pdw;

    // if both allocated, we have room.
    if (ppsz && pdw)
    {
        int nIndex = m_cStrings++;
        m_prgpStrings[nIndex] = lstrdup(pszNewElement);
        m_prgItemData[nIndex] = 0;
        return nIndex;
    }
    return -1;
}

void CStringArray::RemoveAt(int nIndex)
{
	ASSERT(nIndex >= 0 && nIndex < m_cStrings);

	free(m_prgpStrings[nIndex]);
	m_cStrings--;

	for ( ; nIndex < m_cStrings; nIndex++)
	{
		m_prgpStrings[nIndex] = m_prgpStrings[nIndex+1];
		m_prgItemData[nIndex] = m_prgItemData[nIndex+1];
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\strstri.h ===
//
// strstri.h
//

char * __cdecl strstri (
        const char * str1,
        const char * str2
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\sortstr.h ===
//
// SortString.h
//

#pragma once


typedef int (WINAPI* SORTSTRING_COMPARE_PROC)(LPCTSTR, LPCTSTR);

// A custom compare routine that will put strings like "100+" after "9"
int WINAPI CompareStringsWithNumbers(LPCTSTR psz1, LPCTSTR psz2);


class CSortedStringArray
{
public:
	CSortedStringArray(SORTSTRING_COMPARE_PROC pfnCustomCompare = NULL);
	~CSortedStringArray();

	int Add(LPCTSTR psz, DWORD dwData);
	int GetSize() const;
	LPCTSTR GetAt(int iItem) const;
	LPCTSTR operator[](int iItem) const;
	DWORD GetItemData(int iItem) const;
	int Find(LPCTSTR pszString) const;

protected:
	LPTSTR*	m_prgStrings; // points to string data, which is preceded by 4-byte item data
	int m_cStrings;
	int m_maxStrings;

	SORTSTRING_COMPARE_PROC m_pfnCompare;

	static int __cdecl _crtCompareHelper(const void* elem1, const void* elem2);
	static SORTSTRING_COMPARE_PROC _pfnCompare;
};

inline int CSortedStringArray::GetSize() const
{
	return m_cStrings;
}

inline LPCTSTR CSortedStringArray::GetAt(int iItem) const
{
	ASSERT(iItem >= 0 && iItem < m_cStrings);
	return m_prgStrings[iItem];
}

inline LPCTSTR CSortedStringArray::operator[](int iItem) const
{
	return GetAt(iItem);
}

inline DWORD CSortedStringArray::GetItemData(int iItem) const
{
	ASSERT(iItem >= 0 && iItem < m_cStrings);
	return *((DWORD*)m_prgStrings[iItem] - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\strarray.h ===
//
// StrArray.h
//
//		A very simple string array implementation, intended to be small
//		rather than scalable or particularly fast.
//
// History:
//
//		10/05/1999  KenSh     Created
//

#pragma once


#ifndef _AFX

class CStringArray
{
public:
	CStringArray();
	~CStringArray();

	inline int GetSize() const
		{ return m_cStrings; }
	inline int GetUpperBound() const
		{ return m_cStrings - 1; }
	inline LPCTSTR GetAt(int nIndex) const
		{ return m_prgpStrings[nIndex]; }
	inline LPTSTR& ElementAt(int nIndex)
		{ return m_prgpStrings[nIndex]; }
	inline LPTSTR& operator[](int nIndex)
		{ return ElementAt(nIndex); }
	inline LPCTSTR operator[](int nIndex) const
		{ return GetAt(nIndex); }
	inline void SetItemData(int nIndex, DWORD dwItemData)
		{ m_prgItemData[nIndex] = dwItemData; }
	inline DWORD GetItemData(int nIndex) const
		{ return m_prgItemData[nIndex]; }

	void RemoveAll();
	int Add(LPCTSTR pszNewElement);
	void RemoveAt(int nIndex);

protected:
	int		m_cStrings;
	LPTSTR*	m_prgpStrings;
	DWORD*	m_prgItemData;
};

#endif // !_AFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\strstri.cpp ===
/***
*strstri.cpp - search for one string inside another
*
*       Modified from strstr.c in the CRT source code
*
*******************************************************************************/

#include "stdafx.h"
//#include <cruntime.h>
//#include <string.h>

/***
*char *strstri(string1, string2) - case-insensitive search for string2 in string1
*
*Purpose:
*       finds the first occurrence of string2 in string1
*
*Entry:
*       char *string1 - string to search in
*       char *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strstri (
        const char * str1,
        const char * str2
        )
{
        char *cp = (char *) str1;
        char *s1, *s2;

        if ( !*str2 )
            return((char *)str1);

        while (*cp)
        {
                s1 = cp;
                s2 = (char *) str2;

                while ( *s1 && *s2 )
				{
#ifdef WIN32
					LPTSTR ch1 = CharUpper((LPTSTR)(*s1));
					LPTSTR ch2 = CharUpper((LPTSTR)(*s2));
#else
					LPSTR ch1 = AnsiUpper((LPSTR)(*s1));
					LPSTR ch2 = AnsiUpper((LPSTR)(*s2));
#endif

					if (ch1 != ch2)
						break;

					s1++;
					s2++;
				}

                if (*s2 == '\0')
                        return(cp);

                cp++;
        }

        return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\netdi1.h ===
//**********************************************************************
//
//  NETDI.H
//
//  Copyright (c) 1995 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Network Device Installer services.
//
//**********************************************************************

#ifndef _INC_NETDI
#define _INC_NETDI          // NETDI.H signature
#include <prsht.h>          // Property sheet API
#include <setupx.h>         // Device Installer API

// Return error codes for NDI_ messages.
#define NDI_ERROR           (1200)  // ISSUE-2002/01/16-roelfc: see setupx.h for error #
enum _ERR_NET_DEVICE_INSTALL
{
    ERR_NDI_ERROR               = NDI_ERROR,  // generic failure
    ERR_NDI_INVALID_HNDI,
    ERR_NDI_INVALID_DEVICE_INFO,
    ERR_NDI_INVALID_DRIVER_PROC,
    ERR_NDI_LOW_MEM,
    ERR_NDI_REG_API,
    ERR_NDI_NOTBOUND,
    ERR_NDI_NO_MATCH,
    ERR_NDI_INVALID_NETCLASS,
    ERR_NDI_INSTANCE_ONCE,
    ERR_NDI_CANCEL,
    ERR_NDI_NO_DEFAULT,
};

// Network Driver Info Handle
DECLARE_HANDLE(HNDI);

// Network Driver Installer Callback
typedef RETERR (CALLBACK* NDIPROC)(HNDI, UINT, WPARAM, LPARAM);
RETERR WINAPI DefNdiProc(HNDI,UINT,WPARAM,LPARAM);

// Network Driver Installer Messages
#define NDI_NULL                0x0000
#define NDI_CREATE              0x0001
#define NDI_DESTROY             0x0002
#define NDI_VALIDATE            0x0003
#define NDI_INSTALL             0x0004
// johnri 3/8/84 removed-using property sheets only
//#define NDI_ASSIGNRESOURCES     0x0005
#define NDI_HASPROPPAGES        0x0005
#define NDI_ADDPROPPAGES        0x0006
// lpapp = (LPNDIADDPROPPAGES)lParam;
typedef BOOL (CALLBACK* LPFNADDNDIPROPPAGE)(LPCPROPSHEETPAGE,LPARAM,BOOL);
typedef struct tagNDIADDPROPPAGES
{
    LPFNADDNDIPROPPAGE      lpfnAddNdiPropPage;
    LPARAM                  lParam;
} NDIADDPROPPAGES, FAR* LPNDIADDPROPPAGES;

#define NDI_REMOVE              0x0007
#define NDI_FIRSTTIMESETUP      0x0008
#define NDI_QUERY_BIND          0x0009
#define NDI_NOTIFY_BIND         0x000A
#define NDI_NOTIFY_UNBIND       0x000B
#define NDI_GETTEXT             0x000C
#define NDI_SETTEXT             0x000D
#define NDI_SYSTEMCHANGE        0x000E 

#define NDI_NDICREATE           0x0040
#define NDI_NDIDESTROY          0x0041

// Messages above NDI_INSTALLER are reserved for installer dlls
#define NDI_INSTALLER           0x8000

// Ndi_Create: lParam flags:
#define NDI_CREATE_BATCHMODE    0x00000001
#define NDI_CREATE_NODISPLAY    0x00000002
#define NDI_CREATE_WORKSTATION  0x00000004

// General NDI management
HNDI   WINAPI NdiGetFirst(VOID);
HNDI   WINAPI NdiGetNext(HNDI hndi);
HNDI   WINAPI NdiFindNdi(HNDI ndiRelation, WORD wNetClass, LPCSTR lpszDeviceId);
RETERR WINAPI NdiIsNdi(HNDI hndi);
RETERR WINAPI NdiCallInstaller(HNDI hndi,UINT,WPARAM,LPARAM);
RETERR WINAPI NdiAddNewDriver(HNDI FAR* lphndi, LPDEVICE_INFO lpdi, LPCSTR lpszDeviceID, UINT uFlags);
    #define NDI_ADD_NO_DISELECT 0x0001

HNDI   WINAPI NdiFindDefNdi( WORD wNetClass );
RETERR WINAPI NdiSetDefNdi( HNDI ndi );
RETERR WINAPI NdiClrDefNdi( HNDI ndi );
HNDI   WINAPI NdiChooseCandidateDefNdi( HNDI ndi, WORD wClass );
RETERR WINAPI NdiNeedReboot ( HNDI ndi, DWORD wRebootType );
RETERR WINAPI CreateNdiFromDeviceId (LPCSTR szId);

// Device Manager
RETERR WINAPI NdiValidate(HNDI hndi, HWND hwndParent);
RETERR WINAPI NdiInstall(HNDI hndi);
RETERR WINAPI NdiRemove(HNDI hndi);
RETERR WINAPI NdiProperties(HNDI hndi, HWND hwndParent);

// Bindings
RETERR WINAPI NdiBind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiUnbind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiQueryBind(HNDI hndiLower, HNDI hndiUpper, UINT uBindType);
RETERR WINAPI NdiIsBound(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiGetBinding(HNDI hndi, HNDI FAR* lphndi, UINT uBindType);
enum _NDIBIND {
    NDIBIND_UPPER       = 1,
    NDIBIND_UPPER_FIRST = NDIBIND_UPPER,
    NDIBIND_UPPER_NEXT,
    NDIBIND_LOWER,
    NDIBIND_LOWER_FIRST = NDIBIND_LOWER,
    NDIBIND_LOWER_NEXT};

// Ndi_SystemChange object properties
RETERR WINAPI NdiSystemChange(UINT uTypeOfChange, HNDI hndi);
enum _NDISYTEMCHANGE {  //lpwClass
    NDISYSTEMCHANGE_ADD,
    NDISYSTEMCHANGE_REMOVE};

// General NDI Object Properties
RETERR WINAPI NdiGetText(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiSetText(HNDI hndi, LPSTR);
RETERR WINAPI NdiGetDeviceInfo(HNDI hndi, LPLPDEVICE_INFO);
RETERR WINAPI NdiGetClass(HNDI hndi, LPWORD lpwClass);
enum _NDICLASS {    // lpwClass
    NDI_CLASS_NET,
    NDI_CLASS_TRANS,
    NDI_CLASS_CLIENT,
    NDI_CLASS_SERVICE};
RETERR WINAPI NdiGetProperties(HNDI hndi, LPVOID FAR* lplpvProperties);
RETERR WINAPI NdiSetProperties(HNDI hndi, LPVOID lpvProperties);
RETERR WINAPI NdiGetOwnerWindow(HNDI hndi, HWND FAR* lphwnd);
RETERR WINAPI NdiGetDeviceId(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiGetFlags(HNDI hndi, LPDWORD lpdwFlags);
// hiword is reserved for internal use
    #define NDIF_ADDED                  0x00000001
    #define NDIF_REMOVED                0x00000002
    #define NDIF_MODIFIED_BINDINGS      0x00000004
    #define NDIF_MODIFIED_PROPERTIES    0x00000008
    #define NDIF_SAVE_MASK              0x0000000F
    #define NDIF_DEFAULT                0x00000010
    #define NDIF_INVISIBLE              0x00000020
    #define NDIF_HAS_PARAMS             0x00000040

// Interfaces
RETERR WINAPI NdiCompareInterface(HNDI ndi, UINT uRelation, HNDI ndi2, UINT uRelation2);
RETERR WINAPI NdiGetInterface(HNDI ndi, UINT uRelation, UINT index, LPSTR lpsz, UINT cbSizeOflpsz);
RETERR WINAPI NdiAddInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
RETERR WINAPI NdiRemoveInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
enum _NDIEDGERELATION {
    NDI_EDGE_ALL=100,               // used to free all edges and marker for first in edge class
    NDI_EDGE_UPPER,
    NDI_EDGE_LOWER,
    NDI_EDGE_UPPERRANGE,
    NDI_EDGE_LOWERRANGE,
    NDI_EDGE_REQUIRELOWER,
    NDI_EDGE_REQUIREANY,
    NDI_EDGE_EXCLUDELOWER,
    NDI_EDGE_EXCLUDEANY,
    NDI_EDGE_ORGUPPER,
    NDI_EDGE_ORGLOWER,
    NDI_EDGE_END,                   // marker only for end of edges
    NDI_COMATIBLE_ALL=200,          // used to free all edges and marker for first in compatible class
    NDI_COMPATIBLE_REQUIREDUPPER,
    NDI_COMPATIBLE_REQUIREDLOWER,
    NDI_COMPATIBLE_REQUIREDALL,
    NDI_COMPATIBLE_REQUIREDANY,
    NDI_COMPATIBLE_EXCLUDEUPPER,
    NDI_COMPATIBLE_EXCLUDELOWER,
    NDI_COMPATIBLE_EXCLUDEALL,
    NDI_COMPATIBLE_END };           // marker only for end of edges

// Driver Registry Access
RETERR WINAPI NdiRegOpenKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCreateKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCloseKey(HKEY hkey);
RETERR WINAPI NdiRegQueryValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, LPSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegSetValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, DWORD dwType, LPCSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegDeleteValue(HNDI hndi,LPCSTR lpszSubKey, LPCSTR lpszValueName);

// Entry point called by NETCPL.
RETERR WINAPI NdiCplProperties(HWND hwndCpl);

#endif // _INC_NETDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\util.h ===
//
// Util.h
//

#ifndef __UTIL_H__
#define __UTIL_H__

#include <stdarg.h>

#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C
#endif


#ifndef _countof
#define _countof(ar) (sizeof(ar) / sizeof((ar)[0]))
#endif

#ifndef _lengthof
#define _lengthof(sz) (_countof(sz) - 1)
#endif

#ifndef ROUND_UP
#define ROUND_UP(val, quantum) ((val) + (((quantum) - ((val) % (quantum))) % (quantum)))
#endif

#ifdef __cplusplus
inline BOOL IsWindows9x() { return (GetVersion() >= 0x80000000) ? TRUE : FALSE; }
#else
#define IsWindows9x() ((GetVersion() >= 0x80000000) ? TRUE : FALSE)
#endif

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)


#define HARDWAREADDRESSBUFLEN 64


#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS 0x0
#endif

#ifndef GUID_LENGTH
#define GUID_LENGTH 42
#endif


EXTERN_C LPTSTR lstrchr(LPCTSTR pszString, TCHAR ch);
EXTERN_C LPTSTR lstrdup(LPCTSTR psz);
EXTERN_C BOOL MyIsDigit(TCHAR ch);
EXTERN_C int MyAtoi(LPCTSTR psz);
EXTERN_C int CountChars(LPCTSTR psz, TCHAR ch);
EXTERN_C BOOL LoadDllFunctions(LPCTSTR pszDll, LPCSTR pszFunctionNames, FARPROC* prgFunctions);
EXTERN_C int MakePath(LPTSTR pszBuf, LPCTSTR pszFolder, LPCTSTR pszFileTitle);
EXTERN_C HRESULT MakeLnkFile(CLSID clsid, LPCTSTR pszLinkTarget, LPCTSTR pszDescription, LPCTSTR pszFolderPath, LPCTSTR pszFileName);
EXTERN_C LPTSTR FindPartialPath(LPCTSTR pszFullPath, int nDepth);
EXTERN_C LPTSTR FindFileTitle(LPCTSTR pszFullPath);
EXTERN_C LPTSTR FindExtension(LPCTSTR pszFileName);
EXTERN_C BOOL IsFullPath(LPCTSTR pszPath);
EXTERN_C void ShowDlgItem(HWND hwndDlg, int nCtrlID, int nCmdShow);
EXTERN_C HWND GetDlgItemRect(HWND hwndDlg, int nCtrlID, RECT* pRect);
EXTERN_C void GetRelativeRect(HWND hwndCtrl, RECT* pRect);
EXTERN_C void SetDlgItemRect(HWND hwndDlg, int nCtrlID, CONST RECT* pRect);
EXTERN_C BOOL __cdecl FormatDlgItemText(HWND hwnd, int nCtrlID, LPCTSTR pszFormat, ...);
EXTERN_C void FormatWindowTextV(HWND hwnd, LPCTSTR pszFormat, va_list argList);
EXTERN_C LPTSTR __cdecl LoadStringFormat(HINSTANCE hInstance, UINT nStringID, ...);
EXTERN_C int EstimateFormatLength(LPCTSTR pszFormat, va_list argList);
EXTERN_C void CenterWindow(HWND hwnd);
EXTERN_C LPCWSTR FindResourceString(HINSTANCE hInstance, UINT nStringID, int* pcchString, WORD wLangID);
EXTERN_C int GetResourceStringLength(HINSTANCE hInstance, UINT nStringID, WORD wLangID);
EXTERN_C LPTSTR LoadStringAllocEx(HINSTANCE hInstance, UINT nID, WORD wLangID);
EXTERN_C void TrimLeft(LPTSTR pszText);
EXTERN_C void TrimRight(LPTSTR pszText);
EXTERN_C DWORD RegDeleteKeyAndSubKeys(HKEY hkey, LPCTSTR pszSubKey);
EXTERN_C void DrawHollowRect(HDC hdc, const RECT* pRect, int cxLeft, int cyTop, int cxRight, int cyBottom);
EXTERN_C void DrawFastRect(HDC hdc, const RECT* pRect);
EXTERN_C int GetFontHeight(HFONT hFont);
EXTERN_C HRESULT MyGetSpecialFolderPath(int nFolder, LPTSTR pszPath);
EXTERN_C BOOL GetLinkTarget(LPCTSTR pszLinkPath, LPTSTR pszLinkTarget);

#ifdef __cplusplus
EXTERN_C LPBYTE LoadFile(LPCTSTR pszFileName, DWORD* pdwFileSize = NULL);
#else
EXTERN_C LPBYTE LoadFile(LPCTSTR pszFileName, DWORD* pdwFileSize);
#endif

#ifdef __cplusplus
    BOOL GetFirstToken(LPCSTR& pszList, TCHAR chSeparator, LPSTR pszBuf, int cchBuf);
    inline LPTSTR LoadStringAlloc(HINSTANCE hInst, UINT nStringID)
        { return LoadStringAllocEx(hInst, nStringID, 0); }
    void ReplaceString(LPTSTR& pszTarget, LPCTSTR pszSource);
#else
    #define LoadStringAlloc(hInst, nStringID) LoadStringAllocEx(hInst, nStringID, 0)
#endif

#define DoesFileExist(szFile) (GetFileAttributes(szFile) != 0xFFFFFFFF)


#define INT16_CCH_MAX    6    // -32768
#define INT32_CCH_MAX    11    // -2147483648
#define INT64_CCH_MAX    20    // -9223372036854775808
#define INT128_CCH_MAX    40    // -170141183460469231731687303715884105728
#define INT16X_CCH_MAX    4    // FFFF
#define INT32X_CCH_MAX    8    // FFFFFFFF
#define INT64X_CCH_MAX    16    // FFFFFFFFFFFFFFFF
#define INT128X_CCH_MAX    32    // FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF


#if defined(WIN64) // REVIEW: I don't know if these values are correct for Win64
#define INT_CCH_MAX        INT32_CCH_MAX
#define INTX_CCH_MAX    INT32X_CCH_MAX
#define LONG_CCH_MAX    INT32_CCH_MAX
#define LONGX_CCH_MAX    INT32X_CCH_MAX
#define SHORT_CCH_MAX    INT16_CCH_MAX
#define SHORTX_CCH_MAX    INT16X_CCH_MAX
#elif defined(WIN32) // Win32
#define INT_CCH_MAX        INT32_CCH_MAX
#define INTX_CCH_MAX    INT32X_CCH_MAX
#define LONG_CCH_MAX    INT32_CCH_MAX
#define LONGX_CCH_MAX    INT32X_CCH_MAX
#define SHORT_CCH_MAX    INT16_CCH_MAX
#define SHORTX_CCH_MAX    INT16X_CCH_MAX
#else // Win16
#define INT_CCH_MAX        INT16_CCH_MAX
#define INTX_CCH_MAX    INT16X_CCH_MAX
#define LONG_CCH_MAX    INT32_CCH_MAX
#define LONGX_CCH_MAX    INT32X_CCH_MAX
#define SHORT_CCH_MAX    INT16_CCH_MAX
#define SHORTX_CCH_MAX    INT16X_CCH_MAX
#endif

inline HRESULT HrFromWin32Error(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}


#endif // !__UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\setupx.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for         ;Internal
//                          exports in SETUP4.DLL                               ;Internal
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific          ;Internal
//                          helper functions to SETUP4.H                        ;Internal
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle       ;Internal
//                          ClassInstaller load/unload.                         ;Internal
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.          ;Internal
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags                   ;Internal
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
	E2I_VCPM,           // Maps VCPM to strings
	E2I_SETUPX,         // Maps setupx returns to strings
	E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
	E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
	E2I_DOS_REASON,     // Maps DOS extended errors to strings.
	E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
	WORD        cbSize;                 // Size of this structure (bytes)
	LOGDISKID   ldid;                   // Logical Disk ID.
	LPSTR       pszPath;                // Ptr. to associated Path string.
	LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
	LPSTR       pszDiskName;            // Ptr. to Disk Name string.
	WORD        wVolTime;               // Volume label modification time.
	WORD        wVolDate;               // Volume label modification date.
	DWORD       dwSerNum;               // Disk serial number.
	WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;



// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for registry-assigned LDIDs
#define LDID_VAR_START  0x7000
#define LDID_VAR_END    0x7FFF

// Range for dynamically-assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // ISSUE-2002/01/16-roelfc: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
							// network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
							// only valid after mouse class installer.
#define LDID_PATCH      37  // path to Patch related files
#define LDID_WIN3XIE    38  // install path of Internet Explorer on Windows 3.1
							// Only defined during system install
#define LDID_UPDATEDFILES   40 //only defined during maint. mode

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// ISSUE-2002/01/16-roelfc: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );


// Constants that determine ranking of device compatibility
#define FIRST_CID_RANK_FROM_INF     1000
#define FIRST_CID_RANK_FROM_DEVICE  2000
#define BAD_DRIVER_RANK             4000

/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* ISSUE-2002/01/16-roelfc -- clean this up */

enum _ERR_VCP
{
	ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
	ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
	ERR_VCP_NOMEM,                          // Insufficient memory to comply
	ERR_VCP_QUEUEFULL,                      // Trying to add a node to a maxed-out queue
	ERR_VCP_NOVHSTR,                        // No string handles available
	ERR_VCP_OVERFLOW,                       // Reference count would overflow
	ERR_VCP_BADARG,                         // Invalid argument to function
	ERR_VCP_UNINIT,                         // String library not initialized
	ERR_VCP_NOTFOUND ,                      // String not found in string table
	ERR_VCP_BUSY,                           // Can't do that now
	ERR_VCP_INTERRUPTED,                    // User interrupted operation
	ERR_VCP_BADDEST,                        // Invalid destination directory
	ERR_VCP_SKIPPED,                        // User skipped operation
	ERR_VCP_IO,                             // Hardware error encountered
	ERR_VCP_LOCKED,                         // List is locked
	ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
	ERR_VCP_CHANGEMODE,                     //
	ERR_VCP_LDDINVALID,                     // Logical Disk ID Invalid.
	ERR_VCP_LDDFIND,                        // Logical Disk ID not found.
	ERR_VCP_LDDUNINIT,                      // Logical Disk Descriptor Uninitialized.
	ERR_VCP_LDDPATH_INVALID,
	ERR_VCP_NOEXPANSION,                    // Failed to load expansion dll
	ERR_VCP_NOTOPEN,                        // Copy session not open
	ERR_VCP_NO_DIGITAL_SIGNATURE_CATALOG,   // Catalog is not digitally signed
	ERR_VCP_NO_DIGITAL_SIGNATURE_FILE,      // A file is not digitally signed
	ERR_VCP_FAILED_PRESERVE_ENUM,           // Error occured in enumerating the file queue for files to preserve
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
	DWORD   dwSoFar;            /* Number of units copied so far */
	DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/*  ISSUE-2002/01/16-roelfc:                                       ;Internal
 *  I currently don't use wVolumeTime, wVolumeDate or              ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
																/* ;Internal */

typedef struct tagVCPDISKINFO {
	WORD        cbSize;         /* Size of this structure in bytes */
	LOGDISKID   ldid;           /* Logical disk ID */
	VHSTR       vhstrRoot;      /* Location of root directory */
	VHSTR       vhstrVolumeLabel;/* Volume label */
	VHSTR       vhstrDiskName;  // Printed name on the disk.
	WORD        wVolumeTime;    /* Volume label modification time */
	WORD        wVolumeDate;    /* Volume label modification date */
	DWORD       dwSerialNumber; /* Disk serial number */
	WORD        fl;             /* Flags */
	LPARAM      lparamRef;      /* Reference data for client */

	VCPPROGRESS prgFileRead;    /* Progress info */
	VCPPROGRESS prgByteRead;

	VCPPROGRESS prgFileWrite;
	VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
	LOGDISKID   ldid;           /* Logical disk */
	VHSTR       vhstrDir;       /* Directory withing logical disk */
	VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * ISSUE-2002/01/16-roelfc -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
	UINT    uiMDate;            /* Modification date */
	UINT    uiMTime;            /* Modification time */
	UINT    uiADate;            /* Access date */
	UINT    uiATime;            /* Access time */
	UINT    uiAttr;             /* File attribute bits */
	DWORD   llenIn;             /* Original file length */
	DWORD   llenOut;            /* Final file length */
								/* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

typedef struct tagVCPFILESTAT
{
	UINT    uDate;
	UINT    uTime;
	DWORD   dwSize;
} VCPFILESTAT, FAR *LPVCPFILESTAT;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
	HFILE           hFileSrc;
	HFILE           hFileDst;
	VCPFATTR        fAttr;
	WORD            dosError;   // The first/last error encountered
	VHSTR           vhstrFileName;  // The original destination name.
	WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 *                                                                 ;Internal
 *  The vFileStat and vhstrCatalogFile fields were added at the    ;Internal
 *  end of the structure after Windows 95 shipped to support driver;Internal
 *  cetification.  Offsets of pre-Win95 fields remain the same.    ;Internal
 *  vFileStat duplicates information in lpvnex, but lpvnex was left;Internal
 *  alone for backcompatibility's sake.                            ;Internal
 *                                                                 ;Internal
 */                                                             /* ;Internal */
																/* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
	WORD            cbSize;
	VCPFILESPEC     vfsSrc;
	VCPFILESPEC     vfsDst;
	WORD            fl;
	LPARAM          lParam;
	LPEXPANDVTBL    lpExpandVtbl;
	LPVIRTNODEEX    lpvnex;
	VHSTR           vhstrDstFinalName;
	VCPFILESTAT     vFileStat;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
	WORD    flDevAttr;          /* Device attributes */
	LONG    cbCapacity;         /* Disk capacity */
	WORD    cbCluster;          /* Bytes per cluster */
	WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED             0x0080  // Node has already been copied.

// ISSUE-2002/01/16-roelfc: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY               0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE          ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
	/* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

#define VNFL_VALIDVQCFLAGS      0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
	WORD    cbSize;             /* Size of this structure */

	VCPPROGRESS prgDiskRead;
	VCPPROGRESS prgFileRead;
	VCPPROGRESS prgByteRead;

	VCPPROGRESS prgDiskWrite;
	VCPPROGRESS prgFileWrite;
	VCPPROGRESS prgByteWrite;

	LPVCPDISKINFO lpvdiIn;      /* Current input disk */
	LPVCPDISKINFO lpvdiOut;     /* Current output disk */
	LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

	LPCSTR  lpszOldFileName;
	LPCSTR  lpszNewFileName;
	DWORD   dwConflictType;     /* Same values as VerInstallFiles */
	LPVOID  lpvinfoOld;         /* Version information resources */
	LPVOID  lpvinfoNew;
	WORD    wAttribOld;         /* File attributes for original */
	LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);


/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required
#define VCPUI_BACKUPVER      0x0008 // backup version conflicts instead of displaying UI

typedef struct {
	UINT flags;
	HWND hwndParent;            // window of parent
	HWND hwndProgress;          // window to get progress updates (nonzero ids)
	UINT idPGauge;              // id for progress gauge
	VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
	LPARAM lUserData;           // caller definable data
	LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

/* ISSUE-2002/01/16-roelfc -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

	VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
	VCPM_DISKGETINFO,
	VCPM_DISKDESTROYINFO,
	VCPM_DISKPREPINFO,

	VCPM_DISKENSURE,
	VCPM_DISKPROMPT,

	VCPM_DISKFORMATBEGIN,
	VCPM_DISKFORMATTING,
	VCPM_DISKFORMATEND,

	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// ISSUE-2002/01/16-roelfc: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
	VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
	VCPM_FILEGETFATTR,
	VCPM_FILECLOSEIN,
	VCPM_FILECOPY,
	VCPM_FILENEEDED,

	VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
	VCPM_FILESETFATTR,
	VCPM_FILECLOSEOUT,
	VCPM_FILEFINALIZE,
	VCPM_FILEDELETE,
	VCPM_FILERENAME,
	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
	VCPM_NODECREATE = VCPM_NODEFIRST,
	VCPM_NODEACCEPT,
	VCPM_NODEREJECT,
	VCPM_NODEDESTROY,
	VCPM_NODECHANGEDESTDIR,
	VCPM_NODECOMPARE,
	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
	VCPM_TALLYSTART = VCPM_TALLYFIRST,
	VCPM_TALLYEND,
	VCPM_TALLYFILE,
	VCPM_TALLYDISK,
	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
	VCPM_VERCHECK = VCPM_VERFIRST,
	VCPM_VERCHECKDONE,
	VCPM_VERRESOLVECONFLICT,
	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
	VCPM_VSTATSTART = VCPM_VSTATFIRST,
	VCPM_VSTATEND,
	VCPM_VSTATREAD,
	VCPM_VSTATWRITE,
	VCPM_VSTATNEWDISK,

	VCPM_VSTATCLOSESTART,       // Start of VCP close
	VCPM_VSTATCLOSEEND,         // upon leaving VCP close
	VCPM_VSTATBACKUPSTART,      // Backup is beginning
	VCPM_VSTATBACKUPEND,        // Backup is finished
	VCPM_VSTATRENAMESTART,      // Rename phase start/end
	VCPM_VSTATRENAMEEND,
	VCPM_VSTATCOPYSTART,        // Acutal copy phase
	VCPM_VSTATCOPYEND,
	VCPM_VSTATDELETESTART,      // Delete phase
	VCPM_VSTATDELETEEND,
	VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
	VCPM_VSTATPATHCHECKEND,
	VCPM_VSTATCERTIFYSTART,     // Certify phase
	VCPM_VSTATCERTIFYEND,
	VCPM_VSTATUSERABORT,        // User wants to quit.
	VCPM_VSTATYIELD,            // Do a yield.
	/* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
	VCPM_BUILDPATH = VCPM_PATHFIRST,
	VCPM_UNIQUEPATH,
	VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*--------------------------------------------------------------------------*
 *          Patch processing callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATCHCLASS      0x09
#define VCPM_PATCHFIRST      0x0900
#define VCPM_PATCHLAST       0x09FF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_PATCH{

	VCPM_FILEPATCHBEFORECPY = VCPM_PATCHFIRST,
	VCPM_FILEPATCHAFTERCPY,
	VCPM_FILEPATCHINFOPEN,
	VCPM_FILEPATCHINFCLOSE,
};

/*--------------------------------------------------------------------------*
 *         Certificate processing callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_CERTCLASS      0x0A
#define VCPM_CERTFIRST      0x0A00
#define VCPM_CERTLAST       0x0AFF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_CERT{

	VCPM_FILECERTIFY = VCPM_CERTFIRST,
	VCPM_FILECERTIFYWARN,
};

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL               (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME )

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
	VCPEX_SRC_DISK,
	VCPEX_SRC_CABINET,
	VCPEX_SRC_LOCN,
	VCPEX_DST_LOCN,
	VCPEX_SRC_FILE,
	VCPEX_DST_FILE,
	VCPEX_DST_FILE_FINAL,
	VCPEX_DOS_ERROR,
	VCPEX_MESSAGE,
	VCPEX_DOS_SOLUTION,
	VCPEX_SRC_FULL,
	VCPEX_DST_FULL,
	VCPEX_DST_FULL_FINAL
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */
// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)
#define VNLP_PATCHIFEXIST   0x0040  // patch only the file exists, if file not there,
#define VNLP_NOPATCH        0x0080  // per file base turn on/off patch option (default patch on)
#define VNLP_CATALOGCERT    0x0100  // This file is a catalog certificate.
#define VNLP_NEEDCERTIFY    0x0200  // This file need to be certified.
#define VNLP_COPYIFEXISTS   0x0400  // if dest file exists, copy it.

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
								 * and ignore the OP field */

// ISSUE-2002/01/16-roelfc: add the other VCP stuff necessary to use this

// ISSUE-2002/01/16-roelfc: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
				LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
				LOGDISKID ldidSrc, LOGDISKID ldidDst,
				LPEXPANDVTBL lpExpandVtbl, WORD fl,
				LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
							  LPCSTR lpszDstDir,
							  LOGDISKID ldidDst,
							  LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
							LPCSTR      lpszDstFileName,
							LPCSTR      lpszSrcDir,
							LPCSTR      lpszDstDir,
							LOGDISKID   ldidSrc,
							LOGDISKID   ldidDst,
							LPARAM      lParam );

RETERR WINAPI vcpRegisterSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
												LPCSTR lpszPath );
RETERR WINAPI vcpGetSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
										LPSTR lpszBuf, UINT uBufSize );

#endif // NOVCP

#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
	ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
	ERR_IP_ALLOC_ERR,
	ERR_IP_INVALID_SECT_NAME,
	ERR_IP_OUT_OF_HANDLES,
	ERR_IP_INF_NOT_FOUND,
	ERR_IP_INVALID_INFFILE,
	ERR_IP_INVALID_HINF,
	ERR_IP_INVALID_FIELD,
	ERR_IP_SECT_NOT_FOUND,
	ERR_IP_END_OF_SECTION,
	ERR_IP_PROFILE_NOT_FOUND,
	ERR_IP_LINE_NOT_FOUND,
	ERR_IP_FILEREAD,
	ERR_IP_TOOMANYINFFILES,
	ERR_IP_INVALID_SAVERESTORE,
	ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN           64

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);
RETERR  WINAPI IpOpenValidate( LPCSTR lpszInfFile, HINF FAR * lphInf,
								 DWORD dwVer, DWORD dwFlags) ;
RETERR WINAPI IpGetDriverDate
(
	LPSTR       lpszInfName,
	UINT        infType,
	LPSTR       lpszSectionName,
	LPWORD      lpwDate
);

RETERR WINAPI IpGetDriverVersion
(
	LPSTR       lpszInfName,
	UINT        infType,
	LPSTR       lpszSectionName,
	LPSTR       lpszVersion,
	WORD        cbVersion
);

RETERR WINAPI IpGetDriverClass
(
    LPSTR       lpszInfName,
    LPSTR       lpszClassName,
    WORD        cbClass
);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
	ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
					// not necessarily terminal
	ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
	ERR_TP_READ,        // could not read the disc - terminal
	ERR_TP_WRITE,       // could not write the data - terminal.
	ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
	ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // ISSUE-2002/01/16-roelfc: max line length?
#define SECTION_LEN     64      // ISSUE-2002/01/16-roelfc: max length of a section name?
#define MAX_STRING_LEN  512     // ISSUE-2002/01/16-roelfc: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
	ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
	ERR_GEN_INVALID_FILE,           // Invalid INF file.
	ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
	ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
	ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
	ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
	ERR_GEN_ADDREG,                 // Can't process AddReg=.
	ERR_GEN_DELREG,                 // Can't process DelReg=.
	ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
	ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
	ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
	ERR_GEN_FILE_REN,               // Can't process RenFiles=.
	ERR_GEN_REG_API,                // Error returned by Reg API.
	ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
	ERR_GEN_ADDIME,                 // Can't process AddIme=.
	ERR_GEN_DELIME,                 // Can't process DelIme=.
	ERR_GEN_PERUSER,                // Can't process PerUserInstall=.
	ERR_GEN_BITREG,                 // Can't process BitReg=.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
	WORD         cbSize;                 // Size of this structure (bytes).
	WORD         wOperation;             // Operation being performed.
	LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
	LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
	LPCSTR       pszSrcFileName;         // Source file name (base name).
	LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
	LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
	LPCSTR       pszDstFileName;         // Dest. file name (base name).
	LPEXPANDVTBL lpExpandVtbl;           // ISSUE-2002/01/16-roelfc: Needed? NULL right now!
	WORD         wflags;                 // flags for VcpQueueCopy.
	LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */
#define GENO_WININITRENAME 4    /* VCP wininit rename being added */

typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
															LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
								HKEY hRegKey, GENCALLBACKPROC CallbackProc,
								LPARAM lparam);

RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
												LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
																HINF hInf ) ;
RETERR WINAPI GenInitSrcPathsInReg(HINF hInf);

// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
// (updated from setupapi.h, with unsupported features commented out)
//
#define FLG_ADDREG_BINVALUETYPE         ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER            ( 0x00000002 )
#define FLG_ADDREG_DELVAL               ( 0x00000004 )
//#define FLG_ADDREG_APPEND             ( 0x00000008 ) // Currently supported only
//                                                     // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY              ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY        ( 0x00000020 ) // Set only if value already exists
#define FLG_ADDREG_TYPE_REPLACEIFEXISTS ( 0x00000040 )

#define FLG_ADDREG_TYPE_MASK            ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ              ( 0x00000000                           )
//#define FLG_ADDREG_TYPE_MULTI_SZ      ( 0x00010000                           )
//#define FLG_ADDREG_TYPE_EXPAND_SZ     ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY          ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD           ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
//#define FLG_ADDREG_TYPE_NONE          ( 0x00020000 | FLG_ADDREG_BINVALUETY