  {
                CDwnDoc * pDwnDoc = _pDwnBindData->GetDwnDoc();

                if (pDwnDoc)
                {
                    DWNPROG DwnProg;
                    _pDwnBindData->GetProgress(&DwnProg);
                    pDwnDoc->AddBytesRead(DwnProg.dwMax);
                }

                _pDwnBindData->Disconnect();
                OnDone(S_OK);

                hr = S_FALSE;
                goto Cleanup;
            }
        }
    }

    _pDwnInfo->SetSecFlags(_pDwnBindData->GetSecFlags());
    
Cleanup:    
    PerfDbgLog1(tagImgLoad, this, "-CImgLoad::OnBindHeaders (hr=%lX)", hr);
    RRETURN1(hr, S_FALSE);
}

HRESULT
CImgLoad::OnBindMime(const MIMEINFO * pmi)
{
    PerfDbgLog1(tagImgLoad, this, "+CImgLoad::OnBindMime %ls",
        pmi ? pmi->pch : g_Zero.ach);

    CImgTask *  pImgTask = NULL;
    HRESULT     hr       = S_OK;

    if (!pmi || _pDwnInfo->TstFlags(DWNF_DOWNLOADONLY))
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (!pmi->pfnImg)
    {
        hr = E_ABORT;
        goto Cleanup;
    }

    _pDwnInfo->SetMimeInfo(pmi);

    pImgTask = pmi->pfnImg();

    if (pImgTask == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pImgTask->Init(GetImgInfo(), pmi, _pDwnBindData);

    hr = THR(StartImgTask(pImgTask));
    if (hr)
        goto Cleanup;

    EnterCriticalSection();

    if (_fPassive)
        hr = E_ABORT;
    else
    {
        _pImgTask = pImgTask;
        pImgTask  = NULL;
    }

    LeaveCriticalSection();

    if (hr == S_OK)
    {
        GetImgInfo()->OnLoadTask(this, _pImgTask);
    }

Cleanup:
    if (pImgTask)
        pImgTask->Release();
    PerfDbgLog1(tagImgLoad, this, "-CImgLoad::OnBindMime (hr=%lX)", hr);
    RRETURN(hr);
}

HRESULT
CImgLoad::OnBindData()
{
    PerfDbgLog(tagImgLoad, this, "+CImgLoad::OnBindData");

    HRESULT hr = S_OK;

    if (_pImgTask)
    {
        _pImgTask->SetBlocked(FALSE);
    }
    else if (_pDwnInfo->TstFlags(DWNF_DOWNLOADONLY))
    {
        BYTE  ab[1024];
        ULONG cb;

        do
        {
            hr = THR(_pDwnBindData->Read(ab, sizeof(ab), &cb));
        }
        while (!hr && cb);
    }
    else
    {
#if !defined(WINCE) && !defined(WIN16)
        // If we're getting data but never got a valid mime type that we
        // know how to decode, use the data to figure out if a pluggable
        // decoder should be used.

        BYTE        ab[200];
        ULONG       cb;
        const MIMEINFO *  pmi;
        
        hr = THR(_pDwnBindData->Peek(ab, ARRAY_SIZE(ab), &cb));
        if (hr)
            goto Cleanup;

        if (cb < ARRAY_SIZE(ab) && _pDwnBindData->IsPending())
            goto Cleanup;

        pmi = GetMimeInfoFromData(ab, cb, _pDwnBindData->GetContentType());
        
        if (!pmi || !pmi->pfnImg)
        {
            pmi = _pDwnBindData->GetRawMimeInfoPtr();
            if( !pmi || !pmi->pfnImg )
            {
                hr = E_ABORT;
                goto Cleanup;
            }
        }

        hr = OnBindMime(pmi);
        if (hr)
            goto Cleanup;

        _pImgTask->SetBlocked(FALSE);
#else
        hr = E_ABORT;
#endif
    }

Cleanup:
    PerfDbgLog1(tagImgLoad, this, "-CImgLoad::OnBindData (hr=%lX)", hr);
    RRETURN(hr);
}

void
CImgLoad::OnBindDone(HRESULT hrErr)
{
    PerfDbgLog1(tagImgLoad, this, "+CImgLoad::OnBindDone (hrErr=%lX)", hrErr);

    CImgInfo *pImgInfo = (CImgInfo *)_pDwnInfo;

    if (_pImgTask)
        _pImgTask->SetBlocked(FALSE);

    pImgInfo->_dwPrivacyFlags = _pDwnBindData->GetPrivacyFlags();
    pImgInfo->SetPolicyRef(_pDwnBindData->GetPolicyRef());

    OnDone(hrErr);

    PerfDbgLog(tagImgLoad, this, "-CImgLoad::OnBindDone");
}

// CImgTask -------------------------------------------------------------------

CImgTask::~CImgTask()
{
    PerfDbgLog(tagImgTask, this, "+CImgTask::~CImgTask");

    if (_pImgInfo)
        _pImgInfo->SubRelease();

    if (_pDwnBindData)
        _pDwnBindData->Release();

    if (!_fComplete)
    {
        FreeGifAnimData(&_gad, (CImgBitsDIB *)_pImgBits);
#ifndef NO_ART
        if (_pArtPlayer)
            delete _pArtPlayer;
#endif
#ifdef _MAC
        if(_Profile)
            _Profile->Release();
#endif
        if (_pImgBits)
            delete _pImgBits;
    }

    PerfDbgLog(tagImgTask, this, "-CImgTask::~CImgTask");
}

void
CImgTask::Init(CImgInfo * pImgInfo, const MIMEINFO * pmi, CDwnBindData * pDwnBindData)
{
    PerfDbgLog1(tagImgTask, this, "+CImgTask::Init %ls", pImgInfo->GetUrl());

    _colorMode  = pImgInfo->GetColorMode();
    _pmi        = pmi;
    _lTrans     = -1;
    _ySrcBot    = -2;

    _pImgInfo = pImgInfo;
    _pImgInfo->SubAddRef();

    _pDwnBindData = pDwnBindData;
    _pDwnBindData->AddRef();

    TraceTag((tagImgTrans, "CImgTask %x (info %x) Init _lTrans = %d  %ls",
                    this, pImgInfo, _lTrans, _pDwnBindData->FileNameDbg()));

    PerfDbgLog(tagImgTask, this, "-CImgTask::Init");
}

void
CImgTask::Run()
{
    PerfDbgLog(tagImgTask, this, "+CImgTask::Run");

    GetImgTaskExec()->RunTask(this);

    PerfDbgLog(tagImgTask, this, "-CImgTask::Run");
}

BOOL
CImgTask::Read(void * pv, ULONG cb, ULONG * pcbRead, ULONG cbMinReq)
{
    PerfDbgLog1(tagImgTaskIO, this, "+CImgTask::Read (req %ld)", cb);

    ULONG   cbReq = cb, cbGot, cbTot = 0;
    HRESULT hr    = S_OK;

    if (cbMinReq == 0 || cbMinReq > cb)
        cbMinReq = cb;

    for (;;)
    {
        if (_fTerminate)
        {
            hr = E_ABORT;
            break;
        }

        hr = THR(_pDwnBindData->Read(pv, cbReq, &cbGot));
        if (hr)
            break;

        cbTot += cbGot;
        cbReq -= cbGot;
        pv = (BYTE *)pv + cbGot;

        if (cbReq == 0)
            break;

        if (!cbGot || IsTimeout())
        {
            if (    _pDwnBindData->IsEof()
                ||  (!cbGot && cbTot >= cbMinReq))
                break;

            PerfDbgLog2(tagImgTask, this, "-CImgTask::Read (fiber %ld yield %s)",
                _pfi - g_pImgTaskExec->_afi, cbGot ? "timeout" : "pending");

            GetImgTaskExec()->YieldTask(this, !cbGot);

            PerfDbgLog1(tagImgTask, this, "+CImgTask::Read (fiber %ld resume)",
                _pfi - g_pImgTaskExec->_afi);
        }
    }

    if (pcbRead)
    {
        *pcbRead = cbTot;
    }

    PerfDbgLog3(tagImgTaskIO, this, "-CImgTask::Read (got %ld) %c%c",
        cbTot, _pDwnBindData->IsEof() ? 'E' : ' ',
        hr == S_OK && cbTot > 0 ? 'T' : 'F');

    return(hr == S_OK && cbTot > 0);
}

void
CImgTask::Terminate()
{
    if (!_fTerminate)
    {
        _fTerminate = TRUE;
        SetBlocked(FALSE);
    }
}

void
CImgTask::OnProg(BOOL fLast, ULONG ulBits, BOOL fAll, LONG yBot)
{
    DWORD dwTick = GetTickCount();

    _yTopProg = Union(_yTopProg, _yBotProg, fAll, yBot);
    _yBotProg = yBot;

    if (fLast || (dwTick - _dwTickProg > 1000))
    {
        _dwTickProg = dwTick;

        _pImgInfo->OnTaskProg(this, ulBits, _yTopProg == -1, _yBotProg);

        _yTopProg = _yBotProg;
    }

    #if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagImgProgSlow))
        Sleep(100);
    #endif
}

void
CImgTask::OnAnim()
{
    _pImgInfo->OnTaskAnim(this);

    #if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagImgAnimSlow))
        Sleep(1000);
    #endif
}

void
CImgTask::Exec()
{
    BOOL fNonProgressive = FALSE;

    _dwTickProg = GetTickCount();

    Decode(&fNonProgressive);
    if (_pImgInfo->TstFlags(DWNF_MIRRORIMAGE))
    {
        if(_pImgBits)
        {
           ((CImgBitsDIB*)(_pImgBits))->SetMirrorStatus(TRUE);
        }
    }
    
    if (_pImgBits && _ySrcBot > -2)
    {
#ifdef NO_ART
        _fComplete = _pImgInfo->OnTaskBits(this, _pImgBits,
            &_gad, NULL, _lTrans, _ySrcBot, fNonProgressive
#ifdef _MAC
            ,_Profile
#endif _MAC
            );
#else
        _fComplete = _pImgInfo->OnTaskBits(this, _pImgBits,
            &_gad, _pArtPlayer, _lTrans, _ySrcBot, fNonProgressive
#ifdef _MAC
            ,_Profile
#endif _MAC
         );
#endif
    }

    if (_ySrcBot == -2 || (_fComplete && _ySrcBot != -1))
    {
        OnProg(TRUE, _ySrcBot == -2 ? IMGBITS_NONE : IMGBITS_PARTIAL,
            TRUE, _yBot);
    }

    #if DBG==1 || defined(PERFTAGS)
    if (_ySrcBot != -1)
        PerfDbgLog4(tagImgTask, this,
            "CImgTask::Exec [%s decode (%ld of %ld) for %ls]",
            _ySrcBot == -2 ? "Failed" : "Partial", max(0L, _ySrcBot),
            _gad.pgf ? _gad.pgf->height : _yHei, GetUrl());
    #endif

    if (_fComplete && _ySrcBot == -1 && !_pDwnBindData->IsEof())
    {
        BYTE ab[512];

        // The image is fully decoded but the binding hasn't reached EOF.
        // Attempt to read the final EOF to allow the binding to complete
        // normally.  This will make sure that HTTP downloads don't delete
        // the cache file just because a decoder (such as the BMP decoder)
        // knows how many bytes to expect based on the header and doesn't
        // stick around until it sees EOF.

        Read(ab, sizeof(ab), NULL);
    }

    if (!_pDwnBindData->IsEof())
    {
        // Looks like the decoder didn't like the data.  Since it is still
        // flowing and we don't need any more of it, abort the binding.

        _pDwnBindData->Terminate(E_ABORT);
    }

    _fTerminate = TRUE;
}

#ifndef NO_ART
BOOL
CImgTask::DoTaskGetReport(CArtPlayer * pArtPlayer)
{
    BOOL fResult = FALSE;

    if ((pArtPlayer == _pArtPlayer) && _pImgBits)
        fResult = _pArtPlayer->GetArtReport((CImgBitsDIB **)_pImgBits,
                        _yHei, _colorMode);

    return (fResult);
}
#endif

// CImgTaskExec ---------------------------------------------------------------

void
CImgTaskExec::YieldTask(CImgTask * pImgTask, BOOL fBlock)
{
    if (fBlock)
    {
        pImgTask->SetBlocked(TRUE);
    }

    SuspendCAP();
    SwitchesEndTimer(SWITCHES_TIMER_DECODEIMAGE);

    FbrSwitchToFiber(_pvFiberMain);

    SwitchesBegTimer(SWITCHES_TIMER_DECODEIMAGE);
    ResumeCAP();
}

FIBERINFO *
CImgTaskExec::GetFiber(CImgTask * pImgTask)
{
    BOOL        fAll = pImgTask->IsFullyAvail() ? 0 : 1;
    FIBERINFO * pfi  = &_afi[fAll];
    UINT        cfi  = ARRAY_SIZE(_afi) - fAll;

    for (; cfi > 0; --cfi, ++pfi)
    {
        if (pfi->pImgTask == NULL)
            goto found;
    }

    return(NULL);

found:

    if (pfi->pvFiber == NULL)
    {
        pfi->pvMain = _pvFiberMain;

        if (pfi->pvMain)
        {
            pfi->pvFiber = FbrCreateFiber(0x8000, FiberProc, pfi);
        }

        if (pfi->pvFiber == NULL)
            return(NULL);
    }

    return(pfi);
}

void
CImgTaskExec::AssignFiber(FIBERINFO * pfi)
{
    BOOL fAll = (pfi == &_afi[0]);

    EnterCriticalSection();

    CImgTask * pImgTask = (CImgTask *)_pDwnTaskHead;

    for (; pImgTask; pImgTask = (CImgTask *)pImgTask->_pDwnTaskNext)
    {
        if (    pImgTask->_fWaitForFiber
            &&  !pImgTask->_fTerminate
            &&  !pImgTask->_pfi
            &&  (!fAll || pImgTask->IsFullyAvail()))
        {
            pfi->pImgTask = pImgTask;
            pImgTask->_pfi = pfi;
            pImgTask->_fWaitForFiber = FALSE;
            pImgTask->SubAddRef();
            pImgTask->SetBlocked(FALSE);
            goto Cleanup;
        }
    }

Cleanup:
    LeaveCriticalSection();    
}

void
CImgTaskExec::RunTask(CImgTask * pImgTask)
{
    FIBERINFO * pfi = pImgTask->_pfi;

    if (pfi == NULL && !pImgTask->_fTerminate)
    {
        pfi = GetFiber(pImgTask);

        if (pfi)
        {
            pfi->pImgTask = pImgTask;
            pImgTask->_pfi = pfi;
            pImgTask->_fWaitForFiber = FALSE;
            pImgTask->SubAddRef();
        }
        else
        {
            // No fiber available.  Note that when one becomes available
            // there may be a task waiting to hear about it.

            pImgTask->_fWaitForFiber = TRUE;
            pImgTask->SetBlocked(TRUE);
            goto Cleanup;
        }
    }

    if (pfi)
    {
        Assert(pfi->pImgTask == pImgTask);
        Assert(pImgTask->_pfi == pfi);

        SwitchesEndTimer(SWITCHES_TIMER_DECODEIMAGE);
        SuspendCAP();

        FbrSwitchToFiber(pfi->pvFiber);

        ResumeCAP();
        SwitchesBegTimer(SWITCHES_TIMER_DECODEIMAGE);

        if (pImgTask->_pfi == NULL)
        {
            pImgTask->SubRelease();
            AssignFiber(pfi);
        }
    }

    // If the image task is done (or forcibly termintate)
    // delete the task from the queue.  However, if the task
    // still has a fiber attached to it, wait to do this until
    // that fiber proc is done with the task.
    if (    pImgTask->_fTerminate
        &&  (   !pfi
             ||  pfi->pImgTask != pImgTask))
    {
        pImgTask->_pImgInfo->OnTaskDone(pImgTask);
        super::DelTask(pImgTask);
    }

Cleanup:
    return;
}

HRESULT
CImgTaskExec::ThreadInit()
{
    PerfDbgLog(tagImgTask, this, "+CImgTaskExec::ThreadInit");

    // Name this thread for IceCAP
    NameThread("ImgTask");

    HRESULT hr;

    hr = THR(super::ThreadInit());
    if (hr)
        goto Cleanup;

    if (FbrAttachToBase())
    {
        _pvFiberMain = FbrConvertThreadToFiber(0);
    }

Cleanup:
    PerfDbgLog(tagImgTask, this, "-CImgTaskExec::ThreadInit");
    RRETURN(hr);
}

void
CImgTaskExec::ThreadTerm()
{
    PerfDbgLog(tagImgTask, this, "+CImgTaskExec::ThreadTerm");

    FIBERINFO * pfi = _afi;
    UINT        cfi = ARRAY_SIZE(_afi);

    for (; cfi > 0; --cfi, ++pfi)
    {
        if (pfi->pImgTask)
        {
            pfi->pImgTask->_pfi = NULL;
            pfi->pImgTask->SubRelease();
            pfi->pImgTask = NULL;
        }
        if (pfi->pvFiber)
        {
            FbrDeleteFiber(pfi->pvFiber);
            pfi->pvFiber = NULL;
        }
    }

    // Manually release any tasks remaining on the queue.  Don't call super::ThreadTerm
    // because it tries to call Terminate() on the task and expects it to dequeue.  Our
    // tasks don't dequeue in Terminate() though, so we end up in an infinite loop.

    while (_pDwnTaskHead)
    {
        CImgTask * pImgTask = (CImgTask *)_pDwnTaskHead;
        _pDwnTaskHead = pImgTask->_pDwnTaskNext;
        Assert(pImgTask->_fEnqueued);
        pImgTask->SubRelease();
    }

    PerfDbgLog(tagImgTask, this, "-CImgTaskExec::ThreadTerm");
}

void
CImgTaskExec::ThreadExit()
{
    PerfDbgLog(tagImgTask, this, "CImgTaskExec::ThreadExit");

    void * pvMain = _pvFiberMain;

    if (_fCoInit)
    {
        CoUninitialize();
    }

    super::ThreadExit();

    if (pvMain)
    {
        if (!g_fWhistlerOS)
        {
            // Due to a bug in the Win95 and WinNT implementation of fibers,
            // we don't call FbrDeleteFiber(pvMain) anymore.  Instead we manually
            // free the fiber data for the main fiber on this thread.

            LocalFree(pvMain);
            FbrDetachFromBase();
        }
        else
        {
            // the bug mentioned above is fixed on Whistler
            FbrDeleteFiber(pvMain);
        }
    }
}

void
CImgTaskExec::ThreadTimeout()
{
    PerfDbgLog(tagImgTask, this, "+CImgTaskExec::ThreadTimeout");

    KillImgTaskExec();

    PerfDbgLog(tagImgTask, this, "-CDwnTaskExec::ThreadTimeout");
}

void WINAPI
CImgTaskExec::FiberProc(void * pv)
{
    FIBERINFO * pfi = (FIBERINFO *)pv;
    CImgTask * pImgTask = NULL;

    SwitchesBegTimer(SWITCHES_TIMER_DECODEIMAGE);
    StartCAP();

    while (pfi)
    {
        PerfDbgLog1(tagImgTask, pImgTask, "CImgTaskExec::FiberProc (fiber "
            "%ld attach)", pfi - g_pImgTaskExec->_afi);

        pImgTask = pfi->pImgTask;
        pImgTask->Exec();
        pfi->pImgTask = NULL;
        pImgTask->_pfi = NULL;

        PerfDbgLog1(tagImgTask, pImgTask, "CImgTaskExec::FiberProc (fiber "
            "%ld detach)", pfi - g_pImgTaskExec->_afi);

        SwitchesEndTimer(SWITCHES_TIMER_DECODEIMAGE);
        SuspendCAP();

        FbrSwitchToFiber(pfi->pvMain);

        ResumeCAP();
        SwitchesBegTimer(SWITCHES_TIMER_DECODEIMAGE);
    }

    StopCAP();
    SwitchesEndTimer(SWITCHES_TIMER_DECODEIMAGE);
}

HRESULT
CImgTaskExec::RequestCoInit()
{
    HRESULT hr = S_OK;

    if (!_fCoInit)
    {
        hr = CoInitialize(NULL);

        if (!FAILED(hr))
        {
            _fCoInit = TRUE;
            hr = S_OK;
        }
    }

    RRETURN(hr);
}

#if DBG==1

void
CImgTaskExec::Invariant()
{
    EnterCriticalSection();

    FIBERINFO * pfi = _afi;
    UINT        cfi = ARRAY_SIZE(_afi);
    CImgTask *  pImgTask;
    BOOL        fFound;

    super::Invariant();

    // Because the invariant is looking at the fiber list, this code can only be
    // run on the CImgTaskExec thread.

    if (_dwThreadId != GetCurrentThreadId())
        cfi = 0;

    for (; cfi > 0; --cfi, ++pfi)
    {
        Assert(!pfi->pImgTask || pfi->pImgTask->_pfi == pfi);

        fFound   = !pfi->pImgTask;
        pImgTask = fFound ? NULL : (CImgTask *)_pDwnTaskHead;

        for (; pImgTask; pImgTask = (CImgTask *)pImgTask->_pDwnTaskNext)
        {
            if (pImgTask == pfi->pImgTask)
            {
                fFound = TRUE;
                break;
            }
        }

        Assert(fFound);
    }

    LeaveCriticalSection();
}

#endif

// External Functions ---------------------------------------------------------

HRESULT
StartImgTask(CImgTask * pImgTask)
{
    PerfDbgLog1(tagImgTask, NULL, "+StartImgTask %lX", pImgTask);

    HRESULT hr = S_OK;

    g_csImgTaskExec.Enter();

    if (g_pImgTaskExec == NULL)
    {
        g_pImgTaskExec = new CImgTaskExec(g_csImgTaskExec.GetPcs());

        if (g_pImgTaskExec == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(g_pImgTaskExec->Launch());

        if (hr)
        {
            g_pImgTaskExec->Release();
            g_pImgTaskExec = NULL;
            goto Cleanup;
        }
    }

    g_pImgTaskExec->AddTask(pImgTask);

Cleanup:
    g_csImgTaskExec.Leave();
    PerfDbgLog(tagImgTask, NULL, "-StartImgTask");
    RRETURN(hr);
}

void
KillImgTaskExec()
{
    PerfDbgLog(tagImgTask, NULL, "+KillImgTaskExec");

    g_csImgTaskExec.Enter();

    CImgTaskExec * pImgTaskExec = g_pImgTaskExec;
    g_pImgTaskExec = NULL;

    g_csImgTaskExec.Leave();

    if (pImgTaskExec)
    {
        pImgTaskExec->Shutdown();
        pImgTaskExec->Release();
    }

    PerfDbgLog(tagImgTask, NULL, "-KillImgTaskExec");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\imgwmf.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       imgwmf.cxx
//
//  Contents:   Image filter for .wmf files
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IMG_HXX_
#define X_IMG_HXX_
#include "img.hxx"
#endif

#ifndef X_IMGBITS_HXX_
#define X_IMGBITS_HXX_
#include "imgbits.hxx"
#endif

MtDefine(CImgTaskWmf, Dwn, "CImgTaskWmf")
MtDefine(CImgTaskWmfBuf, CImgTaskWmf, "CImgTaskWmf Decode Buffer")

/* placeable metafile header */
#include "pshpack1.h"

#ifdef UNIX
inline WORD READWINTELWORD(BYTE* b)
{
    return ((*b) | ((WORD)*(b+1) << 8));
}

inline DWORD READWINTELDWORD(BYTE* p)
{
    return (READWINTELWORD(p+2) << 16 | READWINTELWORD(p));
}
#endif

typedef struct tagSRECT {
    short    left;
    short    top;
    short    right;
    short    bottom;
} SRECT;

typedef struct {
        DWORD   key;
        WORD    hmf;
        SRECT   bbox;
        WORD    inch;
        DWORD   reserved;
        WORD    checksum;
}ALDUSMFHEADER;
#include "poppack.h"

class CImgTaskWmf : public CImgTask
{

public:

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CImgTaskWmf))

    typedef CImgTask super;

    // CImgTask methods

    virtual void Decode(BOOL *pfNonProgressive);

    // CImgTaskWmf methods

    void ReadImage();

};

#ifdef UNIX
#define SIZEOF_METAHEADER (5*sizeof(WORD) + 2*sizeof(DWORD))
#endif

void CImgTaskWmf::ReadImage()
{
    METAHEADER mh;
    LPBYTE pbBuf = NULL;
    CImgBitsDIB *pibd = NULL;
    HDC hdcDst = NULL;
    HMETAFILE hmf = NULL;
    HBITMAP hbmSav = NULL;
    ULONG ulSize;
    HRESULT hr;
    RGBQUAD argb[256];

    // Get the metafile header so we know how big it is
#ifndef UNIX
    if (!Read((unsigned char *)&mh, sizeof(mh)))
        return;
#else
    METAHEADER mhTmp;
    if (!Read((unsigned char *)&mhTmp, SIZEOF_METAHEADER))
        return;

    BYTE * p = (BYTE*)&mhTmp;

    mh.mtType = READWINTELWORD(p );
    mh.mtHeaderSize = READWINTELWORD(p += sizeof(WORD));
    mh.mtVersion = READWINTELWORD( p += sizeof(WORD));
    mh.mtSize = READWINTELDWORD(p += sizeof(WORD));
    mh.mtNoObjects = READWINTELWORD( p += sizeof(DWORD));
    mh.mtMaxRecord = READWINTELDWORD(p += sizeof(WORD));
    mh.mtNoParameters = READWINTELWORD( p += sizeof(DWORD)); 
#endif

    // allocate a buffer to hold it
    ulSize = mh.mtSize * sizeof(WORD);

    //The header contains a size field for the entire file.  
    //If this size is less than the header length (which we've just
    //successfully read in), then the field is clearly bogus.
    //Catch this now.
#ifndef UNIX
    if (ulSize < sizeof(METAHEADER))
        return;
#else
    if (ulSize < SIZEOF_METAHEADER)
        return;
#endif

    pbBuf = (LPBYTE)MemAlloc(Mt(CImgTaskWmfBuf), ulSize);
    if (!pbBuf)
        return;

    // copy the header into the front of the buffer
#ifdef UNIX // Needs to use raw data
    memcpy(pbBuf, &mhTmp, SIZEOF_METAHEADER);
#else
    memcpy(pbBuf, &mh, sizeof(METAHEADER));
#endif
    
    // read the metafile into memory after the header
#ifndef UNIX
    if (!Read(pbBuf + sizeof(METAHEADER), 
            ulSize - sizeof(METAHEADER)))
#else
    if (!Read(pbBuf + SIZEOF_METAHEADER, 
            ulSize - SIZEOF_METAHEADER))
#endif
        goto Cleanup;

    // convert the buffer into a metafile handle
    hmf = SetMetaFileBitsEx(ulSize, pbBuf);
    if (!hmf)
        goto Cleanup;

    // Free the metafile buffer
    MemFree(pbBuf);
    pbBuf = NULL;

    // Use the halftone palette for the color table
    CopyColorsFromPaletteEntries(argb, g_lpHalftone.ape, 256);
    memcpy(_ape, g_lpHalftone.ape, sizeof(PALETTEENTRY) * 256);

    pibd = new CImgBitsDIB();
    if (!pibd)
        goto Cleanup;

    hr = pibd->AllocDIBSection(8, _xWid, _yHei, argb, 256, 255);
    if (hr)
        goto Cleanup;

    _lTrans = 255;

    TraceTag((tagImgTrans, "CImgTaskWmf %x  _lTrans = %d", this, _lTrans));

    Assert(pibd->GetBits() && pibd->GetHbm());

    memset(pibd->GetBits(), (BYTE)_lTrans, pibd->CbLine() * _yHei);

    // Render the metafile into the bitmap
    
    hdcDst = GetMemoryDC();
    if (!hdcDst)
        goto Cleanup;

    hbmSav = (HBITMAP)SelectObject(hdcDst, pibd->GetHbm());

    SaveDC(hdcDst);

    SetMapMode(hdcDst, MM_ANISOTROPIC);
    SetViewportExtEx(hdcDst, _xWid, _yHei, (SIZE *)NULL);
    PlayMetaFile(hdcDst, hmf);

    RestoreDC(hdcDst, -1);

    _pImgBits = pibd;
    pibd = NULL;
        
    _ySrcBot = -1;

Cleanup:
    if (hbmSav)
        SelectObject(hdcDst, hbmSav);
    if (hdcDst)
        ReleaseMemoryDC(hdcDst);
    if (pibd)
        delete pibd;
    if (hmf)
        DeleteMetaFile(hmf);
    if (pbBuf)
        MemFree(pbBuf);
        
    return;
}

void CImgTaskWmf::Decode(BOOL *pfNonProgressive)
{
    ALDUSMFHEADER amfh;

    *pfNonProgressive = TRUE;

    // KENSY: What do I do about the color table?
    // KENSY: scale according to DPI of screen
#ifndef UNIX
    if (!Read((unsigned char *)&amfh, sizeof(amfh)))
        goto Cleanup;
#else
    {
    ALDUSMFHEADER amfhTmp;
    
    if (!Read((unsigned char *)&amfhTmp, 3*sizeof(WORD)+2*sizeof(DWORD)+sizeof(SRECT)))
        goto Cleanup;

    BYTE *p = (BYTE*)&amfhTmp;

    amfh.key =            READWINTELDWORD(p);
    amfh.hmf =            READWINTELWORD(p += sizeof(DWORD));
    amfh.bbox.left =   READWINTELWORD(p += sizeof(WORD));
    amfh.bbox.top =    READWINTELWORD( p += sizeof(WORD));
    amfh.bbox.right =  READWINTELWORD( p += sizeof(WORD));
    amfh.bbox.bottom = READWINTELWORD( p += sizeof(WORD));
    amfh.inch =           READWINTELWORD( p += sizeof(WORD));
    amfh.reserved =    READWINTELDWORD( p += sizeof(WORD));
    amfh.checksum =    READWINTELWORD( p += sizeof(DWORD));
    }
#endif

    _xWid = abs(MulDiv(amfh.bbox.right - amfh.bbox.left, 96, amfh.inch));
    _yHei = abs(MulDiv(amfh.bbox.bottom - amfh.bbox.top, 96, amfh.inch));
    
    // Post WHKNOWN
    OnSize(_xWid, _yHei, -1);

    ReadImage();

Cleanup:
    return;
}

CImgTask * NewImgTaskWmf()
{
    return(new CImgTaskWmf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\spacectx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       textctx.cxx
//
//  Contents:   Various text parse contexts to deal with space-collapsing
//              and other issues
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTM_HXX_
#define X_HTM_HXX_
#include "htm.hxx"
#endif

MtDefine(CHtmCrlfParseCtx, CHtmParseCtx, "CHtmCrlfParseCtx")
MtDefine(CHtmCrlfParseCtx_AddText_pchTemp, CHtmCrlfParseCtx, "CHtmCrlfParseCtx::AddText/pchTemp")


//+---------------------------------------------------------------------------
//
//  Method:     CHtmCrlfParseCtx::AddText
//
//  Synposis:   Calls AddNonspaces and AddSpaces methods
//
//              Eliminates CRLFs from space runs (converting \n and
//              \r\n to \r) before calling AddSpaces and AddNonspaces
//
//----------------------------------------------------------------------------
            
HRESULT
CHtmCrlfParseCtx::AddText(CTreeNode *pNode, TCHAR *pchIn, ULONG cchIn, BOOL fAscii)
{
    HRESULT hr      = S_OK;
    TCHAR *pchLast  = pchIn + cchIn;
    TCHAR ach[64];
    TCHAR *pchTemp  = ach;
    ULONG  cchTemp  = ARRAY_SIZE(ach);
    TCHAR *pch;
    TCHAR *pchTo;
    ULONG cch;
    TCHAR *pchWord;
    ULONG cchWord;

    while (pchIn < pchLast)
    {
        // eat strings of spaces
        if (ISSPACE(*pchIn))
        {
            pchWord = pchIn++;

            while (pchIn < pchLast && ISSPACE(*pchIn))
                pchIn++;

            cchWord = pchIn - pchWord;
            cchIn -= cchWord;

            // step 1: scan to see if there are an \n at all

            for (pch = pchWord, cch = cchWord; cch; pch++, cch--)
                if (*pch == _T('\n'))
                    break;

            // step 2: if there are \n's, convert them appropriately

            if (!cch)
            {
                pchTo = pchWord;
                cch = cchWord;
            }
            else
            {
                // Allocate memory only if space string is longer than ach's size

                if (cchWord > cchTemp)
                {
                    if (pchTemp == ach)
                        pchTemp = NULL;

                    hr = MemRealloc(Mt(CHtmCrlfParseCtx_AddText_pchTemp), (void **)&pchTemp, cchWord * sizeof(TCHAR));
                    if (hr)
                        goto Cleanup;
                }

                // Skip over non \n chars, and \n if it is the first one and _fLastCr

                pchTo = pchTemp;

                if (pch > pchWord)
                {
                    memcpy(pchTemp, pchWord, (cchWord - cch) * sizeof(TCHAR));
                    pchTo += cchWord - cch;
                }
                else
                {
                    if (_fLastCr)
                    {
                        pch++;
                        cch--;
                    }
                }

                // Skip over any \n that follow \r, and convert other \n to \r

                for (; cch; cch--)
                {
                    if (*pch != _T('\n'))
                        *pchTo++ = *pch++;
                    else
                    {
                        if (*(pch-1) != _T('\r'))
                            *pchTo++ = _T('\r');

                        pch++;
                    }
                }

                cch = pchTo - pchTemp;
                pchTo = pchTemp;
            }

            if (cch)
            {
                // step 3: pass the string on
                hr = THR(AddSpaces(pNode, pchTo, cch));
                if (hr)
                    goto Cleanup;

            }

            _fLastCr = (pchWord[cchWord-1] == _T('\r'));
		}
        else
        {
            pchWord = pchIn++;

            for (;;)
            {
                while (pchIn < pchLast && ISNONSP(*pchIn))
                    pchIn++;

                if (pchIn+1 < pchLast && *pchIn == _T(' ') && ISNONSP(pchIn[1]))
                {
                    pchIn += 2;
                }
                else
                {
                    break;
                }
            }

            cchWord = pchIn - pchWord;
            cchIn -= cchWord;

            _fLastCr = FALSE;

            if (cchWord)
            {
                hr = THR(AddNonspaces(pNode, pchWord, cchWord, fAscii));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    if (pchTemp != ach)
        MemFree(pchTemp);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CHtmCrlfParseCtx::Finish
//
//  Synopsis:   Would be needed if we were converting \r's to \n's instead
//              of \n's to \r's. For the time being, it does nothing.
//
//----------------------------------------------------------------------------
HRESULT CHtmCrlfParseCtx::Finish()
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Class:      CHtmSpaceParseCtx
//
//  Synopsis:   1. Collapses multiple spaces down to one space
//              2. Can eat space to the left or to the right of "fill"
//                 markers, or transfer space from the left to the right
//                 of a fill marker.
//              3. Will eat single linefeeds between two adjacent chinese
//                 characters
//
//----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   HanguelRange
//
//  Synopsis:   Detects Korean Hangeul characters
//
//-----------------------------------------------------------------------------

static inline BOOL
HanguelRange ( TCHAR ch )
{
    return ch > 0x10ff &&
           (InRange(ch, 0x1100, 0x11f9) ||
            InRange(ch, 0x3130, 0x318f) ||
            InRange(ch, 0xac00, 0xd7a3) ||
            InRange(ch, 0xffa1, 0xffdc));
}

//+----------------------------------------------------------------------------
//
//  Function:   TwoFarEastNonHanguelChars
//
//  Synopsis:   Determines if a CR between two characters should be
//              ignored (e.g., so Chinese chars on separate lines
//              of HTML are adjacent).
//
//-----------------------------------------------------------------------------

static inline BOOL
TwoFarEastNonHanguelChars ( TCHAR chPrev, TCHAR chAfter )
{
    if (chPrev < 0x3000 || chAfter < 0x3000)
        return FALSE;

    return ! HanguelRange( chPrev ) && ! HanguelRange( chAfter );
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmSpaceParseCtx::Destructor
//
//  Synopsis:   Releases any unreleased pointers
//
//-----------------------------------------------------------------------------

CHtmSpaceParseCtx::~CHtmSpaceParseCtx()
{
#ifdef NOPARSEADDREF
    CTreeNode::ReleasePtr(_pNodeSpace);
#endif
}


//+----------------------------------------------------------------------------
//
//  Function:   CHtmSpaceParseCtx::AddNonspaces
//
//  Synopsis:   Adds any deferred space
//
//-----------------------------------------------------------------------------
HRESULT
CHtmSpaceParseCtx::AddNonspaces(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii)
{
    Assert(cch && *pch);
    Assert(!_fEatSpace || !_pNodeSpace);
    Assert(!_pNodeSpace || _pNodeSpace == pNode);
    Assert((DWORD_PTR)_pNodeSpace != 1);

    HRESULT hr;
    CTreeNode *pNodeSpace;

    // 1. If space is needed, add it now

    if (_pNodeSpace)
    {
        // reentrant code
        pNodeSpace = _pNodeSpace;
        _pNodeSpace = NULL;

        if (!_chLast || !_fOneLine || !TwoFarEastNonHanguelChars(_chLast, *pch))
        {
            hr = THR(AddSpace(pNodeSpace));
            if (hr)
                goto Cleanup;
        }

       
#ifdef NOPARSEADDREF
        pNodeSpace->NodeRelease();
#endif
    }

    // 2. Add words 

    hr = THR(AddWord(pNode, pch, cch, fAscii));
    if (hr)
        goto Cleanup;

    // 3. Stop eating space and note last (possibly chinese) char
    
    _fEatSpace = FALSE;
    _chLast = pch[cch - 1];
    _fOneLine = FALSE;

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmSpaceParseCtx::AddSpaces
//
//  Synopsis:   Makes a note of any space that may need to be inserted later
//
//-----------------------------------------------------------------------------
HRESULT
CHtmSpaceParseCtx::AddSpaces(CTreeNode *pNode, TCHAR *pch, ULONG cch)
{
    HRESULT hr = S_OK;
    
    Assert(cch && *pch); // more than zero spaces
    Assert(!_fEatSpace || !_pNodeSpace);
    Assert(!_pNodeSpace || _pNodeSpace == pNode);
    Assert((DWORD_PTR)_pNodeSpace != 1);

    // 1. Note space if we're not eating space

    if (!_fEatSpace && !_pNodeSpace)
    {
#ifdef NOPARSEADDREF
        pNode->NodeAddRef();
#endif
        _pNodeSpace = pNode;
    }

    // 2. If last char was nonspace (possibly chinese), note single line
    
    if (_chLast)
    {
        if (cch == 1 && *pch == _T('\r') && !_fOneLine)
            _fOneLine = TRUE;
        else
            _chLast = _T('\0');
    }

    // 3. If the markup supports collapsed whitespace, add to the whitespace buffer

    Assert(pNode && pNode->GetMarkup());

    if (pNode->GetMarkup()->SupportsCollapsedWhitespace())
    {
        hr = THR(AddCollapsedWhitespace(pNode, pch, cch));
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmSpaceParseCtx::LFill
//
//  Synopsis:   Flushes any deferred space
//
//-----------------------------------------------------------------------------
HRESULT
CHtmSpaceParseCtx::LFill(UINT fillcode)
{
    Assert(!_fEatSpace || !_pNodeSpace);
    Assert((DWORD_PTR)_pNodeSpace != 1);

    HRESULT hr = S_OK;
    
    // 1. Now last char was not chinese
    
    _chLast = _T('\0');

    // 2. Output, eat, or transfer space from the left

    if (_pNodeSpace)
    {
        if (fillcode == FILL_PUT)
        {
            hr = THR(AddSpace(_pNodeSpace));
            if (hr)
                goto Cleanup;

            _fEatSpace = TRUE;
        }        

#ifdef NOPARSEADDREF
        _pNodeSpace->NodeRelease();
#endif
        _pNodeSpace = NULL;

        if (fillcode == FILL_NUL)
            _pNodeSpace = (CTreeNode*)1L;

    }

  Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmSpaceParseCtx::RFill
//
//  Synopsis:   Sets up state for absorbing or accepting space
//
//-----------------------------------------------------------------------------
HRESULT
CHtmSpaceParseCtx::RFill(UINT fillcode, CTreeNode *pNode)
{
    Assert(!_fEatSpace || !_pNodeSpace);
    Assert(!_chLast);
    Assert(!_pNodeSpace || (DWORD_PTR)_pNodeSpace == 1);

    // 1. Reject space to the right if EAT

    if (fillcode == FILL_EAT)
    {
        _pNodeSpace = NULL;
        _fEatSpace = TRUE;
    }

    // 2. Accept space to the right if PUT

    if (fillcode == FILL_PUT)
    {
        _fEatSpace = FALSE;
    }
    
    // 3. Transfer any existing space

    if (_pNodeSpace)
    {
#ifdef NOPARSEADDREF
        pNode->NodeAddRef();
#endif
        _pNodeSpace = pNode;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jcomapi.c ===
/*
 * jcomapi.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface routines that are used for both
 * compression and decompression.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/*
 * Abort processing of a JPEG compression or decompression operation,
 * but don't destroy the object itself.
 *
 * For this, we merely clean up all the nonpermanent memory pools.
 * Note that temp files (virtual arrays) are not allowed to belong to
 * the permanent pool, so we will be able to close all temp files here.
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
  int pool;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
    (*cinfo->mem->free_pool) (cinfo, pool);
  }

  /* Reset overall state for possible reuse of object */
  cinfo->global_state = (cinfo->is_decompressor ? DSTATE_START : CSTATE_START);
}


/*
 * Destruction of a JPEG object.
 *
 * Everything gets deallocated except the master jpeg_compress_struct itself
 * and the error manager struct.  Both of these are supplied by the application
 * and must be freed, if necessary, by the application.  (Often they are on
 * the stack and so don't need to be freed anyway.)
 * Closing a data source or destination, if necessary, is the application's
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
    (*cinfo->mem->self_destruct) (cinfo);
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
  cinfo->global_state = 0;	/* mark it destroyed */
}


/*
 * Convenience routines for allocating quantization and Huffman tables.
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
  return tbl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jconfig.h ===
/*
 * jconfig.doc
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file documents the configuration options that are required to
 * customize the JPEG software for a particular system.
 *
 * The actual configuration options for a particular installation are stored
 * in jconfig.h.  On many machines, jconfig.h can be generated automatically
 * or copied from one of the "canned" jconfig files that we supply.  But if
 * you need to generate a jconfig.h file by hand, this file tells you how.
 *
 * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
 * EDIT A COPY NAMED JCONFIG.H.
 */


/*
 * These symbols indicate the properties of your machine or compiler.
 * #define the symbol if yes, #undef it if no.
 */
#define HAVE_BOOLEAN
typedef unsigned char boolean;

/* Does your compiler support function prototypes?
 * (If not, you also need to use ansi2knr, see install.doc)
 */
#define HAVE_PROTOTYPES

/* Does your compiler support the declaration "unsigned char" ?
 * How about "unsigned short" ?
 */
#define HAVE_UNSIGNED_CHAR
#define HAVE_UNSIGNED_SHORT

/* Define "void" as "char" if your compiler doesn't know about type void.
 * NOTE: be sure to define void such that "void *" represents the most general
 * pointer type, e.g., that returned by malloc().
 */
/* #define void char */

/* Define "const" as empty if your compiler doesn't know the "const" keyword.
 */
/* #define const */

/* Define this if an ordinary "char" type is unsigned.
 * If you're not sure, leaving it undefined will work at some cost in speed.
 * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
 */
#undef CHAR_IS_UNSIGNED

/* Define this if your system has an ANSI-conforming <stddef.h> file.
 */
#define HAVE_STDDEF_H

/* Define this if your system has an ANSI-conforming <stdlib.h> file.
 */
#define HAVE_STDLIB_H

/* Define this if your system does not have an ANSI/SysV <string.h>,
 * but does have a BSD-style <strings.h>.
 */
#undef NEED_BSD_STRINGS

/* Define this if your system does not provide typedef size_t in any of the
 * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
 * <sys/types.h> instead.
 */
#undef NEED_SYS_TYPES_H

/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
 * unless you are using a large-data memory model or 80386 flat-memory mode.
 * On less brain-damaged CPUs this symbol must not be defined.
 * (Defining this symbol causes large data structures to be referenced through
 * "far" pointers and to be allocated with a special version of malloc.)
 */
#undef NEED_FAR_POINTERS
#undef FAR
#define FAR

/* Define this if your linker needs global names to be unique in less
 * than the first 15 characters.
 */
#undef NEED_SHORT_EXTERNAL_NAMES

/* Although a real ANSI C compiler can deal perfectly well with pointers to
 * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
 * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
 * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
 * actually get "missing structure definition" warnings or errors while
 * compiling the JPEG code.
 */
#undef INCOMPLETE_TYPES_BROKEN

/*
 * The following options affect code selection within the JPEG library,
 * but they don't need to be visible to applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS has been defined.
 */
#ifdef JPEG_INTERNALS

/* Define this if your compiler implements ">>" on signed values as a logical
 * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
 * which is the normal and rational definition.
 */
#undef RIGHT_SHIFT_IS_UNSIGNED

/* Because sizeof(double) = 10 on 68K Mac						*/
/* see ALIGN_TYPE definitiion in jmemmgr.c for details.			*/
#if defined(MAC) && !defined(POWERPC)
#define ALIGN_TYPE long
#endif /* defined(MAC) && !defined(POWERPC) */

#endif /* JPEG_INTERNALS */

/*
 * The remaining options do not affect the JPEG library proper,
 * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).
 * Other applications can ignore these.
 */
#ifdef JPEG_CJPEG_DJPEG

/* These defines indicate which image (non-JPEG) file formats are allowed. */

#define BMP_SUPPORTED		/* BMP image file format */
#define GIF_SUPPORTED		/* GIF image file format */
#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
#undef RLE_SUPPORTED		/* Utah RLE image file format */
#define TARGA_SUPPORTED		/* Targa image file format */

/* Define this if you want to name both input and output files on the command
 * line, rather than using stdout and optionally stdin.  You MUST do this if
 * your system can't cope with binary I/O to stdin/stdout.  See comments at
 * head of cjpeg.c or djpeg.c.
 */
#undef TWO_FILE_COMMANDLINE

/* Define this if your system needs explicit cleanup of temporary files.
 * This is crucial under MS-DOS, where the temporary "files" may be areas
 * of extended memory; on most other systems it's not as important.
 */
#undef NEED_SIGNAL_CATCHER

/* By default, we open image files with fopen(...,"rb") or fopen(...,"wb").
 * This is necessary on systems that distinguish text files from binary files,
 * and is harmless on most systems that don't.  If you have one of the rare
 * systems that complains about the "b" spec, define this symbol.
 */
#undef DONT_USE_B_MODE

/* Define this if you want percent-done progress reports from cjpeg/djpeg.
 */
#undef PROGRESS_REPORT

#endif /* JPEG_CJPEG_DJPEG */

#define SHORTxSHORT_32
#define INLINE  __inline

#define USE_SETMODE		    /* Microsoft has setmode() */
#define _NTSDK              /* Non-ANSI names for compatibility */
#define J_SIZEOF(x) SIZEOF(x)
#define NO_GETENV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\rootctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       rootctx.cxx
//
//  Contents:   CHtmRootParseCtx adds text and nodes to the tree on
//              behalf of the parser.
//
//              CHtmTopParseCtx is also defined here.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTM_HXX_
#define X_HTM_HXX_
#include "htm.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_ROOTCTX_HXX_
#define X_ROOTCTX_HXX_
#include "rootctx.hxx"
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

ExternTag(tagParse);

DeclareTag(tagRootParseCtx,     "Tree",     "Trace RootParseCtx");

MtDefine(CHtmRootParseCtx, CHtmParseCtx, "CHtmRootParseCtx");
MtDefine(CHtmTopParseCtx, CHtmParseCtx, "CHtmTopParseCtx");

MtDefine(RootParseCtx, Metrics, "Tree Building");
MtDefine(ParseTextNotifications, RootParseCtx, "Text Notifications sent");
MtDefine(ParseElementNotifications, RootParseCtx, "Element Notifications sent");
MtDefine(ParseNailDownChain, RootParseCtx, "Chain nailed down");
MtDefine(ParseInclusions, RootParseCtx, "Inclusions built");
MtDefine(ParsePrepare, RootParseCtx, "Prepare called");
MtDefine(CollapsedWhitespace, RootParseCtx, "Collapsed whitespace buffer");



extern const ELEMENT_TAG s_atagNull[];

//+------------------------------------------------------------------------
//
//  CHtmRootParseCtx
//
//  The root parse context.
//
//  The root parse context is responsible for:
//
//  1. Creating nodes for elements
//  2. Putting nodes and text into the tree verbatim
//  3. Ending elements, creating "proxy" nodes as needed
//
//-------------------------------------------------------------------------

const ELEMENT_TAG s_atagRootReject[] = {ETAG_NULL};

//+----------------------------------------------------------------------------
//
//  Members:    Factory, constructor, destructor
//
//  Synopsis:   hold on to root site
//
//-----------------------------------------------------------------------------
HRESULT
CreateHtmRootParseCtx(CHtmParseCtx **pphpx, CMarkup *pMarkup)
{
    *pphpx = new CHtmRootParseCtx(pMarkup);
    if (!*pphpx)
        RRETURN(E_OUTOFMEMORY);

    return S_OK;
}

CHtmRootParseCtx::CHtmRootParseCtx(CMarkup *pMarkup)
  : CHtmParseCtx(0.0)
{
    pMarkup->AddRef();
    _pMarkup       = pMarkup;
    _pDoc          = pMarkup->Doc();
    _atagReject    = s_atagNull;
}

CHtmRootParseCtx::~CHtmRootParseCtx()
{
    // Defensive deletion and release of all pointers
    // should already be null except in out of memory or other catastophic error
    // This can happen also if the parser recieves a STOP
    
    if (!_fFinished)
    {
        _pMarkup->CompactStory();

        Assert(_pMarkup->IsStreaming());
        _pMarkup->SetRootParseCtx( NULL );

        _pMarkup->_fNoUndoInfo = FALSE;
    }

    if (_ptpSpaceCache)
    {
        delete [] _ptpSpaceCache->GetCollapsedWhitespace();
        MemFree(_ptpSpaceCache);
    }

    _pMarkup->Release();
}

CHtmParseCtx *
CHtmRootParseCtx::GetHpxEmbed()
{
    return this;
}

BOOL
CHtmRootParseCtx::SetGapToFrontier( CTreePosGap * ptpg )
{
    if( _ptpAfterFrontier )
    {
        IGNORE_HR( ptpg->MoveTo( _ptpAfterFrontier, TPG_RIGHT ) );
        return TRUE;
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Members:    Prepare, Commit, Finish
//
//-----------------------------------------------------------------------------

HRESULT
CHtmRootParseCtx::Init()
{
    HRESULT hr = S_OK;
    
    Assert(!_pMarkup->IsStreaming());
    _pMarkup->SetRootParseCtx( this );

    _sidLast = sidAsciiLatin;

    Assert( ! _pMarkup->_fNoUndoInfo );
    _pMarkup->_fNoUndoInfo = TRUE;

    // Set up the dummy text node in my insertion chain
    _tdpTextDummy.SetType( CTreePos::Text );
    _tdpTextDummy.SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD | CTreePos::TPF_DATA_POS );
    WHEN_DBG( _tdpTextDummy._pOwner = _pMarkup; );

    _ptpChainTail = & _tdpTextDummy;
    _ptpChainCurr = & _tdpTextDummy;

    RRETURN(hr);
}


HRESULT
CHtmRootParseCtx::Prepare()
{
    HRESULT hr = S_OK;

    _fLazyPrepareNeeded = TRUE;

    MtAdd(Mt(ParsePrepare), 1, 0);
    
    RRETURN(hr);
}

HRESULT
CHtmRootParseCtx::Commit()
{
    HRESULT         hr;

    hr = THR(FlushNotifications());

    AssertSz( _pMarkup->IsNodeValid(), "Markup not valid after root parse ctx, talk to JBeda");

    RRETURN(hr);
}

HRESULT
CHtmRootParseCtx::Finish()
{
    HRESULT hr = S_OK;
        

    // Step 1: Commit
    
    hr = THR(Commit());
    if (hr)
        goto Cleanup;

    // Step 2: Update the markup
    _pMarkup->CompactStory();

    Assert(_pMarkup->IsStreaming());
    _pMarkup->SetRootParseCtx( NULL );

    Assert( _pMarkup->_fNoUndoInfo );
    _pMarkup->_fNoUndoInfo = FALSE;

    _fFinished = TRUE;

Cleanup:
    RRETURN(hr);
}

HRESULT
CHtmRootParseCtx::InsertLPointer ( CTreePos * * pptp, CTreeNode * pNodeCur)
{
    RRETURN(InsertPointer(pptp, pNodeCur, TRUE));
}

HRESULT
CHtmRootParseCtx::InsertRPointer ( CTreePos * * pptp, CTreeNode * pNodeCur)
{
    RRETURN(InsertPointer(pptp, pNodeCur, TRUE));
}

HRESULT
CHtmRootParseCtx::InsertPointer ( CTreePos * * pptp, CTreeNode * pNodeCur, BOOL fRightGravity )
{
    HRESULT hr = S_OK;

    Assert( pptp );

    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNodeCur );
        if (hr)
            goto Cleanup;
    }
    VALIDATE( pNodeCur );

    // Quick and dirty way to get a pos into the tree
    NailDownChain();

    *pptp = _pMarkup->NewPointerPos( NULL, fRightGravity, FALSE );
    if( ! *pptp )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( _pMarkup->Insert( *pptp, _ptpAfterFrontier, TRUE ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

HRESULT
CHtmRootParseCtx::InsertTextFrag ( TCHAR * pch, ULONG cch, CTreeNode * pNodeCur )
{
    HRESULT     hr = S_OK;
    CTreePos *  ptpTextFrag = NULL;
    CMarkupTextFragContext * ptfc;

    Assert( pch && cch );

    if (!_pMarkup->_fDesignMode)
        goto Cleanup;

    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNodeCur );
        if (hr)
            goto Cleanup;
    }
    VALIDATE( pNodeCur );

    // Insert the text frag into the list
    ptfc = _pMarkup->EnsureTextFragContext();
    if( !ptfc )
        goto OutOfMemory;

    hr = THR( InsertPointer( &ptpTextFrag , pNodeCur, FALSE ) );
    if (hr) 
        goto Cleanup;
    
#if DBG==1
    if( ptfc->_aryMarkupTextFrag.Size() )
    {
        CTreePos * ptpLast = ptfc->_aryMarkupTextFrag[ptfc->_aryMarkupTextFrag.Size()-1]._ptpTextFrag;
        Assert( ptpLast );
        Assert( ptpLast->InternalCompare( ptpTextFrag ) == -1 );
    }
#endif

    hr = THR( ptfc->AddTextFrag( ptpTextFrag, pch, cch, ptfc->_aryMarkupTextFrag.Size() ) );
    if (hr)
    {
        IGNORE_HR( _pMarkup->Remove( ptpTextFrag ) );
        goto Cleanup;
    }

    WHEN_DBG( ptfc->TextFragAssertOrder() );

Cleanup:

    RRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  CHtmRootParseCtx::BeginElement
//
//  1. Create the new node
//  2. Add it to the tree
//  3. Call hack code
//
//-------------------------------------------------------------------------
HRESULT
CHtmRootParseCtx::BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty)
{
    HRESULT         hr = S_OK;
    CTreeNode *     pNode;

    TraceTagEx((tagRootParseCtx, TAG_NONAME,
        "RootParse      : BeginElement %S.E%d",
        pel->TagName(), pel->SN()));

    // Step 1: set our insertion point if needed
    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNodeCur );
        if (hr)
            goto Cleanup;
    }
    VALIDATE( pNodeCur );
   
    // Step 2: create the node

    pNode = *ppNodeNew = new CTreeNode(pNodeCur, pel);
    if (!*ppNodeNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#if NOPARSEADDREF
    // Addref for the parser -- get rid of this!
    (*ppNodeNew)->NodeAddRef();
#endif

     pel->__pNodeFirstBranch = pNode;

    {
        CTreePos *  ptpBegin, * ptpEnd;
        CTreePos *  ptpAfterCurr = _ptpChainCurr->Next();

        //
        // Step 3: append the node into the pending chain
        //

        // Initialize/create the tree poses
        Assert( pNode->GetBeginPos()->IsUninit() );
        ptpBegin = pNode->InitBeginPos( TRUE );
        Assert( ptpBegin );

        Assert( pNode->GetEndPos()->IsUninit() );
        ptpEnd = pNode->InitEndPos( TRUE );
        Assert( ptpEnd );

        // Add them to the chain
        ptpBegin->SetFirstChild( _ptpChainCurr );
        ptpBegin->SetNext( ptpEnd );
        ptpBegin->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        ptpBegin->SetLeftThread( _ptpChainCurr );
        ptpBegin->SetRightThread( ptpEnd );
#endif

        ptpEnd->SetFirstChild( ptpBegin );
        ptpEnd->SetNext( ptpAfterCurr );
        ptpEnd->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        ptpEnd->SetLeftThread( ptpBegin );
        ptpEnd->SetRightThread( ptpAfterCurr );
#endif
        _ptpChainCurr->SetNext( ptpBegin );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        _ptpChainCurr->SetRightThread( ptpBegin );
#endif
        Assert( _ptpChainCurr->IsLeftChild() );
        Assert( _ptpChainCurr->IsLastChild() );

        if( ptpAfterCurr )
        {
            ptpAfterCurr->SetFirstChild( ptpEnd );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
            ptpAfterCurr->SetLeftThread( ptpEnd );
#endif
            Assert( ptpAfterCurr->IsLeftChild() );
            Assert( ptpAfterCurr->IsLastChild() );
        }
        else
            _ptpChainTail = ptpEnd;

        // CONSIDER: update the counts on the
        // insertion list as we add these.

        // The node is now "in" the tree so
        // addref it for the tree
        pNode->PrivateEnterTree();


        // Step 4: remember info for notifications
        if (!_pNodeForNotify)
            _pNodeForNotify = pNodeCur;
        _nElementsAdded++;
        if( !_ptpElementAdded )
            _ptpElementAdded = ptpBegin;

        // "Add" the characters
        _cchNodeBefore++;
        _cchNodeAfter++;
        AddCharsToNotification( _cpChainCurr, 2 );

        pel->SetMarkupPtr( _pMarkup);
        pel->PrivateEnterTree();

        // Step 5: Advance the frontier
        _ptpChainCurr = ptpBegin;
        _pNodeChainCurr = pNode;
        _cpChainCurr++;
    }


    // Step 6: compatibility hacks
    hr = THR(HookBeginElement(pNode));
    if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  CHtmRootParseCtx::EndElement
//
//  1. Call hack code
//  2. Create proxy nodes and add them all to the tree if needed
//  3. Compute and return new current node
//
//-------------------------------------------------------------------------
HRESULT
CHtmRootParseCtx::EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd)
{
    HRESULT hr = S_OK;
    CElement * pElementEnd = pNodeEnd->Element();
    BOOL    fFlushNotification = FALSE;

    TraceTagEx((tagRootParseCtx, TAG_NONAME,
        "RootParse      : EndElement %S.E%d",
        pNodeEnd->Element()->TagName(), pNodeEnd->Element()->SN()));

    // Make sure the node ending passed in is actually in 
    // the pNodeCur's branch
    Assert( pNodeCur->SearchBranchToRootForNode( pNodeEnd ) );

    // Step 1: set our insertion point if needed
    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNodeCur );
        if (hr)
            goto Cleanup;
    }
    VALIDATE( pNodeCur );
       
    // Step 2: compatibility hacks - this is kind of
    // a nasty place to put this, but we need to make
    // sure that the element is in the tree before
    // we do the hacks.

    hr = THR(HookEndElement(pNodeEnd, pNodeCur));
    if (hr)
        goto Cleanup;

    if (!_pNodeForNotify)
    {
        _pNodeForNotify = pNodeCur;
    }

    // Step 3: decide if we are going to flush a notification
    // because the element is ending
    {
        // This asserts that elements that we have just put in
        // the tree (below the notification) don't want text
        // change notifications.
        Assert(     ! pElementEnd->WantTextChangeNotifications()
                ||  ! _fTextPendingValid
                ||  _nfTextPending.Node()->SearchBranchToRootForScope( pElementEnd ) );

        if(   pElementEnd->WantTextChangeNotifications()
           || pElementEnd->WantEndParseNotification() )
        {
            fFlushNotification = TRUE;
        }
    }

    // step 4: optimization: bottom node is ending

    if (pNodeEnd == pNodeCur)
    {
        *ppNodeNew = pNodeEnd->Parent();

        if( *ppNodeNew )
        {
#ifdef NOPARSEADDREF
            (*ppNodeNew)->NodeAddRef();
#endif

            // If we are at the end of the chain, nail
            // down the chain and advance the real frontier
            if( _ptpChainCurr == _ptpChainTail )
            {
                WHEN_DBG( CTreePos * ptpContent );

                NailDownChain();

                WHEN_DBG( ptpContent = ) AdvanceFrontier();

                Assert(     ptpContent->IsEndNode()
                       &&   ptpContent->Branch() == pNodeEnd );

            }
            // otherwise, advance within the chain
            else
            {
                _ptpChainCurr = _ptpChainCurr->Next();

                Assert(     _ptpChainCurr
                       &&   _ptpChainCurr->IsEndNode()
                       &&   _ptpChainCurr->Branch() == pNodeEnd );

                Assert( _cchNodeAfter );
            }

            _cpChainCurr++;
            _pNodeChainCurr = *ppNodeNew;

            // If we have WCH_NODE chars pending after the current cp
            // move them behind the current cp.  If this isn't the case,
            // we just advance the cp and assume the character we are moving
            // over is a WCH_NODE
            if( _cchNodeAfter)
            {
                _cchNodeAfter--;
                _cchNodeBefore++;
            }
#if DBG==1
            else
                Assert( CTxtPtr( _pMarkup, _cpChainCurr - 1 ).GetChar() == WCH_NODE );
#endif
        }
        else
        {
            Assert( pNodeEnd->Tag() == ETAG_ROOT );
            goto Cleanup;
        }
    }

    // step 5: create an inclusion and move the end pos
    // for pNodeEnd into it.  Get the new node for ppNodeNew

    else
    {
        hr = THR( OverlappedEndElement( ppNodeNew, pNodeCur, pNodeEnd, fFlushNotification ) );
        if (hr)
            goto Cleanup;
    }

    // step 6: Push off the notificication or update it if necessary

    {
        if( fFlushNotification && _fTextPendingValid )
        {
            FlushTextNotification();
        }

        // If we didn't send the notification above and we
        // think we want to send it to the element that is ending
        // we should send it to that element's parent instead
        if(     _fTextPendingValid
           &&   _nfTextPending.Node()->Element() == pElementEnd )
        {
            _nfTextPending.SetNode( pNodeEnd->Parent() );
        }
        else if( _pNodeForNotify && _pNodeForNotify->Element() == pElementEnd )
        {
            _pNodeForNotify = pNodeEnd->Parent();
            Assert( _pNodeForNotify );
        }
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     OverlappedEndElement
//
//  Synopsis:   Handles the complex case of overlapping end elements
//
//-----------------------------------------------------------------------------
HRESULT 
CHtmRootParseCtx::OverlappedEndElement( CTreeNode **ppNodeNew, CTreeNode* pNodeCur, CTreeNode *pNodeEnd, BOOL fFlushNotification )
{
    HRESULT         hr = S_OK;
    CTreeNode *     pNodeReparent;
    CTreePos *      ptpWalkLeft;
    long            iLeft;
    long            cIncl = 0;
    CTreeNode *     pNodeNotifyRight;

    // The basic idea here is that we want to create an inclusion
    // for the element while sending the right notifications.  I'm going to
    // use the fact that there can be no real content after the frontier
    // besides end edges.  If we encounter pointers here, we will move
    // them.

    hr = THR( NailDownChain() );
    if (hr)
        goto Cleanup;

    Assert( _cchNodeBefore == 0 );

    // Walk up the tree to count the size of the inclusion.  Change
    // the end edges to non edges to form the left side of the inclusion
    {
        CTreeNode * pNodeWalk;

        for( pNodeWalk = pNodeCur; pNodeWalk != pNodeEnd; pNodeWalk = pNodeWalk->Parent() )
        {
            CTreePos * ptpEnd = pNodeWalk->GetEndPos();

            // This will handle cleaning up character counts
            ptpEnd->MakeNonEdge();

            cIncl++;
        }
    }

    // Make sure that _pNdoeForNotify is in sync with the notification
    if( _fTextPendingValid )
        _pNodeForNotify = _nfTextPending.Node();

    // Create nodes on the right side of the inclusion.  Move any pointers
    // that may be inside of the inclusion to the appropriate places on the right
    pNodeReparent       = pNodeEnd->Parent();
    ptpWalkLeft         = pNodeEnd->GetEndPos()->PreviousTreePos();
    pNodeNotifyRight    = _pNodeForNotify;

    // We have an empty chain and we want to put it after the node ending
    _ptpAfterFrontier   = pNodeEnd->GetEndPos()->NextTreePos();

    for( iLeft = cIncl; iLeft > 0; iLeft-- )
    {
        CElement *  pElementCur;
        CTreeNode * pNodeNew;
        CTreePos *  ptpBegin;
        CTreePos *  ptpEnd;
        CTreePos *  ptpAfterCurr = _ptpChainCurr->Next();

        // Pointers need to be removed from the original position and put in the chain.
        while( ptpWalkLeft->IsPointer() )
        {
            // Pull the pointer out
            CTreePos * ptpCurr = ptpWalkLeft;
            ptpWalkLeft = ptpWalkLeft->PreviousTreePos();
            ptpCurr->Remove();

            // Prep it for the chain
            ptpCurr->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );

            // And add it into the chain    
            ptpCurr->SetFirstChild( _ptpChainCurr );
            ptpCurr->SetNext( ptpAfterCurr );

#if defined(MAINTAIN_SPLAYTREE_THREADS)
            // Set all our threads
            ptpCurr->SetLeftThread( _ptpChainCurr );
            ptpCurr->SetRightThread( ptpAfterCurr );
            _ptpChainCurr->SetRightThread( ptpCurr );
#endif

            _ptpChainCurr->SetNext( ptpCurr );
            if( ptpAfterCurr )
            {
                ptpAfterCurr->SetFirstChild( ptpCurr );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                ptpAfterCurr->SetLeftThread( ptpCurr );
#endif
            }
            else
                _ptpChainTail = ptpCurr;   

            // Pointers sort of push out onto the chain to preserve ordering
            ptpAfterCurr = ptpCurr;
        }

        // Now, we'd better be a non-edge node
        Assert( ptpWalkLeft->IsEndNode() && ! ptpWalkLeft->IsEdgeScope() );

        pElementCur = ptpWalkLeft->Branch()->Element();

        pNodeNew = new CTreeNode( pNodeReparent, pElementCur );
        if( !pNodeNew )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // initialize the begin and end pos's
        ptpBegin = pNodeNew->InitBeginPos( FALSE );
        ptpBegin->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );

        ptpEnd = pNodeNew->InitEndPos( TRUE );
        ptpEnd->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );

        // Link them together
        ptpBegin->SetFirstChild( _ptpChainCurr );
        ptpBegin->SetNext( ptpEnd );

        ptpEnd->SetFirstChild( ptpBegin );
        ptpEnd->SetNext( ptpAfterCurr );

        // Link them into the chain
        _ptpChainCurr->SetNext( ptpBegin );

#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // Set all our threads
        ptpBegin->SetLeftThread( _ptpChainCurr );
        ptpBegin->SetRightThread( ptpEnd );
        ptpEnd->SetLeftThread( ptpBegin );
        ptpEnd->SetRightThread( ptpAfterCurr );
        _ptpChainCurr->SetRightThread( ptpBegin );
#endif

        // Link up the rest of the chain
        if( ptpAfterCurr )
        {
            ptpAfterCurr->SetFirstChild( ptpEnd );

#if defined(MAINTAIN_SPLAYTREE_THREADS)
            ptpAfterCurr->SetLeftThread( ptpEnd );
#endif
        }
        else
            _ptpChainTail = ptpEnd;    

        // tell the node it is in the tree
        pNodeNew->PrivateEnterTree();

        if( _pNodeForNotify == ptpWalkLeft->Branch() )
            pNodeNotifyRight = pNodeNew;

        _ptpChainCurr = ptpBegin;

        // set up for next time
        pNodeReparent = pNodeNew;
        ptpWalkLeft = ptpWalkLeft->PreviousTreePos();
    }

    // Adjust for all the work we just did.
    _cpChainCurr += 1;    // Just jump the kernel
    _pNodeChainCurr = pNodeReparent;

    // That's the sound of the man working on the chain gang...
    hr = THR( NailDownChain() );
    if( hr )
        goto Cleanup; 

    if( _pNodeForNotify == pNodeEnd )
        pNodeNotifyRight = pNodeEnd->Parent();

    *ppNodeNew = pNodeReparent;

    // There is really no efficient way to do notifications here unless
    // we lie a little bit.  So that is what we are going to do.

    // Take our canonical example of overlapping:
    // <P><B><U><I></B></I></U></P>.  
    // Before we see the </B>, everything looks normal.  
    // Then when we created the inclusion, we turned things
    // into this:
    // <P><B><U><I>{/I}{/U}</B>{U}{I}</I></U></P>.
    //
    // Since non-edge node chars don't have any characters in the
    // text stream, this is what each element should see:
    // <I> - The Italic should see that it now has 3 characters - it's
    //       begin and end chars, plus the char for the end of the Bold
    //       This is a net GAIN of one for the Italic
    // <I> - The Underline should see that it now has 5 characters - it's
    //       begin and end plus the Italic's begin and end, plus the
    //       end of the Bold.
    //       This is also a net GAIN of one for the Underline
    // <B> - The Bold should now see that it has lost 2 characters, since
    //       the ends of the Italic and Underline that it contains were
    //       converted to non-edge pos's.  So the Bold is down to 
    //       containing 4 characters, where it used to have 6.  
    //       This is a net LOSS equal to the size of the inclusion generated.
    // <P> - As far as the Paragraph is concerned, nothing has changed.
    //       Everything is still completely contained inside the paragraph, so
    //       This is a net change of ZERO for the paragraph.

    // To make sure everyone sees the proper changes, and that it all adds up
    // to a change of ZERO for the paragraph, here is what we're going to do:
    //
    // 1) Tell the Bold that it lost cIncl chars, to account for turning things
    // into non-edge pos's.  This propagates up to the Paragraph, leaving him
    // down by cIncl chars.
    //
    // 2) Tell the right-hand node at the bottom of the inclusion that he's gained
    // one char, to account for the end of the Bold being inside him now.  This
    // change propagates up the parent chain EXCLUDING the Bold, so everyone is
    // now happy, except for the Paragraph, who is down cIncl - 1 chars.
    //
    // 3) Now tell the paragraph that he's gained cIncl - 1 chars to fix up his
    // counts as well as those above him.

    // We can't do any nifty tricks with merging notifications anymore.
    {
        WHEN_DBG( _nfTextPending._fNoTextValidate = TRUE );
        FlushTextNotification();
        WHEN_DBG( _nfTextPending._fNoTextValidate = FALSE );

        // Remove cIncl characters from the node we're ending
        {
            CNotification nfRemove;

            nfRemove.CharsDeleted( _cpChainCurr - 1, cIncl, pNodeEnd );

            nfRemove.SetFlag(NFLAGS_PARSER_TEXTCHANGE);

            WHEN_DBG( nfRemove._fNoTextValidate = TRUE );
           _pMarkup->Notify( nfRemove );

            MtAdd(Mt(ParseTextNotifications), 1, 0);
        }

        // Add one character to the bottom of the inclusion
        {
            CNotification nfAdd;

            nfAdd.CharsAdded( _cpChainCurr, 1, pNodeReparent );

            nfAdd.SetFlag(NFLAGS_PARSER_TEXTCHANGE);

            WHEN_DBG( nfAdd._fNoTextValidate = TRUE );
            _pMarkup->Notify( nfAdd );

            MtAdd(Mt(ParseTextNotifications), 1, 0);
        }

        if( _pNodeForNotify == pNodeEnd->Parent() )
        {
            // If the ending node's parent was the one to notify, just add to pending
            AddCharsToNotification( _cpChainCurr, cIncl - 1 );
        }
        else
        {
            // Otherwise, we have to notify him explicitly
            CNotification nfAdd;

            nfAdd.CharsAdded( _cpChainCurr, cIncl - 1, pNodeEnd->Parent() );

            nfAdd.SetFlag(NFLAGS_PARSER_TEXTCHANGE);

            WHEN_DBG( nfAdd._fNoTextValidate = TRUE );
            _pMarkup->Notify( nfAdd );

            MtAdd(Mt(ParseTextNotifications), 1, 0);

            _pNodeForNotify = pNodeNotifyRight;
        }
    }

    MtAdd(Mt(ParseInclusions), 1, 0);

Cleanup:
    RRETURN( hr );
}

HRESULT
CHtmRootParseCtx::AddCollapsedWhitespace(CTreeNode *pNode, TCHAR *pch, ULONG cch)
{
    HRESULT hr = S_OK;    
    TCHAR *pchWhitespace;

    Assert(pch && cch);

    // Step 1: set our insertion point if needed

    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNode );
        if (hr)
            goto Cleanup;
    }

    // Step 2: Put down any pending WCH_NODE characters

    if( _cchNodeBefore )
    {
        ULONG    cpInsert = _cpChainCurr - _cchNodeBefore;

        Verify( CTxtPtr( _pMarkup, cpInsert ).
                    InsertRepeatingChar( _cchNodeBefore, WCH_NODE ) == _cchNodeBefore );
        _cchNodeBefore = 0;
    }
    
    // Step 3: Attach whitespace 

    if (_ptpChainCurr->HasCollapsedWhitespace())
    {
        // Step 4: Append whitespace to existing collapsed whitespace pointer
    
        TCHAR   *pchCurrentWhitespace = _ptpChainCurr->GetCollapsedWhitespace();
        long    cchCurrentWhitespace = _tcslen(pchCurrentWhitespace); 

        Assert(pchCurrentWhitespace && cchCurrentWhitespace);

        pchWhitespace = new(Mt(CollapsedWhitespace)) TCHAR[cchCurrentWhitespace + cch + 1];
        if (!pchWhitespace)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memcpy(pchWhitespace, pchCurrentWhitespace, cchCurrentWhitespace*sizeof(TCHAR));
        memcpy(pchWhitespace + cchCurrentWhitespace, pch, cch*sizeof(TCHAR));
        pchWhitespace[cch + cchCurrentWhitespace] = '\0';

        _ptpChainCurr->SetCollapsedWhitespace(pchWhitespace);
        delete [] pchCurrentWhitespace;
    }
    else
    {
        // Step 4: Insert pointer pos in chain

        CTreePos *ptp;

        if (_ptpSpaceCache && cch == 1 && *pch == ' ')
        {
            ptp = _ptpSpaceCache;
            _ptpSpaceCache = NULL;
        }
        else
        {
            ptp = _pMarkup->NewPointerPos(NULL, FALSE, TRUE, TRUE /* fCollapsedWhitespace */);
            if (!ptp)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pchWhitespace = new(Mt(CollapsedWhitespace)) TCHAR[cch+1];
            if (!pchWhitespace)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            memcpy(pchWhitespace, pch, cch*sizeof(TCHAR));
            pchWhitespace[cch] = '\0';

            ptp->SetCollapsedWhitespace(pchWhitespace);   
        }
    
        ptp->SetWhitespaceParent(pNode);

        InsertTreePosInChain(_ptpChainCurr, ptp);
        _ptpChainCurr = ptp;
    }

    
Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     AddText
//
//  Synopsis:   Inserts text directly into the tree
//
//-----------------------------------------------------------------------------

HRESULT
CHtmRootParseCtx::AddText(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii)
{
    HRESULT         hr = S_OK;

    // No more null runs
    Assert( cch != 0 );

    TraceTagEx((tagRootParseCtx, TAG_NONAME,
        "RootParse      : AddText cch=%d",
        cch));

    // Step 1: set our insertion point if needed
    if (_fLazyPrepareNeeded)
    {
        hr = LazyPrepare( pNode );
        if (hr)
            goto Cleanup;
    }
    VALIDATE( pNode );

    if (! _pNodeForNotify)
    {
        _pNodeForNotify = pNode;
    }

    // Step 2: Put down any pending WCH_NODE characters

    if( _cchNodeBefore )
    {
        ULONG    cpInsert = _cpChainCurr - _cchNodeBefore;

        Verify( CTxtPtr( _pMarkup, cpInsert ).
                    InsertRepeatingChar( _cchNodeBefore, WCH_NODE ) == _cchNodeBefore );
        _cchNodeBefore = 0;
    }

    // Step 3: If we're the first space after collapsed whitespace, then
    // we're a generated space and we should cling the collapsed whitespace
    // to this space.

    if (*pch == ' ' && _ptpChainCurr->HasCollapsedWhitespace())
    {
        if (_tcscmp(_ptpChainCurr->GetCollapsedWhitespace(), _T(" ")) == 0)
        {
            CTreePos *ptpRemove = _ptpChainCurr;
            CTreePos *ptpNext = _ptpChainCurr->Next();

            Assert( _ptpChainCurr->IsLeftChild() );
            Assert( _ptpChainCurr->IsLastChild() );
            
            // move to previous tree pos
            _ptpChainCurr = _ptpChainCurr->LeftChild();

            // unlink this text pos
            _ptpChainCurr->SetNext(ptpNext);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
            _ptpChainCurr->SetRightThread(ptpNext);
#endif
            Assert( _ptpChainCurr->IsLeftChild() );
            Assert( _ptpChainCurr->IsLastChild() );

            if (ptpNext)
            {
                ptpNext->SetFirstChild(_ptpChainCurr);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                ptpNext->SetLeftThread(_ptpChainCurr);
#endif
            }
            else
            {
                _ptpChainTail = _ptpChainCurr;
            }

            // release the pointer pos
            if (_ptpSpaceCache)
            {
                delete [] ptpRemove->GetCollapsedWhitespace();
                MemFree(ptpRemove);
            }
            else
            {
                _ptpSpaceCache = ptpRemove;
            }
        }
        else
        {
            Assert(_ptpChainCurr->Cling());
            _ptpChainCurr->SetGravity(TRUE /* fRight */);
        }
    }

    // Step 4: Insert a run or add chars to a current run
    AddCharsToNotification( _cpChainCurr, cch );
 
    // First case handles the all ASCII case
    if ( !cch || _sidLast == sidAsciiLatin && fAscii )
    {
        if ( ! _ptpChainCurr->IsText() )
        {
            CTreePos    *ptpTextNew;
            // insert the new text pos

            ptpTextNew = InsertNewTextPosInChain( cch, _sidLast, _ptpChainCurr );
            if (!ptpTextNew)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            _ptpChainCurr = ptpTextNew;
        }
        else
        {
            _ptpChainCurr->DataThis()->t._cch += cch;
        }
    }
    else
    {
        // Slow loop to take care of non ascii characters
        TCHAR *pchStart = pch;
        TCHAR *pchScan = pch;
        ULONG cchScan = cch;
        LONG sid = sidDefault;

        for (;;)
        {
            // TODO: this might do something strange when _sidLast == sidDefault
            // or _sidLast == sidMerge (jbeda)

            // Break string into uniform sid's, merging from left
            while (cchScan)
            {
                sid = ScriptIDFromCh(*pchScan);
                sid = FoldScriptIDs(_sidLast, sid);
                
                if (sid != _sidLast)
                    break;

                cchScan--;
                pchScan++;
            }

            // Add to the current run or create a new run
            if (pchScan > pchStart)
            {
                long cchChunk = pchScan - pchStart;

                if ( ! _ptpChainCurr->IsText() || _ptpChainCurr->Sid() != _sidLast )                 
                {
                    CTreePos * ptpTextNew;

                    ptpTextNew = InsertNewTextPosInChain( cchChunk, _sidLast, _ptpChainCurr);
                    if (!ptpTextNew)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    _ptpChainCurr = ptpTextNew;
                }
                else
                {
                    _ptpChainCurr->DataThis()->t._cch += cchChunk;
                }
            }

            pchStart = pchScan;

            if (!cchScan)
                break;
                
            Assert(sid != sidMerge);

            _sidLast = sid;
        }

    }


    // Step 2: Add the actual text to the story
    if (cch > 0)
    {
        Verify(
            ULONG(
                CTxtPtr( _pMarkup, _cpChainCurr ).
                    InsertRange( cch, pch ) ) == cch );
    }

    _cpChainCurr += cch;

Cleanup:

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member:     HookBeginElement
//
//  Synopsis:   Compatibility hacks for begin element
//
//-------------------------------------------------------------------------
HRESULT
CHtmRootParseCtx::HookBeginElement(CTreeNode * pNode)
{
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     HookEndElement
//
//  Synopsis:   Compatibility hacks for end element
//
//-------------------------------------------------------------------------
HRESULT
CHtmRootParseCtx::HookEndElement(CTreeNode * pNode, CTreeNode * pNodeCur)
{
    //
    // <p>'s which have </p>'s render differently.  Here, when a <p> goes
    // out of scope, we check to see if a </p> was detected, and invalidate
    // the para graph to render correctly.  We only have to do this if the
    // paragraph has gotten an EnterTree notification.
    //

    if (    pNode->Tag() == ETAG_P 
        &&  pNode->Element()->_fExplicitEndTag
        &&  pNode->Element()->IsInMarkup() )
    {
        // This is a hack. Basically, the regular code is WAY too slow.
        // In fact, it forces rerendering of the paragraph AND runs the
        // monster walk.
        //
        // The bug it is trying to solve is that the fancy format for the
        // P tag has already been calculated, and the </P> tag changes the
        // fancy format's _cuvSpaceAfter. Fortunately, we haven't actually used
        // the space after yet (because we haven't even parsed anything following
        // this </P> tag), and because fancy formats aren't inherited,
        // we can just recalc the format for this one tag (actually, we
        // could do even less, just reset the post spacing, but we lack
        // primitives for that).
        // - Arye
        BYTE ab[sizeof(CFormatInfo)];
        ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
        ((CFormatInfo *)ab)->_lRecursionDepth = 0;
        if (pNode->IsFancyFormatValid())
        {
            pNode->VoidCachedInfo();
            pNode->Element()->ComputeFormats((CFormatInfo *)ab, pNode);
        }
    }

    return S_OK;
}

void    
CHtmRootParseCtx::AddCharsToNotification( long cpStart, long cch  )
{
    if( ! _fTextPendingValid )
    {
        Assert( _pNodeForNotify );

        // We are adding chars to an existing text pos
        _nfTextPending.CharsAdded(  cpStart,
                                    cch,
                                    _pNodeForNotify );

        _nfTextPending.SetFlag( NFLAGS_CLEANCHANGE );

        _fTextPendingValid = TRUE;
    }
    else
    {
        // Add to the current notification
        _nfTextPending.AddChars( cch );
    }
}

HRESULT
CHtmRootParseCtx::NailDownChain()
{
    HRESULT     hr = S_OK;
    BOOL        fResetChain = FALSE;

    // Create/Modify text pos as necessary
    if( _tdpTextDummy.Cch() != 0 )
    {
        CTreePos   *ptpBeforeFrontier;

        ptpBeforeFrontier = _ptpAfterFrontier->PreviousTreePos();
        if(     ptpBeforeFrontier->IsText()
           &&   ptpBeforeFrontier->Sid() == _tdpTextDummy.Sid() )
        {
            ptpBeforeFrontier->ChangeCch( _tdpTextDummy.Cch() );
        }
        else
        {
            CTreePos * ptpTextNew;

            ptpTextNew = InsertNewTextPosInChain( 
                            _tdpTextDummy.Cch(),
                            _tdpTextDummy.Sid(),
                            &_tdpTextDummy );
            if( !ptpTextNew )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Assert( _tdpTextDummy.Next() == ptpTextNew );

            if( _ptpChainCurr == &_tdpTextDummy )
                _ptpChainCurr = ptpTextNew;
        }

        fResetChain = TRUE;
    }

    // Add chain to the tree
    if( _ptpChainTail != &_tdpTextDummy )
    {
        CTreePos * ptpChainHead = _tdpTextDummy.Next();

        Assert( ptpChainHead );

        ptpChainHead->SetFirstChild( NULL );

        hr = THR( _pMarkup->InsertPosChain( ptpChainHead, _ptpChainTail, _ptpAfterFrontier ) );
        if (hr)
            goto Cleanup;

        fResetChain = TRUE;
    }

    if( fResetChain )
    {
        // update the frontier
        if( _ptpChainCurr != &_tdpTextDummy )
            _ptpAfterFrontier = _ptpChainCurr->NextTreePos();
#if DBG == 1
        // The current pos on the chain should only be the
        // dummy text pos when the chain is empty
        else
            Assert( ! _tdpTextDummy.Next() );
#endif

        // reset the chain
        _tdpTextDummy.SetNext( NULL );
        _tdpTextDummy.DataThis()->t._cch = 0;
        _tdpTextDummy.DataThis()->t._sid = _ptpChainCurr->IsText() ? _ptpChainCurr->Sid() : sidAsciiLatin;
        _ptpChainCurr = &_tdpTextDummy;
        _ptpChainTail = &_tdpTextDummy;

        MtAdd(Mt(ParseNailDownChain), 1, 0);
    }

    // insert any WCH_NODE characters
    if( _cchNodeBefore || _cchNodeAfter )
    {
        ULONG cpInsert = _cpChainCurr - _cchNodeBefore;
        ULONG cchInsert = _cchNodeBefore + _cchNodeAfter;

        Verify(
            ULONG(
                CTxtPtr( _pMarkup, cpInsert ).
                    InsertRepeatingChar( cchInsert, WCH_NODE ) ) == cchInsert );

        _cchNodeBefore = 0;
        _cchNodeAfter = 0;
    }

Cleanup:
    RRETURN( hr );
}

void 
CHtmRootParseCtx::FlushTextNotification()
{
    // Step 1: nail down the chain
    IGNORE_HR( NailDownChain() );

    // Step 2: up the documents content version
    _pMarkup->UpdateMarkupTreeVersion();

    // Step 3: send the pending text notification
    if (_fTextPendingValid)
    {
        // If we've made this notification 0 length, don't do anything with it!
        if( _nfTextPending.Cch(LONG_MAX) )
        {
            WHEN_DBG(_nfTextPending.ResetSN());

            TraceTagEx((tagRootParseCtx, TAG_NONAME,
               "RootParse      : Notification sent (%d, %S) Node(N%d.%S) cp(%d) cch(%d)",
               _nfTextPending.SerialNumber(),
               _nfTextPending.Name(),
               _nfTextPending.Node()->SN(),
               _nfTextPending.Node()->Element()->TagName(),
               _nfTextPending.Cp(0),
               _nfTextPending.Cch(LONG_MAX)));

            _nfTextPending.SetFlag(NFLAGS_PARSER_TEXTCHANGE);

            _pMarkup->Notify( _nfTextPending );

            MtAdd(Mt(ParseTextNotifications), 1, 0);
        }

        _fTextPendingValid = FALSE;
    }

    _pNodeForNotify = NULL;
}

HRESULT
CHtmRootParseCtx::FlushNotifications()
{
    HRESULT hr;
    long lVer;

    hr = S_OK;

    // Step 1: send the pending text notification

    FlushTextNotification();

    lVer = _pMarkup->GetMarkupTreeVersion();

#if DBG == 1
    _pMarkup->DbgLockTree(TRUE);
#endif


    // Step 2: send any pending ElementEnter and ElementAdded notifications

    if (_nElementsAdded)
    {
        CTreePos * ptpCurr = _ptpElementAdded;

        Assert( ptpCurr );

        {
            CNotification nf;

            nf.ElementsAdded( _ptpElementAdded->SourceIndex(), _nElementsAdded );

            TraceTagEx((tagRootParseCtx, TAG_NONAME,
               "RootParse      : Notification sent (%d, %S) si(%d) cElements(%d)",
               nf.SerialNumber(),
               nf.Name(),
               nf.SI(),
               nf.CElements()));

            _pMarkup->Notify( nf );

            // 49396: duck out if markup has been modified to avoid crash (dbau).
            if (lVer != _pMarkup->GetMarkupTreeVersion())
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            MtAdd(Mt(ParseElementNotifications), 1, 0);
        }

        while (_nElementsAdded)
        {
            // We assert ptpCurr!= NULL, but we have an IEWatson crash where it is.  Leaving the asserts
            // for debugging, but adding a check to protect the crash:
            if( !ptpCurr )
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            if( ptpCurr->IsBeginElementScope() )
            {
                CNotification   nf;
                CElement *      pElement = ptpCurr->Branch()->Element();

                nf.ElementEntertree( pElement );
                nf.SetData( ENTERTREE_PARSE );

                TraceTagEx((tagRootParseCtx, TAG_NONAME,
                   "RootParse      : Notification sent (%d, %S) Element(E%d.%S)",
                   nf.SerialNumber(),
                   nf.Name(),
                   pElement->SN(),
                   pElement->TagName()));

                pElement->Notify( &nf );


                // 49396: duck out if markup has been modified to avoid crash (dbau).
                if (lVer != _pMarkup->GetMarkupTreeVersion())
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }

                _nElementsAdded--;
            }

            ptpCurr = ptpCurr->NextTreePos();

            Assert( ptpCurr );
        }

        _ptpElementAdded = NULL;
    }

Cleanup:

#if DBG == 1
    _pMarkup->DbgLockTree(FALSE);
#endif

    RRETURN(hr);
}

void 
CHtmRootParseCtx::InsertTreePosInChain( 
    CTreePos *ptpBeforeOnChain,
    CTreePos *ptpNew)
{
    CTreePos *  ptpAfterCurr = ptpBeforeOnChain->Next();

    ptpNew->SetFirstChild( ptpBeforeOnChain );
    ptpNew->SetNext( ptpAfterCurr );
    ptpNew->SetFlag( CTreePos::TPF_LEFT_CHILD | CTreePos::TPF_LAST_CHILD );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    ptpNew->SetLeftThread( ptpBeforeOnChain );
    ptpNew->SetRightThread( ptpAfterCurr );
#endif

    ptpBeforeOnChain->SetNext( ptpNew );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    ptpBeforeOnChain->SetRightThread( ptpNew );
#endif
    Assert( ptpBeforeOnChain->IsLeftChild() );
    Assert( ptpBeforeOnChain->IsLastChild() );

    if( ptpAfterCurr )
    {
        ptpAfterCurr->SetFirstChild( ptpNew );
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        ptpAfterCurr->SetLeftThread( ptpNew );
#endif
        Assert( ptpAfterCurr->IsLeftChild() );
        Assert( ptpAfterCurr->IsLastChild() );
    }
    else
        _ptpChainTail = ptpNew;

}

CTreePos *
CHtmRootParseCtx::InsertNewTextPosInChain( 
    LONG cch, 
    SCRIPT_ID sid,
    CTreePos *ptpBeforeOnChain)
{
    CTreePos *  ptpTextNew;

    Assert( cch != 0 );
    ptpTextNew = _pMarkup->NewTextPos(cch, sid);
    if (!ptpTextNew)
        goto Cleanup;

    InsertTreePosInChain(ptpBeforeOnChain, ptpTextNew);

Cleanup:
    return ptpTextNew;
}

#if DBG==1
CTreePos *
#else
void
#endif
CHtmRootParseCtx::AdvanceFrontier()
{
    WHEN_DBG( CTreePos * ptpContent );

    while( _ptpAfterFrontier->IsPointer() )
        _ptpAfterFrontier = _ptpAfterFrontier->NextTreePos();

    WHEN_DBG( ptpContent = _ptpAfterFrontier );
    _ptpAfterFrontier = _ptpAfterFrontier->NextTreePos();

    if( _ptpAfterFrontier->IsPointer() )
    {
        CTreePosGap tpg( _ptpAfterFrontier, TPG_LEFT );

        tpg.PartitionPointers( _pMarkup, FALSE );

        _ptpAfterFrontier = tpg.AdjacentTreePos( TPG_RIGHT );
    }

    WHEN_DBG( return ptpContent );
}

HRESULT    
CHtmRootParseCtx::LazyPrepare( CTreeNode * pNodeUnder )
{
    HRESULT hr;
    CTreePos * ptpBeforeFrontier;

    Assert( _fLazyPrepareNeeded );

    hr = _pMarkup->EmbedPointers();
    if (hr)
        goto Cleanup;

    // Set up the real frontier
    _ptpAfterFrontier = pNodeUnder->GetEndPos();

    // Set up the script ID for the accumulation TextPos
    ptpBeforeFrontier = _ptpAfterFrontier->PreviousTreePos();
    Assert( _ptpChainCurr == &_tdpTextDummy ); 
    Assert( _ptpChainTail == &_tdpTextDummy );
    if( ptpBeforeFrontier->IsText() )
    {
        _sidLast = ptpBeforeFrontier->Sid();
    }
    else
    {
        _sidLast = sidAsciiLatin;

    }

    if( ptpBeforeFrontier->IsPointer() )
    {
        CTreePosGap tpg( _ptpAfterFrontier, TPG_LEFT );

        tpg.PartitionPointers( _pMarkup, FALSE );
        
        _ptpAfterFrontier = tpg.AdjacentTreePos( TPG_RIGHT );
    }

    _ptpChainCurr->DataThis()->t._sid = _sidLast;

    // Set up the frontier inside of the chain
    _pNodeChainCurr = pNodeUnder;
    _cpChainCurr = _ptpAfterFrontier->GetCp();

    // Assert a bunch of stuff
    Assert( _cchNodeBefore == 0 );
    Assert( _cchNodeAfter == 0 );
    Assert( _pNodeForNotify == NULL );
    Assert( _nElementsAdded == 0 );
    Assert( _ptpElementAdded == NULL );
    Assert( !_fTextPendingValid );

    _fLazyPrepareNeeded = FALSE;

Cleanup:
    RRETURN( hr );
}

#if DBG == 1
void 
CHtmRootParseCtx::Validate( CTreeNode * pNodeUnder)
{
    Assert( ! _pMarkup->HasUnembeddedPointers() );
    
    // Make sure that we are just under the end of pNodeUnder
    if( _ptpChainCurr->Next() )
        Assert( _ptpChainCurr->Next() == pNodeUnder->GetEndPos() );
    else
    {
        CTreePos * ptpVerify = _ptpAfterFrontier;

        while( ptpVerify->IsPointer() )
            ptpVerify = ptpVerify->NextTreePos();

        Assert( ptpVerify == pNodeUnder->GetEndPos() );
    }

    // Make sure that the element we are going to send a notfication to
    // above the current insertion point
    if( _fTextPendingValid )
    {
        Assert( pNodeUnder->SearchBranchToRootForScope( _nfTextPending.Node()->Element() ) );
    }

    Assert( pNodeUnder == _pNodeChainCurr );
}
#endif


//+------------------------------------------------------------------------
//
//  CHtmTopParseCtx
//
//  The top parse context.
//
//  The top parse context is responsible for:
//
//  Throwing out text (and asserting on nonspace)
//
//  Recognizing that an input type=hidden at the beginning of the document
//  is not textlike
//
//-------------------------------------------------------------------------

class CHtmTopParseCtx : public CHtmParseCtx
{
public:
    typedef CHtmParseCtx super;
    
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmTopParseCtx))
    
    CHtmTopParseCtx(CHtmParseCtx *phpxParent);
    
    virtual BOOL QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht);

#if DBG==1
    virtual HRESULT AddText(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii) 
        { Assert(IsAllSpaces(pch, cch)); return S_OK; }
#endif
};

HRESULT
CreateHtmTopParseCtx(CHtmParseCtx **pphpx, CHtmParseCtx *phpxParent)
{
    CHtmParseCtx *phpx;

    phpx = new CHtmTopParseCtx(phpxParent);
    if (!phpx)
        return E_OUTOFMEMORY;

    *pphpx = phpx;

    return S_OK;
}

const ELEMENT_TAG
s_atagTopReject[] =
{
    ETAG_NULL
};

const ELEMENT_TAG s_atagTopIgnoreEnd[] = {ETAG_HTML, ETAG_HEAD, ETAG_BODY, ETAG_NULL};

CHtmTopParseCtx::CHtmTopParseCtx(CHtmParseCtx *phpxParent)
    : CHtmParseCtx(phpxParent)
{
    _atagReject    = s_atagTopReject;
    _atagIgnoreEnd = s_atagTopIgnoreEnd;
}


BOOL
CHtmTopParseCtx::QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht)
{
    Assert(!pht || pht->Is(etag));
        
    // For Netscape comptibility:
    // An INPUT in the HEAD is not textlike if the input is type=hidden.
    // Also, For IE4 compat during paste, if the head was not explicit, then all
    // inputs, including hidden are text like.
    // Also, forms tags must force a body in the paste scenario

    switch ( etag )
    {
        case ETAG_MAP :
        case ETAG_GENERIC :
        case ETAG_GENERIC_LITERAL :
        case ETAG_GENERIC_BUILTIN :
        case ETAG_BASEFONT :
        case ETAG_AREA :
        case ETAG_FORM :
        
            // Some tags should be text-like when parsing (pasting, usually)
            
            if (pMarkup->_fMarkupServicesParsing)
                return TRUE;
            else
                return FALSE;
                
        case ETAG_INPUT:
        
            // If not parsing from markup services (pasting, usually) then the hidden input
            // is not text-like (it can begin before the body.

            if (pMarkup->_fMarkupServicesParsing)
                return TRUE;
                
            {
                TCHAR * pchType;

                if (pht->ValFromName(_T("TYPE"), &pchType) && !StrCmpIC(pchType, _T("HIDDEN")))
                    return FALSE;
            }

        case ETAG_OBJECT:
        case ETAG_APPLET:
        
            // Objects and applets that appear bare at the top (not in head) are textlike

            return TRUE;

        case ETAG_A:
        default:
        
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdcoefct.c ===
/*
 * jdcoefct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for decompression.
 * This controller is the top level of the JPEG decompressor proper.
 * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
 *
 * In buffered-image mode, this controller is the interface between
 * input-oriented processing and output-oriented processing.
 * Also, the input side (only) is used when reading a file for transcoding.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"

/* Block smoothing is only applicable for progressive JPEG, so: */
#ifndef D_PROGRESSIVE_SUPPORTED
#undef BLOCK_SMOOTHING_SUPPORTED
#endif

/* Private buffer controller object */

typedef struct {
  struct jpeg_d_coef_controller pub; /* public fields */

  /* These variables keep track of the current location of the input side. */
  /* cinfo->input_iMCU_row is also used for this. */
  JDIMENSION MCU_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* The output side's location is represented by cinfo->output_iMCU_row. */

  /* In single-pass modes, it's sufficient to buffer just one MCU.
   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,
   * and let the entropy decoder write into that workspace each time.
   * (On 80x86, the workspace is FAR even though it's not really very big;
   * this is to keep the module interfaces unchanged when a large coefficient
   * buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays; it is used only by the input side.
   */
  JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];

#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
#endif

#ifdef BLOCK_SMOOTHING_SUPPORTED
  /* When doing block smoothing, we latch coefficient Al values here */
  int * coef_bits_latch;
#define SAVED_COEFS  6		/* we save coef_bits[0..5] */
#endif
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;

/* Forward declarations */
METHODDEF(int) decompress_onepass
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#ifdef D_MULTISCAN_FILES_SUPPORTED
METHODDEF(int) decompress_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif
#ifdef BLOCK_SMOOTHING_SUPPORTED
LOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
METHODDEF(int) decompress_smooth_data
	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
#endif


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->MCU_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  cinfo->input_iMCU_row = 0;
  start_iMCU_row(cinfo);
}


/*
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
      coef->pub.decompress_data = decompress_smooth_data;
    else
      coef->pub.decompress_data = decompress_data;
  }
#endif
  cinfo->output_iMCU_row = 0;
}


/*
 * Decompress and return some data in the single-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Input and output must run in lockstep since we have only a one-MCU buffer.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 * For single pass, this is the same as the components in the scan.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, ci, xindex, yindex, yoffset, useful_width;
  JSAMPARRAY output_ptr;
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
	  blkn += compptr->MCU_blocks;
	  continue;
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
	output_ptr = output_buf[ci] + yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
	    }
	  }
	  blkn += compptr->MCU_width;
	  output_ptr += compptr->DCT_scaled_size;
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
}


#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Consume input data and store it in the full-image coefficient buffer.
 * We read as much as one fully interleaved MCU row ("iMCU" row) per call,
 * ie, v_samp_factor block rows for each component in the scan.
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       cinfo->input_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, TRUE);
    /* Note: entropy decoder expects buffer to be zeroed,
     * but this is handled automatically by the memory manager
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
    start_iMCU_row(cinfo);
    return JPEG_ROW_COMPLETED;
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
  return JPEG_SCAN_COMPLETED;
}


/*
 * Decompress and return some data in the multi-pass case.
 * Always attempts to emit one fully interleaved MCU row ("iMCU" row).
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 *
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num;
  int ci, block_row, block_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
			output_ptr, output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */


#ifdef BLOCK_SMOOTHING_SUPPORTED

/*
 * This code applies interblock smoothing as described by section K.8
 * of the JPEG standard: the first 5 AC coefficients are estimated from
 * the DC values of a DCT block and its 8 neighboring blocks.
 * We apply smoothing only for progressive JPEG decoding, and only if
 * the coefficients it can estimate are not yet known to full precision.
 */

/* Natural-order array positions of the first 5 zigzag-order coefficients */
#define Q01_POS  1
#define Q10_POS  8
#define Q20_POS  16
#define Q11_POS  9
#define Q02_POS  2

/*
 * Determine whether block smoothing is applicable and safe.
 * We also latch the current states of the coef_bits[] entries for the
 * AC coefficients; otherwise, if the input side of the decompressor
 * advances into a new scan, we might think the coefficients are known
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  boolean smoothing_useful = FALSE;
  int ci, coefi;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
    return FALSE;

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
	qtable->quantval[Q01_POS] == 0 ||
	qtable->quantval[Q10_POS] == 0 ||
	qtable->quantval[Q20_POS] == 0 ||
	qtable->quantval[Q11_POS] == 0 ||
	qtable->quantval[Q02_POS] == 0)
      return FALSE;
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
    if (coef_bits[0] < 0)
      return FALSE;
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
      coef_bits_latch[coefi] = coef_bits[coefi];
      if (coef_bits[coefi] != 0)
	smoothing_useful = TRUE;
    }
    coef_bits_latch += SAVED_COEFS;
  }

  return smoothing_useful;
}


/*
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION block_num, last_block_column;
  int ci, block_row, block_rows, access_rows;
  JBLOCKARRAY buffer;
  JBLOCKROW buffer_ptr, prev_block_row, next_block_row;
  JSAMPARRAY output_ptr;
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;
  boolean first_row, last_row;
  JBLOCK workspace;
  int *coef_bits;
  JQUANT_TBL *quanttbl;
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
      block_rows = compptr->v_samp_factor;
      access_rows = block_rows * 2; /* this and next iMCU row */
      last_row = FALSE;
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
      access_rows = block_rows; /* this iMCU row only */
      last_row = TRUE;
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
      first_row = FALSE;
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
    quanttbl = compptr->quant_table;
    Q00 = quanttbl->quantval[0];
    Q01 = quanttbl->quantval[Q01_POS];
    Q10 = quanttbl->quantval[Q10_POS];
    Q20 = quanttbl->quantval[Q20_POS];
    Q11 = quanttbl->quantval[Q11_POS];
    Q02 = quanttbl->quantval[Q02_POS];
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      if (first_row && block_row == 0)
	prev_block_row = buffer_ptr;
      else
	prev_block_row = buffer[block_row-1];
      if (last_row && block_row == block_rows-1)
	next_block_row = buffer_ptr;
      else
	next_block_row = buffer[block_row+1];
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
      for (block_num = 0; block_num <= last_block_column; block_num++) {
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
	/* Update DC values */
	if (block_num < last_block_column) {
	  DC3 = (int) prev_block_row[1][0];
	  DC6 = (int) buffer_ptr[1][0];
	  DC9 = (int) next_block_row[1][0];
	}
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
	  num = 36 * Q00 * (DC4 - DC6);
	  if (num >= 0) {
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[1] = (JCOEF) pred;
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
	  num = 36 * Q00 * (DC2 - DC8);
	  if (num >= 0) {
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[8] = (JCOEF) pred;
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[16] = (JCOEF) pred;
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
	  if (num >= 0) {
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[9] = (JCOEF) pred;
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
	    if (Al > 0 && pred >= (1<<Al))
	      pred = (1<<Al)-1;
	    pred = -pred;
	  }
	  workspace[2] = (JCOEF) pred;
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}

#endif /* BLOCK_SMOOTHING_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
  coef->pub.start_input_pass = start_input_pass;
  coef->pub.start_output_pass = start_output_pass;
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
	access_rows *= 3;
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
    coef->pub.decompress_data = decompress_data;
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdapimin.c ===
/*
 * jdapimin.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "minimum" API routines that may be
 * needed in either the normal full-decompression case or the
 * transcoding-only case.
 *
 * Most of the routines intended to be called directly by an application
 * are in this file or in jdapistd.c.  But also see jcomapi.c for routines
 * shared by compression and decompression, and jdtrans.c for the transcoding
 * case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/*
 * Initialization of a JPEG decompression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
  if (version != JPEG_LIB_VERSION)
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
	     (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);

  /* For debugging purposes, zero the whole master structure.
   * But error manager pointer is already there, so save and restore it.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
    cinfo->err = err;
  }
  cinfo->is_decompressor = TRUE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->src = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  jinit_marker_reader(cinfo);

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);

  /* Check for MMX machine if necessary */
  if (vfMMXMachine == 2)
      vfMMXMachine = !!IsMMX();
      
  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
}


/*
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Abort processing of a JPEG decompression operation,
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_decompress (j_decompress_ptr cinfo)
{
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Install a special processing method for COM or APPn markers.
 */

GLOBAL(void)
jpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,
			   jpeg_marker_parser_method routine)
{
  if (marker_code == JPEG_COM)
    cinfo->marker->process_COM = routine;
  else if (marker_code >= JPEG_APP0 && marker_code <= JPEG_APP0+15)
    cinfo->marker->process_APPn[marker_code-JPEG_APP0] = routine;
  else
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);
}


/*
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
    cinfo->out_color_space = JCS_GRAYSCALE;
    break;
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
    } else if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
	break;
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
	break;
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
      int cid1 = cinfo->comp_info[1].component_id;
      int cid2 = cinfo->comp_info[2].component_id;

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
    break;
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
      switch (cinfo->Adobe_transform) {
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
	break;
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
	break;
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
    }
    cinfo->out_color_space = JCS_CMYK;
    break;
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
    cinfo->out_color_space = JCS_UNKNOWN;
    break;
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = 1;		/* 1:1 scaling */
  cinfo->scale_denom = 1;
  cinfo->output_gamma = 1.0;
  cinfo->buffered_image = FALSE;
  cinfo->raw_data_out = FALSE;
  cinfo->dct_method = JDCT_DEFAULT;
  cinfo->do_fancy_upsampling = TRUE;
  cinfo->do_block_smoothing = TRUE;
  cinfo->quantize_colors = FALSE;
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
  cinfo->colormap = NULL;
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
  cinfo->enable_external_quant = FALSE;
  cinfo->enable_2pass_quant = FALSE;
}


/*
 * Decompression startup: read start of JPEG datastream to see what's there.
 * Need only initialize JPEG object and supply a data source before calling.
 *
 * This routine will read as far as the first SOS marker (ie, actual start of
 * compressed data), and will save all tables and parameters in the JPEG
 * object.  It will also initialize the decompression parameters to default
 * values, and finally return JPEG_HEADER_OK.  On return, the application may
 * adjust the decompression parameters and then call jpeg_start_decompress.
 * (Or, if the application only wanted to determine the image parameters,
 * the data need not be decompressed.  In that case, call jpeg_abort or
 * jpeg_destroy to release any temporary space.)
 * If an abbreviated (tables only) datastream is presented, the routine will
 * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then
 * re-use the JPEG object to read the abbreviated image datastream(s).
 * It is unnecessary (but OK) to call jpeg_abort in this case.
 * The JPEG_SUSPENDED return code only occurs if the data source module
 * requests suspension of the decompressor.  In this case the application
 * should load more source data and then re-call jpeg_read_header to resume
 * processing.
 * If a non-suspending data source is used and require_image is TRUE, then the
 * return code need not be inspected since only JPEG_HEADER_OK is possible.
 *
 * This routine is now just a front end to jpeg_consume_input, with some
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
      cinfo->global_state != DSTATE_INHEADER)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  retcode = jpeg_consume_input(cinfo);

  switch (retcode) {
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
    break;
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
      ERREXIT(cinfo, JERR_NO_IMAGE);
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
    retcode = JPEG_HEADER_TABLES_ONLY;
    break;
  case JPEG_SUSPENDED:
    /* no work */
    break;
  }

  return retcode;
}


/*
 * Consume data in advance of what the decompressor requires.
 * This can be called at any time once the decompressor object has
 * been created and a data source has been set up.
 *
 * This routine is essentially a state machine that handles a couple
 * of critical state-transition actions, namely initial setup and
 * transition from header scanning to ready-for-start_decompress.
 * All the actual input is done via the input controller's consume_input
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
    cinfo->global_state = DSTATE_INHEADER;
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
    }
    break;
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
    break;
  case DSTATE_PRELOAD:
  case DSTATE_PRESCAN:
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    break;
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  return retcode;
}


/*
 * Have we finished reading the input file?
 */

GLOBAL(boolean)
jpeg_input_complete (j_decompress_ptr cinfo)
{
  /* Check for valid jpeg object */
  if (cinfo->global_state < DSTATE_START ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->eoi_reached;
}


/*
 * Is there more than one scan?
 */

GLOBAL(boolean)
jpeg_has_multiple_scans (j_decompress_ptr cinfo)
{
  /* Only valid after jpeg_read_header completes */
  if (cinfo->global_state < DSTATE_READY ||
      cinfo->global_state > DSTATE_STOPPING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  return cinfo->inputctl->has_multiple_scans;
}


/*
 * Finish JPEG decompression.
 *
 * This will normally just verify the file trailer and release temp storage.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state != DSTATE_STOPPING) {
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdapistd.c ===
/*
 * jdapistd.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the decompression half
 * of the JPEG library.  These are the "standard" API routines that are
 * used in the normal full-decompression case.  They are not used by a
 * transcoding-only application.  Note that if an application links in
 * jpeg_start_decompress, it will end up linking in the entire decompressor.
 * We thus must separate this file from jdapimin.c to avoid linking the
 * whole decompression library into a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Forward declarations */
LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));


/*
 * Decompression initialization.
 * jpeg_read_header must be completed before calling this.
 *
 * If a multipass operating mode was selected, this will do all but the
 * last pass, and thus may take a great deal of time.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
  if (cinfo->global_state == DSTATE_READY) {
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
    if (cinfo->buffered_image) {
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
      return TRUE;
    }
    cinfo->global_state = DSTATE_PRELOAD;
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
	if (retcode == JPEG_SUSPENDED)
	  return FALSE;
	if (retcode == JPEG_REACHED_EOI)
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
	  }
	}
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
  } else if (cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
}


/*
 * Set up for an output pass, and perform any dummy pass(es) needed.
 * Common subroutine for jpeg_start_decompress and jpeg_start_output.
 * Entry: global_state = DSTATE_PRESCAN only if previously suspended.
 * Exit: If done, returns TRUE and sets global_state for proper output mode.
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
  if (cinfo->global_state != DSTATE_PRESCAN) {
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
    cinfo->global_state = DSTATE_PRESCAN;
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
	cinfo->progress->pass_limit = (long) cinfo->output_height;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
	return FALSE;		/* No progress made, must suspend */
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
  return TRUE;
}


/*
 * Read some scanlines of data from the JPEG decompressor.
 *
 * The return value will be the number of lines actually read.
 * This may be less than the number requested in several cases,
 * including bottom of image, data source suspension, and operating
 * modes that emit multiple scanlines at a time.
 *
 * Note: we warn about excess calls to jpeg_read_scanlines() since
 * this likely signals an application programmer error.  However,
 * an oversize buffer (max_lines > scanlines remaining) is not an error.
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Process some data */
  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
  cinfo->output_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to read raw data.
 * Processes exactly one iMCU row per call, unless suspended.
 */

GLOBAL(JDIMENSION)
jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
		    JDIMENSION max_lines)
{
  JDIMENSION lines_per_iMCU_row;

  if (cinfo->global_state != DSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->output_scanline >= cinfo->output_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
    cinfo->progress->pass_limit = (long) cinfo->output_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Verify that at least one iMCU row can be returned. */
  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
  if (max_lines < lines_per_iMCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Decompress directly into user's buffer. */
  if (! (*cinfo->coef->decompress_data) (cinfo, data))
    return 0;			/* suspension forced, can do nothing more */

  /* OK, we processed one iMCU row. */
  cinfo->output_scanline += lines_per_iMCU_row;
  return lines_per_iMCU_row;
}


/* Additional entry points for buffered-image mode. */

#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Initialize for an output pass in buffered-image mode.
 */

GLOBAL(boolean)
jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
{
  if (cinfo->global_state != DSTATE_BUFIMAGE &&
      cinfo->global_state != DSTATE_PRESCAN)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Limit scan number to valid range */
  if (scan_number <= 0)
    scan_number = 1;
  if (cinfo->inputctl->eoi_reached &&
      scan_number > cinfo->input_scan_number)
    scan_number = cinfo->input_scan_number;
  cinfo->output_scan_number = scan_number;
  /* Perform any dummy output passes, and set up for the real pass */
  return output_pass_setup(cinfo);
}


/*
 * Finish up after an output pass in buffered-image mode.
 *
 * Returns FALSE if suspended.  The return value need be inspected only if
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_output (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
    /* Terminate this pass. */
    /* We do not require the whole pass to have been completed. */
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_BUFPOST;
  } else if (cinfo->global_state != DSTATE_BUFPOST) {
    /* BUFPOST = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read markers looking for SOS or EOI */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
	 ! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  cinfo->global_state = DSTATE_BUFIMAGE;
  return TRUE;
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdcolor.c ===
/*
 * jdcolor.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains output colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_deconverter pub; /* public fields */

  /* Private state for YCC->RGB conversion */
  int * Cr_r_tab;		/* => table for Cr to R conversion */
  int * Cb_b_tab;		/* => table for Cb to B conversion */
  INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
  INT32 * Cb_g_tab;		/* => table for Cb to G conversion */
} my_color_deconverter;

typedef my_color_deconverter * my_cconvert_ptr;


/**************** YCbCr -> RGB conversion: most common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *	R = Y                + 1.40200 * Cr
 *	G = Y - 0.34414 * Cb - 0.71414 * Cr
 *	B = Y + 1.77200 * Cb
 * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 * Notice that Y, being an integral input, does not contribute any fraction
 * so it need not participate in the rounding.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times Cb and Cr for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
 * values for the G calculation are left scaled up, since we must add them
 * together before rounding.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))


/*
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}


/*
 * Convert some rows of samples to the output colorspace.
 *
 * Note that we change from noninterleaved, one-plane-per-component format
 * to interleaved-pixel format.  The output buffer is therefore three times
 * as wide as the input buffer.
 * A starting row offset is provided only for the input buffer.  The caller
 * can easily adjust the passed output_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
      outptr += RGB_PIXELSIZE;
    }
  }
}


/**************** Cases other than YCbCr -> RGB **************/


/*
 * Color conversion for no colorspace change: just copy the data,
 * converting from separate-planes to interleaved representation.
 */

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
      for (count = num_cols; count > 0; count--) {
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
	outptr += num_components;
      }
    }
    input_row++;
    output_buf++;
  }
}


/*
 * Color conversion for grayscale: just copy the data.
 * This also works for YCbCr -> grayscale conversion, in which
 * we just copy the Y (luminance) component and ignore chrominance.
 */

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
		    num_rows, cinfo->output_width);
}


/*
 * Adobe-style YCCK->CMYK conversion.
 * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume build_ycc_rgb_table has been called.
 */

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  register int * Crrtab = cconvert->Cr_r_tab;
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
      outptr += 4;
    }
  }
}


/*
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
  cconvert->pub.start_pass = start_pass_dcolor;

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    break;
  }

  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
	cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = grayscale_convert;
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
	cinfo->comp_info[ci].component_needed = FALSE;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = ycc_rgb_convert;
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_CMYK:
    cinfo->out_color_components = 4;
    if (cinfo->jpeg_color_space == JCS_YCCK) {
      cconvert->pub.color_convert = ycck_cmyk_convert;
      build_ycc_rgb_table(cinfo);
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
      cinfo->out_color_components = cinfo->num_components;
      cconvert->pub.color_convert = null_convert;
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
  }

  if (cinfo->quantize_colors)
    cinfo->output_components = 1; /* single colormapped output component */
  else
    cinfo->output_components = cinfo->out_color_components;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdhuff.c ===
/*
 * jdhuff.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy decoding routines.
 *
 * Much of the complexity here has to do with supporting input suspension.
 * If the data source module demands suspension, we want to be able to back
 * up to the start of the current MCU.  To do this, we copy state variables
 * into local working storage, and update them back to the permanent
 * storage only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdhuff.h"		/* Declarations shared with jdphuff.c */


/*
 * Expanded entropy decoder object for Huffman decoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_decoder pub; /* public fields */

  /* These fields are loaded into local variables at start of each MCU.
   * In case of suspension, we exit WITHOUT updating them.
   */
  bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
  savable_state saved;		/* Other state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
} huff_entropy_decoder;

typedef huff_entropy_decoder * huff_entropy_ptr;


/*
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;

  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
   * This ought to be an error condition, but we make it a warning because
   * there are some baseline files out there with all zeroes in these bytes.
   */
  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
      cinfo->Ah != 0 || cinfo->Al != 0)
    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    /* Make sure requested tables are present */
    if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS ||
	cinfo->dc_huff_tbl_ptrs[dctbl] == NULL)
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
    if (actbl < 0 || actbl >= NUM_HUFF_TBLS ||
	cinfo->ac_huff_tbl_ptrs[actbl] == NULL)
      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
    /* Compute derived values for Huffman tables */
    /* We may do this more than once for a table, but it's not expensive */
    jpeg_make_d_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[dctbl],
			    & entropy->dc_derived_tbls[dctbl]);
    jpeg_make_d_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[actbl],
			    & entropy->ac_derived_tbls[actbl]);
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->bitstate.printed_eod = FALSE;

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
}


/*
 * Compute the derived values for a Huffman table.
 * Note this is also used by jdphuff.c.
 */

GLOBAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, JHUFF_TBL * htbl,
			 d_derived_tbl ** pdtbl)
{
  d_derived_tbl *dtbl;
  int p, i, l, si;
  int lookbits, ctr;
  char huffsize[257];
  unsigned int huffcode[257];
  unsigned int code;

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
  dtbl->pub = htbl;		/* fill in back link */
  
  /* Figure C.1: make table of Huffman code length for each symbol */
  /* Note that this is in code-length order. */

  p = 0;
  for (l = 1; l <= 16; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
  
  /* Figure C.2: generate the codes themselves */
  /* Note that this is in code-length order. */
  
  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
      code++;
    }
    code <<= 1;
    si++;
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
      dtbl->valptr[l] = p; /* huffval[] index of 1st symbol of code length l */
      dtbl->mincode[l] = huffcode[p]; /* minimum code of length l */
      p += htbl->bits[l];
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */

  /* Compute lookahead tables to speed up decoding.
   * First we set all the table entries to 0, indicating "too long";
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
	dtbl->look_nbits[lookbits] = l;
	dtbl->look_sym[lookbits] = htbl->huffval[p];
	lookbits++;
      }
    }
  }
}


/*
 * Out-of-line code for bit fetching (shared with jdphuff.c).
 * See jdhuff.h for info about usage.
 * Note: current values of get_buffer and bits_left are passed as parameters,
 * but are returned in the corresponding fields of the state struct.
 *
 * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
 * of get_buffer to be used.  (On machines with wider words, an even larger
 * buffer could be used.)  However, on some machines 32-bit shifts are
 * quite slow and take time proportional to the number of places shifted.
 * (This is true with most PC compilers, for instance.)  In this case it may
 * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
 * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
 */

#ifdef SLOW_SHIFT_32
#define MIN_GET_BITS  15	/* minimum allowable value */
#else
#define MIN_GET_BITS  (BIT_BUF_SIZE-7)
#endif


GLOBAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
  register size_t bytes_in_buffer = state->bytes_in_buffer;
  register int c;

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */

  while (bits_left < MIN_GET_BITS) {
    /* Attempt to read a byte */
    if (state->unread_marker != 0)
      goto no_more_data;	/* can't advance past a marker */

    if (bytes_in_buffer == 0) {
      if (! (*state->cinfo->src->fill_input_buffer) (state->cinfo))
	return FALSE;
      next_input_byte = state->cinfo->src->next_input_byte;
      bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c = GETJOCTET(*next_input_byte++);

    /* If it's 0xFF, check and discard stuffed zero byte */
    if (c == 0xFF) {
      do {
	if (bytes_in_buffer == 0) {
	  if (! (*state->cinfo->src->fill_input_buffer) (state->cinfo))
	    return FALSE;
	  next_input_byte = state->cinfo->src->next_input_byte;
	  bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
	}
	bytes_in_buffer--;
	c = GETJOCTET(*next_input_byte++);
      } while (c == 0xFF);

      if (c == 0) {
	/* Found FF/00, which represents an FF data byte */
	c = 0xFF;
      } else {
	/* Oops, it's actually a marker indicating end of compressed data. */
	/* Better put it back for use later */
	state->unread_marker = c;

      no_more_data:
	/* There should be enough bits still left in the data segment; */
	/* if so, just break out of the outer while loop. */
	if (bits_left >= nbits)
	  break;
	/* Uh-oh.  Report corrupted data to user and stuff zeroes into
	 * the data stream, so that we can produce some kind of image.
	 * Note that this code will be repeated for each byte demanded
	 * for the rest of the segment.  We use a nonvolatile flag to ensure
	 * that only one warning message appears.
	 */
	if (! *(state->printed_eod_ptr)) {
	  WARNMS(state->cinfo, JWRN_HIT_MARKER);
	  *(state->printed_eod_ptr) = TRUE;
	}
	c = 0;			/* insert a zero byte into bit buffer */
      }
    }

    /* OK, load c into get_buffer */
    get_buffer = (get_buffer << 8) | c;
    bits_left += 8;
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
  state->bytes_in_buffer = bytes_in_buffer;
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  return TRUE;
}


/*
 * Out-of-line code for Huffman code decoding.
 * See jdhuff.h for info about usage.
 */

GLOBAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
  register int l = min_bits;
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
  code = GET_BITS(l);

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
    code <<= 1;
    CHECK_BIT_BUFFER(*state, 1, return -1);
    code |= GET_BITS(1);
    l++;
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
  state->bits_left = bits_left;

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
    return 0;			/* fake a zero as the safest result */
  }

  return htbl->pub->huffval[ htbl->valptr[l] +
			    ((int) (code - htbl->mincode[l])) ];
}


/*
 * Figure F.12: extend sign bit.
 * On some machines, a shift and add will be faster than a table lookup.
 */

#ifdef AVOID_TABLES

#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#else

#define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))

static const int extend_test[16] =   /* entry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#endif /* AVOID_TABLES */


/*
 * Check for a restart marker & resynchronize decoder.
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
  entropy->bitstate.bits_left = 0;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    entropy->saved.last_dc_val[ci] = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;

  /* Next segment can get another out-of-data warning */
  entropy->bitstate.printed_eod = FALSE;

  return TRUE;
}


/*
 * Decode and return one MCU's worth of Huffman-compressed coefficients.
 * The coefficients are reordered from zigzag order into natural array order,
 * but are not dequantized.
 *
 * The i'th block of the MCU is stored into the block pointed to by
 * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
 * (Wholesale zeroing is usually a little faster than retail...)
 *
 * Returns FALSE if data source requested suspension.  In that case no
 * changes have been made to permanent state.  (Exception: some output
 * coefficients may already have been assigned.  This is harmless for
 * this module, since we'll just re-assign them on the next call.)
 */

METHODDEF(boolean)
__cdecl decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  register int s, k, r;
  int blkn, ci;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  savable_state state;
  d_derived_tbl * dctbl;
  d_derived_tbl * actbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(state, entropy->saved);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    dctbl = entropy->dc_derived_tbls[compptr->dc_tbl_no];
    actbl = entropy->ac_derived_tbls[compptr->ac_tbl_no];

    /* Decode a single block's worth of coefficients */

    /* Section F.2.2.1: decode the DC coefficient difference */
    HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
    if (s) {
      CHECK_BIT_BUFFER(br_state, s, return FALSE);
      r = GET_BITS(s);
      s = HUFF_EXTEND(r, s);
    }

    /* Shortcut if component's values are not interesting */
    if (! compptr->component_needed)
      goto skip_ACs;

    /* Convert DC difference to actual value, update last_dc_val */
    s += state.last_dc_val[ci];
    state.last_dc_val[ci] = s;
    /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
    (*block)[0] = (JCOEF) s;

    /* Do we need to decode the AC coefficients for this component? */
    if (compptr->DCT_scaled_size > 1) {

      /* Section F.2.2.2: decode the AC coefficients */
      /* Since zeroes are skipped, output area must be cleared beforehand */
      for (k = 1; k < DCTSIZE2; k++) {
	HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
      
	r = s >> 4;
	s &= 15;
      
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	  /* Output coefficient in natural (dezigzagged) order.
	   * Note: the extra entries in jpeg_natural_order[] will save us
	   * if k >= DCTSIZE2, which could happen if the data is corrupted.
	   */
	  (*block)[jpeg_natural_order[k]] = (JCOEF) s;
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

    } else {
skip_ACs:

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (k = 1; k < DCTSIZE2; k++) {
	HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
      
	r = s >> 4;
	s &= 15;
      
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  DROP_BITS(s);
	} else {
	  if (r != 15)
	    break;
	  k += 15;
	}
      }

    }
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(entropy->saved, state);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_huff_decoder;
  entropy->pub.decode_mcu = decode_mcu;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jddctmgr.c ===
/*
 * jddctmgr.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the inverse-DCT management logic.
 * This code selects a particular IDCT implementation to be used,
 * and it performs related housekeeping chores.  No code in this file
 * is executed per IDCT step, only during output pass setup.
 *
 * Note that the IDCT routines are responsible for performing coefficient
 * dequantization as well as the IDCT proper.  This module sets up the
 * dequantization multiplier table needed by the IDCT routine.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */


/*
 * The decompressor input side (jdinput.c) saves away the appropriate
 * quantization table for each component at the start of the first scan
 * involving that component.  (This is necessary in order to correctly
 * decode files that reuse Q-table slots.)
 * When we are ready to make an output pass, the saved Q-table is converted
 * to a multiplier table that will actually be used by the IDCT routine.
 * The multiplier table contents are IDCT-method-dependent.  To support
 * application changes in IDCT method between scans, we can remake the
 * multiplier tables if necessary.
 * In buffered-image mode, the first output pass may occur before any data
 * has been seen for some components, and thus before their Q-tables have
 * been saved away.  To handle this case, multiplier tables are preset
 * to zeroes; the result of the IDCT will be a neutral gray level.
 */


/* Private subobject for this module */

typedef struct {
  struct jpeg_inverse_dct pub;	/* public fields */

  /* This array contains the IDCT method code that each multiplier table
   * is currently set up for, or -1 if it's not yet set up.
   * The actual multiplier tables are pointed to by dct_table in the
   * per-component comp_info structures.
   */
  int cur_method[MAX_COMPONENTS];
} my_idct_controller;

typedef my_idct_controller * my_idct_ptr;


/* Allocated multiplier tables: big enough for any supported variant */

typedef union {
  ISLOW_MULT_TYPE islow_array[DCTSIZE2];
#ifdef DCT_IFAST_SUPPORTED
  IFAST_MULT_TYPE ifast_array[DCTSIZE2];
#endif
#ifdef DCT_FLOAT_SUPPORTED
  FLOAT_MULT_TYPE float_array[DCTSIZE2];
#endif
} multiplier_table;


/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
 * so be sure to compile that code if either ISLOW or SCALING is requested.
 */
#ifdef DCT_ISLOW_SUPPORTED
#define PROVIDE_ISLOW_TABLES
#else
#ifdef IDCT_SCALING_SUPPORTED
#define PROVIDE_ISLOW_TABLES
#endif
#endif


/*
 * Prepare for an output pass.
 * Here we select the proper IDCT routine for each component and build
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
  int ci, i;
  jpeg_component_info *compptr;
  int method = 0;
  inverse_DCT_method_ptr method_ptr = NULL;
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch (compptr->DCT_scaled_size) {
#ifdef IDCT_SCALING_SUPPORTED
    case 1:
      method_ptr = jpeg_idct_1x1;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
    case 2:
      method_ptr = jpeg_idct_2x2;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
    case 4:
      method_ptr = jpeg_idct_4x4;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
#endif
    case DCTSIZE:
      switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
      case JDCT_ISLOW:
	method_ptr = jpeg_idct_islow;
	method = JDCT_ISLOW;
	break;
#endif
#ifdef DCT_IFAST_SUPPORTED
      case JDCT_IFAST:
	method_ptr = jpeg_idct_ifast;
	method = JDCT_IFAST;
	break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
      case JDCT_FLOAT:
	method_ptr = jpeg_idct_float;
	method = JDCT_FLOAT;
	break;
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
	break;
      }
      break;
    default:
      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
      break;
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
    /* Create multiplier table from quant table.
     * However, we can skip this if the component is uninteresting
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
      continue;
    qtbl = compptr->quant_table;
    if (qtbl == NULL)		/* happens if no data yet for component */
      continue;
    idct->cur_method[ci] = method;
    switch (method) {
#ifdef PROVIDE_ISLOW_TABLES
    case JDCT_ISLOW:
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
	for (i = 0; i < DCTSIZE2; i++) {
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
	}
      }
      break;
#endif
#ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST:
      {
	/* For AA&N IDCT method, multipliers are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * For integer operation, the multiplier table is to be scaled by
	 * IFAST_SCALE_BITS.
	 */
	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
#define CONST_BITS 14
	static const INT16 aanscales[DCTSIZE2] = {
	  /* precomputed values scaled up by 14 bits */
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
	  ifmtbl[i] = (IFAST_MULT_TYPE)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
				  (INT32) aanscales[i]),
		    CONST_BITS-IFAST_SCALE_BITS);
	}
      }
      break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
      {
	/* For float AA&N IDCT method, multipliers are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 */
	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
	int row, col;
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	i = 0;
	for (row = 0; row < DCTSIZE; row++) {
	  for (col = 0; col < DCTSIZE; col++) {
	    fmtbl[i] = (FLOAT_MULT_TYPE)
	      ((double) qtbl->quantval[i] *
	       aanscalefactor[row] * aanscalefactor[col]);
	    i++;
	  }
	}
      }
      break;
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
      break;
    }
  }
}


/*
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
  idct->pub.start_pass = start_pass;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdct.h ===
/*
 * jdct.h
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This include file contains common declarations for the forward and
 * inverse DCT modules.  These declarations are private to the DCT managers
 * (jcdctmgr.c, jddctmgr.c) and the individual DCT algorithms.
 * The individual DCT algorithms are kept in separate files to ease 
 * machine-dependent tuning (e.g., assembly coding).
 */


/*
 * A forward DCT routine is given a pointer to a work area of type DCTELEM[];
 * the DCT is to be performed in-place in that buffer.  Type DCTELEM is int
 * for 8-bit samples, INT32 for 12-bit samples.  (NOTE: Floating-point DCT
 * implementations use an array of type FAST_FLOAT, instead.)
 * The DCT inputs are expected to be signed (range +-CENTERJSAMPLE).
 * The DCT outputs are returned scaled up by a factor of 8; they therefore
 * have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
 * convention improves accuracy in integer implementations and saves some
 * work in floating-point ones.
 * Quantization of the output coefficients is done by jcdctmgr.c.
 */

#if BITS_IN_JSAMPLE == 8
typedef int DCTELEM;		/* 16 or 32 bits is fine */
#else
typedef INT32 DCTELEM;		/* must have 32 bits */
#endif

typedef JMETHOD(void, forward_DCT_method_ptr, (DCTELEM * data));
typedef JMETHOD(void, float_DCT_method_ptr, (FAST_FLOAT * data));


/*
 * An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
 * to an output sample array.  The routine must dequantize the input data as
 * well as perform the IDCT; for dequantization, it uses the multiplier table
 * pointed to by compptr->dct_table.  The output data is to be placed into the
 * sample array starting at a specified column.  (Any row offset needed will
 * be applied to the array pointer before it is passed to the IDCT code.)
 * Note that the number of samples emitted by the IDCT routine is
 * DCT_scaled_size * DCT_scaled_size.
 */

/* typedef inverse_DCT_method_ptr is declared in jpegint.h */

/*
 * Each IDCT routine has its own ideas about the best dct_table element type.
 */

typedef MULTIPLIER ISLOW_MULT_TYPE; /* short or int, whichever is faster */
#if BITS_IN_JSAMPLE == 8
typedef MULTIPLIER IFAST_MULT_TYPE; /* 16 bits is OK, use short if faster */
#define IFAST_SCALE_BITS  2	/* fractional bits in scale factors */
#else
typedef INT32 IFAST_MULT_TYPE;	/* need 32 bits for scaled quantizers */
#define IFAST_SCALE_BITS  13	/* fractional bits in scale factors */
#endif
typedef FAST_FLOAT FLOAT_MULT_TYPE; /* preferred floating type */


/*
 * Each IDCT routine is responsible for range-limiting its results and
 * converting them to unsigned form (0..MAXJSAMPLE).  The raw outputs could
 * be quite far out of range if the input data is corrupt, so a bulletproof
 * range-limiting step is required.  We use a mask-and-table-lookup method
 * to do the combined operations quickly.  See the comments with
 * prepare_range_limit_table (in jdmaster.c) for more info.
 */

#define IDCT_range_limit(cinfo)  ((cinfo)->sample_range_limit + CENTERJSAMPLE)

#define RANGE_MASK  (MAXJSAMPLE * 4 + 3) /* 2 bits wider than legal samples */


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_fdct_islow		jFDislow
#define jpeg_fdct_ifast		jFDifast
#define jpeg_fdct_float		jFDfloat
#define jpeg_idct_islow		jRDislow
#define jpeg_idct_ifast		jRDifast
#define jpeg_idct_float		jRDfloat
#define jpeg_idct_4x4		jRD4x4
#define jpeg_idct_2x2		jRD2x2
#define jpeg_idct_1x1		jRD1x1
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Extern declarations for the forward and inverse DCT routines. */

EXTERN(void) jpeg_fdct_islow JPP((DCTELEM * data));
EXTERN(void) jpeg_fdct_ifast JPP((DCTELEM * data));
EXTERN(void) jpeg_fdct_float JPP((FAST_FLOAT * data));

EXTERN(void) jpeg_idct_islow
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_ifast
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_float
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_4x4
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_2x2
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
EXTERN(void) jpeg_idct_1x1
    JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));


/*
 * Macros for handling fixed-point arithmetic; these are used by many
 * but not all of the DCT/IDCT modules.
 *
 * All values are expected to be of type INT32.
 * Fractional constants are scaled left by CONST_BITS bits.
 * CONST_BITS is defined within each module using these macros,
 * and may differ from one module to the next.
 */

#define ONE	((INT32) 1)
#define CONST_SCALE (ONE << CONST_BITS)

/* Convert a positive real constant to an integer scaled by CONST_SCALE.
 * Caution: some C compilers fail to reduce "FIX(constant)" at compile time,
 * thus causing a lot of useless floating-point operations at run time.
 */

#define FIX(x)	((INT32) ((x) * CONST_SCALE + 0.5))

/* Descale and correctly round an INT32 value that's scaled by N bits.
 * We assume RIGHT_SHIFT rounds towards minus infinity, so adding
 * the fudge factor is correct for either sign of X.
 */

#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)

/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * This macro is used only when the two inputs will actually be no more than
 * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a
 * full 32x32 multiply.  This provides a useful speedup on many machines.
 * Unfortunately there is no way to specify a 16x16->32 multiply portably
 * in C, but some C compilers will do the right thing if you provide the
 * correct combination of casts.
 */

#ifdef SHORTxSHORT_32		/* may work if 'int' is 32 bits */
#define MULTIPLY16C16(var,const)  (((INT16) (var)) * ((INT16) (const)))
#endif
#ifdef SHORTxLCONST_32		/* known to work with Microsoft C 6.0 */
#define MULTIPLY16C16(var,const)  (((INT16) (var)) * ((INT32) (const)))
#endif

#ifndef MULTIPLY16C16		/* default definition */
#define MULTIPLY16C16(var,const)  ((var) * (const))
#endif

/* Same except both inputs are variables. */

#ifdef SHORTxSHORT_32		/* may work if 'int' is 32 bits */
#define MULTIPLY16V16(var1,var2)  (((INT16) (var1)) * ((INT16) (var2)))
#endif

#ifndef MULTIPLY16V16		/* default definition */
#define MULTIPLY16V16(var1,var2)  ((var1) * (var2))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdhuff.h ===
/*
 * jdhuff.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains declarations for Huffman entropy decoding routines
 * that are shared between the sequential decoder (jdhuff.c) and the
 * progressive decoder (jdphuff.c).  No other modules need to see these.
 */

/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_make_d_derived_tbl	jMkDDerived
#define jpeg_fill_bit_buffer	jFilBitBuf
#define jpeg_huff_decode	jHufDecode
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Derived data constructed for each Huffman table */

#define HUFF_LOOKAHEAD	8	/* # of bits of lookahead */

typedef struct {
  /* Basic tables: (element [0] of each array is unused) */
  INT32 mincode[17];		/* smallest code of length k */
  INT32 maxcode[18];		/* largest code of length k (-1 if none) */
  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
  int valptr[17];		/* huffval[] index of 1st symbol of length k */

  /* Link to public Huffman table (needed only in jpeg_huff_decode) */
  JHUFF_TBL *pub;

  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
   * the input data stream.  If the next Huffman code is no more
   * than HUFF_LOOKAHEAD bits long, we can obtain its length and
   * the corresponding symbol directly from these tables.
   */
  int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
  UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */
} d_derived_tbl;

/* Expand a Huffman table definition into the derived format */
EXTERN(void) jpeg_make_d_derived_tbl JPP((j_decompress_ptr cinfo,
				JHUFF_TBL * htbl, d_derived_tbl ** pdtbl));


/*
 * Fetching the next N bits from the input stream is a time-critical operation
 * for the Huffman decoders.  We implement it with a combination of inline
 * macros and out-of-line subroutines.  Note that N (the number of bits
 * demanded at one time) never exceeds 15 for JPEG use.
 *
 * We read source bytes into get_buffer and dole out bits as needed.
 * If get_buffer already contains enough bits, they are fetched in-line
 * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough
 * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
 * as full as possible (not just to the number of bits needed; this
 * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
 * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
 * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
 * at least the requested number of bits --- dummy zeroes are inserted if
 * necessary.
 */

typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
#define BIT_BUF_SIZE  32	/* size of buffer in bits */
typedef __int64 bit_buf_type_64;	/* type of bit-extraction buffer */
#define BIT_BUF_SIZE_64  64	/* size of buffer in bits */

/* If long is > 32 bits on your machine, and shifting/masking longs is
 * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
 * appropriately should be a win.  Unfortunately we can't do this with
 * something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
 * because not all machines measure sizeof in 8-bit bytes.
 */

typedef struct {		/* Bitreading state saved across MCUs */
  bit_buf_type_64 get_buffer_64;	/* MMX current bit-extraction buffer */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
  boolean printed_eod;		/* flag to suppress multiple warning msgs */
} bitread_perm_state;

typedef struct {		/* Bitreading working state within an MCU */
  /* current data source state */
  const JOCTET * next_input_byte; /* => next byte to read from source */
  size_t bytes_in_buffer;	/* # of bytes remaining in source buffer */
  int unread_marker;		/* nonzero if we have hit a marker */
  /* bit input buffer --- note these values are kept in register variables,
   * not in this struct, inside the inner loops.
   */
  bit_buf_type get_buffer;	/* current bit-extraction buffer */
  bit_buf_type_64 get_buffer_64;	/* MMX current bit-extraction buffer */
  int bits_left;		/* # of unused bits in it */
  /* pointers needed by jpeg_fill_bit_buffer */
  j_decompress_ptr cinfo;	/* back link to decompress master record */
  boolean * printed_eod_ptr;	/* => flag in permanent state */
} bitread_working_state;
// these BITREAD MACROS are only called in decode_mcu, but not by MMX routine
// not aware of MMX get_buffer
/* Macros to declare and load/save bitread local variables. */
#define BITREAD_STATE_VARS  \
	register bit_buf_type get_buffer;  \
	register int bits_left;  \
	bitread_working_state br_state

#define BITREAD_LOAD_STATE(cinfop,permstate)  \
	br_state.cinfo = cinfop; \
	br_state.next_input_byte = cinfop->src->next_input_byte; \
	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
	br_state.unread_marker = cinfop->unread_marker; \
	get_buffer = permstate.get_buffer; \
	bits_left = permstate.bits_left; \
	br_state.printed_eod_ptr = & permstate.printed_eod

#define BITREAD_SAVE_STATE(cinfop,permstate)  \
	cinfop->src->next_input_byte = br_state.next_input_byte; \
	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
	cinfop->unread_marker = br_state.unread_marker; \
	permstate.get_buffer = get_buffer; \
	permstate.bits_left = bits_left

/*
 * These macros provide the in-line portion of bit fetching.
 * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
 * before using GET_BITS, PEEK_BITS, or DROP_BITS.
 * The variables get_buffer and bits_left are assumed to be locals,
 * but the state struct might not be (jpeg_huff_decode needs this).
 *	CHECK_BIT_BUFFER(state,n,action);
 *		Ensure there are N bits in get_buffer; if suspend, take action.
 *      val = GET_BITS(n);
 *		Fetch next N bits.
 *      val = PEEK_BITS(n);
 *		Fetch next N bits without removing them from the buffer.
 *	DROP_BITS(n);
 *		Discard next N bits.
 * The value N should be a simple variable, not an expression, because it
 * is evaluated multiple times.
 */
// these macros are only called in non-MMX version of jpeg_huff_decoder and
// decode_mcu -- no changes made here, not aware of MMX get_buffer
#define CHECK_BIT_BUFFER(state,nbits,action) \
	{ if (bits_left < (nbits)) {  \
	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \
	      { action; }  \
	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }

#define GET_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -= (nbits)))) & ((1<<(nbits))-1))

#define PEEK_BITS(nbits) \
	(((int) (get_buffer >> (bits_left -  (nbits)))) & ((1<<(nbits))-1))

#define DROP_BITS(nbits) \
	(bits_left -= (nbits))

/* Load up the bit buffer to a depth of at least nbits */
EXTERN(boolean) jpeg_fill_bit_buffer
	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
	     register int bits_left, int nbits));


/*
 * Code for extracting next Huffman-coded symbol from input bit stream.
 * Again, this is time-critical and we make the main paths be macros.
 *
 * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
 * without looping.  Usually, more than 95% of the Huffman codes will be 8
 * or fewer bits long.  The few overlength codes are handled with a loop,
 * which need not be inline code.
 *
 * Notes about the HUFF_DECODE macro:
 * 1. Near the end of the data segment, we may fail to get enough bits
 *    for a lookahead.  In that case, we do it the hard way.
 * 2. If the lookahead table contains no entry, the next code must be
 *    more than HUFF_LOOKAHEAD bits long.
 * 3. jpeg_huff_decode returns -1 if forced to suspend.
 */
// not called by MMX code -- not aware of MMX get_buffer
#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
{ register int nb, look; \
  if (bits_left < HUFF_LOOKAHEAD) { \
    if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
    if (bits_left < HUFF_LOOKAHEAD) { \
      nb = 1; goto slowlabel; \
    } \
  } \
  look = PEEK_BITS(HUFF_LOOKAHEAD); \
  if ((nb = htbl->look_nbits[look]) != 0) { \
    DROP_BITS(nb); \
    result = htbl->look_sym[look]; \
  } else { \
    nb = HUFF_LOOKAHEAD+1; \
slowlabel: \
    if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
	{ failaction; } \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
  } \
}

/* Out-of-line case for Huffman code fetching */
EXTERN(int) jpeg_huff_decode
	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
	     register int bits_left, d_derived_tbl * htbl, int min_bits));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdinput.c ===
/*
 * jdinput.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains input control logic for the JPEG decompressor.
 * These routines are concerned with controlling the decompressor's input
 * processing (marker reading and coefficient decoding).  The actual input
 * reading is done in jdmarker.c, jdhuff.c, and jdphuff.c.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Private state */

typedef struct {
  struct jpeg_input_controller pub; /* public fields */

  boolean inheaders;		/* TRUE until first SOS is reached */
} my_input_controller;

typedef my_input_controller * my_inputctl_ptr;


/* Forward declarations */
METHODDEF(int) consume_markers JPP((j_decompress_ptr cinfo));


/*
 * Routines to calculate various quantities related to the size of the image.
 */

LOCAL(void)
initial_setup (j_decompress_ptr cinfo)
/* Called once, when first SOS marker is reached */
{
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
				   compptr->v_samp_factor);
  }

  /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
   * In the full decompressor, this will be overridden by jdmaster.c;
   * but in the transcoder, jdmaster.c is not used, so we must do it here.
   */
  cinfo->min_DCT_scaled_size = DCTSIZE;

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->DCT_scaled_size = DCTSIZE;
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
    /* downsampled_width and downsampled_height will also be overridden by
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) cinfo->max_v_samp_factor);
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
		  (long) (cinfo->max_v_samp_factor*DCTSIZE));

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
    cinfo->inputctl->has_multiple_scans = TRUE;
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
}


LOCAL(void)
per_scan_setup (j_decompress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
    compptr->MCU_height = 1;
    compptr->MCU_blocks = 1;
    compptr->MCU_sample_width = compptr->DCT_scaled_size;
    compptr->last_col_width = 1;
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
    if (tmp == 0) tmp = compptr->v_samp_factor;
    compptr->last_row_height = tmp;
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
    cinfo->MCU_membership[0] = 0;
    
  } else {
    
    /* Interleaved (multi-component) scan */
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
	       MAX_COMPS_IN_SCAN);
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width,
		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
    cinfo->MCU_rows_in_scan = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height,
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
    
    cinfo->blocks_in_MCU = 0;
    
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
      /* Sampling factors give # of blocks of component in each MCU */
      compptr->MCU_width = compptr->h_samp_factor;
      compptr->MCU_height = compptr->v_samp_factor;
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
      /* Figure number of non-dummy blocks in last MCU column & row */
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
      if (tmp == 0) tmp = compptr->MCU_width;
      compptr->last_col_width = tmp;
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
      if (tmp == 0) tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
      while (mcublks-- > 0) {
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }
}


/*
 * Save away a copy of the Q-table referenced by each component present
 * in the current scan, unless already saved during a prior scan.
 *
 * In a multiple-scan JPEG file, the encoder could assign different components
 * the same Q-table slot number, but change table definitions between scans
 * so that each component uses a different Q-table.  (The IJG encoder is not
 * currently capable of doing this, but other encoders might.)  Since we want
 * to be able to dequantize all the components at the end of the file, this
 * means that we have to save away the table actually used for each component.
 * We do this by copying the table at the start of the first scan containing
 * the component.
 * The JPEG spec prohibits the encoder from changing the contents of a Q-table
 * slot between scans of a component using that slot.  If the encoder does so
 * anyway, this decoder will simply use the Q-table values that were current
 * at the start of the first scan for the component.
 *
 * The decompressor output side looks only at the saved quant tables,
 * not at the current Q-table slots.
 */

LOCAL(void)
latch_quant_tables (j_decompress_ptr cinfo)
{
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    compptr->quant_table = qtbl;
  }
}


/*
 * Initialize the input modules to read a scan of compressed data.
 * The first call to this is done by jdmaster.c after initializing
 * the entire decompressor (during jpeg_start_decompress).
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  per_scan_setup(cinfo);
  latch_quant_tables(cinfo);
  (*cinfo->entropy->start_pass) (cinfo);
  (*cinfo->coef->start_input_pass) (cinfo);
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
}


/*
 * Finish up after inputting a compressed-data scan.
 * This is called by the coefficient controller after it's read all
 * the expected data of the scan.
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
}


/*
 * Read JPEG markers before, between, or after compressed-data scans.
 * Change state as necessary when a new scan is reached.
 * Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 *
 * The consume_input method pointer points either here or to the
 * coefficient controller's consume_data routine, depending on whether
 * we are reading a compressed data segment or inter-segment markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
    return JPEG_REACHED_EOI;

  val = (*cinfo->marker->read_markers) (cinfo);

  switch (val) {
  case JPEG_REACHED_SOS:	/* Found SOS */
    if (inputctl->inheaders) {	/* 1st SOS */
      initial_setup(cinfo);
      inputctl->inheaders = FALSE;
      /* Note: start_input_pass must be called by jdmaster.c
       * before any more input can be consumed.  jdapi.c is
       * responsible for enforcing this sequencing.
       */
    } else {			/* 2nd or later SOS marker */
      if (! inputctl->pub.has_multiple_scans)
	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
      start_input_pass(cinfo);
    }
    break;
  case JPEG_REACHED_EOI:	/* Found EOI */
    inputctl->pub.eoi_reached = TRUE;
    if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
      if (cinfo->marker->saw_SOF)
	ERREXIT(cinfo, JERR_SOF_NO_SOS);
    } else {
      /* Prevent infinite loop in coef ctlr's decompress_data routine
       * if user set output_scan_number larger than number of scans.
       */
      if (cinfo->output_scan_number > cinfo->input_scan_number)
	cinfo->output_scan_number = cinfo->input_scan_number;
    }
    break;
  case JPEG_SUSPENDED:
    break;
  }

  return val;
}


/*
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;

  inputctl->pub.consume_input = consume_markers;
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
  inputctl->pub.eoi_reached = FALSE;
  inputctl->inheaders = TRUE;
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->marker->reset_marker_reader) (cinfo);
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
}


/*
 * Initialize the input controller module.
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
  inputctl->pub.reset_input_controller = reset_input_controller;
  inputctl->pub.start_input_pass = start_input_pass;
  inputctl->pub.finish_input_pass = finish_input_pass;
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
  inputctl->pub.eoi_reached = FALSE;
  inputctl->inheaders = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdmarker.c ===
/*
 * jdmarker.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to decode JPEG datastream markers.
 * Most of the complexity arises from our desire to support input
 * suspension: if not all of the data for a marker is available,
 * we must exit back to the application.  On resumption, we reprocess
 * the marker.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;


/*
 * Macros for fetching data from the data source module.
 *
 * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect
 * the current restart point; we update them only when we have reached a
 * suitable place to restart if a suspension occurs.
 */

/* Declare and initialize local copies of input pointer/count */
#define INPUT_VARS(cinfo)  \
	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
	size_t bytes_in_buffer = datasrc->bytes_in_buffer

/* Unload the local copies --- do this only at a restart boundary */
#define INPUT_SYNC(cinfo)  \
	( datasrc->next_input_byte = next_input_byte,  \
	  datasrc->bytes_in_buffer = bytes_in_buffer )

/* Reload the local copies --- seldom used except in MAKE_BYTE_AVAIL */
#define INPUT_RELOAD(cinfo)  \
	( next_input_byte = datasrc->next_input_byte,  \
	  bytes_in_buffer = datasrc->bytes_in_buffer )

/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.
 * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,
 * but we must reload the local copies after a successful fill.
 */
#define MAKE_BYTE_AVAIL(cinfo,action)  \
	if (bytes_in_buffer == 0) {  \
	  if (! (*datasrc->fill_input_buffer) (cinfo))  \
	    { action; }  \
	  INPUT_RELOAD(cinfo);  \
	}  \
	bytes_in_buffer--

/* Read a byte into variable V.
 * If must suspend, take the specified action (typically "return FALSE").
 */
#define INPUT_BYTE(cinfo,V,action)  \
	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
		  V = GETJOCTET(*next_input_byte++); )

/* As above, but read two bytes interpreted as an unsigned 16-bit integer.
 * V should be declared unsigned int or perhaps INT32.
 */
#define INPUT_2BYTES(cinfo,V,action)  \
	MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
		  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \
		  MAKE_BYTE_AVAIL(cinfo,action); \
		  V += GETJOCTET(*next_input_byte++); )


/*
 * Routines to process JPEG markers.
 *
 * Entry condition: JPEG marker itself has been read and its code saved
 *   in cinfo->unread_marker; input restart point is just after the marker.
 *
 * Exit: if return TRUE, have read and processed any parameters, and have
 *   updated the restart point to point after the parameters.
 *   If return FALSE, was forced to suspend before reaching end of
 *   marker parameters; restart point has not been moved.  Same routine
 *   will be called again after application supplies more input data.
 *
 * This approach to suspension assumes that all of a marker's parameters can
 * fit into a single input bufferload.  This should hold for "normal"
 * markers.  Some COM/APPn markers might have large parameter segments,
 * but we use skip_input_data to get past those, and thereby put the problem
 * on the source manager's shoulders.
 *
 * Note that we don't bother to avoid duplicate trace messages if a
 * suspension occurs within marker parameters.  Other side effects
 * require more care.
 */


LOCAL(boolean)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
  int i;
  
  TRACEMS(cinfo, 1, JTRC_SOI);

  if (cinfo->marker->saw_SOI)
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }
  cinfo->restart_interval = 0;

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */

  cinfo->saw_JFIF_marker = FALSE;
  cinfo->density_unit = 0;	/* set default JFIF APP0 values */
  cinfo->X_density = 1;
  cinfo->Y_density = 1;
  cinfo->saw_Adobe_marker = FALSE;
  cinfo->Adobe_transform = 0;

  cinfo->marker->saw_SOI = TRUE;

  return TRUE;
}


LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
/* Process a SOFn marker */
{
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);

  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);

  length -= 8;

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
      || cinfo->num_components <= 0)
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);

  if (length != (cinfo->num_components * 3))
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));
  
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->component_index = ci;
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);
    compptr->h_samp_factor = (c >> 4) & 15;
    compptr->v_samp_factor = (c     ) & 15;
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);

  if (! cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOS_NO_SOF);

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */

  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  TRACEMS1(cinfo, 1, JTRC_SOS, n);

  cinfo->comps_in_scan = n;

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);
    
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      if (cc == compptr->component_id)
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);

  id_found:

    cinfo->cur_comp_info[i] = compptr;
    compptr->dc_tbl_no = (c >> 4) & 15;
    compptr->ac_tbl_no = (c     ) & 15;
    
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Ss = c;
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Se = c;
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Ah = (c >> 4) & 15;
  cinfo->Al = (c     ) & 15;

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;

  /* Count another SOS marker */
  cinfo->input_scan_number++;

  INPUT_SYNC(cinfo);
  return TRUE;
}


METHODDEF(boolean)
get_app0 (j_decompress_ptr cinfo)
/* Process an APP0 marker */
{
#define JFIF_LEN 14
  INT32 length;
  UINT8 b[JFIF_LEN];
  int buffp;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  /* See if a JFIF APP0 marker is present */

  if (length >= JFIF_LEN) {
    for (buffp = 0; buffp < JFIF_LEN; buffp++)
      INPUT_BYTE(cinfo, b[buffp], return FALSE);
    length -= JFIF_LEN;

    if (b[0]==0x4A && b[1]==0x46 && b[2]==0x49 && b[3]==0x46 && b[4]==0) {
      /* Found JFIF APP0 marker: check version */
      /* Major version must be 1, anything else signals an incompatible change.
       * We used to treat this as an error, but now it's a nonfatal warning,
       * Minor version should be 0..2, but process anyway if newer.
       */
      if (b[5] != 1)
	WARNMS2(cinfo, JWRN_JFIF_MAJOR, b[5], b[6]);
      else if (b[6] > 2)
	TRACEMS2(cinfo, 1, JTRC_JFIF_MINOR, b[5], b[6]);
      /* Save info */
      cinfo->saw_JFIF_marker = TRUE;
      cinfo->density_unit = b[7];
      cinfo->X_density = (b[8] << 8) + b[9];
      cinfo->Y_density = (b[10] << 8) + b[11];
      TRACEMS3(cinfo, 1, JTRC_JFIF,
	       cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
      if (b[12] | b[13])
	TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL, b[12], b[13]);
      if (length != ((INT32) b[12] * (INT32) b[13] * (INT32) 3))
	TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) length);
    } else {
      /* Start of APP0 does not match "JFIF" */
      TRACEMS1(cinfo, 1, JTRC_APP0, (int) length + JFIF_LEN);
    }
  } else {
    /* Too short to be JFIF marker */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) length);
  }

  INPUT_SYNC(cinfo);
  if (length > 0)		/* skip any remaining data -- could be lots */
    (*cinfo->src->skip_input_data) (cinfo, (long) length);

  return TRUE;
}


METHODDEF(boolean)
get_app14 (j_decompress_ptr cinfo)
/* Process an APP14 marker */
{
#define ADOBE_LEN 12
  INT32 length;
  UINT8 b[ADOBE_LEN];
  int buffp;
  unsigned int version, flags0, flags1, transform;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  /* See if an Adobe APP14 marker is present */

  if (length >= ADOBE_LEN) {
    for (buffp = 0; buffp < ADOBE_LEN; buffp++)
      INPUT_BYTE(cinfo, b[buffp], return FALSE);
    length -= ADOBE_LEN;

    if (b[0]==0x41 && b[1]==0x64 && b[2]==0x6F && b[3]==0x62 && b[4]==0x65) {
      /* Found Adobe APP14 marker */
      version = (b[5] << 8) + b[6];
      flags0 = (b[7] << 8) + b[8];
      flags1 = (b[9] << 8) + b[10];
      transform = b[11];
      TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
      cinfo->saw_Adobe_marker = TRUE;
      cinfo->Adobe_transform = (UINT8) transform;
    } else {
      /* Start of APP14 does not match "Adobe" */
      TRACEMS1(cinfo, 1, JTRC_APP14, (int) length + ADOBE_LEN);
    }
  } else {
    /* Too short to be Adobe marker */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) length);
  }

  INPUT_SYNC(cinfo);
  if (length > 0)		/* skip any remaining data -- could be lots */
    (*cinfo->src->skip_input_data) (cinfo, (long) length);

  return TRUE;
}


LOCAL(boolean)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
  INT32 length;
  int index, val;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;
  
  while (length > 0) {
    INPUT_BYTE(cinfo, index, return FALSE);
    INPUT_BYTE(cinfo, val, return FALSE);

    length -= 2;

    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
      ERREXIT1(cinfo, JERR_DAC_INDEX, index);

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
    } else {			/* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
    }
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;
  
  while (length > 0) {
    INPUT_BYTE(cinfo, index, return FALSE);

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
      
    bits[0] = 0;
    count = 0;
    for (i = 1; i <= 16; i++) {
      INPUT_BYTE(cinfo, bits[i], return FALSE);
      count += bits[i];
    }

    length -= 1 + 16;

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
	     bits[9], bits[10], bits[11], bits[12],
	     bits[13], bits[14], bits[15], bits[16]);

    if (count > 256 || ((INT32) count) > length)
      ERREXIT(cinfo, JERR_DHT_COUNTS);

    for (i = 0; i < count; i++)
      INPUT_BYTE(cinfo, huffval[i], return FALSE);

    length -= count;

    if (index & 0x10) {		/* AC table definition */
      index -= 0x10;
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);

    if (*htblptr == NULL)
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
  
    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
  INT32 length;
  int n, i, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 0) {
    INPUT_BYTE(cinfo, n, return FALSE);
    prec = n >> 4;
    n &= 0x0F;

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);

    if (n >= NUM_QUANT_TBLS)
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
      
    if (cinfo->quant_tbl_ptrs[n] == NULL)
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
    quant_ptr = cinfo->quant_tbl_ptrs[n];

    for (i = 0; i < DCTSIZE2; i++) {
      if (prec)
	INPUT_2BYTES(cinfo, tmp, return FALSE);
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
      for (i = 0; i < DCTSIZE2; i += 8) {
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
		 quant_ptr->quantval[i],   quant_ptr->quantval[i+1],
		 quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= DCTSIZE2+1;
    if (prec) length -= DCTSIZE2;
  }

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  
  if (length != 4)
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  INPUT_2BYTES(cinfo, tmp, return FALSE);

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);

  cinfo->restart_interval = tmp;

  INPUT_SYNC(cinfo);
  return TRUE;
}


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
  INT32 length;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  
  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
  (*cinfo->src->skip_input_data) (cinfo, (long) length - 2L);

  return TRUE;
}


/*
 * Find the next JPEG marker, save it in cinfo->unread_marker.
 * Returns FALSE if had to suspend before reaching a marker;
 * in that case cinfo->unread_marker is unchanged.
 *
 * Note that the result might not be a valid marker code,
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
  int c;
  INPUT_VARS(cinfo);

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
      cinfo->marker->discarded_bytes++;
      INPUT_SYNC(cinfo);
      INPUT_BYTE(cinfo, c, return FALSE);
    }
    /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
    } while (c == 0xFF);
    if (c != 0)
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
    INPUT_SYNC(cinfo);
  }

  if (cinfo->marker->discarded_bytes != 0) {
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
    cinfo->marker->discarded_bytes = 0;
  }

  cinfo->unread_marker = c;

  INPUT_SYNC(cinfo);
  return TRUE;
}


LOCAL(boolean)
first_marker (j_decompress_ptr cinfo)
/* Like next_marker, but used to obtain the initial SOI marker. */
/* For this marker, we do not allow preceding garbage or fill; otherwise,
 * we might well scan an entire input file before realizing it ain't JPEG.
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
  int c, c2;
  INPUT_VARS(cinfo);

  INPUT_BYTE(cinfo, c, return FALSE);
  INPUT_BYTE(cinfo, c2, return FALSE);
  if (c != 0xFF || c2 != (int) M_SOI)
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);

  cinfo->unread_marker = c2;

  INPUT_SYNC(cinfo);
  return TRUE;
}


/*
 * Read markers until SOS or EOI.
 *
 * Returns same codes as are defined for jpeg_consume_input:
 * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
      if (! cinfo->marker->saw_SOI) {
	if (! first_marker(cinfo))
	  return JPEG_SUSPENDED;
      } else {
	if (! next_marker(cinfo))
	  return JPEG_SUSPENDED;
      }
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
    case M_SOI:
      if (! get_soi(cinfo))
	return JPEG_SUSPENDED;
      break;

    case M_SOF0:		/* Baseline */
    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, TRUE, FALSE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE))
	return JPEG_SUSPENDED;
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, TRUE, TRUE))
	return JPEG_SUSPENDED;
      break;

    /* Currently unsupported SOFn types */
    case M_SOF3:		/* Lossless, Huffman */
    case M_SOF5:		/* Differential sequential, Huffman */
    case M_SOF6:		/* Differential progressive, Huffman */
    case M_SOF7:		/* Differential lossless, Huffman */
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
      break;

    case M_SOS:
      if (! get_sos(cinfo))
	return JPEG_SUSPENDED;
      cinfo->unread_marker = 0;	/* processed the marker */
      return JPEG_REACHED_SOS;
    
    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
      cinfo->unread_marker = 0;	/* processed the marker */
      return JPEG_REACHED_EOI;
      
    case M_DAC:
      if (! get_dac(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DHT:
      if (! get_dht(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DQT:
      if (! get_dqt(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_DRI:
      if (! get_dri(cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_APP0:
    case M_APP1:
    case M_APP2:
    case M_APP3:
    case M_APP4:
    case M_APP5:
    case M_APP6:
    case M_APP7:
    case M_APP8:
    case M_APP9:
    case M_APP10:
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*cinfo->marker->process_APPn[cinfo->unread_marker - (int) M_APP0]) (cinfo))
	return JPEG_SUSPENDED;
      break;
      
    case M_COM:
      if (! (*cinfo->marker->process_COM) (cinfo))
	return JPEG_SUSPENDED;
      break;

    case M_RST0:		/* these are all parameterless */
    case M_RST1:
    case M_RST2:
    case M_RST3:
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
      break;

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
	return JPEG_SUSPENDED;
      break;

    default:			/* must be DHP, EXP, JPGn, or RESn */
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
      break;
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
  } /* end loop */
}


/*
 * Read a restart marker, which is expected to appear next in the datastream;
 * if the marker is not there, take appropriate recovery action.
 * Returns FALSE if suspension is required.
 *
 * This is called by the entropy decoder after it has read an appropriate
 * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder
 * has already read a marker from the data source.  Under normal conditions
 * cinfo->unread_marker will be reset to 0 before returning; if not reset,
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
    if (! next_marker(cinfo))
      return FALSE;
  }

  if (cinfo->unread_marker ==
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
    cinfo->unread_marker = 0;
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
					    cinfo->marker->next_restart_num))
      return FALSE;
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;

  return TRUE;
}


/*
 * This is the default resync_to_restart method for data source managers
 * to use if they don't have any better approach.  Some data source managers
 * may be able to back up, or may have additional knowledge about the data
 * which permits a more intelligent recovery strategy; such managers would
 * presumably supply their own resync method.
 *
 * read_restart_marker calls resync_to_restart if it finds a marker other than
 * the restart marker it was expecting.  (This code is *not* used unless
 * a nonzero restart interval has been declared.)  cinfo->unread_marker is
 * the marker code actually found (might be anything, except 0 or FF).
 * The desired restart marker number (0..7) is passed as a parameter.
 * This routine is supposed to apply whatever error recovery strategy seems
 * appropriate in order to position the input stream to the next data segment.
 * Note that cinfo->unread_marker is treated as a marker appearing before
 * the current data-source input point; usually it should be reset to zero
 * before returning.
 * Returns FALSE if suspension is required.
 *
 * This implementation is substantially constrained by wanting to treat the
 * input as a data stream; this means we can't back up.  Therefore, we have
 * only the following actions to work with:
 *   1. Simply discard the marker and let the entropy decoder resume at next
 *      byte of file.
 *   2. Read forward until we find another marker, discarding intervening
 *      data.  (In theory we could look ahead within the current bufferload,
 *      without having to discard data if we don't find the desired marker.
 *      This idea is not implemented here, in part because it makes behavior
 *      dependent on buffer size and chance buffer-boundary positions.)
 *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).
 *      This will cause the entropy decoder to process an empty data segment,
 *      inserting dummy zeroes, and then we will reprocess the marker.
 *
 * #2 is appropriate if we think the desired marker lies ahead, while #3 is
 * appropriate if the found marker is a future restart marker (indicating
 * that we have missed the desired restart marker, probably because it got
 * corrupted).
 * We apply #2 or #3 if the found marker is a restart marker no more than
 * two counts behind or ahead of the expected one.  We also apply #2 if the
 * found marker is not a legal JPEG marker code (it's certainly bogus data).
 * If the found marker is a restart marker more than 2 counts away, we do #1
 * (too much risk that the marker is erroneous; with luck we will be able to
 * resync at some future point).
 * For any valid non-restart JPEG marker, we apply #3.  This keeps us from
 * overrunning the end of a scan.  An implementation limited to single-scan
 * files might find it better to apply #2 for markers other than EOI, since
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
  int marker = cinfo->unread_marker;
  int action = 1;
  
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
  
  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
      action = 2;		/* invalid marker */
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
      action = 3;		/* valid non-restart marker */
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
	action = 3;		/* one of the next two expected restarts */
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
	action = 2;		/* a prior restart, so advance */
      else
	action = 1;		/* desired restart or too far away */
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
    switch (action) {
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
      return TRUE;
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
	return FALSE;
      marker = cinfo->unread_marker;
      break;
    case 3:
      /* Return without advancing past this marker. */
      /* Entropy decoder will be forced to process an empty segment. */
      return TRUE;
    }
  } /* end loop */
}


/*
 * Reset marker processing state to begin a fresh datastream.
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
  cinfo->comp_info = NULL;		/* until allocated by get_sof */
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
  cinfo->unread_marker = 0;		/* no pending marker */
  cinfo->marker->saw_SOI = FALSE;	/* set internal state too */
  cinfo->marker->saw_SOF = FALSE;
  cinfo->marker->discarded_bytes = 0;
}


/*
 * Initialize the marker reader module.
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
  int i;

  /* Create subobject in permanent pool */
  cinfo->marker = (struct jpeg_marker_reader *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(struct jpeg_marker_reader));
  /* Initialize method pointers */
  cinfo->marker->reset_marker_reader = reset_marker_reader;
  cinfo->marker->read_markers = read_markers;
  cinfo->marker->read_restart_marker = read_restart_marker;
  cinfo->marker->process_COM = skip_variable;
  for (i = 0; i < 16; i++)
    cinfo->marker->process_APPn[i] = skip_variable;
  cinfo->marker->process_APPn[0] = get_app0;
  cinfo->marker->process_APPn[14] = get_app14;
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdmerge.c ===
/*
 * jdmerge.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains code for merged upsampling/color conversion.
 *
 * This file combines functions from jdsample.c and jdcolor.c;
 * read those files first to understand what's going on.
 *
 * When the chroma components are to be upsampled by simple replication
 * (ie, box filtering), we can save some work in color conversion by
 * calculating all the output pixels corresponding to a pair of chroma
 * samples at one time.  In the conversion equations
 *	R = Y           + K1 * Cr
 *	G = Y + K2 * Cb + K3 * Cr
 *	B = Y + K4 * Cb
 * only the Y term varies among the group of pixels corresponding to a pair
 * of chroma samples, so the rest of the terms can be calculated just once.
 * At typical sampling ratios, this eliminates half or three-quarters of the
 * multiplications needed for color conversion.
 *
 * This file currently provides implementations for the following cases:
 *	YCbCr => RGB color conversion only.
 *	Sampling ratios of 2h1v or 2h2v.
 *	No scaling needed at upsample time.
 *	Corner-aligned (non-CCIR601) sampling alignment.
 * Other special cases could be added, but in most applications these are
 * the only common cases.  (For uncommon cases we fall back on the more
 * general code in jdsample.c and jdcolor.c.)
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"

#ifdef UPSAMPLE_MERGING_SUPPORTED


/* Private subobject */

typedef struct {
  struct jpeg_upsampler pub;	/* public fields */

  /* Pointer to routine to do actual upsampling/conversion of one row group */
  JMETHOD(void, upmethod, (j_decompress_ptr cinfo,
			   JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
			   JSAMPARRAY output_buf));

  /* Private state for YCC->RGB conversion */
  int * Cr_r_tab;		/* => table for Cr to R conversion */
  int * Cb_b_tab;		/* => table for Cb to B conversion */
  INT32 * Cr_g_tab;		/* => table for Cr to G conversion */
  INT32 * Cb_g_tab;		/* => table for Cb to G conversion */

  /* For 2:1 vertical sampling, we produce two output rows at a time.
   * We need a "spare" row buffer to hold the second output row if the
   * application provides just a one-row buffer; we also use the spare
   * to discard the dummy last row if the image height is odd.
   */
  JSAMPROW spare_row;
  boolean spare_full;		/* T if spare buffer is occupied */

  JDIMENSION out_row_width;	/* samples per output row */
  JDIMENSION rows_to_go;	/* counts rows remaining in image */
} my_upsampler;

typedef my_upsampler * my_upsample_ptr;

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))


/*
 * Initialize tables for YCC->RGB colorspace conversion.
 * This is taken directly from jdcolor.c; see that file for more info.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}


/*
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
}


/*
 * Control routine to do upsampling (and color conversion).
 *
 * The control routine just handles the row buffering considerations.
 */

METHODDEF(void)
merged_2v_upsample (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
		      1, upsample->out_row_width);
    num_rows = 1;
    upsample->spare_full = FALSE;
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
      num_rows = upsample->rows_to_go;
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
    if (num_rows > out_rows_avail)
      num_rows = out_rows_avail;
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
    if (num_rows > 1) {
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
    } else {
      work_ptrs[1] = upsample->spare_row;
      upsample->spare_full = TRUE;
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
    (*in_row_group_ctr)++;
}


METHODDEF(void)
merged_1v_upsample (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
			 output_buf + *out_row_ctr);
  /* Adjust counts */
  (*out_row_ctr)++;
  (*in_row_group_ctr)++;
}


/*
 * These are the routines invoked by the control routines to do
 * the actual upsampling/conversion.  One row group is processed per call.
 *
 * Note: since we may be writing directly into application-supplied buffers,
 * we have to be honest about the output width; we can't assume the buffer
 * has been rounded up to an even width.
 */


/*
 * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 */

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  int * Crrtab = upsample->Cr_r_tab;
  int * Cbbtab = upsample->Cb_b_tab;
  INT32 * Crgtab = upsample->Cr_g_tab;
  INT32 * Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr0);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
  }
}


/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
  int * Crrtab = upsample->Cr_r_tab;
  int * Cbbtab = upsample->Cb_b_tab;
  INT32 * Crgtab = upsample->Cr_g_tab;
  INT32 * Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr00);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    y  = GETJSAMPLE(*inptr01);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
  }
}


/*
 * Module initialization routine for merged upsampling/color conversion.
 *
 * NB: this is called under the conditions determined by use_merged_upsample()
 * in jdmaster.c.  That routine MUST correspond to the actual capabilities
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
  upsample->pub.start_pass = start_pass_merged_upsample;
  upsample->pub.need_context_rows = FALSE;

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;

  if (cinfo->max_v_samp_factor == 2) {
    upsample->pub.upsample = merged_2v_upsample;
    upsample->upmethod = h2v2_merged_upsample;
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
  } else {
    upsample->pub.upsample = merged_1v_upsample;
    upsample->upmethod = h2v1_merged_upsample;
    /* No spare row needed */
    upsample->spare_row = NULL;
  }

  build_ycc_rgb_table(cinfo);
}

#endif /* UPSAMPLE_MERGING_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdmaster.c ===
/*
 * jdmaster.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains master control logic for the JPEG decompressor.
 * These routines are concerned with selecting the modules to be executed
 * and with determining the number of passes and the work to be done in each
 * pass.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Private state */

typedef struct {
  struct jpeg_decomp_master pub; /* public fields */

  int pass_number;		/* # of passes completed */

  boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */

  /* Saved references to initialized quantizer modules,
   * in case we need to switch modes.
   */
  struct jpeg_color_quantizer * quantizer_1pass;
  struct jpeg_color_quantizer * quantizer_2pass;
} my_decomp_master;

typedef my_decomp_master * my_master_ptr;


/*
 * Determine whether merged upsample/color conversion should be used.
 * CRUCIAL: this must match the actual capabilities of jdmerge.c!
 */

LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
    return FALSE;
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
      cinfo->out_color_space != JCS_RGB ||
      cinfo->out_color_components != RGB_PIXELSIZE)
    return FALSE;
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
      cinfo->comp_info[1].h_samp_factor != 1 ||
      cinfo->comp_info[2].h_samp_factor != 1 ||
      cinfo->comp_info[0].v_samp_factor >  2 ||
      cinfo->comp_info[1].v_samp_factor != 1 ||
      cinfo->comp_info[2].v_samp_factor != 1)
    return FALSE;
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
      cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
    return FALSE;
  /* ??? also need to test for upsample-time rescaling, when & if supported */
  return TRUE;			/* by golly, it'll work... */
#else
  return FALSE;
#endif
}


/*
 * Compute output image dimensions and related values.
 * NOTE: this is exported for possible use by application.
 * Hence it mustn't do anything that can't be done twice.
 * Also note that it may be called before the master module is initialized!
 */

GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase */
{
  int ci;
  jpeg_component_info *compptr;

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

#ifdef IDCT_SCALING_SUPPORTED

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
    /* Provide 1/8 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 8L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 8L);
    cinfo->min_DCT_scaled_size = 1;
  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
    /* Provide 1/4 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 4L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 4L);
    cinfo->min_DCT_scaled_size = 2;
  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
    /* Provide 1/2 scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, 2L);
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, 2L);
    cinfo->min_DCT_scaled_size = 4;
  } else {
    /* Provide 1/1 scaling */
    cinfo->output_width = cinfo->image_width;
    cinfo->output_height = cinfo->image_height;
    cinfo->min_DCT_scaled_size = DCTSIZE;
  }
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
    while (ssize < DCTSIZE &&
	   (compptr->h_samp_factor * ssize * 2 <=
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
	   (compptr->v_samp_factor * ssize * 2 <=
	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
      ssize = ssize * 2;
    }
    compptr->DCT_scaled_size = ssize;
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width *
		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height *
		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
  }

#else /* !IDCT_SCALING_SUPPORTED */

  /* Hardwire it to "no scaling" */
  cinfo->output_width = cinfo->image_width;
  cinfo->output_height = cinfo->image_height;
  /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
   * and has computed unscaled downsampled_width and downsampled_height.
   */

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
    break;
  case JCS_RGB:
#if RGB_PIXELSIZE != 3
    cinfo->out_color_components = RGB_PIXELSIZE;
    break;
#endif /* else share code with YCbCr */
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
    break;
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
    break;
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
    break;
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
  else
    cinfo->rec_outbuf_height = 1;
}


/*
 * Several decompression processes need to range-limit values to the range
 * 0..MAXJSAMPLE; the input value may fall somewhat outside this range
 * due to noise introduced by quantization, roundoff error, etc.  These
 * processes are inner loops and need to be as fast as possible.  On most
 * machines, particularly CPUs with pipelines or instruction prefetch,
 * a (subscript-check-less) C table lookup
 *		x = sample_range_limit[x];
 * is faster than explicit tests
 *		if (x < 0)  x = 0;
 *		else if (x > MAXJSAMPLE)  x = MAXJSAMPLE;
 * These processes all use a common table prepared by the routine below.
 *
 * For most steps we can mathematically guarantee that the initial value
 * of x is within MAXJSAMPLE+1 of the legal range, so a table running from
 * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial
 * limiting step (just after the IDCT), a wildly out-of-range value is 
 * possible if the input data is corrupt.  To avoid any chance of indexing
 * off the end of memory and getting a bad-pointer trap, we perform the
 * post-IDCT limiting thus:
 *		x = range_limit[x & MASK];
 * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
 * samples.  Under normal circumstances this is more than enough range and
 * a correct output will be generated; with bogus input data the mask will
 * cause wraparound, and we will safely generate a bogus-but-in-range output.
 * For the post-IDCT step, we want to convert the data from signed to unsigned
 * representation by adding CENTERJSAMPLE at the same time that we limit it.
 * So the post-IDCT limiting table ends up looking like this:
 *   CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,
 *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
 *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
 *   0,1,...,CENTERJSAMPLE-1
 * Negative inputs select values from the upper half of the table after
 * masking.
 *
 * We can save some space by overlapping the start of the post-IDCT table
 * with the simpler range limiting table.  The post-IDCT table begins at
 * sample_range_limit + CENTERJSAMPLE.
 *
 * Note that the table is allocated in near data space on PCs; it's small
 * enough and used often enough to justify this.
 */

LOCAL(void)
prepare_range_limit_table (j_decompress_ptr cinfo)
/* Allocate and fill in the sample_range_limit table */
{
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
  cinfo->sample_range_limit = table;
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
    table[i] = (JSAMPLE) i;
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
    table[i] = MAXJSAMPLE;
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
}


/*
 * Master selection of decompression modules.
 * This is done once at jpeg_start_decompress time.  We determine
 * which modules will be used and give them appropriate initialization calls.
 * We also initialize the decompressor input side to begin consuming data.
 *
 * Since jpeg_read_header has finished, we know what is in the SOF
 * and (first) SOS markers.  We also have all the application parameter
 * settings.
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
  prepare_range_limit_table(cinfo);

  /* Width of an output scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
  jd_samplesperrow = (JDIMENSION) samplesperrow;
  if ((long) jd_samplesperrow != samplesperrow)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);

  /* Initialize my private state */
  master->pass_number = 0;
  master->using_merged_upsample = use_merged_upsample(cinfo);

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
  master->quantizer_2pass = NULL;
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
    cinfo->enable_1pass_quant = FALSE;
    cinfo->enable_external_quant = FALSE;
    cinfo->enable_2pass_quant = FALSE;
  }
  if (cinfo->quantize_colors) {
    if (cinfo->raw_data_out)
      ERREXIT(cinfo, JERR_NOTIMPL);
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
      cinfo->enable_1pass_quant = TRUE;
      cinfo->enable_external_quant = FALSE;
      cinfo->enable_2pass_quant = FALSE;
      cinfo->colormap = NULL;
    } else if (cinfo->colormap != NULL) {
      cinfo->enable_external_quant = TRUE;
    } else if (cinfo->two_pass_quantize) {
      cinfo->enable_2pass_quant = TRUE;
    } else {
      cinfo->enable_1pass_quant = TRUE;
    }

    if (cinfo->enable_1pass_quant) {
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
      master->quantizer_1pass = cinfo->cquantize;
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
      master->quantizer_2pass = cinfo->cquantize;
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }
    /* If both quantizers are initialized, the 2-pass one is left active;
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
    if (master->using_merged_upsample) {
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
      jinit_upsampler(cinfo);
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
  } else {
    if (cinfo->progressive_mode) {
#ifdef D_PROGRESSIVE_SUPPORTED
      jinit_phuff_decoder(cinfo);
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_decoder(cinfo);
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
  jinit_d_coef_controller(cinfo, use_c_buffer);

  if (! cinfo->raw_data_out)
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);

#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
      cinfo->inputctl->has_multiple_scans) {
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
    }
    cinfo->progress->pass_counter = 0L;
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
    cinfo->progress->completed_passes = 0;
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
    /* Count the input pass as done */
    master->pass_number++;
  }
#endif /* D_MULTISCAN_FILES_SUPPORTED */
}


/*
 * Per-pass setup.
 * This is called at the beginning of each output pass.  We determine which
 * modules will be active during this pass and give them appropriate
 * start_pass calls.  We also set is_dummy_pass to indicate whether this
 * is a "real" output pass or a dummy pass for color quantization.
 * (In the latter case, jdapi.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  if (master->pub.is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
	cinfo->cquantize = master->quantizer_2pass;
	master->pub.is_dummy_pass = TRUE;
      } else if (cinfo->enable_1pass_quant) {
	cinfo->cquantize = master->quantizer_1pass;
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
    (*cinfo->coef->start_output_pass) (cinfo);
    if (! cinfo->raw_data_out) {
      if (! master->using_merged_upsample)
	(*cinfo->cconvert->start_pass) (cinfo);
      (*cinfo->upsample->start_pass) (cinfo);
      if (cinfo->quantize_colors)
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
      (*cinfo->post->start_pass) (cinfo,
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->completed_passes = master->pass_number;
    cinfo->progress->total_passes = master->pass_number +
				    (master->pub.is_dummy_pass ? 2 : 1);
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
    }
  }
}


/*
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  if (cinfo->quantize_colors)
    (*cinfo->cquantize->finish_pass) (cinfo);
  master->pass_number++;
}


#ifdef D_MULTISCAN_FILES_SUPPORTED

/*
 * Switch to a new external colormap between output passes.
 */

GLOBAL(void)
jpeg_new_colormap (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_BUFIMAGE)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (cinfo->quantize_colors && cinfo->enable_external_quant &&
      cinfo->colormap != NULL) {
    /* Select 2-pass quantizer for external colormap use */
    cinfo->cquantize = master->quantizer_2pass;
    /* Notify quantizer of colormap change */
    (*cinfo->cquantize->new_color_map) (cinfo);
    master->pub.is_dummy_pass = FALSE; /* just in case */
  } else
    ERREXIT(cinfo, JERR_MODE_CHANGE);
}

#endif /* D_MULTISCAN_FILES_SUPPORTED */


/*
 * Initialize master decompression control and select active modules.
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
  master->pub.finish_output_pass = finish_output_pass;

  master->pub.is_dummy_pass = FALSE;

  master_selection(cinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdphuff.c ===
/*
 * jdphuff.c
 *
 * Copyright (C) 1995-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy decoding routines for progressive JPEG.
 *
 * Much of the complexity here has to do with supporting input suspension.
 * If the data source module demands suspension, we want to be able to back
 * up to the start of the current MCU.  To do this, we copy state variables
 * into local working storage, and update them back to the permanent
 * storage only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdhuff.h"		/* Declarations shared with jdhuff.c */


#ifdef D_PROGRESSIVE_SUPPORTED

/*
 * Expanded entropy decoder object for progressive Huffman decoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  unsigned int EOBRUN;			/* remaining EOBs in EOBRUN */
  int last_dc_val[MAX_COMPS_IN_SCAN];	/* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).EOBRUN = (src).EOBRUN, \
	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_decoder pub; /* public fields */

  /* These fields are loaded into local variables at start of each MCU.
   * In case of suspension, we exit WITHOUT updating them.
   */
  bitread_perm_state bitstate;	/* Bit buffer at start of MCU */
  savable_state saved;		/* Other state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];

  d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */
} phuff_entropy_decoder;

typedef phuff_entropy_decoder * phuff_entropy_ptr;

/* Forward declarations */
METHODDEF(boolean) __cdecl decode_mcu_DC_first JPP((j_decompress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) __cdecl decode_mcu_AC_first JPP((j_decompress_ptr cinfo,
					    JBLOCKROW *MCU_data));
METHODDEF(boolean) __cdecl decode_mcu_DC_refine JPP((j_decompress_ptr cinfo,
					     JBLOCKROW *MCU_data));
METHODDEF(boolean) __cdecl decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
					     JBLOCKROW *MCU_data));


/*
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_phuff_decoder (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  boolean is_DC_band, bad;
  int ci, coefi, tbl;
  int *coef_bit_ptr;
  jpeg_component_info * compptr;

  is_DC_band = (cinfo->Ss == 0);

  /* Validate scan parameters */
  bad = FALSE;
  if (is_DC_band) {
    if (cinfo->Se != 0)
      bad = TRUE;
  } else {
    /* need not check Ss/Se < 0 since they came from unsigned bytes */
    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
      bad = TRUE;
    /* AC scans may have only one component */
    if (cinfo->comps_in_scan != 1)
      bad = TRUE;
  }
  if (cinfo->Ah != 0) {
    /* Successive approximation refinement scan: must have Al = Ah-1. */
    if (cinfo->Al != cinfo->Ah-1)
      bad = TRUE;
  }
  if (cinfo->Al > 13)		/* need not check for < 0 */
    bad = TRUE;
  if (bad)
    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
  /* Update progression status, and verify that scan order is legal.
   * Note that inter-scan inconsistencies are treated as warnings
   * not fatal errors ... not clear if this is right way to behave.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    int cindex = cinfo->cur_comp_info[ci]->component_index;
    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
      int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
      if (cinfo->Ah != expected)
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
      coef_bit_ptr[coefi] = cinfo->Al;
    }
  }

  /* Select MCU decoding routine */
  if (cinfo->Ah == 0) {
    if (is_DC_band)
      entropy->pub.decode_mcu = decode_mcu_DC_first;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_first;
  } else {
    if (is_DC_band)
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    /* Make sure requested tables are present, and compute derived tables.
     * We may build same derived table more than once, but it's not expensive.
     */
    if (is_DC_band) {
      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
	tbl = compptr->dc_tbl_no;
	if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
	    cinfo->dc_huff_tbl_ptrs[tbl] == NULL)
	  ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
	jpeg_make_d_derived_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[tbl],
				& entropy->derived_tbls[tbl]);
      }
    } else {
      tbl = compptr->ac_tbl_no;
      if (tbl < 0 || tbl >= NUM_HUFF_TBLS ||
          cinfo->ac_huff_tbl_ptrs[tbl] == NULL)
        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
      jpeg_make_d_derived_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[tbl],
			      & entropy->derived_tbls[tbl]);
      /* remember the single active table */
      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
    }
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
  entropy->bitstate.printed_eod = FALSE;

  /* Initialize private state variables */
  entropy->saved.EOBRUN = 0;

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
}


/*
 * Figure F.12: extend sign bit.
 * On some machines, a shift and add will be faster than a table lookup.
 */

#ifdef AVOID_TABLES

#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#else

#define HUFF_EXTEND(x,s)  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))

static const int extend_test[16] =   /* entry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#endif /* AVOID_TABLES */


/*
 * Check for a restart marker & resynchronize decoder.
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
  entropy->bitstate.bits_left = 0;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
    entropy->saved.last_dc_val[ci] = 0;
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;

  /* Next segment can get another out-of-data warning */
  entropy->bitstate.printed_eod = FALSE;

  return TRUE;
}


/*
 * Huffman MCU decoding.
 * Each of these routines decodes and returns one MCU's worth of
 * Huffman-compressed coefficients. 
 * The coefficients are reordered from zigzag order into natural array order,
 * but are not dequantized.
 *
 * The i'th block of the MCU is stored into the block pointed to by
 * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
 *
 * We return FALSE if data source requested suspension.  In that case no
 * changes have been made to permanent state.  (Exception: some output
 * coefficients may already have been assigned.  This is harmless for
 * spectral selection, since we'll just re-assign them on the next call.
 * Successive approximation AC refinement has to be more careful, however.)
 */

/*
 * MCU decoding for DC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
__cdecl decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Al = cinfo->Al;
  register int s, r;
  int blkn, ci;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(state, entropy->saved);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    tbl = entropy->derived_tbls[compptr->dc_tbl_no];

    /* Decode a single block's worth of coefficients */

    /* Section F.2.2.1: decode the DC coefficient difference */
    HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
    if (s) {
      CHECK_BIT_BUFFER(br_state, s, return FALSE);
      r = GET_BITS(s);
      s = HUFF_EXTEND(r, s);
    }

    /* Convert DC difference to actual value, update last_dc_val */
    s += state.last_dc_val[ci];
    state.last_dc_val[ci] = s;
    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
    (*block)[0] = (JCOEF) (s << Al);
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  ASSIGN_STATE(entropy->saved, state);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC initial scan (either spectral selection,
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
__cdecl decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Se = cinfo->Se;
  int Al = cinfo->Al;
  register int s, k, r;
  unsigned int EOBRUN;
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state.
   * We can avoid loading/saving bitread state if in an EOB run.
   */
  EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we care about */

  /* There is always only one block per MCU */

  if (EOBRUN > 0)		/* if it's a band of zeroes... */
    EOBRUN--;			/* ...process it now (we do nothing) */
  else {
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    block = MCU_data[0];
    tbl = entropy->ac_derived_tbl;

    for (k = cinfo->Ss; k <= Se; k++) {
      HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
      r = s >> 4;
      s &= 15;
      if (s) {
        k += r;
        CHECK_BIT_BUFFER(br_state, s, return FALSE);
        r = GET_BITS(s);
        s = HUFF_EXTEND(r, s);
	/* Scale and output coefficient in natural (dezigzagged) order */
        (*block)[jpeg_natural_order[k]] = (JCOEF) (s << Al);
      } else {
        if (r == 15) {		/* ZRL */
          k += 15;		/* skip 15 zeroes in band */
        } else {		/* EOBr, run length is 2^r + appended bits */
          EOBRUN = 1 << r;
          if (r) {		/* EOBr, r > 0 */
	    CHECK_BIT_BUFFER(br_state, r, return FALSE);
            r = GET_BITS(r);
            EOBRUN += r;
          }
	  EOBRUN--;		/* this band is processed at this moment */
	  break;		/* force end-of-band */
	}
      }
    }

    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  }

  /* Completed MCU, so update state */
  entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we care about */

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for DC successive approximation refinement scan.
 * Note: we assume such scans can be multi-component, although the spec
 * is not very clear on the point.
 */

METHODDEF(boolean)
__cdecl decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
    if (GET_BITS(1))
      (*block)[0] |= p1;
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;
}


/*
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
__cdecl decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Se = cinfo->Se;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
  int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
  register int s, k, r;
  unsigned int EOBRUN;
  JBLOCKROW block;
  JCOEFPTR thiscoef;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! process_restart(cinfo))
	return FALSE;
  }

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
  EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we care about */

  /* There is always only one block per MCU */
  block = MCU_data[0];
  tbl = entropy->ac_derived_tbl;

  /* If we are forced to suspend, we must undo the assignments to any newly
   * nonzero coefficients in the block, because otherwise we'd get confused
   * next time about which coefficients were already nonzero.
   * But we need not undo addition of bits to already-nonzero coefficients;
   * instead, we can test the current bit position to see if we already did it.
   */
  num_newnz = 0;

  /* initialize coefficient loop counter to start of band */
  k = cinfo->Ss;

  if (EOBRUN == 0) {
    for (; k <= Se; k++) {
      HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
      r = s >> 4;
      s &= 15;
      if (s) {
	if (s != 1)		/* size of new coef should always be 1 */
	  WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
        CHECK_BIT_BUFFER(br_state, 1, goto undoit);
        if (GET_BITS(1))
	  s = p1;		/* newly nonzero coef is positive */
	else
	  s = m1;		/* newly nonzero coef is negative */
      } else {
	if (r != 15) {
	  EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
	  if (r) {
	    CHECK_BIT_BUFFER(br_state, r, goto undoit);
	    r = GET_BITS(r);
	    EOBRUN += r;
	  }
	  break;		/* rest of block is handled by EOB logic */
	}
	/* note s = 0 for processing ZRL */
      }
      /* Advance over already-nonzero coefs and r still-zero coefs,
       * appending correction bits to the nonzeroes.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      do {
	thiscoef = *block + jpeg_natural_order[k];
	if (*thiscoef != 0) {
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	  if (GET_BITS(1)) {
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
	      if (*thiscoef >= 0)
		*thiscoef += (short)p1;
	      else
		*thiscoef += (short)m1;
	    }
	  }
	} else {
	  if (--r < 0)
	    break;		/* reached target zero coefficient */
	}
	k++;
      } while (k <= Se);
      if (s) {
	int pos = jpeg_natural_order[k];
	/* Output newly nonzero coefficient */
	(*block)[pos] = (JCOEF) s;
	/* Remember its position in case we have to suspend */
	newnz_pos[num_newnz++] = pos;
      }
    }
  }

  if (EOBRUN > 0) {
    /* Scan any remaining coefficient positions after the end-of-band
     * (the last newly nonzero coefficient, if any).  Append a correction
     * bit to each already-nonzero coefficient.  A correction bit is 1
     * if the absolute value of the coefficient must be increased.
     */
    for (; k <= Se; k++) {
      thiscoef = *block + jpeg_natural_order[k];
      if (*thiscoef != 0) {
	CHECK_BIT_BUFFER(br_state, 1, goto undoit);
	if (GET_BITS(1)) {
	  if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
	    if (*thiscoef >= 0)
	      *thiscoef += (short)p1;
	    else
	      *thiscoef += (short)m1;
	  }
	}
      }
    }
    /* Count one block completed in EOB run */
    EOBRUN--;
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
  entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we care about */

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;

  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
    (*block)[newnz_pos[--num_newnz]] = 0;

  return FALSE;
}


/*
 * Module initialization routine for progressive Huffman entropy decoding.
 */

GLOBAL(void)
jinit_phuff_decoder (j_decompress_ptr cinfo)
{
  phuff_entropy_ptr entropy;
  int *coef_bit_ptr;
  int ci, i;

  entropy = (phuff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(phuff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_phuff_decoder;

  /* Mark derived tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->derived_tbls[i] = NULL;
  }

  /* Create progression status table */
  cinfo->coef_bits = (int (*)[DCTSIZE2])
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
  for (ci = 0; ci < cinfo->num_components; ci++) 
    for (i = 0; i < DCTSIZE2; i++)
      *coef_bit_ptr++ = -1;
}

#endif /* D_PROGRESSIVE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdmainct.c ===
/*
 * jdmainct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the main buffer controller for decompression.
 * The main buffer lies between the JPEG decompressor proper and the
 * post-processor; it holds downsampled data in the JPEG colorspace.
 *
 * Note that this code is bypassed in raw-data mode, since the application
 * supplies the equivalent of the main buffer in that case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/*
 * In the current system design, the main buffer need never be a full-image
 * buffer; any full-height buffers will be found inside the coefficient or
 * postprocessing controllers.  Nonetheless, the main controller is not
 * trivial.  Its responsibility is to provide context rows for upsampling/
 * rescaling, and doing this in an efficient fashion is a bit tricky.
 *
 * Postprocessor input data is counted in "row groups".  A row group
 * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
 * sample rows of each component.  (We require DCT_scaled_size values to be
 * chosen such that these numbers are integers.  In practice DCT_scaled_size
 * values will likely be powers of two, so we actually have the stronger
 * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
 * Upsampling will typically produce max_v_samp_factor pixel rows from each
 * row group (times any additional scale factor that the upsampler is
 * applying).
 *
 * The coefficient controller will deliver data to us one iMCU row at a time;
 * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
 * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
 * to one row of MCUs when the image is fully interleaved.)  Note that the
 * number of sample rows varies across components, but the number of row
 * groups does not.  Some garbage sample rows may be included in the last iMCU
 * row at the bottom of the image.
 *
 * Depending on the vertical scaling algorithm used, the upsampler may need
 * access to the sample row(s) above and below its current input row group.
 * The upsampler is required to set need_context_rows TRUE at global selection
 * time if so.  When need_context_rows is FALSE, this controller can simply
 * obtain one iMCU row at a time from the coefficient controller and dole it
 * out as row groups to the postprocessor.
 *
 * When need_context_rows is TRUE, this controller guarantees that the buffer
 * passed to postprocessing contains at least one row group's worth of samples
 * above and below the row group(s) being processed.  Note that the context
 * rows "above" the first passed row group appear at negative row offsets in
 * the passed buffer.  At the top and bottom of the image, the required
 * context rows are manufactured by duplicating the first or last real sample
 * row; this avoids having special cases in the upsampling inner loops.
 *
 * The amount of context is fixed at one row group just because that's a
 * convenient number for this controller to work with.  The existing
 * upsamplers really only need one sample row of context.  An upsampler
 * supporting arbitrary output rescaling might wish for more than one row
 * group of context when shrinking the image; tough, we don't handle that.
 * (This is justified by the assumption that downsizing will be handled mostly
 * by adjusting the DCT_scaled_size values, so that the actual scale factor at
 * the upsample step needn't be much less than one.)
 *
 * To provide the desired context, we have to retain the last two row groups
 * of one iMCU row while reading in the next iMCU row.  (The last row group
 * can't be processed until we have another row group for its below-context,
 * and so we have to save the next-to-last group too for its above-context.)
 * We could do this most simply by copying data around in our buffer, but
 * that'd be very slow.  We can avoid copying any data by creating a rather
 * strange pointer structure.  Here's how it works.  We allocate a workspace
 * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
 * of row groups per iMCU row).  We create two sets of redundant pointers to
 * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
 * pointer lists look like this:
 *                   M+1                          M-1
 * master pointer --> 0         master pointer --> 0
 *                    1                            1
 *                   ...                          ...
 *                   M-3                          M-3
 *                   M-2                           M
 *                   M-1                          M+1
 *                    M                           M-2
 *                   M+1                          M-1
 *                    0                            0
 * We read alternate iMCU rows using each master pointer; thus the last two
 * row groups of the previous iMCU row remain un-overwritten in the workspace.
 * The pointer lists are set up so that the required context rows appear to
 * be adjacent to the proper places when we pass the pointer lists to the
 * upsampler.
 *
 * The above pictures describe the normal state of the pointer lists.
 * At top and bottom of the image, we diddle the pointer lists to duplicate
 * the first or last sample row as necessary (this is cheaper than copying
 * sample rows around).
 *
 * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that
 * situation each iMCU row provides only one row group so the buffering logic
 * must be different (eg, we must read two iMCU rows before we can emit the
 * first row group).  For now, we simply do not support providing context
 * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
 * be worth providing --- if someone wants a 1/8th-size preview, they probably
 * want it quick and dirty, so a context-free upsampler is sufficient.
 */


/* Private buffer controller object */

typedef struct {
  struct jpeg_d_main_controller pub; /* public fields */

  /* Pointer to allocated workspace (M or M+2 row groups). */
  JSAMPARRAY buffer[MAX_COMPONENTS];

  boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
  JDIMENSION rowgroup_ctr;	/* counts row groups output to postprocessor */

  /* Remaining fields are only used in the context case. */

  /* These are the master pointers to the funny-order pointer lists. */
  JSAMPIMAGE xbuffer[2];	/* pointers to weird pointer lists */

  int whichptr;			/* indicates which pointer set is now in use */
  int context_state;		/* process_data state machine status */
  JDIMENSION rowgroups_avail;	/* row groups available to postprocessor */
  JDIMENSION iMCU_row_ctr;	/* counts iMCU rows to detect image top/bot */
} my_main_controller;

typedef my_main_controller * my_main_ptr;

/* context_state values: */
#define CTX_PREPARE_FOR_IMCU	0	/* need to prepare for MCU row */
#define CTX_PROCESS_IMCU	1	/* feeding iMCU to postprocessor */
#define CTX_POSTPONED_ROW	2	/* feeding postponed row group */


/* Forward declarations */
METHODDEF(void) process_data_simple_main
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
METHODDEF(void) process_data_context_main
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
#ifdef QUANT_2PASS_SUPPORTED
METHODDEF(void) process_data_crank_post
	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
#endif


LOCAL(void)
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
    xbuf += rgroup;		/* want one row group at negative offsets */
    main->xbuffer[0][ci] = xbuf;
    xbuf += rgroup * (M + 4);
    main->xbuffer[1][ci] = xbuf;
  }
}


LOCAL(void)
make_funny_pointers (j_decompress_ptr cinfo)
/* Create the funny pointer lists discussed in the comments above.
 * The actual workspace is already allocated (in main->buffer),
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
    for (i = 0; i < rgroup * (M + 2); i++) {
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
    }
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[0];
    }
  }
}


LOCAL(void)
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
    }
  }
}


LOCAL(void)
set_bottom_pointers (j_decompress_ptr cinfo)
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
    if (rows_left == 0) rows_left = iMCUheight;
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
    for (i = 0; i < rgroup * 2; i++) {
      xbuf[rows_left + i] = xbuf[rows_left-1];
    }
  }
}


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
      main->pub.process_data = process_data_context_main;
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
      main->context_state = CTX_PREPARE_FOR_IMCU;
      main->iMCU_row_ctr = 0;
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
    main->rowgroup_ctr = 0;
    break;
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data.
 * This handles the simple case where no context is required.
 */

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
  /* Note: at the bottom of the image, we may pass extra garbage row groups
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
    main->buffer_full = FALSE;
    main->rowgroup_ctr = 0;
  }
}


/*
 * Process some data.
 * This handles the case where context rows must be provided.
 */

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
  my_main_ptr main = (my_main_ptr) cinfo->main;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
    if (! (*cinfo->coef->decompress_data) (cinfo,
					   main->xbuffer[main->whichptr]))
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
    main->iMCU_row_ctr++;	/* count rows received */
  }

  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
    if (*out_row_ctr >= out_rows_avail)
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
      set_bottom_pointers(cinfo);
    main->context_state = CTX_PROCESS_IMCU;
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
      set_wraparound_pointers(cinfo);
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
    main->buffer_full = FALSE;
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
    main->context_state = CTX_POSTPONED_ROW;
  }
}


/*
 * Process some data.
 * Final pass of two-pass quantization: just call the postprocessor.
 * Source data will be the postprocessor controller's internal buffer.
 */

#ifdef QUANT_2PASS_SUPPORTED

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}

#endif /* QUANT_2PASS_SUPPORTED */


/*
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
  main->pub.start_pass = start_pass_main;

  if (need_full_buffer)		/* shouldn't happen */
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
      ERREXIT(cinfo, JERR_NOTIMPL);
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
    ngroups = cinfo->min_DCT_scaled_size + 2;
  } else {
    ngroups = cinfo->min_DCT_scaled_size;
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_scaled_size,
			 (JDIMENSION) (rgroup * ngroups));
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdsample.c ===
/*
 * jdsample.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains upsampling routines.
 *
 * Upsampling input data is counted in "row groups".  A row group
 * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
 * sample rows of each component.  Upsampling will normally produce
 * max_v_samp_factor pixel rows from each row group (but this could vary
 * if the upsampler is applying a scale factor of its own).
 *
 * An excellent reference for image resampling is
 *   Digital Image Warping, George Wolberg, 1990.
 *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Pointer to routine to upsample a single component */
typedef JMETHOD(void, upsample1_ptr,
		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));

/* Private subobject */

typedef struct {
  struct jpeg_upsampler pub;	/* public fields */

  /* Color conversion buffer.  When using separate upsampling and color
   * conversion steps, this buffer holds one upsampled row group until it
   * has been color converted and output.
   * Note: we do not allocate any storage for component(s) which are full-size,
   * ie do not need rescaling.  The corresponding entry of color_buf[] is
   * simply set to point to the input data array, thereby avoiding copying.
   */
  JSAMPARRAY color_buf[MAX_COMPONENTS];

  /* Per-component upsampling method pointers */
  upsample1_ptr methods[MAX_COMPONENTS];

  int next_row_out;		/* counts rows emitted from color_buf */
  JDIMENSION rows_to_go;	/* counts rows remaining in image */

  /* Height of an input row group for each component. */
  int rowgroup_height[MAX_COMPONENTS];

  /* These arrays save pixel expansion factors so that int_expand need not
   * recompute them each time.  They are unused for other upsampling methods.
   */
  UINT8 h_expand[MAX_COMPONENTS];
  UINT8 v_expand[MAX_COMPONENTS];
} my_upsampler;

typedef my_upsampler * my_upsample_ptr;


/*
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
}


/*
 * Control routine to do upsampling (and color conversion).
 *
 * In this version we upsample each component independently.
 * We upsample one row group into the conversion buffer, then apply
 * color conversion a row at a time.
 */

METHODDEF(void)
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
	upsample->color_buf + ci);
    }
    upsample->next_row_out = 0;
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
  /* Not more than the distance to the end of the image.  Need this test
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go) 
    num_rows = upsample->rows_to_go;
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
  if (num_rows > out_rows_avail)
    num_rows = out_rows_avail;

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
				     (JDIMENSION) upsample->next_row_out,
				     output_buf + *out_row_ctr,
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  upsample->next_row_out += num_rows;
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
    (*in_row_group_ctr)++;
}


/*
 * These are the routines invoked by sep_upsample to upsample pixel values
 * of a single component.  One row group is processed per call.
 */


/*
 * For full-size components, we just make color_buf[ci] point at the
 * input buffer, and thus avoid copying any data.  Note that this is
 * safe only because sep_upsample doesn't declare the input row group
 * "consumed" until we are done color converting and emitting it.
 */

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = input_data;
}


/*
 * This is a no-op version used for "uninteresting" components.
 * These components will not be referenced by color conversion.
 */

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = NULL;	/* safety check */
}


/*
 * This version handles any integral sampling ratios.
 * This is not used for typical JPEG files, so it need not be fast.
 * Nor, for that matter, is it particularly accurate: the algorithm is
 * simple replication of the input pixel onto the corresponding output
 * pixels.  The hi-falutin sampling literature refers to this as a
 * "box filter".  A box filter tends to introduce visible artifacts,
 * so if you are actually going to use 3:1 or 4:1 sampling ratios
 * you would be well advised to improve this code.
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
  v_expand = upsample->v_expand[compptr->component_index];

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      for (h = h_expand; h > 0; h--) {
	*outptr++ = invalue;
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
			v_expand-1, cinfo->output_width);
    }
    inrow++;
    outrow += v_expand;
  }
}


/*
 * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
  }
}


/*
 * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
		      1, cinfo->output_width);
    inrow++;
    outrow += 2;
  }
}


/*
 * Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
 *
 * The upsampling algorithm is linear interpolation between pixel centers,
 * also known as a "triangle filter".  This is a good compromise between
 * speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
 * of the way between input pixel centers.
 *
 * A note about the "bias" calculations: when rounding fractional values to
 * integer, we do not want to always round 0.5 up to the next integer.
 * If we did that, we'd introduce a noticeable bias towards larger values.
 * Instead, this code is arranged so that 0.5 will be rounded up or down at
 * alternate pixel locations (a simple ordered dither pattern).
 */

METHODDEF(void)
h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register int invalue;
  register JDIMENSION colctr;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    /* Special case for first column */
    invalue = GETJSAMPLE(*inptr++);
    *outptr++ = (JSAMPLE) invalue;
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);

    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
      /* General case: 3/4 * nearer pixel + 1/4 * further pixel */
      invalue = GETJSAMPLE(*inptr++) * 3;
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
    }

    /* Special case for last column */
    invalue = GETJSAMPLE(*inptr);
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
    *outptr++ = (JSAMPLE) invalue;
  }
}


/*
 * Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
 * Again a triangle filter; see comments for h2v1 case, above.
 *
 * It is OK for us to reference the adjacent input rows because we demanded
 * context from the main buffer controller (see initialization code).
 */

METHODDEF(void)
h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr0, inptr1, outptr;
#if BITS_IN_JSAMPLE == 8
  register int thiscolsum, lastcolsum, nextcolsum;
#else
  register INT32 thiscolsum, lastcolsum, nextcolsum;
#endif
  register JDIMENSION colctr;
  int inrow, outrow, v;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    for (v = 0; v < 2; v++) {
      /* inptr0 points to nearest input row, inptr1 points to next nearest */
      inptr0 = input_data[inrow];
      if (v == 0)		/* next nearest is row above */
	inptr1 = input_data[inrow-1];
      else			/* next nearest is row below */
	inptr1 = input_data[inrow+1];
      outptr = output_data[outrow++];

      /* Special case for first column */
      thiscolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
      lastcolsum = thiscolsum; thiscolsum = nextcolsum;

      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */
	/* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */
	nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
	lastcolsum = thiscolsum; thiscolsum = nextcolsum;
      }

      /* Special case for last column */
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 7) >> 4);
    }
    inrow++;
  }
}


/*
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample;
  int ci;
  jpeg_component_info * compptr;
  boolean need_buffer, do_fancy;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
  upsample->pub.start_pass = start_pass_upsample;
  upsample->pub.upsample = sep_upsample;
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);

  /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,
   * so don't ask for it.
   */
  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
		 cinfo->min_DCT_scaled_size;
    v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
		 cinfo->min_DCT_scaled_size;
    h_out_group = cinfo->max_h_samp_factor;
    v_out_group = cinfo->max_v_samp_factor;
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
    need_buffer = TRUE;
    if (! compptr->component_needed) {
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
      need_buffer = FALSE;
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
      need_buffer = FALSE;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group == v_out_group) {
      /* Special cases for 2h1v upsampling */
      if (do_fancy && compptr->downsampled_width > 2)
	upsample->methods[ci] = h2v1_fancy_upsample;
      else
	upsample->methods[ci] = h2v1_upsample;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group * 2 == v_out_group) {
      /* Special cases for 2h2v upsampling */
      if (do_fancy && compptr->downsampled_width > 2) {
	upsample->methods[ci] = h2v2_fancy_upsample;
	upsample->pub.need_context_rows = TRUE;
      } else
	upsample->methods[ci] = h2v2_upsample;
    } else if ((h_out_group % h_in_group) == 0 &&
	       (v_out_group % v_in_group) == 0) {
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
    if (need_buffer) {
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) cinfo->output_width,
				(long) cinfo->max_h_samp_factor),
	 (JDIMENSION) cinfo->max_v_samp_factor);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdpostct.c ===
/*
 * jdpostct.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the decompression postprocessing controller.
 * This controller manages the upsampling, color conversion, and color
 * quantization/reduction steps; specifically, it controls the buffering
 * between upsample/color conversion and color quantization/reduction.
 *
 * If no color quantization/reduction is required, then this module has no
 * work to do, and it just hands off to the upsample/color conversion code.
 * An integrated upsample/convert/quantize process would replace this module
 * entirely.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Private buffer controller object */

typedef struct {
  struct jpeg_d_post_controller pub; /* public fields */

  /* Color quantization source buffer: this holds output data from
   * the upsample/color conversion step to be passed to the quantizer.
   * For two-pass color quantization, we need a full-image buffer;
   * for one-pass operation, a strip buffer is sufficient.
   */
  jvirt_sarray_ptr whole_image;	/* virtual array, or NULL if one-pass */
  JSAMPARRAY buffer;		/* strip buffer, or current strip of virtual */
  JDIMENSION strip_height;	/* buffer size in rows */
  /* for two-pass mode only: */
  JDIMENSION starting_row;	/* row # of first row in current strip */
  JDIMENSION next_row;		/* index of next row to fill/empty in strip */
} my_post_controller;

typedef my_post_controller * my_post_ptr;


/* Forward declarations */
METHODDEF(void) post_process_1pass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
#ifdef QUANT_2PASS_SUPPORTED
METHODDEF(void) post_process_prepass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
METHODDEF(void) post_process_2pass
	JPP((j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	     JDIMENSION in_row_groups_avail,
	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	     JDIMENSION out_rows_avail));
#endif


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
	post->buffer = (*cinfo->mem->access_virt_sarray)
	  ((j_common_ptr) cinfo, post->whole_image,
	   (JDIMENSION) 0, post->strip_height, TRUE);
      }
    } else {
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
    }
    break;
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    post->pub.post_process_data = post_process_prepass;
    break;
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    post->pub.post_process_data = post_process_2pass;
    break;
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
  post->starting_row = post->next_row = 0;
}


/*
 * Process some data in the one-pass (strip buffer) case.
 * This is used for color precision reduction as well as one-pass quantization.
 */

METHODDEF(void)
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
  if (max_rows > post->strip_height)
    max_rows = post->strip_height;
  num_rows = 0;
  (*cinfo->upsample->upsample) (cinfo,
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
  *out_row_ctr += num_rows;
}


#ifdef QUANT_2PASS_SUPPORTED

/*
 * Process some data in the first pass of 2-pass quantization.
 */

METHODDEF(void)
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
    post->buffer = (*cinfo->mem->access_virt_sarray)
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
  (*cinfo->upsample->upsample) (cinfo,
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
    num_rows = post->next_row - old_next_row;
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}


/*
 * Process some data in the second pass of 2-pass quantization.
 */

METHODDEF(void)
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
  my_post_ptr post = (my_post_ptr) cinfo->post;
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
    post->buffer = (*cinfo->mem->access_virt_sarray)
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
  if (num_rows > max_rows)
    num_rows = max_rows;
  /* We have to check bottom of image here, can't depend on upsampler. */
  max_rows = cinfo->output_height - post->starting_row;
  if (num_rows > max_rows)
    num_rows = max_rows;

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
		post->buffer + post->next_row, output_buf + *out_row_ctr,
		(int) num_rows);
  *out_row_ctr += num_rows;

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
  if (post->next_row >= post->strip_height) {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}

#endif /* QUANT_2PASS_SUPPORTED */


/*
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
  my_post_ptr post;

  post = (my_post_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
  post->pub.start_pass = start_pass_dpost;
  post->whole_image = NULL;	/* flag for no virtual arrays */
  post->buffer = NULL;		/* flag for no strip buffer */

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
    if (need_full_buffer) {
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 cinfo->output_width * cinfo->out_color_components,
	 (JDIMENSION) jround_up((long) cinfo->output_height,
				(long) post->strip_height),
	 post->strip_height);
#else
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif /* QUANT_2PASS_SUPPORTED */
    } else {
      /* One-pass color quantization: just make a strip buffer. */
      post->buffer = (*cinfo->mem->alloc_sarray)
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 cinfo->output_width * cinfo->out_color_components,
	 post->strip_height);
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jdtrans.c ===
/*
 * jdtrans.c
 *
 * Copyright (C) 1995-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains library routines for transcoding decompression,
 * that is, reading raw DCT coefficient arrays from an input JPEG file.
 * The routines in jdapimin.c will also be needed by a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"


/* Forward declarations */
LOCAL(void) transdecode_master_selection JPP((j_decompress_ptr cinfo));


/*
 * Read the coefficient arrays from a JPEG file.
 * jpeg_read_header must be completed before calling this.
 *
 * The entire image is read into a set of virtual coefficient-block arrays,
 * one per component.  The return value is a pointer to the array of
 * virtual-array descriptors.  These can be manipulated directly via the
 * JPEG memory manager, or handed off to jpeg_write_coefficients().
 * To release the memory occupied by the virtual arrays, call
 * jpeg_finish_decompress() when done with the data.
 *
 * Returns NULL if suspended.  This case need be checked only if
 * a suspending data source is used.
 */

GLOBAL(jvirt_barray_ptr *)
jpeg_read_coefficients (j_decompress_ptr cinfo)
{
  if (cinfo->global_state == DSTATE_READY) {
    /* First call: initialize active modules */
    transdecode_master_selection(cinfo);
    cinfo->global_state = DSTATE_RDCOEFS;
  } else if (cinfo->global_state != DSTATE_RDCOEFS)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Absorb whole file into the coef buffer */
  for (;;) {
    int retcode;
    /* Call progress monitor hook if present */
    if (cinfo->progress != NULL)
      (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
    /* Absorb some more input */
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    if (retcode == JPEG_SUSPENDED)
      return NULL;
    if (retcode == JPEG_REACHED_EOI)
      break;
    /* Advance progress counter if appropriate */
    if (cinfo->progress != NULL &&
	(retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
      if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
	/* startup underestimated number of scans; ratchet up one scan */
	cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
      }
    }
  }
  /* Set state so that jpeg_finish_decompress does the right thing */
  cinfo->global_state = DSTATE_STOPPING;
  return cinfo->coef->coef_arrays;
}


/*
 * Master selection of decompression modules for transcoding.
 * This substitutes for jdmaster.c's initialization of the full decompressor.
 */

LOCAL(void)
transdecode_master_selection (j_decompress_ptr cinfo)
{
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
  } else {
    if (cinfo->progressive_mode) {
#ifdef D_PROGRESSIVE_SUPPORTED
      jinit_phuff_decoder(cinfo);
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_decoder(cinfo);
  }

  /* Always get a full-image coefficient buffer. */
  jinit_d_coef_controller(cinfo, TRUE);

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);

  /* Initialize progress monitoring. */
  if (cinfo->progress != NULL) {
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
    } else if (cinfo->inputctl->has_multiple_scans) {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
    } else {
      nscans = 1;
    }
    cinfo->progress->pass_counter = 0L;
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
    cinfo->progress->completed_passes = 0;
    cinfo->progress->total_passes = 1;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jerror.h ===
/*
 * jerror.h
 *
 * Copyright (C) 1994-1995, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the error and message codes for the JPEG library.
 * Edit this file to add new codes, or to translate the message strings to
 * some other language.
 * A set of error-reporting macros are defined too.  Some applications using
 * the JPEG library may wish to include this file to get the error codes
 * and/or the macros.
 */

/*
 * To define the enum list of message codes, include this file without
 * defining macro JMESSAGE.  To create a message string table, include it
 * again with a suitable JMESSAGE definition (see jerror.c for an example).
 */
#ifndef JMESSAGE
#ifndef JERROR_H
/* First time through, define the enum list */
#define JMAKE_ENUM_LIST
#else
/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
#define JMESSAGE(code,string)
#endif /* JERROR_H */
#endif /* JMESSAGE */

#ifdef JMAKE_ENUM_LIST

typedef enum {

#define JMESSAGE(code,string)	code ,

#endif /* JMAKE_ENUM_LIST */

JMESSAGE(JMSG_NOMESSAGE, "Bogus message code %d") /* Must be first entry! */

/* For maintenance convenience, list is alphabetical by message code name */
JMESSAGE(JERR_ARITH_NOTIMPL,
	 "Sorry, there are legal restrictions on arithmetic coding")
JMESSAGE(JERR_BAD_ALIGN_TYPE, "ALIGN_TYPE is wrong, please fix")
JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
JMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
JMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
JMESSAGE(JERR_BAD_LENGTH, "Bogus marker length")
JMESSAGE(JERR_BAD_LIB_VERSION,
	 "Wrong JPEG library version: library is %d, caller expects %d")
JMESSAGE(JERR_BAD_MCU_SIZE, "Sampling factors too large for interleaved scan")
JMESSAGE(JERR_BAD_POOL_ID, "Invalid memory pool code %d")
JMESSAGE(JERR_BAD_PRECISION, "Unsupported JPEG data precision %d")
JMESSAGE(JERR_BAD_PROGRESSION,
	 "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d")
JMESSAGE(JERR_BAD_PROG_SCRIPT,
	 "Invalid progressive parameters at scan script entry %d")
JMESSAGE(JERR_BAD_SAMPLING, "Bogus sampling factors")
JMESSAGE(JERR_BAD_SCAN_SCRIPT, "Invalid scan script at entry %d")
JMESSAGE(JERR_BAD_STATE, "Improper call to JPEG library in state %d")
JMESSAGE(JERR_BAD_STRUCT_SIZE,
	 "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u")
JMESSAGE(JERR_BAD_VIRTUAL_ACCESS, "Bogus virtual array access")
JMESSAGE(JERR_BUFFER_SIZE, "Buffer passed to JPEG library is too small")
JMESSAGE(JERR_CANT_SUSPEND, "Suspension not allowed here")
JMESSAGE(JERR_CCIR601_NOTIMPL, "CCIR601 sampling not implemented yet")
JMESSAGE(JERR_COMPONENT_COUNT, "Too many color components: %d, max %d")
JMESSAGE(JERR_CONVERSION_NOTIMPL, "Unsupported color conversion request")
JMESSAGE(JERR_DAC_INDEX, "Bogus DAC index %d")
JMESSAGE(JERR_DAC_VALUE, "Bogus DAC value 0x%x")
JMESSAGE(JERR_DHT_COUNTS, "Bogus DHT counts")
JMESSAGE(JERR_DHT_INDEX, "Bogus DHT index %d")
JMESSAGE(JERR_DQT_INDEX, "Bogus DQT index %d")
JMESSAGE(JERR_EMPTY_IMAGE, "Empty JPEG image (DNL not supported)")
JMESSAGE(JERR_EMS_READ, "Read from EMS failed")
JMESSAGE(JERR_EMS_WRITE, "Write to EMS failed")
JMESSAGE(JERR_EOI_EXPECTED, "Didn't expect more than one scan")
JMESSAGE(JERR_FILE_READ, "Input file read error")
JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
JMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, "Fractional sampling not implemented yet")
JMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
JMESSAGE(JERR_HUFF_MISSING_CODE, "Missing Huffman code table entry")
JMESSAGE(JERR_IMAGE_TOO_BIG, "Maximum supported image dimension is %u pixels")
JMESSAGE(JERR_INPUT_EMPTY, "Empty input file")
JMESSAGE(JERR_INPUT_EOF, "Premature end of input file")
JMESSAGE(JERR_MISMATCHED_QUANT_TABLE,
	 "Cannot transcode due to multiple use of quantization table %d")
JMESSAGE(JERR_MISSING_DATA, "Scan script does not transmit all data")
JMESSAGE(JERR_MODE_CHANGE, "Invalid color quantization mode change")
JMESSAGE(JERR_NOTIMPL, "Not implemented yet")
JMESSAGE(JERR_NOT_COMPILED, "Requested feature was omitted at compile time")
JMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
JMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
JMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
JMESSAGE(JERR_NO_QUANT_TABLE, "Quantization table 0x%02x was not defined")
JMESSAGE(JERR_NO_SOI, "Not a JPEG file: starts with 0x%02x 0x%02x")
JMESSAGE(JERR_OUT_OF_MEMORY, "Insufficient memory (case %d)")
JMESSAGE(JERR_QUANT_COMPONENTS,
	 "Cannot quantize more than %d color components")
JMESSAGE(JERR_QUANT_FEW_COLORS, "Cannot quantize to fewer than %d colors")
JMESSAGE(JERR_QUANT_MANY_COLORS, "Cannot quantize to more than %d colors")
JMESSAGE(JERR_SOF_DUPLICATE, "Invalid JPEG file structure: two SOF markers")
JMESSAGE(JERR_SOF_NO_SOS, "Invalid JPEG file structure: missing SOS marker")
JMESSAGE(JERR_SOF_UNSUPPORTED, "Unsupported JPEG process: SOF type 0x%02x")
JMESSAGE(JERR_SOI_DUPLICATE, "Invalid JPEG file structure: two SOI markers")
JMESSAGE(JERR_SOS_NO_SOF, "Invalid JPEG file structure: SOS before SOF")
JMESSAGE(JERR_TFILE_CREATE, "Failed to create temporary file %s")
JMESSAGE(JERR_TFILE_READ, "Read failed on temporary file")
JMESSAGE(JERR_TFILE_SEEK, "Seek failed on temporary file")
JMESSAGE(JERR_TFILE_WRITE,
	 "Write failed on temporary file --- out of disk space?")
JMESSAGE(JERR_TOO_LITTLE_DATA, "Application transferred too few scanlines")
JMESSAGE(JERR_UNKNOWN_MARKER, "Unsupported marker type 0x%02x")
JMESSAGE(JERR_VIRTUAL_BUG, "Virtual array controller messed up")
JMESSAGE(JERR_WIDTH_OVERFLOW, "Image too wide for this implementation")
JMESSAGE(JERR_XMS_READ, "Read from XMS failed")
JMESSAGE(JERR_XMS_WRITE, "Write to XMS failed")
JMESSAGE(JMSG_COPYRIGHT, JCOPYRIGHT)
JMESSAGE(JMSG_VERSION, JVERSION)
JMESSAGE(JTRC_16BIT_TABLES,
	 "Caution: quantization tables are too coarse for baseline JPEG")
JMESSAGE(JTRC_ADOBE,
	 "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d")
JMESSAGE(JTRC_APP0, "Unknown APP0 marker (not JFIF), length %u")
JMESSAGE(JTRC_APP14, "Unknown APP14 marker (not Adobe), length %u")
JMESSAGE(JTRC_DAC, "Define Arithmetic Table 0x%02x: 0x%02x")
JMESSAGE(JTRC_DHT, "Define Huffman Table 0x%02x")
JMESSAGE(JTRC_DQT, "Define Quantization Table %d  precision %d")
JMESSAGE(JTRC_DRI, "Define Restart Interval %u")
JMESSAGE(JTRC_EMS_CLOSE, "Freed EMS handle %u")
JMESSAGE(JTRC_EMS_OPEN, "Obtained EMS handle %u")
JMESSAGE(JTRC_EOI, "End Of Image")
JMESSAGE(JTRC_HUFFBITS, "        %3d %3d %3d %3d %3d %3d %3d %3d")
JMESSAGE(JTRC_JFIF, "JFIF APP0 marker, density %dx%d  %d")
JMESSAGE(JTRC_JFIF_BADTHUMBNAILSIZE,
	 "Warning: thumbnail image size does not match data length %u")
JMESSAGE(JTRC_JFIF_MINOR, "Unknown JFIF minor revision number %d.%02d")
JMESSAGE(JTRC_JFIF_THUMBNAIL, "    with %d x %d thumbnail image")
JMESSAGE(JTRC_MISC_MARKER, "Skipping marker 0x%02x, length %u")
JMESSAGE(JTRC_PARMLESS_MARKER, "Unexpected marker 0x%02x")
JMESSAGE(JTRC_QUANTVALS, "        %4u %4u %4u %4u %4u %4u %4u %4u")
JMESSAGE(JTRC_QUANT_3_NCOLORS, "Quantizing to %d = %d*%d*%d colors")
JMESSAGE(JTRC_QUANT_NCOLORS, "Quantizing to %d colors")
JMESSAGE(JTRC_QUANT_SELECTED, "Selected %d colors for quantization")
JMESSAGE(JTRC_RECOVERY_ACTION, "At marker 0x%02x, recovery action %d")
JMESSAGE(JTRC_RST, "RST%d")
JMESSAGE(JTRC_SMOOTH_NOTIMPL,
	 "Smoothing not supported with nonstandard sampling ratios")
JMESSAGE(JTRC_SOF, "Start Of Frame 0x%02x: width=%u, height=%u, components=%d")
JMESSAGE(JTRC_SOF_COMPONENT, "    Component %d: %dhx%dv q=%d")
JMESSAGE(JTRC_SOI, "Start of Image")
JMESSAGE(JTRC_SOS, "Start Of Scan: %d components")
JMESSAGE(JTRC_SOS_COMPONENT, "    Component %d: dc=%d ac=%d")
JMESSAGE(JTRC_SOS_PARAMS, "  Ss=%d, Se=%d, Ah=%d, Al=%d")
JMESSAGE(JTRC_TFILE_CLOSE, "Closed temporary file %s")
JMESSAGE(JTRC_TFILE_OPEN, "Opened temporary file %s")
JMESSAGE(JTRC_UNKNOWN_IDS,
	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
JMESSAGE(JWRN_ADOBE_XFORM, "Unknown Adobe color transform code %d")
JMESSAGE(JWRN_BOGUS_PROGRESSION,
	 "Inconsistent progression sequence for component %d coefficient %d")
JMESSAGE(JWRN_EXTRANEOUS_DATA,
	 "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x")
JMESSAGE(JWRN_HIT_MARKER, "Corrupt JPEG data: premature end of data segment")
JMESSAGE(JWRN_HUFF_BAD_CODE, "Corrupt JPEG data: bad Huffman code")
JMESSAGE(JWRN_JFIF_MAJOR, "Warning: unknown JFIF revision number %d.%02d")
JMESSAGE(JWRN_JPEG_EOF, "Premature end of JPEG file")
JMESSAGE(JWRN_MUST_RESYNC,
	 "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
JMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
JMESSAGE(JWRN_TOO_MUCH_DATA, "Application transferred too many scanlines")

#ifdef JMAKE_ENUM_LIST

  JMSG_LASTMSGCODE
} J_MESSAGE_CODE;

#undef JMAKE_ENUM_LIST
#endif /* JMAKE_ENUM_LIST */

/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
#undef JMESSAGE


#ifndef JERROR_H
#define JERROR_H

/* Macros to simplify using the error and trace message stuff */
/* The first parameter is either type of cinfo pointer */

/* Fatal errors (print message and exit) */
#define ERREXIT(cinfo,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT1(cinfo,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT2(cinfo,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT3(cinfo,code,p1,p2,p3)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (cinfo)->err->msg_parm.i[2] = (p3), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXIT4(cinfo,code,p1,p2,p3,p4)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (cinfo)->err->msg_parm.i[2] = (p3), \
   (cinfo)->err->msg_parm.i[3] = (p4), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
#define ERREXITS(cinfo,code,str)  \
  ((cinfo)->err->msg_code = (code), \
   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))

#define MAKESTMT(stuff)		do { stuff } while (0)

/* Nonfatal errors (we can keep going, but the data is probably corrupt) */
#define WARNMS(cinfo,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
#define WARNMS1(cinfo,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
#define WARNMS2(cinfo,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))

/* Informational/debugging messages */
#define TRACEMS(cinfo,lvl,code)  \
  ((cinfo)->err->msg_code = (code), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS1(cinfo,lvl,code,p1)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS2(cinfo,lvl,code,p1,p2)  \
  ((cinfo)->err->msg_code = (code), \
   (cinfo)->err->msg_parm.i[0] = (p1), \
   (cinfo)->err->msg_parm.i[1] = (p2), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
#define TRACEMS3(cinfo,lvl,code,p1,p2,p3)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMS4(cinfo,lvl,code,p1,p2,p3,p4)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMS8(cinfo,lvl,code,p1,p2,p3,p4,p5,p6,p7,p8)  \
  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
	   _mp[4] = (p5); _mp[5] = (p6); _mp[6] = (p7); _mp[7] = (p8); \
	   (cinfo)->err->msg_code = (code); \
	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
#define TRACEMSS(cinfo,lvl,code,str)  \
  ((cinfo)->err->msg_code = (code), \
   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))

#endif /* JERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jidctred.c ===
/*
 * jidctred.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains inverse-DCT routines that produce reduced-size output:
 * either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
 *
 * The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&M)
 * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step
 * with an 8-to-4 step that produces the four averages of two adjacent outputs
 * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
 * These steps were derived by computing the corresponding values at the end
 * of the normal LL&M code, then simplifying as much as possible.
 *
 * 1x1 is trivial: just take the DC coefficient divided by 8.
 *
 * See jidctint.c for additional comments.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef IDCT_SCALING_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling is the same as in jidctint.c. */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 13
#define FIX_0_211164243  ((INT32)  1730)	/* FIX(0.211164243) */
#define FIX_0_509795579  ((INT32)  4176)	/* FIX(0.509795579) */
#define FIX_0_601344887  ((INT32)  4926)	/* FIX(0.601344887) */
#define FIX_0_720959822  ((INT32)  5906)	/* FIX(0.720959822) */
#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
#define FIX_0_850430095  ((INT32)  6967)	/* FIX(0.850430095) */
#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
#define FIX_1_061594337  ((INT32)  8697)	/* FIX(1.061594337) */
#define FIX_1_272758580  ((INT32)  10426)	/* FIX(1.272758580) */
#define FIX_1_451774981  ((INT32)  11893)	/* FIX(1.451774981) */
#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
#define FIX_2_172734803  ((INT32)  17799)	/* FIX(2.172734803) */
#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
#define FIX_3_624509785  ((INT32)  29692)	/* FIX(3.624509785) */
#else
#define FIX_0_211164243  FIX(0.211164243)
#define FIX_0_509795579  FIX(0.509795579)
#define FIX_0_601344887  FIX(0.601344887)
#define FIX_0_720959822  FIX(0.720959822)
#define FIX_0_765366865  FIX(0.765366865)
#define FIX_0_850430095  FIX(0.850430095)
#define FIX_0_899976223  FIX(0.899976223)
#define FIX_1_061594337  FIX(1.061594337)
#define FIX_1_272758580  FIX(1.272758580)
#define FIX_1_451774981  FIX(1.451774981)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_172734803  FIX(2.172734803)
#define FIX_2_562915447  FIX(2.562915447)
#define FIX_3_624509785  FIX(3.624509785)
#endif


/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
 * For 8-bit samples with the recommended scaling, all the variable
 * and constant values involved are no more than 16 bits wide, so a
 * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
 * For 12-bit samples, a full 32-bit multiplication will be needed.
 */

#if BITS_IN_JSAMPLE == 8
#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
#else
#define MULTIPLY(var,const)  ((var) * (const))
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce an int result.  In this module, both inputs and result
 * are 16 bits or less, so either int or short multiply will work.
 */

#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 4x4 output block.
 */

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp2, tmp10, tmp12;
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE*4];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process column 4, because second pass won't use it */
    if (ctr == DCTSIZE-4)
      continue;
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*5] | inptr[DCTSIZE*6] | inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero; we need not examine term 4 for 4x4 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      
      continue;
    }
    
    /* Even part */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp0 <<= (CONST_BITS+1);
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
    
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    
    /* Odd part */
    
    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    z2 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    z4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    
    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
    
    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
  }
  
  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 4; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[5] | wsptr[6] |
	 wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      
      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part */
    
    tmp0 = ((INT32) wsptr[0]) << (CONST_BITS+1);
    
    tmp2 = MULTIPLY((INT32) wsptr[2], FIX_1_847759065)
	 + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);
    
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    
    /* Odd part */
    
    z1 = (INT32) wsptr[7];
    z2 = (INT32) wsptr[5];
    z3 = (INT32) wsptr[3];
    z4 = (INT32) wsptr[1];
    
    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */
    
    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp2,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp12 + tmp0,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 2x2 output block.
 */

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp10, z1;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE*2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process columns 2,4,6 */
    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
      continue;
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*5] | inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      
      continue;
    }
    
    /* Even part */
    
    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp10 = z1 << (CONST_BITS+2);
    
    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp0 += MULTIPLY(z1, FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */

    /* Final output stage */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
  }
  
  /* Pass 2: process 2 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 2; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[3] | wsptr[5] | wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      
      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part */
    
    tmp10 = ((INT32) wsptr[0]) << (CONST_BITS+2);
    
    /* Odd part */

    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
	 + MULTIPLY((INT32) wsptr[5], FIX_0_850430095) /* sqrt(2) * (-c1+c3+c5+c7) */
	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
	 + MULTIPLY((INT32) wsptr[1], FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */

    /* Final output stage */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp0,
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}


/*
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 1x1 output block.
 */

GLOBAL(void)
jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
  int dcval;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  SHIFT_TEMPS

  /* We hardly need an inverse DCT routine for this: just take the
   * average pixel value, which is one-eighth of the DC coefficient.
   */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
  dcval = (int) DESCALE((INT32) dcval, 3);

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
}

#endif /* IDCT_SCALING_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jidctfst.c ===
/*
 * jidctfst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a fast, not so accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with fixed-point math,
 * accuracy is lost due to imprecise representation of the scaled
 * quantization values.  The smaller the quantization table entry, the less
 * precise the scaled value, so this implementation does worse with high-
 * quality-setting files than with low-quality ones.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_IFAST_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling decisions are generally the same as in the LL&M algorithm;
 * see jidctint.c for more details.  However, we choose to descale
 * (right shift) multiplication products as soon as they are formed,
 * rather than carrying additional fractional bits into subsequent additions.
 * This compromises accuracy slightly, but it lets us save a few shifts.
 * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
 * everywhere except in the multiplications proper; this saves a good deal
 * of work on 16-bit-int machines.
 *
 * The dequantized coefficients are not integers because the AA&N scaling
 * factors have been incorporated.  We represent them scaled up by PASS1_BITS,
 * so that the first and second IDCT rounds have the same input scaling.
 * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
 * avoid a descaling shift; this compromises accuracy rather drastically
 * for small quantization table entries, but it saves a lot of shifts.
 * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
 * so we use a much larger scaling factor to preserve accuracy.
 *
 * A final compromise is to represent the multiplicative constants to only
 * 8 fractional bits, rather than 13.  This saves some shifting work on some
 * machines, and may also reduce the cost of multiplication (since there
 * are fewer one-bits in the constants).
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  8
#define PASS1_BITS  2
#else
#define CONST_BITS  8
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */ 

#if CONST_BITS == 8
#define FIX_1_082392200  ((INT32)  277)		/* FIX(1.082392200) */
#define FIX_1_414213562  ((INT32)  362)		/* FIX(1.414213562) */
#define FIX_1_847759065  ((INT32)  473)		/* FIX(1.847759065) */
#define FIX_2_613125930  ((INT32)  669)		/* FIX(2.613125930) */
#else
#define FIX_1_082392200  FIX(1.082392200)
#define FIX_1_414213562  FIX(1.414213562)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_613125930  FIX(2.613125930)
#endif


/* We can gain a little more speed, with a further compromise in accuracy,
 * by omitting the addition in a descaling shift.  This yields an incorrectly
 * rounded result half the time...
 */

#ifndef USE_ACCURATE_ROUNDING
#undef DESCALE
#define DESCALE(x,n)  RIGHT_SHIFT(x, n)
#endif

//#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
/* Multiply a DCTELEM variable by an INT32 constant, and immediately
 * descale to yield a DCTELEM result.
 */

//#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))
#define MULTIPLY(var,const)  ((DCTELEM) ((var) * (const)))


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
 * multiplication will do.  For 12-bit data, the multiplier table is
 * declared INT32, so a 32-bit multiply will be used.
 */

#if BITS_IN_JSAMPLE == 8
//#define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))
#define DEQUANTIZE(coef,quantval)  (((coef)) * (quantval))
#else
#define DEQUANTIZE(coef,quantval)  \
	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
#endif

 
/* Like DESCALE, but applies to a DCTELEM and produces an int.
 * We assume that int right shift is unsigned if INT32 right shift is.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define ISHIFT_TEMPS	DCTELEM ishift_temp;
#if BITS_IN_JSAMPLE == 8
#define DCTELEMBITS  16		/* DCTELEM may be 16 or 32 bits */
#else
#define DCTELEMBITS  32		/* DCTELEM must be 32 bits */
#endif
#define IRIGHT_SHIFT(x,shft)  \
    ((ishift_temp = (x)) < 0 ? \
     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
     (ishift_temp >> (shft)))
#else
#define ISHIFT_TEMPS
#define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif

#ifdef USE_ACCURATE_ROUNDING
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
#else
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT(x, n))
#endif


#ifdef USECSOURCE

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  DCTELEM tmp10, tmp11, tmp12, tmp13;
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE2];	/* buffers data between passes */
  SHIFT_TEMPS			/* for DESCALE */
  ISHIFT_TEMPS			/* for IDESCALE */
  
 
	  IFAST_MULT_TYPE * quantptr;
	  int *wsptr;

	  /* Pass 1: process columns from input, store into work array. */

	  inptr = coef_block;
	  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
	  wsptr = workspace;
	  for (ctr = DCTSIZE; ctr > 0; ctr--) {
		/* Due to quantization, we will usually find that many of the input
		 * coefficients are zero, especially the AC terms.  We can exploit this
		 * by short-circuiting the IDCT calculation for any column in which all
		 * the AC terms are zero.  In that case each output is equal to the
		 * DC coefficient (with scale factor as needed).
		 * With typical images and quantization tables, half or more of the
		 * column DCT calculations can be simplified this way.
		 */
    
		if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
		 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
		 inptr[DCTSIZE*7]) == 0) {
		  /* AC terms all zero */
		  int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);

		  wsptr[DCTSIZE*0] = dcval;
		  wsptr[DCTSIZE*1] = dcval;
		  wsptr[DCTSIZE*2] = dcval;
		  wsptr[DCTSIZE*3] = dcval;
		  wsptr[DCTSIZE*4] = dcval;
		  wsptr[DCTSIZE*5] = dcval;
		  wsptr[DCTSIZE*6] = dcval;
		  wsptr[DCTSIZE*7] = dcval;
      
		  inptr++;			/* advance pointers to next column */
		  quantptr++;
		  wsptr++;
		  continue;
		}
    
		/* Even part */

		tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
		tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
		tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
		tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

		tmp10 = tmp0 + tmp2;	/* phase 3 */
		tmp11 = tmp0 - tmp2;

		tmp13 = tmp1 + tmp3;	/* phases 5-3 */
		tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */

		tmp0 = tmp10 + tmp13;	/* phase 2 */
		tmp3 = tmp10 - tmp13;
		tmp1 = tmp11 + tmp12;
		tmp2 = tmp11 - tmp12;
    
		/* Odd part */

		tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
		tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
		tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
		tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);

		z13 = tmp6 + tmp5;		/* phase 6 */
		z10 = tmp6 - tmp5;
		z11 = tmp4 + tmp7;
		z12 = tmp4 - tmp7;

		tmp7 = z11 + z13;		/* phase 5 */
		tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

		z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
		tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
		tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

		tmp6 = tmp12 - tmp7;	/* phase 2 */
		tmp5 = tmp11 - tmp6;
		tmp4 = tmp10 + tmp5;

		wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
		wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
		wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
		wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
		wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
		wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
		wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
		wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);

		inptr++;			/* advance pointers to next column */
		quantptr++;
		wsptr++;
	  }
  
	  /* Pass 2: process rows from work array, store into output array. */
	  /* Note that we must descale the results by a factor of 8 == 2**3, */
	  /* and also undo the PASS1_BITS scaling. */

	  wsptr = workspace;
	  for (ctr = 0; ctr < DCTSIZE; ctr++) {
		outptr = output_buf[ctr] + output_col;
		/* Rows of zeroes can be exploited in the same way as we did with columns.
		 * However, the column calculation has created many nonzero AC terms, so
		 * the simplification applies less often (typically 5% to 10% of the time).
		 * On machines with very fast multiplication, it's possible that the
		 * test takes more time than it's worth.  In that case this section
		 * may be commented out.
		 */
    
	#ifndef NO_ZERO_ROW_TEST
		if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
		 wsptr[7]) == 0) {
		  /* AC terms all zero */
		  JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
					  & RANGE_MASK];
      
		  outptr[0] = dcval;
		  outptr[1] = dcval;
		  outptr[2] = dcval;
		  outptr[3] = dcval;
		  outptr[4] = dcval;
		  outptr[5] = dcval;
		  outptr[6] = dcval;
		  outptr[7] = dcval;

		  wsptr += DCTSIZE;		/* advance pointer to next row */
		  continue;
		}
	#endif
    
		/* Even part */

		tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
		tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);

		tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
		tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
			- tmp13;

		tmp0 = tmp10 + tmp13;
		tmp3 = tmp10 - tmp13;
		tmp1 = tmp11 + tmp12;
		tmp2 = tmp11 - tmp12;

		/* Odd part */

		z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
		z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
		z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
		z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];

		tmp7 = z11 + z13;		/* phase 5 */
		tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

		z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
		tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
		tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

		tmp6 = tmp12 - tmp7;	/* phase 2 */
		tmp5 = tmp11 - tmp6;
		tmp4 = tmp10 + tmp5;

		/* Final output stage: scale down by a factor of 8 and range-limit */
 
		outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
					& RANGE_MASK];
		outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
					& RANGE_MASK];

		wsptr += DCTSIZE;		/* advance pointer to next row */
	  }
	}

#else

extern void midct8x8aan(short* dctcoeff, short* tempcoeff, short* quantptr,
				  JSAMPARRAY output_buf, JDIMENSION output_col,
				  JSAMPLE *range_limit ) ;

extern void pidct8x8aan(short* dctcoeff, short* tempcoeff, short* quantptr,
				  JSAMPARRAY output_buf, JDIMENSION output_col,
				  JSAMPLE *range_limit ) ;


/*
* Perform dequantization and inverse DCT on one block of coefficients.
*/

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  short * quantptr;
  short * wsptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  short aworkspace[DCTSIZE2+8] ;

  // ensure that the temporary working space is quad aligned
  wsptr = (short *)((INT32)(aworkspace) + 0x8) ;
  wsptr = (short *)((INT32)(wsptr) & 0xfffffff8) ;


  quantptr = (short *) compptr->dct_table;
  
  // do the 2-Dal idct and store the corresponding results
  // from the range_limit array

  if(vfMMXMachine) {
    midct8x8aan(coef_block, wsptr, quantptr, output_buf, output_col, range_limit) ;
  }
  else {
    pidct8x8aan(coef_block, wsptr, quantptr, output_buf, output_col, range_limit) ;
  }

}

#endif //USECSOURCE

#endif /* DCT_IFAST_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jidctflt.c ===
/*
 * jidctflt.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a floating-point implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * This implementation should be more accurate than either of the integer
 * IDCT implementations.  However, it may not give the same results on all
 * machines because of differences in roundoff behavior.  Speed will depend
 * on the hardware's floating point capacity.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with a fixed-point
 * implementation, accuracy is lost due to imprecise representation of the
 * scaled quantization values.  However, that problem does not arise if
 * we use floating point arithmetic.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_FLOAT_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a float result.
 */

#define DEQUANTIZE(coef,quantval)  (((FAST_FLOAT) (coef)) * (quantval))


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;
  FAST_FLOAT z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  FLOAT_MULT_TYPE * quantptr;
  FAST_FLOAT * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
    /* Due to quantization, we will usually find that many of the input
     * coefficients are zero, especially the AC terms.  We can exploit this
     * by short-circuiting the IDCT calculation for any column in which all
     * the AC terms are zero.  In that case each output is equal to the
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
	 inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero */
      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      wsptr[DCTSIZE*4] = dcval;
      wsptr[DCTSIZE*5] = dcval;
      wsptr[DCTSIZE*6] = dcval;
      wsptr[DCTSIZE*7] = dcval;
      
      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp10 = tmp0 + tmp2;	/* phase 3 */
    tmp11 = tmp0 - tmp2;

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */

    tmp0 = tmp10 + tmp13;	/* phase 2 */
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);

    z13 = tmp6 + tmp5;		/* phase 6 */
    z10 = tmp6 - tmp5;
    z11 = tmp4 + tmp7;
    z12 = tmp4 - tmp7;

    tmp7 = z11 + z13;		/* phase 5 */
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    wsptr[DCTSIZE*0] = tmp0 + tmp7;
    wsptr[DCTSIZE*7] = tmp0 - tmp7;
    wsptr[DCTSIZE*1] = tmp1 + tmp6;
    wsptr[DCTSIZE*6] = tmp1 - tmp6;
    wsptr[DCTSIZE*2] = tmp2 + tmp5;
    wsptr[DCTSIZE*5] = tmp2 - tmp5;
    wsptr[DCTSIZE*4] = tmp3 + tmp4;
    wsptr[DCTSIZE*3] = tmp3 - tmp4;

    inptr++;			/* advance pointers to next column */
    quantptr++;
    wsptr++;
  }
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* Rows of zeroes can be exploited in the same way as we did with columns.
     * However, the column calculation has created many nonzero AC terms, so
     * the simplification applies less often (typically 5% to 10% of the time).
     * And testing floats for zero is relatively expensive, so we don't bother.
     */
    
    /* Even part */

    tmp10 = wsptr[0] + wsptr[4];
    tmp11 = wsptr[0] - wsptr[4];

    tmp13 = wsptr[2] + wsptr[6];
    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;

    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;

    /* Odd part */

    z13 = wsptr[5] + wsptr[3];
    z10 = wsptr[5] - wsptr[3];
    z11 = wsptr[1] + wsptr[7];
    z12 = wsptr[1] - wsptr[7];

    tmp7 = z11 + z13;
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[(int) DESCALE((INT32) (tmp0 + tmp7), 3)
			    & RANGE_MASK];
    outptr[7] = range_limit[(int) DESCALE((INT32) (tmp0 - tmp7), 3)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE((INT32) (tmp1 + tmp6), 3)
			    & RANGE_MASK];
    outptr[6] = range_limit[(int) DESCALE((INT32) (tmp1 - tmp6), 3)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE((INT32) (tmp2 + tmp5), 3)
			    & RANGE_MASK];
    outptr[5] = range_limit[(int) DESCALE((INT32) (tmp2 - tmp5), 3)
			    & RANGE_MASK];
    outptr[4] = range_limit[(int) DESCALE((INT32) (tmp3 + tmp4), 3)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE((INT32) (tmp3 - tmp4), 3)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}

#endif /* DCT_FLOAT_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jinclude.h ===
/*
 * jinclude.h
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file exists to provide a single place to fix any problems with
 * including the wrong system include files.  (Common problems are taken
 * care of by the standard jconfig symbols, but on really weird systems
 * you may have to edit this file.)
 *
 * NOTE: this file is NOT intended to be included by applications using the
 * JPEG library.  Most applications need only include jpeglib.h.
 */


/* Include auto-config file to find out which system include files we need. */

#include "jconfig.h"		/* auto configuration options */
#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */

#ifndef X_MARKCODE_HXX_
#define X_MARKCODE_HXX_
#include "..\..\..\core\include\markcode.hxx"
#endif

/*
 * We need the NULL macro and size_t typedef.
 * On an ANSI-conforming system it is sufficient to include <stddef.h>.
 * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
 * pull in <sys/types.h> as well.
 * Note that the core JPEG library does not require <stdio.h>;
 * only the default error handler and data source/destination modules do.
 * But we must pull it in because of the references to FILE in jpeglib.h.
 * You can remove those references if you want to compile without <stdio.h>.
 */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
#endif

#include <stdio.h>

/*
 * We need memory copying and zeroing functions, plus strncpy().
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * Some systems may declare memset and memcpy in <memory.h>.
 *
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Change the casts in these macros if not!
 */

#ifdef NEED_BSD_STRINGS

#include <strings.h>
#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))

#else /* not BSD, assume ANSI/SysV string lib */

#include <string.h>
#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))

#endif

/*
 * In ANSI C, and indeed any rational implementation, size_t is also the
 * type returned by sizeof().  However, it seems there are some irrational
 * implementations out there, in which sizeof() returns an int even though
 * size_t is defined as long or unsigned long.  To ensure consistent results
 * we always use this SIZEOF() macro in place of using sizeof() directly.
 */

#define SIZEOF(object)	((size_t) sizeof(object))

/*
 * The modules that use fread() and fwrite() always invoke them through
 * these macros.  On some systems you may need to twiddle the argument casts.
 * CAUTION: argument order is different from underlying functions!
 */

#define JFREAD(file,buf,sizeofbuf)  \
  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
#define JFWRITE(file,buf,sizeofbuf)  \
  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
	
/*
 * USEINLINEASM is defined on intel platforms allowing the JPEG decoder to run faster.
 * You can also remove this definition to test non-intel platform behavior on an intel
 * machine.  Code checks this macro with #ifdef.
 *
 */

#if defined(_X86_) && !defined(WIN16)
#define USEINLINEASM
#else
#define USECSOURCE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jidctint.c ===
/*
 * jidctint.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a slow-but-accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on an algorithm described in
 *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
 *   Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
 *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
 * The primary algorithm described there uses 11 multiplies and 29 adds.
 * We use their alternate method with 12 multiplies and 32 adds.
 * The advantage of this method is that no data path contains more than one
 * multiplication; this allows a very simple and accurate implementation in
 * scaled fixed-point arithmetic, with a minimal number of shifts.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_ISLOW_SUPPORTED


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/*
 * The poop on this scaling stuff is as follows:
 *
 * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
 * larger than the true IDCT outputs.  The final outputs are therefore
 * a factor of N larger than desired; since N=8 this can be cured by
 * a simple right shift at the end of the algorithm.  The advantage of
 * this arrangement is that we save two multiplications per 1-D IDCT,
 * because the y0 and y4 inputs need not be divided by sqrt(N).
 *
 * We have to do addition and subtraction of the integer inputs, which
 * is no problem, and multiplication by fractional constants, which is
 * a problem to do in integer arithmetic.  We multiply all the constants
 * by CONST_SCALE and convert them to integer constants (thus retaining
 * CONST_BITS bits of precision in the constants).  After doing a
 * multiplication we have to divide the product by CONST_SCALE, with proper
 * rounding, to produce the correct output.  This division can be done
 * cheaply as a right shift of CONST_BITS bits.  We postpone shifting
 * as long as possible so that partial sums can be added together with
 * full fractional precision.
 *
 * The outputs of the first pass are scaled up by PASS1_BITS bits so that
 * they are represented to better-than-integral precision.  These outputs
 * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
 * with the recommended scaling.  (To scale up 12-bit sample data further, an
 * intermediate INT32 array would be needed.)
 *
 * To avoid overflow of the 32-bit intermediate results in pass 2, we must
 * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis
 * shows that the values given below are the most effective.
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */

#if CONST_BITS == 13
#define FIX_0_298631336  ((INT32)  2446)	/* FIX(0.298631336) */
#define FIX_0_390180644  ((INT32)  3196)	/* FIX(0.390180644) */
#define FIX_0_541196100  ((INT32)  4433)	/* FIX(0.541196100) */
#define FIX_0_765366865  ((INT32)  6270)	/* FIX(0.765366865) */
#define FIX_0_899976223  ((INT32)  7373)	/* FIX(0.899976223) */
#define FIX_1_175875602  ((INT32)  9633)	/* FIX(1.175875602) */
#define FIX_1_501321110  ((INT32)  12299)	/* FIX(1.501321110) */
#define FIX_1_847759065  ((INT32)  15137)	/* FIX(1.847759065) */
#define FIX_1_961570560  ((INT32)  16069)	/* FIX(1.961570560) */
#define FIX_2_053119869  ((INT32)  16819)	/* FIX(2.053119869) */
#define FIX_2_562915447  ((INT32)  20995)	/* FIX(2.562915447) */
#define FIX_3_072711026  ((INT32)  25172)	/* FIX(3.072711026) */
#else
#define FIX_0_298631336  FIX(0.298631336)
#define FIX_0_390180644  FIX(0.390180644)
#define FIX_0_541196100  FIX(0.541196100)
#define FIX_0_765366865  FIX(0.765366865)
#define FIX_0_899976223  FIX(0.899976223)
#define FIX_1_175875602  FIX(1.175875602)
#define FIX_1_501321110  FIX(1.501321110)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_1_961570560  FIX(1.961570560)
#define FIX_2_053119869  FIX(2.053119869)
#define FIX_2_562915447  FIX(2.562915447)
#define FIX_3_072711026  FIX(3.072711026)
#endif


#if BITS_IN_JSAMPLE == 8
#define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
#else
#define MULTIPLY(var,const)  ((var) * (const))
#endif


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce an int result.  In this module, both inputs and result
 * are 16 bits or less, so either int or short multiply will work.
 */

#define DEQUANTIZE(coef,quantval)  (((ISLOW_MULT_TYPE) (coef)) * (quantval))




#ifdef USECSOURCE

 /*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_islow(j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
  INT32 tmp0, tmp1, tmp2, tmp3;
  INT32 tmp10, tmp11, tmp12, tmp13;
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int ctr;
  int workspace[DCTSIZE2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
    /* Due to quantization, we will usually find that many of the input
     * coefficients are zero, especially the AC terms.  We can exploit this
     * by short-circuiting the IDCT calculation for any column in which all
     * the AC terms are zero.  In that case each output is equal to the
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if ((inptr[DCTSIZE*1] | inptr[DCTSIZE*2] | inptr[DCTSIZE*3] |
	 inptr[DCTSIZE*4] | inptr[DCTSIZE*5] | inptr[DCTSIZE*6] |
	 inptr[DCTSIZE*7]) == 0) {
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
      
      wsptr[DCTSIZE*0] = dcval;
      wsptr[DCTSIZE*1] = dcval;
      wsptr[DCTSIZE*2] = dcval;
      wsptr[DCTSIZE*3] = dcval;
      wsptr[DCTSIZE*4] = dcval;
      wsptr[DCTSIZE*5] = dcval;
      wsptr[DCTSIZE*6] = dcval;
      wsptr[DCTSIZE*7] = dcval;
      
      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
    }
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);

    tmp0 = (z2 + z3) << CONST_BITS;
    tmp1 = (z2 - z3) << CONST_BITS;
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
    
    inptr++;			/* advance pointers to next column */
    quantptr++;
    wsptr++;
  }
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
    /* Rows of zeroes can be exploited in the same way as we did with columns.
     * However, the column calculation has created many nonzero AC terms, so
     * the simplification applies less often (typically 5% to 10% of the time).
     * On machines with very fast multiplication, it's possible that the
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if ((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
	 wsptr[7]) == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
      
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      outptr[4] = dcval;
      outptr[5] = dcval;
      outptr[6] = dcval;
      outptr[7] = dcval;

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
    }
#endif
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
    z3 = (INT32) wsptr[6];
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
    
    tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
    
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = (INT32) wsptr[7];
    tmp1 = (INT32) wsptr[5];
    tmp2 = (INT32) wsptr[3];
    tmp3 = (INT32) wsptr[1];
    
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
    
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
    
    z3 += z5;
    z4 += z5;
    
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}

#else

extern void midct8x8llm(JCOEFPTR inptr, short *quantptr, short *wsptr,
							JSAMPARRAY output_buf, JDIMENSION output_col,
							JSAMPLE *range);

extern void pidct8x8llm(JCOEFPTR inptr, short *quantptr, short *wsptr,
							JSAMPARRAY output_buf, JDIMENSION output_col,
							JSAMPLE *range);


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 * MMX Enhanced and Pentium enhanced versions.
 */

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
  JCOEFPTR inptr;
  short * quantptr;
  short * wsptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
  int workspace[DCTSIZE2+8];	/* buffers data between passes */

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  // ensure that the temporary working space is quad aligned
  wsptr = (short *)((INT32)(workspace) + 0x8) ;
  wsptr = (short *)((INT32)(wsptr) & 0xfffffff8) ;


  inptr = coef_block;
  quantptr = (short *) compptr->dct_table;
  wsptr = (short *)workspace;
  
  if (vfMMXMachine) {	
    midct8x8llm(inptr, quantptr, wsptr,output_buf, output_col,range_limit ) ;
  }
  else {
    pidct8x8llm(inptr, quantptr, wsptr,output_buf, output_col,range_limit ) ;    
  }
}
#endif //USECSOURCE

#endif /* DCT_ISLOW_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jmemnobs.c ===
/*
 * jmemnobs.c
 *
 * Copyright (C) 1992-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides a really simple implementation of the system-
 * dependent portion of the JPEG memory manager.  This implementation
 * assumes that no backing-store files are needed: all required space
 * can be obtained from malloc().
 * This is very portable in the sense that it'll compile on almost anything,
 * but you'd better have lots of main memory (or virtual memory) if you want
 * to process big images.
 * Note that the max_memory_to_use option is ignored by this implementation.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jmemsys.h"		/* import the system-dependent declarations */

#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare malloc(),free() */
extern void * malloc JPP((size_t size));
extern void free JPP((void *ptr));
#endif


/*
 * Memory allocation and freeing are controlled by the regular library
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
  free(object);
}


/*
 * "Large" objects are treated the same as "small" ones.
 * NB: although we include FAR keywords in the routine declarations,
 * this file won't actually work in 80x86 small/medium model; at least,
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void FAR *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
  free(object);
}


/*
 * This routine computes the total memory space available for allocation.
 * Here we always say, "we got all you want bud!"
 */

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
  return max_bytes_needed;
}


/*
 * Backing store (temporary file) management.
 * Since jpeg_mem_available always promised the moon,
 * this should never be called and we can just error out.
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
}


/*
 * These routines take care of any system-dependent initialization and
 * cleanup required.  Here, there isn't any.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
  return 0;			/* just set max_memory_to_use to 0 */
}

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
  /* no work */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jmemmgr.c ===
/*
 * jmemmgr.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the JPEG system-independent memory management
 * routines.  This code is usable across a wide variety of machines; most
 * of the system dependencies have been isolated in a separate file.
 * The major functions provided here are:
 *   * pool-based allocation and freeing of memory;
 *   * policy decisions about how to divide available memory among the
 *     virtual arrays;
 *   * control logic for swapping virtual arrays between main memory and
 *     backing storage.
 * The separate system-dependent file provides the actual backing-storage
 * access code, and it contains the policy decision about how much total
 * main memory to use.
 * This file is system-dependent in the sense that some of its functions
 * are unnecessary in some systems.  For example, if there is enough virtual
 * memory so that backing storage will never be used, much of the virtual
 * array control logic could be removed.  (Of course, if you have that much
 * memory then you shouldn't care about a little bit of unused code...)
 */

#define JPEG_INTERNALS
#define AM_MEMORY_MANAGER	/* we define jvirt_Xarray_control structs */
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jmemsys.h"		/* import the system-dependent declarations */

#ifndef NO_GETENV
#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare getenv() */
extern char * getenv JPP((const char * name));
#endif
#endif


/*
 * Some important notes:
 *   The allocation routines provided here must never return NULL.
 *   They should exit to error_exit if unsuccessful.
 *
 *   It's not a good idea to try to merge the sarray and barray routines,
 *   even though they are textually almost the same, because samples are
 *   usually stored as bytes while coefficients are shorts or ints.  Thus,
 *   in machines where byte pointers have a different representation from
 *   word pointers, the resulting machine code could not be the same.
 */


/*
 * Many machines require storage alignment: longs must start on 4-byte
 * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
 * always returns pointers that are multiples of the worst-case alignment
 * requirement, and we had better do so too.
 * There isn't any really portable way to determine the worst-case alignment
 * requirement.  This module assumes that the alignment requirement is
 * multiples of sizeof(ALIGN_TYPE).
 * By default, we define ALIGN_TYPE as double.  This is necessary on some
 * workstations (where doubles really do need 8-byte alignment) and will work
 * fine on nearly everything.  If your machine has lesser alignment needs,
 * you can save a few bytes by making ALIGN_TYPE smaller.
 * The only place I know of where this will NOT work is certain Macintosh
 * 680x0 compilers that define double as a 10-byte IEEE extended float.
 * Doing 10-byte alignment is counterproductive because longwords won't be
 * aligned well.  Put "#define ALIGN_TYPE long" in jconfig.h if you have
 * such a compiler.
 */

#ifndef ALIGN_TYPE		/* so can override from jconfig.h */
#define ALIGN_TYPE  double
#endif


/*
 * We allocate objects from "pools", where each pool is gotten with a single
 * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
 * overhead within a pool, except for alignment padding.  Each pool has a
 * header with a link to the next pool of the same class.
 * Small and large pool headers are identical except that the latter's
 * link pointer must be FAR on 80x86 machines.
 * Notice that the "real" header fields are union'ed with a dummy ALIGN_TYPE
 * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
 * of the alignment requirement of ALIGN_TYPE.
 */

typedef union small_pool_struct * small_pool_ptr;

typedef union small_pool_struct {
  struct {
    small_pool_ptr next;	/* next in list of pools */
    size_t bytes_used;		/* how many bytes already used within pool */
    size_t bytes_left;		/* bytes still available in this pool */
  } hdr;
  ALIGN_TYPE dummy;		/* included in union to ensure alignment */
} small_pool_hdr;

typedef union large_pool_struct FAR * large_pool_ptr;

typedef union large_pool_struct {
  struct {
    large_pool_ptr next;	/* next in list of pools */
    size_t bytes_used;		/* how many bytes already used within pool */
    size_t bytes_left;		/* bytes still available in this pool */
  } hdr;
  ALIGN_TYPE dummy;		/* included in union to ensure alignment */
} large_pool_hdr;


/*
 * Here is the full definition of a memory manager object.
 */

typedef struct {
  struct jpeg_memory_mgr pub;	/* public fields */

  /* Each pool identifier (lifetime class) names a linked list of pools. */
  small_pool_ptr small_list[JPOOL_NUMPOOLS];
  large_pool_ptr large_list[JPOOL_NUMPOOLS];

  /* Since we only have one lifetime class of virtual arrays, only one
   * linked list is necessary (for each datatype).  Note that the virtual
   * array control blocks being linked together are actually stored somewhere
   * in the small-pool list.
   */
  jvirt_sarray_ptr virt_sarray_list;
  jvirt_barray_ptr virt_barray_list;

  /* This counts total space obtained from jpeg_get_small/large */
  size_t total_space_allocated;

  /* alloc_sarray and alloc_barray set this value for use by virtual
   * array routines.
   */
  JDIMENSION last_rowsperchunk;	/* from most recent alloc_sarray/barray */
} my_memory_mgr;

typedef my_memory_mgr * my_mem_ptr;


/*
 * The control blocks for virtual arrays.
 * Note that these blocks are allocated in the "small" pool area.
 * System-dependent info for the associated backing store (if any) is hidden
 * inside the backing_store_info struct.
 */

struct jvirt_sarray_control {
  JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
  JDIMENSION rows_in_array;	/* total virtual array height */
  JDIMENSION samplesperrow;	/* width of array (and of memory buffer) */
  JDIMENSION maxaccess;		/* max rows accessed by access_virt_sarray */
  JDIMENSION rows_in_mem;	/* height of memory buffer */
  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
  JDIMENSION cur_start_row;	/* first logical row # in the buffer */
  JDIMENSION first_undef_row;	/* row # of first uninitialized row */
  boolean pre_zero;		/* pre-zero mode requested? */
  boolean dirty;		/* do current buffer contents need written? */
  boolean b_s_open;		/* is backing-store data valid? */
  jvirt_sarray_ptr next;	/* link to next virtual sarray control block */
  backing_store_info b_s_info;	/* System-dependent control info */
};

struct jvirt_barray_control {
  JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
  JDIMENSION rows_in_array;	/* total virtual array height */
  JDIMENSION blocksperrow;	/* width of array (and of memory buffer) */
  JDIMENSION maxaccess;		/* max rows accessed by access_virt_barray */
  JDIMENSION rows_in_mem;	/* height of memory buffer */
  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
  JDIMENSION cur_start_row;	/* first logical row # in the buffer */
  JDIMENSION first_undef_row;	/* row # of first uninitialized row */
  boolean pre_zero;		/* pre-zero mode requested? */
  boolean dirty;		/* do current buffer contents need written? */
  boolean b_s_open;		/* is backing-store data valid? */
  jvirt_barray_ptr next;	/* link to next virtual barray control block */
  backing_store_info b_s_info;	/* System-dependent control info */
};


#ifdef MEM_STATS		/* optional extra stuff for statistics */

LOCAL(void)
print_mem_stats (j_common_ptr cinfo, int pool_id)
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;

  /* Since this is only a debugging stub, we can cheat a little by using
   * fprintf directly rather than going through the trace message code.
   * This is helpful because message parm array can't handle longs.
   */
  fprintf(stderr, "Freeing pool %d, total space = %ld\n",
	  pool_id, mem->total_space_allocated);

  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
       lhdr_ptr = lhdr_ptr->hdr.next) {
    fprintf(stderr, "  Large chunk used %ld\n",
	    (long) lhdr_ptr->hdr.bytes_used);
  }

  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
       shdr_ptr = shdr_ptr->hdr.next) {
    fprintf(stderr, "  Small chunk used %ld free %ld\n",
	    (long) shdr_ptr->hdr.bytes_used,
	    (long) shdr_ptr->hdr.bytes_left);
  }
}

#endif /* MEM_STATS */


LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
}


/*
 * Allocation of "small" objects.
 *
 * For these, we use pooled storage.  When a new pool must be created,
 * we try to get enough space for the current request plus a "slop" factor,
 * where the slop will be the amount of leftover space in the new pool.
 * The speed vs. space tradeoff is largely determined by the slop values.
 * A different slop value is provided for each pool class (lifetime),
 * and we also distinguish the first pool of a class from later ones.
 * NOTE: the values given work fairly well on both 16- and 32-bit-int
 * machines, but may be too small if longs are 64 bits or more.
 */

static const size_t first_pool_slop[JPOOL_NUMPOOLS] = 
{
	1600,			/* first PERMANENT pool */
	16000			/* first IMAGE pool */
};

static const size_t extra_pool_slop[JPOOL_NUMPOOLS] = 
{
	0,			/* additional PERMANENT pools */
	5000			/* additional IMAGE pools */
};

#define MIN_SLOP  50		/* greater than 0 to avoid futile looping */


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
  prev_hdr_ptr = NULL;
  hdr_ptr = mem->small_list[pool_id];
  while (hdr_ptr != NULL) {
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
    hdr_ptr = hdr_ptr->hdr.next;
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
      slop = first_pool_slop[pool_id];
    else
      slop = extra_pool_slop[pool_id];
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
      if (hdr_ptr != NULL)
	break;
      slop /= 2;
      if (slop < MIN_SLOP)	/* give up when it gets real small */
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
    }
    mem->total_space_allocated += min_request + slop;
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
    hdr_ptr->hdr.bytes_used = 0;
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
      mem->small_list[pool_id] = hdr_ptr;
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
  hdr_ptr->hdr.bytes_used += sizeofobject;
  hdr_ptr->hdr.bytes_left -= sizeofobject;

  return (void *) data_ptr;
}


/*
 * Allocation of "large" objects.
 *
 * The external semantics of these are the same as "small" objects,
 * except that FAR pointers are used on 80x86.  However the pool
 * management heuristics are quite different.  We assume that each
 * request is large enough that it may as well be passed directly to
 * jpeg_get_large; the pool management just links everything together
 * so that we can free it all on demand.
 * Note: the major use of "large" objects is in JSAMPARRAY and JBLOCKARRAY
 * structures.  The routines that create these structures (see below)
 * deliberately bunch rows together to ensure a large request size.
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
  hdr_ptr->hdr.bytes_left = 0;
  mem->large_list[pool_id] = hdr_ptr;

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
}


/*
 * Creation of 2-D sample arrays.
 * The pointers are in near heap, the samples themselves in FAR heap.
 *
 * To minimize allocation overhead and to allow I/O of large contiguous
 * blocks, we allocate the sample rows in groups of as many rows as possible
 * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
 * NB: the virtual array control routines, later in this file, know about
 * this chunking of rows.  The rowsperchunk value is left in the mem manager
 * object so that it can be saved away if this sarray is the workspace for
 * a virtual array.
 */

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  JSAMPARRAY result;
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
  if (ltemp < (long) numrows)
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
      workspace += samplesperrow;
    }
  }

  return result;
}


/*
 * Creation of 2-D coefficient-block arrays.
 * This is essentially the same as the code for sample arrays, above.
 */

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  JBLOCKARRAY result;
  JBLOCKROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
  if (ltemp <= 0)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
  if (ltemp < (long) numrows)
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
      workspace += blocksperrow;
    }
  }

  return result;
}


/*
 * About virtual array management:
 *
 * The above "normal" array routines are only used to allocate strip buffers
 * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 * are handled as "virtual" arrays.  The array is still accessed a strip at a
 * time, but the memory manager must save the whole array for repeated
 * accesses.  The intended implementation is that there is a strip buffer in
 * memory (as high as is possible given the desired memory limit), plus a
 * backing file that holds the rest of the array.
 *
 * The request_virt_array routines are told the total size of the image and
 * the maximum number of rows that will be accessed at once.  The in-memory
 * buffer must be at least as large as the maxaccess value.
 *
 * The request routines create control blocks but not the in-memory buffers.
 * That is postponed until realize_virt_arrays is called.  At that time the
 * total amount of space needed is known (approximately, anyway), so free
 * memory can be divided up fairly.
 *
 * The access_virt_array routines are responsible for making a specific strip
 * area accessible (after reading or writing the backing file, if necessary).
 * Note that the access routines are told whether the caller intends to modify
 * the accessed strip; during a read-only pass this saves having to rewrite
 * data to disk.  The access routines are also responsible for pre-zeroing
 * any newly accessed rows, if pre-zeroing was requested.
 *
 * In current usage, the access requests are usually for nonoverlapping
 * strips; that is, successive access start_row numbers differ by exactly
 * num_rows = maxaccess.  This means we can get good performance with simple
 * buffer dump/reload logic, by making the in-memory buffer be a multiple
 * of the access height; then there will never be accesses across bufferload
 * boundaries.  The code will still work with overlapping access requests,
 * but it doesn't handle bufferload overlaps very efficiently.
 */


METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
  result->rows_in_array = numrows;
  result->samplesperrow = samplesperrow;
  result->maxaccess = maxaccess;
  result->pre_zero = pre_zero;
  result->b_s_open = FALSE;	/* no associated backing-store object */
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
  mem->virt_sarray_list = result;

  return result;
}


METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
  result->rows_in_array = numrows;
  result->blocksperrow = blocksperrow;
  result->maxaccess = maxaccess;
  result->pre_zero = pre_zero;
  result->b_s_open = FALSE;	/* no associated backing-store object */
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
  mem->virt_barray_list = result;

  return result;
}


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  long space_per_minheight, maximum_space, avail_mem;
  long minheights, max_minheights;
  jvirt_sarray_ptr sptr;
  jvirt_barray_ptr bptr;

  /* Compute the minimum space needed (maxaccess rows in each buffer)
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
  maximum_space = 0;
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) sptr->maxaccess *
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
      maximum_space += (long) sptr->rows_in_array *
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) bptr->maxaccess *
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
      maximum_space += (long) bptr->rows_in_array *
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
    }
  }

  if (space_per_minheight <= 0)
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
				 mem->total_space_allocated);

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
    max_minheights = 1000000000L;
  else {
    max_minheights = avail_mem / space_per_minheight;
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
      max_minheights = 1;
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
      if (minheights <= max_minheights) {
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
      } else {
	/* It doesn't fit in memory, create backing store. */
	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
				(long) sptr->rows_in_array *
				(long) sptr->samplesperrow *
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
      sptr->cur_start_row = 0;
      sptr->first_undef_row = 0;
      sptr->dirty = FALSE;
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
      if (minheights <= max_minheights) {
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
      } else {
	/* It doesn't fit in memory, create backing store. */
	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
				(long) bptr->rows_in_array *
				(long) bptr->blocksperrow *
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
      bptr->cur_start_row = 0;
      bptr->first_undef_row = 0;
      bptr->dirty = FALSE;
    }
  }
}


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}


METHODDEF(JSAMPARRAY)
access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
  JDIMENSION end_row = start_row + num_rows;
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
      ptr->mem_buffer == NULL)
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
    if (! ptr->b_s_open)
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
      do_sarray_io(cinfo, ptr, TRUE);
      ptr->dirty = FALSE;
    }
    /* Decide what part of virtual array to access.
     * Algorithm: if target address > current window, assume forward scan,
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
      ptr->cur_start_row = start_row;
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
      if (ltemp < 0)
	ltemp = 0;		/* don't fall off front end of file */
      ptr->cur_start_row = (JDIMENSION) ltemp;
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_sarray_io(cinfo, ptr, FALSE);
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
    if (ptr->first_undef_row < start_row) {
      if (writable)		/* writer skipped over a section of array */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
    ptr->dirty = TRUE;
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}


METHODDEF(JBLOCKARRAY)
access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
  JDIMENSION end_row = start_row + num_rows;
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
      ptr->mem_buffer == NULL)
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
    if (! ptr->b_s_open)
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
      do_barray_io(cinfo, ptr, TRUE);
      ptr->dirty = FALSE;
    }
    /* Decide what part of virtual array to access.
     * Algorithm: if target address > current window, assume forward scan,
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
      ptr->cur_start_row = start_row;
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
      if (ltemp < 0)
	ltemp = 0;		/* don't fall off front end of file */
      ptr->cur_start_row = (JDIMENSION) ltemp;
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_barray_io(cinfo, ptr, FALSE);
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
    if (ptr->first_undef_row < start_row) {
      if (writable)		/* writer skipped over a section of array */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
    ptr->dirty = TRUE;
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}


/*
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */

#ifdef MEM_STATS
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
      if (sptr->b_s_open) {	/* there may be no backing store */
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
      }
    }
    mem->virt_sarray_list = NULL;
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
      if (bptr->b_s_open) {	/* there may be no backing store */
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
      }
    }
    mem->virt_barray_list = NULL;
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
  mem->large_list[pool_id] = NULL;

  while (lhdr_ptr != NULL) {
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
    space_freed = lhdr_ptr->hdr.bytes_used +
		  lhdr_ptr->hdr.bytes_left +
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
    mem->total_space_allocated -= space_freed;
    lhdr_ptr = next_lhdr_ptr;
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
  mem->small_list[pool_id] = NULL;

  while (shdr_ptr != NULL) {
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
    space_freed = shdr_ptr->hdr.bytes_used +
		  shdr_ptr->hdr.bytes_left +
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
    mem->total_space_allocated -= space_freed;
    shdr_ptr = next_shdr_ptr;
  }
}


/*
 * Close up shop entirely.
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
  int pool;

  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    free_pool(cinfo, pool);
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
  cinfo->mem = NULL;		/* ensures I will be called only once */

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
}


/*
 * Memory manager initialization.
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */

  /* Check for configuration errors.
   * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
   * doesn't reflect any real hardware alignment requirement.
   * The test is a little tricky: for X>0, X and X-1 have no one-bits
   * in common if and only if X is a power of 2, ie has only one one-bit.
   * Some compilers may give an "unreachable code" warning here; ignore it.
   */
  if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   * a multiple of SIZEOF(ALIGN_TYPE).
   * Again, an "unreachable code" warning may be ignored here.
   * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   */
  test_mac = (size_t) MAX_ALLOC_CHUNK;
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));

  if (mem == NULL) {
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
  mem->pub.alloc_large = alloc_large;
  mem->pub.alloc_sarray = alloc_sarray;
  mem->pub.alloc_barray = alloc_barray;
  mem->pub.request_virt_sarray = request_virt_sarray;
  mem->pub.request_virt_barray = request_virt_barray;
  mem->pub.realize_virt_arrays = realize_virt_arrays;
  mem->pub.access_virt_sarray = access_virt_sarray;
  mem->pub.access_virt_barray = access_virt_barray;
  mem->pub.free_pool = free_pool;
  mem->pub.self_destruct = self_destruct;

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    mem->small_list[pool] = NULL;
    mem->large_list[pool] = NULL;
  }
  mem->virt_sarray_list = NULL;
  mem->virt_barray_list = NULL;

  mem->total_space_allocated = SIZEOF(my_memory_mgr);

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;

  /* Check for an environment variable JPEGMEM; if found, override the
   * default max_memory setting from jpeg_mem_init.  Note that the
   * surrounding application may again override this value.
   * If your system doesn't support getenv(), define NO_GETENV to disable
   * this feature.
   */
#ifndef NO_GETENV
  { char * memenv;

    if ((memenv = getenv("JPEGMEM")) != NULL) {
      char ch = 'x';

      if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
	if (ch == 'm' || ch == 'M')
	  max_to_use *= 1000L;
	mem->pub.max_memory_to_use = max_to_use * 1000L;
      }
    }
  }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jmemsys.h ===
/*
 * jmemsys.h
 *
 * Copyright (C) 1992-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This include file defines the interface between the system-independent
 * and system-dependent portions of the JPEG memory manager.  No other
 * modules need include it.  (The system-independent portion is jmemmgr.c;
 * there are several different versions of the system-dependent portion.)
 *
 * This file works as-is for the system-dependent memory managers supplied
 * in the IJG distribution.  You may need to modify it if you write a
 * custom memory manager.  If system-dependent changes are needed in
 * this file, the best method is to #ifdef them based on a configuration
 * symbol supplied in jconfig.h, as we have done with USE_MSDOS_MEMMGR.
 */


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_get_small		jGetSmall
#define jpeg_free_small		jFreeSmall
#define jpeg_get_large		jGetLarge
#define jpeg_free_large		jFreeLarge
#define jpeg_mem_available	jMemAvail
#define jpeg_open_backing_store	jOpenBackStore
#define jpeg_mem_init		jMemInit
#define jpeg_mem_term		jMemTerm
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/*
 * These two functions are used to allocate and release small chunks of
 * memory.  (Typically the total amount requested through jpeg_get_small is
 * no more than 20K or so; this will be requested in chunks of a few K each.)
 * Behavior should be the same as for the standard library functions malloc
 * and free; in particular, jpeg_get_small must return NULL on failure.
 * On most systems, these ARE malloc and free.  jpeg_free_small is passed the
 * size of the object being freed, just in case it's needed.
 * On an 80x86 machine using small-data memory model, these manage near heap.
 */

EXTERN(void *) jpeg_get_small JPP((j_common_ptr cinfo, size_t sizeofobject));
EXTERN(void) jpeg_free_small JPP((j_common_ptr cinfo, void * object,
				  size_t sizeofobject));

/*
 * These two functions are used to allocate and release large chunks of
 * memory (up to the total free space designated by jpeg_mem_available).
 * The interface is the same as above, except that on an 80x86 machine,
 * far pointers are used.  On most other machines these are identical to
 * the jpeg_get/free_small routines; but we keep them separate anyway,
 * in case a different allocation strategy is desirable for large chunks.
 */

EXTERN(void FAR *) jpeg_get_large JPP((j_common_ptr cinfo,
				       size_t sizeofobject));
EXTERN(void) jpeg_free_large JPP((j_common_ptr cinfo, void FAR * object,
				  size_t sizeofobject));

/*
 * The macro MAX_ALLOC_CHUNK designates the maximum number of bytes that may
 * be requested in a single call to jpeg_get_large (and jpeg_get_small for that
 * matter, but that case should never come into play).  This macro is needed
 * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
 * On those machines, we expect that jconfig.h will provide a proper value.
 * On machines with 32-bit flat address spaces, any large constant may be used.
 *
 * NB: jmemmgr.c expects that MAX_ALLOC_CHUNK will be representable as type
 * size_t and will be a multiple of sizeof(align_type).
 */

#ifndef MAX_ALLOC_CHUNK		/* may be overridden in jconfig.h */
#define MAX_ALLOC_CHUNK  1000000000L
#endif

/*
 * This routine computes the total space still available for allocation by
 * jpeg_get_large.  If more space than this is needed, backing store will be
 * used.  NOTE: any memory already allocated must not be counted.
 *
 * There is a minimum space requirement, corresponding to the minimum
 * feasible buffer sizes; jmemmgr.c will request that much space even if
 * jpeg_mem_available returns zero.  The maximum space needed, enough to hold
 * all working storage in memory, is also passed in case it is useful.
 * Finally, the total space already allocated is passed.  If no better
 * method is available, cinfo->mem->max_memory_to_use - already_allocated
 * is often a suitable calculation.
 *
 * It is OK for jpeg_mem_available to underestimate the space available
 * (that'll just lead to more backing-store access than is really necessary).
 * However, an overestimate will lead to failure.  Hence it's wise to subtract
 * a slop factor from the true available space.  5% should be enough.
 *
 * On machines with lots of virtual memory, any large constant may be returned.
 * Conversely, zero may be returned to always use the minimum amount of memory.
 */

EXTERN(long) jpeg_mem_available JPP((j_common_ptr cinfo,
				     long min_bytes_needed,
				     long max_bytes_needed,
				     long already_allocated));


/*
 * This structure holds whatever state is needed to access a single
 * backing-store object.  The read/write/close method pointers are called
 * by jmemmgr.c to manipulate the backing-store object; all other fields
 * are private to the system-dependent backing store routines.
 */

#define TEMP_NAME_LENGTH   64	/* max length of a temporary file's name */

#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */

typedef unsigned short XMSH;	/* type of extended-memory handles */
typedef unsigned short EMSH;	/* type of expanded-memory handles */

typedef union {
  short file_handle;		/* DOS file handle if it's a temp file */
  XMSH xms_handle;		/* handle if it's a chunk of XMS */
  EMSH ems_handle;		/* handle if it's a chunk of EMS */
} handle_union;

#endif /* USE_MSDOS_MEMMGR */

typedef struct backing_store_struct * backing_store_ptr;

typedef struct backing_store_struct {
  /* Methods for reading/writing/closing this backing-store object */
  JMETHOD(void, read_backing_store, (j_common_ptr cinfo,
				     backing_store_ptr info,
				     void FAR * buffer_address,
				     long file_offset, long byte_count));
  JMETHOD(void, write_backing_store, (j_common_ptr cinfo,
				      backing_store_ptr info,
				      void FAR * buffer_address,
				      long file_offset, long byte_count));
  JMETHOD(void, close_backing_store, (j_common_ptr cinfo,
				      backing_store_ptr info));

  /* Private fields for system-dependent backing-store management */
#ifdef USE_MSDOS_MEMMGR
  /* For the MS-DOS manager (jmemdos.c), we need: */
  handle_union handle;		/* reference to backing-store storage object */
  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
#else
  /* For a typical implementation with temp files, we need: */
  FILE * temp_file;		/* stdio reference to temp file */
  char temp_name[TEMP_NAME_LENGTH]; /* name of temp file */
#endif
} backing_store_info;

/*
 * Initial opening of a backing-store object.  This must fill in the
 * read/write/close pointers in the object.  The read/write routines
 * may take an error exit if the specified maximum file size is exceeded.
 * (If jpeg_mem_available always returns a large value, this routine can
 * just take an error exit.)
 */

EXTERN(void) jpeg_open_backing_store JPP((j_common_ptr cinfo,
					  backing_store_ptr info,
					  long total_bytes_needed));


/*
 * These routines take care of any system-dependent initialization and
 * cleanup required.  jpeg_mem_init will be called before anything is
 * allocated (and, therefore, nothing in cinfo is of use except the error
 * manager pointer).  It should return a suitable default value for
 * max_memory_to_use; this may subsequently be overridden by the surrounding
 * application.  (Note that max_memory_to_use is only important if
 * jpeg_mem_available chooses to consult it ... no one else will.)
 * jpeg_mem_term may assume that all requested memory has been freed and that
 * all opened backing-store objects have been closed.
 */

EXTERN(long) jpeg_mem_init JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_mem_term JPP((j_common_ptr cinfo));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jversion.h ===
/*
 * jversion.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains software version identification.
 */


#define JVERSION	"6a  7-Feb-96"

#define JCOPYRIGHT	"Copyright (C) 1996, Thomas G. Lane"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jquant1.c ===
/*
 * jquant1.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 1-pass color quantization (color mapping) routines.
 * These routines provide mapping to a fixed color map using equally spaced
 * color values.  Optional Floyd-Steinberg or ordered dithering is available.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"

#ifdef QUANT_1PASS_SUPPORTED


/*
 * The main purpose of 1-pass quantization is to provide a fast, if not very
 * high quality, colormapped output capability.  A 2-pass quantizer usually
 * gives better visual quality; however, for quantized grayscale output this
 * quantizer is perfectly adequate.  Dithering is highly recommended with this
 * quantizer, though you can turn it off if you really want to.
 *
 * In 1-pass quantization the colormap must be chosen in advance of seeing the
 * image.  We use a map consisting of all combinations of Ncolors[i] color
 * values for the i'th component.  The Ncolors[] values are chosen so that
 * their product, the total number of colors, is no more than that requested.
 * (In most cases, the product will be somewhat less.)
 *
 * Since the colormap is orthogonal, the representative value for each color
 * component can be determined without considering the other components;
 * then these indexes can be combined into a colormap index by a standard
 * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
 * can be precalculated and stored in the lookup table colorindex[].
 * colorindex[i][j] maps pixel value j in component i to the nearest
 * representative value (grid plane) for that component; this index is
 * multiplied by the array stride for component i, so that the
 * index of the colormap entry closest to a given pixel value is just
 *    sum( colorindex[component-number][pixel-component-value] )
 * Aside from being fast, this scheme allows for variable spacing between
 * representative values with no additional lookup cost.
 *
 * If gamma correction has been applied in color conversion, it might be wise
 * to adjust the color grid spacing so that the representative colors are
 * equidistant in linear space.  At this writing, gamma correction is not
 * implemented by jdcolor, so nothing is done here.
 */


/* Declarations for ordered dithering.
 *
 * We use a standard 16x16 ordered dither array.  The basic concept of ordered
 * dithering is described in many references, for instance Dale Schumacher's
 * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
 * In place of Schumacher's comparisons against a "threshold" value, we add a
 * "dither" value to the input pixel and then round the result to the nearest
 * output value.  The dither value is equivalent to (0.5 - threshold) times
 * the distance between output values.  For ordered dithering, we assume that
 * the output colors are equally spaced; if not, results will probably be
 * worse, since the dither may be too much or too little at a given point.
 *
 * The normal calculation would be to form pixel value + dither, range-limit
 * this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
 * We can skip the separate range-limiting step by extending the colorindex
 * table in both directions.
 */

#define ODITHER_SIZE  16	/* dimension of dither matrix */
/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */
#define ODITHER_CELLS (ODITHER_SIZE*ODITHER_SIZE)	/* # cells in matrix */
#define ODITHER_MASK  (ODITHER_SIZE-1) /* mask for wrapping around counters */

typedef int ODITHER_MATRIX[ODITHER_SIZE][ODITHER_SIZE];
typedef int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];

static const UINT8 base_dither_matrix[ODITHER_SIZE][ODITHER_SIZE] = {
  /* Bayer's order-4 dither array.  Generated by the code given in
   * Stephen Hawley's article "Ordered Dithering" in Graphics Gems I.
   * The values in this array must range from 0 to ODITHER_CELLS-1.
   */
  {   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },
  { 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },
  {  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },
  { 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },
  {   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },
  { 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },
  {  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },
  { 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },
  {   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },
  { 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },
  {  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },
  { 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },
  {  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },
  { 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },
  {  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },
  { 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }
};


/* Declarations for Floyd-Steinberg dithering.
 *
 * Errors are accumulated into the array fserrors[], at a resolution of
 * 1/16th of a pixel count.  The error at a given pixel is propagated
 * to its not-yet-processed neighbors using the standard F-S fractions,
 *		...	(here)	7/16
 *		3/16	5/16	1/16
 * We work left-to-right on even rows, right-to-left on odd rows.
 *
 * We can get away with a single array (holding one row's worth of errors)
 * by using it to store the current row's errors at pixel columns not yet
 * processed, but the next row's errors at columns already processed.  We
 * need only a few extra variables to hold the errors immediately around the
 * current column.  (If we are lucky, those variables are in registers, but
 * even if not, they're probably cheaper to access than array elements are.)
 *
 * The fserrors[] array is indexed [component#][position].
 * We provide (#columns + 2) entries per component; the extra entry at each
 * end saves us from special-casing the first and last pixels.
 *
 * Note: on a wide image, we might not have enough room in a PC's near data
 * segment to hold the error array; so it is allocated with alloc_large.
 */

#if BITS_IN_JSAMPLE == 8
typedef INT16 FSERROR;		/* 16 bits should be enough */
typedef int LOCFSERROR;		/* use 'int' for calculation temps */
#else
typedef INT32 FSERROR;		/* may need more than 16 bits */
typedef INT32 LOCFSERROR;	/* be sure calculation temps are big enough */
#endif

typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */


/* Private subobject */

#define MAX_Q_COMPS 4		/* max components I can handle */

typedef struct {
  struct jpeg_color_quantizer pub; /* public fields */

  /* Initially allocated colormap is saved here */
  JSAMPARRAY sv_colormap;	/* The color map as a 2-D pixel array */
  int sv_actual;		/* number of entries in use */

  JSAMPARRAY colorindex;	/* Precomputed mapping for speed */
  /* colorindex[i][j] = index of color closest to pixel value j in component i,
   * premultiplied as described above.  Since colormap indexes must fit into
   * JSAMPLEs, the entries of this array will too.
   */
  boolean is_padded;		/* is the colorindex padded for odither? */

  int Ncolors[MAX_Q_COMPS];	/* # of values alloced to each component */

  /* Variables for ordered dithering */
  int row_index;		/* cur row's vertical index in dither matrix */
  ODITHER_MATRIX_PTR odither[MAX_Q_COMPS]; /* one dither array per component */

  /* Variables for Floyd-Steinberg dithering */
  FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */
  boolean on_odd_row;		/* flag to remember which row we are on */
} my_cquantizer;

typedef my_cquantizer * my_cquantize_ptr;


/*
 * Policy-making subroutines for create_colormap and create_colorindex.
 * These routines determine the colormap to be used.  The rest of the module
 * only assumes that the colormap is orthogonal.
 *
 *  * select_ncolors decides how to divvy up the available colors
 *    among the components.
 *  * output_value defines the set of representative values for a component.
 *  * largest_input_value defines the mapping from input values to
 *    representative values for a component.
 * Note that the latter two routines may impose different policies for
 * different components, though this is not currently done.
 */


LOCAL(int)
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
  int nc = cinfo->out_color_components; /* number of color components */
  int max_colors = cinfo->desired_number_of_colors;
  int total_colors, iroot, i, j;
  boolean changed;
  long temp;
  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
  do {
    iroot++;
    temp = iroot;		/* set temp = iroot ** nc */
    for (i = 1; i < nc; i++)
      temp *= iroot;
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
  iroot--;			/* now iroot = floor(root) */

  /* Must have at least 2 color values per component */
  if (iroot < 2)
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);

  /* Initialize to iroot color values for each component */
  total_colors = 1;
  for (i = 0; i < nc; i++) {
    Ncolors[i] = iroot;
    total_colors *= iroot;
  }
  /* We may be able to increment the count for one or more components without
   * exceeding max_colors, though we know not all can be incremented.
   * Sometimes, the first component can be incremented more than once!
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
    for (i = 0; i < nc; i++) {
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
      if (temp > (long) max_colors)
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
      total_colors = (int) temp;
      changed = TRUE;
    }
  } while (changed);

  return total_colors;
}


LOCAL(int)
output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
{
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
}


LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
}


/*
 * Create the colormap.
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    blksize = blkdist / nci;
    for (j = 0; j < nci; j++) {
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
	  colormap[i][ptr+k] = (JSAMPLE) val;
      }
    }
    blkdist = blksize;		/* blksize of this color is blkdist of next */
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
  cquantize->sv_actual = total_colors;
}


/*
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPROW indexptr;
  int i,j,k, nci, blksize, val, pad;

  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
    pad = MAXJSAMPLE*2;
    cquantize->is_padded = TRUE;
  } else {
    pad = 0;
    cquantize->is_padded = FALSE;
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
     (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    blksize = blksize / nci;

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
      cquantize->colorindex[i] += MAXJSAMPLE;

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci-1);
    for (j = 0; j <= MAXJSAMPLE; j++) {
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
    }
    /* Pad at both ends if necessary */
    if (pad)
      for (j = 1; j <= MAXJSAMPLE; j++) {
	indexptr[-j] = indexptr[0];
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
      }
  }
}


/*
 * Create an ordered-dither array for a component having ncolors
 * distinct output values.
 */

LOCAL(ODITHER_MATRIX_PTR)
make_odither_array (j_decompress_ptr cinfo, int ncolors)
{
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(ODITHER_MATRIX));
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
    }
  }
  return odither;
}


/*
 * Create the ordered-dither tables.
 * Components having the same number of representative colors may 
 * share a dither table.
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    odither = NULL;		/* search for matching prior component */
    for (j = 0; j < i; j++) {
      if (nci == cquantize->Ncolors[j]) {
	odither = cquantize->odither[j];
	break;
      }
    }
    if (odither == NULL)	/* need a new table? */
      odither = make_odither_array(cinfo, nci);
    cquantize->odither[i] = odither;
  }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPARRAY colorindex = cquantize->colorindex;
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  register int nc = cinfo->out_color_components;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
      }
      *ptrout++ = (JSAMPLE) pixcode;
    }
  }
}


METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
  JSAMPROW colorindex1 = cquantize->colorindex[1];
  JSAMPROW colorindex2 = cquantize->colorindex[2];
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
      *ptrout++ = (JSAMPLE) pixcode;
    }
  }
}


METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      colorindex_ci = cquantize->colorindex[ci];
      dither = cquantize->odither[ci][row_index];
      col_index = 0;

      for (col = width; col > 0; col--) {
	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
	 * select output value, accumulate into output code for this pixel.
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
	input_ptr += nc;
	output_ptr++;
	col_index = (col_index + 1) & ODITHER_MASK;
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}


METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
  JSAMPROW colorindex1 = cquantize->colorindex[1];
  JSAMPROW colorindex2 = cquantize->colorindex[2];
  int * dither0;		/* points to active row of dither matrix */
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    row_index = cquantize->row_index;
    input_ptr = input_buf[row];
    output_ptr = output_buf[row];
    dither0 = cquantize->odither[0][row_index];
    dither1 = cquantize->odither[1][row_index];
    dither2 = cquantize->odither[2][row_index];
    col_index = 0;

    for (col = width; col > 0; col--) {
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
      col_index = (col_index + 1) & ODITHER_MASK;
    }
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}


METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register LOCFSERROR cur;	/* current error or pixel value */
  LOCFSERROR belowerr;		/* error for pixel below cur */
  LOCFSERROR bpreverr;		/* error for below/prev col */
  LOCFSERROR bnexterr;		/* error for below/next col */
  LOCFSERROR delta;
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      if (cquantize->on_odd_row) {
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
	output_ptr += width-1;
	dir = -1;
	dirnc = -nc;
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
      } else {
	/* work left to right in this row */
	dir = 1;
	dirnc = nc;
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
      }
      colorindex_ci = cquantize->colorindex[ci];
      colormap_ci = cquantize->sv_colormap[ci];
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;

      for (col = width; col > 0; col--) {
	/* cur holds the error propagated from the previous pixel on the
	 * current line.  Add the error propagated from the previous line
	 * to form the complete error correction term for this pixel, and
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
	cur = GETJSAMPLE(range_limit[cur]);
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
	*output_ptr += (JSAMPLE) pixcode;
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
	delta = cur * 2;
	cur += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr + cur);
	cur += delta;		/* form error * 5 */
	bpreverr = belowerr + cur;
	belowerr = bnexterr;
	cur += delta;		/* form error * 7 */
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
	output_ptr += dir;	/* advance output ptr to next column */
	errorptr += dir;	/* advance errorptr to current column */
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
  }
}


/*
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
  for (i = 0; i < cinfo->out_color_components; i++) {
    cquantize->fserrors[i] = (FSERRPTR)
      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
  }
}


/*
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
  cinfo->actual_number_of_colors = cquantize->sv_actual;

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
      cquantize->pub.color_quantize = color_quantize3;
    else
      cquantize->pub.color_quantize = color_quantize;
    break;
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
      cquantize->pub.color_quantize = quantize3_ord_dither;
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
    cquantize->row_index = 0;	/* initialize state for ordered dither */
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
      create_colorindex(cinfo);
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
      create_odither_tables(cinfo);
    break;
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
      alloc_fs_workspace(cinfo);
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
    for (i = 0; i < cinfo->out_color_components; i++)
      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
    break;
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
    break;
  }
}


/*
 * Finish up at the end of the pass.
 */

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
  /* no work in 1-pass case */
}


/*
 * Switch to a new external colormap between output passes.
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
  ERREXIT(cinfo, JERR_MODE_CHANGE);
}


/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_1_quant;
  cquantize->pub.finish_pass = finish_pass_1_quant;
  cquantize->pub.new_color_map = new_color_map_1_quant;
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
  create_colorindex(cinfo);

  /* Allocate Floyd-Steinberg workspace now if requested.
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
    alloc_fs_workspace(cinfo);
}

#endif /* QUANT_1PASS_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jutils.c ===
/*
 * jutils.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains tables and miscellaneous utility routines needed
 * for both compression and decompression.
 * Note we prefix all global names with "j" to minimize conflicts with
 * a surrounding application.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef UNIX
#include "jpeglib.h"
// INT32 is defined by JPEG library in same way; turn off warning of benign
// type definition
#pragma warning(disable: 4142)
#include <windows.h>
#pragma warning(default: 4142)
#else 
// When the reason that windows.h must be after jpeglib.h in Windows platform is resolved. We can take out this #ifdef. 
#include <windows.h>
#include "jpeglib.h"
#endif
boolean vfMMXMachine = 2;

/*
 * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
 * of a DCT block read in natural order (left to right, top to bottom).
 */

const int jpeg_zigzag_order[DCTSIZE2] = {
   0,  1,  5,  6, 14, 15, 27, 28,
   2,  4,  7, 13, 16, 26, 29, 42,
   3,  8, 12, 17, 25, 30, 41, 43,
   9, 11, 18, 24, 31, 40, 44, 53,
  10, 19, 23, 32, 39, 45, 52, 54,
  20, 22, 33, 38, 46, 51, 55, 60,
  21, 34, 37, 47, 50, 56, 59, 61,
  35, 36, 48, 49, 57, 58, 62, 63
};

/*
 * jpeg_natural_order[i] is the natural-order position of the i'th element
 * of zigzag order.
 *
 * When reading corrupted data, the Huffman decoders could attempt
 * to reference an entry beyond the end of this array (if the decoded
 * zero run length reaches past the end of the block).  To prevent
 * wild stores without adding an inner-loop test, we put some extra
 * "63"s after the real entries.  This will cause the extra coefficient
 * to be stored in location 63 of the block, not somewhere random.
 * The worst case would be a run-length of 15, which means we need 16
 * fake entries.
 */

const int jpeg_natural_order[DCTSIZE2+16] = {
  0,  1,  8, 16,  9,  2,  3, 10,
 17, 24, 32, 25, 18, 11,  4,  5,
 12, 19, 26, 33, 40, 48, 41, 34,
 27, 20, 13,  6,  7, 14, 21, 28,
 35, 42, 49, 56, 57, 50, 43, 36,
 29, 22, 15, 23, 30, 37, 44, 51,
 58, 59, 52, 45, 38, 31, 39, 46,
 53, 60, 61, 54, 47, 55, 62, 63,
 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
 63, 63, 63, 63, 63, 63, 63, 63
};


/*
 * Arithmetic utilities
 */

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
  return (a + b - 1L) / b;
}


GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
  a += b - 1L;
  return a - (a % b);
}


/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
 * and coefficient-block arrays.  This won't work on 80x86 because the arrays
 * are FAR and we're assuming a small-pointer memory model.  However, some
 * DOS compilers provide far-pointer versions of memcpy() and memset() even
 * in the small-model libraries.  These will be used if USE_FMEM is defined.
 * Otherwise, the routines below do it the hard way.  (The performance cost
 * is not all that great, because these routines aren't very heavily used.)
 */

#ifndef NEED_FAR_POINTERS	/* normal case, same as regular macros */
#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
#define FMEMZERO(target,size)	MEMZERO(target,size)
#else				/* 80x86 case, define if we can */
#ifdef USE_FMEM
#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
#endif
#endif


GLOBAL(void)
jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
		   JSAMPARRAY output_array, int dest_row,
		   int num_rows, JDIMENSION num_cols)
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
  output_array += dest_row;

  for (row = num_rows; row > 0; row--) {
    inptr = *input_array++;
    outptr = *output_array++;
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
#endif
  }
}


GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
#else
  register JCOEFPTR inptr, outptr;
  register long count;

  inptr = (JCOEFPTR) input_row;
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}


GLOBAL(void)
jzero_far (void FAR * target, size_t bytestozero)
/* Zero out a chunk of FAR memory. */
/* This might be sample-array data, block-array data, or alloc_large data. */
{
#ifdef FMEMZERO
  FMEMZERO(target, bytestozero);
#else
  register char FAR * ptr = (char FAR *) target;
  register size_t count;

  for (count = bytestozero; count > 0; count--) {
    *ptr++ = 0;
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jmorecfg.h ===
/*
 * jmorecfg.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains additional configuration options that customize the
 * JPEG software for special applications or support machine-dependent
 * optimizations.  Most users will not need to touch this file.
 */


/*
 * Define BITS_IN_JSAMPLE as either
 *   8   for 8-bit sample values (the usual setting)
 *   12  for 12-bit sample values
 * Only 8 and 12 are legal data precisions for lossy JPEG according to the
 * JPEG standard, and the IJG code does not support anything else!
 * We do not support run-time selection of data precision, sorry.
 */

#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */


/*
 * Maximum number of components (color channels) allowed in JPEG image.
 * To meet the letter of the JPEG spec, set this to 255.  However, darn
 * few applications need more than 4 channels (maybe 5 for CMYK + alpha
 * mask).  We recommend 10 as a reasonable compromise; use 4 if you are
 * really short on memory.  (Each allowed component costs a hundred or so
 * bytes of storage, whether actually used in an image or not.)
 */

#define MAX_COMPONENTS  10	/* maximum number of image components */


/*
 * Basic data types.
 * You may need to change these if you have a machine with unusual data
 * type sizes; for example, "char" not 8 bits, "short" not 16 bits,
 * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,
 * but it had better be at least 16.
 */

/* Representation of a single sample (pixel element value).
 * We frequently allocate large arrays of these, so it's important to keep
 * them small.  But if you have memory to burn and access to char or short
 * arrays is very slow on your hardware, you might want to change these.
 */

#if BITS_IN_JSAMPLE == 8
/* JSAMPLE should be the smallest type that will hold the values 0..255.
 * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JSAMPLE;
#ifdef CHAR_IS_UNSIGNED
#define GETJSAMPLE(value)  ((int) (value))
#else
#define GETJSAMPLE(value)  ((int) (value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */

#define MAXJSAMPLE	255
#define CENTERJSAMPLE	128

#endif /* BITS_IN_JSAMPLE == 8 */


#if BITS_IN_JSAMPLE == 12
/* JSAMPLE should be the smallest type that will hold the values 0..4095.
 * On nearly all machines "short" will do nicely.
 */

typedef short JSAMPLE;
#define GETJSAMPLE(value)  ((int) (value))

#define MAXJSAMPLE	4095
#define CENTERJSAMPLE	2048

#endif /* BITS_IN_JSAMPLE == 12 */


/* Representation of a DCT frequency coefficient.
 * This should be a signed value of at least 16 bits; "short" is usually OK.
 * Again, we allocate large arrays of these, but you can change to int
 * if you have memory to burn and "short" is really slow.
 */

typedef short JCOEF;


/* Compressed datastreams are represented as arrays of JOCTET.
 * These must be EXACTLY 8 bits wide, at least once they are written to
 * external storage.  Note that when using the stdio data source/destination
 * managers, this is also the data type passed to fread/fwrite.
 */

#ifdef HAVE_UNSIGNED_CHAR

typedef unsigned char JOCTET;
#define GETJOCTET(value)  (value)

#else /* not HAVE_UNSIGNED_CHAR */

typedef char JOCTET;
#ifdef CHAR_IS_UNSIGNED
#define GETJOCTET(value)  (value)
#else
#define GETJOCTET(value)  ((value) & 0xFF)
#endif /* CHAR_IS_UNSIGNED */

#endif /* HAVE_UNSIGNED_CHAR */


/* These typedefs are used for various table entries and so forth.
 * They must be at least as wide as specified; but making them too big
 * won't cost a huge amount of memory, so we don't provide special
 * extraction code like we did for JSAMPLE.  (In other words, these
 * typedefs live at a different point on the speed/space tradeoff curve.)
 */
#ifndef _BASETSD_H_		/* basetsd.h correctly defines [U]INT[8|16|32] */

/* UINT8 must hold at least the values 0..255. */

#ifdef HAVE_UNSIGNED_CHAR
typedef unsigned char UINT8;
#else /* not HAVE_UNSIGNED_CHAR */
#ifdef CHAR_IS_UNSIGNED
typedef char UINT8;
#else /* not CHAR_IS_UNSIGNED */
typedef short UINT8;
#endif /* CHAR_IS_UNSIGNED */
#endif /* HAVE_UNSIGNED_CHAR */

/* UINT16 must hold at least the values 0..65535. */

#ifdef HAVE_UNSIGNED_SHORT
typedef unsigned short UINT16;
#else /* not HAVE_UNSIGNED_SHORT */
typedef unsigned int UINT16;
#endif /* HAVE_UNSIGNED_SHORT */

/* INT16 must hold at least the values -32768..32767. */

#ifndef XMD_H			/* X11/xmd.h correctly defines INT16 */
typedef short INT16;
#endif

/* INT32 must hold at least signed 32-bit values. */

#if !defined(XMD_H)     /* X11/xmd.h correctly defines INT32 */
typedef long INT32;
#endif
#endif

/* Datatype used for image dimensions.  The JPEG standard only supports
 * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
 * "unsigned int" is sufficient on all machines.  However, if you need to
 * handle larger images and you don't mind deviating from the spec, you
 * can change this datatype.
 */

typedef unsigned int JDIMENSION;

#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */


/* These macros are used in all function definitions and extern declarations.
 * You could modify them if you need to change function linkage conventions;
 * in particular, you'll need to do that to make the library a Windows DLL.
 * Another application is to make all functions global for use with debuggers
 * or code profilers that require it.
 */

/* a function called through method pointers: */
#define METHODDEF(type)               static type
/* a function used only in its module: */
#define LOCAL(type)           static type
/* a function referenced thru EXTERNs: */
#define GLOBAL(type)          type
/* a reference to a GLOBAL function: */

#define EXTERN(type)          extern type

/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
 * Again, you can customize this if you need special linkage keywords.
 */

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
#endif


/* Here is the pseudo-keyword for declaring pointers that must be "far"
 * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
 * by just saying "FAR *" where such a pointer is needed.  In a few places
 * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
 */

#ifndef WIN32 /* don't mess with this at all */
#ifdef NEED_FAR_POINTERS
#define FAR  far
#else
#define FAR
#endif
#endif

#if WINNT   // For some reason wants FAR ??? -scousens
#ifndef FAR // windows.h has not been included
#ifdef NEED_FAR_POINTERS
#define FAR  far
#else
#define FAR
#endif
#endif
#endif

/*
 * On a few systems, type boolean and/or its values FALSE, TRUE may appear
 * in standard header files.  Or you may have conflicts with application-
 * specific header files that you want to include together with these files.
 * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
 */

#ifndef HAVE_BOOLEAN
typedef int boolean;
#endif
#ifndef FALSE			/* in case these macros already exist */
#define FALSE	0		/* values of boolean */
#endif
#ifndef TRUE
#define TRUE	1
#endif


/*
 * The remaining options affect code selection within the JPEG library,
 * but they don't need to be visible to most applications using the library.
 * To minimize application namespace pollution, the symbols won't be
 * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.
 */

#ifdef JPEG_INTERNALS
#define JPEG_INTERNAL_OPTIONS
#endif

#ifdef JPEG_INTERNAL_OPTIONS


/*
 * These defines indicate whether to include various optional functions.
 * Undefining some of these symbols will produce a smaller but less capable
 * library.  Note that you can leave certain source files out of the
 * compilation/linking process if you've #undef'd the corresponding symbols.
 * (You may HAVE to do that if your compiler doesn't like null source files.)
 */

/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */

/* Capability options common to encoder and decoder: */

#define DCT_ISLOW_SUPPORTED	/* slow but accurate integer algorithm */
#define DCT_IFAST_SUPPORTED	/* faster, less accurate integer method */
#define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */

/* Encoder capability options: */

#undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
#define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
#define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
/* Note: if you selected 12-bit data precision, it is dangerous to turn off
 * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
 * precision, so jchuff.c normally uses entropy optimization to compute
 * usable tables for higher precision.  If you don't want to do optimization,
 * you'll have to supply different default Huffman tables.
 * The exact same statements apply for progressive JPEG: the default tables
 * don't work for progressive mode.  (This may get fixed, however.)
 */
#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */

/* Decoder capability options: */

#undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
#define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
#define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
#define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
#undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */

/* more capability options later, no doubt */


/*
 * Ordering of RGB data in scanlines passed to or from the application.
 * If your application wants to deal with data in the order B,G,R, just
 * change these macros.  You can also deal with formats such as R,G,B,X
 * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing
 * the offsets will also change the order in which colormap data is organized.
 * RESTRICTIONS:
 * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.
 * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not
 *    useful if you are using JPEG color spaces other than YCbCr or grayscale.
 * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE
 *    is not 3 (they don't understand about dummy color components!).  So you
 *    can't use color quantization if you change that value.
 */

#define RGB_RED		0	/* Offset of Red in an RGB scanline element */
#define RGB_GREEN	1	/* Offset of Green */
#define RGB_BLUE	2	/* Offset of Blue */
#define RGB_PIXELSIZE	3	/* JSAMPLEs per RGB scanline element */


/* Definitions for speed-related optimizations. */


/* If your compiler supports inline functions, define INLINE
 * as the inline keyword; otherwise define it as empty.
 */

#ifndef INLINE
#ifdef __GNUC__			/* for instance, GNU C knows about inline */
#define INLINE __inline__
#endif
#ifndef INLINE
#define INLINE			/* default is to define it as empty */
#endif
#endif


/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying
 * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
 * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.
 */

#define MULTIPLIER  short

#ifndef MULTIPLIER
#define MULTIPLIER  int		/* type for fastest integer multiply */
#endif


/* FAST_FLOAT should be either float or double, whichever is done faster
 * by your compiler.  (Note that this type is only used in the floating point
 * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)
 * Typically, float is faster in ANSI C compilers, while double is faster in
 * pre-ANSI compilers (because they insist on converting to double anyway).
 * The code below therefore chooses float if we have ANSI-style prototypes.
 */

#ifndef FAST_FLOAT
#ifdef HAVE_PROTOTYPES
#define FAST_FLOAT  float
#else
#define FAST_FLOAT  double
#endif
#endif

#endif /* JPEG_INTERNAL_OPTIONS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jpegint.h ===
/*
 * jpegint.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides common declarations for the various JPEG modules.
 * These declarations are considered internal to the JPEG library; most
 * applications using the library shouldn't need to include this file.
 */


/* Declarations for both compression & decompression */

typedef enum {			/* Operating modes for buffer controllers */
	JBUF_PASS_THRU,		/* Plain stripwise operation */
	/* Remaining modes require a full-image buffer to have been created */
	JBUF_SAVE_SOURCE,	/* Run source subobject only, save output */
	JBUF_CRANK_DEST,	/* Run dest subobject only, using saved data */
	JBUF_SAVE_AND_PASS	/* Run both subobjects, save output */
} J_BUF_MODE;

/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
#define CSTATE_START	100	/* after create_compress */
#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
#define DSTATE_START	200	/* after create_decompress */
#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */


/* Declarations for compression modules */

/* Master control module */
struct jpeg_comp_master {
  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean call_pass_startup;	/* True if pass_startup must be called */
  boolean is_last_pass;		/* True during last pass */
};

/* Main buffer control (downsampled-data buffer) */
struct jpeg_c_main_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, process_data, (j_compress_ptr cinfo,
			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
			       JDIMENSION in_rows_avail));
};

/* Compression preprocessing (downsampling input buffer control) */
struct jpeg_c_prep_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
				   JSAMPARRAY input_buf,
				   JDIMENSION *in_row_ctr,
				   JDIMENSION in_rows_avail,
				   JSAMPIMAGE output_buf,
				   JDIMENSION *out_row_group_ctr,
				   JDIMENSION out_row_groups_avail));
};

/* Coefficient buffer control */
struct jpeg_c_coef_controller {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
				   JSAMPIMAGE input_buf));
};

/* Colorspace conversion */
struct jpeg_color_converter {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
				JDIMENSION output_row, int num_rows));
};

/* Downsampling */
struct jpeg_downsampler {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  JMETHOD(void, downsample, (j_compress_ptr cinfo,
			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
			     JSAMPIMAGE output_buf,
			     JDIMENSION out_row_group_index));

  boolean need_context_rows;	/* TRUE if need rows above & below */
};

/* Forward DCT (also controls coefficient quantization) */
struct jpeg_forward_dct {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
  /* perhaps this should be an array??? */
  JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
			      jpeg_component_info * compptr,
			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
			      JDIMENSION start_row, JDIMENSION start_col,
			      JDIMENSION num_blocks));
};

/* Entropy encoding */
struct jpeg_entropy_encoder {
  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
};

/* Marker writing */
struct jpeg_marker_writer {
  /* write_any_marker is exported for use by applications */
  /* Probably only COM and APPn markers should be written */
  JMETHOD(void, write_any_marker, (j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));
  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
};


/* Declarations for decompression modules */

/* Master control module */
struct jpeg_decomp_master {
  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
};

/* Input control module */
struct jpeg_input_controller {
  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean has_multiple_scans;	/* True if file has multiple scans */
  boolean eoi_reached;		/* True when EOI has been consumed */
};

/* Main buffer control (downsampled-data buffer) */
struct jpeg_d_main_controller {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			       JDIMENSION out_rows_avail));
};

/* Coefficient buffer control */
struct jpeg_d_coef_controller {
  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
				 JSAMPIMAGE output_buf));
  /* Pointer to array of coefficient virtual arrays, or NULL if none */
  jvirt_barray_ptr *coef_arrays;
};

/* Decompression postprocessing (color quantization buffer control) */
struct jpeg_d_post_controller {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
				    JSAMPIMAGE input_buf,
				    JDIMENSION *in_row_group_ctr,
				    JDIMENSION in_row_groups_avail,
				    JSAMPARRAY output_buf,
				    JDIMENSION *out_row_ctr,
				    JDIMENSION out_rows_avail));
};

/* Marker reading & parsing */
struct jpeg_marker_reader {
  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
  /* Read markers until SOS or EOI.
   * Returns same codes as are defined for jpeg_consume_input:
   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
   */
  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
  /* Read a restart marker --- exported for use by entropy decoder only */
  jpeg_marker_parser_method read_restart_marker;
  /* Application-overridable marker processing methods */
  jpeg_marker_parser_method process_COM;
  jpeg_marker_parser_method process_APPn[16];

  /* State of marker reader --- nominally internal, but applications
   * supplying COM or APPn handlers might like to know the state.
   */
  boolean saw_SOI;		/* found SOI? */
  boolean saw_SOF;		/* found SOF? */
  int next_restart_num;		/* next restart number expected (0-7) */
  unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
};

/* Entropy decoding */
struct jpeg_entropy_decoder {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  boolean (__cdecl *decode_mcu)(j_decompress_ptr cinfo,	JBLOCKROW *MCU_data);
};

/* Inverse DCT (also performs dequantization) */
typedef JMETHOD(void, inverse_DCT_method_ptr,
		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col));

struct jpeg_inverse_dct {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  /* It is useful to allow each component to have a separate IDCT method. */
  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
};

/* Upsampling (note that upsampler must also call color converter) */
struct jpeg_upsampler {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
			   JSAMPIMAGE input_buf,
			   JDIMENSION *in_row_group_ctr,
			   JDIMENSION in_row_groups_avail,
			   JSAMPARRAY output_buf,
			   JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail));

  boolean need_context_rows;	/* TRUE if need rows above & below */
};

/* Colorspace conversion */
struct jpeg_color_deconverter {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
				JSAMPIMAGE input_buf, JDIMENSION input_row,
				JSAMPARRAY output_buf, int num_rows));
};

/* Color quantization or color precision reduction */
struct jpeg_color_quantizer {
  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
				 int num_rows));
  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
};


/* Miscellaneous useful macros */

#undef MAX
#define MAX(a,b)	((a) > (b) ? (a) : (b))
#undef MIN
#define MIN(a,b)	((a) < (b) ? (a) : (b))


/* We assume that right shift corresponds to signed division by 2 with
 * rounding towards minus infinity.  This is correct for typical "arithmetic
 * shift" instructions that shift in copies of the sign bit.  But some
 * C compilers implement >> with an unsigned shift.  For these machines you
 * must define RIGHT_SHIFT_IS_UNSIGNED.
 * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
 * It is only applied with constant shift counts.  SHIFT_TEMPS must be
 * included in the variables of any routine using RIGHT_SHIFT.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define SHIFT_TEMPS	INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
	((shift_temp = (x)) < 0 ? \
	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
	 (shift_temp >> (shft)))
#else
#define SHIFT_TEMPS
#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_compress_master	jICompress
#define jinit_c_master_control	jICMaster
#define jinit_c_main_controller	jICMainC
#define jinit_c_prep_controller	jICPrepC
#define jinit_c_coef_controller	jICCoefC
#define jinit_color_converter	jICColor
#define jinit_downsampler	jIDownsampler
#define jinit_forward_dct	jIFDCT
#define jinit_huff_encoder	jIHEncoder
#define jinit_phuff_encoder	jIPHEncoder
#define jinit_marker_writer	jIMWriter
#define jinit_master_decompress	jIDMaster
#define jinit_d_main_controller	jIDMainC
#define jinit_d_coef_controller	jIDCoefC
#define jinit_d_post_controller	jIDPostC
#define jinit_input_controller	jIInCtlr
#define jinit_marker_reader	jIMReader
#define jinit_huff_decoder	jIHDecoder
#define jinit_phuff_decoder	jIPHDecoder
#define jinit_inverse_dct	jIIDCT
#define jinit_upsampler		jIUpsampler
#define jinit_color_deconverter	jIDColor
#define jinit_1pass_quantizer	jI1Quant
#define jinit_2pass_quantizer	jI2Quant
#define jinit_merged_upsampler	jIMUpsampler
#define jinit_memory_mgr	jIMemMgr
#define jdiv_round_up		jDivRound
#define jround_up		jRound
#define jcopy_sample_rows	jCopySamples
#define jcopy_block_row		jCopyBlocks
#define jzero_far		jZeroFar
#define jpeg_zigzag_order	jZIGTable
#define jpeg_natural_order	jZAGTable
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Compression module initialization routines */
EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
					 boolean transcode_only));
EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
/* Decompression module initialization routines */
EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
					  boolean need_full_buffer));
EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
/* Memory manager initialization */
EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));

/* Utility routines in jutils.c */
EXTERN(long) jdiv_round_up JPP((long a, long b));
EXTERN(long) jround_up JPP((long a, long b));
EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
				    JSAMPARRAY output_array, int dest_row,
				    int num_rows, JDIMENSION num_cols));
EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
				  JDIMENSION num_blocks));
EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
EXTERN(int)  IsMMX JPP((void));

/* Constant tables in jutils.c */
extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
extern boolean vfMMXMachine;

/* Suppress undefined-structure complaints if necessary. */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
#endif
#endif /* INCOMPLETE_TYPES_BROKEN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jpeglib.h ===
/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 */

#ifndef JPEGLIB_H
#define JPEGLIB_H

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
#include "jconfig.h"		/* widely used configuration options */
#endif
#include "jmorecfg.h"		/* seldom changed options */


/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
 */

#define JPEG_LIB_VERSION  61	/* Version 6a */


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
/* The PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
 */
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This array gives the coefficient quantizers in natural array order
   * (not the zigzag order in which they are stored in a JPEG DQT marker).
   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];		/* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;		/* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;		/* identifier for this component (0..255) */
  int component_index;		/* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;		/* horizontal sampling factor (1..4) */
  int v_samp_factor;		/* vertical sampling factor (1..4) */
  int quant_tbl_no;		/* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  /* The decompressor output side may not use these variables. */
  int dc_tbl_no;		/* DC entropy table selector (0..3) */
  int ac_tbl_no;		/* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
   */
  int DCT_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
   */
  JDIMENSION downsampled_width;	 /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;	/* do we need the value of this component? */

  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
  int MCU_width;		/* number of blocks per MCU, horizontally */
  int MCU_height;		/* number of blocks per MCU, vertically */
  int MCU_blocks;		/* MCU_width * MCU_height */
  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
  int last_col_width;		/* # of non-dummy blocks across in last MCU */
  int last_row_height;		/* # of non-dummy blocks down in last MCU */

  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is currently used only for decompression.
   */
  JQUANT_TBL * quant_table;

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;		/* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;			/* progressive JPEG spectral selection parms */
  int Ah, Al;			/* progressive JPEG successive approx. parms */
} jpeg_scan_info;


/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,		/* error/unspecified */
	JCS_GRAYSCALE,		/* monochrome */
	JCS_RGB,		/* red/green/blue */
	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,		/* C/M/Y/K */
	JCS_YCCK		/* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,		/* slow but accurate integer algorithm */
	JDCT_IFAST,		/* faster, less accurate integer method */
	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,		/* no dithering */
	JDITHER_ORDERED,	/* simple ordered dither */
	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;	/* Error handler module */\
  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  boolean is_decompressor;	/* so common code can tell which is which */\
  int global_state		/* for checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;		/* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;	/* input image width */
  JDIMENSION image_height;	/* input image height */
  int input_components;		/* # of color components in input image */
  J_COLOR_SPACE in_color_space;	/* colorspace of input image */

  double input_gamma;		/* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  int data_precision;		/* bits of precision in image data */

  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */
  
  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */
  
  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  int num_scans;		/* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;	/* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;		/* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;	/* should a JFIF marker be written? */
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
  
  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;	/* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
  
  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
  JDIMENSION image_height;	/* nominal image height */
  int num_components;		/* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;		/* image gamma wanted in output */

  boolean buffered_image;	/* TRUE=multiple output passes */
  boolean raw_data_out;		/* TRUE=downsampled data wanted */

  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */

  boolean quantize_colors;	/* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
  int desired_number_of_colors;	/* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;	/* scaled image width */
  JDIMENSION output_height;	/* scaled image height */
  int out_color_components;	/* # of color components in out_color_space */
  int output_components;	/* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;	/* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress or jpeg_start_output.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;	/* number of entries in use */
  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */

  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
   */

  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
  JDIMENSION output_scanline;	/* 0 .. output_height-1  */

  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;	/* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;	/* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;		/* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker: */
  UINT8 density_unit;		/* JFIF code for pixel size units */
  UINT16 X_density;		/* Horizontal pixel density */
  UINT16 Y_density;		/* Vertical pixel density */
  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */

  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;	/* largest h_samp_factor */
  int max_v_samp_factor;	/* largest v_samp_factor */

  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */

  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   * Note that the decompressor output side must not use these fields.
   */
  int comps_in_scan;		/* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */

  int blocks_in_MCU;		/* # of DCT blocks per MCU */
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;		/* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;		/* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;	/* code for first string in addon table */
  int last_addon_message;	/* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;		/* work units completed in this pass */
  long pass_limit;		/* total number of work units in this pass */
  int completed_passes;		/* passes completed so far */
  int total_passes;		/* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS	2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   JDIMENSION num_rows,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    JDIMENSION num_rows,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)	arglist
#else
#define JPP(arglist)	()
#endif


/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error		jStdError
#define jpeg_CreateCompress	jCreaCompress
#define jpeg_CreateDecompress	jCreaDecompress
#define jpeg_destroy_compress	jDestCompress
#define jpeg_destroy_decompress	jDestDecompress
#define jpeg_stdio_dest		jStdDest
#define jpeg_stdio_src		jStdSrc
#define jpeg_set_defaults	jSetDefaults
#define jpeg_set_colorspace	jSetColorspace
#define jpeg_default_colorspace	jDefColorspace
#define jpeg_set_quality	jSetQuality
#define jpeg_set_linear_quality	jSetLQuality
#define jpeg_add_quant_table	jAddQuantTable
#define jpeg_quality_scaling	jQualityScaling
#define jpeg_simple_progression	jSimProgress
#define jpeg_suppress_tables	jSuppressTables
#define jpeg_alloc_quant_table	jAlcQTable
#define jpeg_alloc_huff_table	jAlcHTable
#define jpeg_start_compress	jStrtCompress
#define jpeg_write_scanlines	jWrtScanlines
#define jpeg_finish_compress	jFinCompress
#define jpeg_write_raw_data	jWrtRawData
#define jpeg_write_marker	jWrtMarker
#define jpeg_write_tables	jWrtTables
#define jpeg_read_header	jReadHeader
#define jpeg_start_decompress	jStrtDecompress
#define jpeg_read_scanlines	jReadScanlines
#define jpeg_finish_decompress	jFinDecompress
#define jpeg_read_raw_data	jReadRawData
#define jpeg_has_multiple_scans	jHasMultScn
#define jpeg_start_output	jStrtOutput
#define jpeg_finish_output	jFinOutput
#define jpeg_input_complete	jInComplete
#define jpeg_new_colormap	jNewCMap
#define jpeg_consume_input	jConsumeInput
#define jpeg_calc_output_dimensions	jCalcDimensions
#define jpeg_set_marker_processor	jSetMarker
#define jpeg_read_coefficients	jReadCoefs
#define jpeg_write_coefficients	jWrtCoefs
#define jpeg_copy_critical_parameters	jCopyCrit
#define jpeg_abort_compress	jAbrtCompress
#define jpeg_abort_decompress	jAbrtDecompress
#define jpeg_abort		jAbort
#define jpeg_destroy		jDestroy
#define jpeg_resync_to_restart	jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN(struct jpeg_error_mgr *) jpeg_std_error
	JPP((struct jpeg_error_mgr * err));

/* Initialization of JPEG compression objects.
 * jpeg_create_compress() and jpeg_create_decompress() are the exported
 * names that applications should call.  These expand to calls on
 * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
 * passed for version mismatch checking.
 * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
 */
#define jpeg_create_compress(cinfo) \
    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
			(size_t) sizeof(struct jpeg_compress_struct))
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))
EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
				      int version, size_t structsize));
EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
					int version, size_t structsize));
/* Destruction of JPEG compression objects */
EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
//EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
//EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));

/* Default parameter setup for compression */
EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
/* Compression parameter setup aids */
EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				      J_COLOR_SPACE colorspace));
EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				   boolean force_baseline));
EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					  int scale_factor,
					  boolean force_baseline));
EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				       const unsigned int *basic_table,
				       int scale_factor,
				       boolean force_baseline));
EXTERN(int) jpeg_quality_scaling JPP((int quality));
EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				       boolean suppress));
EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));

/* Main entry points for compression */
EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
				      boolean write_all_tables));
EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					     JSAMPARRAY scanlines,
					     JDIMENSION num_lines));
EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					    JSAMPIMAGE data,
					    JDIMENSION num_lines));

/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN(void) jpeg_write_marker
	JPP((j_compress_ptr cinfo, int marker,
	     const JOCTET * dataptr, unsigned int datalen));

/* Alternate compression function: just write an abbreviated table file */
EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
				  boolean require_image));
/* Return value is one of: */
#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK		1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION max_lines));
EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION max_lines));

/* Additional entry points for buffered-image mode. */
EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
				       int scan_number));
EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
/* Return value is one of: */
/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
#define JPEG_REACHED_EOI	2 /* Reached end of image */
#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */

/* Precalculate output dimensions for current decompression parameters. */
EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));

/* Install a special processing method for COM or APPn markers. */
EXTERN(void) jpeg_set_marker_processor
	JPP((j_decompress_ptr cinfo, int marker_code,
	     jpeg_marker_parser_method routine));

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					  jvirt_barray_ptr * coef_arrays));
EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
						j_compress_ptr dstinfo));

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					    int desired));


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_RST0	0xD0	/* RST0 marker code */
#define JPEG_EOI	0xD9	/* EOI marker code */
#define JPEG_APP0	0xE0	/* APP0 marker code */
#define JPEG_COM	0xFE	/* COM marker code */


/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_input_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"		/* fetch private declarations */
#include "jerror.h"		/* fetch error codes too */
#endif

#endif /* JPEGLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\jquant2.c ===
/*
 * jquant2.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 2-pass color quantization (color mapping) routines.
 * These routines provide selection of a custom color map for an image,
 * followed by mapping of the image to that color map, with optional
 * Floyd-Steinberg dithering.
 * It is also possible to use just the second pass to map to an arbitrary
 * externally-given color map.
 *
 * Note: ordered dithering is not supported, since there isn't any fast
 * way to compute intercolor distances; it's unclear that ordered dither's
 * fundamental assumptions even hold with an irregularly spaced color map.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"

#ifdef QUANT_2PASS_SUPPORTED


/*
 * This module implements the well-known Heckbert paradigm for color
 * quantization.  Most of the ideas used here can be traced back to
 * Heckbert's seminal paper
 *   Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
 *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
 *
 * In the first pass over the image, we accumulate a histogram showing the
 * usage count of each possible color.  To keep the histogram to a reasonable
 * size, we reduce the precision of the input; typical practice is to retain
 * 5 or 6 bits per color, so that 8 or 4 different input values are counted
 * in the same histogram cell.
 *
 * Next, the color-selection step begins with a box representing the whole
 * color space, and repeatedly splits the "largest" remaining box until we
 * have as many boxes as desired colors.  Then the mean color in each
 * remaining box becomes one of the possible output colors.
 * 
 * The second pass over the image maps each input pixel to the closest output
 * color (optionally after applying a Floyd-Steinberg dithering correction).
 * This mapping is logically trivial, but making it go fast enough requires
 * considerable care.
 *
 * Heckbert-style quantizers vary a good deal in their policies for choosing
 * the "largest" box and deciding where to cut it.  The particular policies
 * used here have proved out well in experimental comparisons, but better ones
 * may yet be found.
 *
 * In earlier versions of the IJG code, this module quantized in YCbCr color
 * space, processing the raw upsampled data without a color conversion step.
 * This allowed the color conversion math to be done only once per colormap
 * entry, not once per pixel.  However, that optimization precluded other
 * useful optimizations (such as merging color conversion with upsampling)
 * and it also interfered with desired capabilities such as quantizing to an
 * externally-supplied colormap.  We have therefore abandoned that approach.
 * The present code works in the post-conversion color space, typically RGB.
 *
 * To improve the visual quality of the results, we actually work in scaled
 * RGB space, giving G distances more weight than R, and R in turn more than
 * B.  To do everything in integer math, we must use integer scale factors.
 * The 2/3/1 scale factors used here correspond loosely to the relative
 * weights of the colors in the NTSC grayscale equation.
 * If you want to use this code to quantize a non-RGB color space, you'll
 * probably need to change these scale factors.
 */

#define R_SCALE 2		/* scale R distances by this much */
#define G_SCALE 3		/* scale G distances by this much */
#define B_SCALE 1		/* and B by this much */

/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined
 * in jmorecfg.h.  As the code stands, it will do the right thing for R,G,B
 * and B,G,R orders.  If you define some other weird order in jmorecfg.h,
 * you'll get compile errors until you extend this logic.  In that case
 * you'll probably want to tweak the histogram sizes too.
 */

#if RGB_RED == 0
#define C0_SCALE R_SCALE
#endif
#if RGB_BLUE == 0
#define C0_SCALE B_SCALE
#endif
#if RGB_GREEN == 1
#define C1_SCALE G_SCALE
#endif
#if RGB_RED == 2
#define C2_SCALE R_SCALE
#endif
#if RGB_BLUE == 2
#define C2_SCALE B_SCALE
#endif


/*
 * First we have the histogram data structure and routines for creating it.
 *
 * The number of bits of precision can be adjusted by changing these symbols.
 * We recommend keeping 6 bits for G and 5 each for R and B.
 * If you have plenty of memory and cycles, 6 bits all around gives marginally
 * better results; if you are short of memory, 5 bits all around will save
 * some space but degrade the results.
 * To maintain a fully accurate histogram, we'd need to allocate a "long"
 * (preferably unsigned long) for each cell.  In practice this is overkill;
 * we can get by with 16 bits per cell.  Few of the cell counts will overflow,
 * and clamping those that do overflow to the maximum value will give close-
 * enough results.  This reduces the recommended histogram size from 256Kb
 * to 128Kb, which is a useful savings on PC-class machines.
 * (In the second pass the histogram space is re-used for pixel mapping data;
 * in that capacity, each cell must be able to store zero to the number of
 * desired colors.  16 bits/cell is plenty for that too.)
 * Since the JPEG code is intended to run in small memory model on 80x86
 * machines, we can't just allocate the histogram in one chunk.  Instead
 * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
 * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
 * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
 * on 80x86 machines, the pointer row is in near memory but the actual
 * arrays are in far memory (same arrangement as we use for image arrays).
 */

#define MAXNUMCOLORS  (MAXJSAMPLE+1) /* maximum size of colormap */

/* These will do the right thing for either R,G,B or B,G,R color order,
 * but you may not like the results for other color orders.
 */
#define HIST_C0_BITS  5		/* bits of precision in R/B histogram */
#define HIST_C1_BITS  6		/* bits of precision in G histogram */
#define HIST_C2_BITS  5		/* bits of precision in B/R histogram */

/* Number of elements along histogram axes. */
#define HIST_C0_ELEMS  (1<<HIST_C0_BITS)
#define HIST_C1_ELEMS  (1<<HIST_C1_BITS)
#define HIST_C2_ELEMS  (1<<HIST_C2_BITS)

/* These are the amounts to shift an input value to get a histogram index. */
#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)


typedef UINT16 histcell;	/* histogram cell; prefer an unsigned type */

typedef histcell FAR * histptr;	/* for pointers to histogram cells */

typedef histcell hist1d[HIST_C2_ELEMS]; /* typedefs for the array */
typedef hist1d FAR * hist2d;	/* type for the 2nd-level pointers */
typedef hist2d * hist3d;	/* type for top-level pointer */


/* Declarations for Floyd-Steinberg dithering.
 *
 * Errors are accumulated into the array fserrors[], at a resolution of
 * 1/16th of a pixel count.  The error at a given pixel is propagated
 * to its not-yet-processed neighbors using the standard F-S fractions,
 *		...	(here)	7/16
 *		3/16	5/16	1/16
 * We work left-to-right on even rows, right-to-left on odd rows.
 *
 * We can get away with a single array (holding one row's worth of errors)
 * by using it to store the current row's errors at pixel columns not yet
 * processed, but the next row's errors at columns already processed.  We
 * need only a few extra variables to hold the errors immediately around the
 * current column.  (If we are lucky, those variables are in registers, but
 * even if not, they're probably cheaper to access than array elements are.)
 *
 * The fserrors[] array has (#columns + 2) entries; the extra entry at
 * each end saves us from special-casing the first and last pixels.
 * Each entry is three values long, one value for each color component.
 *
 * Note: on a wide image, we might not have enough room in a PC's near data
 * segment to hold the error array; so it is allocated with alloc_large.
 */

#if BITS_IN_JSAMPLE == 8
typedef INT16 FSERROR;		/* 16 bits should be enough */
typedef int LOCFSERROR;		/* use 'int' for calculation temps */
#else
typedef INT32 FSERROR;		/* may need more than 16 bits */
typedef INT32 LOCFSERROR;	/* be sure calculation temps are big enough */
#endif

typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */


/* Private subobject */

typedef struct {
  struct jpeg_color_quantizer pub; /* public fields */

  /* Space for the eventually created colormap is stashed here */
  JSAMPARRAY sv_colormap;	/* colormap allocated at init time */
  int desired;			/* desired # of colors = size of colormap */

  /* Variables for accumulating image statistics */
  hist3d histogram;		/* pointer to the histogram */

  boolean needs_zeroed;		/* TRUE if next pass must zero histogram */

  /* Variables for Floyd-Steinberg dithering */
  FSERRPTR fserrors;		/* accumulated errors */
  boolean on_odd_row;		/* flag to remember which row we are on */
  int * error_limiter;		/* table for clamping the applied error */
} my_cquantizer;

typedef my_cquantizer * my_cquantize_ptr;


/*
 * Prescan some rows of pixels.
 * In this module the prescan simply updates the histogram, which has been
 * initialized to zeroes by start_pass.
 * An output_buf parameter is required by the method signature, but no data
 * is actually output (in fact the buffer controller is probably passing a
 * NULL pointer).
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptr = input_buf[row];
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
	(*histp)--;
      ptr += 3;
    }
  }
}


/*
 * Next we have the really interesting routines: selection of a colormap
 * given the completed histogram.
 * These routines work with a list of "boxes", each representing a rectangular
 * subset of the input color space (to histogram precision).
 */

typedef struct {
  /* The bounds of the box (inclusive); expressed as histogram indexes */
  int c0min, c0max;
  int c1min, c1max;
  int c2min, c2max;
  /* The volume (actually 2-norm) of the box */
  INT32 volume;
  /* The number of nonzero histogram cells within this box */
  long colorcount;
} box;

typedef box * boxptr;


LOCAL(boxptr)
find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
    if (boxp->colorcount > maxc && boxp->volume > 0) {
      which = boxp;
      maxc = boxp->colorcount;
    }
  }
  return which;
}


LOCAL(boxptr)
find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
    if (boxp->volume > maxv) {
      which = boxp;
      maxv = boxp->volume;
    }
  }
  return which;
}


LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;
  
  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c0min = c0min = c0;
	    goto have_c0min;
	  }
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c0max = c0max = c0;
	    goto have_c0max;
	  }
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c1min = c1min = c1;
	    goto have_c1min;
	  }
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
	    boxp->c1max = c1max = c1;
	    goto have_c1max;
	  }
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
	    boxp->c2min = c2min = c2;
	    goto have_c2min;
	  }
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
	    boxp->c2max = c2max = c2;
	    goto have_c2max;
	  }
      }
 have_c2max:

  /* Update box volume.
   * We use 2-norm rather than real volume here; this biases the method
   * against making long narrow boxes, and it has the side benefit that
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
  
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
	if (*histp != 0) {
	  ccount++;
	}
    }
  boxp->colorcount = ccount;
}


LOCAL(int)
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
/* Repeatedly select and split the largest box until we have enough boxes */
{
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
      b1 = find_biggest_color_pop(boxlist, numboxes);
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
    }
    if (b1 == NULL)		/* no splittable boxes left! */
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
    /* We want to break any ties in favor of green, then red, blue last.
     * This code does the right thing for R,G,B or B,G,R color orders only.
     */
#if RGB_RED == 0
    cmax = c1; n = 1;
    if (c0 > cmax) { cmax = c0; n = 0; }
    if (c2 > cmax) { n = 2; }
#else
    cmax = c1; n = 1;
    if (c2 > cmax) { cmax = c2; n = 2; }
    if (c0 > cmax) { n = 0; }
#endif
    /* Choose split point along selected axis, and update box bounds.
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
      b1->c0max = lb;
      b2->c0min = lb+1;
      break;
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
      b1->c1max = lb;
      b2->c1min = lb+1;
      break;
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
      b1->c2max = lb;
      b2->c2min = lb+1;
      break;
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
    update_box(cinfo, b2);
    numboxes++;
  }
  return numboxes;
}


LOCAL(void)
compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  long count;
  long total = 0;
  long c0total = 0;
  long c1total = 0;
  long c2total = 0;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;
  
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
	}
      }
    }
  
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
}


LOCAL(void)
select_colors (j_decompress_ptr cinfo, int desired_colors)
/* Master routine for color selection */
{
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
  boxlist[0].c0min = 0;
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
  boxlist[0].c1min = 0;
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
  boxlist[0].c2min = 0;
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
    compute_color(cinfo, & boxlist[i], i);
  cinfo->actual_number_of_colors = numboxes;
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
}


/*
 * These routines are concerned with the time-critical task of mapping input
 * colors to the nearest color in the selected colormap.
 *
 * We re-use the histogram space as an "inverse color map", essentially a
 * cache for the results of nearest-color searches.  All colors within a
 * histogram cell will be mapped to the same colormap entry, namely the one
 * closest to the cell's center.  This may not be quite the closest entry to
 * the actual input color, but it's almost as good.  A zero in the cache
 * indicates we haven't found the nearest color for that cell yet; the array
 * is cleared to zeroes before starting the mapping pass.  When we find the
 * nearest color for a cell, its colormap index plus one is recorded in the
 * cache for future use.  The pass2 scanning routines call fill_inverse_cmap
 * when they need to use an unfilled entry in the cache.
 *
 * Our method of efficiently finding nearest colors is based on the "locally
 * sorted search" idea described by Heckbert and on the incremental distance
 * calculation described by Spencer W. Thomas in chapter III.1 of Graphics
 * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that
 * the distances from a given colormap entry to each cell of the histogram can
 * be computed quickly using an incremental method: the differences between
 * distances to adjacent cells themselves differ by a constant.  This allows a
 * fairly fast implementation of the "brute force" approach of computing the
 * distance from every colormap entry to every histogram cell.  Unfortunately,
 * it needs a work array to hold the best-distance-so-far for each histogram
 * cell (because the inner loop has to be over cells, not colormap entries).
 * The work array elements have to be INT32s, so the work array would need
 * 256Kb at our recommended precision.  This is not feasible in DOS machines.
 *
 * To get around these problems, we apply Thomas' method to compute the
 * nearest colors for only the cells within a small subbox of the histogram.
 * The work array need be only as big as the subbox, so the memory usage
 * problem is solved.  Furthermore, we need not fill subboxes that are never
 * referenced in pass2; many images use only part of the color gamut, so a
 * fair amount of work is saved.  An additional advantage of this
 * approach is that we can apply Heckbert's locality criterion to quickly
 * eliminate colormap entries that are far away from the subbox; typically
 * three-fourths of the colormap entries are rejected by Heckbert's criterion,
 * and we need not compute their distances to individual cells in the subbox.
 * The speed of this approach is heavily influenced by the subbox size: too
 * small means too much overhead, too big loses because Heckbert's criterion
 * can't eliminate as many colormap entries.  Empirically the best subbox
 * size seems to be about 1/512th of the histogram (1/8th in each direction).
 *
 * Thomas' article also describes a refined method which is asymptotically
 * faster than the brute-force method, but it is also far more complex and
 * cannot efficiently be applied to small subboxes.  It is therefore not
 * useful for programs intended to be portable to DOS machines.  On machines
 * with plenty of memory, filling the whole histogram in one shot with Thomas'
 * refined method might be faster than the present code --- but then again,
 * it might not be any faster, and it's certainly more complicated.
 */


/* log2(histogram cells in update box) for each axis; this can be adjusted */
#define BOX_C0_LOG  (HIST_C0_BITS-3)
#define BOX_C1_LOG  (HIST_C1_BITS-3)
#define BOX_C2_LOG  (HIST_C2_BITS-3)

#define BOX_C0_ELEMS  (1<<BOX_C0_LOG) /* # of hist cells in update box */
#define BOX_C1_ELEMS  (1<<BOX_C1_LOG)
#define BOX_C2_ELEMS  (1<<BOX_C2_LOG)

#define BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)
#define BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)
#define BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)


/*
 * The next three routines implement inverse colormap filling.  They could
 * all be folded into one big routine, but splitting them up this way saves
 * some stack space (the mindist[] and bestdist[] arrays need not coexist)
 * and may allow some compilers to produce better code by registerizing more
 * inner-loop variables.
 */

LOCAL(int)
find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
		    JSAMPLE colorlist[])
/* Locate the colormap entries close enough to an update box to be candidates
 * for the nearest entry to some cell(s) in the update box.  The update box
 * is specified by the center coordinates of its first cell.  The number of
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
  int numcolors = cinfo->actual_number_of_colors;
  int maxc0, maxc1, maxc2;
  int centerc0, centerc1, centerc2;
  int i, x, ncolors;
  INT32 minmaxdist, min_dist, max_dist, tdist;
  INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */

  /* Compute true coordinates of update box's upper corner and center.
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
  centerc0 = (minc0 + maxc0) >> 1;
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
  centerc1 = (minc1 + maxc1) >> 1;
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
  centerc2 = (minc2 + maxc2) >> 1;

  /* For each color in colormap, find:
   *  1. its minimum squared-distance to any point in the update box
   *     (zero if color is within update box);
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
    if (x < minc0) {
      tdist = (x - minc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - maxc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else if (x > maxc0) {
      tdist = (x - maxc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - minc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
      if (x <= centerc0) {
	tdist = (x - maxc0) * C0_SCALE;
	max_dist = tdist*tdist;
      } else {
	tdist = (x - minc0) * C0_SCALE;
	max_dist = tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
    if (x < minc1) {
      tdist = (x - minc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc1) {
      tdist = (x - maxc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
	tdist = (x - maxc1) * C1_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc1) * C1_SCALE;
	max_dist += tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
    if (x < minc2) {
      tdist = (x - minc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc2) {
      tdist = (x - maxc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
	tdist = (x - maxc2) * C2_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc2) * C2_SCALE;
	max_dist += tdist*tdist;
      }
    }

    mindist[i] = min_dist;	/* save away the results */
    if (max_dist < minmaxdist)
      minmaxdist = max_dist;
  }

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
    if (mindist[i] <= minmaxdist)
      colorlist[ncolors++] = (JSAMPLE) i;
  }
  return ncolors;
}


LOCAL(void)
find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
/* Find the closest colormap entry for each cell in the update box,
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
  int ic0, ic1, ic2;
  int i, icolor;
  register INT32 * bptr;	/* pointer into bestdist[] array */
  JSAMPLE * cptr;		/* pointer into bestcolor[] array */
  INT32 dist0, dist1;		/* initial distance values */
  register INT32 dist2;		/* current distance in inner loop */
  INT32 xx0, xx1;		/* distance increments */
  register INT32 xx2;
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;
  
  /* For each color selected by find_nearby_colors,
   * compute its distance to the center of each cell in the box.
   * If that's less than best-so-far, update best distance and color number.
   */
  
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
    icolor = GETJSAMPLE(colorlist[i]);
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
    dist0 = inc0*inc0;
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
    dist0 += inc1*inc1;
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
    dist0 += inc2*inc2;
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
    cptr = bestcolor;
    xx0 = inc0;
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
      dist1 = dist0;
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
	dist2 = dist1;
	xx2 = inc2;
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
	  if (dist2 < *bptr) {
	    *bptr = dist2;
	    *cptr = (JSAMPLE) icolor;
	  }
	  dist2 += xx2;
	  xx2 += 2 * STEP_C2 * STEP_C2;
	  bptr++;
	  cptr++;
	}
	dist1 += xx1;
	xx1 += 2 * STEP_C1 * STEP_C1;
      }
      dist0 += xx0;
      xx0 += 2 * STEP_C0 * STEP_C0;
    }
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int minc0, minc1, minc2;	/* lower left corner of update box */
  int ic0, ic1, ic2;
  register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
  register histptr cachep;	/* pointer into main cache array */
  /* This array lists the candidate colormap indexes. */
  JSAMPLE colorlist[MAXNUMCOLORS];
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
  c1 >>= BOX_C1_LOG;
  c2 >>= BOX_C2_LOG;

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
      cachep = & histogram[c0+ic0][c1+ic1][c2];
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
      }
    }
  }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      cachep = & histogram[c0][c1][c2];
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, c0,c1,c2);
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
    }
  }
}


METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  JSAMPROW inptr;		/* => current input pixel */
  JSAMPROW outptr;		/* => current output pixel */
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *error_limit = cquantize->error_limiter;
  JSAMPROW colormap0 = cinfo->colormap[0];
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    if (cquantize->on_odd_row) {
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
      outptr += width-1;
      dir = -1;
      dir3 = -3;
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
      cquantize->on_odd_row = FALSE; /* flip for next time */
    } else {
      /* work left to right in this row */
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors; /* => entry before first real column */
      cquantize->on_odd_row = TRUE; /* flip for next time */
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
    bpreverr0 = bpreverr1 = bpreverr2 = 0;

    for (col = width; col > 0; col--) {
      /* curN holds the error propagated from the previous pixel on the
       * current line.  Add the error propagated from the previous line
       * to form the complete error correction term for this pixel, and
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
      cur1 = error_limit[cur1];
      cur2 = error_limit[cur2];
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
      cur1 += GETJSAMPLE(inptr[1]);
      cur2 += GETJSAMPLE(inptr[2]);
      cur0 = GETJSAMPLE(range_limit[cur0]);
      cur1 = GETJSAMPLE(range_limit[cur1]);
      cur2 = GETJSAMPLE(range_limit[cur2]);
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
	*outptr = (JSAMPLE) pixcode;
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
      }
      /* Compute error fractions to be propagated to adjacent pixels.
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
	delta = cur0 * 2;
	cur0 += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
	cur0 += delta;		/* form error * 5 */
	bpreverr0 = belowerr0 + cur0;
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
	bnexterr = cur1;	/* Process component 1 */
	delta = cur1 * 2;
	cur1 += delta;		/* form error * 3 */
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
	cur1 += delta;		/* form error * 5 */
	bpreverr1 = belowerr1 + cur1;
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
	bnexterr = cur2;	/* Process component 2 */
	delta = cur2 * 2;
	cur2 += delta;		/* form error * 3 */
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
	cur2 += delta;		/* form error * 5 */
	bpreverr2 = belowerr2 + cur2;
	belowerr2 = bnexterr;
	cur2 += delta;		/* form error * 7 */
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
      outptr += dir;
      errorptr += dir3;		/* advance errorptr to current column */
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
    errorptr[1] = (FSERROR) bpreverr1;
    errorptr[2] = (FSERROR) bpreverr2;
  }
}


/*
 * Initialize the error-limiting transfer function (lookup table).
 * The raw F-S error computation can potentially compute error values of up to
 * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
 * much less, otherwise obviously wrong pixels will be created.  (Typical
 * effects include weird fringes at color-area boundaries, isolated bright
 * pixels in a dark area, etc.)  The standard advice for avoiding this problem
 * is to ensure that the "corners" of the color cube are allocated as output
 * colors; then repeated errors in the same direction cannot cause cascading
 * error buildup.  However, that only prevents the error from getting
 * completely out of hand; Aaron Giles reports that error limiting improves
 * the results even with corner colors allocated.
 * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
 * well, but the smoother transfer function used below is even better.  Thanks
 * to Aaron Giles for this idea.
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
  cquantize->error_limiter = table;

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    table[in] = out; table[-in] = -out;
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
    table[in] = out; table[-in] = -out;
  }
#undef STEPSIZE
}


/*
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
  select_colors(cinfo, cquantize->desired);
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
}


METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
  /* no work */
}


/*
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  if (is_pre_scan) {
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
    cquantize->pub.finish_pass = finish_pass1;
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
      cquantize->pub.color_quantize = pass2_fs_dither;
    else
      cquantize->pub.color_quantize = pass2_no_dither;
    cquantize->pub.finish_pass = finish_pass2;

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
    if (i < 1)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
    if (i > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);

    if (cinfo->dither_mode == JDITHER_FS) {
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      jzero_far((void FAR *) cquantize->fserrors, arraysize);
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
	init_error_limit(cinfo);
      cquantize->on_odd_row = FALSE;
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
    for (i = 0; i < HIST_C0_ELEMS; i++) {
      jzero_far((void FAR *) histogram[i],
		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
  }
}


/*
 * Switch to a new external colormap between output passes.
 */

METHODDEF(void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
}


/*
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_2_quant;
  cquantize->pub.new_color_map = new_color_map_2_quant;
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
  cquantize->error_limiter = NULL;

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
    ERREXIT(cinfo, JERR_NOTIMPL);

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
  } else
    cquantize->sv_colormap = NULL;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
  }
}

#endif /* QUANT_2PASS_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\mifst.c ===
/***************************************************************************
*
*                INTEL Corporation Proprietary Information  
*
*      
*                  Copyright (c) 1996 Intel Corporation.
*                         All rights reserved.
*
***************************************************************************
*/
/*
 * jidctfst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a fast, not so accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with fixed-point math,
 * accuracy is lost due to imprecise representation of the scaled
 * quantization values.  The smaller the quantization table entry, the less
 * precise the scaled value, so this implementation does worse with high-
 * quality-setting files than with low-quality ones.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_IFAST_SUPPORTED

#ifndef USEINLINEASM

GLOBAL(void)
midct8x8aan (JCOEFPTR coef_block, short * wsptr, short * quantptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{
}

#else

/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling decisions are generally the same as in the LL&M algorithm;
 * see jidctint.c for more details.  However, we choose to descale
 * (right shift) multiplication products as soon as they are formed,
 * rather than carrying additional fractional bits into subsequent additions.
 * This compromises accuracy slightly, but it lets us save a few shifts.
 * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
 * everywhere except in the multiplications proper; this saves a good deal
 * of work on 16-bit-int machines.
 *
 * The dequantized coefficients are not integers because the AA&N scaling
 * factors have been incorporated.  We represent them scaled up by PASS1_BITS,
 * so that the first and second IDCT rounds have the same input scaling.
 * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
 * avoid a descaling shift; this compromises accuracy rather drastically
 * for small quantization table entries, but it saves a lot of shifts.
 * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
 * so we use a much larger scaling factor to preserve accuracy.
 *
 * A final compromise is to represent the multiplicative constants to only
 * 8 fractional bits, rather than 13.  This saves some shifting work on some
 * machines, and may also reduce the cost of multiplication (since there
 * are fewer one-bits in the constants).
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  8
#define PASS1_BITS  2
#else
#define CONST_BITS  8
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */ 

#if CONST_BITS == 8
#define FIX_1_082392200  ((INT32)  277)		/* FIX(1.082392200) */
#define FIX_1_414213562  ((INT32)  362)		/* FIX(1.414213562) */
#define FIX_1_847759065  ((INT32)  473)		/* FIX(1.847759065) */
#define FIX_2_613125930  ((INT32)  669)		/* FIX(2.613125930) */
#else
#define FIX_1_082392200  FIX(1.082392200)
#define FIX_1_414213562  FIX(1.414213562)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_613125930  FIX(2.613125930)
#endif


/* We can gain a little more speed, with a further compromise in accuracy,
 * by omitting the addition in a descaling shift.  This yields an incorrectly
 * rounded result half the time...
 */

#ifndef USE_ACCURATE_ROUNDING
#undef DESCALE
#define DESCALE(x,n)  RIGHT_SHIFT(x, n)
#endif

//#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
/* Multiply a DCTELEM variable by an INT32 constant, and immediately
 * descale to yield a DCTELEM result.
 */

//#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))
#define MULTIPLY(var,const)  ((DCTELEM) ((var) * (const)))


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
 * multiplication will do.  For 12-bit data, the multiplier table is
 * declared INT32, so a 32-bit multiply will be used.
 */

#if BITS_IN_JSAMPLE == 8
//#define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))
#define DEQUANTIZE(coef,quantval)  (((coef)) * (quantval))
#else
#define DEQUANTIZE(coef,quantval)  \
	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
#endif

 
/* Like DESCALE, but applies to a DCTELEM and produces an int.
 * We assume that int right shift is unsigned if INT32 right shift is.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define ISHIFT_TEMPS	DCTELEM ishift_temp;
#if BITS_IN_JSAMPLE == 8
#define DCTELEMBITS  16		/* DCTELEM may be 16 or 32 bits */
#else
#define DCTELEMBITS  32		/* DCTELEM must be 32 bits */
#endif
#define IRIGHT_SHIFT(x,shft)  \
    ((ishift_temp = (x)) < 0 ? \
     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
     (ishift_temp >> (shft)))
#else
#define ISHIFT_TEMPS
#define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif

#ifdef USE_ACCURATE_ROUNDING
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
#else
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT(x, n))
#endif

static const __int64  x5a825a825a825a82 = 0x0000016a0000016a ;
static const __int64  x539f539f539f539f = 0x0000fd630000fd63 ; 
static const __int64  x4546454645464546 = 0x0000011500000115 ; 
static const __int64  x61f861f861f861f8 = 0x000001d9000001d9 ; 
static const __int64  const_mask  = 0x03ff03ff03ff03ff ;
static const __int64  const_zero  = 0x0000000000000000 ;


 
/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
midct8x8aan (JCOEFPTR coef_block, short * wsptr, short * quantptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{
  __int64 scratch3, scratch5, scratch7 ;

  // do the 2-Dal idct and store the corresponding results
  // from the range_limit array



__asm {

mov ebx, coef_block   ; source coeff
mov	esi, wsptr	  ; temp results
mov edi, quantptr	  ; quant factors

movq mm0,  [ebx+8*12]	; V12
pmullw mm0,  [edi+8*12]
movq mm1,  [ebx+8*4]	; V4
pmullw mm1,  [edi+8*4]
movq mm3,  [ebx+8*0]	; V0
pmullw mm3,  [edi+8*0]

movq mm5,  [ebx+8*8]	; V8
movq mm2, mm1						; duplicate V4

pmullw mm5,  [edi+8*8]
psubw mm1, mm0						; V16 (s1)

movq 	mm7,  x5a825a825a825a82	; 23170 ->V18 (s3)
;***************************************************PackMulW
movq		mm6, mm1

punpcklwd	mm1,  const_zero
paddw mm2, mm0						; V17

pmaddwd		mm1, mm7
movq mm0, mm2						; duplicate V17

punpckhwd	mm6,  const_zero
movq mm4, mm3						; duplicate V0

pmaddwd		mm6, mm7
paddw mm3, mm5						; V19

psrad		mm1, 8
psubw mm4, mm5						; V20 ;mm5 free

psrad		mm6, 8				; mm6 = (s1)

packssdw	mm1, mm6
;**********************************************************
movq mm6, mm3						; duplicate t74=t81

psubw mm1, mm0						; V21 ; mm0 free
paddw mm3, mm2						; V22

movq mm5, mm1						; duplicate V21
paddw mm1, mm4						; V23

movq  [esi+8*4], mm3		; V22
psubw mm4, mm5						; V24; mm5 free

movq  [esi+8*12], mm1		; V23
psubw mm6, mm2						; V25; mm2 free

movq  [esi+8*0], mm4		; V24

; keep mm6 alive all along the next block
movq mm7,  [ebx+8*10]	; V10

pmullw mm7,  [edi+8*10]

movq mm0,  [ebx+8*6]	; V6

pmullw mm0,  [edi+8*6]
movq mm3, mm7						; duplicate V10

movq mm5,  [ebx+8*2]	; V2

pmullw mm5,  [edi+8*2]
psubw mm7, mm0						; V26 (s1/7)

movq mm4,  [ebx+8*14]	; V14

pmullw mm4,  [edi+8*14]
paddw mm3, mm0						; V29 ; free mm0

movq mm1,  x539f539f539f539f	;23170 ->V18 (scratch3)
 ;mm0 = s5, 
;***************************************************PackMulW
movq		 scratch7, mm7
movq		mm2, mm7

punpcklwd	mm7,  const_zero
movq		mm0, mm5				; duplicate V2

pmaddwd		mm7, mm1
paddw		mm5, mm4				; V27

punpckhwd	mm2,  const_zero
psubw 		mm0, mm4		;(s1) for next	; V28 ; free mm4

pmaddwd		mm2, mm1
movq		mm4, mm0

punpcklwd	mm0,  const_zero
psrad		mm7, 8

psrad		mm2, 8			; mm2 = scratch1
movq		mm1, mm4			; duplicate V28

punpckhwd	mm4,  const_zero
packssdw	mm7, mm2

movq		mm2,  x4546454645464546	; 23170 ->V18
;**********************************************************

;***************************************************PackMulW
pmaddwd		mm0, mm2

pmaddwd		mm4, mm2
psrad		mm0, 8

movq	mm2,  x61f861f861f861f8	; 23170 ->V18
psrad		mm4, 8

packssdw	mm0, mm4
movq		mm4, mm1

movq mm1,  scratch7
;**********************************************************

movq	 scratch5, mm0
paddw mm1, mm4						; V32 ; free mm4

;***************************************************PackMulW
movq		mm0, mm1

punpcklwd	mm1,  const_zero
movq		mm4, mm5						; duplicate t90=t93

pmaddwd		mm1, mm2
paddw		mm5, mm3						; V31

punpckhwd	mm0,  const_zero
psubw		mm4, mm3						; V30 ; free mm3

movq 	mm3,  x5a825a825a825a82	; 23170 ->V18
pmaddwd		mm0, mm2

psrad		mm1, 8
movq		mm2, mm4		; make a copy of mm4

punpcklwd	mm4,  const_zero
psrad		mm0, 8

pmaddwd		mm4, mm3
packssdw	mm1, mm0
;**********************************************************

;***************************************************PackMulW
punpckhwd	mm2,  const_zero

movq		mm0,  scratch5
pmaddwd		mm2, mm3

psubw		mm0, mm1						; V38
paddw		mm1, mm7						; V37 ; free mm7

movq		mm7,  [esi+8*4]		; V22
psrad		mm4, 8

psrad		mm2, 8
movq mm3, mm6                       ; duplicate V25

packssdw	mm4, mm2
psubw mm1, mm5						; V39 (mm5 still needed for next block)
;**********************************************************

movq mm2,  [esi+8*12]     ; V23
psubw mm4, mm1						; V40

paddw mm0, mm4						; V41; free mm0

psubw mm6, mm0						; tm6
paddw mm3, mm0						; tm8; free mm1

movq mm0, mm1		; line added by Kumar
movq mm1, mm7						; duplicate V22

movq  [esi+8*8], mm3     ; tm8; free mm3
paddw mm7, mm5						; tm0

movq  [esi+8*6], mm6		; tm6; free mm6
psubw mm1, mm5						; tm14; free mm5

movq mm6,  [esi+8*0]		; V24
movq mm3, mm2						; duplicate t117=t125

movq  [esi+8*0], mm7      ; tm0; free mm7
paddw mm2, mm0						; tm2

movq  [esi+8*14], mm1		; tm14; free mm1
psubw mm3, mm0						; tm12; free mm0

movq  [esi+8*2], mm2		; tm2; free mm2
movq mm0, mm6						; duplicate t119=t123

movq  [esi+8*12], mm3      ; tm12; free mm3
paddw mm6, mm4						; tm4

movq mm1,  [ebx+8*5]	; V5
psubw mm0, mm4						; tm10; free mm4

pmullw mm1,  [edi+8*5]
movq  [esi+8*4], mm6		; tm4; free mm6
movq  [esi+8*10], mm0     ; tm10; free mm0

; column 1: even part
; use V5, V13, V1, V9 to produce V56..V59

movq mm7,  [ebx+8*13]	; V13
movq mm2, mm1						; duplicate t128=t130

pmullw mm7,  [edi+8*13]
movq mm3,  [ebx+8*1]	; V1
pmullw mm3,  [edi+8*1]

movq mm5,  [ebx+8*9]	; V9
psubw mm1, mm7						; V50

pmullw mm5,  [edi+8*9]
paddw mm2, mm7						; V51

movq mm7,  x5a825a825a825a82	; 23170 ->V18
;***************************************************PackMulW
movq		mm4, mm1

punpcklwd	mm1,  const_zero
movq		mm6, mm2						; duplicate V51

pmaddwd		mm1, mm7

punpckhwd	mm4,  const_zero

movq mm0,  [ebx+8*11]	; V11
pmaddwd		mm4, mm7

pmullw mm0,  [edi+8*11]
psrad		mm1, 8

psrad		mm4, 8

packssdw	mm1, mm4
movq		mm4, mm3						; duplicate V1
;**********************************************************

paddw		mm3, mm5						; V53
psubw mm4, mm5						; V54 ;mm5 free

movq mm7, mm3						; duplicate V53
psubw mm1, mm6						; V55 ; mm6 free

movq mm6,  [ebx+8*7]	; V7
paddw mm3, mm2						; V56

movq mm5, mm4						; duplicate t140=t142
paddw mm4, mm1						; V57

movq  [esi+8*5], mm3		; V56
psubw mm5, mm1						; V58; mm1 free

pmullw mm6,  [edi+8*7]
psubw mm7, mm2						; V59; mm2 free

movq  [esi+8*13], mm4		; V57
movq mm3, mm0						; duplicate V11

; keep mm7 alive all along the next block
movq  [esi+8*9], mm5		; V58
paddw mm0, mm6						; V63

movq mm4,  [ebx+8*15]	; V15
psubw mm3, mm6						; V60 ; free mm6

pmullw mm4,  [edi+8*15]
; note that V15 computation has a correction step:
; this is a 'magic' constant that rebiases the results to be closer to the expected result
; this magic constant can be refined to reduce the error even more
; by doing the correction step in a later stage when the number is actually multiplied by 16
movq mm1, mm3						; duplicate V60

movq mm5,  [ebx+8*3]	; V3
movq		mm2, mm1

pmullw mm5,  [edi+8*3]

movq  scratch7, mm7
movq mm6, mm5						; duplicate V3

movq mm7,  x539f539f539f539f	; 23170 ->V18
paddw mm5, mm4						; V61

;***************************************************PackMulW
punpcklwd	mm1,  const_zero
psubw mm6, mm4						; V62 ; free mm4

pmaddwd		mm1, mm7
movq mm4, mm5						; duplicate V61

punpckhwd	mm2,  const_zero
paddw mm5, mm0						; V65 -> result

pmaddwd		mm2, mm7
psubw mm4, mm0						; V64 ; free mm0

movq  scratch3, mm3
psrad		mm1, 8

movq mm3,  x5a825a825a825a82	; 23170 ->V18
psrad		mm2, 8

packssdw	mm1, mm2
movq		mm2, mm4
;**********************************************************

;***************************************************PackMulW
punpcklwd	mm4,  const_zero

pmaddwd		mm4, mm3

punpckhwd	mm2,  const_zero

pmaddwd		mm2, mm3
psrad		mm4, 8

movq mm3,  scratch3

movq mm0,  x61f861f861f861f8	; 23170 ->V18
paddw		mm3, mm6						; V66

psrad		mm2, 8
movq		mm7, mm3

packssdw	mm4, mm2
movq mm2, mm5					; duplicate V65
;**********************************************************

;***************************************************PackMulW
punpcklwd	mm3,  const_zero

pmaddwd		mm3, mm0

punpckhwd	mm7,  const_zero

pmaddwd		mm7, mm0
movq		mm0, mm6

psrad		mm3, 8

punpcklwd	mm6,  const_zero

psrad		mm7, 8

packssdw	mm3, mm7
;**********************************************************

movq mm7,  x4546454645464546	; 23170 ->V18

;***************************************************PackMulW
punpckhwd	mm0,  const_zero
pmaddwd		mm6, mm7

pmaddwd		mm0, mm7
psrad		mm6, 8

psrad		mm0, 8

packssdw	mm6, mm0
;**********************************************************

movq mm0,  [esi+8*5]		; V56
psubw mm6, mm3						; V72

paddw mm3, mm1						; V71 ; free mm1

psubw mm3, mm2						; V73 ; free mm2
movq mm1, mm0						; duplicate t177=t188

psubw mm4, mm3						; V74
paddw mm0, mm5						; tm1

movq mm2,  [esi+8*13]     ; V57
paddw mm6, mm4						; V75

;location 
;  5 - V56
; 13 - V57
;  9 - V58
;  X - V59, mm7
;  X - V65, mm5
;  X - V73, mm6
;  X - V74, mm4
;  X - V75, mm3                              
; free mm0, mm1 & mm2                        

movq mm7,  scratch7      ; tm1; free mm0
psubw mm1, mm5						; tm15; free mm5

;save the store as used directly in the transpose
movq  [esi+8*1], mm0      ; tm1; free mm0
movq mm5, mm7                       ; duplicate t182=t184

movq mm0,  [esi+8*9]		; V58
psubw mm7, mm6						; tm7

paddw mm5, mm6						; tm9; free mm6
movq mm6, mm3

movq  [esi+8*7], mm7		; tm7; free mm7
movq mm3, mm2						; duplicate V57

psubw mm3, mm6						; tm13
paddw mm2, mm6						; tm3 ; free mm6

movq  [esi+8*3], mm2		; tm3; free mm2
movq mm6, mm0						; duplicate V58

paddw mm0, mm4						; tm5
psubw mm6, mm4						; tm11; free mm4

movq  [esi+8*5], mm0		; tm5; free mm0
movq		mm0, mm5			; copy w4---0,1,3,5,6


; transpose the bottom right quadrant(4X4) of the matrix
;  ---------       ---------
; | M1 | M2 |     | M1'| M3'|
;  ---------  -->  ---------
; | M3 | M4 |     | M2'| M4'|
;  ---------       ---------

punpcklwd	mm5, mm6			;

punpckhwd	mm0, mm6			;---0,1,3,5,6 
movq	mm6,  [esi+8*0]  ;get w0 of top left quadrant

movq		mm2, mm3			;---0,1,2,3,5,6
punpcklwd	mm3, mm1			;

movq	mm7,  [esi+8*2]  ;get w1 of top left quadrant
punpckhwd	mm2, mm1			;---0,2,3,5,6,7

movq		mm4, mm5			;---0,2,3,4,5,6,7
punpckldq	mm5, mm3			; transposed w4

movq	 [esi+8*9], mm5  ; store w4
punpckhdq	mm4, mm3			; transposed w5---0,2,4,6,7

movq		mm3, mm0			;---0,2,3,4,6,7
punpckldq	mm0, mm2			; transposed w6

movq	 [esi+8*11], mm4  ; store w5
punpckhdq	mm3, mm2			; transposed w7---0,3,6,7

movq	 [esi+8*13], mm0  ; store w6---3,5,6,7	
movq	mm5, mm6				; copy w0

movq	 [esi+8*15], mm3  ; store w7---5,6,7
punpcklwd	mm6, mm7

; transpose the top left quadrant(4X4) of the matrix

punpckhwd	mm5, mm7			;---5,6,7
movq	mm7,  [esi+8*4]  ; get w2 of TL quadrant

movq	mm4,  [esi+8*6]  ; get w3 of TL quadrant
movq	mm3, mm7				; copy w2---3,4,5,6,7

movq		mm2, mm6
punpcklwd	mm7, mm4			;---2,3,4,5,6,7

punpckhwd	mm3, mm4			;---2,3,4,5,6,7
movq		mm4, mm5			;	

movq		mm1, mm5
punpckldq	mm6, mm7			;---1,2,3,4,5,6,7

movq	 [esi+8*0], mm6	; store w0 of TL quadrant
punpckhdq	mm2, mm7			;---1,2,3,4,5,6,7

movq	 [esi+8*2], mm2	; store w1 of TL quadrant
punpckldq	mm5, mm3			;---1,2,3,4,5,6,7

movq	 [esi+8*4], mm5	; store w2 of TL quadrant
punpckhdq	mm1, mm3			;---1,2,3,4,5,6,7

movq	 [esi+8*6], mm1	; store w3 of TL quadrant


; transpose the top right quadrant(4X4) of the matrix

movq	mm0,  [esi+8*1]	;---0

movq	mm1,  [esi+8*3]	;---0,1,2
movq	mm2, mm0

movq	mm3,  [esi+8*5]
punpcklwd	mm0, mm1				;---0,1,2,3

punpckhwd	mm2, mm1
movq	mm1,  [esi+8*7]	;---0,1,2,3

movq	mm4, mm3
punpcklwd	mm3, mm1				;---0,1,2,3,4

punpckhwd	mm4, mm1				;---0,1,2,3,4
movq	mm1, mm0

movq	mm5, mm2
punpckldq	mm0, mm3				;---0,1,2,3,4,5

punpckhdq	mm1, mm3				;---0,1,2,3,4,5
movq		mm3,  [esi+8*8]

movq		 [esi+8*8], mm0
punpckldq	mm2, mm4				;---1,2,3,4,5

punpckhdq	mm5, mm4				;---1,2,3,4,5
movq		mm4,  [esi+8*10]

; transpose the bottom left quadrant(4X4) of the matrix
; Also store w1,w2,w3 of top right quadrant into
; w5,w6,w7 of bottom left quadrant. Storing w0 of TR in w4
; of BL is already done.

movq	 [esi+8*10], mm1
movq	mm1, mm3					;---1,2,3,4,5

movq	mm0,  [esi+8*12]
punpcklwd	mm3, mm4				;---0,1,2,3,4,5

punpckhwd	mm1, mm4				;---0,1,2,3,4,5
movq	mm4,  [esi+8*14]

movq	 [esi+8*12], mm2
movq	mm2, mm0

movq	 [esi+8*14], mm5
punpcklwd	mm0, mm4				;---0,1,2,3,4

punpckhwd	mm2, mm4				;---0,1,2,3,4
movq	mm4, mm3

movq	mm5, mm1
punpckldq	mm3, mm0				;---0,1,2,3,4,5

movq	 [esi+8*1], mm3
punpckhdq	mm4, mm0				;---1,2,4,5

movq	 [esi+8*3], mm4
punpckldq	mm1, mm2				;---1,2,5

movq	 [esi+8*5], mm1
punpckhdq	mm5, mm2				;---5

movq	 [esi+8*7], mm5

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;   1D DCT of the rows    ;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


mov	esi, wsptr  ; source

; column 0: even part
; use V4, V12, V0, V8 to produce V22..V25
movq mm0,  [esi+8*12]	; V12

movq mm1,  [esi+8*4]	; V4

movq mm3,  [esi+8*0]	; V0
movq mm2, mm1						; duplicate V4

movq mm5,  [esi+8*8]	; V8
psubw mm1, mm0						; V16

movq mm6,  x5a825a825a825a82	; 23170 ->V18
;***************************************************PackMulW
movq		mm4, mm1

punpcklwd	mm1,  const_zero
paddw mm2, mm0						; V17

pmaddwd		mm1, mm6
movq mm0, mm2						; duplicate V17

punpckhwd	mm4,  const_zero

pmaddwd		mm4, mm6
psrad		mm1, 8

psrad		mm4, 8

packssdw	mm1, mm4
movq		mm4, mm3						; duplicate V0
;**********************************************************

paddw mm3, mm5						; V19
psubw mm4, mm5						; V20 ;mm5 free

movq mm6, mm3						; duplicate t74=t81
psubw mm1, mm0						; V21 ; mm0 free

paddw mm3, mm2						; V22
movq mm5, mm1						; duplicate V21

paddw mm1, mm4						; V23

movq  [esi+8*4], mm3		; V22
psubw mm4, mm5						; V24; mm5 free

movq  [esi+8*12], mm1		; V23
psubw mm6, mm2						; V25; mm2 free

movq  [esi+8*0], mm4		; V24
; keep mm6 alive all along the next block
; column 0: odd part
; use V2, V6, V10, V14 to produce V31, V39, V40, V41
movq mm7,  [esi+8*10]	; V10

movq mm0,  [esi+8*6]	; V6
movq mm3, mm7						; duplicate V10

movq mm5,  [esi+8*2]	; V2
psubw mm7, mm0						; V26

movq mm4,  [esi+8*14]	; V14
paddw mm3, mm0						; V29 ; free mm0

movq mm2,  x539f539f539f539f	; 23170 ->V18
movq mm1, mm7						; duplicate V26

;***************************************************PackMulW
movq		 scratch5, mm6	; store mm6
movq		mm0, mm7

punpcklwd	mm7,  const_zero

pmaddwd		mm7, mm2

punpckhwd	mm0,  const_zero

pmaddwd		mm0, mm2
psrad		mm7, 8

movq mm6,  x4546454645464546	; 23170 ->V18
psrad		mm0, 8

packssdw	mm7, mm0
movq		mm0, mm5				; duplicate V2
;**********************************************************

paddw mm5, mm4						; V27
psubw mm0, mm4						; V28 ; free mm4

movq mm2, mm0						; duplicate V28
;***************************************************PackMulW
movq		mm4, mm0

punpcklwd	mm0,  const_zero

pmaddwd		mm0, mm6

punpckhwd	mm4,  const_zero

pmaddwd		mm4, mm6
paddw mm1, mm2						; V32 ; free mm2

movq mm2,  x61f861f861f861f8	; 23170 ->V18
psrad		mm0, 8

psrad		mm4, 8
movq		mm6, mm1

packssdw	mm0, mm4
movq		mm4, mm5			; duplicate t90=t93
;**********************************************************

;***************************************************PackMulW
punpcklwd	mm1,  const_zero
paddw		mm5, mm3				; V31

pmaddwd		mm1, mm2
psubw		mm4, mm3				; V30 ; free mm3

punpckhwd	mm6,  const_zero

pmaddwd		mm6, mm2
psrad		mm1, 8

psrad		mm6, 8

packssdw	mm1, mm6
;**********************************************************

psubw mm0, mm1						; V38
paddw mm1, mm7						; V37 ; free mm7

movq		mm7,  x5a825a825a825a82	; 23170 ->V18
;***************************************************PackMulW
movq		mm3, mm4

punpcklwd	mm4,  const_zero
psubw		mm1, mm5				; V39 (mm5 still needed for next block)

pmaddwd		mm4, mm7

punpckhwd	mm3,  const_zero

movq		mm6,  scratch5
pmaddwd		mm3, mm7

movq mm2,  [esi+8*12]     ; V23
psrad		mm4, 8

movq mm7,  [esi+8*4]		; V22
psrad		mm3, 8

packssdw	mm4, mm3
movq		mm3, mm6                       ; duplicate V25
;**********************************************************						  

psubw mm4, mm1						; V40

paddw mm0, mm4						; V41; free mm0

; column 0: output butterfly

psubw mm6, mm0						; tm6
paddw mm3, mm0						; tm8; free mm1

movq mm0, mm1		; line added by Kumar
movq mm1, mm7						; duplicate V22

movq  [esi+8*8], mm3     ; tm8; free mm3
paddw mm7, mm5						; tm0

movq  [esi+8*6], mm6		; tm6; free mm6
psubw mm1, mm5						; tm14; free mm5

movq mm6,  [esi+8*0]		; V24
movq mm3, mm2						; duplicate t117=t125

movq  [esi+8*0], mm7      ; tm0; free mm7
paddw mm2, mm0						; tm2

movq  [esi+8*14], mm1		; tm14; free mm1
psubw mm3, mm0						; tm12; free mm0

movq  [esi+8*2], mm2		; tm2; free mm2
movq mm0, mm6						; duplicate t119=t123

movq  [esi+8*12], mm3      ; tm12; free mm3
paddw mm6, mm4						; tm4

movq mm1,  [esi+8*5]	; V5
psubw mm0, mm4						; tm10; free mm4

movq  [esi+8*4], mm6		; tm4; free mm6

movq  [esi+8*10], mm0     ; tm10; free mm0

; column 1: even part
; use V5, V13, V1, V9 to produce V56..V59

movq mm7,  [esi+8*13]	; V13
movq mm2, mm1						; duplicate t128=t130

movq mm3,  [esi+8*1]	; V1
psubw mm1, mm7						; V50

movq mm5,  [esi+8*9]	; V9
paddw mm2, mm7						; V51

movq mm4,  x5a825a825a825a82	; 23170 ->V18
;***************************************************PackMulW
movq		mm6, mm1

punpcklwd	mm1,  const_zero

pmaddwd		mm1, mm4

punpckhwd	mm6,  const_zero

pmaddwd		mm6, mm4
movq		mm4, mm3				; duplicate V1

paddw mm3, mm5						; V53
psrad		mm1, 8

psubw mm4, mm5						; V54 ;mm5 free
movq mm7, mm3						; duplicate V53

psrad		mm6, 8

packssdw	mm1, mm6
movq		mm6, mm2				; duplicate V51

;**********************************************************
psubw mm1, mm6						; V55 ; mm6 free
paddw mm3, mm2						; V56

movq mm5, mm4						; duplicate t140=t142
paddw mm4, mm1						; V57

movq  [esi+8*5], mm3		; V56
psubw mm5, mm1						; V58; mm1 free

movq  [esi+8*13], mm4		; V57
psubw mm7, mm2						; V59; mm2 free

movq  [esi+8*9], mm5		; V58

; keep mm7 alive all along the next block

movq mm0,  [esi+8*11]	; V11

movq mm6,  [esi+8*7]	; V7

movq mm4,  [esi+8*15]	; V15
movq mm3, mm0						; duplicate V11

movq mm5,  [esi+8*3]	; V3
paddw mm0, mm6						; V63

; note that V15 computation has a correction step:
; this is a 'magic' constant that rebiases the results to be closer to the expected result
; this magic constant can be refined to reduce the error even more
; by doing the correction step in a later stage when the number is actually multiplied by 16
movq	 scratch7, mm7
psubw mm3, mm6						; V60 ; free mm6

movq mm6,  x539f539f539f539f	; 23170 ->V18
movq mm1, mm3						; duplicate V60

;***************************************************PackMulW
movq		mm7, mm1

punpcklwd	mm1,  const_zero

pmaddwd		mm1, mm6

punpckhwd	mm7,  const_zero

pmaddwd		mm7, mm6
movq mm6, mm5						; duplicate V3

paddw mm5, mm4						; V61
psrad		mm1, 8

psubw mm6, mm4						; V62 ; free mm4
movq mm4, mm5						; duplicate V61

psrad		mm7, 8
paddw mm5, mm0						; V65 -> result

packssdw	mm1, mm7
psubw mm4, mm0						; V64 ; free mm0
;**********************************************************

movq mm7,  x5a825a825a825a82	; 23170 ->V18
;***************************************************PackMulW
movq		mm2, mm4

punpcklwd	mm4,  const_zero
paddw		mm3, mm6			; V66

pmaddwd		mm4, mm7

punpckhwd	mm2,  const_zero

pmaddwd		mm2, mm7

movq mm7,  x61f861f861f861f8	; 23170 ->V18
psrad		mm4, 8

psrad		mm2, 8

packssdw	mm4, mm2
;**********************************************************
;***************************************************PackMulW
movq		mm2, mm3

punpcklwd	mm3,  const_zero

pmaddwd		mm3, mm7

punpckhwd	mm2,  const_zero

pmaddwd		mm2, mm7

movq mm7,  x4546454645464546	; 23170 ->V18
psrad		mm3, 8

psrad		mm2, 8

packssdw	mm3, mm2
;**********************************************************
;***************************************************PackMulW
movq		mm2, mm6

punpcklwd	mm6,  const_zero

pmaddwd		mm6, mm7

punpckhwd	mm2,  const_zero

pmaddwd		mm2, mm7

movq mm0,  [esi+8*5]		; V56
psrad		mm6, 8

movq	mm7,  scratch7
psrad		mm2, 8

packssdw	mm6, mm2
movq		mm2, mm5			; duplicate V65
;**********************************************************

psubw mm6, mm3						; V72
paddw mm3, mm1						; V71 ; free mm1

psubw mm3, mm2						; V73 ; free mm2
movq mm1, mm0						; duplicate t177=t188

psubw mm4, mm3						; V74
paddw mm0, mm5						; tm1

movq mm2,  [esi+8*13]     ; V57
paddw mm6, mm4						; V75


;location 
;  5 - V56
; 13 - V57
;  9 - V58
;  X - V59, mm7
;  X - V65, mm5
;  X - V73, mm6
;  X - V74, mm4
;  X - V75, mm3                              
; free mm0, mm1 & mm2                        

movq  [esi+8*1], mm0      ; tm1; free mm0
psubw mm1, mm5						; tm15; free mm5

;save the store as used directly in the transpose
movq mm5, mm7                       ; duplicate t182=t184
psubw mm7, mm6						; tm7

paddw mm5, mm6						; tm9; free mm3
movq mm6, mm3

movq mm0,  [esi+8*9]		; V58
movq mm3, mm2						; duplicate V57

movq  [esi+8*7], mm7		; tm7; free mm7
psubw mm3, mm6						; tm13

paddw mm2, mm6						; tm3 ; free mm6
movq mm6, mm0						; duplicate V58

movq  [esi+8*3], mm2		; tm3; free mm2
paddw mm0, mm4						; tm5

psubw mm6, mm4						; tm11; free mm4

movq  [esi+8*5], mm0		; tm5; free mm0


; Final results to be stored after the transpose
; transpose the bottom right quadrant(4X4) of the matrix
;  ---------       ---------
; | M1 | M2 |     | M1'| M3'|
;  ---------  -->  ---------
; | M3 | M4 |     | M2'| M4'|
;  ---------       ---------
;
; get the pointer to array "range"
mov		edi, range_limit

; calculate the destination address
mov		edx,  output_buf		; get output_buf[4]

mov		ebx, [edx+16]
add		ebx,  output_col			; add to output_col	

movq		mm0, mm5			; copy w4---0,1,3,5,6
punpcklwd	mm5, mm6			;

punpckhwd	mm0, mm6			;---0,1,3,5,6
movq		mm2, mm3			;---0,1,2,3,5,6
 
movq	mm6,  [esi+8*0]  ;get w0 of top left quadrant
punpcklwd	mm3, mm1			;

movq	mm7,  [esi+8*2]  ;get w1 of top left quadrant
punpckhwd	mm2, mm1			;---0,2,3,5,6,7

movq		mm4, mm5			;---0,2,3,4,5,6,7
punpckldq	mm5, mm3			; transposed w4

psrlw	mm5, 5
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al

mov		ebx, [edx+20]
add		ebx,  output_col			; add to output_col	

punpckhdq	mm4, mm3			; transposed w5---0,2,4,6,7

movq		mm3, mm0			;---0,2,3,4,6,7
punpckldq	mm0, mm2			; transposed w6

psrlw	mm4, 5
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al

mov		ecx, [edx+24]			
add		ecx,  output_col			; add to output_col	

punpckhdq	mm3, mm2			; transposed w7---0,3,6,7

psrlw	mm0, 5

movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+4], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+5], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+6], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+7], al

mov		ebx, [edx+28]		
add		ebx,  output_col			; add to output_col	

movq	mm5, mm6				; copy w0

psrlw	mm3, 5
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al


punpcklwd	mm6, mm7

; transpose the top left quadrant(4X4) of the matrix

; calculate the destination address
mov		edx, output_buf		; get output_buf[0]

mov		ebx, [edx+0]
add		ebx, output_col			; add to output_col	


movq	mm4,  [esi+8*6]  ; get w3 of TL quadrant
punpckhwd	mm5, mm7			;---5,6,7

movq	mm7,  [esi+8*4]  ; get w2 of TL quadrant
movq		mm2, mm6

movq	mm3, mm7				; copy w2---3,4,5,6,7
punpcklwd	mm7, mm4			;---2,3,4,5,6,7

punpckhwd	mm3, mm4			;---2,3,4,5,6,7
movq		mm4, mm5			;	

movq		mm1, mm5
punpckldq	mm6, mm7			;---1,2,3,4,5,6,7

psrlw	mm6, 5
movd    eax, mm6
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al

psrlq	mm6, 16
movd    eax, mm6
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm6, 16
movd    eax, mm6
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm6, 16
movd    eax, mm6
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al


mov		ebx, [edx+4]
add		ebx, output_col			; add to output_col	

punpckhdq	mm2, mm7			;---1,2,3,4,5,6,7

psrlw	mm2, 5
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al


mov		ecx, [edx+8]			
add		ecx, output_col			; add to output_col	

punpckldq	mm5, mm3			;---1,2,3,4,5,6,7

psrlw	mm5, 5
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+1], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+2], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+3], al


mov		ebx, [edx+12]		
add		ebx, output_col			; add to output_col	

punpckhdq	mm1, mm3			;---1,2,3,4,5,6,7

psrlw	mm1, 5
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al


; transpose the top right quadrant(4X4) of the matrix

; calculate the destination address for **bottom left quadrant
mov		edx, output_buf		; get output_buf[4]

mov		ebx, [edx+16]
add		ebx, output_col			; add to output_col	

movq	mm0,  [esi+8*1]	;---0

movq	mm1,  [esi+8*3]	;---0,1,2
movq	mm2, mm0

movq	mm3,  [esi+8*5]
punpcklwd	mm0, mm1				;---0,1,2,3

punpckhwd	mm2, mm1
movq	mm4, mm3

movq	mm1,  [esi+8*7]	;---0,1,2,3
movq	mm5, mm2

punpcklwd	mm3, mm1				;---0,1,2,3,4

punpckhwd	mm4, mm1				;---0,1,2,3,4
movq	mm1, mm0

punpckldq	mm0, mm3				;---0,1,2,3,4,5

punpckhdq	mm1, mm3				;---0,1,2,3,4,5

movq		mm3,  [esi+8*8]
psrlw	mm0, 5
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm0, 16
movd    eax, mm0
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al

mov		ebx, [edx+20]
add		ebx, output_col			; add to output_col	

punpckldq	mm2, mm4				;---1,2,3,4,5

punpckhdq	mm5, mm4				;---1,2,3,4,5
movq		mm4,  [esi+8*10]

; transpose the bottom left quadrant(4X4) of the matrix
; Also store w1,w2,w3 of top right quadrant into
; w5,w6,w7 of bottom left quadrant. Storing w0 of TR in w4
; of BL is already done.

psrlw	mm1, 5
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al

mov		ecx, [edx+24]			
add		ecx, output_col			; add to output_col	

movq	mm0,  [esi+8*12]
movq	mm1, mm3					;---1,2,3,4,5

punpcklwd	mm3, mm4				;---0,1,2,3,4,5

punpckhwd	mm1, mm4				;---0,1,2,3,4,5

movq	mm4,  [esi+8*14]
psrlw	mm2, 5
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+1], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+2], al

psrlq	mm2, 16
movd    eax, mm2
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+3], al

mov		ebx, [edx+28]		
add		ebx, output_col			; add to output_col	

movq	mm2, mm0

psrlw	mm5, 5
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx], al


psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+1], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+2], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+3], al


punpcklwd	mm0, mm4				;---0,1,2,3,4

punpckhwd	mm2, mm4				;---0,1,2,3,4
movq	mm4, mm3

movq	mm5, mm1
punpckldq	mm3, mm0				;---0,1,2,3,4,5

; calculate the destination address for **top right quadrant
mov		edx, output_buf		; get output_buf[0]

mov		ebx, [edx+0]
add		ebx, output_col			; add to output_col	

psrlw	mm3, 5
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm3, 16
movd    eax, mm3
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al

mov		ebx, [edx+4]
add		ebx, output_col			; add to output_col	

punpckhdq	mm4, mm0				;---1,2,4,5

psrlw	mm4, 5
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm4, 16
movd    eax, mm4
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al

mov		ecx, [edx+8]			
add		ecx, output_col			; add to output_col	

punpckldq	mm1, mm2				;---1,2,5

psrlw	mm1, 5
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+4], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+5], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+6], al

psrlq	mm1, 16
movd    eax, mm1
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ecx+7], al

mov		ebx, [edx+12]		
add		ebx, output_col			; add to output_col	

punpckhdq	mm5, mm2				;---5

psrlw	mm5, 5
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+4], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+5], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+6], al

psrlq	mm5, 16
movd    eax, mm5
and		eax, 03ffh
mov		al, byte ptr [edi][eax]
mov		byte ptr [ebx+7], al

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

emms


} /* end of __asm */
}


#endif /* X86 */

#endif /* DCT_IFAST_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\pifst.c ===
/***************************************************************************
*
*                INTEL Corporation Proprietary Information  
*
*      
*                  Copyright (c) 1996 Intel Corporation.
*                         All rights reserved.
*
***************************************************************************
*/
/*
 * jidctfst.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a fast, not so accurate integer implementation of the
 * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
 * must also perform dequantization of the input coefficients.
 *
 * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
 * on each row (or vice versa, but it's more convenient to emit a row at
 * a time).  Direct algorithms are also available, but they are much more
 * complex and seem not to be any faster when reduced to code.
 *
 * This implementation is based on Arai, Agui, and Nakajima's algorithm for
 * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
 * Japanese, but the algorithm is described in the Pennebaker & Mitchell
 * JPEG textbook (see REFERENCES section in file README).  The following code
 * is based directly on figure 4-8 in P&M.
 * While an 8-point DCT cannot be done in less than 11 multiplies, it is
 * possible to arrange the computation so that many of the multiplies are
 * simple scalings of the final outputs.  These multiplies can then be
 * folded into the multiplications or divisions by the JPEG quantization
 * table entries.  The AA&N method leaves only 5 multiplies and 29 adds
 * to be done in the DCT itself.
 * The primary disadvantage of this method is that with fixed-point math,
 * accuracy is lost due to imprecise representation of the scaled
 * quantization values.  The smaller the quantization table entry, the less
 * precise the scaled value, so this implementation does worse with high-
 * quality-setting files than with low-quality ones.
 */

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_IFAST_SUPPORTED

#ifndef USEINLINEASM

GLOBAL(void)
pidct8x8aan (JCOEFPTR coef_block, short * wsptr, short * quantptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{
}

#else


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif


/* Scaling decisions are generally the same as in the LL&M algorithm;
 * see jidctint.c for more details.  However, we choose to descale
 * (right shift) multiplication products as soon as they are formed,
 * rather than carrying additional fractional bits into subsequent additions.
 * This compromises accuracy slightly, but it lets us save a few shifts.
 * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
 * everywhere except in the multiplications proper; this saves a good deal
 * of work on 16-bit-int machines.
 *
 * The dequantized coefficients are not integers because the AA&N scaling
 * factors have been incorporated.  We represent them scaled up by PASS1_BITS,
 * so that the first and second IDCT rounds have the same input scaling.
 * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
 * avoid a descaling shift; this compromises accuracy rather drastically
 * for small quantization table entries, but it saves a lot of shifts.
 * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
 * so we use a much larger scaling factor to preserve accuracy.
 *
 * A final compromise is to represent the multiplicative constants to only
 * 8 fractional bits, rather than 13.  This saves some shifting work on some
 * machines, and may also reduce the cost of multiplication (since there
 * are fewer one-bits in the constants).
 */

#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  8
#define PASS1_BITS  2
#else
#define CONST_BITS  8
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
 * causing a lot of useless floating-point operations at run time.
 * To get around this we use the following pre-calculated constants.
 * If you change CONST_BITS you may want to add appropriate values.
 * (With a reasonable C compiler, you can just rely on the FIX() macro...)
 */ 

#if CONST_BITS == 8
#define FIX_1_082392200  ((INT32)  277)		/* FIX(1.082392200) */
#define FIX_1_414213562  ((INT32)  362)		/* FIX(1.414213562) */
#define FIX_1_847759065  ((INT32)  473)		/* FIX(1.847759065) */
#define FIX_2_613125930  ((INT32)  669)		/* FIX(2.613125930) */
#else
#define FIX_1_082392200  FIX(1.082392200)
#define FIX_1_414213562  FIX(1.414213562)
#define FIX_1_847759065  FIX(1.847759065)
#define FIX_2_613125930  FIX(2.613125930)
#endif


/* We can gain a little more speed, with a further compromise in accuracy,
 * by omitting the addition in a descaling shift.  This yields an incorrectly
 * rounded result half the time...
 */

#ifndef USE_ACCURATE_ROUNDING
#undef DESCALE
#define DESCALE(x,n)  RIGHT_SHIFT(x, n)
#endif

//#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
/* Multiply a DCTELEM variable by an INT32 constant, and immediately
 * descale to yield a DCTELEM result.
 */

//#define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))
#define MULTIPLY(var,const)  ((DCTELEM) ((var) * (const)))


/* Dequantize a coefficient by multiplying it by the multiplier-table
 * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
 * multiplication will do.  For 12-bit data, the multiplier table is
 * declared INT32, so a 32-bit multiply will be used.
 */

#if BITS_IN_JSAMPLE == 8
//#define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))
#define DEQUANTIZE(coef,quantval)  (((coef)) * (quantval))
#else
#define DEQUANTIZE(coef,quantval)  \
	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
#endif

 
/* Like DESCALE, but applies to a DCTELEM and produces an int.
 * We assume that int right shift is unsigned if INT32 right shift is.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define ISHIFT_TEMPS	DCTELEM ishift_temp;
#if BITS_IN_JSAMPLE == 8
#define DCTELEMBITS  16		/* DCTELEM may be 16 or 32 bits */
#else
#define DCTELEMBITS  32		/* DCTELEM must be 32 bits */
#endif
#define IRIGHT_SHIFT(x,shft)  \
    ((ishift_temp = (x)) < 0 ? \
     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
     (ishift_temp >> (shft)))
#else
#define ISHIFT_TEMPS
#define IRIGHT_SHIFT(x,shft)	((x) >> (shft))
#endif

#ifdef USE_ACCURATE_ROUNDING
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
#else
#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT(x, n))
#endif


static const long  x5a825a825a825a82	= 0x0000016a ;				
static const long  x539f539f539f539f 	= 0xfffffd63 ;
static const long  x4546454645464546	= 0x00000115 ;	
static const long  x61f861f861f861f8	= 0x000001d9 ;	


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
pidct8x8aan (JCOEFPTR coef_block, short * wsptr, short * quantptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{

  INT32	locdwinptr, locdwqptr, locdwwsptr, locwctr ;
  short locwcounter, locwtmp0, locwtmp1	;
  short locwtmp3, scratch1, scratch2, scratch3 ;


  
  // do the 2-Dal idct and store the corresponding results
  // from the range_limit array
//  pidct(coef_block, quantptr, wsptr, output_buf, output_col, range_limit) ;

__asm {


mov esi, coef_block   ; source coeff
mov edi, quantptr	  ; quant pointer

mov locdwinptr, esi
mov eax, wsptr	  ; temp storage pointer

mov locdwqptr, edi
mov locdwwsptr, eax

mov locwcounter, 8

;; perform the 1D-idct on each of the eight columns

idct_column:

mov esi, locdwinptr
mov edi, locdwqptr

mov ax, word ptr [esi+16*0]

mov bx, word ptr [esi+16*4]
imul ax, word ptr [edi+16*0]

mov cx, word ptr [esi+16*2]

imul bx, word ptr [edi+16*4]

mov dx, word ptr [esi+16*6]
imul cx, word ptr [edi+16*2]

imul dx, word ptr [edi+16*6]

;;;; at this point C0, C2, C4 and C6 have been dequantized

mov scratch1, ax
add ax, bx		; tmp10 in ax

sub scratch1, bx		; tmp11 
mov bx, cx

add cx, dx		; tmp13 in cx
sub bx, dx		; tmp1 - tmp3 in bx

mov dx, ax
movsx ebx, bx	; sign extend bx: get ready to do imul

add ax, cx		; tmp0 in ax
imul ebx, dword ptr x5a825a825a825a82

sub dx, cx		; tmp3 in dx
mov locwtmp0, ax 

mov locwtmp3, dx
sar ebx, 8		; bx now has (tmp1-tmp3)*1.414

mov ax, scratch1	; copy of tmp11
sub bx, cx		; tmp12 in bx

add ax, bx		; tmp1 in ax
sub scratch1, bx		; tmp2 

mov locwtmp1, ax

;;;;;completed computing/storing the even part;;;;;;;;;; 

mov ax, [esi+16*1]		; get C1

imul ax, [edi+16*1]
mov bx, [esi+16*7]		; get C7

mov cx, [esi+16*3]

imul bx, [edi+16*7]	

mov dx, [esi+16*5]

imul cx, [edi+16*3]

imul dx, [edi+16*5]

mov scratch2, ax
add ax, bx		; z11 in ax

sub scratch2, bx		; z12 
mov bx, dx		; copy of deQ C5

add dx, cx		; z13 in dx
sub bx, cx		; z10 in bx

mov cx, ax		; copy of z11
add ax, dx		; tmp7 in ax

sub cx, dx		; partial tmp11

movsx ecx, cx
mov dx, bx		; copy of z10

add bx, scratch2		; partial z5 
imul ecx, dword ptr x5a825a825a825a82

movsx edx, dx	; sign extend z10: get ready for imul
movsx ebx, bx	; sign extend partial z5 for imul

imul edx, dword ptr x539f539f539f539f	; partial tmp12
imul ebx, dword ptr x61f861f861f861f8	; partial z5 product

mov	di, scratch2
movsx edi, di	; sign extend z12: get ready for imul
sar ecx, 8		; tmp11 in cx

sar ebx, 8		; z5 in bx
imul edi, dword ptr x4546454645464546

sar edx, 8
sar edi, 8

sub di, bx		; tmp10 
add dx, bx		; tmp12 in dx

sub dx, ax		; tmp6 in dx

sub cx, dx		; tmp5 in cx

add di, cx		; tmp4 
mov	scratch3, di

;;; completed calculating the odd part ;;;;;;;;;;;

mov edi, dword ptr locdwwsptr	; get address of temp. destn

mov si, ax		; copy of tmp7
mov bx, locwtmp0	; get tmp0

add ax, locwtmp0	; wsptr[0]
sub bx, si		; wsptr[7]

mov word ptr [edi+16*0], ax
mov word ptr [edi+16*7], bx

mov ax, dx		; copy of tmp6
mov bx, locwtmp1

add dx, bx		; wsptr[1]
sub bx, ax		; wsptr[6]

mov word ptr [edi+16*1], dx
mov word ptr [edi+16*6], bx

mov dx, cx		; copy of tmp5
mov bx, scratch1


add cx, bx		; wsptr[2]
sub bx, dx		; wsptr[5]

mov word ptr [edi+16*2], cx
mov word ptr [edi+16*5], bx

mov cx, scratch3		; copy of tmp4
mov ax, locwtmp3

add scratch3, ax		; wsptr[4]
sub ax, cx		; wsptr[3]

mov	bx, scratch3
mov word ptr [edi+16*4], bx
mov word ptr [edi+16*3], ax

;;;;; completed storing 1D idct of one column ;;;;;;;;

;; update inptr, qptr and wsptr for next column

add locdwinptr, 2
add locdwqptr, 2

add locdwwsptr, 2
mov ax, locwcounter	; get loop count

dec ax		; another loop done

mov locwcounter, ax
jnz idct_column

;;;;;;; end of 1D idct on all columns  ;;;;;;;
;;;;;;; temp result is stored in wsptr  ;;;;;;;

;;;;;;; perform 1D-idct on each row and store final result

mov esi, wsptr	; initialize source ptr to original wsptr
mov locwctr, 0

mov locwcounter, 8
mov locdwwsptr, esi

idct_row:

mov edi, output_buf
mov esi, locdwwsptr

add edi, locwctr

mov	edi, [edi]		; get output_buf[ctr]

add edi, output_col	; now edi is pointing to the resp. row
add locwctr, 4

;; get even coeffs. and do the even part

mov ax, word ptr [esi+2*0]

mov bx, word ptr [esi+2*4]

mov cx, word ptr [esi+2*2]

mov dx, word ptr [esi+2*6]

mov scratch1, ax
add ax, bx		; tmp10 in ax

sub scratch1, bx		; tmp11 
mov bx, cx

add cx, dx		; tmp13 in cx
sub bx, dx		; tmp1 - tmp3 in bx

mov dx, ax
movsx ebx, bx	; sign extend bx: get ready to do imul

add ax, cx		; tmp0 in ax
imul ebx, dword ptr x5a825a825a825a82

sub dx, cx		; tmp3 in dx
mov locwtmp0, ax 

mov locwtmp3, dx
sar ebx, 8		; bx now has (tmp1-tmp3)*1.414

mov ax, scratch1	; copy of tmp11
sub bx, cx		; tmp12 in bx

add ax, bx		; tmp1 in ax
sub scratch1, bx		; tmp2 

mov locwtmp1, ax

;;;;;completed computing/storing the even part;;;;;;;;;; 

mov ax, [esi+2*1]		; get C1
mov bx, [esi+2*7]		; get C7

mov cx, [esi+2*3]
mov dx, [esi+2*5]

mov scratch2, ax
add ax, bx		; z11 in ax

sub scratch2, bx		; z12 
mov bx, dx		; copy of deQ C5

add dx, cx		; z13 in dx
sub bx, cx		; z10 in bx

mov cx, ax		; copy of z11
add ax, dx		; tmp7 in ax

sub cx, dx		; partial tmp11

movsx ecx, cx
mov dx, bx		; copy of z10

add bx, scratch2	; partial z5 
imul ecx, dword ptr x5a825a825a825a82

movsx edx, dx	; sign extend z10: get ready for imul
movsx ebx, bx	; sign extend partial z5 for imul

imul edx, dword ptr x539f539f539f539f	; partial tmp12
imul ebx, dword ptr x61f861f861f861f8	; partial z5 product

mov	si, scratch2
movsx esi, si	; sign extend z12: get ready for imul
sar ecx, 8		; tmp11 in cx

sar ebx, 8		; z5 in bx
imul esi, dword ptr x4546454645464546

sar edx, 8
sar esi, 8

sub si, bx		; tmp10 
add dx, bx		; tmp12 in dx

sub dx, ax		; tmp6 in dx

sub cx, dx		; tmp5 in cx

add si, cx		; tmp4 
mov	scratch3, si

;;; completed calculating the odd part ;;;;;;;;;;;

mov si, ax		; copy of tmp7
mov bx, locwtmp0	; get tmp0

add ax, locwtmp0	; wsptr[0]
sub bx, si		; wsptr[7]

mov esi, range_limit	; initialize esi to range_limit pointer

sar ax, 5
sar bx, 5

and eax, 3ffh
and ebx, 3ffh

mov al, byte ptr [esi][eax]
mov bl, byte ptr [esi][ebx]

mov byte ptr [edi+0], al
mov byte ptr [edi+7], bl

mov ax, dx		; copy of tmp6
mov bx, locwtmp1

add dx, bx		; wsptr[1]
sub bx, ax		; wsptr[6]

sar dx, 5
sar bx, 5

and edx, 3ffh
and ebx, 3ffh

mov dl, byte ptr [esi][edx]
mov bl, byte ptr [esi][ebx]

mov byte ptr [edi+1], dl
mov byte ptr [edi+6], bl

mov dx, cx		; copy of tmp5
mov bx, scratch1

add cx, bx		; wsptr[2]
sub bx, dx		; wsptr[5]

sar cx, 5
sar bx, 5

and ecx, 3ffh
and ebx, 3ffh

mov cl, byte ptr [esi][ecx]
mov bl, byte ptr [esi][ebx]

mov byte ptr [edi+2], cl
mov byte ptr [edi+5], bl

mov cx, scratch3		; copy of tmp4
mov ax, locwtmp3

add scratch3, ax		; wsptr[4]
sub ax, cx		; wsptr[3]

sar scratch3, 5
sar ax, 5

mov	cx, scratch3

and ecx, 3ffh
and eax, 3ffh


mov bl, byte ptr [esi][ecx]
mov al, byte ptr [esi][eax]

mov byte ptr [edi+4], bl
mov byte ptr [edi+3], al

;;;;; completed storing 1D idct of one row ;;;;;;;;

;; update the source pointer (wsptr) for next row

add locdwwsptr, 16

mov ax, locwcounter	; get loop count

dec ax		; another loop done

mov locwcounter, ax
jnz idct_row


;; end of 1D idct on all rows
;; final result is stored in outptr

}	/* end of __asm */
}

#endif /* X86 */

#endif /* DCT_IFAST_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\piint.c ===
/***************************************************************************
*
*                INTEL Corporation Proprietary Information  
*
*      
*                  Copyright (c) 1996 Intel Corporation.
*                         All rights reserved.
*
***************************************************************************
			AUTHOR:  Kumar Balasubramanian 
***************************************************************************

** Pentium version of the "integer LLM mode" within IJG decompressor code.
** The following is a non-MMX Pentium implementation of the integer slow mode
** IDCT within the IJG code.
*/

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_ISLOW_SUPPORTED

#ifndef USEINLINEASM

GLOBAL(void)
pidct8x8llm (JCOEFPTR inptr, short *quantptr, short *wsptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{
}

#else

/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif



#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Define the constants for the case BITS_IN_JSAMPLE = 8 */


static const INT32 const_0_2986	=	0x0000098E ;
static const INT32 const_0_3901	=	0x0fffff384;
static const INT32 const_0_54119	=	0x00001151;
static const INT32 const_0_7653	=	0x0000187E;
static const INT32 const_0_899	=	0x0ffffe333;
static const INT32 const_1_175	=	0x000025a1;
static const INT32 const_1_501	=	0x0000300b;
static const INT32 const_1_8477	=	0x0ffffc4df;
static const INT32 const_1_961	=	0x0ffffc13b;
static const INT32 const_2_053	=	0x000041b3;
static const INT32 const_2_562	=	0x0ffffadfd;
static const INT32 const_3_072	=	0x00006254;

static const INT32 const_round	=	0x00000400;
static const INT32 const_round_row	=	0x00020000;
static const INT32 const_mask		=	0x000003ff;


/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
pidct8x8llm (JCOEFPTR inptr, short *quantptr, short *wsptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{

INT32   locdwinptr, locdwqptr, locdwwsptr, locdwtmp0, locdwtmp1 ;
INT32   locdwtmp2, locdwtmp3, locdwtmp00, locdwtmp01, locdwtmp02 ;
INT32   locdwtmp03, locdwtmp10, locdwtmp11, locdwtmp12 ;
INT32   locdwtmp13, locdwcounter, locdwrowctr ;	



// Inline assembly to do the IDCT and store the result */

__asm {

mov		esi, inptr	; point to start of source
mov		edi, quantptr	;

mov		eax, wsptr
mov		locdwinptr, esi	; point to start of source

mov		locdwqptr, edi	;
mov		locdwwsptr, eax

mov	locdwcounter, 8
mov		eax, [esi]		; warm up the cache

mov		ebx, [esi+32]
mov		ecx, [esi+64]

mov		edx, [esi+96]
mov		eax, [edi]

mov		ebx, [edi+32]
mov		ecx, [edi+64]

mov		edx, [edi+96]

;; 1D-IDCT of all the eight columns
idct_column:

mov		esi, locdwinptr	; point to start of source
mov		edi, locdwqptr		;

;; do the even part

mov		ax, [esi+16*2]
mov		bx, [edi+16*2]

shl		eax, 16		; sign extend the i/p
mov		cx, [esi+16*6]

sar		eax, 16
mov		dx, [edi+16*6]

shl		ebx, 16		; sign extend the quant factor

sar		ebx, 16

imul	eax, ebx	; dequantized C2 = z2

shl		ecx, 16

sar		ecx, 16

shl		edx, 16

sar		edx, 16

imul	ecx, edx	; dequantized C6 = z3

mov		ebx, eax	; copy of z2

imul	eax, const_0_7653

add		ebx, ecx	; z2 + z3

imul	ecx, const_1_8477

imul	ebx, const_0_54119	; z1

mov		dx, [edi+16*4]	; quant factor for C4
add		ecx, ebx	; tmp2

add		eax, ebx	; tmp3
mov		locdwtmp2, ecx

mov		locdwtmp3, eax

mov		cx, [esi+16*4]	; C4
mov		ax, [esi+16*0]	; C0

mov		bx, [edi+16*0]	; quant factor for C0

movsx	edx, dx

movsx	ecx, cx

movsx	eax, ax

movsx	ebx, bx

imul	ecx, edx	; dequantize C4 = z3

imul	eax, ebx	; dequantize C0 = z2

mov		edx, ecx	; copy of z3
add		ecx, eax	; z2 + z3

shl		ecx, 13		; tmp0
sub		eax, edx	; z2 - z3

shl		eax, 13		; tmp1
mov		ebx, ecx	; copy of tmp0

add		ecx, locdwtmp3	; tmp10
mov		edx, eax	; copy of tmp1

add		eax, locdwtmp2	; tmp11
mov		locdwtmp00, ecx

sub		ebx, locdwtmp3	; tmp13
mov		locdwtmp01, eax

sub		edx, locdwtmp2	; tmp12
mov		locdwtmp03, ebx

mov		ax, [esi+16*7]	; C7 for the odd part
mov		locdwtmp02, edx

mov		bx, [edi+16*7]	; quant factor for C7

;; now do the odd part

shl		eax, 16
mov		cx, [esi+16*3]

sar		eax, 16
mov		dx, [edi+16*3]

shl		ebx, 16

sar		ebx, 16

imul	eax, ebx		; dequantized C7 = tmp0

shl		ecx, 16

sar		ecx, 16

shl		edx, 16

sar		edx, 16
mov		bx, [esi+16*1]

imul	ecx, edx		; dequantized C3 = tmp2

shl		ebx, 16
mov		dx, [edi+16*1]

sar		ebx, 16

shl		edx, 16

sar		edx, 16

imul	ebx, edx		; dequantized C1 = tmp3

mov		locdwtmp0, eax
mov		locdwtmp2, ecx

mov		ax, [esi+16*5]
mov		dx, [edi+16*5]

shl		eax, 16

sar		eax, 16

shl		edx, 16

sar		edx, 16

imul	eax, edx	; dequantized C5 = tmp1

imul	ecx, const_3_072	; tmp2

mov		locdwtmp3, ebx
mov		edx, locdwtmp0

imul	ebx, const_1_501	; tmp3

imul	edx, const_0_2986	; tmp0

mov		locdwtmp1, eax	; store tmp1
mov		locdwtmp10, edx

imul	eax, const_2_053	; tmp1

mov		locdwtmp11, eax
mov		locdwtmp12, ecx

mov		locdwtmp13, ebx
mov		eax, locdwtmp0

mov		ebx, locdwtmp1
mov		ecx, eax

mov		edx, ebx
add		eax, locdwtmp3	; z1

add		ebx, locdwtmp3	; z4
add		ecx, locdwtmp2	; z3

add		edx, locdwtmp2	; z2
mov		esi, ecx	; copy of z3

imul	eax,  const_0_899	; z1

imul	edx,  const_2_562	; z2

add		esi, ebx	; z3 + z4

imul	esi,  const_1_175	; z5

imul	ecx,  const_1_961	; z3

imul	ebx,  const_0_3901	; z4

add		ecx, esi	; z3
add		ebx, esi	; z4

mov		esi, eax	; copy of z1
add		eax, ecx	; z1 + z3

add		esi, ebx	; z1 + z4
add		ecx, edx	; z3 + z2

add		edx, ebx	; z2 + z4
add		eax, locdwtmp10		; tmp0

add		edx, locdwtmp11		; tmp1
add		ecx, locdwtmp12		; tmp2

add		esi, locdwtmp13		; tmp3
mov		ebx, locdwtmp03

sub		ebx, eax			; w4
add		eax, locdwtmp03		; w3

add		ebx,  const_round
mov		edi, locdwwsptr		; keep in mind that wsptr stores 32 bit values

sar		ebx, 11				; So store/update the pointer accordingly
add		eax,  const_round

sar		eax, 11
mov		[edi+32*4], ebx

mov		[edi+32*3], eax
mov		ebx, locdwtmp02

mov		eax, locdwtmp01
sub		ebx, edx			; w5

add		edx, locdwtmp02		; w2
sub		eax, ecx			; w6

add		ecx, locdwtmp01		; w1
add		ebx,  const_round

sar		ebx, 11
add		eax,  const_round

sar		eax, 11
add		edx,  const_round

add		ecx,  const_round
mov		[edi+32*5], ebx

sar		edx, 11
mov		[edi+32*6], eax

sar		ecx, 11
mov		[edi+32*2], edx

mov		eax, locdwtmp00
mov		[edi+32*1], ecx

mov		ebx, eax
sub		eax, esi			; w7

add		ebx, esi			; w0
add		eax, const_round

sar		eax, 11
add		ebx, const_round

sar		ebx, 11
mov		[edi+32*7], eax

mov		[edi+32*0], ebx
mov		eax, locdwcounter

add		locdwinptr, 2
add		locdwwsptr, 4		; wsptr stores 32 bit quantities

add		locdwqptr, 2
dec		eax

mov		locdwcounter, eax
jnz		idct_column

;; End of 1D-idct of all the columns

;; get ready for the 1D-idct of the rows

mov		esi, wsptr
mov		locdwcounter, 8

mov		locdwrowctr, 0
mov		locdwwsptr, esi


;; 1D-IDCT of all the eight rows
idct_row:

mov		esi, locdwwsptr	; point to start of source
mov		edi, output_buf	

add		edi, locdwrowctr
mov		edi, [edi]

add		locdwrowctr, 4
add		edi, output_col	; this is the dest start addr for this row


;; do the even part

mov		eax, [esi+4*2]
mov		ecx, [esi+4*6]

mov		ebx, eax	; copy of z2
mov		edx, [edi]	; warm up the cache for writing this output row

imul	eax, const_0_7653

add		ebx, ecx	; z2 + z3

imul	ecx,  const_1_8477

imul	ebx,  const_0_54119	; z1

add		ecx, ebx	; tmp2
add		eax, ebx	; tmp3

mov		locdwtmp2, ecx
mov		locdwtmp3, eax

mov		ecx, [esi+4*4]	; C4
mov		eax, [esi+4*0]	; C0

mov		edx, ecx	; copy of z3

add		ecx, eax	; z2 + z3
sub		eax, edx	; z2 - z3

shl		ecx, 13		; tmp0

shl		eax, 13		; tmp1
mov		ebx, ecx	; copy of tmp0

add		ecx, locdwtmp3	; tmp10
mov		edx, eax	; copy of tmp1

add		eax, locdwtmp2	; tmp11
mov		locdwtmp00, ecx

sub		ebx, locdwtmp3	; tmp13
mov		locdwtmp01, eax

sub		edx, locdwtmp2	; tmp12
mov		locdwtmp03, ebx

mov		eax, [esi+4*7]	; C7 for the odd part
mov		locdwtmp02, edx

;; now do the odd part

mov		ecx, [esi+4*3]
mov		ebx, [esi+4*1]

mov		locdwtmp0, eax
mov		locdwtmp2, ecx

mov		eax, [esi+4*5]
mov		locdwtmp3, ebx

imul	ecx,  const_3_072	; tmp2

mov		edx, locdwtmp0

imul	ebx,  const_1_501	; tmp3

imul	edx,  const_0_2986	; tmp0

mov		locdwtmp1, eax	; store tmp1

imul	eax, const_2_053	; tmp1

mov		locdwtmp10, edx
mov		locdwtmp11, eax

mov		locdwtmp12, ecx
mov		locdwtmp13, ebx

mov		eax, locdwtmp0
mov		ebx, locdwtmp1

mov		ecx, eax
mov		edx, ebx

add		eax, locdwtmp3	; z1
add		edx, locdwtmp2	; z2

add		ebx, locdwtmp3	; z4
add		ecx, locdwtmp2	; z3

mov		esi, ecx	; copy of z3

imul	eax,  const_0_899	; z1

imul	edx, const_2_562	; z2

add		esi, ebx	; z3 + z4

imul	esi, const_1_175	; z5

imul	ecx, const_1_961	; z3

imul	ebx,  const_0_3901	; z4

add		ecx, esi	; z3
add		ebx, esi	; z4

mov		esi, eax	; copy of z1
add		eax, ecx	; z1 + z3

add		esi, ebx	; z1 + z4
add		ecx, edx	; z3 + z2

add		edx, ebx	; z2 + z4
add		eax, locdwtmp10		; tmp0

add		edx, locdwtmp11		; tmp1
add		ecx, locdwtmp12		; tmp2

add		esi, locdwtmp13		; tmp3
mov		locdwtmp0, eax

mov		locdwtmp1, edx
mov		locdwtmp2, ecx

mov		locdwtmp3, esi
mov		ebx, locdwtmp03

add		ebx, locdwtmp0	; out3
mov		ecx, locdwtmp00

sub		ecx, locdwtmp3	; out7
add		ebx,  const_round_row

sar		ebx, 18
add		ecx,  const_round_row

sar		ecx, 18
mov		esi, range_limit

and		ebx,  const_mask
and		ecx, const_mask

mov		al, [esi][ebx]
mov		dl, [esi][ecx]

mov		ebx, locdwtmp02
mov		ecx, locdwtmp01

add		ebx, locdwtmp1	; out2
sub		ecx, locdwtmp2	; out6

shl		eax, 8		; get ready to receive next output byte
add		ebx,  const_round_row

shl		edx, 8		; get ready to receive next output byte
add		ecx, const_round_row

sar		ebx, 18

sar		ecx, 18
and		ebx,  const_mask

and		ecx,  const_mask
mov		al, [esi][ebx]

mov		dl, [esi][ecx]
mov		ebx, locdwtmp01

mov		ecx, locdwtmp02
add		ebx, locdwtmp2	; out1

shl		eax, 8		; get ready to receive next output byte
sub		ecx, locdwtmp1	; out5

shl		edx, 8		; get ready to receive next output byte
add		ebx,  const_round_row

sar		ebx, 18
add		ecx,  const_round_row

sar		ecx, 18
and		ebx,  const_mask

and		ecx,  const_mask
mov		al, [esi][ebx]	; out1

mov		dl, [esi][ecx]	; out5
mov		ebx, locdwtmp00

mov		ecx, locdwtmp03
add		ebx, locdwtmp3	; out0

shl		eax, 8		; get ready to receive next output byte
sub		ecx, locdwtmp0	; out4

shl		edx, 8		; get ready to receive next output byte
add		ebx,  const_round_row

sar		ebx, 18
add		ecx,  const_round_row

sar		ecx, 18
and		ebx,  const_mask

and		ecx,  const_mask
mov		al, [esi][ebx]	; out0

mov		dl, [esi][ecx]	; out4
mov		[edi], eax		; store the first four bytes

mov		[edi+4], edx	; store the next four bytes of this row
mov		eax, locdwcounter

add		locdwwsptr, 32		; wsptr stores 32 bit quantities
dec		eax

mov		locdwcounter, eax
jnz		idct_row

} //end of __asm

}


#endif /* X86 */

#endif /* DCT_ISLOW_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\encode\unicode.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       unicode.cxx
//
//  Contents:   Support for Unicode character set encoding
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

static const TCHAR s_chUnknown = _T('?');

//+-----------------------------------------------------------------------
//
//  Member:     WideCharFromUcs2
//
//  Synopsis:   Convert from UCS-2 to Unicode
//
//------------------------------------------------------------------------

HRESULT
CEncodeReader::WideCharFromUcs2( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    size_t cb = (_cbBuffer - (_pbBufferPtr - _pbBuffer)) & ~1;
    int cch = cb / sizeof(WCHAR);
    TCHAR * p;

    hr = THR( MakeRoomForChars( cch ) );
    if (hr)
        goto Cleanup;

    memcpy( _pchEnd, _pbBufferPtr, cb );

    // Replace private use area characters
    
    p = _pchEnd + cch;
    while (p-- > _pchEnd)
    {
        if (!IsValidWideChar(*p))
            *p = s_chUnknown;
    }

    *pcch = cch;
    _pbBufferPtr += cb;

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     UnicodeFromWideChar
//
//  Synopsis:   Convert from Unicode to UCS-2
//
//------------------------------------------------------------------------

HRESULT
CEncodeWriter::UnicodeFromWideChar( BOOL fReadEof, int * pcb )
{
    HRESULT hr;
    int     cb = _cchBuffer * sizeof(TCHAR);

    hr = THR(MakeRoomForChars(cb));
    if( hr )
        goto Cleanup;

    memcpy( _pbBuffer + _cbBuffer, _pchBuffer, cb );

    *pcb = cb;
    _cbBuffer += cb;

Cleanup:
    RRETURN( hr );
}

#ifndef WINCE
//+-----------------------------------------------------------------------
//
//  Member:     WideCharFromUtf8
//
//  Synopsis:   Convert from UTF-8 to Unicode
//
//------------------------------------------------------------------------

// Unicode value                                UTF-8 value
//
// 0000 0000 0xxx xxxx                          0xxx xxxx
// 0000 0yyy yyxx xxxx                          110y yyyy 10xx xxxx   
// zzzz yyyy yyxx xxxx                          1110 zzzz 10yy yyyy 10xx xxxx
// 1101 10ww wwzz zzyy + 1101 11yy yyxx xxxx    1111 0uuu 10uu zzzz 10yy yyyy 10xx xxxxx (uuuuu = wwww + 1)

static int aiByteCountForLeadNibble[16] =
{
    1,  // 0000
    1,  // 0001
    1,  // 0010
    1,  // 0011
    1,  // 0100
    1,  // 0101
    1,  // 0110
    1,  // 0111
    1,  // 1000
    1,  // 1001
    1,  // 1010
    1,  // 1011
    2,  // 1100
    2,  // 1101
    3,  // 1110
    4   // 1111
};

HRESULT
CEncodeReader::WideCharFromUtf8( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    unsigned char * pb;
    unsigned char * pbStop;
    WCHAR * pchDst;
    int cch;
    WHEN_DBG( BOOL fSkipAssert = FALSE; );


    // First determine the destination size (cch).
    // Note that pbStop is adjust to the last character boundary.

    for (pb = _pbBufferPtr, pbStop = _pbBuffer + _cbBuffer, cch = 0; pb < pbStop;)
    {
        unsigned char t = *pb;
        size_t bytes = aiByteCountForLeadNibble[t>>4];

        if (pb + bytes > pbStop)
        {
            pbStop = pb;
            break;
        }
        else
        {
            pb += bytes;
        }

        cch += 1 + (bytes>>2); // surrogates need an extra wchar
    }
    
    hr = THR( MakeRoomForChars( cch ) );
    if (hr)
        goto Cleanup;

    // Now decode

    for (pchDst  = _pchEnd, pb = _pbBufferPtr; pb < pbStop;)
    {
        unsigned char t = *pb;
        size_t bytes = aiByteCountForLeadNibble[t>>4];
        WCHAR ch = 0;

        switch (bytes)
        {
            case 1:
                // 0xxxxxxx or 10xxxxxx
                // NOTE: 10xxxxxx is invalid (it is following byte, not first)
                if (WCHAR(*pb & 0x80) != 0)
                {
                    ++pb;
                    *pchDst++ = s_chUnknown;
                }
                else
                    *pchDst++ = WCHAR(*pb++);           // 0x0000 - 0x007f
                break;

            case 2:
                // 110XXXXx 10xxxxxx
                // Look for overlong utf-8 sequence.
                if (WCHAR(*pb & 0x1e) == 0)
                {
                    // Invalid utf-8 sequence: 1100000x 10xxxxxx
                    ch = s_chUnknown;
                    pb += 2;
                }
                else
                {
                    ch |= WCHAR(*pb++ & 0x1f) << 6;     // 0x0080 - 0x07ff
                    ch |= WCHAR(*pb++ & 0x3f);
                }

                if (IsValidWideChar(ch))
                {
                    *pchDst++ = ch;
                }
                else
                {
                    *pchDst++ = s_chUnknown;
                }
                break;
                    
            case 3:
                // 1110XXXX 10Xxxxxx 10xxxxxx
                // Look for overlong utf-8 sequence.
                if (   WCHAR(*pb & 0x0f) == 0
                    && WCHAR(*(pb+1) & 0x20) == 0)
                {
                    // Invalid utf-8 sequence: 11100000 100xxxxx 10xxxxxx
                    ch = s_chUnknown;
                    pb += 3;
                }
                else
                {
                    ch  = WCHAR(*pb++ & 0x0f) << 12;    // 0x0800 - 0xffff
                    ch |= WCHAR(*pb++ & 0x3f) << 6;     // 0x0080 - 0x07ff
                    ch |= WCHAR(*pb++ & 0x3f);
                }

                if (IsValidWideChar(ch))
                {
                    *pchDst++ = ch;
                }
                else
                {
                    *pchDst++ = s_chUnknown;
                }
                break;

            case 4:                                 // 0xd800 - 0xdfff (Surrogates)
                // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx or 11111xxx ....
                // NOTE: 11111xxx is not supported
                if (WCHAR(*pb & 0x08) != 0)
                {
                    // We have more than 4 bytes, and we do not support that yet
                    size_t bytesToSkip = aiByteCountForLeadNibble[*pb & 0x0f];
                    pb += 4 + (bytesToSkip == 4 ? 0 : bytesToSkip);
                    *pchDst++ = s_chUnknown;
                    WHEN_DBG( fSkipAssert = TRUE; );
                    break;
                }
                ch  = WCHAR(*pb++ & 0x07) << 2;
                ch |= WCHAR(*pb & 0x30) >> 4;
                ch  = (ch - 1) << 6;                // ch == 0000 00ww ww00 0000
                ch |= WCHAR(*pb++ & 0x0f) << 2;     // ch == 0000 00ww wwzz zz00
                ch |= WCHAR(*pb & 0x30) >> 4;       // ch == 0000 00ww wwzz zzyy
                *pchDst++ = 0xD800 + ch;
                Assert(IsHighSurrogateChar(pchDst[-1]));
                if (!IsHighSurrogateChar(pchDst[-1]))
                {
                    pchDst[-1] = s_chUnknown;
                    pb += 2;
                    break;
                }

                ch  = WCHAR(*pb++ & 0x0f) << 6;     // ch == 0000 00yy yy00 0000
                ch |= WCHAR(*pb++ & 0x3f);          // ch == 0000 00yy yyxx xxxx
                *pchDst++ = 0xDC00 + ch;
                Assert(IsLowSurrogateChar(pchDst[-1]));
                if (!IsLowSurrogateChar(pchDst[-1]))
                {
                    pchDst--;
                    pchDst[-1] = s_chUnknown;
                    break;
                }
                break;
        }

        WHEN_DBG( cch -= (bytes == 4) ? 2 : 1 );
    }

    Assert( fSkipAssert || cch == 0 );

    *pcch = pchDst - _pchEnd;
    _pbBufferPtr = pbStop;

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     Utf8FromWideChar
//
//  Synopsis:   Convert from Unicode to UTF-8
//
//------------------------------------------------------------------------

static TCHAR s_cUtf8FirstSignal[5] = {0x00, 0x00, 0xC0, 0xE0, 0xF0};

HRESULT
CEncodeWriter::Utf8FromWideChar( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    TCHAR* pch = _pchBuffer, *pchStop = _pchBuffer + _cchBuffer;
    unsigned char* pbDst;
    const  TCHAR cMask   = 0xBF;
    const  TCHAR cSignal = 0x80;
    int    cb;

    // First make a pass to see how many characters we will be converting.

    for( cb = 0; pch < pchStop; )
    {
        const TCHAR ch = *pch++;

        if (ch < 0x800)
        {
            cb += (ch < 0x80) ? 1 : 2;
        }
        else
        {
#ifndef NO_UTF16
            if (!IsHighSurrogateChar(ch))
            {
                cb += 3;
            }
            else
            {
                // NOTE (cthrash): Ideally, if a surrogate pair is split at pchStop boundary,
                // we should wait emitting any multibyte chars until we have more data.
                // Nevertheless, utf-8 converters should be written in such a way that
                // surrogate chars can be stored as one four-byte sequence or two three-
                // byte sequences.  So ignore the issue for now.

                if (pch == pchStop || !IsLowSurrogateChar(*pch))
                {
                    cb += 3;
                }
                else
                {
                    pch++;
                    cb += 4;
                }
            }
#else
            cb += 3;
#endif
        }
    }

    hr = THR( MakeRoomForChars( cb ) );
    if( hr )
        goto Cleanup;

    // Now encode Utf8
    
    for (pbDst  = _pbBuffer + _cbBuffer, pch = _pchBuffer; pch < pchStop;)
    {
        DWORD ch = DWORD(*pch++); // UCS4
        size_t cbTotal;

        if (ch < 0x800)
        {
            cbTotal = (ch < 0x80) ? 1 : 2;
        }
        else
        {
#ifndef NO_UTF16
            if (   IsHighSurrogateChar(ch)
                && pch < pchStop
                && IsLowSurrogateChar(*pch))
            {
                const DWORD ch2 = DWORD(*pch++);
                ch = 0x10000 + ((ch & 0x3ff) << 10) + (ch2 & 0x3ff);
                cbTotal = 4;
            }
            else
            {
                cbTotal = 3;
            }
#else
            cbTotal = 3;
#endif
        }

        pbDst += cbTotal;
        
        switch (cbTotal)
        {
            case 4: *--pbDst = (ch | cSignal) & cMask; ch >>= 6;
            case 3: *--pbDst = (ch | cSignal) & cMask; ch >>= 6;
            case 2: *--pbDst = (ch | cSignal) & cMask; ch >>= 6;
            case 1: *--pbDst = (ch | s_cUtf8FirstSignal[ cbTotal ]);
        }

        pbDst += cbTotal;
    }

    *pcch = cb;                    // return number of bytes converted
    _cbBuffer += cb;

Cleanup:
    RRETURN( hr );
}

#endif  // WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\encode\encode.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       encode.cxx
//
//  Contents:   Support for HTML character set encoding
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifdef WIN16
#define MB_PRECOMPOSED   0
#define MB_ERR_INVALID_CHARS 0
#endif

DeclareTag(tagEncGeneral,        "Enc", "Encode: General");
DeclareTag(tagEncAlwaysUseMlang, "Enc", "Encode: Always Use Mlang");

MtDefine(CEncodeReader, Utilities, "CEncodeReader")
MtDefine(CEncodeReaderPbBuf, CEncodeReader, "CEncodeReader::_pbBuffer")
MtDefine(CEncodeWriter, Utilities, "CEncodeWriter")
MtDefine(CEncodeWriterPbBuf, CEncodeWriter, "CEncodeWriter::_pbBuffer")
MtDefine(CEncodeWriterPchBuf, CEncodeWriter, "CEncodeWriter::_pchBuffer")
MtDefine(CToUnicodeConverterPchBuf, Utilities, "CToUnicodeConverter")

struct ENCODINGREADFUNC
{
    CODEPAGE cp;
    DECLARE_ENCODING_FUNCTION( (CEncodeReader::*pfnWCFromMB) );
};

struct ENCODINGWRITEFUNC
{
    CODEPAGE cp;
    DECLARE_ENCODING_FUNCTION( (CEncodeWriter::*pfnMBFromWC) );
};

BOOL IsSameEncoding(CODEPAGE cp1, CODEPAGE cp2)
{
    if (cp1 == cp2)
        return TRUE;

    // For now, all encodings are different except for windows-1252 and ISO-8859
    if (cp1 == CP_1252 && cp2 == CP_ISO_8859_1 || cp1 == CP_ISO_8859_1 && cp2 == CP_1252)
        return TRUE;

    return FALSE;
}

CEncode::CEncode( size_t nBlockSize )
{
    _cp = CP_UNDEFINED;
    _nBlockSize = nBlockSize;
    _dwState = 0UL;
}


CEncode::~CEncode()
{
}

CEncodeReader::CEncodeReader(
    CODEPAGE cp,
    size_t nBlockSize ) : CEncode( nBlockSize )
{
    _fCheckedForUnicode = FALSE;
    _fDiscardUtf7BOM = FALSE;
    _fDetectionFailed = FALSE;
    _cbScanStart = 0;
    _pfnWideCharFromMultiByte = NULL;
    _pchBuffer = NULL;
    _pbBuffer = NULL;

    SwitchCodePage( cp, NULL ); // sets _pfnWideCharFromMultiByte
}

CEncodeReader::~CEncodeReader()
{
    if (_pchBuffer)
    {
        MemFree(_pchBuffer);
        _pchBuffer = NULL;
    }
    if (_pbBuffer)
    {
        MemFree(_pbBuffer);
        _pbBuffer = NULL;
    }
}

BOOL
CEncodeReader::Exhausted()
{
    // If we're left with a only few DBCS orphan characters at the end,
    // consider ourselves exhausted.  The orphan characters will come
    // back to life in the next iteration of CEncodeReader::PrepareForRead().

    // Note that if we're in autodetect mode, we can have _cbScanStart != 0.
    // What this means is that we've scanned that many bytes without being
    // able determine the encoding.  We leave _pbBufferPtr as is because
    // that's where we need to start converting, but there's no point in
    // rescanning from there when we read more bytes.  We start scanning from
    // _cbScanStart bytes in to _pbBufferPtr.

    return _pbBuffer &&
           (_cbBuffer - ( _pbBufferPtr + _cbScanStart - _pbBuffer ) <
            ENCODE_DBCS_THRESHOLD);
}

BOOL
CEncodeReader::ForceSwitchCodePage( CODEPAGE cp, BOOL *pfDifferentEncoding )
{
    BOOL fSwitched = FALSE;

    fSwitched = CEncodeReader::SwitchCodePage(cp, pfDifferentEncoding);

    // see if we wanted to switch but failed
    if (cp != _cp && !fSwitched)
    {
        // check to see if the codepage can be jit-in
        if (S_OK == THR(mlang().IsCodePageInstallable(cp)))
        {
            fSwitched = TRUE;

            if (pfDifferentEncoding)
            {
                *pfDifferentEncoding = !IsSameEncoding(cp, _cp);
            }

            _cp = cp;
        }
    }

    return fSwitched;
}

BOOL
CEncodeReader::SwitchCodePage( CODEPAGE cp, BOOL *pfDifferentEncoding, BOOL fNeedRestart)
{
    BOOL fSuccess = FALSE, fSwitched;
    static const struct ENCODINGREADFUNC aEncodingFuncs[] =
    {
        { CP_1252,         &CEncodeReader::WideCharFromMultiByteGeneric },
        { CP_ISO_8859_1,   &CEncodeReader::WideCharFromMultiByteGeneric },
#ifndef WINCE
        { CP_UTF_8,        &CEncodeReader::WideCharFromUtf8 },
#endif // WINCE
        { CP_UCS_2,        &CEncodeReader::WideCharFromUcs2 },
        { CP_1250,         &CEncodeReader::WideCharFromMultiByteGeneric },
        { CP_1251,         &CEncodeReader::WideCharFromMultiByteGeneric },
        { CP_1253,         &CEncodeReader::WideCharFromMultiByteGeneric },
        { CP_1254,         &CEncodeReader::WideCharFromMultiByteGeneric },
        { CP_1257,         &CEncodeReader::WideCharFromMultiByteGeneric },
    };

    const struct ENCODINGREADFUNC * p = aEncodingFuncs;
    const struct ENCODINGREADFUNC * pStop = aEncodingFuncs +
                                        ARRAY_SIZE( aEncodingFuncs );

    // Nothing has changed, quickly bail.

    if (cp == _cp && _pfnWideCharFromMultiByte)
        goto Cleanup;

    Assert(cp != CP_ACP);

#if DBG == 1
    if (!IsTagEnabled(tagEncAlwaysUseMlang)) {
#endif

    // See if we can handle this codepage natively.
    for (;p < pStop;p++)
    {
        if (cp == p->cp)
            break;
    }

    if (p < pStop)
    {
        // Check to see if we can go from the native codepage to Unicode.

        fSuccess = IsStraightToUnicodeCodePage(cp);
        if (!fSuccess)
        {
            UINT uCP = WindowsCodePageFromCodePage( cp );
            CPINFO cpinfo;

            fSuccess = GetCPInfo( uCP, &cpinfo );
            if (fSuccess)
            {
                _uMaxCharSize = cpinfo.MaxCharSize;
            }
        }
    }

#if DBG == 1
    }
    else
    {
        p = pStop;
        TraceTag((tagEncAlwaysUseMlang, "Forcing mlang use for codepage %d", cp));
    }
#endif

    // If we cannot handle this codepage natively, hand it over to mlang
    if (!fSuccess)
    {
        fSuccess = (S_OK == THR(mlang().IsConvertible(cp, CP_UCS_2)));
    }

    if (fSuccess)
    {
        _pfnWideCharFromMultiByte = p == pStop ?
           &CEncodeReader::WideCharFromMultiByteMlang : p->pfnWCFromMB;
    }
    else
    {
        // If we failed, do not switch code pages.
        TraceTag((tagEncGeneral, "Don't know how to read with codepage: %d", cp));
        cp = _cp;
    }

    TraceTag((tagEncGeneral, "CEncodeReader switching to codepage: %d", cp));

Cleanup:

    if (!_pfnWideCharFromMultiByte)
    {
        // If we still haven't come up with an encoding use 1252
        _pfnWideCharFromMultiByte = &CEncodeReader::WideCharFromMultiByteGeneric;
        cp = CP_1252;
        _uMaxCharSize = 1;
    }

    fSwitched = _cp != cp;

    if (pfDifferentEncoding)
    {
        *pfDifferentEncoding = !IsSameEncoding(cp, _cp);
    }

    _cp = cp;

    return fSwitched;
}

HRESULT
CEncodeReader::PrepareToEncode()
{
    HRESULT hr = S_OK;

    if (!_pbBuffer)
    {
        _cbBufferMax = BlockSize() + ENCODE_DBCS_THRESHOLD;
        _cbBuffer = _cbBufferMax;
        _pbBuffer = (unsigned char *)MemAlloc(Mt(CEncodeReaderPbBuf), _cbBufferMax );
        if (!_pbBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pbBufferPtr = _pbBuffer + _cbBuffer;
    }

    //
    // _cbBuffer is the number of valid multibyte characters in our
    // multibyte buffer. It is non-zero when (a) you've split a multibyte
    // character at a read boundary, or (b) autodetection has not yet been
    // able to correctly identify the encoding.
    //

    _cbBuffer -= (INT)(_pbBufferPtr - _pbBuffer);

    memmove( _pbBuffer, _pbBufferPtr, _cbBuffer );

    if (_cbBuffer > ENCODE_DBCS_THRESHOLD)
    {
        // Ensure that we have space to read an BlockSize() chunk.

        _cbBufferMax = _cbBuffer + BlockSize();
        hr = THR( MemRealloc(Mt(CEncodeReaderPbBuf), (void **)&_pbBuffer , _cbBufferMax ) );
        if (hr)
            goto Cleanup;
    }

    _pbBufferPtr = _pbBuffer + _cbBuffer;

Cleanup:
    RRETURN(hr);
}

HRESULT
CEncodeReader::WideCharFromMultiByte( BOOL fReadEof, int * pcch )
{
    HRESULT hr;

#ifndef WIN16
    // Do a quick check for Unicode files

    if (!_fCheckedForUnicode)
    {
        AssertSz(_pbBufferPtr == _pbBuffer,
                 "We should be at the beginning of the buffer.");

        BOOL fCheckNoFurther = FALSE;

        for (;;)
        {

            if (_cbBuffer > 1)
            {
                WCHAR uSignature = *(WCHAR *)_pbBuffer;

                // TODO (davidd) Support NON/NATIVE_UNICODE_CODEPAGE (sizeof(WCHAR) == 4/2)
                if (NATIVE_UNICODE_SIGNATURE == uSignature)
                {
                    // (davidd) CP_UCS_2 does not currently distinguish between
                    // 2/4 byte unicode so it is the right answer for native
                    // unicode reading..  should be NATIVE_UNICODE_CODEPAGE

                    SwitchCodePage( CP_UCS_2 );
                    _pbBufferPtr += sizeof(WCHAR);
                    fCheckNoFurther = TRUE;
                    break;
                }
                else if (NONNATIVE_UNICODE_SIGNATURE == uSignature)
                {
                    SwitchCodePage( CP_UCS_2_BIGENDIAN );
                    _pbBufferPtr += sizeof(WCHAR);
                    fCheckNoFurther = TRUE;
                    break;
                }
            }

            if (_cbBuffer > 2)
            {
                if (   _pbBufferPtr[0] == 0xEF
                     && _pbBufferPtr[1] == 0xBB
                     && _pbBufferPtr[2] == 0xBF)
                {
                    SwitchCodePage( CP_UTF_8 );
                    _pbBufferPtr += 3;
                    fCheckNoFurther = TRUE;
                    break;
                }
            }

            if (_cbBuffer > 3)
            {
                if (   _pbBufferPtr[0] == '+'
                    && _pbBufferPtr[1] == '/'
                    && _pbBufferPtr[2] == 'v'
                    && (   _pbBufferPtr[3] == '8'
                        || _pbBufferPtr[3] == '9'
                        || _pbBufferPtr[3] == '+'
                        || _pbBufferPtr[3] == '/'))
                {
                    SwitchCodePage( CP_UTF_7 );
                    _fDiscardUtf7BOM = TRUE;
                }

                fCheckNoFurther = TRUE;
            }

            break;
        }

        _fCheckedForUnicode = fCheckNoFurther;
    }
#endif //!WIN16

    hr = THR( CALL_METHOD( this, _pfnWideCharFromMultiByte, ( fReadEof, pcch )) );

    RRETURN(hr);
}

HRESULT
CEncodeReader::WideCharFromMultiByteGeneric( BOOL fReadEof, int * pcch )
{
    size_t cb = _cbBuffer - (_pbBufferPtr - _pbBuffer);
    size_t cch = 0;
    HRESULT hr = S_OK;
    CODEPAGE cp = _cp;

    // PERF HACK (grzegorz): We are using WideCharFromMultiByteGeneric to convert
    //      from CP_ISO_8859_1 to Unicode, but MultiByteToWideChar in this case
    //      doesn't converts all characters properly (example: 0x80 (euro)).
    //      MLang has a hack for this case, they are using CP_1252. To make the
    //      behavior consistent we need to do the same.
    if (cp == CP_ISO_8859_1)
        cp = CP_1252;

    // If we have a multibyte character encoding, we are at risk of splitting
    // some characters at the read boundary.  We must Make sure we have a
    // discrete number of characters first.

    Assert( _uMaxCharSize );

    if (_uMaxCharSize > 1)
    {
        UINT uMax = _uMaxCharSize;
        cb++;// pre-increment
        do
        {
            cch = MultiByteToWideChar( cp,
                                       MB_ERR_INVALID_CHARS | MB_PRECOMPOSED,
                                       (char *)_pbBufferPtr, --cb,
                                       NULL, 0 );
            --uMax;
        } while (!cch && uMax && cb);
    }
    else
    {
        cch = cb;
    }

    if (cch == 0)
    {
        cch = MultiByteToWideChar( cp, MB_PRECOMPOSED,
                                   (char*)_pbBufferPtr, cb,
                                   NULL, 0 );

    }

    if (cch)
    {
        hr = THR(MakeRoomForChars(cch));
        if (hr)
            goto Cleanup;

        cch = MultiByteToWideChar( cp, MB_PRECOMPOSED,
                                   (char *)_pbBufferPtr, cb,
                                   _pchEnd, cch );
    }

    *pcch = cch;
    _pbBufferPtr += cb;

Cleanup:
    RRETURN(hr);
}

#ifndef NO_MLANG
HRESULT
CEncodeReader::WideCharFromMultiByteMlang( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    UINT    cch = 0, cb = _cbBuffer - (_pbBufferPtr - _pbBuffer);
    DWORD   dwState = _dwState;

    hr = THR(mlang().ConvertStringToUnicode(&dwState, _cp, (CHAR *)_pbBufferPtr, &cb, NULL, &cch));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(MakeRoomForChars(cch));
    if (hr)
        goto Cleanup;

    hr = THR(mlang().ConvertStringToUnicode(&_dwState, _cp, (CHAR *)_pbBufferPtr, &cb, (WCHAR *)_pchEnd, &cch));
    if (FAILED(hr))
        goto Cleanup;

    if (IsAutodetectCodePage(_cp))
    {
        // Mlang stuffs the actual codepage into the hiword of the state
        CODEPAGE cpDetected = HIWORD(_dwState);

        // if cpDetected is zero, it implies that there was insufficient data
        // (typically all-ASCII data) to determine the charset.  We will
        // continue to encode in autodetect mode in this case.  If non-zero,
        // we'll switch the doc so that we can submit, etc., correctly.

        if (cpDetected)
        {
            // if we're getting codepage detecting result from
            // mlang, chances are that we have not processed
            // the stream at all because the system didn't have
            // the corresponding codepage installed.
            // we need to start over and get the codepage JIT-in.
            //
            BOOL fNeedRestart = _fDetectionFailed;

            if (_cp == CP_AUTO)
            {
                MIMECPINFO cpinfo;
                ZeroMemory(&cpinfo, sizeof(MIMECPINFO));

                if (   (mlang().GetCodePageInfo(cpDetected, MLGetUILanguage(), &cpinfo) == S_OK)
                    && !(cpinfo.dwFlags & MIMECONTF_VALID))
                {
                    fNeedRestart = TRUE;
                }
            }

            _fDetectionFailed = FALSE;

            SwitchCodePage(cpDetected, NULL, fNeedRestart);
        }
        else
            _fDetectionFailed = TRUE;
    }
    else if (_fDiscardUtf7BOM)
    {
        // Discard the BOM.  Note we can't do this sooner because part of the
        // first character is mixed in with the BOM bytes.

        --cch;
        memmove( _pchEnd, _pchEnd + 1, cch * sizeof(wchar_t));
        _fDiscardUtf7BOM = FALSE;
    }


    hr = S_OK;

    *pcch = cch;
    _pbBufferPtr += cb;

Cleanup:
    RRETURN(hr);
}
#endif // !NO_MLANG

HRESULT
CEncodeReader::MakeRoomForChars( int cch )
{
    // call my superclass first!

    _pchEndLast = _pchEnd;
    _pbBufferPtrLast = _pbBufferPtr;

    RRETURN(S_OK);
}

//---------------------------------------------------------------------

CEncodeWriter::CEncodeWriter(
    CODEPAGE cp,
    size_t nBlockSize ) : CEncode( nBlockSize )
{
    _pfnMultiByteFromWideChar = NULL;
    _pchBuffer = NULL;
    _cchBuffer = _cchBufferMax = 0;
    _pbBuffer = NULL;
    _cbBuffer = _cbBufferMax = 0;
    _cDefaultChar = '?';
    _fEntitizeUnknownChars = TRUE;

    // Choose something sane for _uiWinCodepage
    _uiWinCodepage = g_cpDefault;

    SwitchCodePage( cp ); // sets _pfnWideCharFromMultiByte
}

CEncodeWriter::~CEncodeWriter()
{
    if (_pchBuffer)
    {
        MemFree(_pchBuffer);
        _pchBuffer = NULL;
        _cchBuffer = _cchBufferMax = 0;
    }
    if (_pbBuffer)
    {
        MemFree(_pbBuffer);
        _pbBuffer = NULL;
        _cbBuffer = _cbBufferMax = 0;
    }
}

BOOL
CEncodeWriter::SwitchCodePage( CODEPAGE cp, BOOL *pfDifferentEncoding, BOOL fNeedRestart )
{
    BOOL fSuccess = FALSE, fSwitched;
    static const struct ENCODINGWRITEFUNC aEncodingFuncs[] =
    {
        { CP_1252,         &CEncodeWriter::MultiByteFromWideCharGeneric },
        { CP_ISO_8859_1,   &CEncodeWriter::MultiByteFromWideCharGeneric },
#ifndef WINCE
        { CP_UTF_8,        &CEncodeWriter::Utf8FromWideChar },
#endif // WINCE
        { CP_UCS_2,        &CEncodeWriter::UnicodeFromWideChar },
        { CP_1250,         &CEncodeWriter::MultiByteFromWideCharGeneric },
        { CP_1251,         &CEncodeWriter::MultiByteFromWideCharGeneric },
        { CP_1253,         &CEncodeWriter::MultiByteFromWideCharGeneric },
        { CP_1254,         &CEncodeWriter::MultiByteFromWideCharGeneric },
        { CP_1257,         &CEncodeWriter::MultiByteFromWideCharGeneric },
    };

    const struct ENCODINGWRITEFUNC * p = aEncodingFuncs;
    const struct ENCODINGWRITEFUNC * pStop = aEncodingFuncs + ARRAY_SIZE(aEncodingFuncs);

    // Nothing has changed, quickly bail.

    if (cp == _cp && _pfnMultiByteFromWideChar)
        goto Cleanup;

    Assert(cp != CP_ACP);

    // See if we can handle this codepage natively.
    for (;p < pStop; p++)
    {
        if (cp == p->cp)
            break;
    }

    fSuccess = (p < pStop);

    // If we cannot handle this codepage natively, hand it over to mlang
    if (!fSuccess)
    {
        fSuccess = (S_OK == THR(mlang().IsConvertible(CP_UCS_2, cp)));
    }

    if (fSuccess)
    {
        if (p == pStop)
        {
            if (mlang().IsMLangAvailable())
                _pfnMultiByteFromWideChar = &CEncodeWriter::MultiByteFromWideCharMlang2;
            else
            {
                _pfnMultiByteFromWideChar = MultiByteFromWideCharGeneric;
                CPINFO cpinfo;
                fSuccess = GetCPInfo(cp, &cpinfo);
            }
        }
        else
            _pfnMultiByteFromWideChar = p->pfnMBFromWC;
    }

    if (!fSuccess)
    {
        _pfnMultiByteFromWideChar = &CEncodeWriter::MultiByteFromWideCharMlang2;
        cp = g_cpDefault; // desperation
    }

    TraceTag((tagEncGeneral, "CEncodeWriter switching to codepage: %d", cp));

Cleanup:
    fSwitched = _cp != cp;

    if (pfDifferentEncoding)
    {
        *pfDifferentEncoding = fSwitched;
    }

    _cp = cp;

    // Cache the windows codepage for the new cp
    _uiWinCodepage = WindowsCodePageFromCodePage( _cp );

    if (fSwitched)
    {
        _dwState = 0;
    }

    return fSwitched;
}

HRESULT
CEncodeWriter::PrepareToEncode()
{
    HRESULT hr = S_OK;

    //
    // Allocate a unicode buffer the size of our block size, if we haven't already.
    //
    if (!_pchBuffer)
    {
        _cchBufferMax = BlockSize();
        _cchBuffer = 0;
        _pchBuffer = (TCHAR*)MemAlloc(Mt(CEncodeWriterPchBuf), _cchBufferMax*sizeof(TCHAR) );
        if (!_pchBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CEncodeWriter::MultiByteFromWideChar( BOOL fReadEof, int * pcch )
{
    HRESULT hr;

    Assert( _pfnMultiByteFromWideChar != NULL );

    hr = THR( CALL_METHOD( this, _pfnMultiByteFromWideChar, ( fReadEof, pcch ) ));

    RRETURN(hr);
}

HRESULT
CEncodeWriter::MultiByteFromWideCharGeneric( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    UINT    cchTotal;

    cchTotal = WideCharToMultiByte(_uiWinCodepage, 0, _pchBuffer, _cchBuffer,
                                   NULL, 0, NULL, NULL);

    hr = THR(MakeRoomForChars(cchTotal));
    if (hr)
        goto Cleanup;

    cchTotal = WideCharToMultiByte(_uiWinCodepage, 0, _pchBuffer, _cchBuffer,
                                   (char*)_pbBuffer + _cbBuffer, _cbBufferMax - _cbBuffer,
                                   &_cDefaultChar, NULL);
    if (!_fEntitizeUnknownChars)
    {
        _cbBuffer += cchTotal;
    }
    else
    {
        BOOL fEntitizeMode = FALSE;
        WCHAR * pchOrig;
        WCHAR * pchNew;
        UINT cchUnicode;

        // Convert output buffer back to Unicode to find out which characters
        // need to be entitized (&#xxxxx;).
        cchUnicode = MultiByteToWideChar(_uiWinCodepage, 0, (char*)_pbBuffer + _cbBuffer,
                                         cchTotal, NULL, 0);
        WCHAR * pch = (WCHAR *)MemAlloc(Mt(CEncodeWriter), cchUnicode * sizeof(WCHAR));
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        cchUnicode = MultiByteToWideChar(_uiWinCodepage, 0, (char*)_pbBuffer + _cbBuffer,
                                         cchTotal, pch, cchUnicode);

        // Compare results, and if they:
        // 1) match, use already converted string
        // 2) don't match, we need to switch to entitize mode, replace unknown characters
        //    with &#xxxxx;  Need to go one byte at a time.
        Assert(_cchBuffer == cchUnicode);
        pchOrig = _pchBuffer;
        pchNew  = pch;
        for (UINT i = 0; i < _cchBuffer; i++)
        {
            if (*pchNew++ != *pchOrig++)
            {
                fEntitizeMode = TRUE;
                break;
            }
        }

        if (fEntitizeMode)
        {
            unsigned char *pb = _pbBuffer + _cbBuffer;
            unsigned char *pbStart;
            UINT cchNeed = cchTotal;  // we need at least this much room in the buffer
            cchTotal = 0;

            pchOrig = _pchBuffer;
            pchNew  = pch;
            for (UINT i = 0; i < _cchBuffer; i++)
            {
                if (*pchNew == *pchOrig)
                {
                    LONG cchTemp = WideCharToMultiByte(_uiWinCodepage, 0, pchOrig, 1,
                                                       (char*)pb, _cbBufferMax - _cbBuffer, NULL, 0);

                    pb += cchTemp;
                    cchTotal += cchTemp;

                    cchNeed -= cchTemp;
                }
                else
                {
                    // Fill in an entitity reference instead
                    // Allocate eight more characters for the numeric entity
                    hr = THR(MakeRoomForChars(cchTotal + 8 + cchNeed));
                    if (hr)
                        goto Cleanup;

                    // _pbBuffer can change in MakeRoomForChars
                    pb = pbStart = _pbBuffer + _cbBuffer + cchTotal;

                    *pb++ = '&';
                    *pb++ = '#';
                    _ultoa((unsigned long)*pchOrig, (char*)pb, 10);
                    pb += lstrlenA((const char*)pb);
                    *pb++ = ';';

                    AssertSz(pb <= _pbBuffer + _cbBufferMax, "Entitizing overflow");

                    cchTotal += (UINT)(pb - pbStart);
                }
                ++pchNew;
                ++pchOrig;
            }
        }
        _cbBuffer += cchTotal;

        MemFree(pch);
    }

    *pcch = cchTotal;

Cleanup:
    RRETURN( hr );
}

#ifndef NO_MLANG
HRESULT
CEncodeWriter::MultiByteFromWideCharMlang( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    UINT    cb = 0, cch = _cchBuffer;
    DWORD   dwState;

    _dwState |= _fEntitizeUnknownChars ? 0x00008000 : 0;
    dwState = _dwState;

    hr = THR(mlang().ConvertStringFromUnicode(&dwState, _cp, (WCHAR *)_pchBuffer, &cch, NULL, &cb));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(MakeRoomForChars(cb));
    if( hr )
        goto Cleanup;

    hr = THR(mlang().ConvertStringFromUnicode(&_dwState, _cp, (WCHAR *)_pchBuffer, &cch, (CHAR *)_pbBuffer + _cbBuffer, &cb));
    if (FAILED(hr))
        goto Cleanup;

    // NB (cthrash) MLANG returns S_FALSE when everything converted fine, except
    // there were WC chars not native to the codepage _cp.  These are entitized,
    // so there's no error.  We don't want to propagate the S_FALSE up to the caller.

    hr = S_OK;

    *pcch = cb;
    _cbBuffer += cb;

Cleanup:
    RRETURN( hr );
}

HRESULT
CEncodeWriter::MultiByteFromWideCharMlang2( BOOL fReadEof, int * pcch )
{
    HRESULT hr;
    UINT    cb = 0, cch = _cchBuffer;
    DWORD   dwArg = _fEntitizeUnknownChars ? (MLCONVCHARF_NAME_ENTITIZE | MLCONVCHARF_NCR_ENTITIZE) : 0;
    DWORD   dwState = _dwState;

    hr = THR(mlang().ConvertStringFromUnicodeEx(&dwState, _cp, (WCHAR *)_pchBuffer, &cch, NULL, &cb, dwArg, NULL));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(MakeRoomForChars(cb));
    if( hr )
        goto Cleanup;

    hr = THR(mlang().ConvertStringFromUnicodeEx(&_dwState, _cp, (WCHAR *)_pchBuffer, &cch, (CHAR *)_pbBuffer + _cbBuffer, &cb, dwArg, NULL));
    if (FAILED(hr))
        goto Cleanup;

    // NB (cthrash) MLANG returns S_FALSE when everything converted fine, except
    // there were WC chars not native to the codepage _cp.  These are entitized,
    // so there's no error.  We don't want to propagate the S_FALSE up to the caller.

    hr = S_OK;

    *pcch = cb;
    _cbBuffer += cb;

Cleanup:
    RRETURN( hr );
}
#endif // !NO_MLANG

HRESULT
CEncodeWriter::MakeRoomForChars( int cch )
{
    HRESULT hr = S_OK;

    if (!_pbBuffer)
    {
        // round up to block size multiple >= cch+1
        _cbBufferMax = (cch + _nBlockSize*2 - 1) & ~(_nBlockSize*2 - 1);

        _pbBuffer = (unsigned char*)MemAlloc(Mt(CEncodeWriterPbBuf), _cbBufferMax);
        if (!_pbBuffer)
            RRETURN( E_OUTOFMEMORY );
    }
    else
    {
        int cchNeed = _cbBuffer + cch;

        // Reallocate the chunk if we need more memory for the extra characters.

        if (cchNeed >= _cbBufferMax)
        {
            // round up to WBUFF_SIZE*2
            cchNeed = (cchNeed + _nBlockSize*2 - 1) & ~(_nBlockSize*2 - 1);

            hr = THR(MemRealloc(Mt(CEncodeWriterPbBuf), (void**)&_pbBuffer, cchNeed ) );
            if (hr)
                goto Cleanup;

            _cbBufferMax = cchNeed;
        }

    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CToUnicodeConverter::Convert
//
//  Synopsis:   Convert a multibyte string to a Unicode string.
//
//  Input:      pbBuffer - multibyte string.
//
//              cbBuffer - byte count of pbBuffer, or -1.
//                         -1 implies that the string is nul-terminated.
//
//  Returns:    HRESULT - S_OK/E_OUTOFMEMORY
//
//              *ppchBuffer - Unicode buffer.  Allocated by this object.
//                            Should be freed by caller.
//
//              *pcch - Character count of string in *ppchBuffer
//
//-----------------------------------------------------------------------------

HRESULT
CToUnicodeConverter::Convert(
    const char *pbBuffer,   // IN
    const int cbBuffer,     // IN
    TCHAR ** ppchBuffer,    // OUT
    int *pcch )             // OUT
{
    HRESULT hr = S_OK;

    Assert(pbBuffer && cbBuffer >= -1);

    _fMakeRoomForNUL = (cbBuffer != -1);
    _pbBuffer = _pbBufferPtr = (unsigned char *)pbBuffer;
    _cbBuffer = _cbBufferMax = _fMakeRoomForNUL ? cbBuffer : lstrlenA(pbBuffer) + 1;

    hr = THR(WideCharFromMultiByte(TRUE, pcch));

    if (FAILED(hr))
        goto Cleanup;

    if (AutoDetectionFailed())
    {
        SwitchCodePage( g_cpDefault );

        _fMakeRoomForNUL = (cbBuffer != -1);
        _pbBuffer = _pbBufferPtr = (unsigned char *)pbBuffer;
        _cbBuffer = _cbBufferMax = _fMakeRoomForNUL ? cbBuffer : lstrlenA(pbBuffer) + 1;

        hr = THR(WideCharFromMultiByte(TRUE, pcch));

        if (FAILED(hr))
            goto Cleanup;
    }

    *ppchBuffer = _pchBuffer;

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CToUnicodeConverter::MakeRoomForChars
//
//  Synopsis:   Allocate a Unicode string buffer.
//
//  Input:      cch = Unicode character count
//
//  Returns:    HRESULT - S_OK/E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------

HRESULT
CToUnicodeConverter::MakeRoomForChars(
    int cch )
{
    HRESULT hr = S_OK;

    if (!_pchBuffer || cch > _cchBuffer)
    {
        if (_fMakeRoomForNUL)
            ++cch;

        if( !_pchBuffer )
        {
            _pchBuffer = (TCHAR *)MemAlloc(_mt, cch * sizeof(TCHAR));

            if (!_pchBuffer)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else if( cch > 0 )
        {
            // If we did this for cch == 0, Realloc would free the buffer, and that'd be
            // substantially different.
            hr = THR( MemRealloc(_mt, (void **)&_pchBuffer, cch * sizeof(TCHAR)));
            if( hr )
                goto Cleanup;
        }

        _cchBuffer = cch;
        _pchEnd = _pchBuffer;
    }

    IGNORE_HR(CEncodeReader::MakeRoomForChars(cch));

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CToUnicodeConverter dtor
//
//  Synopsis:   Caller should free both the multibyte and unicode string
//              buffers.  To prevent the base class CEncodeReader from freeing
//              if for you, we NULL out the pointers.
//
//-----------------------------------------------------------------------------

CToUnicodeConverter::~CToUnicodeConverter()
{
    // Let the caller free this memory

    _pbBuffer = NULL;
    _pchBuffer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\empty.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\sitedisp.h ===
/**************************************************************************************


  (rgardner) This file is obsolete - please put all changes in COREDISP.H
  It will be delfile'd shortly in a cleanup pass
                                                

 **************************************************************************************/



#error "Don't include this file"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\download\jpglib6a\miint.c ===
/***************************************************************************
*
*                INTEL Corporation Proprietary Information  
*
*      
*                  Copyright (c) 1996 Intel Corporation.
*                         All rights reserved.
*
***************************************************************************
			AUTHOR:  Kumar Balasubramanian 
***************************************************************************

** MMX version of the "integer LLM mode" within IJG decompressor code.
** The following is an MMX implementation of the integer slow mode
** IDCT within the IJG code.
*/

#define JPEG_INTERNALS
#include "jinclude.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */

#ifdef DCT_ISLOW_SUPPORTED

#ifndef USEINLINEASM

GLOBAL(void)
midct8x8llm (JCOEFPTR inptr, short *quantptr, short *wsptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{
}

#else


/*
 * This module is specialized to the case DCTSIZE = 8.
 */

#if DCTSIZE != 8
  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */
#endif



#if BITS_IN_JSAMPLE == 8
#define CONST_BITS  13
#define PASS1_BITS  2
#else
#define CONST_BITS  13
#define PASS1_BITS  1		/* lose a little precision to avoid overflow */
#endif

/* Define the constants for the case BITS_IN_JSAMPLE = 8 */

static const __int64 const_0_2986	=	0x0000098E0000098E ;
static const __int64 const_0_3901	=	0x00000c7c00000c7c;
static const __int64 const_0_54119	=	0x0000115100001151;
static const __int64 const_0_7653	=	0x0000187E0000187E;
static const __int64 const_0_899	=	0x00001ccd00001ccd;
static const __int64 const_1_175	=	0x000025a1000025a1;
static const __int64 const_1_501	=	0x0000300b0000300b;
static const __int64 const_1_8477	=	0x00003b2100003b21;
static const __int64 const_1_961	=	0x00003ec500003ec5 ;
static const __int64 const_2_053	=	0x000041b3000041b3 ;
static const __int64 const_2_562	=	0x0000520300005203 ;
static const __int64 const_3_072	=	0x0000625400006254 ;

static const __int64 const_all_ones	=	0x0ffffffffffffffff;	
static const __int64 const_0_1_0_1		=	0x0000000100000001	 ;
static const __int64 const_zero		=	0x0000000000000000;	
static const __int64 const_1_0			=	0x0000000100000001	;
static const __int64 const_round		=	0x0000040000000400;
static const __int64 const_round_two	=	0x0002000000020000;
static const __int64 const_mask		=  0x000003ff000003ff;

static const __int64 const_00_1_84_00_0_765	=	0x00003b210000187E;
static const __int64 const_00_0_5411_00_00		=	0x0000115100000000;
static const __int64 const_3_072_00_1_501_00	=	0x62540000300b0000;
static const __int64 const_0_2986_00_2_053_00	=	0x098E000041b30000;
static const __int64 const_0_899_00_2_562_00	=   0x1ccd000052030000;
static const __int64 const_1_96_00_0_3901_00	=   0x3ec500000c7c0000;
static const __int64 const_1_175_00_00_00		=	0x25a1000000000000;







/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
midct8x8llm (JCOEFPTR inptr, short *quantptr, short *wsptr,
		 JSAMPARRAY output_buf, JDIMENSION output_col, JSAMPLE *range_limit )
{

	INT32 locdwinptr,	locdwqptr, locdwwsptr, locdwcounter, locdwrowctr ;
__int64 locqwtmp0e,locqwtmp0o, locqwtmp1e, locqwtmp1o, locqwtmp2e ;

__int64 locqwtmp10e	, locqwtmp10o	,locqwtmp11e	,
		 locqwtmp11o	, locqwtmp12e	, locqwtmp12o	,
		 locqwtmp13e	, locqwtmp13o	,locqwtmp0	,
		locqwtmp1	,locqwtmp2	,locqwtmp3	,
		locqwz5e ,locqwz5o	,locqwz1e ,locqwz1o	,
		locqwz13e	,locqwz13o	,locqwz14e	,
		locqwz14o	,locqwz23e	,locqwz23o	,
		locqwz24e	,locqwz24o ;




// Inline assembly to do the IDCT and store the result */

__asm {

mov	esi, inptr	; load the input pointer
mov edi, quantptr		; load the quant table pointer

mov locdwinptr, esi	; to be used in the idct_column loop
mov locdwqptr, edi	; to be used in the idct_column loop

mov esi, wsptr
mov locdwcounter, 2	; idct_column loop counter

mov locdwwsptr, esi



;; do the idct on all the columns. Do four columns per
;; iteration of the loop.

idct_column:

mov		esi, locdwinptr	; get the source pointer
mov		edi, locdwqptr		; get the quantzn. pointer

;; fetch C2 and Q2
movq	mm0,  [esi+16*2]	; get C2

movq	mm1,  [edi+16*2]	; get Q2

movq	mm2,  [esi+16*6]	; get C6
pmullw	mm0, mm1		; dequantized C2 = z2

movq	mm3, [edi+16*6]	; get Q6

movq	mm6,  const_0_7653	
pmullw	mm2, mm3		; dequant. C6 = z3

movq	mm7,  const_1_8477	
movq	mm4, mm0		; copy z2

pmaddwd	mm4, mm6		; tmp3 - z1 for columns 0 & 2
movq	mm5, mm0		; copy z2

movq	mm3, mm2		; z3 copy
psrlq	mm5, 16			; move z2 columns 1 & 3 to 0 & 2

movq	mm1,  const_0_54119
pmaddwd	mm5, mm6		; tmp3 - z1 for columns 1 & 3

psrlq	mm3, 16			; move z3 columns 1 & 3 to 0 & 2
paddw	mm0, mm2		; z2 + z3

pmaddwd	mm2, mm7		; tmp2 - z1 for columns 0 & 2
movq	mm6, mm0		; z2 + z3 copy

psrlq	mm6, 16			; z2 + z3 columns 1 & 3 in 0 & 2
pmaddwd	mm3, mm7		; tmp2 - z1 for columns 1 & 3

movq	mm7,  const_all_ones
pmaddwd	mm0, mm1		; z1 columns 0 & 2

pmaddwd	mm6, mm1		; z1 columns 1 & 3
pxor	mm2, mm7		; 1s complement of tmp2 - z1

movq	mm1,  const_0_1_0_1
pxor	mm3, mm7		; 1s complement of tmp2 - z1 

paddd	mm2, mm1		; 2s complement of tmp2 - z1(col 0 &2)
paddd	mm3, mm1		; 2s complement of tmp2 - z1(col 1 & 3)

paddd	mm2, mm0		; tmp2 (columns 0 & 2)
paddd	mm4, mm0		; tmp2 (cols. 1 & 3)

;; get C0 and Q0
movq	mm0,  [esi+16*0]	; get C0
paddd	mm3, mm6		; tmp3

movq	mm1,  [edi+16*0]	; getQ0
paddd	mm5, mm6		; tmp3

movq	mm6,  [esi+16*4]	; get C4
pmullw	mm0, mm1		; dequant C0 = z2

movq	mm7,  [edi+16*4]	; get Q4
nop

movq	locqwtmp2e, mm2	; store tmp2 even part
pmullw	mm6, mm7		; dequant C4 = z3

movq	mm7,  const_1_0
movq	mm1, mm0		; copy of z2

paddw	mm0, mm6		; z2+z3
nop

psubw	mm1, mm6		; z2-z3
movq	mm6, mm0		; z2+z3 copy

pmaddwd	mm0, mm7		; get 0 & 2 cols
psrlq	mm6, 16			; get the other two cols.

pmaddwd	mm6, mm7		; 
movq	mm2, mm1		; copy of z2-z3

pmaddwd	mm1, mm7
psrlq	mm2, 16

pmaddwd	mm2, mm7
pslld	mm0, 13			; tmp0 cols 0&2

movq	mm7, mm4
pslld	mm6, 13			; tmp0 cols 1 & 3

paddd	mm4, mm0		; 
psubd	mm0, mm7		; 

movq	mm7, mm5
pslld	mm2, 13

movq	locqwtmp13e, mm0	; store tmp13 cols 0&2
paddd	mm5, mm6

movq	mm0, locqwtmp2e
psubd	mm6, mm7


movq	locqwtmp10o, mm5	; store tmp10 cols 1&3
movq	mm7, mm3

movq	locqwtmp13o, mm6	; store tmp13 cols 1&3
paddd	mm3, mm2

movq	locqwtmp10e, mm4	; store tmp10 cols 0&2
pslld	mm1, 13

movq	locqwtmp11o, mm3	; store tmp11 cols 1,3
psubd	mm2, mm7

movq	mm6,  [esi+16*1]
movq	mm3, mm0

movq	locqwtmp12o, mm2	; store tmp12 cols. 1,3
paddd	mm0, mm1

movq	mm7,  [edi+16*1]

movq	locqwtmp11e, mm0	; store tmp11 cols. 0,2
psubd	mm1, mm3

movq	mm0,  [esi+16*7]
pmullw	mm6, mm7	; dequant. C1 = tmp3

movq	locqwtmp12e, mm1

;; completed the even part.
;; Now start the odd part

movq	mm1,  [edi+16*7]	; get C7

movq	mm2,  [esi+16*5]	; get C5
pmullw	mm0, mm1	; dequant. C7 = tmp0

movq	mm3,  [edi+16*5]

movq	mm4,  [esi+16*3]
pmullw	mm2, mm3	; dequant. C5 = tmp1

movq	mm5,  [edi+16*3]
movq	mm1, mm0

movq	locqwtmp3, mm6
pmullw	mm4, mm5	; dequant. C3 = tmp2

movq	locqwtmp0, mm0
paddw	mm0, mm6	; z1 

movq	locqwtmp1, mm2
movq	mm3, mm2

movq	locqwtmp2, mm4
paddw	mm2, mm4	; z2

paddw	mm1, mm4	; z3

movq	mm4,  const_1_175
paddw	mm3, mm6	; z4	

movq	mm5, mm1
movq	mm7, mm0

psrlq	mm7, 16		; other two cols. of z1
paddw	mm5, mm3	; z3 + z4

movq	mm6, mm5
pmaddwd	mm5, mm4	; z5 cols 0 & 2

pmaddwd	mm0,  const_0_899	; z1 even part
psrlq	mm6, 16

pmaddwd	mm6, mm4	; z5 cols 1 & 3
movq	mm4, mm2	; z2 copy

movq	locqwz5e, mm5
psrlq	mm4, 16		; get z2 cols 1 & 3

pxor	mm0,  const_all_ones
movq	mm5, mm1

movq	locqwz5o, mm6
psrlq	mm5, 16

movq	mm6,  const_2_562
nop

paddd	mm0,  const_0_1_0_1
pmaddwd	mm2, mm6	; z2 cols 0 & 2

movq	locqwz1e, mm0
pmaddwd	mm4, mm6	; z2 cols 1 & 3

pmaddwd	mm7,  const_0_899	; z1
movq	mm0, mm3

movq	mm6,  const_1_961
psrlq	mm0, 16

pxor	mm2,  const_all_ones
pmaddwd	mm1, mm6	; z3 cols 0 & 2

paddd	mm2,  const_0_1_0_1
pmaddwd	mm5, mm6	; z3 cols 1 & 3

movq	mm6,  const_0_3901
nop

pxor	mm4,  const_all_ones
pmaddwd	mm3, mm6	; z4 cols 0 & 2

paddd	mm4,  const_0_1_0_1
pmaddwd	mm0, mm6	; z4 cols 1 & 3

movq	mm6,  const_all_ones
nop

pxor	mm1, mm6
pxor	mm7, mm6

;; twos complement of z1, z2, z3, z4

paddd	mm1,  const_0_1_0_1	
pxor	mm5, mm6

paddd	mm7,  const_0_1_0_1
pxor	mm3, mm6

paddd	mm5,  const_0_1_0_1
nop

movq	locqwz1o, mm7
pxor	mm0, mm6

paddd	mm1, locqwz5e	; z3+z5 cols 0 & 2
nop

movq	mm6, locqwz1e
nop

paddd	mm5, locqwz5o	; z3+z5 cols 1 & 3
paddd	mm6, mm1

paddd	mm3,  const_0_1_0_1
paddd	mm1, mm2

paddd	mm0,  const_0_1_0_1
paddd	mm7, mm5

paddd	mm3, locqwz5e	; z4+z5 cols 0 & 2
paddd	mm5, mm4

paddd	mm0, locqwz5o	; z4+z5 cols 0 & 2
paddd	mm2, mm3

paddd	mm3, locqwz1e
paddd	mm4, mm0

paddd	mm0, locqwz1o

movq	locqwz23e, mm1
nop

movq	locqwz14o, mm0
nop

movq	mm0, locqwtmp0
nop

movq	locqwz24e, mm2
movq	mm1, mm0

movq	mm2,  const_0_2986
psrlq	mm1, 16

movq	locqwz14e, mm3
pmaddwd	mm0, mm2	; tmp0 even

movq	mm3, locqwtmp1
pmaddwd	mm1, mm2	; tmp0 odd

movq	locqwz24o, mm4
movq	mm2, mm3

movq	mm4,  const_2_053
psrlq	mm2, 16

movq	locqwz23o, mm5
pmaddwd	mm3, mm4	; tmp1 even

movq	mm5, locqwtmp2
pmaddwd	mm2, mm4	; tmp1 odd

movq	locqwz13e, mm6
movq	mm4, mm5

movq	mm6,  const_3_072
psrlq	mm4, 16

movq	locqwz13o, mm7
pmaddwd	mm5, mm6	; tmp2 even
	
;;;;;;; now calculate tmp0..tmp3
;; then calculate the pre-descaled values
;; this includes the right shift with rounding

movq	mm7, locqwtmp3
pmaddwd	mm4, mm6	; tmp2 odd

paddd	mm0, locqwz13e
movq	mm6, mm7

paddd	mm1, locqwz13o
psrlq	mm6, 16

movq	locqwtmp0e, mm0		; tmp0 even
nop

movq	mm0,  const_1_501
nop

movq	locqwtmp0o, mm1
pmaddwd	mm7, mm0

paddd	mm3, locqwz24e
pmaddwd	mm6, mm0

movq	mm0, locqwtmp10e
nop

paddd	mm7, locqwz14e
nop

paddd	mm6, locqwz14o
psubd	mm0, mm7

movq	mm1, locqwtmp10o
nop

movq	locqwtmp1e, mm3
psubd	mm1, mm6

movq	mm3,  const_round
nop

paddd	mm2, locqwz24o
paddd	mm0, mm3

paddd	mm7, locqwtmp10e
psrad	mm0, 11

movq	locqwtmp1o, mm2
paddd	mm1, mm3

paddd	mm6, locqwtmp10o
psrad	mm1, 11

paddd	mm5, locqwz23e
movq	mm2, mm0

paddd	mm4, locqwz23o
punpcklwd	mm0, mm1

paddd	mm6, mm3
punpckhwd	mm2, mm1

paddd	mm7, mm3
punpckldq	mm0, mm2

;; now do all the stores of the 1D-iDCT of the four columns

mov		edi, locdwwsptr	; get pointer to scratch pad array

movq	 [edi+16*7], mm0	; store wsptr[7]
psrad	mm6, 11

movq	mm2, locqwtmp11e
psrad	mm7, 11

psubd	mm2, mm5
movq	mm0, mm7

movq	mm1, locqwtmp11o
punpcklwd	mm7, mm6

psubd	mm1, mm4
punpckhwd	mm0, mm6

paddd	mm5, locqwtmp11e
punpckldq	mm7, mm0

paddd	mm4, locqwtmp11o
paddd	mm2, mm3

paddd	mm1, mm3
paddd	mm5, mm3

paddd	mm4, mm3
psrad	mm2, 11

movq	 [edi+16*0], mm7	; store wsptr[0]
psrad	mm1, 11

movq	mm0, mm2
psrad	mm5, 11

movq	mm6, locqwtmp12e
punpcklwd	mm2, mm1

punpckhwd	mm0, mm1
movq	mm1, mm5

movq	mm7, locqwtmp12o
punpckldq	mm2, mm0

movq	 [edi+16*6], mm2	; store wsptr[6]
psrad	mm4, 11

movq	mm2, mm6
punpcklwd	mm5, mm4

paddd	mm6, locqwtmp1e
punpckhwd	mm1, mm4

psubd	mm2, locqwtmp1e
punpckldq	mm5, mm1

movq	 [edi+16*1], mm5	; store wsptr[1]
movq	mm0, mm7

paddd	mm7, locqwtmp1o
paddd	mm6, mm3

psubd	mm0, locqwtmp1o
paddd	mm7, mm3

paddd	mm2, mm3
psrad	mm7, 11

paddd	mm0, mm3
psrad	mm6, 11

movq	mm1, mm6
psrad	mm2, 11

movq	mm4, locqwtmp13e
punpcklwd	mm6, mm7

movq	mm5, mm4
punpckhwd	mm1, mm7

paddd	mm4, locqwtmp0e
punpckldq	mm6, mm1

psubd	mm5, locqwtmp0e
psrad	mm0, 11

movq	 [edi+16*2], mm6	; store wsptr[2]
movq	mm6, mm2

paddd	mm4, mm3
punpcklwd	mm2, mm0

paddd	mm5, mm3
punpckhwd	mm6, mm0

movq	mm0, locqwtmp13o
punpckldq	mm2, mm6

movq	mm1, mm0
psrad	mm4, 11

paddd	mm0, locqwtmp0o
psrad	mm5, 11

paddd	mm0, mm3
movq	mm6, mm4

psubd	mm1, locqwtmp0o
psrad	mm0, 11

paddd	mm1, mm3
punpcklwd	mm4, mm0

movq	mm3, mm5
punpckhwd	mm6, mm0

movq	 [edi+16*5], mm2	; store wsptr[5]
punpckldq	mm4, mm6

psrad	mm1, 11

movq	 [edi+16*3], mm4	; store wsptr[3]
punpcklwd	mm5, mm1

punpckhwd	mm3, mm1

punpckldq	mm5, mm3

add locdwinptr, 8	; skip first four columns
add	locdwqptr,  8

movq	 [edi+16*4], mm5	; store wsptr[4]


;;;;;;; done with 1D-idct of four columns ;;;;;;;

;; now update pointers for next four columns

add locdwwsptr, 8
mov	eax, locdwcounter

dec eax

mov locdwcounter, eax
jnz idct_column

;;;;;;;end of 1D-idct on the columns ;;;;;;;

mov	esi, wsptr	; get start addr of temp array
mov locdwcounter, 8

mov	locdwwsptr, esi
mov	locdwrowctr, 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;; start of 1D-idct on the rows ;;;;;;;


idct_row:

mov	esi, locdwwsptr	; get next row start addr of temp array
mov	edi, output_buf	

movq	mm0,  [esi+0]	; get first 4 elements of row

movq	mm1,  [esi+2*4] ; get next 4 elem. of row
movq	mm2, mm0

movq	mm3, mm0	; copy of e3|e2|e1|e0
paddw	mm2, mm1	; (e3+e7)|(e2+e6)|(e1+e5)|(e0+e4)

movq	mm4, mm2	; copy of (e3+e7)|(e2+e6)|(e1+e5)|(e0+e4)
punpckhdq	mm3, mm1	; e7|e6|e3|e2

pmaddwd	mm3,  const_00_1_84_00_0_765	; (tmp2 - z1)||(tmp3-z1)
movq	mm6, mm0	; copy of e3|e2|e1|e0

pmaddwd	mm2,  const_00_0_5411_00_00	; z1||xxx
psubw	mm6, mm1	; (e3-e7)|(e2-e6)|(e1-e5)|(e0-e4)

punpckldq	mm4, mm6	; (e1-e5)|(e0-e4)|(e1+e5)|(e0+e4)
movq	mm6, mm0	; 

movq	mm5, mm3
pslld	mm4, 16	; (e0-e4)|(e1+e5)||(e0+e4)|x0000

pxor	mm3,  const_all_ones
punpckhdq	mm2, mm2	; z1||z1

paddd	mm3,  const_0_1_0_1
psrad	mm4, 3	; (e0-e4)<<13||(e0+e4)<<13

psrlq	mm3, 32
movq	mm7, mm4	; copy of tmp1||tmp0

punpckldq	mm5, mm3
movq	mm3, mm0	; e3|e2|e1|e0

paddd	mm5, mm2		; tmp2 || tmp3
paddw	mm3, mm1	; (e7+e3)|(e2+e6)|(e1+e5)|(e0+e4)

paddd	mm4, mm5
psubd	mm7, mm5


;; end of even part calculation ;;
;; mm0 => e3|e2|e1|e0
;; mm1 => e7|e6|e5|e4
;; mm4 => tmp11||tmp10
;; mm7 => tmp12||tmp13

movq	mm5, mm3
movq	mm2, mm0

pmaddwd	mm0,  const_3_072_00_1_501_00	; tmp2|tmp3
punpckldq	mm5, mm5

paddw	mm5, mm3
punpckldq	mm2, mm2

pmaddwd	mm5,  const_1_175_00_00_00		; z5|0
punpckhdq	mm6, mm2

pmaddwd		mm3,  const_1_96_00_0_3901_00	; z3|z4
paddw	mm6, mm1

pmaddwd		mm6,  const_0_899_00_2_562_00	; z1|z2
nop

pmaddwd		mm1,  const_0_2986_00_2_053_00	; tmp0|tmp1
punpckhdq	mm5, mm5

movq	mm2,  const_0_1_0_1
nop

pxor	mm3,  const_all_ones
nop

pxor	mm6,  const_all_ones
paddd	mm3, mm2

paddd	mm6, mm2
paddd	mm3, mm5

movq	mm5, mm6
paddd	mm6, mm3

movq	mm2, mm5
punpckldq	mm5, mm5

punpckhdq	mm2, mm5
paddd	mm1, mm6

paddd	mm2, mm3
movq	mm5, mm1

movq	mm3, mm4
paddd	mm0, mm2

movq	mm2, mm7
punpckldq	mm5, mm5

punpckhdq	mm1, mm5
psubd	mm3, mm0

movq	mm5,  const_round_two
paddd	mm0, mm4

movq	mm6,  const_mask
psubd	mm2, mm1

paddd	mm0, mm5
paddd	mm1, mm7



;; descale the resulting coeff values
paddd	mm1, mm5
psrad	mm0, 18

paddd	mm3, mm5
psrad	mm1, 18

paddd	mm2, mm5
psrad	mm3, 18


;; mask the result with RANGE_MASK (least 10 bits)
pand	mm1, mm6	; w2|w3
psrad	mm2, 18

movd	ebx, mm1	; w3
psrlq	mm1, 32		; 0|w2

;; using the results as index, get the corresponding
;; value from array range_limit and store the final result

mov		ecx, range_limit	; get start addr of range_limit array
add	edi, locdwrowctr

movd	edx, mm1	; w2
pand	mm0, mm6	; w1|w0

mov		ah, [ecx][ebx]	; w3
mov		edi, [edi]

movd	ebx, mm0	; w0
psrlq	mm0, 32		; 0|w1

mov		al, [ecx][edx]	; w2
add	locdwrowctr, 4

movd	edx, mm0	; w1
pand	mm3, mm6	; w6|w7

add	edi, output_col	; this is the dest start addr for this row
shl		eax, 16		; w3|w2|0|0

mov		al, [ecx][ebx]	; w0

mov		ah, [ecx][edx]	; w1

movd	mm4, eax	; w3|w2|w1|w0
pand	mm2, mm6	; w5|w4

movd	ebx, mm3	; w7
psrlq	mm3, 32		; 0|w6

movd	edx, mm3	; w6

mov		ah, [ecx][ebx]	; w7

mov		al, [ecx][edx]	; w6

movd	ebx, mm2	; w4
psrlq	mm2, 32		; 0|w5

shl		eax, 16		; w7|w6|0|0

movd	edx, mm2	; w5

mov		al, [ecx][ebx]	; w4

mov		ah, [ecx][edx]	; w5

movd	mm5, eax	; w7|w6|w5|w4

punpckldq	mm4, mm5	; w7|w6|w5|w4|w3|w2|w1|w0

add	locdwwsptr, 16
mov	eax, locdwcounter

movq	 [edi], mm4

;; update address pointer and loop counter

dec eax

mov	locdwcounter, eax
jnz	idct_row

;;;;;;; end of 1D-idct on all the rows ;;;;;;;
 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

emms


} //end of __asm

}


#endif /* X86 */

#endif /* DCT_ISLOW_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\siteguid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       siteguid.h
//
//  Contents:   extern references for site guids and manifest constants
//              for dispids
//
//----------------------------------------------------------------------------

//
// Reserve 10000 GUID entries beginning 3050f160-98b5-11cf-bb82-00aa00bdce0b
// and ending at 30c38c70-98b5-11cf-bb82-00aa00bdce0b.
//
// See the next available GUID in ...\src\guids.txt
// Check procedure for using next available GUID with F3 procedures handbook
//

#ifndef I_SITEGUID_H_
#define I_SITEGUID_H_
#pragma INCMSG("--- Beg 'siteguid.h'")

// Use PUBLIC_GUID for GUIDs used outside FORMS3.DLL.
// Use PRIVATE_GUID for all other GUIDS.

#ifndef PUBLIC_GUID
#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

#ifndef PRIVATE_GUID
#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

PUBLIC_GUID(CLSID_CTextSite,  0x3050f35e, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CTextEdit,  0x3050f330, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CRange,     0x3050f234, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CElement,   0x3050f233, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CStyle,     0x3050f499, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CElementCollection,   0x3050f627, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CAttribute, 0x3050f6a1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_CDocument,  0x3050f83b, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(CLSID_CMarkup,         0x3050F4FB, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)
PRIVATE_GUID(CLSID_CTreeNode,       0x3050F432, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)
PRIVATE_GUID(CLSID_CMarkupPointer,  0x3050f4a5, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)
PRIVATE_GUID(CLSID_CDisplayPointer, 0x3050f69f, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)
PRIVATE_GUID(CLSID_CComputedStyle,  0x3050f6c4, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)
PRIVATE_GUID(CLSID_CHighlightSegment, 0x3050f694, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)

// ********************** DO NOT REMOVE the below GUID. **********************
//
// IE4 shipped the interface IHTMLControlElement with the same GUID as IControl
// from forms^3 this is of course bad.  To resolve this problem Trident's
// GUID for IHTMLControlElement has changed however, the old GUID remembered in
// the QI for CSite to return IHTMLControlElement.  The only side affect is that
// using the old GUID will not marshall the interface correctly only the new
// GUID has the correct marshalling code.

// {04598fc6-866c-11cf-ab7c-00aa00c08fcf}
PRIVATE_GUID(IID_IControl, 0x04598fc6, 0x866c, 0x11cf, 0xab, 0x7c, 0x00, 0xaa, 0x00, 0xc0, 0x8f, 0xcf);

#pragma INCMSG("--- End 'siteguid.h'")
#else
#pragma INCMSG("*** Dup 'siteguid.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\tomconst.h ===
// These are constants defined in tom.h

#ifndef I_TOMCONST_H_
#define I_TOMCONST_H_
#pragma INCMSG("--- Beg 'tomconst.h'")

typedef enum {
    tomFalse = 0,
    tomTrue = -1,
    tomUndefined = -9999999,
    tomToggle = -9999998,
    tomAutoColor = -9999997,
    tomDefault = -9999996,
    tomBackward = -1073741825,
    tomForward = 1073741823,
    tomMove = 0,
    tomExtend = 1,
    tomNoSelection = 0,
    tomSelectionIP = 1,
    tomSelectionNormal = 2,
    tomSelectionObject = 3,
    tomSelectionFrame = 4,
    tomSelectionColumn = 5,
    tomSelectionRow = 6,
    tomSelectionBlock = 7,
    tomSelectionPicture = 8,
    tomSelectionShape = 9,
    tomSelStartActive = 1,
    tomSelAtEOL = 2,
    tomSelOvertype = 4,
    tomSelActive = 8,
    tomSelReplace = 16,
    tomEnd = 0,
    tomStart = 32,
    tomNone = 0,
    tomSingle = 1,
    tomWords = 2,
    tomDouble = 3,
    tomDotted = 4,
    tomLineSpaceSingle = 0,
    tomLineSpace1pt5 = 1,
    tomLineSpaceDouble = 2,
    tomLineSpaceAtLeast = 3,
    tomLineSpaceExactly = 4,
    tomLineSpaceMultiple = 5,
    tomAlignLeft = 0,
    tomAlignCenter = 1,
    tomAlignRight = 2,
    tomAlignJustify = 3,
    tomAlignDecimal = 3,
    tomAlignChar = 4,
    tomAlignBar = 5,
    tomSpaces = 0,
    tomDots = 1,
    tomDashes = 2,
    tomLines = 3,
    tomTabBack = -3,
    tomTabNext = -2,
    tomTabHere = -1,
    tomListNone = 0,
    tomListBullet = 1,
    tomListNumberAsArabic = 2,
    tomListNumberAsLCLetter = 3,
    tomListNumberAsUCLetter = 4,
    tomListNumberAsLCRoman = 5,
    tomListNumberAsUCRoman = 6,
    tomListNumberAsSequence = 7,
    tomListParentheses = 65536,
    tomListPeriod = 131072,
    tomListPlain = 196608,
    tomCharacter = 1,
    tomWord = 2,
    tomSentence = 3,
    tomParagraph = 4,
    tomLine = 5,
    tomStory = 6,
    tomScreen = 7,
    tomSection = 8,
    tomColumn = 9,
    tomRow = 10,
    tomWindow = 11,
    tomCell = 12,
    tomCharFormat = 13,
    tomParaFormat = 14,
    tomTable = 15,
    tomObject = 16,
    tomMatchWord = 2,
    tomMatchCase = 4,
    tomMatchPattern = 8,
    tomUnknownStory = 0,
    tomMainTextStory = 1,
    tomFootnotesStory = 2,
    tomEndnotesStory = 3,
    tomCommentsStory = 4,
    tomHeadersStory = 5,
    tomFootersStory = 6,
    tomTextboxStory = 7,
    tomNoAnimation = 0,
    tomBlinkingText = 1,
    tomBlinkingBackground = 2,
    tomSparkleText = 3,
    tomBlackMarchingAnts = 4,
    tomRedMarchingAnts = 5,
    tomWipeDown = 6,
    tomWipeRight = 7,
    tomLasVegasLights = 8,
    tomFadeOut = 9,
    tomShimmer = 10,
    tomScrollRight = 11,
    tomScrollDown = 12,
    tomMeltingText = 13,
    tomShrinkingText = 14,
    tomSquish = 15,
    tomWave = 16,
    tomFlameText = 17,
    tomBlinkingColors = 18,
    tomSentenceCase = 0,
    tomLowerCase = 1,
    tomUpperCase = 2,
    tomTitleCase = 3,
    tomToggleCase = 4,
    tomReadOnly = 256,
    tomShareDenyRead = 512,
    tomShareDenyWrite = 1024,
    tomPasteFile = 4096,
    tomCreateNew = 16,
    tomCreateAlways = 32,
    tomOpenExisting = 48,
    tomOpenAlways = 64,
    tomTruncateExisting = 80,
    tomRTF = 1,
    tomText = 2,
    tomHTML = 3,
    tomWordDocument = 4
} tomConstants;

#pragma INCMSG("--- End 'tomconst.h'")
#else
#pragma INCMSG("*** Dup 'tomconst.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\uniwbk.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIWBK.HXX -- Unicode Word-breaking Classes
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      06/19/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef I__UNIWBK_H_
#define I__UNIWBK_H_
#pragma INCMSG("--- Beg 'uniwbk.h'")

typedef BYTE CHAR_CLASS;
typedef BYTE WBKCLS;

enum
{
    wbkclsPunctSymb,     // 0
    wbkclsKanaFollow,    // 1
    wbkclsKatakanaW,     // 2
    wbkclsHiragana,      // 3
    wbkclsTab,           // 4
    wbkclsKanaDelim,     // 5
    wbkclsPrefix,        // 6
    wbkclsPostfix,       // 7
    wbkclsSpaceA,        // 8
    wbkclsAlpha,         // 9
    wbkclsIdeoW,         // 10
    wbkclsSuperSub,      // 11
    wbkclsDigitsN,       // 12
    wbkclsPunctInText,   // 13
    wbkclsDigitsW,       // 14
    wbkclsKatakanaN,     // 15
    wbkclsHangul,        // 16
    wbkclsLatinW,        // 17
    wbkclsLim
};

WBKCLS WordBreakClassFromCharClass( CHAR_CLASS cc );
BOOL   IsWordBreakBoundaryDefault( WCHAR, WCHAR );
BOOL   IsProofWordBreakBoundary( WCHAR, WCHAR );
BOOL   IsURLBreak( WCHAR );

#pragma INCMSG("--- End 'uniwbk.h'")
#else
#pragma INCMSG("*** Dup 'uniwbk.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\uniprop.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIPROP.H -- Unicode property bits
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      11/30/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef I__UNIPROP_H_
#define I__UNIPROP_H_
#pragma INCMSG("--- Beg 'uniprop.h'")

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

struct tagUNIPROP
{
    BYTE fNeedsGlyphing     : 1;    // partition needs glyphing
    BYTE fCombiningMark     : 1;    // partition consists of combining marks
    BYTE fZeroWidth         : 1;    // characters in partition have zero width
    BYTE fWhiteBetweenWords : 1;    // white space between words not required
    BYTE fMoveByCluster     : 1;    // The caret cannot be positioned inside of a cluster
    BYTE fUnused            : 3;    // unused bits
};

typedef tagUNIPROP UNIPROP;

extern const UNIPROP s_aPropBitsFromCharClass[];

#pragma INCMSG("--- End 'uniprop.h'")
#else
#pragma INCMSG("*** Dup 'uniprop.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\siterc.h ===
To be removed

//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       siterc.h
//
//  Contents:   Resource identifiers for Site directory tree
//
//----------------------------------------------------------------------------

#ifndef I_SITERC_H_
#define I_SITERC_H_
#pragma INCMSG("--- Beg 'siterc.h'")

//----------------------------------------------------------------------------
//
// Registered servers
//
//  00900 - 00999    Site registered servers
//  08000 - 08999    Site miscellaneous
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Registered servers
//
//----------------------------------------------------------------------------


// HTML Form

#define IDR_BASE_HTMLFORM           900
#define IDS_HTMLFORM_USERTYPEFULL   180
#define IDS_HTMLFORM_USERTYPESHORT  181
#define IDR_HTMLFORM_TOOLBOXBITMAP  905
#define IDR_HTMLFORM_ACCELS         906
#define IDR_HTMLFORM_MENUDESIGN     907
#define IDR_HTMLFORM_MENURUN        908
#define IDR_HTMLFORM_DOCDIR         909


//----------------------------------------------------------------------------
//
// Errors
//
//----------------------------------------------------------------------------

#define IDS_SITE_BASE      7999

#define IDS_ACT_UPDATEPROPS          (IDS_SITE_BASE + 1)
#define IDS_ACT_DDOCSTARTUP          (IDS_SITE_BASE + 2)
#define IDS_ERR_DDOCPOPULATEFAILED   (IDS_SITE_BASE + 3)
#define IDS_ERR_DDOCGENERAL          (IDS_SITE_BASE + 4)
#define IDS_ACT_DDOCSCROLLGENERAL    (IDS_SITE_BASE + 5)
#define IDS_ACT_DDOCSCROLLLINEUP     (IDS_SITE_BASE + 6)
#define IDS_ACT_DDOCSCROLLLINEDOWN   (IDS_SITE_BASE + 7)
#define IDS_ACT_DDOCSCROLLPAGEUP     (IDS_SITE_BASE + 8)
#define IDS_ACT_DDOCSCROLLPAGEDOWN   (IDS_SITE_BASE + 9)
#define IDS_ACT_DDOCSCROLLEND        (IDS_SITE_BASE + 10)

#define IDS_SYNTAX_ERROR             (IDS_SITE_BASE + 12)    // "Syntax error in file %s (line %n): %s"
#define IDS_LAYOUTSELTOOL            (IDS_SITE_BASE + 13)
#define IDS_ACT_DDOCAFTERLOAD        (IDS_SITE_BASE + 14)
#define IDS_LOADTEXT                 (IDS_SITE_BASE + 15)
#define IDS_LOADTEXTUNKNOWNPROP      (IDS_SITE_BASE + 16)
#define IDS_CONTAINERTEXT            (IDS_SITE_BASE + 17)
#define IDS_TEXTSITETEXT             (IDS_SITE_BASE + 18)
#define IDS_HTMLDEFAULTFONT          (IDS_SITE_BASE + 19)

#define IDS_NAMEDPROPERTIES          (IDS_SITE_BASE + 21)
#define IDS_UNNAMEDPROPERTIES        (IDS_SITE_BASE + 22)

#define IDS_ERR_SAVEPICTUREAS        (IDS_SITE_BASE + 26)
#define IDS_ERR_SETWALLPAPER         (IDS_SITE_BASE + 27)

#define IDS_RUNAWAYSCRIPT            (IDS_SITE_BASE + 29)
#define IDS_PROTECTEDFROMUNSAFEOCX   (IDS_SITE_BASE + 31)
#define IDS_PROTECTEDFROMOCXINIT     (IDS_SITE_BASE + 32)
#define IDS_REPOSTFORMDATA           (IDS_SITE_BASE + 33)
#define IDS_OCXDISABLED              (IDS_SITE_BASE + 34)
#define IDS_MISMATCHEDXML            (IDS_SITE_BASE + 35)
#define IDS_DEBUGCONTINUE            (IDS_SITE_BASE + 36)
#define IDS_FMTDEBUGCONTINUE         (IDS_SITE_BASE + 37)
#define IDS_ERR_SETDESKTOPITEM       (IDS_SITE_BASE + 38)

#define IDC_SITE_CURSORBASE         9800
#define IDC_HYPERLINK               9801
#define IDC_HYPERLINK_OFFLINE       9802
#define IDC_HYPERLINK_WAIT          9803

// Menu index
#define MENU_INDEX_EDIT             1
#define MENU_INDEX_VIEW             2
#define MENU_INDEX_INSERT           3
#define MENU_INDEX_FORMAT           4
#define MENU_INDEX_TABLE            5

#define IDS_HTMLFORM_SAVE                   8114
#define IDS_2DFORM_SAVE                     8115
#define IDS_SAVEPICTUREAS_GIF               8116
#define IDS_SAVEPICTUREAS_JPG               8117
#define IDS_SAVEPICTUREAS_BMP               8118
#define IDS_SAVEPICTUREAS_XBM               8119
#define IDS_SAVEPICTUREAS_ART               8120
#define IDS_SAVEPICTUREAS_WMF               8121
#define IDS_SAVEPICTUREAS_EMF               8122
#define IDS_SAVEPICTUREAS_AVI               8123
#define IDS_SAVEPICTUREAS_MPG               8124
#define IDS_SAVEPICTUREAS_MOV               8125
#define IDS_SAVEPICTUREAS_ORIGINAL          8126
#define IDS_UNTITLED_BITMAP                 8127
#define IDS_UNTITLED                        8128
#define IDS_WALLPAPER_BMP                   8129

// default document security property
#define IDS_DEFAULT_DOC_SECURITY_PROP       8130

// Jave Script prompt() dialog
#define IDD_PROMPT                          8131
#define IDC_PROMPT_PROMPT                   8132
#define IDC_PROMPT_EDIT                     8133

// Plugin/ActiveX Viewer Not Installed dialog
#define IDD_PLUGIN_UPGRADE                  8134
#define IDC_PLUGIN_UPGRADE_CHECK            8135
#define IDC_PLUGIN_UPGRADE_EXTENSION        8136
#define IDC_PLUGIN_UPGRADE_MIME_TYPE        8137

// Save As string for PNG images
#define IDS_SAVEPICTUREAS_PNG               8138

//+----------------------------------------------------------------------------
//
// Progress status text strings
//
//-----------------------------------------------------------------------------

#define IDS_BINDSTATUS_DOWNLOADING                  8154
#define IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE      8155
#define IDS_BINDSTATUS_GENERATINGDATA_TEXT          8156
#define IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT         8157
#define IDS_BINDSTATUS_INSTALLINGCOMPONENTS         8160
#define IDS_BINDSTATUS_DOWNLOADINGDATA_BITS         8167

#define IDS_DONE                                    8169

#define IDS_LOADINGTABLE                            8170
#define IDS_DATABINDING                             8171

#define IDS_FRIENDLYURL_SHORTCUTTO                  8172
#define IDS_FRIENDLYURL_AT                          8173
#define IDS_FRIENDLYURL_SENDSMAILTO                 8174
#define IDS_FRIENDLYURL_LOCAL                       8175
#define IDS_FRIENDLYURL_GOPHER                      8176
#define IDS_FRIENDLYURL_FTP                         8177
#define IDS_FRIENDLYURL_SECUREWEBSITE               8178

#define IDS_CANNOTLOAD                              8193
#define IDS_ONBEFOREUNLOAD_PREAMBLE                 8194
#define IDS_ONBEFOREUNLOAD_POSTAMBLE                8195

#define IDS_DEFAULT_ISINDEX_PROMPT                  8196


// Add controls to the save as dialog.
#define IDC_SAVE_CHARSET                            8194

//+----------------------------------------------------------------------------
//
// string used in conversion GetIDsOfNames
//
//----------------------------------------------------------------------------

#define IDS_DISPID_FIRST                8200                       // matches:
#define IDS_DISPID_FONTNAME             (IDS_DISPID_FIRST +  1)    // DISPID_CommonCtrl_FONTNAME
#define IDS_DISPID_FONTSIZE             (IDS_DISPID_FIRST +  2)    // DISPID_CommonCtrl_FONTSIZE
#define IDS_DISPID_FONTBOLD             (IDS_DISPID_FIRST +  3)    // DISPID_CommonCtrl_FONTBOLD
#define IDS_DISPID_FONTITAL             (IDS_DISPID_FIRST +  4)    // DISPID_CommonCtrl_FONTITAL
#define IDS_DISPID_FONTUNDER            (IDS_DISPID_FIRST +  5)    // DISPID_CommonCtrl_FONTUNDER
#define IDS_DISPID_FONTSTRIKE           (IDS_DISPID_FIRST +  6)    // DISPID_CommonCtrl_FONTSTRIKE
#define IDS_DISPID_BACKCOLOR            (IDS_DISPID_FIRST +  7)    // DISPID_BACKCOLOR
#define IDS_DISPID_BORDERCOLOR          (IDS_DISPID_FIRST +  9)    // DISPID_BORDERCOLOR
#define IDS_DISPID_BORDERSTYLE          (IDS_DISPID_FIRST + 10)    // DISPID_BORDERSTYLE
#define IDS_DISPID_TEXTALIGN            (IDS_DISPID_FIRST + 11)    // DISPID_CommonCtrl_TextAlign
#define IDS_DISPID_SPECIALEFFECT        (IDS_DISPID_FIRST + 12)    // DISPID_CommonCtrl_SpecialEffect
#define IDS_DISPID_FONTSUPERSCRIPT      (IDS_DISPID_FIRST + 13)    // DISPID_CommonCtrl_FONTSUPERSCRIPT
#define IDS_DISPID_FONTSUBSCRIPT        (IDS_DISPID_FIRST + 14)    // DISPID_CommonCtrl_FONTSUBSCRIPT

//+----------------------------------------------------------------------------
//
// string used by script window
//
//----------------------------------------------------------------------------

#define IDS_OMWINDOW_FIRST             8300

#define IDS_VAR2STR_VTERROR             (IDS_OMWINDOW_FIRST + 0)
#define IDS_VAR2STR_VTNULL              (IDS_OMWINDOW_FIRST + 1)
#define IDS_VAR2STR_VTBOOL_TRUE         (IDS_OMWINDOW_FIRST + 2)
#define IDS_VAR2STR_VTBOOL_FALSE        (IDS_OMWINDOW_FIRST + 3)

//+----------------------------------------------------------------------------
//
//  Printing constants
//
//----------------------------------------------------------------------------

#define IDS_PRINT_FIRST                 8400

#define IDS_PRINT_URLTITLE              8400
#define IDS_PRINT_URLCOL1HEAD           8401
#define IDS_PRINT_URLCOL2HEAD           8402
#define IDS_DEFAULTHEADER               8403
#define IDS_DEFAULTFOOTER               8404
#define IDS_DEFAULTMARGINTOP            8405
#define IDS_DEFAULTMARGINBOTTOM         8406
#define IDS_DEFAULTMARGINLEFT           8407
#define IDS_DEFAULTMARGINRIGHT          8408

#ifdef  UNIX
#define IDU_DEFAULTPRINTNAME  		8430
#define IDU_DEFAULTPRINTCOMMAND  	8431
#endif  // UNIX
//+----------------------------------------------------------------------------
//
//  Button caption constants
//
//----------------------------------------------------------------------------

#define IDS_BUTTONCAPTION_FIRST         8500

#define IDS_BUTTONCAPTION_RESET         8500
#define IDS_BUTTONCAPTION_SUBMIT        8501
#define IDS_BUTTONCAPTION_UPLOAD        8502

//+----------------------------------------------------------------------------
//
//   MailTo constants
//
//----------------------------------------------------------------------------

#define IDS_MAILTO_FIRST                8600
#define IDS_MAILTO_DEFAULTSUBJECT       8600
#define IDS_MAILTO_MAILCLIENTNOTFOUND   8601
#define IDS_MAILTO_SUBMITALERT          8602


//+-------------------------------------------------------------------------
//
//  Property frame
//  (peterlee) moved to shdocvw
//--------------------------------------------------------------------------
#ifdef NEVER
        #define IDD_PROPFRM_DELAYCOMMIT     5400
        #define IDD_PROPFRM_IMMEDCOMMIT     5401
        #define IDC_PROPFRM_TABS            5402
        #define IDC_PROPFRM_APPLY           5403
        #define IDR_PROPFRM_ICON            5404
        #define IDI_PROPDLG_COMBO           44
        #define IDI_PROPDLG_TABS            IDC_PROPFRM_TABS
        #define IDI_PROPDLG_APPLY           IDC_PROPFRM_APPLY
        #define IDR_PROPERTIES_DIALOG       IDD_PROPFRM_DELAYCOMMIT

        #define IDS_PROPFRM_APPLY           5416
        #define IDS_PROPFRM_CLOSE           5417
        #define IDS_PROPFRM_CHANGES         5418
        #define IDS_PROPFRM_DEFCAPTION      5419
        #define IDS_PROPFRM_MULTOBJCAPTION  5420
        #define IDS_PROPFRM_TYPECAPTION     5421
        #define IDS_PROPFRM_UNDOCHANGE      5422
        #define IDS_PROPFRM_SIZETOFIT       5423
#endif // NEVER

#define IDS_CONTAINERPAGE_ACCEL     5424

#if DBG == 1

#define IDS_COLOR_BLACK             5430
#define IDS_COLOR_NAVY              5431
#define IDS_COLOR_BLUE              5432
#define IDS_COLOR_CYAN              5433
#define IDS_COLOR_RED               5434
#define IDS_COLOR_LIME              5435
#define IDS_COLOR_GRAY              5436
#define IDS_COLOR_GREEN             5437
#define IDS_COLOR_YELLOW            5438
#define IDS_COLOR_PINK              5439
#define IDS_COLOR_VIOLET            5440
#define IDS_COLOR_WHITE             5441
// 5442 and 5443 replaced by html dialogs

#endif // DBG == 1

#define IDS_UPLOADFILE              5444

#ifdef UNIX
#  define IDS_PRINT_ERROR             5445
#  define IDS_PRINT_ERROR_MSG         5446
#endif

#ifndef NO_HTML_DIALOG
// find resources are now located in shdocvw (peterlee)
//#define IDR_FINDDIALOG              _T("find.dlg")
//#define IDR_BIDIFINDDIALOG          _T("bidifind.dlg")
#define IDR_REPLACEDIALOG           _T("replace.dlg")
#define IDR_FORPARDIALOG            _T("forpar.dlg")
#define IDR_FORCHARDIALOG           _T("forchar.dlg")
#define IDR_GOBOOKDIALOG            _T("gobook.dlg")
#define IDR_INSIMAGEDIALOG          _T("insimage.dlg")
#define IDR_EDLINKDIALOG            _T("edlink.dlg")
#define IDR_EDBOOKDIALOG            _T("edbook.dlg")
#endif // NO_HTML_DIALOG

#define IDR_PRINTTEMPLATE           _T("preview.dlg")

// property grids removed (peterlee)
#ifdef NEVER
        #ifndef NO_PROPERTY_PAGE
        #define IDR_BACKGRNDPPG             _T("backgrnd.ppg")
        #endif // NO_PROPERTY_PAGE
#endif // NEVER

// New Encoding Menu
#define RES_STRING_ENCODING_MORE            4700

#pragma INCMSG("--- End 'siterc.h'")
#else
#pragma INCMSG("*** Dup 'siterc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\textedit.h ===
/*
 *  TEXTEDIT.H
 *
 *
 *  Copyright (c) 1985-1996, Microsoft Corporation
 */

#ifndef I_TEXTEDIT_H_
#define I_TEXTEDIT_H_
#pragma INCMSG("--- Beg 'textedit.h'")

/* new word break function actions */
// Left must we even, right must be odd
#define WB_CLASSIFY         3
#define WB_MOVEWORDLEFT     4
#define WB_MOVEWORDRIGHT    5
#define WB_LEFTBREAK        6
#define WB_RIGHTBREAK       7
#define WB_MOVEURLLEFT      10
#define WB_MOVEURLRIGHT     11

/* Far East specific flags */
#define WB_MOVEWORDPREV     4
#define WB_MOVEWORDNEXT     5
#define WB_PREVBREAK        6
#define WB_NEXTBREAK        7

/* Word break flags (used with WB_CLASSIFY) */
#define WBF_CLASS           ((BYTE) 0x0F)
#define WBF_WHITE           ((BYTE) 0x10)
#define WBF_BREAKAFTER      ((BYTE) 0x20)
#define WBF_EATWHITE        ((BYTE) 0x40)

#define yHeightCharPtsMost 1638

// NOTE (cthrash) There's really no point in statically allocating an
// array of MAX_TAB_STOPS tabs, since currently we have no mechanism for
// changing them.  In the future, though, we may have via stylesheets a
// way of setting them.  Until then, let's not waste memory in PFs.

#define MAX_TAB_STOPS 1 //32
#define lDefaultTab 960 //720

/* Underline types */
#define CFU_OVERLINE_BITS   0xf0
#define CFU_UNDERLINE_BITS  0x0f
#define CFU_OVERLINE        0x10
#define CFU_STRIKE          0x20
#define CFU_SWITCHSTYLE     0x40
#define CFU_SQUIGGLE        0x80
#define CFU_UNDERLINETHICKDASH 0x6  /* For SmartTags.*/
#define CFU_INVERT          0x5 /* For IME composition fake a selection.*/
#define CFU_CF1UNDERLINE    0x4 /* map charformat's bit underline to CF2.*/
#define CFU_UNDERLINEDOTTED 0x3     /* (*) displayed as ordinary underline  */
#define CFU_UNDERLINEDOUBLE 0x2     /* (*) displayed as ordinary underline  */
#define CFU_UNDERLINEWORD   0x1     /* (*) displayed as ordinary underline  */
#define CFU_UNDERLINE       0x0

#pragma INCMSG("--- End 'textedit.h'")
#else
#pragma INCMSG("*** Dup 'textedit.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\wchdefs.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module WCHDEFS.H -- Wide chararacter definitions for Trident
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      01/09/98     cthrash created
 *      01/23/98     a-pauln added complex script support
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef I_WCHDEFS_H_
#define I_WCHDEFS_H_
#pragma INCMSG("--- Beg 'wchdefs.h'")

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// UNICODE special characters for Trident.
//

//
// If you need to allocate a special character for Trident, redefine one of
// the WCH_UNUSED characters.  Do no redefine WCH_RESERVED characters, as
// this would break rendering of symbol fonts.  If you run out of special
// chars the first candidate to be removed from the RESERVED list is 008A
// (only breaks 1253+1255) and the next is 009A (breaks 1253+1255+1256).
//
// If you make any modification, you need to modify the abUsed table so
// that our IsSyntheticChar and IsValidWideChar functions continue to work.
// Note also that WCH_EMBEDDING must be the first non-reserved character.
//
// Here's a bit of an explanation: Although U+0080 through U+009F are defined
// to be control characters in Unicode, many codepages used codepoints in this
// range for roundtripping characters not in their codepage.  For example,
// windows-1252 does not have a glyph for MB 0x80, but if you convert this to
// WC, you'll get U+0080.  This is useful to know because someone might try
// to use that codepoint (especially in a symbol font) and don't want to
// reject them.  To accomodate as many codepages as possible, I've reserved
// all the unused glyphs in Windows-125x.  This should allow us to use symbol
// fonts in any of these codepages (with, of course, the exception of U+00A0,
// which we'll always treat as an NBSP even if the font has a non-spacing
// glyph.)  Any questions? I'm just e-mail away. (cthrash)
//

//
// In Unicode 3.0 we have 32 characters for private use [U+FDD0-U+FDEF]
// So far we are using them for 'Synthetic characters' and 
// 'Line Services installed object handler support' (see below).
//

#undef WCH_EMBEDDING

#ifdef UNICODE
inline BOOL IsValidWideChar(TCHAR ch)
{
    return (ch < 0xfdd0) || ((ch > 0xfdef) && (ch <= 0xffef)) || ((ch >= 0xfff9) && (ch <= 0xfffd));
}
#else
#define IsValidWideChar(ch) FALSE
#endif

#define WCH_NULL                WCHAR(0x0000)
#define WCH_UNDEF               WCHAR(0x0001)
#define WCH_TAB                 WCHAR(0x0009)
#define WCH_LF                  WCHAR(0x000a)
#define WCH_CR                  WCHAR(0x000d)
#define WCH_SPACE               WCHAR(0x0020)
#define WCH_QUOTATIONMARK       WCHAR(0x0022)
#define WCH_AMPERSAND           WCHAR(0x0026)
#define WCH_APOSTROPHE          WCHAR(0x0027)
#define WCH_ASTERISK            WCHAR(0x002a)
#define WCH_PLUSSIGN            WCHAR(0x002b)
#define WCH_MINUSSIGN           WCHAR(0x002d)
#define WCH_HYPHEN              WCHAR(0x002d)
#define WCH_DOT                 WCHAR(0x002e)
#define WCH_LESSTHAN            WCHAR(0x003c)
#define WCH_GREATERTHAN         WCHAR(0x003e)
#define WCH_NONBREAKSPACE       WCHAR(0x00a0) // &nbsp;
#define WCH_NONREQHYPHEN        WCHAR(0x00ad) // &shy;
#define WCH_KASHIDA             WCHAR(0x0640)
#define WCH_ENQUAD              WCHAR(0x2000) 
#define WCH_EMQUAD              WCHAR(0x2001) 
#define WCH_ENSPACE             WCHAR(0x2002) // &ensp;
#define WCH_EMSPACE             WCHAR(0x2003) // &emsp;
#define WCH_THREE_PER_EM_SPACE  WCHAR(0x2004) 
#define WCH_FOUR_PER_EM_SPACE   WCHAR(0x2005) 
#define WCH_SIX_PER_EM_SPACE    WCHAR(0x2006) 
#define WCH_FIGURE_SPACE        WCHAR(0x2007) 
#define WCH_PUNCTUATION_SPACE   WCHAR(0x2008) 
#define WCH_NARROWSPACE         WCHAR(0x2009) // &thinsp;
#define WCH_NONBREAKHYPHEN      WCHAR(0x2011)
#define WCH_FIGUREDASH          WCHAR(0x2012)
#define WCH_ENDASH              WCHAR(0x2013) // &ndash;
#define WCH_EMDASH              WCHAR(0x2014) // &mdash;
#define WCH_ZWSP                WCHAR(0x200b) // &zwsp; Zero width space
#define WCH_ZWNJ                WCHAR(0x200c) // &zwnj; Zero width non-joiner
#define WCH_ZWJ                 WCHAR(0x200d) // &zwj;  Zero width joiner
#define WCH_LRM                 WCHAR(0x200e) // &lrm;  Left-to-right mark
#define WCH_RLM                 WCHAR(0x200f) // &rlm;  Right-to-left mark
#define WCH_LQUOTE              WCHAR(0x2018) // &lsquo;
#define WCH_RQUOTE              WCHAR(0x2019) // &rsquo;
#define WCH_LDBLQUOTE           WCHAR(0x201c) // &ldquo;
#define WCH_RDBLQUOTE           WCHAR(0x201d) // &rdquo;
#define WCH_BULLET              WCHAR(0x2022) // &bull;
#define WCH_HELLIPSIS           WCHAR(0x2026)
#define WCH_LRE                 WCHAR(0x202a) // &lre;  Left-to-right embedding
#define WCH_RLE                 WCHAR(0x202b) // &rle;  Right-to-left embedding
#define WCH_PDF                 WCHAR(0x202c) // &pdf;  Pop direction format
#define WCH_LRO                 WCHAR(0x202d) // &lro;  Left-to-right override
#define WCH_RLO                 WCHAR(0x202e) // &rlo;  Right-to-left override
#define WCH_ISS                 WCHAR(0x206a) // &iss;  Inhibit symmetric swapping
#define WCH_ASS                 WCHAR(0x206b) // &ass;  Activate symmetric swapping
#define WCH_IAFS                WCHAR(0x206c) // &iafs; Inhibit Arabic form shaping
#define WCH_AAFS                WCHAR(0x206d) // &aafx; Activate Arabic form shaping
#define WCH_NADS                WCHAR(0x206e) // &nads; National digit shapes
#define WCH_NODS                WCHAR(0x206f) // &nods; Nominal digit shapes
#define WCH_EURO                WCHAR(0x20ac) // &euro;
#define WCH_VELLIPSIS           WCHAR(0x22ee)
#define WCH_BLACK_CIRCLE        WCHAR(0x25cf)
#define WCH_FESPACE             WCHAR(0x3000)
#define WCH_UTF16_HIGH_FIRST    WCHAR(0xd800)
#define WCH_UTF16_HIGH_LAST     WCHAR(0xdbff)
#define WCH_UTF16_LOW_FIRST     WCHAR(0xdc00)
#define WCH_UTF16_LOW_LAST      WCHAR(0xdfff)
#define WCH_ZWNBSP              WCHAR(0xfeff) // aka BOM (Byte Order Mark)

//
// Synthetic characters
//
// NOTE (grzegorz): WCH_SYNTHETICEMBEDDING should be remapped to [U+FDD0-U+FDEF] range, 
// because it is using a valid Unicode character. But because weird LS dependencies
// we need to keep it as 0xfffc.

#define WCH_SYNTHETICLINEBREAK    WCHAR(0xfde0)
#define WCH_SYNTHETICBLOCKBREAK   WCHAR(0xfde1)
#define WCH_SYNTHETICEMBEDDING    WCHAR(0xfffc)
//#define WCH_SYNTHETICEMBEDDING    WCHAR(0xfde2)
#define WCH_SYNTHETICTXTSITEBREAK WCHAR(0xfde3)
#define WCH_NODE                  WCHAR(0xfdef)


//
// Trident Aliases
//

#define WCH_WORDBREAK          WCH_ZWSP      // We treat <WBR>==&zwsp;

//
// Line Services Aliases
//

#define WCH_ENDPARA1           WCH_CR
#define WCH_ENDPARA2           WCH_LF
#define WCH_ALTENDPARA         WCH_SYNTHETICBLOCKBREAK
#define WCH_ENDLINEINPARA      WCH_SYNTHETICLINEBREAK
#define WCH_COLUMNBREAK        WCH_UNDEF
#define WCH_SECTIONBREAK       WCH_SYNTHETICTXTSITEBREAK // zero-width
#define WCH_PAGEBREAK          WCH_UNDEF
#define WCH_OPTBREAK           WCH_UNDEF
#define WCH_NOBREAK            WCH_ZWNBSP
#define WCH_TOREPLACE          WCH_UNDEF
#define WCH_REPLACE            WCH_UNDEF

//
// Line Services Visi support (Not currently used by Trident)
//

#define WCH_VISINULL           WCHAR(0x2050) // !
#define WCH_VISIALTENDPARA     WCHAR(0x2051) // !
#define WCH_VISIENDLINEINPARA  WCHAR(0x2052) // !
#define WCH_VISIENDPARA        WCHAR(0x2053) // !
#define WCH_VISISPACE          WCHAR(0x2054) // !
#define WCH_VISINONBREAKSPACE  WCHAR(0x2055) // !
#define WCH_VISINONBREAKHYPHEN WCHAR(0x2056) // !
#define WCH_VISINONREQHYPHEN   WCHAR(0x2057) // !
#define WCH_VISITAB            WCHAR(0x2058) // !
#define WCH_VISIEMSPACE        WCHAR(0x2059) // !
#define WCH_VISIENSPACE        WCHAR(0x205a) // !
#define WCH_VISINARROWSPACE    WCHAR(0x205b) // !
#define WCH_VISIOPTBREAK       WCHAR(0x205c) // !
#define WCH_VISINOBREAK        WCHAR(0x205d) // !
#define WCH_VISIFESPACE        WCHAR(0x205e) // !

//
// Line Services installed object handler support
//

#define WCH_ESCRUBY            WCHAR(0xfdd0) // !
#define WCH_ESCMAIN            WCHAR(0xfdd1) // !
#define WCH_ENDTATENAKAYOKO    WCHAR(0xfdd2) // !
#define WCH_ENDHIH             WCHAR(0xfdd3) // !
#define WCH_ENDFIRSTBRACKET    WCHAR(0xfdd4) // !
#define WCH_ENDTEXT            WCHAR(0xfdd5) // !
#define WCH_ENDWARICHU         WCHAR(0xfdd6) // !
#define WCH_ENDREVERSE         WCHAR(0xfdd7) // !
#define WCH_REVERSE            WCHAR(0xfdd8) // !
#define WCH_NOBRBLOCK          WCHAR(0xfdd9) // !
#define WCH_LAYOUTGRID         WCHAR(0xfdda) // !
#define WCH_ENDLAYOUTGRID      WCHAR(0xfddb) // !

//
// Line Services autonumbering support
//

#define WCH_ESCANMRUN          WCH_NOBRBLOCK // !

//
// Hanguel Syllable/Jamo range specification
//

#define WCH_HANGUL_START       WCHAR(0xac00)
#define WCH_HANGUL_END         WCHAR(0xd7ff)
#define WCH_JAMO_START         WCHAR(0x3131)
#define WCH_JAMO_END           WCHAR(0x318e)

//
// ASCII
//

inline BOOL IsAscii(TCHAR ch)
{
    return ch < 128;
}

//
// End-User Defined Characters (EUDC) code range
// This range corresponds to the Unicode Private Use Area
//
// Usage: Japanese:             U+E000-U+E757
//        Simplified Chinese:   U+E000-U+E4DF  
//        Traditional Chinese:  U+E000-U+F8FF
//        Korean:               U+E000-U+E0BB
//

#define WCH_EUDC_FIRST   WCHAR(0xE000)
#define WCH_EUDC_LAST    WCHAR(0xF8FF)

inline BOOL IsEUDCChar(TCHAR ch)
{
    return InRange( ch, WCH_EUDC_FIRST, WCH_EUDC_LAST );
}

// Non-breaking space

#ifndef WCH_NBSP
    #define WCH_NBSP           TCHAR(0x00A0)
#endif

//
// UNICODE surrogate range for UTF-16 support
//
// High Surrogate D800-DBFF
// Low Surrogate  DC00-DFFF
//

inline BOOL
IsSurrogateChar(TCHAR ch)
{
    return InRange( ch, WCH_UTF16_HIGH_FIRST, WCH_UTF16_LOW_LAST );
}

inline BOOL
IsHighSurrogateChar(TCHAR ch)
{
    return InRange( ch, WCH_UTF16_HIGH_FIRST, WCH_UTF16_HIGH_LAST );
}

inline BOOL
IsLowSurrogateChar(TCHAR ch)
{
    return InRange( ch, WCH_UTF16_LOW_FIRST, WCH_UTF16_LOW_LAST );

}

inline WCHAR
HighSurrogateCharFromUcs4(DWORD ch)
{
    return 0xd800 + ((ch - 0x10000) >> 10);
}

inline WCHAR
LowSurrogateCharFromUcs4(DWORD ch)
{
    return 0xdc00 + (ch & 0x3ff);
}

//
// Quick lookup table for Windows-1252 to Latin-1 conversion in the 0x80-0x9f range
// The data resides in mshtml\src\site\util\intl.cxx
//

extern const WCHAR g_achLatin1MappingInUnicodeControlArea[32];

#ifdef __cplusplus
}
#endif // __cplusplus

#pragma INCMSG("--- End 'wchdefs.h'")
#else
#pragma INCMSG("*** Dup 'wchdefs.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\unidir.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIDIR.H -- Unicode direction classes
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      08/12/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef I__UNIDIR_H_
#define I__UNIDIR_H_
#pragma INCMSG("--- Beg 'unidir.h'")

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

// Direction class of a character.
typedef BYTE DIRCLS;

//--WARNING----WARNING----WARNING----WARNING----WARNING----WARNING----WARNING--
//--WARNING----WARNING----WARNING----WARNING----WARNING----WARNING----WARNING--
//
//  The ordering of the entries in the dircls enum is extremely important. If
//  you change it be sure to correct all the Is???Class() functions below AND
//  also review the code in lscomplx.cxx. There are a couple of lookup tables
//  in CBidiLine which are dependent on this ordering.
//
//--WARNING----WARNING----WARNING----WARNING----WARNING----WARNING----WARNING--
//--WARNING----WARNING----WARNING----WARNING----WARNING----WARNING----WARNING--

enum dircls
{
    LTR, // Left to right
    RTL, // Right to left
    ARA, // Arabic
    ANM, // Arabic numeral
    ENL, // European numeral preceeded by LTR
    ENR, // European numeral preceeded by RTL
    ENM, // European numeral
    ETM, // European numeric terminator
    ESP, // European numeric separator
    CSP, // Common numeric separator
    UNK, // Unknown
    WSP, // Whitespace
    CBN, // Combining mark
    NEU, // Neutral, whitespace, undefined
    SEG, // Segment separator (tab)
    BLK, // Block separator
    LRE, // LTR embedding
    LRO, // LTR override
    RLO, // RTL override
    RLE, // RTL embedding
    PDF, // Pop directional formatting
    FMT, // Embedding format
};

extern const DIRCLS s_aDirClassFromCharClass[];

inline BOOL IsStrongClass(DIRCLS dc)
{
    return IN_RANGE(LTR, dc, ARA);
}
inline BOOL IsFinalClass(DIRCLS dc)
{
    return IN_RANGE(LTR, dc, ENR);
}
inline BOOL IsNumericClass(DIRCLS dc)
{
    return IN_RANGE(ANM, dc, ENM);
}
inline BOOL IsResolvedEuroNumClass(DIRCLS dc)
{
    return IN_RANGE(ENL, dc, ENR);
}
inline BOOL IsNumericPunctuationClass(DIRCLS dc)
{
    return IN_RANGE(ETM, dc, CSP);
}
inline BOOL IsNumericSeparatorClass(DIRCLS dc)
{
    return IN_RANGE(ESP, dc, CSP);
}
inline BOOL IsNeutralClass(DIRCLS dc)
{
    return IN_RANGE(UNK, dc, NEU);
}
inline BOOL IsIndeterminateClass(DIRCLS dc)
{
    return IN_RANGE(ETM, dc, NEU);
}
inline BOOL IsBreakOrEmbeddingClass(DIRCLS dc)
{
    return IN_RANGE(SEG, dc, PDF);
}
inline BOOL IsEmbeddingClass(DIRCLS dc)
{
    return IN_RANGE(LRE, dc, RLE);
}
inline BOOL IsOverrideClass(DIRCLS dc)
{
    return IN_RANGE(LRO, dc, RLO);
}
inline BOOL IsRTLEmbeddingClass(DIRCLS dc)
{
    return IN_RANGE(RLO, dc, RLE);
}

#pragma INCMSG("--- End 'unidir.h'")
#else
#pragma INCMSG("*** Dup 'unidir.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\include\_invar.h ===
/*
 *
 *
 *  _INVAR.H
 *  
 *  Purpose:
 *      Template class designed to call parameterized object's Invariant().
 *
 *  Overview (see also, usage):
 *      1)  declare and define a public const function BOOL Invariant( void ) in your class, with #ifdef DEBUG.
 *      2)  in the source: #define DEBUG_CLASSNAME to be the name of the class you're debugging.
 *      3)  followed by #include "_invar.h"
 *      4)  For every method you wish to check Invariants,
 *          insert the _TEST_INVARIANT_ macro once, usually at the beginning of a routine.
 *          OPTIONAL: You may optionally use the _TEST_INVARIANT_ON (x) to call x's Invariant directly.
 *
 *  Notes:
 *      Invariants are designed to be called at the beginning and upon exit of a routine, 
 *      testing the consistent properties of an object which remain invariant--always the same.
 *
 *      Functions may temporarily make an object inconsistent during their execution.
 *      A generalized invariant test should not be called during these inconsistent times;
 *      if there is a need for a function, which checks invariants, to be called during
 *      an inconsistent object state, a solution will need to be designed--the current design
 *      does not facilitate this.
 *
 *      Because it is entirely possible for an Invariant() function to recurse on itself
 *      causing a stack overflow, the template explicitly prevents this from happening.
 *      The template also prevents invariant-checking during the processing of Assert(),
 *      preventing another type of recursion. Assert() recursion is avoided by checking
 *      a global flag, fInAssert.
 *
 *      Currently Invariant() returns a BOOL, as I think this allows for it to be called
 *      from the QuickWatch window under VC++2.0. TRUE indicates that the invariant executed
 *      normally.
 *
 *  Usage:
 *      -the _invariant.h header should only be included in source files. An error will occur
 *          if included in another header file. This is to prevent multiple #define DEBUG_CLASSNAME.
 *      -Typical #include into a source file looks like this:
            #define DEBUG_CLASSNAME ClassName
            #include "_invar.h"
 *      -Typical definition of a class' Invariant() method looks like this:
            #ifdef DEBUG
                public:
                BOOL Invariant( void ) const;
                protected:
            #endif  // DEBUG
 *      -Typical declaration of Invariant() looks like this:
            #ifdef DEBUG

            BOOL
            ClassName::Invariant( void ) const
            {
                static LONG numTests = 0;
                numTests++;             // how many times we've been called.

                // do mega-assert checking here.

                return TRUE;
            }

            #endif  // DEBUG
 *
 *
 *      
 *  
 *  Author:
 *      Jon Matousek (jonmat) 5/04/1995
 *
 *      Any problems? Please let me know.
 */

#ifndef I__INVAR_H_
#define I__INVAR_H_
#pragma INCMSG("--- Beg '_invar.h'")

#ifndef DEBUG_CLASSNAME
prior to including _invariant.h file, you must define DEBUG_CLASSNAME
to be the name of the class for which you are making Invariant() calls.
#endif


#ifdef DEBUG

template < class T >
class InvariantDebug
{
    public:
    InvariantDebug  ( const T & t) : _t(t)
    {
        static volatile BOOL fRecurse = FALSE;

        if ( fRecurse ) return;     /* Don't allow recursion.*/
        
        fRecurse = TRUE;

        _t.Invariant();

        fRecurse = FALSE;
    }

    ~InvariantDebug ()
    {
        static volatile BOOL fRecurse = FALSE;

        if ( fRecurse ) return;     /* Don't allow recursion.*/
        
        fRecurse = TRUE;

        _t.Invariant();

        fRecurse = FALSE;
    }

    private:
     const T &_t;
};

typedef InvariantDebug<DEBUG_CLASSNAME> DoInvariant;

#define _TEST_INVARIANT_ DoInvariant __invariant_tester( *this );
#define _TEST_INVARIANT_ON(x) \
                    {\
                        static volatile BOOL fRecurse = FALSE;\
                        if ( FALSE == fRecurse )\
                        {\
                            fRecurse = TRUE;\
                            (x).Invariant();\
                            fRecurse = FALSE;\
                        }\
                    }

#else   // DEBUG

#define _TEST_INVARIANT_
#define _TEST_INVARIANT_ON(x)

#endif  // DEBUG


    // code that should be at the start and end of all Invariant() methods.

#pragma INCMSG("--- End '_invar.h'")
#else
#pragma INCMSG("*** Dup '_invar.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\ckboxlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ckboxlyt.cxx
//
//  Contents:   Implementation of layout class for <INPUT type=checkbox|radio>
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_CKBOXLYT_HXX_
#define X_CKBOXLYT_HXX_
#include "ckboxlyt.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

ExternTag(tagCalcSize);

MtDefine(CCheckboxLayout, Layout, "CCheckboxLayout")

const CLayout::LAYOUTDESC CCheckboxLayout::s_layoutdesc =
{
    0,          // _dwFlags
};

//+-------------------------------------------------------------------------
//
//  Method:     CCheckboxLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------
#define CHKBOX_SITE_SIZE_W  20
#define CHKBOX_SITE_SIZE_H  20

const RECT s_CbDefOffsetRect = {4, 4, 3, 3};

DWORD
CCheckboxLayout::CalcSizeVirtual( CCalcInfo * pci,
                                  SIZE *      psize,
                                  SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME, "+CCheckboxLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);

    DWORD   grfReturn;

    _fContentsAffectSize = FALSE;

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    if ( IsSizeThis() )
    {
        SIZE        sizeDefault;   

        sizeDefault.cx = pci->DeviceFromDocPixelsX(CHKBOX_SITE_SIZE_W);
        sizeDefault.cy = pci->DeviceFromDocPixelsY(CHKBOX_SITE_SIZE_H);
        grfReturn = super::CalcSizeVirtual(pci, psize, &sizeDefault);
    }
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME, "-CCheckboxLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCheckboxElement::Draw
//
//  Synopsis:   renders the glyph for the button
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

void
CCheckboxLayout::Draw(CFormDrawInfo * pDI, CDispNode * pDispNode)
{
    RECT    rc;
    SIZE    sizeDefault;
    SIZE    sizeControl;
    SIZE    sizeDefGlyph;

    sizeDefault.cx = pDI->DeviceFromDocPixelsX(CHKBOX_SITE_SIZE_W);
    sizeDefault.cy = pDI->DeviceFromDocPixelsY(CHKBOX_SITE_SIZE_H);

    //use rc to hold offset
    rc.left   = pDI->DeviceFromDocPixelsX(s_CbDefOffsetRect.left);
    rc.top    = pDI->DeviceFromDocPixelsY(s_CbDefOffsetRect.top);
    rc.right  = pDI->DeviceFromDocPixelsX(s_CbDefOffsetRect.right);
    rc.bottom = pDI->DeviceFromDocPixelsY(s_CbDefOffsetRect.bottom);

    pDI->GetDC(TRUE);       // Ensure the DI has an HDC

    // GetClientRect(&rcClient);

    sizeControl.cx  = pDI->_rc.right - pDI->_rc.left;
    sizeDefGlyph.cx = sizeDefault.cx - rc.right - rc.left;
    sizeDefGlyph.cy = sizeDefault.cy - rc.bottom - rc.top;
    if (sizeControl.cx >= sizeDefault.cx)
    {
        rc.right  = pDI->_rc.right - rc.right;


        rc.left   = pDI->_rc.left + rc.left;
        Assert(rc.left <= rc.right);
    }
    else if (sizeControl.cx > sizeDefGlyph.cx)
    {
        rc.left     = pDI->_rc.left + (sizeControl.cx - sizeDefGlyph.cx) / 2;
        rc.right    = rc.left + sizeDefGlyph.cx;
    }
    else
    {
        rc.right = pDI->_rc.right;
        rc.left = pDI->_rc.left;
    }

    sizeControl.cy = pDI->_rc.bottom - pDI->_rc.top;
    if (sizeControl.cy >= sizeDefault.cy)
    {
        rc.bottom = pDI->_rc.bottom - rc.bottom;
        Assert(rc.bottom >= 0);
        rc.top    = pDI->_rc.top + rc.top;
        Assert(rc.top <= rc.bottom);
    }
    else if (sizeControl.cx > sizeDefGlyph.cx)
    {
        rc.top      = pDI->_rc.top + (sizeControl.cy - sizeDefGlyph.cy) / 2;
        rc.bottom   = rc.top + sizeDefGlyph.cy;
    }
    else
    {
        rc.top = pDI->_rc.top;
        rc.bottom = pDI->_rc.bottom;
    }

    DYNCAST(CInput, ElementOwner())->RenderGlyph(pDI, &rc);
}

HRESULT
CCheckboxLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT hr = S_FALSE;

    CLabelElement * pLabel = ElementOwner()->GetLabel();
    if (pLabel)
    {
        hr = THR(pLabel->GetFocusShape(lSubDivision, pdci, ppShape));
    }
    else
    {
        CRect           rc;
        CRectShape *    pShape;

        *ppShape = NULL;

        GetRect(&rc, COORDSYS_FLOWCONTENT);
        if (rc.IsEmpty())
            goto Cleanup;

        pShape = new CRectShape;
        if (!pShape)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pShape->_rect = rc;
        pShape->_rect.InflateRect(1, 1);
        *ppShape = pShape;

        hr = S_OK;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\brktbl.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1999
//
//  File:       BRKTBL.CXX
//
//  Contents:   Implementation of CBreakTable and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BRKTBL_HXX_
#define X_BRKTBL_HXX_
#include "brktbl.hxx"
#endif 

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

MtDefine(ViewChain, Mem, "ViewChain");
MtDefine(CBreakBase_pv, ViewChain, "CBreakBase_pv");
MtDefine(CLayoutBreak_pv, ViewChain, "CLayoutBreak_pv");
MtDefine(CBreakTableBase_pv, ViewChain, "CBreakTableBase_pv");
MtDefine(CBreakTableBase_aryBreak_pv, ViewChain, "CBreakTableBase_ary_pv");
MtDefine(CBreakTable_pv, ViewChain, "CBreakTable_pv");
MtDefine(CRectBreakTable_pv, ViewChain, "CRectBreakTable_ary_pv");
MtDefine(CFlowLayoutBreak_pv, ViewChain, "CFlowLayoutBreak_pv");
MtDefine(CFlowLayoutBreak_arySiteTask_pv, ViewChain, "CFlowLayoutBreak_arySiteTask_pv"); 

//============================================================================
//
//  CBreakBase methods
//
//============================================================================

CBreakBase::~CBreakBase()
{
}

//============================================================================
//
//  CLayoutBreak methods
//
//============================================================================

CLayoutBreak::~CLayoutBreak()
{
}

//============================================================================
//
//  CBreakTableBase methods
//
//============================================================================

//----------------------------------------------------------------------------
//
//  Member: Reset
//
//  Note:   Deletes all entries from break table and shrinks to zero size
//----------------------------------------------------------------------------
void 
CBreakTableBase::Reset()
{
    for (int i = Size(); i-- > 0; )
    {
        Assert(_ary[i]._pBreak);
        delete _ary[i]._pBreak;
    }

    // remove from the array
    if (Size())
    {
        _ary.DeleteMultiple(0, Size() - 1);
    }

    ClearCache();
}

//----------------------------------------------------------------------------
//
//  Member: SetBreak
//
//  Note:   Adds new entry into array and initialize it with pBreak. If the 
//          entry already exists reassigns pointer to new object and deletes 
//          the old one.
//----------------------------------------------------------------------------
HRESULT 
CBreakTableBase::SetBreak(void *pKey, CBreakBase *pBreak)
{
    HRESULT hr = S_OK;
    int     idx;

    Assert(pBreak != NULL);

    idx = Idx(pKey);

    Assert(-1 <= idx && idx < Size());

    if (idx == -1)
    {
        //  append one
        idx = Size();
        _ary.Append();
    }
    else 
    {
        //  replace entry
        Assert(_ary[idx]._pBreak != NULL);
        delete _ary[idx]._pBreak;
    }

    _ary[idx]._pKey = pKey;
    _ary[idx]._pBreak = pBreak;

    SetCache(pKey, idx);

    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: GetBreak
//
//  Note:   Returns break object corresponding to pKey
//----------------------------------------------------------------------------
HRESULT 
CBreakTableBase::GetBreak(void *pKey, CBreakBase **ppBreak)
{
    HRESULT hr = S_OK;
    int     idx;

    Assert(pKey != NULL && ppBreak != NULL);
    
    *ppBreak = NULL;

    idx = Idx(pKey);

    if (idx == -1)
    {
        goto Cleanup;
    }
    
    Assert(0 <= idx && idx < Size() && _ary[idx]._pBreak != NULL);
    *ppBreak = _ary[idx]._pBreak;

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: RemoveBreak
//
//  Note:   Removes break
//----------------------------------------------------------------------------
HRESULT 
CBreakTableBase::RemoveBreak(void *pKey, CBreakBase **ppBreak /*= NULL*/)
{
    HRESULT hr = S_OK;
    int     idx;

    Assert(pKey != NULL);

    idx = Idx(pKey);
    if (idx < 0)
    {
        goto Cleanup;
    }

    Assert(0 <= idx && idx < Size() && _ary[idx]._pBreak != NULL);

    if (ppBreak != NULL)
    {
        *ppBreak = _ary[idx]._pBreak;
    }
    else
    {
        delete _ary[idx]._pBreak;
    }

    _ary.Delete(idx);

    ClearCache();

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: idx
//
//  Note:   Returns the index corrensponding to pKey. (Uses last hit cache 
//          to ompimize search).
//----------------------------------------------------------------------------
int 
CBreakTableBase::Idx(void *pKey)
{
    int idx;

    Assert(pKey != NULL);

    if (_cache._pKey == pKey)
    {
#if DBG==1
        {
            for (idx = Size(); --idx >= 0 && _ary[idx]._pKey != pKey; ) {}

            Assert(idx != -1 
                && idx == _cache._idx 
                && _ary[idx]._pBreak != NULL);
        }
#endif
        goto Cleanup;
    }

    for (idx = Size(); --idx >= 0; ) 
    {
        if (_ary[idx]._pKey == pKey)
        {
            Assert(_ary[idx]._pBreak != NULL);
            SetCache(pKey, idx);
            goto Cleanup;
        }
    }

    ClearCache();

Cleanup:
    return _cache._idx;
}

//============================================================================
//
//  CBreakTableBase methods
//
//============================================================================

//----------------------------------------------------------------------------
//
//  Member: SetBreakAfter
//
//  Note:   Inserts break after break of pKeyAfter
//----------------------------------------------------------------------------
HRESULT 
CRectBreakTable::SetBreakAfter(void *pKey, void *pKeyAfter, CBreakBase *pBreak)
{
    HRESULT hr = S_OK;
    int     idx;

    Assert(pKey != NULL && pBreak != NULL);
    Assert(pKeyAfter != NULL || Size() == 0);

    if (pKeyAfter == NULL )
    {
        Assert(Size() == 0);
        idx = 0;
    }
    else 
    {
        idx = Idx(pKeyAfter) + 1;
        Assert(0 < idx && idx <= Size());
    }

    _ary.InsertIndirect(idx, NULL);
    _ary[idx]._pBreak = pBreak;
    _ary[idx]._pKey = pKey;

    _cache._pKey = pKey;
    _cache._idx = idx;

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\contlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       contlyt.cxx
//
//  Contents:   Layout that only knows how to contain another layout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_CONTLYT_HXX_
#define X_CONTLYT_HXX_
#include "contlyt.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif

MtDefine(CContainerLayout, Layout, "CContainerLayout");

DeclareTag(tagContLyt, "Layout: Cont Lyt", "Trace CContainerLayout fns");

ExternTag(tagLayoutTasks);
ExternTag(tagCalcSize);


//+---------------------------------------------------------------------------
//
// Container layout implementation
// 
//----------------------------------------------------------------------------

const CContainerLayout::LAYOUTDESC CContainerLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

//+-------------------------------------------------------------------------
//
// Constructor
//
//--------------------------------------------------------------------------
CContainerLayout::CContainerLayout(CElement *pElementLayout, CLayoutContext *pLayoutContext) : CLayout(pElementLayout, pLayoutContext)
{
    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL ctor: this=0x%x, e=[0x%x,%d]",
                this,
                pElementLayout, pElementLayout->SN() ));

    // TODO (112486, olego): We should re-think layout context concept 
    // and according to that new understanding correct the code. 

    // (olego): BAD! How are we supposed to handle errors here ???
    CreateLayoutContext(this);
}

//+-------------------------------------------------------------------------
//
// Destructor
//
//--------------------------------------------------------------------------
CContainerLayout::~CContainerLayout()
{
    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL dtor: this=0x%x",
                this ));

    // NOTE (KTam): I don't think we should be detaching in the dtor; other
    // layouts don't do it, and the rest of the codebase appears to do stuff
    // like call detach deliberately before calling release (see CElement::ExitTree)
    // Detach();
}

//+--------------------------------------------------------------------------
//
//  Init
//
//---------------------------------------------------------------------------
HRESULT 
CContainerLayout::Init()
{
    HRESULT     hr = S_OK;
    CElement  * pElem = ElementOwner();

    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL::Init: this=0x%x, e=[0x%x,%d]",
                this,
                ElementOwner(), ElementOwner()->SN() ));

    Assert( ViewChain() == NULL && pElem );

    if (pElem->IsLinkedContentElement() )
    {
        // NOTE: What we're doing here is figuring out whether we're the head
        // of a viewchain, and either creating a new viewchain if necessary
        // or we'll be called later to set view chain (SetViewChain). 

        // Currently we say that if we have a contentSrc property, then
        // we're the head of a chain, and need to create a viewchain obj.
        CVariant cvarAttr;
        
        if ( pElem->GetLinkedContentAttr( _T("contentSrc"), &cvarAttr ) == S_OK )
        {
            CViewChain * pNewViewChain;

            // We do have a content src!
#if DBG            
            TraceTagEx((tagContLyt, TAG_NONAME,
                        "  CCL::Init() found contentSrc, creating view chain"));                        
#endif
            // Create a new view chain.
            pNewViewChain = new CViewChain( this );  

            // If we have set this view chain, indicate ownership.
            if (!SetViewChain(pNewViewChain))
                _fOwnsViewChain = TRUE;

            // Release the local reference - we should have addref'd the member variable in SetViewChain
            pNewViewChain->Release();
        }        
    }

    hr = super::Init();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Detach
//
//---------------------------------------------------------------------------
void
CContainerLayout::Detach()
{
    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL::Detach: this=0x%x",
                this));

    // Release viewchain if we have one
    SetViewChain(NULL);

    AssertSz( !_fOwnsViewChain, "Must have relinquished ownership of viewchain by now" );

    super::Detach();
}


//+-------------------------------------------------------------------------
//
// CalcSizeVirtual
//
// FUTURE (olego): currently CContainerLayout doesn't support size to content 
// calculations. If either width or height is not specified it will end up 
// with zero size.
//--------------------------------------------------------------------------
DWORD   
CContainerLayout::CalcSizeVirtual(CCalcInfo * pci, SIZE * psize, SIZE * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CContainerLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    TraceTagEx((tagContLyt, TAG_NONAME, "CCL::CalcSize: this=0x%x, e=[0x%x,%d]",
                                        this, ElementOwner(), ElementOwner()->SN() ));
    Assert( pci );
    Assert( psize );
    DWORD                    dwRet = 0;
    CViewChain         *pViewChain = ViewChain();

    // Do default sizing to handle user-specified height/width and dispnode creation.
    dwRet = super::CalcSizeVirtual( pci, psize, psizeDefault );

    // In order for a container layout to CalcSize(), it needs to ensure
    // that all containers prior to it in its view chain are clean (i.e.
    // have been calc'ed).
    if ( !pViewChain || !pViewChain->EnsureCleanToContext(DefinedLayoutContext()) )
    {
        // This calc failed, so make sure we get another one.  EnsureCleanToContext()
        // has queued up calc requests for all dirty elements prior to us in the chain.

        TraceTagEx((tagContLyt, TAG_NONAME,
                    "  CCL::CalcSize: Chain doesn't exist or isn't clean, bailing" ));
        // ElementOwner()->RemeasureElement(); // commented out because this causes a hang (TODO LRECT 112511 -> olego)
        return dwRet;
    }

    CElement     * pElementContent = ElementContent();
    CLayoutContext *pLayoutContext = DefinedLayoutContext();

    // Container layouts define a new context for their content element.
    // We need to set the context in the calcinfo so that when
    // our content elem is calc'ing, any children IT has (i.e. our grandchildren)
    // will have multiple layouts correctly created.
    Assert( pLayoutContext && "Container layouts must define a context!" );

    // When we have both containing and defined context, calcing should use the defined one

    // TODO LRECT 112511: this currently causes a layout array to be created even in 
    // single-layout case, but that should be optimized in a more general way (by allowing 
    // single layout to have context), if we care.
    // FUTURE (olego): we care and we'll need to find generic solution for layout handling 
    // in browser and page view mode.
    AssertSz(   pci->GetLayoutContext() == NULL
             || pci->GetLayoutContext() == DefinedLayoutContext()
             || pci->GetLayoutContext() == LayoutContext() && !DefinedLayoutContext(),
        "Wrong context in CalcSizeVirtual" );

    // Use local calc info to pass this layout context to children
    CCalcInfo calcinfoLocal(pci);
    pci = &calcinfoLocal;
    pci->SetLayoutContext( pLayoutContext );

    // Before calcing our children, we set the available parent size for
    // them to the layout rect's size.
    pci->SizeToParent( psize );

    // Get a layout for our child, with appropriate context.  Any element
    // acting as a content element
    // for a container must have layout; in fact, it may have multiple
    // layouts.  The purpose of that layout is to manage the portion of
    // the content element that lies inside the container.
    if ( pElementContent )
    {
        TraceTagEx((tagContLyt, TAG_NONAME,
                    "  CCL::CalcSize: have a content element (BODY)" ));

        CMarkup *pMarkup = pElementContent->GetMarkupPtr(); 
        if (    pMarkup 
            &&  (   pMarkup->LoadStatus() == LOADSTATUS_UNINITIALIZED   //  If markup was created thru OM 
                ||  pMarkup->LoadStatus() >= LOADSTATUS_PARSE_DONE )    //  If markup was created by downloading 
            )
        {
            CLayout *pLayoutContent = pElementContent->GetUpdatedLayout( pLayoutContext );

            if (_fOwnsViewChain && pMarkup->IsStrictCSS1Document())
            {
                IGNORE_HR( FlushWhitespaceChanges() );
            }
        
            if ( pLayoutContent )
            {
                //  mark this rect as empty
                pci->_fHasContent = FALSE;

                //  set available size 
                pci->_cyAvail = psize->cy;

                dwRet = pLayoutContent->CalcSize( pci, psize, psizeDefault );

                // Now that the content has been calc'ed, it dispnode
                // exists.  Attach it to the display tree as a sibling of
                // our first content node.
                Assert(!pLayoutContent->IsDisplayNone());

                Verify( EnsureDispNodeIsContainer() );

                CDispNode *pDispNode = pLayoutContent->GetElementDispNode();
                CDispNode *pDispSibling = GetFirstContentDispNode();

                Assert( pDispSibling );
                Assert( !pDispNode || pDispSibling != pDispNode);

                // this is just stopping a crash, but it doesn't seem like what we want to 
                // do in the future (invalidation handling)
                if (pDispNode && pDispSibling)
                {
                    pDispSibling->InsertSiblingNode(pDispNode, CDispNode::after);

                    // TODO (IE6 bug 13587): RTL goop here, see AddLayoutDispNode for example
                    // of how to do this right.
                    pLayoutContent->SetPosition(CPoint(pLayoutContent->GetXProposed(), pLayoutContent->GetYProposed()), TRUE);
    
                }

                pViewChain->MarkContextClean( pLayoutContext );
            }
        }
#if DBG
        else 
        {
            TraceTagEx((tagContLyt, TAG_NONAME,
                "  CCL::CalcSize: CALLED WHILE DOCUMENT LOADING" ));
        }
#endif
    }
    else
    {
        TraceTagEx((tagContLyt, TAG_NONAME,
                    "  CCL::CalcSize: FAILED TO FIND CONTENT ELEMENT" ));

        Assert(pViewChain && " Upstream ptr test failed");
    }
    
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CContainerLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return dwRet;
}

//+-------------------------------------------------------------------------
//
//   Draw
//
//--------------------------------------------------------------------------
void
CContainerLayout::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    CElement * pElementContent = ElementContent();
    CLayout *  pLayoutContent  = NULL;

    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL::Draw: this=0x%x, e=[0x%x,%d]",
                this,
                ElementOwner(), ElementOwner()->SN() ));

    Assert( DefinedLayoutContext() );

    // Delegate call to our content
    if ( pElementContent )
    {
        TraceTagEx((tagContLyt, TAG_NONAME,
                    "  CCL::Draw: have a content element (BODY)" ));
        pLayoutContent = pElementContent->GetUpdatedLayout( DefinedLayoutContext() );
        Assert(pLayoutContent);
        pLayoutContent->Draw( pDI, pDispNode );
    }
}

//+-------------------------------------------------------------------------
//
//   Notify
//
//--------------------------------------------------------------------------
void
CContainerLayout::Notify(CNotification * pnf)
{
    Assert(ElementOwner());

    if (    pnf->IsType(NTYPE_ELEMENT_RESIZE) 
        ||  pnf->IsType(NTYPE_ELEMENT_REMEASURE)    )
    {
        // TODO LRECT 112511: this is taken from CFrameSetLayout. 
        //                 Is this actually the right thing to do? We get a hang
        //                 under UpdateScreenCaret(), caused by slave and container dirtying each other.
        //
        //  Always "dirty" the layout associated with the element
        //  if the element is not itself.
        //
        if (pnf->Element() != ElementOwner())
        {
            pnf->Element()->DirtyLayout(pnf->LayoutFlags());
        }

        //
        //  Ignore the notification if already "dirty"
        //  Otherwise, post a layout request
        //

        if (    !IsSizeThis()
            &&  !TestLock(CElement::ELEMENTLOCK_SIZING))
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFrameSetLayout::Notify() [n=%S srcelem=0x%x,%S]",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber,
                        pnf->Name(),
                        pnf->Element(),
                        pnf->Element() ? pnf->Element()->TagName() : _T("")));
            PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
        }
        goto Cleanup;
    }

    if (    pnf->IsType(NTYPE_ELEMENT_ZCHANGE) 
        ||  pnf->IsType(NTYPE_ELEMENT_REPOSITION)   )
    {
        //  if the notification was issues by an element from slave markup 
        //  terminate it here. positioning and/or z-changing of an slave markup
        //  element doesn't make sense in master markup anyway (all cases we are 
        //  interested in are handled by CViewChain object) 
        if (pnf->Element() != ElementOwner())
        {
                pnf->SetHandler(ElementOwner());
                goto Cleanup;
        }
    }
    
    super::Notify(pnf);

Cleanup:
    return;
}

BOOL
CContainerLayout::IsDirty()
{
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  ElementContent
//
//---------------------------------------------------------------------------
CElement *
CContainerLayout::ElementContent()
{
    CElement * pElementContent = NULL;

    if (!ViewChain() )
        return NULL;
    
    // If we own the viewchain, then our slave ptr is used to get the slave content.
    // Otherwise, delegate to the viewchain's ElementContent(), which will in turn
    // delegate to the layout that owns the viewchain.
    if ( _fOwnsViewChain )
    {
        CElement * pElementOwner   = ElementOwner();
        CElement * pElementSlave   = pElementOwner->HasSlavePtr() ?
                                     pElementOwner->GetSlavePtr() : NULL;

        // HACK ALERT!  Right now slave ptrs are CRootElements; this doesn't
        // work for us because we want to have something that can have layout.
        // So we're going to go for the slave's markup and grovel for the
        // body element, which is reasonably likely to be around right now.

        if ( pElementSlave )
        {
            pElementContent = pElementSlave->GetMarkup()->GetElementClient();

            if ( pElementContent )
            {
                // NOTE : For safety we refuse to return a content element if it isn't a BODY/FRAMESET.
                // (olego) Another reason is that behaviour of content elements other than BODY/FRAMESET 
                // is not defined in this case -- for example only BODY/FRAMESET has code to send events 
                // DISPID_EVMETH_ONLINKEDOVERFLOW/DISPID_EVMETH_ONLAYOUTCOMPLETE. 
                if ( pElementContent->Tag() != ETAG_BODY && pElementContent->Tag() != ETAG_FRAMESET )
                {
                    AssertSz( FALSE, "Unexpected top-level element -- expecting BODY/FRAMESET" );
                    pElementContent = NULL;
                }
            }
        }
    }
    else
    {
        pElementContent = ViewChain()->ElementContent();
    }

    return pElementContent;
}

//+-------------------------------------------------------------------------
//
//  Member : SetViewChain ()
//
//  Synopsis : CLayout virtual overrided, this helper function sets us up for
//      the future when any layout may be part of a viewChain. For now this is 
//      the only override.
//
//+-------------------------------------------------------------------------
HRESULT
CContainerLayout::SetViewChain( CViewChain * pvc, CLayoutContext * pPrevious)
{
    TraceTagEx((tagContLyt, TAG_NONAME,
                "CCL::SetViewChain: this=0x%x, e=[0x%x,%d]",
                this,
                ElementOwner(), ElementOwner()->SN() ));

    // Don't reset if there is already a chain here. 
    // This way the first one to hook up to us wins in the case of conflicting targeting.
    if (_pViewChain && pvc)
        return S_FALSE;      

    // We are hooking up a view chain.
    if (pvc)
    {
        Assert(!_pViewChain);   // We should have already returned S_FALSE;

        _pViewChain = pvc;
        _pViewChain->AddRef();
        _pViewChain->AddContext(DefinedLayoutContext(), pPrevious);
    }

    // We are removing a view chain.
    else if (ViewChain())   // No work to do if the view chain is already null.
    {
        // Clear the view chain.
        // If we're the owner of the viewchain, disconnect it from us.
        if ( _fOwnsViewChain )
        {
            _fOwnsViewChain = FALSE;
            _pViewChain->SetLayoutOwner(NULL);
        }

        _pViewChain->ReleaseContext(DefinedLayoutContext());
        _pViewChain->Release();
        _pViewChain = NULL;
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Member:     CContainerLayout::GetContentSize
//
//  Synopsis:   Return the width/height of the content
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------
void
CContainerLayout::GetContentSize(
    CSize * psize,
    BOOL    fActualSize)
{
    if (fActualSize)
    {
        CElement      *pElementContent = ElementContent();
        CLayoutContext *pLayoutContext = DefinedLayoutContext();
        *psize = g_Zero.size;
        
        if (pElementContent)
        {
            CLayout *pLayoutContent = pElementContent->GetUpdatedLayout( pLayoutContext );
            if (pLayoutContent)
            {
                pLayoutContent->GetContentSize(psize, fActualSize);
            }            
        }
    }
    else
    {
        super::GetContentSize(psize, fActualSize);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CContainerLayout::FlushWhitespaceChanges
//
//  Synopsis:   Flush whitespace changes
//
//-----------------------------------------------------------------------------

HRESULT 
CContainerLayout::FlushWhitespaceChanges()
{
    CTreePos    *ptp, *ptpEnd;
    CElement    *pElement = ElementContent();
    CTreeNode   *pNode;

    Assert(pElement);

    ptpEnd = pElement->GetLastBranch()->GetEndPos();

    Assert(ptpEnd);

    for (ptp = pElement->GetFirstBranch()->GetBeginPos(); 
         ptp != ptpEnd; 
         ptp = ptp->NextTreePos())
    {    
        if (ptp->Type() == CTreePos::Pointer && ptp->GetCollapsedWhitespace())
        {       
            pNode = ptp->GetBranch();
            Assert(pNode);

            //
            // Force compute formats so that the whitespace changes get registered        	
            //
            pNode->GetParaFormat();

            //
            // Advance ptp so we don't consider this node again
            //

            ptp = pNode->GetEndPos();

            if (ptp == ptpEnd)
                break;
        }
    }

    RRETURN( pElement->Doc()->GetWhitespaceManager()->FlushWhitespaceChanges() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\btnlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       btnlyt.cxx
//
//  Contents:   Implementation of layout class for <BUTTON> controls.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_BTNLYT_HXX_
#define X_BTNLYT_HXX_
#include "btnlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

MtDefine(CButtonLayout, Layout, "CButtonLayout")

const CLayout::LAYOUTDESC CButtonLayout::s_layoutdesc =
{
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};


HRESULT
CButtonLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    // Button can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CButtonLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    super::DrawClient( prcBounds,
                       prcRedraw,
                       pDispSurface,
                       pDispNode,
                       cookie,
                       pClientData,
                       dwFlags );

    // (bug 49150) Has the button just appeared? Should it be the default element
    CButton * pButton = DYNCAST(CButton, ElementOwner());
    const CCharFormat *pCF = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()));
    Assert(pButton && pCF);

    if (pButton->GetBtnWasHidden() && pButton->GetAAtype() == htmlInputSubmit
        && !pCF->IsDisplayNone() && !pCF->IsVisibilityHidden())
    {
        pButton->SetDefaultElem();
        pButton->SetBtnWasHidden( FALSE );
    }
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.

void CButtonLayout::DrawClientBackground(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    CButton *       pButton = DYNCAST(CButton, ElementOwner());
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);

    if (hTheme)
        return;

    super::DrawClientBackground(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
}

void CButtonLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CDoc *          pDoc = Doc();
    CBorderInfo     bi;
    BOOL            fDefaultAndCurrent = pDoc && ElementOwner()->_fDefault
                                    && ElementOwner()->IsEnabled()
                                    && pDoc->HasFocus();
    CButton *       pButton = DYNCAST(CButton, ElementOwner());
    XHDC            hdc    = pDI->GetDC();
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);


    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);

        if (hdc.DrawThemeBackground(   hTheme,
                                        BP_PUSHBUTTON,
                                        pButton->GetThemeState(),
                                        &pDI->_rc,
                                        NULL))
        {
            return;
        }
    }

    Verify(pButton->GetNonThemedBorderInfo(pDI, &bi, TRUE));



    // draw default if necessary
    bi.acrColors[SIDE_TOP][1]    =
    bi.acrColors[SIDE_RIGHT][1]  =
    bi.acrColors[SIDE_BOTTOM][1] =
    bi.acrColors[SIDE_LEFT][1]   = fDefaultAndCurrent
                                            ? RGB(0,0,0)
                                            : ElementOwner()->GetInheritedBackgroundColor();
    
    //  NOTE (greglett) : This xyFlat scheme won't work for outputting to devices 
    //  without a square DPI. Luckily, we never do this.  I think. When this is fixed, 
    //  please change CButtonLayout::DrawClientBorder and CInputButtonLayout::DrawClientBorder 
    //  by removing the following assert and these comments.
    Assert(pDI->IsDeviceIsotropic());
    bi.xyFlat = pDI->DeviceFromDocPixelsX(fDefaultAndCurrent ? -1 : 1);
    //bi.yFlat = pDI->DeviceFromDocPixelsY(fDefaultAndCurrent ? -1 : 1);

    ::DrawBorder(pDI, (RECT *)prcBounds, &bi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CButtonLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CButtonLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CBorderInfo     bi;
    CRect           rc;    
    CRectShape *    pShape;
    HRESULT         hr = S_OK;
    CButton *       pButton = DYNCAST(CButton, ElementOwner());

    *ppShape = NULL;
    
    pButton->GetBorderInfo(pdci, &bi);
    GetRect(&rc, COORDSYS_FLOWCONTENT);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_rect.top     += bi.aiWidths[SIDE_TOP];
    pShape->_rect.left    += bi.aiWidths[SIDE_LEFT];
    pShape->_rect.bottom  -= bi.aiWidths[SIDE_BOTTOM];
    pShape->_rect.right   -= bi.aiWidths[SIDE_RIGHT];

    // Exclude xflat border
    // (Themed buttons don't have this!!!)
    pShape->_rect.InflateRect(pdci->DeviceFromDocPixelsX(-1), pdci->DeviceFromDocPixelsY(-1));

    *ppShape = pShape;
    hr = S_OK;

    // IE6 bug 33042
    // For some reason, only the area inside the focus adorner is being invalidated
    // for submit inputs. This matters in the theme case because we need the border
    // to be invalidated in order to redraw the control. We're going to go ahead
    // and invalidate the whole dispnode here in order to ensure that the control
    // is properly drawn. This is only a problem for themed buttons.

    if (pButton->GetTheme(THEME_BUTTON))
        _pDispNode->Invalidate();

Cleanup:
    RRETURN(hr);
}

void
CButtonLayout::DoLayout(
    DWORD   grfLayout)
{
    super::DoLayout(grfLayout);
    if(     !IsDisplayNone()
        &&  (grfLayout & LAYOUT_MEASURE)
        )
    {
        GetElementDispNode()->SetInset(GetBtnHelper()->_sizeInset);
    }
}

CBtnHelper * CButtonLayout::GetBtnHelper()
{
    CElement * pElement = ElementOwner();
    Assert(pElement);
    CButton * pButton = DYNCAST(CButton, pElement);
    return pButton->GetBtnHelper();
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.
BOOL
CButtonLayout::GetInsets(SIZEMODE smMode, SIZE &size, SIZE &sizeText, BOOL fw, BOOL fh, const SIZE &sizeBorder)
{
    CCalcInfo       CI(this);
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CBtnHelper *    pBtnHelper = GetBtnHelper();
    
    GetFontSize(&CI, &sizeFontForShortStr, &sizeFontForLongStr);

    // if half of text size is less than the size of the netscape border
    // we need to make sure we display at least one char
    if (!fw && (sizeText.cx - sizeBorder.cx - sizeFontForLongStr.cx < 0))
    {
        sizeText.cx = sizeFontForLongStr.cx + CI.DeviceFromDocPixelsX(2) + sizeText.cx;
    }
    else
    {
        size.cx = max((long)CI.DeviceFromDocPixelsX(2), fw ? (size.cx - sizeText.cx)
                             : ((sizeText.cx - sizeBorder.cx)/2 - CI.DeviceFromDocPixelsX(6)));

        if (!fw)
        {
            sizeText.cx = size.cx + sizeText.cx;
        }
    }

    //
    // text centering is done through alignment
    //

    size.cx = 0;
    pBtnHelper->_sizeInset.cx = 0;

    if (smMode == SIZEMODE_MMWIDTH)
    {
        sizeText.cy = sizeText.cx;
        pBtnHelper->_sizeInset = g_Zero.size;
    }
    else
    {
        // vertical inset is 1/2 of font height
        size.cy = fh    ? (size.cy - sizeText.cy)
            : (sizeFontForShortStr.cy/2 - (sizeBorder.cy ? CI.DeviceFromDocPixelsY(6) : CI.DeviceFromDocPixelsY(4)));

        size.cy = max((long)CI.DeviceFromDocPixelsY(1), size.cy);
            
        sizeText.cy =   max(sizeText.cy, sizeFontForShortStr.cy + sizeBorder.cy)        
            + size.cy;

           
        if (size.cy < CI.DeviceFromDocPixelsY(3) && !fh)
        {        
            // for netscape compat            
            size.cy = 0;
        }

        pBtnHelper->_sizeInset.cy = size.cy / 2;
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CButtonLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the button layout contains the point
//
//----------------------------------------------------------------------------

BOOL
CButtonLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CButton *       pElem = DYNCAST(CButton, ElementOwner());
    CHitTestInfo *  phti = (CHitTestInfo *) pClientData;
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    BOOL            fRet = TRUE;
    RECT            rcClient;
    WORD            wHitTestCode;
    HRESULT         hr = S_OK;

    if (!hTheme)
    {
        fRet = super::HitTestContent(   pptHit,
                                        pDispNode,
                                        pClientData,
                                        fDeclinedByPeer);
        goto Cleanup;
    }

    Assert(pElem);

    GetClientRect(&rcClient);

    hr = HitTestThemeBackground(    hTheme,
                                    NULL,
                                    BP_PUSHBUTTON, 
                                    pElem->GetThemeState(),
                                    0,
                                    &rcClient,
                                    NULL,
                                    *pptHit,
                                    &wHitTestCode);

    if (SUCCEEDED(hr) && wHitTestCode == HTNOWHERE)
    {
        fRet = FALSE;
        phti->_htc = HTC_NO;
        goto Cleanup;
    }

    fRet = super::HitTestContent(pptHit,
                                pDispNode,  
                                pClientData,
                                fDeclinedByPeer);

Cleanup:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\bodylyt.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ebody.cxx
//
//  Contents:   Body element class
//
//  Classes:    CBodyLayout
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "frame.hxx"

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

ExternTag(tagCalcSize);

const CLayout::LAYOUTDESC CBodyLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

//+---------------------------------------------------------------------------
//
//  Member:     CBodyLayout::HandleMessage
//
//  Synopsis:   Check if we have a setcursor or mouse down in the
//              border (outside of the client rect) so that we can
//              pass the message to the containing frameset if we're
//              hosted in one.
//
//----------------------------------------------------------------------------
HRESULT
BUGCALL
CBodyLayout::HandleMessage(CMessage *pMessage)
{
    HRESULT hr = S_FALSE;

    // have any mouse messages
    //
    if(     pMessage->message >= WM_MOUSEFIRST
        &&  pMessage->message <= WM_MOUSELAST
        &&  pMessage->message != WM_MOUSEMOVE
        &&  ElementOwner() == Doc()->_pElemCurrent)
    {
        RequestFocusRect(FALSE);
    }

    if (    (   !GetOwnerMarkup()
            ||  !GetOwnerMarkup()->IsHtmlLayout() )         // In HTML layout, BODY concent can be outside its rect.
        &&  (   (   pMessage->message >= WM_MOUSEFIRST
                &&  pMessage->message != WM_MOUSEWHEEL
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR ) )
    {
        RECT rc;

        GetRect(&rc, COORDSYS_GLOBAL);

        if (    pMessage->htc != HTC_HSCROLLBAR
            &&  pMessage->htc != HTC_VSCROLLBAR
            &&  !PtInRect(&rc, pMessage->pt)
            &&  !Doc()->HasCapture(ElementOwner()) ) // marka - don't send message to frame if we have capture.
        {
            {
                // Its on the inset, and we are not hosted inside
                // of a frame, so just consume the message here.
                //
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    hr = THR(super::HandleMessage(pMessage));

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CalcSizeCore
//
//  Synopsis:   see CSite::CalcSize documentation
//
//----------------------------------------------------------------------------
DWORD
CBodyLayout::CalcSizeCore(CCalcInfo * pci, 
                          SIZE      * psize, 
                          SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CBodyLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0
        
    CScopeFlag  csfCalcing(this);

    // We want to reset the "table calc nesting level" when we cross
    // a certain boundaries in the content.  What boundaries?  Different markups?
    // IFRAMEs?  Viewlinks?  For now we'll settle for resetting it for
    // nested BODY elements.  This is necessary now because prior to NF, calcinfos
    // were naturally restricted by frames -- now a given calcinfo can be
    // used across all kinds of boundaries (KTam).
    int cIncomingNestedCalcs = 0;
    if ( pci->_fTableCalcInfo )
    {
        cIncomingNestedCalcs = ((CTableCalcInfo*)pci)->_cNestedCalcs;
        ((CTableCalcInfo*)pci)->_cNestedCalcs = -1; // set to -1 instead of 0 b/c new TCI instances will increment!
    }      

    //(dmitryt) we should never propagate FORCE across IFRAME border. 
    // Normally, FORCE is only used for catastrophic changes in display styles
    // that are likely to change entire subtree so we don't bother with notifying
    // descendants and rather set FORCE. No such changes affect content inside IFRAME.
    // Only size or visibility changes do, and they don't need FORCE.
    if(pci->_grfLayout & LAYOUT_FORCE)
    {
	   if(     ElementOwner()->GetMarkup()
            &&  ElementOwner()->GetMarkup()->Root()
            &&  ElementOwner()->GetMarkup()->Root()->HasMasterPtr() 
            &&  (   ElementOwner()->GetMarkup()->Root()->GetMasterPtr()->Tag() == ETAG_IFRAME
                ||  ElementOwner()->GetMarkup()->Root()->GetMasterPtr()->IsLinkedContentElement() ) )
        {
            pci->_grfLayout &= ~LAYOUT_FORCE;
        }
    }

    DWORD dwRet = super::CalcSizeCore(pci, psize, psizeDefault);

    //
    // PRINT VIEW : fire onlayoutcomplete with the fOverflow flag set in the event object
    // NOTE : moved from CLayoutContext::SetLayoutBreak
    {
        CLayoutContext * pLayoutContext = pci->GetLayoutContext();
        CViewChain *     pViewChain = pLayoutContext ? pLayoutContext->ViewChain() : NULL;
        CLayoutBreak *   pLayoutBreak, * pPrevBreak;

        if (pViewChain)
        {
            pLayoutContext->GetLayoutBreak(ElementOwner(), &pPrevBreak);
            if (    pViewChain->ElementContent() == ElementOwner()
                &&  (   !pPrevBreak
                     ||  pPrevBreak->LayoutBreakType() != LAYOUT_BREAKTYPE_LAYOUTCOMPLETE
                     ||  pViewChain->HasPositionRequests())  )
            {
                DISPID       dispidEvent  = DISPID_EVMETH_ONLAYOUTCOMPLETE; 
                OVERFLOWTYPE overflowType = OVERFLOWTYPE_UNDEFINED;

                pViewChain->HandlePositionRequests();
                pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);

                if (    pLayoutBreak 
                    &&  (   pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW 
                        ||  pViewChain->HasPositionRequests() )
                   )
                {
                    dispidEvent  = DISPID_EVMETH_ONLINKEDOVERFLOW; 
                    if (pci->_fPageBreakLeft != pci->_fPageBreakRight)
                    {
                        overflowType = pci->_fPageBreakLeft ? OVERFLOWTYPE_LEFT : OVERFLOWTYPE_RIGHT;
                    }
                }
                
                GetView()->AddEventTask(pLayoutContext->GetLayoutOwner()->ElementOwner(),
                                        dispidEvent, (DWORD)overflowType);
            }
        }
    }

    // Update the focus rect    
    if (_fFocusRect && ElementOwner() == Doc()->_pElemCurrent)
    {
        RedrawFocusRect();
    }

    // Restore any incoming table calc nesting level
    if ( pci->_fTableCalcInfo )
    {
        ((CTableCalcInfo*)pci)->_cNestedCalcs = cIncomingNestedCalcs;
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CBodyLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBodyLayout::NotifyScrollEvent
//
//  Synopsis:   Respond to a change in the scroll position of the display node
//
//----------------------------------------------------------------------------

void
CBodyLayout::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    // Update the focus rect
    if (_fFocusRect && ElementOwner() == Doc()->_pElemCurrent)
    {
        RedrawFocusRect();
    }

    super::NotifyScrollEvent(prcScroll, psizeScrollDelta);
}

//+---------------------------------------------------------------------------
//
//  Member:     RequestFocusRect
//
//  Synopsis:   Turns on/off the focus rect of the body.
//
//  Arguments:  fOn     flag for requested state
//
//----------------------------------------------------------------------------
void
CBodyLayout::RequestFocusRect(BOOL fOn)
{
    if (!_fFocusRect != !fOn)
    {
        _fFocusRect = fOn;
        RedrawFocusRect();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     RedrawFocusRect
//
//  Synopsis:   Redraw the focus rect of the body.
//
//----------------------------------------------------------------------------
void
CBodyLayout::RedrawFocusRect()
{
    Assert(ElementOwner() == Doc()->_pElemCurrent);
    CView * pView = GetView();

    // Force update of focus shape
    pView->SetFocus(NULL, 0);
    pView->SetFocus(ElementOwner(), 0);
    pView->InvalidateFocus();
}

//+---------------------------------------------------------------------------
//
//  Member:     CBodyLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CBodyLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;
    CRectShape *    pShape;
    HRESULT         hr = S_FALSE;
    CElement *      pMaster;

    Assert(ppShape);
    *ppShape = NULL;

    if (!_fFocusRect || GetOwnerMarkup()->IsPrintTemplate() || GetOwnerMarkup()->IsPrintMedia())
        goto Cleanup;

    GetClientRect(&rc, CLIENTRECT_BACKGROUND);
    if (rc.IsEmpty())
        goto Cleanup;


    // Honor hideFocus on the master, if it is a frame #95438
    pMaster = ElementOwner()->GetMarkup()->Root()->GetMasterPtr();
    if (    pMaster
        &&  (pMaster->Tag() == ETAG_FRAME || pMaster->Tag() == ETAG_IFRAME)
        &&  pMaster->GetAAhideFocus())
    {
        goto Cleanup;
    }

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_cThick = 2; // always draw extra thick for BODY
    *ppShape = pShape;

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     GetBackgroundInfo
//
//  Synopsis:   Fills out a background info for which has details on how
//              to display a background color &| background image.
//
//-------------------------------------------------------------------------

BOOL
CBodyLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{
    Assert(pDI || !fAll);

    // Our background may be stolen by the canvas,
    if (GetOwnerMarkup()->IsHtmlLayout())
    {
        CElement *pHtml = GetOwnerMarkup()->GetHtmlElement();
        if (    pHtml
            &&  DYNCAST(CHtmlElement, pHtml)->ShouldStealBackground() )
        {
            // Our background, if we have one, is being stolen.  Return transparency.
            pbginfo->crBack         =
            pbginfo->crTrans        = COLORREF_NONE;
            pbginfo->pImgCtx        = NULL;
            pbginfo->lImgCtxCookie  = 0;

            goto Cleanup;
        }
    }

    super::GetBackgroundInfo(pDI, pbginfo, fAll);

Cleanup:
    return TRUE;
}


#if DBG == 1
//+------------------------------------------------------------------------
//
//  Member:     IsInPageTransition
//
//  Synopsis:   Returns TRUE if this body is involved in a page transition.
//              Only needed for an assert in CDispNode::GetDrawProgram.
//
//-------------------------------------------------------------------------

BOOL
CBodyLayout::IsInPageTransitionApply() const
{
    CElement *pElement          = ElementOwner();
    CDocument *pDoc             = pElement  ? pElement->DocumentOrPendingDocument() : NULL;
    CPageTransitionInfo *pInfo  = pDoc      ? pDoc->GetPageTransitionInfo()         : NULL;
    CMarkup *pMarkup            = pInfo     ? pInfo->GetTransitionFromMarkup()      : NULL;

    return (pMarkup &&
            pInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_REQUESTED
            && pMarkup->GetElementClient() == pElement);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\e1dlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       e1dlyt.cxx
//
//  Contents:   Implementation of C1DLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

MtDefine(C1DLayoutBreak_pv, ViewChain, "C1DLayoutBreak_pv");
MtDefine(C1DLayout, Layout, "C1DLayout");

const CLayout::LAYOUTDESC C1DLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,              // _dwFlags
};


//+---------------------------------------------------------------------------
//
//  Member:     C1DLayout::Init()
//
//  Synopsis:   Called when the element enters the tree. Super initializes
//              CDisplay.
//
//----------------------------------------------------------------------------

HRESULT
C1DLayout::Init()
{
    HRESULT hr = super::Init();
    if(hr)
        goto Cleanup;

    // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
    // that prohibit layout breaking in Page View. This approach is not suffitient 
    // enouth for editable Page View there we want this property to be calculated 
    // dynamically depending on layout type and layout nesting position (if parent 
    // has it child should inherit). 
    // This work also will enable CSS attribute page-break-inside support.

    // FRAME and IFRAME could NOT be broken (bug #95525) 
    SetElementCanBeBroken(  ElementCanBeBroken() 
                        &&  ElementOwner()->Tag() != ETAG_IFRAME 
                        &&  ElementOwner()->Tag() != ETAG_FRAME );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
C1DLayout::Notify(CNotification *pNF)
{
    HRESULT     hr = S_OK;
    IStream *   pStream = NULL;

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_SAVE_HISTORY_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_SAVE_HISTORY_2:
        {
            CDataStream ds;
            CHistorySaveCtx *phsc;

            pNF->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream(ElementOwner()->GetSourceIndex(), 
                                           ElementOwner()->HistoryCode(), 
                                           &pStream));
            if (hr)
                goto Cleanup;

            ds.Init(pStream);

            // save scroll pos
            hr = THR(ds.SaveDword(GetYScroll()));
            if (hr)
                goto Cleanup;

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto Cleanup;
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            CMarkup * pMarkup = GetOwnerMarkup();
            Assert( pMarkup );

            IGNORE_HR(pMarkup->GetLoadHistoryStream(
                                ElementOwner()->GetSourceIndex(),
                                ElementOwner()->HistoryCode(), 
                                &pStream));

            if (pStream && !pMarkup->_fUserInteracted)
            {
                CDataStream ds(pStream);
                DWORD       dwScrollPos;

                // load scroll pos
                hr = THR(ds.LoadDword(&dwScrollPos));
                if (hr)
                    goto Cleanup;
                if (    _pDispNode
                    &&  GetElementDispNode()->IsScroller())
                {
                    ScrollToY(dwScrollPos);
                }
            }
        }
        break;
    }

Cleanup:
    ReleaseInterface(pStream);
    return;
}



void
C1DLayout::ShowSelected( CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected,  BOOL fLayoutCompletelyEnclosed )
{
    Assert(ptpStart && ptpEnd && ptpStart->GetMarkup() == ptpStart->GetMarkup());
    CElement* pElement = ElementOwner();
    //
    // For IE 5 we have decided to not draw the dithered selection at browse time for DIVs
    // people thought it weird.
    //
    // We do however draw it for XML Sprinkles.
    //
    if (    ( pElement->IsParentEditable() || pElement->_etag == ETAG_GENERIC || pElement->HasSlavePtr()) && 
            ( ( fSelected && fLayoutCompletelyEnclosed ) ||      
              ( !fSelected && ! fLayoutCompletelyEnclosed ) )
       )
    {
        SetSelected( fSelected, TRUE );
    }
    //
    // Check to see if this selection is not in our markup.
    //
    else if( pElement->HasSlavePtr() && 
                ptpStart->GetMarkup() != ElementOwner()->GetSlavePtr()->GetMarkup() )
    {
        SetSelected( fSelected, TRUE );
    }
    else
    {
        _dp.ShowSelected( ptpStart, ptpEnd, fSelected);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     GetUserHeightForBlock
//
//  Synopsis:   Used in print view. Adjust user specified height of the layout 
//              if the layout is broken by retrieving a value stored in 
//              corresponding break table entry. 
//
//----------------------------------------------------------------------------
long 
C1DLayout::GetUserHeightForBlock(long cyHeightDefault)
{
    CLayoutBreak *       pLayoutBreak; 
    CLayoutContext *     pLayoutContext = LayoutContext();
#if DBG==1
    CTreeNode *          pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pLayoutContext));
    const CCharFormat *  pCF = pNode->GetCharFormat(LC_TO_FC(pLayoutContext));
    const CUnitValue &   cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

    Assert(!pNode->IsAbsolute(LC_TO_FC(pLayoutContext))
        && "GetUserHeightForBlock is called for absolute positioned object!");
    Assert(!cuvHeight.IsNullOrEnum() 
        && "GetUserHeightForBlock is called for layout that have no user specified height!");
    Assert(ElementCanBeBroken() 
        && "GetUserHeightForBlock called for layout that could not be broken!");
    Assert(pLayoutContext && pLayoutContext->ViewChain() 
        && "GetUserHeightForBlock called for layout that is not in ViewChain!");
#endif 

    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        return (DYNCAST(C1DLayoutBreak, pLayoutBreak)->GetAvailableHeight());
    }

    return (cyHeightDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     SetUserHeightForNextBlock
//
//  Synopsis:   Used in print view. Stores user specified height into break 
//              table. 
//
//----------------------------------------------------------------------------
void 
C1DLayout::SetUserHeightForNextBlock(long cyConsumed, long cyHeightDefault)
{
    CLayoutBreak *       pLayoutBreak; 
    CLayoutBreak *       pLayoutBreakEnding; 
    CLayoutContext *     pLayoutContext = LayoutContext();
    long                 cyAvailHeight;
#if DBG==1
    CTreeNode *          pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pLayoutContext));
    const CCharFormat *  pCF = pNode->GetCharFormat(LC_TO_FC(pLayoutContext));
    const CUnitValue &   cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

    Assert(!pNode->IsAbsolute(LC_TO_FC(pLayoutContext))
        && "GetUserHeightForBlock is called for absolute positioned object!");
    Assert(!cuvHeight.IsNullOrEnum() 
        && "GetUserHeightForBlock is called for layout that have no user specified height!");
    Assert(ElementCanBeBroken() 
        && "GetUserHeightForBlock called for layout that could not be broken!");
    Assert(pLayoutContext && pLayoutContext->ViewChain() 
        && "GetUserHeightForBlock called for layout that is not in ViewChain!");
#endif 

    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        cyAvailHeight = DYNCAST(C1DLayoutBreak, pLayoutBreak)->GetAvailableHeight();
    }
    else 
    {
        cyAvailHeight = cyHeightDefault;
    }

    pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnding);
    Assert(pLayoutBreakEnding && "Layout has no ending break set!");
    if (pLayoutBreakEnding)
    {
        DYNCAST(C1DLayoutBreak, pLayoutBreakEnding)->SetAvailableHeight(max(0L, cyAvailHeight - cyConsumed));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     C1DLayout::WantsToObscure
//
//  Synopsis:   Should this element obscure windows that lie below it in the
//              z-order?  (E.g. IFrame over SELECT)
//
//----------------------------------------------------------------------------

BOOL
C1DLayout::WantsToObscure(CDispNode *pDispNode) const
{
    CElement* pElement = ElementOwner();

    if (pElement->Tag() == ETAG_IFRAME && pDispNode == GetElementDispNode())
    {
        CIFrameElement *pIFrame = DYNCAST(CIFrameElement, pElement);
        return pIFrame->IsOpaque();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\flowlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       flowlyt.cxx
//
//  Contents:   Implementation of CFlowLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include <math.h>

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_DOCPRINT_HXX_
#define X_DOCPRINT_HXX_
#include "docprint.hxx" // CPrintPage
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X__ELABEL_HXX_
#define X__ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_ADORNER_HXX_
#define X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifdef UNIX
extern "C" HANDLE MwGetPrimarySelectionData();
#include "mainwin.h"
#include "quxcopy.hxx"
#endif //UNIX

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#define DO_PROFILE  0
#define MAX_RECURSION_LEVEL 40

#if DO_PROFILE==1
#include "icapexp.h"
#endif

// force functions to load through dynamic wrappers
//

#ifndef WIN16
#ifdef WINCOMMCTRLAPI
#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#include "comctrlp.h"
#endif
#endif
#endif // ndef WIN16

MtDefine(CFlowLayout, Layout, "CFlowLayout")
MtDefine(CFlowLayout_aryLayouts_pv, CFlowLayout, "CFlowLayout::__aryLayouts::_pv")
MtDefine(CFlowLayout_pDropTargetSelInfo, CFlowLayout, "CFlowLayout::_pDropTargetSelInfo")
MtDefine(CFlowLayoutScrollRangeInfoView_aryRects_pv, Locals, "CFlowLayout::ScrollRangeIntoView aryRects::_pv")
MtDefine(CFlowLayoutBranchFromPointEx_aryRects_pv, Locals, "CFlowLayout::BranchFromPointEx aryRects::_pv")
MtDefine(CFlowLayoutDrop_aryLayouts_pv, Locals, "CFlowLayout::Drop aryLayouts::_pv")
MtDefine(CFlowLayoutGetChildElementTopLeft_aryRects_pv, Locals, "CFlowLayout::GetChildElementTopLeft aryRects::_pv")
MtDefine(CFlowLayoutPaginate_aryValues_pv, Locals, "CFlowLayout::Paginate aryValues::_pv")
MtDefine(CFlowLayoutNotify_aryRects_pv, Locals, "CFlowLayout::Notify aryRects::_pv")

MtDefine(CStackPageBreaks, CFlowLayout, "CStackPageBreaks")
MtDefine(CStackPageBreaks_aryYPos_pv, CStackPageBreaks, "CStackPageBreaks::_aryYPos::_pv")
MtDefine(CStackPageBreaks_aryXWidthSplit_pv, CStackPageBreaks, "CStackPageBreaks::_aryXWidthSplit::_pv")

MtDefine(LFCCalcSize, Metrics, "CalcSize - changed layout flow")
MtDefine(LFCMinMax, LFCCalcSize, "Min/Max calls")
MtDefine(LFCCalcSizeCore, LFCCalcSize, "CalcSizeCore calls");
MtDefine(LFCCalcSizeNaturalTotal, LFCCalcSize, "Natural calls total");
MtDefine(LFCCalcSizeNaturalFast, LFCCalcSize, "Natural calls with fast solution");
MtDefine(LFCCalcSizeNaturalSlow, LFCCalcSize, "Natural calls with search for solution");
MtDefine(LFCCalcSizeNaturalSlowAbort, LFCCalcSize, "Natural calls with search for solution aborted");
MtDefine(LFCCalcSizeSetTotal, LFCCalcSize, "Set calls total");

ExternTag(tagViewServicesErrors);
ExternTag(tagViewServicesCpHit);
ExternTag(tagViewServicesShowEtag);
ExternTag(tagCalcSize);
ExternTag(tagCalcSizeDetail);
ExternTag(tagLayoutTasks);

DeclareTag(tagUpdateDragFeedback, "Selection", "Update Drag Feedback")
DeclareTag(tagNotifyText, "NotifyText", "Trace text notifications");
DeclareTag(tagRepeatHeaderFooter, "Print", "Repeat table headers and footers on pages");

// Hack constant from viewserv.cxx; keep them in sync.
const long scrollSize = 5;

// Constants for CalcSize
const double ccErrorAcceptableLow  = 0.9;  // -10%
const double ccErrorAcceptableHigh = 1.1;  // +10%
const double ccErrorAcceptableLowForFastSolution  = 0.7;  // -30%
const LONG   ccSwitchCch = 10;   // used in min/max computation for vertical text

extern BOOL g_fInAccess9;


//+----------------------------------------------------------------------------
//
//  Member:     Listen
//
//  Synopsis:   Listen/stop listening to notifications
//
//  Arguments:  fListen - TRUE to listen, FALSE otherwise
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Listen(
    BOOL    fListen)
{
    if ((unsigned)fListen != _fListen)
    {
        if (_fListen)
        {
            Reset(TRUE);
        }

        _fListen = (unsigned)fListen;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     IsListening
//
//  Synopsis:   Return TRUE if accepting text notifications
//              NOTE: Make this inline! (brendand)
//
//-----------------------------------------------------------------------------
BOOL
CFlowLayout::IsListening()
{
    return !!_fListen;
}


//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a tree notification
//
//  Arguments:  pnf - Pointer to the tree notification
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Notify(
    CNotification * pnf)
{
    DWORD   dwData;
    BOOL    fHandle = TRUE;

    Assert(!pnf->IsReceived(_snLast));


    //
    //  Respond to the notification if:
    //      a) The channel is enabled
    //      b) The text is not sizing
    //      c) Or it is a position/z-change notification
    //

    if (    IsListening()
        && (    !TestLock(CElement::ELEMENTLOCK_SIZING)
            ||  IsPositionNotification(pnf)))
    {
        BOOL    fRangeSet = FALSE;

        //
        //  For notifications originating from this element,
        //  set the range to the content rather than that in the container (if they differ)
        //

        if (    pnf->Element() == ElementOwner()
            &&  ElementOwner()->HasSlavePtr()
            )
        {
            pnf->SetTextRange(GetContentFirstCp(), GetContentTextLength());
            fRangeSet = TRUE;
        }

#if DBG==1

        long    cp     = _dtr._cp;
        long    cchNew = _dtr._cchNew;
        long    cchOld = _dtr._cchOld;

        if (pnf->IsTextChange())
        {
            Assert(pnf->Cp(GetContentFirstCp()) >= 0);
        }
#endif

        //
        //  If the notification is already "handled",
        //  Make adjustments to cached values for any text changes
        //

        //FUTURE (carled) this block could be done in a very different place.
        // e.g. as we process the text measurements, we can make this call.
        // after all , it just looks at the dtr
        if (    pnf->IsHandled()
            &&  pnf->IsTextChange())
        {
/*
            //(dmitryt) if it came from view slave, we should Accumulate, 
            //not Adjust. Adjust assumes the change happened in nested layout
            //was handled by nested layout so it can't contain entire dirty
            //range of this layout inside it. This happens in viewlink scenario.

            if(    ElementOwner()->HasSlavePtr() 
                && ElementOwner()->GetMarkup() != pnf->Node()->GetMarkup())
            {
                if(IsDirty())
                    _dtr.Accumulate(pnf, GetContentFirstCp(), GetContentLastCp(), FALSE);
            }
            else
            {
                _dtr.Adjust(pnf, GetContentFirstCp());
            }
*/
            //(dmitryt) IE6 bug 29798, it seems that it is a general case...
            //We want Accumulate always rather then use stripped-down Adjust, because
            //Adjust can produce wrong dtr (with negative cp) that causes crash later
            if(IsDirty())
                _dtr.Accumulate(pnf, GetContentFirstCp(), GetContentLastCp(), FALSE);
                
            _dp.Notify(pnf);
        }

        //
        //  If characters or an element are invalidating,
        //  then immediately invalidate the appropriate rectangles
        //

        else if (IsInvalidationNotification(pnf))
        {
            //
            //  Invalidate the entire layout if the associated element initiated the request
            //
            if (   ElementOwner() == pnf->Element() 
                || pnf->IsType(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS))
            {
                //
                //  If we are dependant upon someone else's height or width, we need to completely
                //  reposition ourselves because this notice may be because our parent has changed.
                //  Otherwise, a simple invalidation will do.
                //
                
                const CFancyFormat * pFF = GetFirstBranch()->GetFancyFormat();
                if (    pFF->_fPositioned   // perf shortcut, was !ElementOwner()->IsPositionStatic()
                    &&  (pFF->IsWidthPercent() || pFF->IsHeightPercent()))
                {
                    ElementOwner()->RepositionElement();
                }
                Invalidate();
            }


            //
            //  Otherwise, isolate the appropriate range and invalidate the derived rectangles
            //

            else
            {
                long    cpFirst = GetContentFirstCp();
                long    cpLast  = GetContentLastCp();
                long    cp      = pnf->Cp(cpFirst) - cpFirst;
                long    cch     = pnf->Cch(cpLast);

                Assert( pnf->IsType(NTYPE_ELEMENT_INVALIDATE)
                    ||  pnf->IsType(NTYPE_CHARS_INVALIDATE));
                Assert(cp  >= 0);
                Assert(cch >= 0);

                //
                //  Obtain the rectangles if the request range is measured
                //

                if (    IsRangeBeforeDirty(cp, cch)
                    &&  (cp + cch) <= _dp._dcpCalcMax)
                {
                    CDataAry<RECT>  aryRects(Mt(CFlowLayoutNotify_aryRects_pv));
                    CTreeNode *pNotifiedNode = pnf->Element()->GetFirstBranch();
                    CTreeNode *pRelativeNode;
                    CRelDispNodeCache *pRDNC;

                    _dp.RegionFromRange(&aryRects, pnf->Cp(cpFirst), cch );

                    if (aryRects.Size() != 0)
                    {
                        // If the notified element is relative or is contained
                        // within a relative element (i.e. what we call "inheriting"
                        // relativeness), then we need to find the element that's responsible
                        // for the relativeness, and invalidate its dispnode.
                        if ( pNotifiedNode->IsInheritingRelativeness() )
                        {
                            pRDNC = _dp.GetRelDispNodeCache();
                            if ( pRDNC ) 
                            {
                                // NOTE: this assert is legit; remove the above if clause
                                // once OnPropertyChange() is modified to not fire invalidate
                                // when its dwFlags have remeasure in them.  The problem is
                                // that OnPropertyChange is invalidating when we've been
                                // asked to remeasure, so the dispnodes/reldispnodcache may
                                // not have been created yet.
                                Assert( pRDNC && "Must have a RDNC if one of our descendants inherited relativeness!" );                       
                                // Find the element that's causing the notified element
                                // to be relative.  Search up to the flow layout owner.
                                pRelativeNode = pNotifiedNode->GetCurrentRelativeNode( ElementOwner() );
                                // Tell the relative dispnode cache to invalidate the
                                // requested region of the relative element
                                pRDNC->Invalidate( pRelativeNode->Element(), &aryRects[0], aryRects.Size() );
                            }
                        }
                        else
                        {
                            Invalidate(&aryRects[0], aryRects.Size());
                        }
                    }
                }

                //
                //  Otherwise, if a dirty region exists, extend the dirty region to encompass it
                //  NOTE: Requests within unmeasured regions are handled automatically during
                //        the measure
                //

                else if (IsDirty())
                {
                    _dtr.Accumulate(pnf, GetContentFirstCp(), GetContentLastCp(), FALSE);
                }
            }
        }


        //
        //  Handle z-order and position change notifications
        //

        else if (IsPositionNotification(pnf))
        {
            fHandle = HandlePositionNotification(pnf);
        }

        //
        //  Handle translated ranges
        //

        else if (pnf->IsType(NTYPE_TRANSLATED_RANGE))
        {
            Assert(pnf->IsDataValid());
            HandleTranslatedRange(pnf->DataAsSize());
        }

        //
        //  Handle z-parent changes
        //

        else if (pnf->IsType(NTYPE_ZPARENT_CHANGE))
        {
            if (!ElementOwner()->IsPositionStatic())
            {
                ElementOwner()->ZChangeElement();
            }

            else if (_fContainsRelative)
            {
                ZChangeRelDispNodes();
            }
        }

        //
        //  Handle changes to CSS display and visibility
        //

        else if (   pnf->IsType(NTYPE_DISPLAY_CHANGE)
                ||  pnf->IsType(NTYPE_VISIBILITY_CHANGE))
        {
             HandleVisibleChange(pnf->IsType(NTYPE_VISIBILITY_CHANGE));

            if (_fContainsRelative)
            {
                if (pnf->IsType(NTYPE_VISIBILITY_CHANGE))
                    _dp.EnsureDispNodeVisibility();
                else
                    _dp.HandleDisplayChange();
            }
        }

#ifdef ADORNERS
        //
        //  Insert adornments as needed
        //
        //
        else if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
        {
            fHandle = HandleAddAdornerNotification(pnf);
        }
#endif // ADORNERS

        //  Otherwise, accumulate the information
        //

        else if (   pnf->IsTextChange()
                ||  pnf->IsLayoutChange())
        {
            long       cpFirst     = GetContentFirstCp();
            long       cpLast      = GetContentLastCp();
            BOOL       fIsChildAbsolute = FALSE;
            CElement * pElemNotify = pnf->Element();

            Assert(!IsLocked());

            if (!pElemNotify && pnf->Node())
            {
                // text change notifications have no element, but do have 
                // a treenode.
                pElemNotify = pnf->Node()->Element();
            }

            //
            //  Always dirty the layout of resizing/morphing elements
            //
            if (    pElemNotify
                &&  pElemNotify != ElementOwner()
                &&      (   pnf->IsType(NTYPE_ELEMENT_RESIZE)
                        ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)))
            {
                pElemNotify->DirtyLayout(pnf->LayoutFlags());

                //
                //  For absolute elements, simply note the need to re-calc them
                //

                if(pElemNotify->IsAbsolute())
                {
                    fIsChildAbsolute = TRUE;

                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Request: Queued RF_MEASURE on ly=0x%x [e=0x%x,%S sn=%d] by CFlowLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pElemNotify,
                                pElemNotify->TagName()));
                    QueueRequest(CRequest::RF_MEASURE, pnf->Element());
                }
            }

            //
            //  Otherwise, collect the range covered by the notification
            //  Note that for text change notifications pnf->Element() is NULL, 
            //  which means that do want (and need) to accumulate the change

            if (    (   (   !fIsChildAbsolute
                         ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE))
                    ||  (   pnf->IsTextChange()
                         || pElemNotify == ElementOwner())
                    )
                &&  pnf->Cp(cpFirst) >= 0)
            {
                //
                //  Accumulate the affected range
                //

                _dtr.Accumulate(pnf,
                                cpFirst,
                                cpLast,
                                (    pnf->Element() == ElementOwner()
                                &&  !fRangeSet));

                //
                // Content's are dirtied so reset the minmax flag on the display
                //
                _dp._fMinMaxCalced = FALSE;

                //
                //  Mark forced layout if requested
                //

                if (pnf->IsFlagSet(NFLAGS_FORCE))
                {
                    if (pElemNotify == ElementOwner())
                    {
                        _fForceLayout = TRUE;
                    }
                    else
                    {
                        _fDTRForceLayout = TRUE;
                    }

                    pnf->ClearFlag(NFLAGS_FORCE);
                }

                //
                //  Invalidate cached min/max values when content changes size
                //

                if (    !_fPreserveMinMax
                    &&  _fMinMaxValid 
                    &&  (   pnf->IsType(NTYPE_ELEMENT_MINMAX)
                        ||  (   _fContentsAffectSize
                            &&  (   pnf->IsTextChange()
                                ||  pnf->IsType(NTYPE_ELEMENT_RESIZE)
                                ||  pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                                ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                                ||  pnf->IsType(NTYPE_CHARS_RESIZE)))))
                {
                    ResetMinMax();

                    //  fix for bug #110026. 
                    //  if the layout is notified about some changes (like chars deleted) 
                    //  when minmax is alreasy calc'ed (_fMinMaxValid == TRUE) but normal 
                    //  calc didn't happen yet, it should notify it's parent also.
                    if (IsSizeThis())
                    {
                        CLayout *pLayoutParent = GetUpdatedParentLayout(LayoutContext());
                        if (pLayoutParent && pLayoutParent->_fMinMaxValid)
                        {
                            pLayoutParent->ElementOwner()->MinMaxElement();
                        }
                    }
                }
            }

            //
            //  If the layout is transitioning to dirty for the first time and
            //  is not set to get called by its containing layout engine (via CalcSize),
            //  post a layout request
            //  (For purposes of posting a layout request, transitioning to dirty
            //   means that previously no text changes were recorded and no absolute
            //   descendents needed sizing and now at least of those states is TRUE)
            //
            //  Why do we need to post a measure on ourself, if a the notification is for an 
            //  APE child?
             if (    fIsChildAbsolute  
                 ||  (  !pnf->IsFlagSet(NFLAGS_DONOTLAYOUT)
                     &&  !IsSizeThis()
                     &&  IsDirty()))
            {
                TraceTagEx((tagLayoutTasks, TAG_NONAME,
                            "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFlowLayout::Notify() [n=%S srcelem=0x%x,%S] [SUSPICOUS! Might need to be a QueueRequest instead of PostLayoutRequest]",
                            this,
                            _pElementOwner,
                            _pElementOwner->TagName(),
                            _pElementOwner->_nSerialNumber,
                            pnf->Name(),
                            pElemNotify,
                            pElemNotify->TagName()));
                PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);

                //                
                // For NTYPE_ELEMENT_RESIZEANDREMEASURE we have just handled the remeasure
                // part but not the resize, so change the notification and pass it on up the 
                // branch.  This is parallel logic to what is in CLayout::nofity. Similarly,
                // if this is a _fContentsAffectSize layout, we need to change type to Resize 
                // and not handle so that the parent gets the clue.
                // 103787 et al.   Remember that if the child (or Me) is an APE, then the parent
                //  doesn't need to get this notification because there is no way we can affect 
                // their size.
                //
                if (   !fIsChildAbsolute
                    && !ElementOwner()->IsAbsolute())
                {
                    if (pElemNotify != ElementOwner())
                    {
                        if (   pnf->IsTextChange()
                            && _fContentsAffectSize)
                        {
                            ElementOwner()->ResizeElement(pnf->IsFlagSet(NFLAGS_FORCE) ? NFLAGS_FORCE : 0);
                        }
                        else if (   pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                            || pnf->IsType(NTYPE_ELEMENT_REMEASURE))
                        {
                            BOOL  fForce = pnf->IsFlagSet(NFLAGS_FORCE);

                            fHandle = FALSE;
                            pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                            if (fForce)
                                pnf->SetFlag(NFLAGS_FORCE);
                        }
                        else if (   pnf->IsType(NTYPE_ELEMENT_RESIZE)
                                 && (   _fContentsAffectSize
                                     || ElementOwner()->HasSlavePtr())
                                    )
                        {
                            //
                            // the notification came from our slave, (because we are not the pnf->Element()
                            // and is a resize. we are already ready to remeasure but our parent needs to know 
                            // we are dirty. don't handle the resize so that our parent can do their work.
                            //
                            // NOTE (carled) there reason we need this hack is because the view-Master 
                            // has a flowlayout rather than a container layout, and so there is an 
                            // ambiguity about who is measureing what.  There are actually 2 CDisplays 
                            // and 2 dirty ranges that end up needed to be processed.  This must change 
                            // in V4.
                            fHandle = FALSE;
                        }
                    }
                    else if (   _fContentsAffectSize
                             && (   pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                                 || pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)))
                    {
                        BOOL  fForce = pnf->IsFlagSet(NFLAGS_FORCE);

                        fHandle = FALSE;
                        pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                        if (fForce)
                            pnf->SetFlag(NFLAGS_FORCE);
                    }
                }
            }

#if DBG==1
            else if (   !pnf->IsFlagSet(NFLAGS_DONOTLAYOUT)
                    &&  !IsSizeThis())
            {
                Assert( !IsDirty()
                    ||  !GetView()->IsActive()
                    ||  IsDisplayNone()
                    ||  GetView()->HasLayoutTask(this));
            }
#endif
        }
#if DBG==1
        if (_dtr._cp != -1 && !pnf->_fNoTextValidate )
        {
            Assert(_dtr._cp >= 0);
            Assert(_dtr._cp <= GetContentTextLength());
            Assert(_dtr._cchNew >= 0);
            Assert(_dtr._cchOld >= 0);
            Assert((_dtr._cp + _dtr._cchNew) <= GetContentTextLength());
        }

        TraceTagEx((tagNotifyText, TAG_NONAME,
                   "NotifyText: (%d) Element(0x%x,%S) cp(%d-%d) cchNew(%d-%d) cchOld(%d-%d)",
                   pnf->SerialNumber(),
                   ElementOwner(),
                   ElementOwner()->TagName(),
                   cp, _dtr._cp,
                   cchNew, _dtr._cchNew,
                   cchOld, _dtr._cchOld));
#endif

        //
        //  Reset the range if previously set
        //

        if (fRangeSet)
        {
            pnf->ClearTextRange();
        }
    }

    switch (pnf->Type())
    {
    case NTYPE_DOC_STATE_CHANGE_1:
        pnf->Data(&dwData);
        if (Doc()->State() <= OS_RUNNING)
        {
            _dp.StopBackgroundRecalc();
        }
        break;

    case NTYPE_SELECT_CHANGE:
        // Fire this onto the form
        Doc()->OnSelectChange();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        Reset(TRUE);
        break;

    case NTYPE_ZERO_GRAY_CHANGE:
        HandleZeroGrayChange( pnf );
        break; 
        
    case NTYPE_RANGE_ENSURERECALC:
    case NTYPE_ELEMENT_ENSURERECALC:

        fHandle = pnf->Element() != ElementOwner();

        //
        //  If the request is for this element and layout is dirty,
        //  convert the pending layout call to a dirty range in the parent layout
        //  (Processing the pending layout call immediately could result in measuring
        //   twice since the parent may be dirty as well - Converting it into a dirty
        //   range in the parent is only slightly more expensive than processing it
        //   immediately and prevents the double measuring, keeping things in the
        //   right order)
        //
        if (    pnf->Element() != ElementOwner()
            ||  !IsDirty())
        {
            CView * pView   = Doc()->GetView();
            long    cpFirst = GetContentFirstCpForBrokenLayout();
            long    cpLast  = GetContentLastCpForBrokenLayout();
            long    cp;
            long    cch;

            //
            //  If the requesting element is the element owner,
            //  calculate up through the end of the available content
            //

            if (pnf->Element() == ElementOwner())
            {
                cp  = _dp._dcpCalcMax;
                cch = cpLast - (cpFirst + cp);
            }

            //
            //  Otherwise, calculate up through the element
            //

            else
            {
                ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);

                cp  = pnf->Cp(cpFirst) - cpFirst;
                cch = pnf->Cch(cpLast);
            }

            if(pView->IsActive())
            {
                CView::CEnsureDisplayTree   edt(pView);

                if (    !IsRangeBeforeDirty(cp, cch)
                    ||  _dp._dcpCalcMax <= (cp + cch))
                {
                    _dp.WaitForRecalc((cpFirst + cp + cch), -1);
                }

                if (    pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)
                    &&  pnf->Element() != ElementOwner())
                {
                    ProcessRequest(pnf->Element() );
                }
            }
        }
        break;
    }


    //
    //  Handle the notification
    //
    //

    if (fHandle && pnf->IsFlagSet(NFLAGS_ANCESTORS))
    {
        pnf->SetHandler(ElementOwner());
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     Reset
//
//  Synopsis:   Reset the channel (clearing any dirty state)
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Reset(BOOL fForce)
{
    super::Reset(fForce);
    CancelChanges();
}

//+----------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Reset the channel
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Detach()
{
    // flushes the region cache and rel line cache.
    _dp.Detach();

    super::Detach();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::CFlowLayout
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//----------------------------------------------------------------------------

CFlowLayout::CFlowLayout(CElement * pElementFlowLayout, CLayoutContext *pLayoutContext)
                : CLayout(pElementFlowLayout, pLayoutContext)
{
    _sizeMin.SetSize(-1,-1);
    _sizeMax.SetSize(-1,-1);
    Assert(ElementContent());
    ElementContent()->_fOwnsRuns = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::~CFlowLayout
//
//  Synopsis:   Normal destructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//----------------------------------------------------------------------------

CFlowLayout::~CFlowLayout()
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::Init
//
//  Synopsis:   Initialization function to initialize the line array, and
//              scroll and background recalc information if necessary.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::Init()
{
    HRESULT hr;
    hr = super::Init();
    if(hr)
    {
        goto Cleanup;
    }

    if(!_dp.Init())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Create layout context here if this element defines resolution
    if (_pElementOwner->TagType() == ETAG_GENERIC)
    {
        // NOTE: Calling GetFancyFormat from CFlowLayout::Init causes recursion on TD.
        //       That's why we check the tag before looking at properties.
        CFancyFormat const *pFF = _pElementOwner->GetFirstBranch()->GetFancyFormat();
        mediaType mediaReference = pFF->GetMediaReference();
        if (mediaReference != mediaTypeNotSet)
        {
            if (S_OK == CreateLayoutContext(this))
                DefinedLayoutContext()->SetMedia(mediaReference);
        }
    }

    // Set _fElementCanBeBroken to TRUE for flow layouts only if markup master is layout rect
    SetElementAsBreakable();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::OnExitTree
//
//  Synopsis:   Deinitilialize the display on exit tree
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::OnExitTree()
{
    HRESULT hr;

    hr = super::OnExitTree();
    if(hr)
    {
        goto Cleanup;
    }

    _dp.FlushRecalc();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::OnPropertyChange
//
//  Synopsis:   Handle the changes in property.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::OnPropertyChange(DISPID dispid, DWORD dwFlags)
{
    HRESULT hr = S_OK;;

    switch(dispid)
    {
        case DISPID_A_EDITABLE:
            _dp.SetCaretWidth( IsEditable() ? 1 : 0);
            // fall thru
        default:
            hr = THR(super::OnPropertyChange(dispid, dwFlags));
            break;
    }

    RRETURN(hr);
}

void
CFlowLayout::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    CElement *  pElementOwner = ElementOwner();

    Assert(pElementOwner->CurrentlyHasAnyLayout());

    //  If this layout is no longer needed, ignore the request and remove it
    if (    pElementOwner->CurrentlyHasAnyLayout()
        &&  !pElementOwner->ShouldHaveLayout())
    {
        ElementOwner()->DestroyLayout();
    }

    //
    //  Hidden layout should just accumulate changes
    //  (It will be measured when re-shown)
    //

    else if(!IsDisplayNone())

    {
        CCalcInfo   CI(this);
        CSize       size;

        // Inside CalcSize we are going to apply element's transformations,
        // hence need to get apparent size.
        GetApparentSize(&size);

        CDispNode * pDispNode = GetElementDispNode();
        if (pDispNode)
        {
            CRect rc(CI._sizeParent);
            pDispNode->TransformRect(rc, COORDSYS_CONTENT, &rc, COORDSYS_TRANSFORMED);

            CI._sizeParent = rc.Size();
            CI._sizeParentForVert = CI._sizeParent;
        }

        CI._grfLayout |= grfLayout;

        //  Init available height for PPV 
        if (    CI.GetLayoutContext()
            &&  CI.GetLayoutContext()->ViewChain() 
            &&  ElementCanBeBroken()  )
        {
            CLayoutBreak *pLayoutBreak;
            CI.GetLayoutContext()->GetEndingLayoutBreak(pElementOwner, &pLayoutBreak);
            Assert(pLayoutBreak);

            if (pLayoutBreak)
            {
                CI._cyAvail = pLayoutBreak->AvailHeight();
            }
        }

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            // we want to do this each time inorder to
            // properly pick up things like opacity.
            if ( _fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            EnsureDispNode(&CI, !!(CI._grfLayout & LAYOUT_FORCE));

            if (    IsDirty()
                ||  (CI._grfLayout & LAYOUT_FORCE)  )
            {
                CElement::CLock Lock(pElementOwner, CElement::ELEMENTLOCK_SIZING);
                int             xRTLOverflow = _dp.GetRTLOverflow();

                //
                // CalcSize handles transformations, vertical-flow, delegation, & attribute sizing.
                //
                // But if we are percent sized, then we cannot pass in our old/current size, we need 
                // to grab our parent size (which the current is calculated from, and pass that in)
                if (   (    PercentSize() 
                        ||  pElementOwner->IsAbsolute() )
                    && (   (    Tag() != ETAG_BODY 
                            &&  Tag() != ETAG_FRAME)
                        || pElementOwner->IsInViewLinkBehavior( FALSE )
                    )  )
                {
                    CLayout *pParent = GetUpdatedParentLayout(LayoutContext());
                    if (pParent)
                    {
                        CFlowLayout *pFlowParent = pParent->ElementOwner()->GetFlowLayout(LayoutContext());
                        CRect rect;

                        BOOL fStrictCSS1Document =    ElementOwner()->HasMarkupPtr() 
                                                  &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document();

                        // If our parent cached a size for calcing children like us, then use that size.
                        if (    !fStrictCSS1Document 
                            &&  pFlowParent 
                            &&  pFlowParent->_sizeReDoCache.cx 
                            &&  pFlowParent->_sizeReDoCache.cy  )
                        {
                            size = pFlowParent->_sizeReDoCache;
                        }
                        // If CSS1 Strict use sizePropsed 
                        else if (   fStrictCSS1Document 
                                &&  pFlowParent )
                        {
                            size = pFlowParent->_sizeProposed;
                        }
                        else
                        {
                            //
                            // get the space inside the scrollbars and border
                            //
                            pParent->GetClientRect(&rect, CLIENTRECT_CONTENT);
                            size.cx = rect.Width();
                            size.cy = rect.Height();

                            //
                            // Now remove padding (and margin if it is the body)
                            //   CSS1 Strict Doctypes: Margin on the BODY really is margin, not padding.
                            //
                            if (    pParent->Tag() == ETAG_BODY
                                &&  !pParent->GetOwnerMarkup()->IsHtmlLayout() )
                            {
                                LONG xLeftMargin, xRightMargin;
                                LONG yTopMargin, yBottomMargin;

                                // get the margin info for the site
                                pParent->GetMarginInfo(&CI, 
                                                       &xLeftMargin, 
                                                       &yTopMargin, 
                                                       &xRightMargin, 
                                                       &yBottomMargin);
                                size.cx -= (xLeftMargin + xRightMargin);
                                size.cy -= (yTopMargin + yBottomMargin);
                            }
                        
                            {
                                CDisplay    *pdpParent   = pFlowParent ? pFlowParent->GetDisplay() : NULL;
                                long         lPadding[SIDE_MAX];

                                if (pdpParent)
                                {
                                    pdpParent->GetPadding(&CI, lPadding);

                                    // padding is in parent coordinate system, but we need it in global
                                    if (pParent->ElementOwner()->HasVerticalLayoutFlow()) 
                                    {
                                        size.cx -= (lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM]);
                                        size.cy -= (lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT]);
                                    }
                                    else
                                    {
                                        size.cx -= (lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT]);
                                        size.cy -= (lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM]);
                                    }
                                }
                            }
                        } // end "use _sizeReDoCache"
                    }

                    CI.SizeToParent(&size);

                    // now that we have found the proper size of our parent, we need to get ready
                    // to call CalcSize - this means setting "size" to be the same as pSizeObj in
                    //  MeasureSite() -- which means, removing OUR margins from the parent size.
                    //
                    // Note - we don't remove margins for APE's
                    //
                    if (!ElementOwner()->IsAbsolute())
                    {
                        LONG xLeftMargin, xRightMargin;
                        LONG yTopMargin, yBottomMargin;

                        // get the margin info for the site
                        GetMarginInfo(&CI, 
                                      &xLeftMargin, 
                                      &yTopMargin, 
                                      &xRightMargin, 
                                      &yBottomMargin);
                        size.cx -= (xLeftMargin + xRightMargin);
                        size.cy -= (yTopMargin + yBottomMargin);
                    }

                }

                CalcSize(&CI, &size);

                if (CI._grfLayout & LAYOUT_FORCE || 
                    IsRTLFlowLayout() && _dp.GetRTLOverflow() != xRTLOverflow) // another reason to update disp nodes.
                {
                    if (pElementOwner->IsAbsolute())
                    {
                        pElementOwner->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
                    }
                }
            }

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            long xParentWidth;
            long yParentHeight;

            _dp.GetViewWidthAndHeightForChild(
                &CI,
                &xParentWidth,
                &yParentHeight,
                CI._smMode == SIZEMODE_MMWIDTH);

            ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
        }

        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }
    else
    {
        FlushRequests();
        RemoveLayoutRequest();
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::DoLayout()" ));
}


//+------------------------------------------------------------------------
//
//  Member:     ResizePercentHeightSites
//
//  Synopsis:   Send an ElementResize for any immediate contained sites
//              whose size is a percentage
//
//-------------------------------------------------------------------------

void
CFlowLayout::ResizePercentHeightSites()
{
    CNotification   nf;
    CLayout *       pLayout;
    DWORD_PTR       dw;
    BOOL            fFoundAtLeastOne = FALSE;

    //
    // If no contained sites are affected, immediately return
    //
    if (!ContainsVertPercentAttr())
        return;

    //
    // Otherwise, iterate through all sites, sending an ElementResize notification for those affected
    // (Also, note that resizing a percentage height site cannot affect min/max values)
    // NOTE: With "autoclear", the min/max can vary after resizing percentage sized
    //       descendents. However, the calculated min/max values, which used for table
    //       sizing, should take into account those changes since doing so would likely
    //       break how tables layout relative to Netscape. (brendand)
    //
    Assert(!_fPreserveMinMax);
    _fPreserveMinMax = TRUE;

    for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
    {
        if (pLayout->PercentHeight())
        {
            nf.ElementResize(pLayout->ElementOwner(), NFLAGS_CLEANCHANGE);
            GetContentMarkup()->Notify( nf );

            fFoundAtLeastOne = TRUE;
        }
    }
    ClearLayoutIterator(dw, FALSE);

    _fPreserveMinMax = FALSE;

    // clear the flag if there was no work done.  oppurtunistic cleanup
    SetVertPercentAttrInfo(fFoundAtLeastOne);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object.  This function had two 
//      responsibilities. First it needs to delegate the CalcSize call to 
//      the IHTMLBehaviorLayout peer if it is there; second, it needs to 
//      detect if there is vertical text on the page and call CalcSizeEx()
//      to handle this.  CalcSizeCore() is the classic sizing code.
//
//      Note, changes to CalcSizeCore or CalcSizeEx need to be reflected in 
//      the other function
//
//      Note, because this function is so central to the layout process (I.E. perf), 
//      it is  organized to streamline the expected (no peerholder) scenario
//
//--------------------------------------------------------------------------

DWORD
CFlowLayout::CalcSizeVirtual( CCalcInfo * pci,
                              SIZE      * psize,
                              SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CElement *pElementOwner = ElementOwner();
    CPeerHolder *   pPeerHolder = pElementOwner->GetLayoutPeerHolder();
    DWORD dwRet = 0;

    // If the element is editable
    if (IsEditable())
    {
        CTreeNode *pNode = pElementOwner->GetFirstBranch();

        // Parent is editable
        if (pNode->IsEditable(TRUE))
        {
            _dp.SetCaretWidth(1);
        }

        // Parent is not, while the element by itself is editable. Find out if it was
        // due to contentEditable. (we do not want to add a pixel for caret to
        // things like textarea/input which are editable at browse -- this is for
        // compat reasons).
        else if (pNode->GetFancyFormat()->_fContentEditable)
        {
            _dp.SetCaretWidth(1);
        }
        else
        {
            _dp.SetCaretWidth(0);
        }
    }

    if (   !pPeerHolder 
        || !pPeerHolder->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // no PeerLayout, do the normal thing
        if (!pci->_pMarkup->_fHaveDifferingLayoutFlows)
        {
            dwRet = CalcSizeCore(pci, psize, psizeDefault);
        }
        else
        {
            dwRet = CalcSizeEx(pci, psize, psizeDefault);
        }
    }
    else
    {
        POINT pt = g_Zero.pt;
        BOOL  fSizeDispNodes;

        fSizeDispNodes = (S_FALSE == EnsureDispNode(pci, (pci->_grfLayout & LAYOUT_FORCE)));
        EnsureDispNodeIsContainer( ElementOwner() );

        DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                         pPeerHolder, 
                         pci, 
                         *psize, 
                         &pt, 
                         psize);

        // do work here to set the dispnode
        if (!fSizeDispNodes)
        {
            CSize sizeOriginal; 
            GetSize(&sizeOriginal); 

            fSizeDispNodes = (psize->cx != sizeOriginal.cx) || (psize->cy != sizeOriginal.cy); 
        }

        if (fSizeDispNodes)
        {
            CSize sizeInset(pt.x, pt.y);

            // NOTE - not sure if setInset is going to do just what we want...
            // it feels like a hack, but if a LayoutBehavior is not a LayoutRender
            // we may have some trouble drawing it properly
            if (sizeInset.cx || sizeInset.cy)
            {
                _pDispNode->SetInset(sizeInset);
            }
            SizeDispNode(pci, *psize);

            SizeContentDispNode( CSize(psize->cx-max(pt.x, 0L), 
                                       psize->cy-max(pt.y, 0L)) );

            dwRet |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // Mark the site clean
        //
        SetSizeThis( FALSE );
    }
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return dwRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeEx
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CFlowLayout::CalcSizeEx( CCalcInfo * pci,
                         SIZE      * psize,
                         SIZE      * psizeDefault)
{
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    DWORD          grfReturn = 0;
    CTreeNode        * pNode = GetFirstBranch();
    const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    BOOL fLayoutFlowVertical = pCF->HasVerticalLayoutFlow();

    if (!pFF->_fLayoutFlowChanged)
    {
        if (    pci->_smMode == SIZEMODE_MMWIDTH
            &&  fLayoutFlowVertical)
        {
            //
            // MIN/MAX mode for vertical layout
            // Need to change calculated min value to avoid situation
            // when each char is in its own vertical-line
            //
            LONG cuMin;
            CSizeUV sizeMaxWidth;
            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMaxWidth);

            if (ccSwitchCch > GetContentTextLength())
            {
                cuMin = sqrt(sizeMaxWidth.cu * sizeMaxWidth.cv);
            }
            else
            {
                CSizeUV sizeChar;
                GetAveCharSize(pci, (PSIZE)&sizeChar);
                cuMin = ccSwitchCch * sizeChar.cu;
            }

            psize->cy = min(_sizeMax.cu, max(_sizeMin.cu, cuMin));
            _sizeMin.SetSize(psize->cy, -1);
            _sizeMax.SetSize(psize->cx, -1);

            if (psizeDefault)
            {
                ((CSize *)psizeDefault)->SetSize(sizeMaxWidth.cu, sizeMaxWidth.cv);
            }
        }
        else if (pci->_smMode == SIZEMODE_NATURALMIN)
        {
            CSizeUV sizeMinWidth;
            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMinWidth);

            _sizeMin.SetSize(sizeMinWidth.cu, -1);
            _sizeMax.SetSize(psize->cx, -1);
        }
        else
        {
            // Normal and also horizontal when there are other vertical
            grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
        }
    }
    else
    {
        CSaveCalcInfo sci(pci, this);

        BOOL fContentSizeOnly = pci->_fContentSizeOnly;
        pci->_fContentSizeOnly = FALSE;

        switch (pci->_smMode)
        {
        case SIZEMODE_MMWIDTH:
        {
            //
            // Coordinate system has been rotated by 270 or 90 degrees
            // MIN/MAX requires min/max logical height
            //
            CSizeUV size;
            CSizeUV sizeMinWidth;

            //
            // Calculate minimum logical height
            //
            //   size will contain max logical width and height
            //   sizeMinWidth will contain min logical width
            //
            {
                // needed only because we have another calc size call right after this one
                CSaveCalcInfo sci(pci, this);

                size.cu = pci->GetDeviceMaxX();
                size.cv = 0;
                pci->_smMode = SIZEMODE_NATURALMIN;
                grfReturn |= CalcSizeCore(pci, (PSIZE)&size, (PSIZE)&sizeMinWidth);
                pci->_smMode = SIZEMODE_MMWIDTH;
            }
            // sizeMin in the cordinates of the parent, and since we are differing flow,
            // we need to flip.
            _sizeMin.SetSize(size.cv, size.cu);

            //
            // Calculate logical width at which maximum logical height will be 
            // calculated
            //
            size.cu = sizeMinWidth.cu;
            size.cv = 0;
            if (fLayoutFlowVertical)
            {
                // Need to change proposed min width value to avoid situation
                // when each char is in its own vertical-line
                if (ccSwitchCch > GetContentTextLength())
                {
                    size.cu = sqrt(_sizeMin.cu * _sizeMin.cv);
                }
                else
                {
                    CSizeUV sizeChar;
                    GetAveCharSize(pci, (PSIZE)&sizeChar);
                    size.cu = ccSwitchCch * sizeChar.cu;
                }
                size.cu = max(sizeMinWidth.cu, min(_sizeMin.cv, size.cu));  // to keep within min/max range
            }
            //
            // Calculate maximum logical height
            //
            pci->_smMode = SIZEMODE_NATURAL;
            grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
            pci->_smMode = SIZEMODE_MMWIDTH;
            // sizeMax in the cordinates of the parent, and since we are differing flow,
            // we need to flip.
            _sizeMax.SetSize(size.cv, size.cu);

            // If we have explicity specified width we need to keep it
            const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
            {
                // If we have explicity specified width we need to keep it
                LONG uUserWidth = cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                          pNode->GetFontHeightInTwips(&cuvWidth));
                //
                // NOTE: We shouldn't measure at > userLW.
                // We can have following cases:
                //    1) userLW <= minLW
                //    2) userLW >= maxLW
                //    3) userLW >  minLW & userLW < maxLW
                // NOTE: maxLW == _sizeMin.cv, minLW == _sizeMax.cv
                //

                // (1) We cannot measure at < minLW, so we need extend width to minLW
                //     In this case set MIN to MAX, to keep minLW
                if (uUserWidth <= _sizeMax.cv)
                {
                    _sizeMin = _sizeMax;
                }
                // (2) User width is greater than maxLW, so we don't care now
                //     We will adjust this value in NATURAL pass
                //
                // (3) We need to reduce maxLW to userLW
                //     To do that we need additional calc size to get MIN
                else if (!(uUserWidth >= _sizeMin.cv))
                {
                    size.SetSize(uUserWidth, 0);
                    pci->_smMode = SIZEMODE_NATURAL;
                    grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                    pci->_smMode = SIZEMODE_MMWIDTH;
                    // sizeMin in the cordinates of the parent, and since we are differing flow,
                    // we need to flip.
                    _sizeMin.SetSize(size.cv, size.cu);
                }
            }

            // If we have explicity specified height we need to keep it
            const CUnitValue & cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            if (!cuvHeight.IsNullOrEnum() && !cuvHeight.IsPercent())
            {
                LONG lHeight = cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy, 
                                                        pNode->GetFontHeightInTwips(&cuvHeight));

                _uMinWidth  = _sizeMin.cu;
                _uMaxWidth  = _sizeMax.cu;
                _sizeMin.cu = max(_sizeMin.cu, lHeight);
                _sizeMax.cu = max(_sizeMax.cu, lHeight);
            }
            else
            {
                _uMinWidth = -1;
                _uMaxWidth = -1;
            }

            Assert((_sizeMax.cv != _sizeMin.cv) || (_sizeMax.cu == _sizeMin.cu));

            ((CSize *)psize)->SetSize(_sizeMax.cu, _sizeMin.cu);
            if (psizeDefault)
            {
                // since sizeDefault is the max dimensions and since they are in the coordinate
                // system of the parent, we need to flip when we set sizeDefault
                ((CSize *)psizeDefault)->SetSize(size.cv, size.cu);
            }

            MtAdd(Mt(LFCMinMax), 1, 0);
            _fMinMaxValid = TRUE;
            break;
        }

        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
        {
            CFlowLayout *pFlowLayout = this;

            if (    GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                &&  pci->GetLayoutContext() 
                &&  pci->GetLayoutContext()->ViewChain()    )
            {
                //  If this is a table cell in print preview 
                //  find layout in compatible layout context : 
                CMarkup *pMarkup = GetContentMarkup();
                AssertSz(pMarkup, "Layout MUST have markup pointer!!!"); 
                
                if (pMarkup && pMarkup->HasCompatibleLayoutContext())
                {
                    pFlowLayout = (CFlowLayout *)(ElementOwner()->GetUpdatedLayout(pMarkup->GetCompatibleLayoutContext())); 
                }
            }

            pci->_smMode = SIZEMODE_NATURAL;
            // _sizeMax.cv >= 0 means we had special MIN/MAX pass
            if (pFlowLayout->_sizeMax.cv >= 0)
            {
                MtAdd(Mt(LFCCalcSizeNaturalTotal), 1, 0);

                // 
                // Auto-sizing after special MIN/MAX mode
                // 

                LONG dur;
                LONG dvr;
                LONG durMin;
                LONG dvrMax = psize->cy;
                LONG dvrMaxOrig = psize->cy;
                BOOL fNeedRecalc = TRUE;
                LONG uUserWidth = -1;
                SIZECOORD   vMin = pFlowLayout->_sizeMin.cv;
                SIZECOORD   vMax = pFlowLayout->_sizeMax.cv;
                SIZECOORD   uMin = pFlowLayout->_sizeMin.cu;
                SIZECOORD   uMax = pFlowLayout->_sizeMax.cu;

                // Get logical user width
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum())
                {
                    // If we have explicity specified width we need to keep it
                    uUserWidth = cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                         pNode->GetFontHeightInTwips(&cuvWidth));
                }

                // Set real min/max values
                if (pFlowLayout->_uMinWidth >= 0)
                {
                    uMin = pFlowLayout->_uMinWidth;
                }
                if (pFlowLayout->_uMaxWidth >= 0)
                {
                    uMax = pFlowLayout->_uMaxWidth;
                }

                //
                // 1) Get maximum logical height (maxLH)
                //    * dvrMax > maxLH => stop and return (dvrMax, LW(maxLH))
                //    * dvrMax = maxLH => stop and return (dvrMax, LW(maxLH))
                //    * dvrMax < maxLH => go to (2)
                // NOTE: maxLH == _sizeMax.cu
                //
                Assert(vMax >= 0);
                dur = max(vMax, uUserWidth);
                dvr = uMax;

                BOOL fDone = (dvr <= dvrMax) || (uUserWidth >= vMin);
                if (!fDone)
                {
                    CSizeUV sizeChar;

                    if (GetAveCharSize(pci, (PSIZE)&sizeChar))
                    {
                        // If requested logical height is too close to min/max
                        // boundaries (< sizeChar.cv), reduce it
                        if (dvrMax < uMin + sizeChar.cv)
                            dvrMax = uMin;
                        else if (dvrMax > uMax - sizeChar.cv)
                            dvrMax = uMax - sizeChar.cv;
                    }

                    durMin = sizeChar.cu;

                    //
                    // 2) Get minimum logical height (minLH)
                    //    * dvrMax < minLH => stop and return (dvrMax, LW(minLH))
                    //    * dvrMax = minLH => stop and return (dvrMax, LW(minLH))
                    //    * dvrMax > minLH => go to (3)
                    // NOTE: minLH == _sizeMin.cu
                    //
                    Assert(vMin >= 0);
                    dur = max(vMin, uUserWidth);
                    dvr = uMin;

                    fDone = (dvr >= (LONG)(dvrMax * ccErrorAcceptableLow));
                    if (!fDone)
                    {
                        //
                        // (3) Find cell's width for specified height
                        //     Start search of most accurate solution.
                        //
                        fNeedRecalc = FALSE;

                        CSizeUV start(vMax, uMax);
                        CSizeUV end(vMin, uMin);
                        CSizeUV sizeOut;

                        grfReturn |= CalcSizeSearch(pci, dur, dvrMax, 
                            (PSIZE)&start, (PSIZE)&end, (PSIZE)&sizeOut);

                        dur = sizeOut.cu;
                        dvr = sizeOut.cv;
                    }
                }

                if (fNeedRecalc)
                {
                    CSizeUV size(dur, dvr);

                    // CFlowLayout::CalcSizeCore checks psize to decide if 
                    // text needs a recalc. Here we are replacing original psize,  
                    // causing that logic to fail. SetSizeThis guarantees that 
                    // text will be recalculated.
                    SetSizeThis(TRUE); 
                    grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                    dur = size.cu;
                    dvr = size.cv;
                }

                // TODO: (SujalP IE6 bug 13567): If something changed in an abs pos'd cell, then
                // the table code (CalcAbsolutePosCell) does not redo the min-max.
                // It uses the old max value and calls CalcSizeAtUserWidth. The new
                // width might be greater because of the changes, and hence we want
                // to size the cell at that new width. The right fix is for the table
                // to do a min-max pass on the cell to correctly get its max size.
                // This is not fully correct, since we do not accout for overflow properties.
                // Hence the correct fix is really for CalcAbsolutePosCell to do min-max
                // on this cell.
                CFlowLayout * pFLParent = pNode->Parent() ? pNode->Parent()->GetFlowLayout(LayoutContext()) : NULL;
                BOOL fBlockInContext =    !pFLParent
                                       || pFLParent->IsElementBlockInContext(pNode->Element());
                if (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                    && pFF->IsAbsolute()
                    && dvr != dvrMaxOrig)
                {
                    CDispNode * pdn = GetElementDispNode();
                    if (pdn)
                    {
                        if (((CTableCellLayout *)this)->TableLayout()->IsFixed())
                            dvr = max(dvr, dvrMaxOrig);
                        SizeDispNode(pci, CSize(dur, max(dvr, dvrMaxOrig)), FALSE);
                    }
                }
                // If out height is different than original we need to change calculated height 
                // and resize display node for non-positioned block elements.
                // Do it also in case of fixed table, because after node sizing
                // we change size to match requested values.
                else if (   (   dvr != dvrMaxOrig 
                             && fBlockInContext 
                             && !pFF->IsPositioned())
                         || (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                             && ((CTableCellLayout *)this)->TableLayout()->IsFixed()))
                {
                    CDispNode * pdn = GetElementDispNode();
                    if (pdn)
                    {
                        dvr = max(dvr, dvrMaxOrig);
                        SizeDispNode(pci, CSize(dur, dvr), FALSE);
                    }
                }

                ((CSize *)psize)->SetSize(dur, dvr);
            }
            else
            {
                if (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                    && (   psize->cx == 0
                        || ((CTableCellLayout *)this)->TableLayout()->IsFixed()))
                {
                    // 
                    // TD layout auto-sizing for fixed table, or
                    // TD layout auto-sizing in case of 0 width
                    //

                    // First calculate min/max
                    CSizeUV size;
                    pci->_smMode = SIZEMODE_MMWIDTH;
                    grfReturn |= pFlowLayout->CalcSizeEx(pci, (PSIZE)&size, NULL);
                    pci->_smMode = SIZEMODE_NATURAL;

                    // Now call naturalmin mode
                    grfReturn |= CalcSizeEx(pci, psize, psizeDefault);
                }
                else
                {
                    Assert(!pci->_fContentSizeOnly);

                    // 
                    // Compute proposed logical width and size at this value
                    //
                    if (pci->_sizeParent.cx == 0)
                    {
                        CTreeNode * pParentNode = pNode->Parent();
                        if (pParentNode)
                            pci->_sizeParent.cx = pParentNode->GetLogicalUserWidth(pci, 
                                                    pCF->HasVerticalLayoutFlow());
                        if (pci->_sizeParent.cx == 0)
                            pci->_sizeParent.cx = pci->_sizeParentForVert.cx;
                    }

                    if (!fLayoutFlowVertical)
                    {
                        if (psize->cx == 0)
                            psize->cx = pci->_sizeParent.cx;

                        // Get content size (sizing in NATURALMIN mode + pci->_fContentSizeOnly set to TRUE)
                        {
                            CSizeUV sizeMinWidth;

                            CSaveCalcInfo sci(pci, this);
                            BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                            pci->_fContentSizeOnly = TRUE;

                            pci->_smMode = SIZEMODE_NATURALMIN;
                            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMinWidth);
                            pci->_smMode = SIZEMODE_NATURAL;

                            pci->_fContentSizeOnly = fContentSizeOnly;
                        }

                        // NATURALMIN mode doesn't do any alignment and it sizes to content size
                        // Hence need to recal text.
                        pci->_grfLayout |= LAYOUT_FORCE;
                        grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
                    }
                    else
                    {
                        // NATURALMIN mode doesn't do any alignment and it sizes to content size.
                        // Hence need to recal text in NATURAL mode, set fNeedRecalc flag by
                        // default to TRUE.
                        BOOL fNeedRecalc = TRUE;

                        CSizeUV sizeMax, sizeMin, size, sizeAbsMax, sizeMinWidth;
                        LONG lMaxWidth;
                        LONG lMinWidth;

                        LONG lUserHeight = 0;

                        // Get logical user height
                        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                        if (!cuvHeight.IsNullOrEnum())
                        {
                            // If we have explicity specified width we need to keep it
                            lUserHeight = cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                                   pNode->GetFontHeightInTwips(&cuvHeight));
                        }

                        //
                        // Get minimum logical width
                        //
                        SIZE sizeChar;
                        GetAveCharSize(pci, &sizeChar);
                        lMinWidth = ccSwitchCch * sizeChar.cx;

                        //
                        // Get maxmimum available logical width
                        //
                        lMaxWidth = pci->_sizeParent.cx;
                        if (lMaxWidth == 0)
                        {
                            lMaxWidth = pNode->GetLogicalUserWidth(pci, pCF->HasVerticalLayoutFlow());

                            // Its possible that we still do not have a logical width. In this case
                            // size at logical maximum(infinity) since that gives us the maximum 
                            // width for this layout and use that for our lMaxWidth.
                            if (lMaxWidth == 0)
                            {
                                CSaveCalcInfo sci(pci, this);
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;

                                sizeAbsMax.SetSize(pci->GetDeviceMaxX(), 0);
                                pci->_sizeParentForVert = pci->_sizeParent;
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeAbsMax, (PSIZE)&sizeMinWidth);
                                lMaxWidth = sizeAbsMax.cu;

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }
                            pci->_sizeParent.cx = lMaxWidth;
                        }
                        lMaxWidth = max(lMaxWidth, lMinWidth);

                        //
                        // Calculate maximum logical width
                        //
                        if (sizeAbsMax.IsZero())
                        {
                            CSaveCalcInfo sci(pci, this);
                            BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                            pci->_fContentSizeOnly = TRUE;
                            pci->_sizeParentForVert = pci->_sizeParent;

                            sizeMax.SetSize(lMaxWidth, 0);
                            pci->_smMode = SIZEMODE_NATURALMIN;
                            grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeMax, (PSIZE)&sizeMinWidth);

                            if (lUserHeight > 0 && lUserHeight < sizeMax.cv)
                            {
                                CSaveCalcInfo sci(pci, this);
                                sizeAbsMax.SetSize(pci->GetDeviceMaxX(), 0);
                                pci->_sizeParentForVert = pci->_sizeParent;
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeAbsMax, (PSIZE)&sizeMinWidth);
                                lMaxWidth = sizeAbsMax.cu;
                                sizeMax = sizeAbsMax;
                            }

                            pci->_fContentSizeOnly = fContentSizeOnly;
                        }
                        else
                        {
                            sizeMax = sizeAbsMax;
                        }

                        //
                        // Calculate minimum logical width, if necessary.
                        // 
                        // (1) if max is the same as min, then use max
                        // (2) if height for max width is >= user height, use max
                        // (3) if we overflow for max, then use max (there is no point to calc min)
                        // (4) get min size and if necessary search for solution
                        //
                        if (lMaxWidth <= lMinWidth)
                        {
                            // (1) see above
                            size = sizeMax;
                        }
                        else if (lUserHeight > 0 && lUserHeight <= sizeMax.cv)
                        {
                            // (2) see above
                            size = sizeMax;
                        }
                        else if (pci->_sizeParent.cy <= sizeMax.cv)
                        {
                            // (3) see above
                            size = sizeMax;
                        }
                        else
                        {
                            // (4) see above
                            {
                                CSaveCalcInfo sci(pci, this);
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;
                                pci->_sizeParentForVert = pci->_sizeParent;

                                sizeMin.SetSize(lMinWidth, 0);
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeMin, (PSIZE)&sizeMinWidth);

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }

                            // 
                            // We have both min and max sizes. There are following cases:
                            //
                            // (a) if we underlow for min, then use min as size
                            // (b) if sulution is between min and max, we need to search for sulution
                            //
                            if (   (lUserHeight > 0 && lUserHeight < sizeMin.cv) 
                                || pci->_sizeParent.cy < sizeMin.cv)
                            {
                                // (b) Search for solution
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;

                                fNeedRecalc = FALSE;
                                grfReturn |= CalcSizeSearch(pci, sizeMax.cu, 
                                    (lUserHeight > 0) ? lUserHeight : pci->_sizeParent.cy, 
                                    (PSIZE)&sizeMin, (PSIZE)&sizeMax, (PSIZE)&size);

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }
                            else
                            {
                                // (a) We can measure at min and we fit to available height, so use it.
                                size = sizeMin;
                            }
                        }

                        //
                        // Recalc layout if:
                        // * we haven't sized at calculated size (fNeedRecalc == TRUE)
                        // * calculated height is smaller than user height -- if its smaller 
                        //
                        if (fNeedRecalc || (size.cv < lUserHeight))
                        {
                            // NATURALMIN mode doesn't do any alignment and it sizes to content size
                            // Hence need to recal text.
                            pci->_grfLayout |= LAYOUT_FORCE;

                            pci->_sizeParentForVert = pci->_sizeParent;
                            size.cv = 0;
                            grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                        }
                        // Block element without specified height need to be sized to parent's height.
                        // Positioned elements should size to content.
                        CFlowLayout * pFLParent = pNode->Parent() ? pNode->Parent()->GetFlowLayout(LayoutContext()) : NULL;
                        BOOL fBlockInContext =    !pFLParent
                                               || pFLParent->IsElementBlockInContext(pNode->Element());
                        if (   cuvHeight.IsNullOrEnum() 
                            && fBlockInContext
                            && !pFF->IsPositioned())
                        {
                            CDispNode * pdn = GetElementDispNode();
                            if (pdn)
                            {
                                LONG lParentHeight = pci->_sizeParent.cy;
                                if (pFF->_fHasMargins)
                                {
                                    CUnitValue cuvMargin;
                                    cuvMargin = pFF->GetLogicalMargin(SIDE_TOP, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                                    if (!cuvMargin.IsNullOrEnum())
                                    {
                                        lParentHeight -= cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pNode->GetFontHeightInTwips(&cuvMargin));
                                    }
                                    cuvMargin = pFF->GetLogicalMargin(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                                    if (!cuvMargin.IsNullOrEnum())
                                    {
                                        lParentHeight -= cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pNode->GetFontHeightInTwips(&cuvMargin));
                                    }
                                }
                                size.cv = max(size.cv, lParentHeight);
                                SizeDispNode(pci, CSize(size.cu, size.cv), FALSE);
                            }
                        }
                        ((CSize *)psize)->SetSize(size.cu, size.cv);
                    }
               }
            }
            break;
        }

        case SIZEMODE_SET:
#if DBG==1
            if (_sizeMax.cv >= 0)
                MtAdd(Mt(LFCCalcSizeSetTotal), 1, 0);
#endif
            // fall thru'
        case SIZEMODE_FULLSIZE:
        case SIZEMODE_PAGE:
            Assert(psize->cx >= 0);
            grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
            break;

        case SIZEMODE_MINWIDTH:
            // MINWIDTH mode shouldn't be called for layouts with changed layout flow
            // because of special MIN/MAX pass
        default:
            Assert(FALSE);
            break;
        }
        pci->_fContentSizeOnly = fContentSizeOnly;
    }

    return grfReturn;
}

DWORD
CFlowLayout::CalcSizeSearch(CCalcInfo * pci,
                            LONG lWidthStart,       // (IN)  last used logical width (for stop algorithm)
                            LONG lHeightProp,       // (IN)  requested logical height
                            const SIZE * psizeMin,  // (IN)  minimum size
                            const SIZE * psizeMax,  // (IN)  maximum size
                            SIZE * psize)           // (OUT) output size
{
    DWORD grfReturn = 0;
    BOOL fNeedRecalc = FALSE;
    BOOL fDone = FALSE;
    BOOL fFastSolution = TRUE;
    BOOL fViewChain =   pci->GetLayoutContext() 
                    &&  pci->GetLayoutContext()->ViewChain();

    CSizeUV start(psizeMin->cx, psizeMin->cy);
    CSizeUV end(psizeMax->cx, psizeMax->cy);
    CSizeUV sizeProp;
    CSizeUV sizeChar;
    LONG dur, dvr, durOld;

    dur = lWidthStart;
    dvr = 0;

    GetAveCharSize(pci, (PSIZE)&sizeChar);

    //
    // Find cell's width for specified height
    // Start search of most accurate solution.
    //
    while (!fDone)
    {
        // This assert may fire. If it does, then its an interesting case which needs to be handled below.
        Assert(start.cv > end.cv);

        //
        // Averaging the area of the layout and then dividing by the proposed v-dimension 
        // to get the U dimension to measure at 
        //
        durOld = dur;

        //  use floating point arithmetic to avoid overflow numarical overflow in hi-res modes : 
        dur =  IntNear(    (((double)start.cu * (double)start.cv + (double)end.cu * (double)end.cv) * 0.5) 
                          / ((double)lHeightProp) );

        if (fFastSolution)
        {
            LONG durNew;
            durNew = (psizeMax->cx * psizeMax->cy) / lHeightProp;
            // keep within min/max range
            durNew = max(min(durNew, psizeMax->cx), psizeMin->cx);

            dur = max(durNew, dur);
        }
        else
        {
            // Note here we are using BOTH the hint from the area of the cell
            // and the mid-point of the current range. This allows us to converge
            // to a solution faster than if we used either one individually.
            dur = (dur + (start.cu + end.cu) / 2) / 2;
        }
        // Make dur a multiple of ave char width
        if (sizeChar.cu)
            dur = sizeChar.cu * (1 + ((dur - 1) / sizeChar.cu));
        // The above snapping to multiple of durMin may put us beyond end.cu, so
        // let us prevent that.
        dur = min(dur, end.cu);

        if (    fViewChain
             && ElementCanBeBroken() )        
        {
            //  In print view pci->_cxAvailForVert is transformed pci->_cyAvail, 
            //  and here we should not be bigger that that. 
            Assert(pci->_cxAvailForVert > 0);
            dur = min(dur, (LONG)pci->_cxAvailForVert);
        }

        if (dur == durOld)
        {
            // Avoid infinite loop; reduce dur by sizeChar.cu and keep it in our search range
            dur = max(start.cu, dur - sizeChar.cu);
        }

        sizeProp.SetSize(dur, 0);
        grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeProp);
        dvr = sizeProp.cv;

        // 
        // Note in the fastSolution, we do not check if the computed dvr is within
        // 'x' percent of dvrmax (the proposed v value). Hence, if we are leaving 
        // too much white space it is because of the fastSolution. We can fix this
        // if needed, but will sacrifice perf for it.
        //
        // Note: in the fastSolution, we use larger tolerance than in regular search pass.
        //
        if (    dvr <= lHeightProp 
            &&  (   (   (fFastSolution && dvr >= (LONG)(lHeightProp * ccErrorAcceptableLowForFastSolution))
                    ||  dvr >= (LONG)(lHeightProp * ccErrorAcceptableLow)))
                    //  In print view we may have no content left to calc so just leave.
                ||  (   fViewChain 
                    &&  ElementCanBeBroken() 
                    &&  !pci->_fLayoutOverflow)   )
        {
            fDone = TRUE;
        }

        //
        // This is a bad case, we have ended up with a dvr which is greater than the
        // max which we had reported / smaller than the min which we had reported.
        // In this case, we will just size to min v. (actually not min v but the
        // last computed v which was lesser than the proposed v)
        //
        else if (dvr < end.cv || dvr > start.cv)
        {
            fDone = fNeedRecalc = TRUE;
            dur = end.cu;
            dvr = end.cv;
            MtAdd(Mt(LFCCalcSizeNaturalSlowAbort), 1, 0);
        }

        //
        // If we have reached the minimum resolution at which we will measure, then break.
        // We could go on till the difference is 1 px between start and end, but in most
        // cases there is little added value by computing beyond the width of a character
        // (i.e. durMin).
        //
        else if (sizeChar.cu >= (end.cu - start.cu) / 2)
        {
            fDone = TRUE;
            if (dvr > lHeightProp)
            {
                fNeedRecalc = TRUE;
                dur = end.cu;
                dvr = end.cv;
            }
        }

        //
        // If we have reached end point again, then break.
        //
        else if (dur == end.cu && dvr == end.cv)
        {
            fDone = TRUE;
            fNeedRecalc = TRUE;
            dur = end.cu;
            dvr = end.cv;
        }

        // This is the case where the above approximation algorithmus hasn't
        // come up with a real progress. dur and dvr felt back to start.cu and
        // start.cv. But in that case dvr is greater than lHeightProp and this
        // is not a proper solution. We force a progress by increasing
        // start.cu by one average character. 
        else if (dur == start.cu && dvr == start.cv)
        {
            Assert(dvr > lHeightProp);

            dur += sizeChar.cu;
            start.SetSize (dur, 0);
            grfReturn |= CalcSizeCore(pci, (PSIZE)&start);

            fDone = (   start.cv <= lHeightProp // if the changes lead to a solution break
                    ||  dvr == start.cv );      // or no progress was made 
            dvr = start.cv;
        }

        //
        // Preare to the next iteration step.
        //
        else
        {
            // Reduce searching range
            if (dvr > lHeightProp)
                start.SetSize(dur, dvr);
            else
                end.SetSize(dur, dvr);
        }

        if (fFastSolution)
        {
            fFastSolution = FALSE;
#if DBG==1
            if (fDone)
                MtAdd(Mt(LFCCalcSizeNaturalFast), 1, 0);
            else
                MtAdd(Mt(LFCCalcSizeNaturalSlow), 1, 0);
#endif
        }
    } // while(!fDone)

    ((CSize*)psize)->SetSize(dur, dvr);
    if (fNeedRecalc)
    {
        psize->cy = 0;
        grfReturn |= CalcSizeCore(pci, psize);
    }

    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeCore
//
//  Synopsis:   Calculate the size of the object
//
//      the basic flow of this routine is as follows:
//      0. get the original size.
//      1. determin if we need to recalc, if Yes :
//          a. get the default size (as set by height= and widht= attributes)
//          b. get the padding and border sizes (this leaves a rough idea for content size
//          c. CalcTextSize
//          d. deal with scroll paddin
//          e. if this is a layoutBehavior delegate 
//          f. if this element is sizeToContent and has % children recalc children
//          g. if (f) gives us a new size redelegate (e)
//      2. Deal with absolute positioned children
//      3. Set the new size values in the dispNode
//
//--------------------------------------------------------------------------
DWORD
CFlowLayout::CalcSizeCore(CCalcInfo * pci, 
                          SIZE      * psize, 
                          SIZE      * psizeDefault)
{
    if (    ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        return (CalcSizeCoreCSS1Strict(pci, psize, psizeDefault));
    }

    return (CalcSizeCoreCompat(pci, psize, psizeDefault));
}

DWORD
CFlowLayout::CalcSizeCoreCompat( CCalcInfo * pci,
                           SIZE      * psize,
                           SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CheckSz(    !ElementOwner()->HasMarkupPtr() 
            ||  (   !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() 
                &&  !ElementOwner()->GetMarkupPtr()->IsHtmlLayout() ), 
           "CFlowLayout::CalcSizeCoreCompat is called to calculate CSS1 Strict Layout");

    CTreeNode * pNode       = GetFirstBranch();
    // BODYs inside viewlinks in general are NOT considered "main body"s,
    // but BODYs inside layout rects (which are viewlinks) ARE.
    BOOL fMainBody =   (    Tag() == ETAG_BODY
                        &&  !ElementOwner()->IsInViewLinkBehavior(FALSE) );

#if DBG == 1
    if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
    {
        MtAdd(Mt(LFCCalcSizeCore), 1, 0);
    }
#endif

    CSaveCalcInfo   sci(pci, this);
    CScopeFlag      csfCalcing(this);

    BOOL  fNormalMode = pci->IsNaturalMode();
    BOOL  fRecalcText = FALSE;
    BOOL  fWidthChanged, fHeightChanged;
    CSize sizeOriginal;
    SIZE  sizeSave;
    DWORD grfReturn;
    CPeerHolder * pPH = ElementOwner()->GetLayoutPeerHolder();

    AssertSz(pci, "no CalcInfo passed to CalcSizeCoreCompat");
    Assert(psize);

    pci->_pMarkup = GetContentMarkup();

    Assert(!IsDisplayNone());

    BOOL fViewChain   = (pci->GetLayoutContext() && pci->GetLayoutContext()->ViewChain());

    // NOTE (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    Listen();

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
    {
        StartCAP();
    }
#endif
  
    //
    // Set default return values and initial state
    //
    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    GetSize(&sizeOriginal);

    fWidthChanged   = fNormalMode && _sizePrevCalcSizeInput.cx != psize->cx;
    fHeightChanged  = fNormalMode && _sizePrevCalcSizeInput.cy != psize->cy;

    _sizePrevCalcSizeInput = *psize;

    //
    // If height has changed, mark percentage sized children as in need of sizing
    // (Width changes cause a full re-calc and thus do not need to resize each
    //  percentage-sized site)
    //

    if (    fNormalMode
        && !fWidthChanged
        && !ContainsVertPercentAttr()
        &&  fHeightChanged)
    {
        long fContentsAffectSize = _fContentsAffectSize;

        _fContentsAffectSize = FALSE;
        ResizePercentHeightSites();
        _fContentsAffectSize = fContentsAffectSize;
    }

    //
    // For changes which invalidate the entire layout, dirty all of the text
    //

    fRecalcText =   (fNormalMode && (   IsDirty()
                                    ||  IsSizeThis()
                                    ||  fWidthChanged
                                    ||  fHeightChanged))
                ||  (pci->_grfLayout & LAYOUT_FORCE)
                ||  (pci->_smMode == SIZEMODE_SET)
                ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
                ||  (pci->_smMode == SIZEMODE_MINWIDTH && !_fMinMaxValid);

    if (!fRecalcText && fViewChain && ElementCanBeBroken()) // (olego) fix for 21322
    {
        // propogate information stored in page break (if any) into pci 
        CLayoutBreak *  pLayoutBreak; 

        pci->GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
        CheckSz(pLayoutBreak, "Ending layout break is expected at this point");

        if (pLayoutBreak)
        {
            if (DYNCAST(CFlowLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
                pci->_fLayoutOverflow = TRUE;
        }
    }

    //
    // Cache sizes and recalculate the text (if required)
    //

    if (fRecalcText)
    {
        BOOL        fNeedShiftLines = FALSE;
        SIZE        sizeUser    = g_Zero.size;
        SIZE        sizePadding = g_Zero.size;
        SIZE        sizeInset   = g_Zero.size;
        SIZE        sizeDefault;
        SIZE        sizeProposed = {0,0};
        CBorderInfo bi;
        LONG        bdrH = 0 , bdrV = 0;
        BOOL        fContentAffectWidth = FALSE;
        BOOL        fContentAffectHeight = FALSE;
        BOOL        fHasWidth = FALSE;
        BOOL        fHasHeight = FALSE;
        BOOL        fHasDefaultWidth  = FALSE;
        BOOL        fHasDefaultHeight = FALSE;
        BOOL        fWidthClipContent = FALSE;
        BOOL        fHeightClipContent = FALSE;
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        BOOL fWidthPercent  = pFF->IsLogicalWidthPercent(fVerticalLayoutFlow, fWritingModeUsed);
        BOOL fHeightPercent = pFF->IsLogicalHeightPercent(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        styleOverflow overflowX;
        styleOverflow overflowY;
        BOOL fNeedToSizeDispNodes = pci->_fNeedToSizeContentDispNode;

        BOOL fHasInsets = FALSE;
        BOOL fSpecialLayout =    Tag() == ETAG_TD
                             ||  Tag() == ETAG_TH
                             ||  Tag() == ETAG_CAPTION
                             ||  Tag() == ETAG_TC
                             ||  fMainBody
                             ||  Tag() == ETAG_INPUT
                                 && DYNCAST(CInput, ElementOwner())->GetType() == htmlInputFile;

        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
            
        //
        // If dirty, ensure display tree nodes exist
        //
        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // don't move this above Ensuredispnode
        // since the element overflow might be changed
        //

        overflowX = pFF->GetLogicalOverflowX(   fVerticalLayoutFlow,
                                                fWritingModeUsed);
        overflowY = pFF->GetLogicalOverflowY(   fVerticalLayoutFlow,
                                                fWritingModeUsed);


        if (fViewChain)
        {
            // 
            //  Defensive code if there is no available height to fill prohibit breaking. 
            //
            if (pci->_cyAvail <= 0 )
            {
                SetElementCanBeBroken(FALSE);
            }

            // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
            // that prohibit layout breaking in Page View. This approach is not suffitient 
            // enouth for editable Page View there we want this property to be calculated 
            // dynamically depending on layout type and layout nesting position (if parent 
            // has it child should inherit). 
            // This work also will enable CSS attribute page-break-inside support.

            if (!fMainBody && ElementCanBeBroken())
            {
                //  Allow to break only if 
                //  1) element is not absolute positioned; 
                //  2) doesn't have certain overflow attribute set; 
                SetElementCanBeBroken(    !pFF->IsAbsolute()
                                        && overflowX != styleOverflowScroll 
                                       && overflowX != styleOverflowAuto 
                                       && overflowY != styleOverflowScroll
                                       && overflowY != styleOverflowAuto    );
            }

            fViewChain = fViewChain && ElementCanBeBroken();
        }

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            fHasWidth  = !cuvWidth.IsNullOrEnum();
            fHasHeight = !cuvHeight.IsNullOrEnum();
            fWidthClipContent  = (  overflowX != styleOverflowVisible
                                 && overflowX != styleOverflowNotSet);
            fHeightClipContent = (  overflowY != styleOverflowVisible 
                                 && overflowY != styleOverflowNotSet);

            if (ElementOwner()->GetBorderInfo(pci, &bi, FALSE, FALSE))
            {
                bdrH = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
                bdrV = bi.aiWidths[SIDE_BOTTOM] + bi.aiWidths[SIDE_TOP];
            }

            // Get element's default size
            // Buttons don't have default w/h and return a 0 default size.
            // Text INPUTs and TEXTAREAs have both default width and height.
            // Marquees have default height.
            sizeDefault = *psize;
            GetDefaultSize(pci, sizeDefault, &fHasDefaultWidth, &fHasDefaultHeight);

            // use astrology to determine if we need to size to content
            if (    !fHasWidth 
                &&  !fHasDefaultWidth
                &&  !fMainBody
                &&  (
                            pFF->_bStyleFloat == styleStyleFloatLeft
                        ||  pFF->_bStyleFloat == styleStyleFloatRight
                        ||  !ElementOwner()->IsBlockElement()
                        ||  ElementOwner()->IsAbsolute()
                    )
                &&
                    // If we're in home publisher, we don't want to size to content.
                    (
                            !(Doc()->_fInHomePublisherDoc || g_fInHomePublisher98)
                        ||  !ElementOwner()->IsAbsolute()
                    )
// TODO (lmollico): should go away
                &&  ElementOwner()->_etag != ETAG_FRAME
                )
            {
                _fSizeToContent = TRUE;
            }
            else
            {
                _fSizeToContent = FALSE;
            }

            if (fWidthPercent && !fNormalMode)
            {
                sizeUser.cx = 0;
            }
            else
            {
                if (fHasWidth)
                {
                    LONG lParentWidth;
                    if (   fWidthPercent 
                        && ElementOwner()->IsAbsolute() 
                        && fVerticalLayoutFlow)
                    {
                        lParentWidth = pci->_sizeParent.cx;
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcxPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcxPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcxPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the width
                        lParentWidth += lcxPadding;
                    }
                    else if (   fWidthPercent 
                             && fVerticalLayoutFlow)
                    {
                        lParentWidth = 0;

                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                        CTreeNode * pNodeParent = pNode->Parent();
                        while (pNodeParent && !pNodeParent->Element()->IsBlockElement())
                        {
                            pNodeParent = pNodeParent->Parent();
                        }
                        if (pNodeParent)
                        {
                            const CUnitValue & cuvWidthParent = pNodeParent->GetFancyFormat()->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                            if (!cuvWidthParent.IsNullOrEnum() && !cuvWidthParent.IsPercent())
                            {
                                lParentWidth = cuvWidthParent.XGetPixelValue(pci, 0, pNodeParent->GetFontHeightInTwips(&cuvWidthParent));
                            }
                            else if (cuvWidthParent.IsPercent() || pNodeParent->Tag() == ETAG_BODY)
                            {
                                lParentWidth = pci->_sizeParent.cx;
                            }
                        }
                    }
                    else
                    {
                        lParentWidth = pFF->_fAlignedLayout ? pci->_sizeParent.cx : psize->cx;
                    }

                    sizeUser.cx = cuvWidth.XGetPixelValue(pci, lParentWidth,
                                    pNode->GetFontHeightInTwips(&cuvWidth));
                }
                else
                {
                    sizeUser.cx = sizeDefault.cx;
                }
            }

            if (fHeightPercent && !fNormalMode)
            {
                sizeUser.cy = 0;
            }
            else
            {
                if (fHasHeight)
                {
                    LONG lParentHeight = pci->_sizeParent.cy;
                    if (   fHeightPercent 
                        && ElementOwner()->IsAbsolute() 
                        && !fVerticalLayoutFlow)
                    {
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcyPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcyPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcyPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the height
                        lParentHeight += lcyPadding;
                    }

                    // 
                    // Complience to CSS2 percentage sizing...
                    // 
                    // This code is to ignore percentage height attribute if the element's *block* parent 
                    // doesn't have height explicitly specified. There are several tricky points here...
                    //
                    //  If the element doesn't have *percentage* size OR if this is a iframe do call right away...
                    if (!fHeightPercent)
                    {
                        sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                    pNode->GetFontHeightInTwips(&cuvHeight));
                    }
                    else 
                    {
                        BOOL        fIgnoreUserPercentHeight = TRUE;

                        if (pFF->IsPositioned())
                        {
                            CElement *pElementZParent = pNode->ZParent(); 
                            Assert( pElementZParent 
                                &&  "pElementZParent == NULL means the element is not in the Tree. Why are we measuring it anyway ?");

                            if (pElementZParent)
                            {
                                if (    pElementZParent->ShouldHaveLayout() 
                                    //  FUTURE (olego): we should try to avoid "special" checks like this:
                                    ||  (  pElementZParent->TagType() == ETAG_GENERIC 
                                        && pElementZParent->HasPeerHolder()
                                        )    
                                    ||  (  pElementZParent->TagType() == ETAG_ROOT
                                        && pElementZParent->HasMasterPtr()
                                        )
                                   )
                                {
                                    sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                                pNode->GetFontHeightInTwips(&cuvHeight));

                                    if (    !sizeUser.cy
                                        &&  pci->_fTableCalcInfo    )
                                    {

                                        CTreeNode * pNodeCur;

                                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                                        for (pNodeCur = pNode->Parent(); pNodeCur; pNodeCur = pNodeCur->Parent())
                                        {
                                            if (    pNodeCur->Tag() == ETAG_TD 
                                                ||  pNodeCur->Tag() == ETAG_TH  )
                                            {
                                                CTableCalcInfo *ptci = (CTableCalcInfo *)pci;

                                                Assert(     ptci->_pRow 
                                                        &&  ptci->_pRowLayout 
                                                        &&  ptci->_pFFRow 
                                                        &&  ptci->_pRowLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext())) == ptci->_pFFRow );

                                                //  If the layout is inside a table cell it's provided with zero height 
                                                //  during table normal calc size pass (always). If table cell has size 
                                                //  set, the layout will have a chance to calc itself one more time during 
                                                //  set calc size pass. We want to predict this and still override natual 
                                                //  size in this case.

                                                //  NOTE: checks below MUST stay consistent with code in CTableLayout::SetCellPositions !!!
                                                if (    ptci->_fTableHasUserHeight 
                                                    ||  ptci->_pRow->RowLayoutCache()->IsHeightSpecified() 
                                                    ||  ptci->_pFFRow->IsHeightPercent()    )
                                                {
                                                    sizeUser.cy = 1;
                                                }
                                            }
                                            // If this is a block element and not a table cell stop searching 
                                            else if (pNodeCur->Element()->IsBlockElement())
                                            {
                                                break;
                                            }
                                        }
                                    }

                                    fIgnoreUserPercentHeight = FALSE;
                                } 
                            }
                        }
                        else 
                        {
                            CTreeNode * pNodeCur;

                            // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                            for (pNodeCur = pNode->Parent(); pNodeCur; pNodeCur = pNodeCur->Parent())
                            {
                                // If the current element has/should have a layout or 
                                // (bug #108387) this is a generic element with peer holder 
                                // (in which case it has no layout but should be treated as 
                                // an element with one)... Do calculations and stop.
                                if (    pNodeCur->Element()->ShouldHaveLayout() 
                                    //  FUTURE (olego): we should try to avoid "special" checks like this:
                                    ||  (  pNodeCur->Element()->TagType() == ETAG_GENERIC 
                                        && pNodeCur->Element()->HasPeerHolder()
                                        )    
                                    ||  (  pNodeCur->Element()->TagType() == ETAG_ROOT
                                        && pNodeCur->Element()->HasMasterPtr()
                                        )
                                   )
                                {
                                    sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                                pNode->GetFontHeightInTwips(&cuvHeight));

                                    if (    !sizeUser.cy
                                        &&  (   pNodeCur->Tag() == ETAG_TD 
                                            ||  pNodeCur->Tag() == ETAG_TH )
                                        //  make sure this cell is inside a table.
                                        &&  pci->_fTableCalcInfo    )
                                    {
                                        CTableCalcInfo *ptci = (CTableCalcInfo *)pci;

                                        Assert(     ptci->_pRow 
                                                &&  ptci->_pRowLayout 
                                                &&  ptci->_pFFRow 
                                                &&  ptci->_pRowLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext())) == ptci->_pFFRow );

                                        //  If the layout is inside a table cell it's provided with zero height 
                                        //  during table normal calc size pass (always). If table cell has size 
                                        //  set, the layout will have a chance to calc itself one more time during 
                                        //  set calc size pass. We want to predict this and still override natual 
                                        //  size in this case.

                                        //  NOTE: checks below MUST stay consistent with code in CTableLayout::SetCellPositions !!!
                                        if (    ptci->_fTableHasUserHeight 
                                            ||  ptci->_pRow->RowLayoutCache()->IsHeightSpecified() 
                                            ||  ptci->_pFFRow->IsHeightPercent()    )
                                        {
                                            sizeUser.cy = 1;
                                        }
                                    }

                                    fIgnoreUserPercentHeight = FALSE;
                                    break;
                                } 
                                // If this is a block element and it has no layout 
                                // (previous check failed) ignore percentage height by 
                                // breaking out of the loop.
                                else if (pNodeCur->Element()->IsBlockElement())
                                {
                                    break;
                                }
                            }
                        }

                        // bug (70270, 104514) % sized Iframes in tables are not being sized properly.
                        // this is because the parent height comes in as 0, and we don't default
                        // back to our defult size, so take the size as the specified percentage
                        // of the defualt height.
                        if (   fNormalMode
                            && Tag() == ETAG_IFRAME
                            && sizeUser.cy == 0)
                        {
                            sizeUser.cy = cuvHeight.GetPercentValue(
                                           CUnitValue::DIRECTION_CY, 
                                           (lParentHeight == 0) ? 150 : lParentHeight);
                            fIgnoreUserPercentHeight = FALSE;
                        }

                        if (fIgnoreUserPercentHeight) 
                        {
                            //  (bug #108565) at this point we fail to set user specified 
                            //  height. This may happen because of the code above decided 
                            //  not to apply it or if this layout is inside table cell (and 
                            //  its been provided with 0 parent height). At this point 
                            //  logical to drop fHasHeight and fHeightPercent flags to 
                            //  prevent confusion of the code below...
                            fHasHeight      = FALSE;
                            fHeightPercent  = FALSE;
                            sizeUser.cy     = sizeDefault.cy;
                        }
                    }

                    if (fHasHeight)
                    {
                        if (fViewChain)
                        {
                            sizeUser.cy = GetUserHeightForBlock(sizeUser.cy);
                        }
                    }
                }
                else
                {
                    sizeUser.cy = sizeDefault.cy;
                }
            }

            // The BODY's content never affects its width/height (style specified
            // w/h and/or container size (usually <HTML> and/orframe window) determine
            // BODY size).
            // In general, contents affects w/h if:
            //    1.) w/h isn't style-specified and there's no default w/h.
            // OR 2.) overflowX/Y == visible or not set (meaning f*ClipContent is false).
            // 
            // once we can support vertical center, we can remove the Tag
            //         check for buttons
            fContentAffectWidth =     !fMainBody
                                  &&  Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasWidth && !fHasDefaultWidth
                                      ||  !fWidthClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            fContentAffectHeight =    !fMainBody
                                  &&  Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasHeight && !fHasDefaultHeight
                                      ||  !fHeightClipContent
                                      ||  !sizeUser.cy 
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            _fContentsAffectSize = fContentAffectWidth || fContentAffectHeight;

            // set the (proposed) size to the default/attr-defined size + parentPadding.
// TODO (lmollico): should go away
            if (ElementOwner()->_etag != ETAG_FRAME)
                *psize = sizeUser;

            if (   fNormalMode
                || (   pci->_smMode==SIZEMODE_MMWIDTH 
                    && ( fHeightPercent || fWidthPercent)))
            {
                if (   fContentAffectHeight 
                    && !fHeightPercent )
                {
                    // when dealing with vertical flow we can't assume a height of zero as we size
                    // to the content, this is because we will end up word wrapping as this height
                    // is used as a width.
                    psize->cy = 0;
                }

                //
                // only marquee like element specify a scroll padding
                // which is used for vertical scrolling marquee
                // 
                sizePadding.cx  = max(0L, sizeUser.cx - bdrH);
                sizePadding.cy  = max(0L, sizeUser.cy - bdrV);

                GetScrollPadding(sizePadding);


                if (sizePadding.cx || sizePadding.cy)
                {
                    // make sure the display is fully recalced with the paddings
                    _dp._defPaddingTop      = sizePadding.cy;
                    _dp._defPaddingBottom   = sizePadding.cy;
                    _dp._fDefPaddingSet     = !!sizePadding.cy;

                    // marquee always size to content
                    _fSizeToContent = TRUE;
                }
            }

            if (    !ParentClipContent()
                &&  ElementOwner()->IsAbsolute()
                &&  (!fHasHeight || !fHasWidth)
               )
            {
                CRect rcSize;
                CalcAbsoluteSize(pci, psize, &rcSize);

                if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
                {
                    rcSize.SetWidth(max(rcSize.Width(), sizeUser.cx));
                    rcSize.SetHeight(max(rcSize.Height(), sizeUser.cx));
                }

                //  109440, for FRAME's that are APE, we do not want the height set to 0
                psize->cx = !fHasWidth  ? max(0L, rcSize.Width()) : max(0L, sizeUser.cx);
                psize->cy = !fHasHeight 
                                ? ((Tag() == ETAG_FRAME) ? max(0L, rcSize.Height()) : 0 )
                                : max(0L, sizeUser.cy);
            }

            // in NF, IFrames use the std flowlayout. For back compat the size specified (even if default)
            // needs to be INSIDE the borders, whereas for all others it is outside.  Since the border sizes
            // are removed from the proposedSize in CalcTextSize
            if (Tag() == ETAG_IFRAME)
            {
                CDispNodeInfo   dni;
                GetDispNodeInfo(&dni, pci, TRUE);

                if (dni.GetBorderType() != DISPNODEBORDER_NONE)
                {
                    CRect   rcBorders;

                    dni.GetBorderWidths(&rcBorders);

                    if (!fWidthPercent)
                        psize->cx    += rcBorders.left + rcBorders.right;

                    if (!fHeightPercent)
                        psize->cy    += rcBorders.top  + rcBorders.bottom;
                }
            }

        }


        sizeProposed = *psize;

        //
        // Calculate the text
        //

        //don't do CalcTextSize in minmax mode if our text size doesn't affect us anyway.
        if(     _fContentsAffectSize || fNormalMode 
            ||  fWidthPercent)  //  preserving backward compat (bug 27982)
        {
            CalcTextSize(pci, psize, psizeDefault);
        }
        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            psize->cy = psize->cx;
        }

        sizeSave = *psize;

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            sizeInset = sizeUser;
            fHasInsets = GetInsets(pci->_smMode, sizeInset, *psize, fHasWidth, fHasHeight, CSize(bdrH, bdrV));
            if (sizeSave.cx != psize->cx)
            {
                grfReturn      |= LAYOUT_HRESIZE;
                fNeedShiftLines = TRUE;
            }

            if (fNormalMode)
            {
                if (sizePadding.cx || sizePadding.cy)
                {
                    SIZE szBdr;

                    szBdr.cx = bdrH;
                    szBdr.cy = bdrV;
                    // We need to call GetScrollPadding, because now we know the text size
                    // we will update scroll parameters

                    SetScrollPadding(sizePadding, *psize, szBdr);

                    fNeedShiftLines = TRUE;
                    *psize = sizeUser;

                    // if the marquee like element is percentage sized or
                    // its size is not specified, its size should be the
                    // default size.
                    // if the default size or the css style size is less 
                    // or equal than 0, marquee like element should not be sized
                    // as such according to IE3 compatibility requirements

                    if ((fHeightPercent || !fHasHeight) && sizeUser.cy <= 0)
                    {
                        psize->cy = _dp.GetHeight() + bdrV; 
                    }
                    else if (!ContainsVertPercentAttr() && sizePadding.cx > 0)
                    {
                        //
                        // if the marquee is horizontal scrolling,
                        // the height should be at least the content high by IE5.
                        //
                        psize->cy = max(psize->cy, _dp.GetHeight() + bdrV);
                    }

                    if (!fHasWidth && sizeUser.cx <= 0)
                    {
                        psize->cx = _dp.GetWidth() + bdrH;
                    }
                }

                else if (fHasWidth && (fWidthClipContent || psize->cx < sizeUser.cx))
                {
                    if (psize->cx != sizeUser.cx)
                    {
                        fNeedShiftLines = TRUE;
                    }
                    psize->cx = max(0L, sizeUser.cx);
                }
                else if (   _fSizeToContent
                        && !((fHasDefaultWidth || fHasWidth || (sizeProposed.cx != psize->cx)) && fWidthClipContent))
                {
                    // when size to content and the width does not 
                    // clip the content, we need to clip on the parent
                    fNeedShiftLines = TRUE;

                    psize->cx = _dp.GetWidth() + bdrH;
                }

                if (fHasHeight)
                {
                    if (fViewChain)
                    {
                        if (psize->cy < sizeUser.cy)
                        {
                            psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                        }
                    }
                    else if (  !pci->_fContentSizeOnly
                            && sizeUser.cy 
                            && (   fHeightClipContent 
                                || psize->cy < sizeUser.cy))
                    {
                        psize->cy = max(0L, sizeUser.cy);
                    }
                }
            }
            else
            {
                if (fHasWidth || !_fContentsAffectSize)
                {
                    // cy contains the min width
                    if (pci->_smMode == SIZEMODE_MMWIDTH)
                    {
                        if (fWidthClipContent)
                        {
                            if (!fWidthPercent)
                            {
                                psize->cy = sizeProposed.cx;
                                psize->cx = psize->cy;
                            }
                        }
                        else
                        {
                            if (_fContentsAffectSize)
                            {
                                Assert(fHasWidth);
                                psize->cy = max(psize->cy, sizeProposed.cx);
                                if (!fWidthPercent)
                                    psize->cx = psize->cy;
                                Assert(psize->cx >= psize->cy);
                            }
                            else
                            {
                                if (!fWidthPercent)
                                {
                                    psize->cx = psize->cy = sizeProposed.cx;
                                }
                                else if (   Tag() == ETAG_IFRAME
                                         && pci->_smMode == SIZEMODE_MMWIDTH
                                         && sizeProposed.cx == 0)
                                {
                                    // bug 70270 - don't let minmax return 0 or else we will never display.
                                    psize->cy = 0; 
                                    psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);

                                }
                            }
                        }
                    }
                    else
                    {
                        // Something in TD causes min width to happen
                        if (   !_fContentsAffectSize
                            && fWidthPercent
                            && Tag() == ETAG_IFRAME
                            && sizeProposed.cx == 0
                            && pci->_smMode == SIZEMODE_MINWIDTH
                            )
                        {
                            // bug 70270
                            psize->cy = 0;
                            psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);
                        }
                        else
                        {
                            Assert(pci->_smMode == SIZEMODE_MINWIDTH);
                            *psize = sizeProposed;
                        }
                    }
                }
            }
        }

        //
        // Before we can cache the computed values and request layout tasks
        //  (positioning) we may need to give layoutBehaviors a chance to 
        //  modify the natural (trident-default) sizing of this element.
        //  e.g. a "glow behavior" may want to increase the size of the 
        //  element that it is instantiated on by 10 pixels in all directions,
        //  so that it can draw the fuzzy glow; or an external HTMLbutton
        //  is the size of its content + some decoration size.
        //
        if (   pPH   
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            POINT pt;

            pt.x = sizePadding.cx;
            pt.y = sizePadding.cy;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, 
                             pci, 
                             CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                             &pt, psize);


            if (psize->cx != sizeUser.cx)
            {
                fNeedShiftLines = TRUE;
            }

            if (pt.x != sizePadding.cx)
            {
                sizeInset.cx += max(0L, pt.x - sizePadding.cx);
            }

            if (pt.y != sizePadding.cy)
            {
                sizeInset.cy += max(0L, pt.y - sizePadding.cy); 
            }
        }


        //
        // we have now completed the first pass of calculation (and possibly) delegation.
        // However, before we can finaly save the computed values, we have to verify that 
        // our percent sized children (if they exist) are resized, this is critical if we
        // ourselves are sized to content.
        //

        if (   fNormalMode 
            && !fSpecialLayout 
            && _fContentsAffectSize
            && (   ContainsHorzPercentAttr()
                || (ContainsVertPercentAttr() && fHasHeight)    )
           )
        {
            unsigned fcasSave = _fContentsAffectSize;
            BOOL     fpspSave = pci->_fPercentSecondPass;
            LONG     lUserHeightSave = sizeUser.cy;
            SIZE     sizeReDo;

            sizeReDo.cx = fHasWidth ? sizeProposed.cx : psize->cx;
            sizeReDo.cy = fHasHeight ? psize->cy : 0;

            _sizeReDoCache = sizeReDo;

            sizeUser = *psize;

            if (fViewChain)
            {
                pci->_fHasContent     = sci._fHasContent;
                pci->_fLayoutOverflow = 0;
            }

            pci->_fPercentSecondPass = TRUE;

            _fContentsAffectSize = FALSE;
            ResizePercentHeightSites();
            _fContentsAffectSize = fcasSave;

            CalcTextSize(pci, &sizeReDo, psizeDefault);

            if (sizeSave.cy != sizeReDo.cy && fContentAffectHeight)
            {
                SIZE szBdr;

                szBdr.cx = bdrH;
                szBdr.cy = bdrV;
                //
                // if we have increased the psize->cy, and we are delegating the size call
                // we need to give the control one more whack... but rememeber we have the
                // _fPercentSeconPass lit up so they can take the appropriate action.
                //
                if (   pPH   
                    && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
                {
                    DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                     pPH, 
                                     pci, 
                                     CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                                     (LPPOINT)&sizeInset, 
                                     &sizeReDo);

                }

                if (sizePadding.cy)
                {
                    // we need to set the new scrollpadding

                    SetScrollPadding(sizePadding, *psize, szBdr);
                    psize->cy = _dp.GetHeight() + bdrV; 
                }
                else
                {
                    psize->cy = fHasHeight ? max(lUserHeightSave, sizeReDo.cy) : sizeReDo.cy;
                }
            }

            if (    psize->cx != sizeReDo.cx
                &&  fContentAffectWidth
                &&  !sizePadding.cx)
            {
                psize->cx = sizeReDo.cx;
            }

            fNeedShiftLines = fNeedShiftLines || (psize->cx != sizeUser.cx);

            pci->_fPercentSecondPass = fpspSave;
        }
        // psize is finally correct, lets get out of here quick.


        if (    fViewChain 
            &&  !fSpecialLayout
            &&  fHasHeight
            &&  fNormalMode     )
        {
            if (psize->cy < sizeUser.cy)
            {
                psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                pci->_fLayoutOverflow = pci->_fLayoutOverflow || (pci->_cyAvail < sizeUser.cy);
            }

            SetUserHeightForNextBlock(psize->cy, sizeUser.cy);
        }


        //
        // but wait, there is one more thing:
        // if we are a master, then we should size ourselves based on the scroll size
        // of our content. this is necessary to display abs-pos elements. (ie bug 90842)
        // but NOT if we are a layoutRect or a [I]Frame
        //
        // Also, this MUST be done LAST (e.g. after the % sizing 2nd pass) so that we don't
        // initiate a race condition, where something in the slave that is % positioned keeps
        // focing the bounds out.
        //
        if (   fNormalMode 
            && !fSpecialLayout 
            && _fContentsAffectSize                        // implies not a [I]Frame
            && ElementOwner()->HasSlavePtr()              // is Master of a view 
            && !ElementOwner()->IsLinkedContentElement()  // not a layoutRect (printing)
            )
        {
            CMarkup  * pSlaveMarkup = ElementOwner()->GetSlavePtr()->GetMarkup();
            CElement * pSlaveElem = (pSlaveMarkup) ? pSlaveMarkup->GetElementClient() : NULL;

            if (pSlaveElem && !pSlaveMarkup->IsStrictCSS1Document())
            {
    
                CLayout * pSlaveLayout = pSlaveElem->GetUpdatedLayout(LayoutContext());

                Assert(pSlaveLayout);

            // NOTE - this works right now (ie5.5) because the slave is over-calculated.
            // the problem is that the positioning pass (required in order to get the 
            // correct Scroll bounds) doesn't happen until AFTER the measureing pass. so on
            // the first measurement, we are going to size to the flow-content-size, THEN
            // on later measures we will jump to the real scroll extent.
            //
            // (dmitryt) It stopped working in IE6 because we don't overcalc slave anymore.
            // So to make it back working as in IE5.5 (with understanding that bottom- and 
            // right- positioned objects and percent sizing is working weird) - I process
            // requests on slave's body. This is a terrible hack only justified by need
            // to get back to IE5.5 compat. (IE6 bug 1455)

            // <HACK>
            {
                CFlowLayout *pFL = pSlaveLayout->IsFlowLayout();

                if(    pFL 
                    && pFL->ElementOwner()->Tag() == ETAG_BODY
                    && pFL->HasRequestQueue() 
                  )
                {
                        long xParentWidth;
                        long yParentHeight;
                        CCalcInfo CI(pci);

                        CI._grfLayout |= LAYOUT_MEASURE|LAYOUT_POSITION;

                        pFL->GetDisplay()->GetViewWidthAndHeightForChild(
                                pci,
                                &xParentWidth,
                                &yParentHeight,
                                FALSE);


                        pFL->ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
                }
            }
            // </HACK>


                if (pSlaveLayout->GetElementDispNode())
                {
                    CRect rectSlave;
                    CSize sizeSave(*psize);

                    // We need to get our hands on the scrollable bounds.
                    //
                    pSlaveLayout->GetElementDispNode()->GetScrollExtent(&rectSlave);

                    // we want to treat the rect as being 0,0 based even if it isn't/
                    // e.g. the only content is APE, so we need the right, bottom (103545)
                    if (!fHasHeight)
                    {
                        psize->cy = (!pSlaveElem->HasVerticalLayoutFlow()) 
                              ? max(psize->cy, (bdrV + rectSlave.bottom)) 
                              : max(psize->cx, (bdrH + rectSlave.right));
                    }

                    if (!fHasWidth)
                    {
                        psize->cx = (!pSlaveElem->HasVerticalLayoutFlow()) 
                              ? max(psize->cx, (bdrH + rectSlave.right)) 
                              : max(psize->cy, (bdrV + rectSlave.bottom));
                    }

                    // now that we have the correct outer bounds, we need to resize the dispnode of the 
                    // slave to expand into the new space. This is necesary so that we do NOT clip away
                    // APE's
                    if (sizeSave != *psize)
                    {
                        sizeSave.cx = rectSlave.right;
                        sizeSave.cy = rectSlave.bottom;

                        pSlaveLayout->SizeDispNode(pci, sizeSave, TRUE);
                    }
                }
            }
        }


        // NOW we have our correct size and can get out of here.

        //
        // For normal modes, cache values and request layout
        //
        if (fNormalMode)
        {
            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0)
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            if (!fSpecialLayout)
            {
                if (fHasInsets)
                {
                    CSize sizeInsetTemp(sizeInset.cx / 2, sizeInset.cy / 2);
                    _pDispNode->SetInset(sizeInsetTemp);
                }

                if (fNeedShiftLines) // || sizeProposed.cx != psize->cx)
                {
                    CRect rc(CSize(psize->cx - bdrH - sizeInset.cx, _dp.GetHeight()));

                    _fSizeToContent = TRUE;
                    _dp.SetViewSize(rc);
                    _dp.RecalcLineShift(pci, 0);
                    _fSizeToContent = FALSE;
                }
            }

            //
            // If size changes occurred, size the display nodes
            //
            if (   _pDispNode
                && ((grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                    || ( /* update display nodes when RTL overflow changes */
                        IsRTLFlowLayout() 
                        && _pDispNode->GetContentOffsetRTL() != _dp.GetRTLOverflow())
                    || HasMapSizePeer() // always call MapSize, if requested
                    || fNeedToSizeDispNodes
                  )
               ) 

            {
                SizeDispNode(pci, *psize);
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }
            //see call to SetViewSize above - it could change the size of CDisplay
            //without changing the size of layout. We need to resize content dispnode.
            else if(fNeedShiftLines) 
            {
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }

            if (    (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                &&  (psize->cy < _yDescent) )
            {
                //  Layout descent should not exceed layout height (bug # 13413) 
                _yDescent = psize->cy;
            }

            //
            // Mark the site clean
            //
            SetSizeThis( FALSE );
        }

        //
        // For min/max mode, cache the values and note that they are now valid
        //

        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cy, -1);
            _fMinMaxValid = TRUE;
        }

        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }
    }

    //
    // If any absolutely positioned sites need sizing, do so now
    //

    if (    (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        &&  HasRequestQueue())
    {
        long xParentWidth;
        long yParentHeight;

        _dp.GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

        //
        //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
        //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
        //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
        //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
        //  See bugs 69335, 72059, et. al. (greglett)
        //
        CCalcInfo CI(pci);
        CI._grfLayout |= LAYOUT_MEASURE;

        ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
    }

    //
    // Lastly, return the requested size
    //

    switch (pci->_smMode)
    {
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_NATURAL:
    case SIZEMODE_FULLSIZE:
        Assert(!IsSizeThis());

        GetSize((CSize *)psize);

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp = *psize;

            // Get the possibly changed size from the peer
            if (DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
                psize->cy = rectMapped.Height();
            }
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        break;

    case SIZEMODE_MMWIDTH:
        Assert(_fMinMaxValid);
        psize->cx = _sizeMax.cu;
        psize->cy = _sizeMin.cu;
        if (!fRecalcText && psizeDefault)
        {
            GetSize((CSize *)psize);
        }

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp.cx = psize->cy;
            // DelegateMapSize does not like a 0 size, so set the cy to cx
            sizeTemp.cy = sizeTemp.cx;

            // Get the possibly changed size from the peer
            if(DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cy = rectMapped.Width();
                psize->cx = max(psize->cy, psize->cx);
            }
        }

        break;

    case SIZEMODE_MINWIDTH:
        psize->cx = _sizeMin.cu;

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            psize->cy = psize->cx;
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
            }
        }

        psize->cy = 0;

        break;
    }

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
        StopCAP();
#endif

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    return grfReturn;
}

DWORD
CFlowLayout::CalcSizeCoreCSS1Strict( CCalcInfo * pci,
                           SIZE      * psize,
                           SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CheckSz(    !ElementOwner()->HasMarkupPtr() 
            ||  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document(), 
           "CFlowLayout::CalcSizeCoreCSS1Strict is called to calculate non-CSS1 Strict Layout");

    CTreeNode * pNode       = GetFirstBranch();
    // BODYs inside viewlinks in general are NOT considered "main body"s,
    // but BODYs inside layout rects (which are viewlinks) ARE.
    // BODYs in Strict CSS1 documents are never special - they're just like a top-level DIV.
    BOOL fMainBody =   (    Tag() == ETAG_BODY
                        &&  !GetOwnerMarkup()->IsHtmlLayout() 
                        &&  !ElementOwner()->IsInViewLinkBehavior(FALSE) );

#if DBG == 1
    if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
    {
        MtAdd(Mt(LFCCalcSizeCore), 1, 0);
    }
#endif

    CSaveCalcInfo   sci(pci, this);
    CScopeFlag      csfCalcing(this);

    BOOL  fNormalMode = pci->IsNaturalMode();
    BOOL  fRecalcText = FALSE;
    BOOL  fWidthChanged, fHeightChanged;
    CSize sizeOriginal;
    SIZE  sizeSave;
    DWORD grfReturn;
    CPeerHolder * pPH = ElementOwner()->GetLayoutPeerHolder();

    AssertSz(pci, "no CalcInfo passed to CalcSizeCoreCSS1Strict");
    Assert(psize);

    pci->_pMarkup = GetContentMarkup();

    Assert(!IsDisplayNone());

    BOOL fViewChain = (pci->GetLayoutContext() && pci->GetLayoutContext()->ViewChain());

    // NOTE (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    Listen();

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
    {
        StartCAP();
    }
#endif
  
    //
    // Set default return values and initial state
    //
    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    GetSize(&sizeOriginal);

    fWidthChanged   = fNormalMode && _sizePrevCalcSizeInput.cx != psize->cx;
    fHeightChanged  = fNormalMode && _sizePrevCalcSizeInput.cy != psize->cy;

    _sizePrevCalcSizeInput = *psize;

    //
    // For changes which invalidate the entire layout, dirty all of the text
    //

    fRecalcText =   (fNormalMode && (   IsDirty()
                                    ||  IsSizeThis()
                                    ||  fWidthChanged
                                    ||  fHeightChanged))
                ||  (pci->_grfLayout & LAYOUT_FORCE)
                ||  (pci->_smMode == SIZEMODE_SET)
                ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
                ||  (pci->_smMode == SIZEMODE_MINWIDTH && !_fMinMaxValid);

    if (!fRecalcText && fViewChain && ElementCanBeBroken()) // (olego) fix for 21322
    {
        // propogate information stored in page break (if any) into pci 
        CLayoutBreak *  pLayoutBreak; 

        pci->GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
        CheckSz(pLayoutBreak, "Ending layout break is expected at this point");

        if (pLayoutBreak)
        {
            if (DYNCAST(CFlowLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
                pci->_fLayoutOverflow = TRUE;
        }
    }

    //
    // Cache sizes and recalculate the text (if required)
    //

    if (fRecalcText)
    {
        BOOL        fNeedShiftLines = FALSE;
        SIZE        sizeUser    = g_Zero.size;
        SIZE        sizePadding = g_Zero.size;
        SIZE        sizeInset   = g_Zero.size;
        SIZE        sizeDefault;
        SIZE        sizeBorderAndPadding = g_Zero.size;
        SIZE        sizeProposed = g_Zero.size;
        CBorderInfo bi;
        LONG        bdrH = 0 , bdrV = 0;
        BOOL        fContentAffectWidth = FALSE;
        BOOL        fContentAffectHeight = FALSE;
        BOOL        fHasWidth = FALSE;
        BOOL        fHasHeight = FALSE;
        BOOL        fHasDefaultWidth  = FALSE;
        BOOL        fHasDefaultHeight = FALSE;
        BOOL        fWidthClipContent = FALSE;
        BOOL        fHeightClipContent = FALSE;
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        BOOL fWidthPercent  = pFF->IsLogicalWidthPercent(fVerticalLayoutFlow, fWritingModeUsed);
        BOOL fHeightPercent = pFF->IsLogicalHeightPercent(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        styleOverflow overflowX;
        styleOverflow overflowY;
        BOOL fNeedToSizeDispNodes = pci->_fNeedToSizeContentDispNode;

        BOOL fHasInsets = FALSE;
        BOOL fSpecialLayout =    Tag() == ETAG_TD
                             ||  Tag() == ETAG_TH
                             ||  Tag() == ETAG_CAPTION
                             ||  Tag() == ETAG_TC
                             ||  fMainBody
                             ||  Tag() == ETAG_INPUT
                                 && DYNCAST(CInput, ElementOwner())->GetType() == htmlInputFile;

        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
            
        //
        // If dirty, ensure display tree nodes exist
        //
        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // don't move this above Ensuredispnode
        // since the element overflow might be changed
        //

        overflowX = pFF->GetLogicalOverflowX(   fVerticalLayoutFlow,
                                                fWritingModeUsed);
        overflowY = pFF->GetLogicalOverflowY(   fVerticalLayoutFlow,
                                                fWritingModeUsed);


        if (fViewChain)
        {
            // 
            //  Defensive code if there is no available height to fill prohibit breaking. 
            //
            if (pci->_cyAvail <= 0 )
            {
                SetElementCanBeBroken(FALSE);
            }

            // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
            // that prohibit layout breaking in Page View. This approach is not suffitient 
            // enouth for editable Page View there we want this property to be calculated 
            // dynamically depending on layout type and layout nesting position (if parent 
            // has it child should inherit). 
            // This work also will enable CSS attribute page-break-inside support.

            if (!fMainBody && ElementCanBeBroken())
            {
                //  Allow to break only if 
                //  1) element is not absolute positioned; 
                //  2) doesn't have certain overflow attribute set; 
                SetElementCanBeBroken(    !pFF->IsAbsolute()
                                        && overflowX != styleOverflowScroll 
                                       && overflowX != styleOverflowAuto 
                                       && overflowY != styleOverflowScroll
                                       && overflowY != styleOverflowAuto    );
            }

            fViewChain = fViewChain && ElementCanBeBroken();
        }

        // 
        // calc sizeBorderAndPadding
        // 
        if (ElementOwner()->GetBorderInfo(pci, &bi, FALSE, FALSE))
        {
            bdrH = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
            bdrV = bi.aiWidths[SIDE_BOTTOM] + bi.aiWidths[SIDE_TOP];
        }

        // Button's content box includes padding and borders thus sizeBorderAndPadding should be (0, 0)
        if (    Tag() != ETAG_BUTTON
            &&  (Tag() != ETAG_INPUT || !DYNCAST(CInput, ElementOwner())->IsButton())   )
        {
            const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);

            sizeBorderAndPadding.cx = (bdrH 
                                     + cuvPaddingLeft.XGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingLeft)) 
                                     + cuvPaddingRight.XGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingRight)) );

            // NOTE : for vertical paddings we also provide lParentWidth as a reference (for percentage values), 
            //        this is done intentionally as per css spec.
            sizeBorderAndPadding.cy = (bdrV 
                                     + cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingTop)) 
                                     + cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingBottom)) );
        }

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            fHasWidth  = pFF->UseLogicalUserWidth(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
            fHasHeight = pFF->UseLogicalUserHeight(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
            fWidthClipContent  = (  overflowX != styleOverflowVisible
                                 && overflowX != styleOverflowNotSet);
            fHeightClipContent = (  overflowY != styleOverflowVisible 
                                 && overflowY != styleOverflowNotSet);

            // Get element's default size
            // Buttons don't have default w/h and return a 0 default size.
            // Text INPUTs and TEXTAREAs have both default width and height.
            // Marquees have default height.
            sizeDefault = *psize;
            GetDefaultSize(pci, sizeDefault, &fHasDefaultWidth, &fHasDefaultHeight);

            // use astrology to determine if we need to size to content
            if (    !fHasWidth 
                &&  !fHasDefaultWidth
                &&  (
                            pFF->_bStyleFloat == styleStyleFloatLeft
                        ||  pFF->_bStyleFloat == styleStyleFloatRight
                        ||  !ElementOwner()->IsBlockElement()
                        ||  ElementOwner()->IsAbsolute()
                    )
                &&
                    // If we're in home publisher, we don't want to size to content.
                    (
                            !(Doc()->_fInHomePublisherDoc || g_fInHomePublisher98)
                        ||  !ElementOwner()->IsAbsolute()
                    )
// TODO (lmollico): should go away
                &&  ElementOwner()->_etag != ETAG_FRAME
                )
            {
                _fSizeToContent = TRUE;
            }
            else
            {
                _fSizeToContent = FALSE;
            }

            if (fWidthPercent && !fNormalMode)
            {
                sizeUser.cx      = 0;
                _sizeProposed.cx = 0;
            }
            else
            {
                if (fHasWidth)
                {
                    LONG lParentWidth;
                    if (   fWidthPercent 
                        && ElementOwner()->IsAbsolute() 
                        && fVerticalLayoutFlow)
                    {
                        lParentWidth = pci->_sizeParent.cx;
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcxPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcxPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcxPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the width
                        lParentWidth += lcxPadding;
                    }
                    else if (   fWidthPercent 
                             && fVerticalLayoutFlow)
                    {
                        lParentWidth = 0;

                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                        CTreeNode * pNodeParent = pNode->Parent();
                        while (pNodeParent && !pNodeParent->Element()->IsBlockElement())
                        {
                            pNodeParent = pNodeParent->Parent();
                        }
                        if (pNodeParent)
                        {
                            const CUnitValue & cuvWidthParent = pNodeParent->GetFancyFormat()->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                            if (!cuvWidthParent.IsNullOrEnum() && !cuvWidthParent.IsPercent())
                            {
                                lParentWidth = cuvWidthParent.XGetPixelValue(pci, 0, pNodeParent->GetFontHeightInTwips(&cuvWidthParent));
                            }
                            else if (cuvWidthParent.IsPercent() || pNodeParent->Tag() == ETAG_BODY)
                            {
                                lParentWidth = pci->_sizeParent.cx;
                            }
                        }
                    }
                    else
                    {
                        lParentWidth = pci->_sizeParent.cx;
                    }

                    _sizeProposed.cx = cuvWidth.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvWidth));
                    sizeUser.cx      = _sizeProposed.cx + sizeBorderAndPadding.cx;
                }
                else
                {
                    sizeUser.cx      = sizeDefault.cx;
                    _sizeProposed.cx = sizeDefault.cx;

                    // If this is default width it corresponds to content box -- no adjustment needed 
                    if (!fHasDefaultWidth)
                    {
                        _sizeProposed.cx -= sizeBorderAndPadding.cx;
                        if (_sizeProposed.cx < 0)
                            _sizeProposed.cx = 0;
                    }
                }
            }

            if (fHeightPercent && !fNormalMode)
            {
                sizeUser.cy      = 0;
                _sizeProposed.cy = 0;
            }
            else
            {
                if (fHasHeight)
                {
                    LONG lParentHeight = pci->_sizeParent.cy;
                    if (   fHeightPercent 
                        && ElementOwner()->IsAbsolute() 
                        && !fVerticalLayoutFlow)
                    {
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcyPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcyPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcyPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the height
                        lParentHeight += lcyPadding;
                    }

                    _sizeProposed.cy = cuvHeight.YGetPixelValue(pci, lParentHeight, pNode->GetFontHeightInTwips(&cuvHeight));
                    sizeUser.cy      = _sizeProposed.cy + sizeBorderAndPadding.cy;

                    if (fViewChain)
                    {
                        sizeUser.cy = GetUserHeightForBlock(sizeUser.cy);
                    }
                }
                else
                {
                    sizeUser.cy      = sizeDefault.cy;
                    _sizeProposed.cy = sizeDefault.cy;

                    // If this is default height it corresponds to content box -- no adjustment needed 
                    if (!fHasDefaultHeight)
                    {
                        _sizeProposed.cy -= sizeBorderAndPadding.cy;
                        if (_sizeProposed.cy < 0)
                            _sizeProposed.cy = 0;
                    }
                }
            }

            // The BODY's content never affects its width/height (style specified
            // w/h and/or container size (usually <HTML> and/orframe window) determine
            // BODY size).
            // In general, contents affects w/h if:
            //    1.) w/h isn't style-specified and there's no default w/h.
            // OR 2.) overflowX/Y == visible or not set (meaning f*ClipContent is false).
            // 
            // once we can support vertical center, we can remove the Tag
            //         check for buttons
            fContentAffectWidth =     Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasWidth && !fHasDefaultWidth
                                      ||  !fWidthClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );

            fContentAffectHeight =    Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasHeight && !fHasDefaultHeight
                                      ||  !fHeightClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            _fContentsAffectSize = fContentAffectWidth || fContentAffectHeight;

            // set the (proposed) size to the default/attr-defined size + parentPadding.
// TODO (lmollico): should go away
            if (ElementOwner()->_etag != ETAG_FRAME)
                *psize = sizeUser;

            if (   fNormalMode
                || (   pci->_smMode==SIZEMODE_MMWIDTH 
                    && ( fHeightPercent || fWidthPercent)))
            {
                if (   fContentAffectHeight 
                    && !fHeightPercent )
                {
                    // when dealing with vertical flow we can't assume a height of zero as we size
                    // to the content, this is because we will end up word wrapping as this height
                    // is used as a width.
                    psize->cy = 0;
                }

                //
                // only marquee like element specify a scroll padding
                // which is used for vertical scrolling marquee
                // 
                sizePadding.cx  = max(0L, sizeUser.cx - bdrH);
                sizePadding.cy  = max(0L, sizeUser.cy - bdrV);

                GetScrollPadding(sizePadding);


                if (sizePadding.cx || sizePadding.cy)
                {
                    // make sure the display is fully recalced with the paddings
                    _dp._defPaddingTop      = sizePadding.cy;
                    _dp._defPaddingBottom   = sizePadding.cy;
                    _dp._fDefPaddingSet     = !!sizePadding.cy;

                    // marquee always size to content
                    _fSizeToContent = TRUE;
                }
            }

            if (    !ParentClipContent()
                &&  ElementOwner()->IsAbsolute()
                &&  (!fHasHeight || !fHasWidth)
               )
            {
                CRect rcSize;
                CalcAbsoluteSize(pci, psize, &rcSize);

                if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
                {
                    rcSize.SetWidth(max(rcSize.Width(), sizeUser.cx));
                    rcSize.SetHeight(max(rcSize.Height(), sizeUser.cx));
                }

                //  109440, for FRAME's that are APE, we do not want the height set to 0
                psize->cx = !fHasWidth  ? max(0L, rcSize.Width()) : max(0L, sizeUser.cx);
                psize->cy = !fHasHeight 
                                ? ((Tag() == ETAG_FRAME) ? max(0L, rcSize.Height()) : 0 )
                                : max(0L, sizeUser.cy);
            }

            // in NF, IFrames use the std flowlayout. For back compat the size specified (even if default)
            // needs to be INSIDE the borders, whereas for all others it is outside.  Since the border sizes
            // are removed from the proposedSize in CalcTextSize
            if (Tag() == ETAG_IFRAME)
            {
                CDispNodeInfo   dni;
                GetDispNodeInfo(&dni, pci, TRUE);

                if (dni.GetBorderType() != DISPNODEBORDER_NONE)
                {
                    CRect   rcBorders;

                    dni.GetBorderWidths(&rcBorders);

                    if (!fWidthPercent)
                        psize->cx    += rcBorders.left + rcBorders.right;

                    if (!fHeightPercent)
                        psize->cy    += rcBorders.top  + rcBorders.bottom;
                }
            }

        }
        else if (fMainBody)
        {
            _sizeProposed = pci->_sizeParent;
            _sizeProposed.cx -= sizeBorderAndPadding.cx;
            _sizeProposed.cy -= sizeBorderAndPadding.cy;
            if (_sizeProposed.cx < 0)
                _sizeProposed.cx = 0;
            if (_sizeProposed.cy < 0)
                _sizeProposed.cy = 0;
        }

        sizeProposed = *psize;

        //
        // Calculate the text
        //

        //don't do CalcTextSize in minmax mode if our text size doesn't affect us anyway.
        if(     _fContentsAffectSize || fNormalMode 
            ||  fWidthPercent)  //  preserving backward compat (bug 27982)
        {
            CalcTextSize(pci, psize, psizeDefault);
        }
        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            psize->cy = psize->cx;
        }

        sizeSave = *psize;

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            sizeInset = sizeUser;
            fHasInsets = GetInsets(pci->_smMode, sizeInset, *psize, fHasWidth, fHasHeight, CSize(bdrH, bdrV));
            if (sizeSave.cx != psize->cx)
            {
                grfReturn      |= LAYOUT_HRESIZE;
                fNeedShiftLines = TRUE;
            }

            if (fNormalMode)
            {
                if (sizePadding.cx || sizePadding.cy)
                {
                    SIZE szBdr;

                    szBdr.cx = bdrH;
                    szBdr.cy = bdrV;
                    // We need to call GetScrollPadding, because now we know the text size
                    // we will update scroll parameters

                    SetScrollPadding(sizePadding, *psize, szBdr);

                    fNeedShiftLines = TRUE;
                    *psize = sizeUser;

                    // if the marquee like element is percentage sized or
                    // its size is not specified, its size should be the
                    // default size.
                    // if the default size or the css style size is less 
                    // or equal than 0, marquee like element should not be sized
                    // as such according to IE3 compatibility requirements

                    if ((fHeightPercent || !fHasHeight) && sizeUser.cy <= 0)
                    {
                        psize->cy = _dp.GetHeight() + bdrV; 
                    }
                    else if (sizePadding.cx > 0)
                    {
                        //
                        // if the marquee is horizontal scrolling,
                        // the height should be at least the content high by IE5.
                        //
                        psize->cy = max(psize->cy, _dp.GetHeight() + bdrV);
                    }

                    if (!fHasWidth && sizeUser.cx <= 0)
                    {
                        psize->cx = _dp.GetWidth() + bdrH;
                    }
                }

                else if (fHasWidth && (fWidthClipContent || psize->cx < sizeUser.cx))
                {
                    if (psize->cx != sizeUser.cx)
                    {
                        fNeedShiftLines = TRUE;
                    }
                    psize->cx = max(0L, sizeUser.cx);
                }
                else if (   _fSizeToContent
                        && !((fHasDefaultWidth || fHasWidth || (sizeProposed.cx != psize->cx)) && fWidthClipContent))
                {
                    // when size to content and the width does not 
                    // clip the content, we need to clip on the parent
                    fNeedShiftLines = TRUE;

                    psize->cx = _dp.GetWidth() + bdrH;
                }

                if (fHasHeight)
                {
                    if (fViewChain)
                    {
                        if (psize->cy < sizeUser.cy)
                        {
                            psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                        }
                    }
                    else if (  !pci->_fContentSizeOnly
                            && (   fHeightClipContent 
                                || psize->cy < sizeUser.cy))
                    {
                        psize->cy = max(0L, sizeUser.cy);
                    }
                }
            }
            else
            {
                if (fHasWidth || !_fContentsAffectSize)
                {
                    // cy contains the min width
                    if (pci->_smMode == SIZEMODE_MMWIDTH)
                    {
                        if (fWidthClipContent)
                        {
                            if (!fWidthPercent)
                            {
                                psize->cy = sizeProposed.cx;
                                psize->cx = psize->cy;
                            }
                        }
                        else
                        {
                            if (_fContentsAffectSize)
                            {
                                Assert(fHasWidth);
                                psize->cy = max(psize->cy, sizeProposed.cx);
                                if (!fWidthPercent)
                                    psize->cx = psize->cy;
                                Assert(psize->cx >= psize->cy);
                            }
                            else
                            {
                                if (!fWidthPercent)
                                {
                                    psize->cx = psize->cy = sizeProposed.cx;
                                }
                                else if (   Tag() == ETAG_IFRAME
                                         && pci->_smMode == SIZEMODE_MMWIDTH
                                         && sizeProposed.cx == 0)
                                {
                                    // bug 70270 - don't let minmax return 0 or else we will never display.
                                    psize->cy = 0; 
                                    psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);

                                }
                            }
                        }
                    }
                    else
                    {
                        // Something in TD causes min width to happen
                        if (   !_fContentsAffectSize
                            && fWidthPercent
                            && Tag() == ETAG_IFRAME
                            && sizeProposed.cx == 0
                            && pci->_smMode == SIZEMODE_MINWIDTH
                            )
                        {
                            // bug 70270
                            psize->cy = 0;
                            psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);
                        }
                        else
                        {
                            Assert(pci->_smMode == SIZEMODE_MINWIDTH);
                            *psize = sizeProposed;
                        }
                    }
                }
            }
        }

        //
        // Before we can cache the computed values and request layout tasks
        //  (positioning) we may need to give layoutBehaviors a chance to 
        //  modify the natural (trident-default) sizing of this element.
        //  e.g. a "glow behavior" may want to increase the size of the 
        //  element that it is instantiated on by 10 pixels in all directions,
        //  so that it can draw the fuzzy glow; or an external HTMLbutton
        //  is the size of its content + some decoration size.
        //
        if (   pPH   
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            POINT pt;

            pt.x = sizePadding.cx;
            pt.y = sizePadding.cy;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, 
                             pci, 
                             CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                             &pt, psize);


            if (psize->cx != sizeUser.cx)
            {
                fNeedShiftLines = TRUE;
            }

            if (pt.x != sizePadding.cx)
            {
                sizeInset.cx += max(0L, pt.x - sizePadding.cx);
            }

            if (pt.y != sizePadding.cy)
            {
                sizeInset.cy += max(0L, pt.y - sizePadding.cy); 
            }
        }

        if (    fViewChain 
            &&  !fSpecialLayout
            &&  fHasHeight
            &&  fNormalMode     )
        {
            if (psize->cy < sizeUser.cy)
            {
                psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                pci->_fLayoutOverflow = pci->_fLayoutOverflow || (pci->_cyAvail < sizeUser.cy);
            }

            SetUserHeightForNextBlock(psize->cy, sizeUser.cy);
        }

        //
        // For normal modes, cache values and request layout
        //
        if (fNormalMode)
        {
            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0)
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            if (!fSpecialLayout)
            {
                if (fHasInsets)
                {
                    CSize sizeInsetTemp(sizeInset.cx / 2, sizeInset.cy / 2);
                    _pDispNode->SetInset(sizeInsetTemp);
                }

                if (fNeedShiftLines) // || sizeProposed.cx != psize->cx)
                {
                    CRect rc(CSize(psize->cx - bdrH - sizeInset.cx, _dp.GetHeight()));

                    _fSizeToContent = TRUE;
                    _dp.SetViewSize(rc);
                    _dp.RecalcLineShift(pci, 0);
                    _fSizeToContent = FALSE;
                }
            }

            //
            // If size changes occurred, size the display nodes
            //
            if (   _pDispNode
                && ((grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                    || ( /* update display nodes when RTL overflow changes */
                        IsRTLFlowLayout() 
                        && _pDispNode->GetContentOffsetRTL() != _dp.GetRTLOverflow())
                    || HasMapSizePeer() // always call MapSize, if requested
                    || fNeedToSizeDispNodes
                  )
               ) 

            {
                SizeDispNode(pci, *psize);
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }
            //see call to SetViewSize above - it could change the size of CDisplay
            //without changing the size of layout. We need to resize content dispnode.
            else if(fNeedShiftLines) 
            {
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }

            if (    (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                &&  (psize->cy < _yDescent) )
            {
                //  Layout descent should not exceed layout height (bug # 13413) 
                _yDescent = psize->cy;
            }

            //
            // Mark the site clean
            //
            SetSizeThis( FALSE );
        }

        //
        // For min/max mode, cache the values and note that they are now valid
        //

        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cy, -1);
            _fMinMaxValid = TRUE;
        }

        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }
    }

    //
    // If any absolutely positioned sites need sizing, do so now
    //

    if (    (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        &&  HasRequestQueue())
    {
        long xParentWidth;
        long yParentHeight;

        _dp.GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

        //
        //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
        //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
        //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
        //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
        //  See bugs 69335, 72059, et. al. (greglett)
        //
        CCalcInfo CI(pci);
        CI._grfLayout |= LAYOUT_MEASURE;

        ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
    }

    //
    // Lastly, return the requested size
    //

    switch (pci->_smMode)
    {
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_NATURAL:
    case SIZEMODE_FULLSIZE:
        Assert(!IsSizeThis());

        GetSize((CSize *)psize);

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp = *psize;

            // Get the possibly changed size from the peer
            if (DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
                psize->cy = rectMapped.Height();
            }
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        break;

    case SIZEMODE_MMWIDTH:
        Assert(_fMinMaxValid);
        psize->cx = _sizeMax.cu;
        psize->cy = _sizeMin.cu;
        if (!fRecalcText && psizeDefault)
        {
            GetSize((CSize *)psize);
        }

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp.cx = psize->cy;
            // DelegateMapSize does not like a 0 size, so set the cy to cx
            sizeTemp.cy = sizeTemp.cx;

            // Get the possibly changed size from the peer
            if(DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cy = rectMapped.Width();
                psize->cx = max(psize->cy, psize->cx);
            }
        }

        break;

    case SIZEMODE_MINWIDTH:
        psize->cx = _sizeMin.cu;

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            psize->cy = psize->cx;
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
            }
        }

        psize->cy = 0;

        break;
    }

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
        StopCAP();
#endif

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcTextSize
//
//  Synopsis:   Calculate the size of the contained text
//
//--------------------------------------------------------------------------

void
CFlowLayout::CalcTextSize(
    CCalcInfo * pci, 
    SIZE      * psize, 
    SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcTextSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CDisplay    *pdp = &_dp;
    BOOL        fNormalMode = (   pci->_smMode == SIZEMODE_NATURAL
                               || pci->_smMode == SIZEMODE_NATURALMIN
                               || pci->_smMode == SIZEMODE_SET);
    BOOL        fFullRecalc;
    CRect       rcView;
    long        cxView, cyView;
    long        cxAdjustment = 0;
    long        cyAdjustment = 0;
    long        xViewWidthOld = pdp->GetViewWidth();
    long        yViewHeightOld = pdp->GetViewHeight();
    BOOL        fRTLDisplayOld = pdp->IsRTLDisplay();
    int         cyAvailSafe = pci->_cyAvail;
    BOOL        fViewChain = (   pci->GetLayoutContext() 
                              && pci->GetLayoutContext()->ViewChain() );

    // Hidden layouts should just accumulate changes, and
    // are measured when unhidden.
    Assert(!IsDisplayNone());

    pdp->SetRTLDisplay((GetFirstBranch()->GetCascadedBlockDirection(LC_TO_FC(LayoutContext())) == styleDirRightToLeft));

    //
    // Adjust the incoming size for max/min width requests
    //

    if (pci->_smMode == SIZEMODE_MMWIDTH)
    {
        psize->cx =
        psize->cy = pci->GetDeviceMaxX();
    }
    else if (pci->_smMode == SIZEMODE_MINWIDTH)
    {
        psize->cx = 1;
        psize->cy = pci->GetDeviceMaxX();
    }

    //
    // Construct the "view" rectangle from the available size
    // Also, determine the amount of space to allow for things external to the view
    // (For sites which size to their content, calculate the full amount;
    //  otherwise, simply take that which is left over after determining the
    //  view size. Additionally, ensure their view size is never less than 1
    //  pixel, since recalc will not take place for smaller sizes.)
    //

    if (_fContentsAffectSize)
    {
        long lMinimum = (pci->_smMode == SIZEMODE_MINWIDTH ? 1 : 0);

        rcView.top    = 0;
        rcView.left   = 0;
        rcView.right  = 0x7FFFFFFF;
        rcView.bottom = 0x7FFFFFFF;

        // Adjust the values of the passed-in rect to not include borders and scrollbar space
        SubtractClientRectEdges(&rcView, pci);

        // the "adjustment" values are the amount of space occupied by borders/scrollbars.
        cxAdjustment  = 0x7FFFFFFF - (rcView.right - rcView.left);
        cyAdjustment  = 0x7FFFFFFF - (rcView.bottom - rcView.top);

        rcView.right  = rcView.left + max(lMinimum, psize->cx - cxAdjustment);
        rcView.bottom = rcView.top  + max(lMinimum, psize->cy - cyAdjustment);
    }

    else
    {
        rcView.top    = 0;
        rcView.left   = 0;
        rcView.right  = psize->cx;
        rcView.bottom = psize->cy;

        SubtractClientRectEdges(&rcView, pci);
    }

    cxView = max(0L, rcView.right - rcView.left);
    cyView = max(0L, rcView.bottom - rcView.top);

    if (!_fContentsAffectSize)
    {
        cxAdjustment = psize->cx - cxView;
        cyAdjustment = psize->cy - cyView;
    }

    if (fViewChain)
    {
        //
        // Update available size 
        //
        
        // TODO (112489, olego) : Work should be done to make Trident story 
        // consistent for handling content document elements margins in PageView. 
        // This requires more feedback from PM.
        
        // (olego): cyAdjustment includes both top and bottom borders (and horizontal scroll bar) 
        // which is not what we want to count if the layout is going to break. We need to have more 
        // sofisticated logic here to correct available size. 
        pci->_cyAvail -= cyAdjustment;
    }

    //
    // Determine if a full recalc of the text is necessary
    // NOTE: SetViewSize must always be called first
    //

    pdp->SetViewSize(rcView);

    fFullRecalc =   pdp->GetViewWidth() != xViewWidthOld
                 || (   (  ContainsVertPercentAttr()
                        || _fContainsRelative
                        || pci->_pMarkup->_fHaveDifferingLayoutFlows)
                    &&  pdp->GetViewHeight() != yViewHeightOld  )
                 //  NOTE (olego) : Check for NoContent has been added to avoid text recalc for partial table 
                 //  cells in print view. So the logic is if layout has been calc'ed and layout has no lines 
                 //  ignore zero line count. 
                 || (!pdp->NoContent() && !pdp->LineCount())
                 || ElementOwner()->Tag() == ETAG_FRAME
                 || ElementOwner()->Tag() == ETAG_IFRAME
                 || !fNormalMode
                 || (pci->_grfLayout & LAYOUT_FORCE)
                 //  if print view do full recalc (since ppv doesn't support partial recalc)
                 || (fViewChain && ElementCanBeBroken())
                 || pdp->IsRTLDisplay() != fRTLDisplayOld;

    TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc: %S", (fFullRecalc ? _T("YES") : _T("NO")) ));
    if (fFullRecalc)
    {
        CSaveCalcInfo sci(pci, this);
        BOOL fWordWrap = pdp->GetWordWrap();

        if (!!_fDTRForceLayout)
            pci->_grfLayout |= LAYOUT_FORCE;

        //
        // If the text will be fully recalc'd, cancel any outstanding changes
        //

        CancelChanges();

        if (pci->_smMode != SIZEMODE_MMWIDTH &&
            pci->_smMode != SIZEMODE_MINWIDTH)
        {
            long          xParentWidth;
            long          yParentHeight;
            pdp->GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

            if (    ElementOwner()->HasMarkupPtr() 
                &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                // If renedering in CSS1 strict mode xParentWidth should stay the same 
                // since percent padding should be relative to *real* parent width. 
                xParentWidth = pci->_sizeParent.cx;
            }

            pci->SizeToParent(xParentWidth, yParentHeight);
        }
        
        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            pdp->SetWordWrap(FALSE);
        }

        if (    fNormalMode
            && !(pci->_grfLayout & LAYOUT_FORCE)
            && !ContainsHorzPercentAttr()           // if we contain a horz percent attr, then RecalcLineShift() is insufficient; we need to do a full RecalcView()
            &&  _fMinMaxValid
            &&  pdp->_fMinMaxCalced
            &&  cxView >= pdp->_xMaxWidth
            && !pdp->GetLastLineAligned()           // RecalcLineShift does not handle last line alignment  
            && !_fSizeToContent
            &&  pdp->LineCount()                    // we can only shift lines if we actually have some, else we should do a RecalcView to make sure (bug #67618)
            // pdp->RecalcLineShift could not handle pagination, so if it's print preview use pdp->RecalcView
            && !fViewChain)
        {
            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc via shifting lines"));
            Assert(pdp->_xWidthView  == cxView);
            Assert(!ContainsHorzPercentAttr());
            Assert(!ContainsNonHiddenChildLayout());

            pdp->RecalcLineShift(pci, pci->_grfLayout);
        }
        else
        {
            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc via recalcing lines"));
            _fAutoBelow        = FALSE;
            _fContainsRelative = FALSE;
            pdp->RecalcView(pci, fFullRecalc);
        }

        //
        // Inval since we are doing a full recalc
        //
        Invalidate();

        if (fNormalMode)
        {
            pdp->_fMinMaxCalced = FALSE;
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            pdp->SetWordWrap(fWordWrap);
        }
    }
    //
    // If only a partial recalc is necessary, commit the changes
    //
    else if (!IsCommitted())
    {
        TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Not a full recalc, but dirty, so committing changes.  DTR(%d, %d, %d) ", _dtr._cp, _dtr._cchNew, _dtr._cchOld ));
        Assert(pci->_smMode != SIZEMODE_MMWIDTH);
        Assert(pci->_smMode != SIZEMODE_MINWIDTH);

        CommitChanges(pci);
    }

    //
    //    Propagate CCalcInfo state as appropriate
    //

    if (fNormalMode)
    {
        CLineCore * pli;
        unsigned    i;

        //
        // For normal calculations, determine the baseline of the "first" line
        // (skipping over any aligned sites at the beginning of the text)
        //

        pci->_yBaseLine = 0;
        for (i=0; i < pdp->Count(); i++)
        {
            pli = pdp->Elem(i);
            if (!pli->IsFrame())
            {
                pci->_yBaseLine = pli->_yHeight - pli->oi()->_yDescent;
                break;
            }
        }
    }

    //
    // Determine the size from the calculated text
    //

    if (pci->_smMode != SIZEMODE_SET)
    {
        switch (pci->_smMode)
        {
        case SIZEMODE_FULLSIZE:
        case SIZEMODE_NATURAL:
            if (_fContentsAffectSize || pci->_smMode == SIZEMODE_FULLSIZE)
            {
                pdp->GetSize(psize);
                ((CSize *)psize)->MaxX(((CRect &)rcView).Size());
            }
            else
            {
                psize->cx = cxView;
                psize->cy = cyView;
            }
            break;

        case SIZEMODE_NATURALMIN:
            if (_fContentsAffectSize)
                pdp->GetSize(psize);
            else
                ((CSize*)psize)->SetSize(cxView, cyView);
            if (psizeDefault)
                psizeDefault->cx = psizeDefault->cy = pdp->_xMinWidth;
            break;

        case SIZEMODE_MMWIDTH:
        {
            psize->cx = pdp->GetWidth();
            psize->cy = pdp->_xMinWidth;

            if (psizeDefault)
            {
                psizeDefault->cx = pdp->GetWidth() + cxAdjustment;
                psizeDefault->cy = pdp->GetHeight() + cyAdjustment;
            }

            break;
        }
        case SIZEMODE_MINWIDTH:
        {
            psize->cx = pdp->GetWidth();
            psize->cy = pdp->GetHeight();
            pdp->FlushRecalc();
            break;
        }

#if DBG==1
        default:
            AssertSz(0, "CFlowLayout::CalcTextSize: Unknown SIZEMODE_xxxx");
            break;
#endif
        }

        psize->cx += cxAdjustment;
        psize->cy += (pci->_smMode == SIZEMODE_MMWIDTH
                              ? cxAdjustment
                              : cyAdjustment);
    }

    pci->_cyAvail = cyAvailSafe;

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcTextSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
}


//+----------------------------------------------------------------------------
//
//    Function:    ViewChange
//
//    Synopsis:    Called when the visible view has changed. Notifies the
//                Doc so that proper Ole notifications can be sent
//
//-----------------------------------------------------------------------------

void
CFlowLayout::ViewChange(BOOL fUpdate)
{
    Doc()->OnViewChange(DVASPECT_CONTENT);
#if 0
    if(fUpdate)
        Doc()->UpdateForm();
#endif
}


//+------------------------------------------------------------------------
//
//    Member:     CFlowLayout::ScrollRangeIntoView
//
//    Synopsis:   Scroll an arbitrary range into view
//
//    Arguments:  cpMin:     Starting cp of the range
//                cpMost:  Ending cp of the range
//                spVert:  Where to "pin" the range
//                spHorz:  Where to "pin" the range
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::ScrollRangeIntoView(
    long        cpMin,
    long        cpMost,
    SCROLLPIN    spVert,
    SCROLLPIN    spHorz)
{
extern void BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects);

    HRESULT hr = S_OK;

    if (    _pDispNode
        &&    cpMin >= 0)
    {
        CStackDataAry<RECT, 5>    aryRects(Mt(CFlowLayoutScrollRangeInfoView_aryRects_pv));
        CRect                    rc;
        CCalcInfo                CI(this);

        hr = THR(WaitForParentToRecalc(cpMost, -1, &CI));
        if (hr)
            goto Cleanup;

        _dp.RegionFromElement( ElementOwner(),        // the element
                                 &aryRects,         // rects returned here
                                 NULL,                // offset the rects
                                 NULL,                // ask RFE to get CFormDrawInfo
                                 RFE_SCROLL_INTO_VIEW, // coord w/ respect to the display and not the client rc
                                 cpMin,             // give me the rects from here ..
                                 cpMost,            // ... till here
                                 NULL);             // dont need bounds of the element!

        // Calculate and return the total bounding rect
        BoundingRectForAnArrayOfRectsWithEmptyOnes(&rc, &aryRects);

        // Ensure rect isn't empty
        if (rc.right <= rc.left)
            rc.right = rc.left + 1;
        if (rc.bottom <= rc.top)
            rc.bottom = rc.top + 1;

        if(spVert == SP_TOPLEFT)
        {
            // Though RegionFromElement has already called WaitForRecalc,
            // it calls it until top is recalculated. In order to scroll
            // ptStart to the to of the screen, we need to wait until
            // another screen is recalculated.
            if (!_dp.WaitForRecalc(-1, rc.top + _dp.GetViewHeight()))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        ScrollRectIntoView(rc, spVert, spHorz);
        hr = S_OK;
    }
    else
    {
        hr = super::ScrollRangeIntoView(cpMin, cpMost, spVert, spHorz);
    }


Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
// Member:      CFlowLayout::GetSiteWidth
//
// Synopsis:    returns the width and x proposed position of any given site
//              taking the margins into account.
//
//-----------------------------------------------------------------------------

BOOL
CFlowLayout::GetSiteWidth(CLayout   *pLayout,
                          CCalcInfo *pci,
                          BOOL       fBreakAtWord,
                          LONG       xWidthMax,
                          LONG      *pxWidth,
                          LONG      *pyHeight,
                          INT       *pxMinSiteWidth,
                          LONG      *pyBottomMargin)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));

    CDoc *pDoc = Doc();
    LONG xLeftMargin, xRightMargin;
    LONG yTopMargin, yBottomMargin;
    SIZE sizeObj = g_Zero.size;
   
    Assert (pLayout && pxWidth);

    *pxWidth = 0;

    if (pxMinSiteWidth)
        *pxMinSiteWidth = 0;

    if (pyHeight)
        *pyHeight = 0;

    if (pyBottomMargin)
        *pyBottomMargin = 0;
    
    if(pLayout->IsDisplayNone())
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S) - no work done",
                    this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
        return FALSE;
    }

    // get the margin info for the site
    pLayout->GetMarginInfo(pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    //
    // measure the site
    //
    if (pDoc->_lRecursionLevel == MAX_RECURSION_LEVEL)
    {
        AssertSz(0, "Max recursion level reached!");
        sizeObj.cx = 0;
        sizeObj.cy = 0;
    }
    else
    {
        LONG lRet;

        pDoc->_lRecursionLevel++;
        lRet = MeasureSite(pLayout,
                   pci,
                   xWidthMax - xLeftMargin - xRightMargin,
                   fBreakAtWord,
                   &sizeObj,
                   pxMinSiteWidth);
        pDoc->_lRecursionLevel--;

        if (lRet)
        {
            TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                        this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
            return TRUE;
        }
    }
    
    //
    // Propagate the _fAutoBelow bit, if the child is auto positioned or
    // non-zparent children have auto positioned children
    //
    if (!_fAutoBelow)
    {
        const CFancyFormat * pFF = pLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));

        if (    pFF->IsAutoPositioned()
            ||    (    !pFF->IsZParent()
                &&    (pLayout->_fContainsRelative || pLayout->_fAutoBelow)))
        {
            _fAutoBelow = TRUE;
        }
    }

    // not adjust the size and proposed x pos to include margins
    *pxWidth = max(0L, xLeftMargin + xRightMargin + sizeObj.cx);

    if (pxMinSiteWidth)
    {
        *pxMinSiteWidth += max(0L, xLeftMargin + xRightMargin);
    }

    if (pyHeight)
    {
        *pyHeight = max(0L, sizeObj.cy + yTopMargin + yBottomMargin);
    }

    if (pyBottomMargin)
    {
        *pyBottomMargin = max(0L, yBottomMargin);
    }
    
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Member:      CFlowLayout::MeasureSite()
//
// Synopsis:    Measure width and height of a embedded site
//
//-----------------------------------------------------------------------------
int
CFlowLayout::MeasureSite(CLayout   *pLayout,
                         CCalcInfo *pci,
                         LONG       xWidthMax,
                         BOOL       fBreakAtWord,
                         SIZE      *psizeObj,
                         int       *pxMinWidth)
{
    CSaveCalcInfo sci(pci);
    LONG lRet = 0;

    Assert(pci->_smMode != SIZEMODE_SET);

    if (!pLayout->ElementOwner()->IsInMarkup())
    {
        psizeObj->cx = psizeObj->cy = 0;
        return lRet;
    }

    // if the layout we are measuring (must be a child of ours)
    // is percent sized, then we should take this oppurtunity
    // to set some work-flags 
    {
        // Set flags relative to this layout's coordinate system

        CTreeNode *pNodeChild = pLayout->GetFirstBranch();
        const CFancyFormat *pFFChild  = pNodeChild->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));
        BOOL  fChildWritingModeUsed   = pNodeChild->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->_fWritingModeUsed;
        BOOL  fThisVerticalLayoutFlow = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()))->HasVerticalLayoutFlow();

        if (pFFChild->IsLogicalHeightPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
        {
            SetVertPercentAttrInfo(TRUE);
        }

        if (pFFChild->IsLogicalWidthPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
        {
            SetHorzPercentAttrInfo(TRUE);
        }
    }

    if (    fBreakAtWord 
        && (!pci->_fIgnorePercentChild || !pLayout->PercentHeight())  )
    {
        BOOL fViewChain =  pci->GetLayoutContext() 
                        && pci->GetLayoutContext()->ViewChain();
        long xParentWidth;
        long yParentHeight;

        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            long cxParentWidth = _sizeProposed.cx - pLayout->ComputeMBPWidthHelper(pci, this);

            if (cxParentWidth < 0)
                cxParentWidth = 0;

            pci->SizeToParent(cxParentWidth, _sizeProposed.cy);
        }
        else 
        {
            _dp.GetViewWidthAndHeightForChild(
                    pci,
                    &xParentWidth,
                    &yParentHeight);

            // Set the appropriate parent width
            pci->SizeToParent(xParentWidth, yParentHeight);
        }


        // set available size in sizeObj or if absolutely positioned, 
        // we WANT the parent's width (bug 98849).
        psizeObj->cx = (pLayout->ElementOwner()->IsAbsolute()) 
                             ? pci->_sizeParent.cx
                             : xWidthMax;           // this value has margins removed from parent size
        psizeObj->cy = pci->_sizeParent.cy;

        if (fViewChain)
        {
            //  Update available height for nested layout
            pci->_cyAvail = max(0, pci->_cyAvail - pci->_yConsumed);
            pci->_yConsumed = 0;
        }

        //
        // Force child not to break if this layout could not 
        //

        // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
        // that prohibit layout breaking in Page View. This approach is not suffitient 
        // enouth for editable Page View there we want this property to be calculated 
        // dynamically depending on layout type and layout nesting position (if parent 
        // has it child should inherit). 
        // This work also will enable CSS attribute page-break-inside support.

        if (!ElementCanBeBroken())
        {
            pLayout->SetElementCanBeBroken(FALSE);
        }

        // Ensure the available size does not exceed that of the view
        // (For example, when word-breaking is disabled, the available size
        //    is set exceedingly large. However, percentage sized sites should
        //    still not grow themselves past the view width.)

        if (    pci->_smMode == SIZEMODE_NATURAL 
            &&  pLayout->PercentSize())
        {
            if (pci->_sizeParent.cx < psizeObj->cx)
            {
                psizeObj->cx = pci->_sizeParent.cx;
            }
            if (pci->_sizeParent.cy < psizeObj->cy)
            {
                psizeObj->cy = pci->_sizeParent.cy;
            }
        }

        //
        // If the site is absolutely positioned, only use SIZEMODE_NATURAL
        //
        if (pLayout->ElementOwner()->IsAbsolute(LC_TO_FC(pLayout->LayoutContext())))
        {
            pci->_smMode = SIZEMODE_NATURAL;
        }

        // Mark the site for sizing if it is already marked
        // or it is percentage sized and the view size has changed and
        // the site doesn't already know whether to resize.
        if (!pLayout->ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_NOPCTRESIZE))
        {
            pLayout->SetSizeThis( pLayout->IsSizeThis() || pLayout->PercentSize() );
        }

        pLayout->CalcSize(pci, psizeObj);

        if (pxMinWidth)
        {
            // In MMWIDTH and NATURALMIN modes we need to get minimum object width
            // In MMWIDTH mode cy contains minimum object width
            // In NATURALMIN mode size is real object size, so we get cx as object width
            if (pci->_smMode == SIZEMODE_MMWIDTH)
                *pxMinWidth = psizeObj->cy;
            else if (pci->_smMode == SIZEMODE_NATURALMIN)
            {
                if (pLayout->GetLayoutDesc()->TestFlag(LAYOUTDESC_FLOWLAYOUT))
                {
                    CFlowLayout * pFlowLayout = DYNCAST(CFlowLayout, pLayout);
                    *pxMinWidth = pFlowLayout->_sizeMin.cu;
                }
                else
                {
                    *pxMinWidth = psizeObj->cx;
                }
            }
        }
    }
    else
    {
        pLayout->GetApparentSize(psizeObj);
    }

    return lRet;
}


//+------------------------------------------------------------------------
//
//    Member:     CommitChanges
//
//    Synopsis:    Commit any outstanding text changes to the display
//
//-------------------------------------------------------------------------
DeclareTag(tagLineBreakCheckOnCommit, "Commit", "Disable Line break check on commit");

void
CFlowLayout::CommitChanges(
    CCalcInfo * pci)
{
    long cp;
    long cchOld;
    long cchNew;
    bool fDTRForceLayout;

    //
    //    Ignore unnecessary or recursive requests
    //
    if (!IsDirty() || (IsDisplayNone()))
        goto Cleanup;

    //
    //    Reset dirty state (since changes they are now being handled)
    //    

    cp         = Cp() + GetContentFirstCp();
    cchOld     = CchOld();
    cchNew     = CchNew();
    //(dmitryt)
    //_fDTRForceLayout tells us to recalc layouts in DTR, even if they are not marked dirty
    //This is used to recalc after element insertion - in this case, element by itself can
    //influence how layouts inside its scope are laid out. However, we don't send
    //notification to descendants to mark them all dirty - too costly. 
    //Instead we set this flag and this forces recalc of all layouts (like IMG) inside
    //affected subtree. Note that _fDTRForceLayout is reset by CancelChanges and is, in fact, 
    //part of DTR so we cache it here to use couple of lines below.
    fDTRForceLayout = !!_fDTRForceLayout; 

    CancelChanges();

    WHEN_DBG(Lock());

    //
    //    Recalculate the display to account for the pending changes
    //

    {
        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
        CSaveCalcInfo    sci(pci, this);

        if (fDTRForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
        }

        _dp.UpdateView(pci, cp, cchOld, cchNew);
    }


    //
    //    Fire a "content changed" notification (to our host)
    //

    OnTextChange();

    WHEN_DBG(Unlock());

Cleanup:
    return;
}

//+------------------------------------------------------------------------
//
//    Member:     CancelChanges
//
//    Synopsis:    Cancel any outstanding text changes to the display
//
//-------------------------------------------------------------------------
void
CFlowLayout::CancelChanges()
{
    if (IsDirty())
    {
        _dtr.Reset();
    }
    _fDTRForceLayout = FALSE;
}

//+------------------------------------------------------------------------
//
//    Member:     IsCommitted
//
//    Synopsis:    Verify that all changes are committed
//
//-------------------------------------------------------------------------
BOOL
CFlowLayout::IsCommitted()
{
    return !IsDirty();
}

extern BOOL IntersectRgnRect(HRGN hrgn, RECT *prc, RECT *prcIntersect);

//+---------------------------------------------------------------------------
//
//    Member:     Draw
//
//    Synopsis:    Paint the object.
//
//----------------------------------------------------------------------------

void
CFlowLayout::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    _dp.Render(pDI, pDI->_rc, pDI->_rcClip, pDispNode);
}

inline BOOL
CFlowLayout::GetMultiLine() const
{
    // see if behaviour set default isMultiLine
    CDefaults *pDefaults = ElementOwner()->GetDefaults();
    return pDefaults ? !!pDefaults->GetAAisMultiLine() : TRUE;
}


//+----------------------------------------------------------------------------
//
//    Member:     GetTextNodeRange
//
//    Synopsis:    Return the range of lines that the given text flow node
//                owns
//
//    Arguments:    pDispNode    - text flow disp node.
//                piliStart    - return parameter for the index of the start line
//                piliFinish    - return parameter for the index of the last line
//
//-----------------------------------------------------------------------------
void
CFlowLayout::GetTextNodeRange(CDispNode * pDispNode, long * piliStart, long * piliFinish)
{
    Assert(pDispNode);
    Assert(piliStart);
    Assert(piliFinish);

    *piliStart = 0;
    *piliFinish = _dp.LineCount();

    //
    // First content disp node does not have a cookie
    //
    if (pDispNode != GetFirstContentDispNode())
    {
        *piliStart = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    for (pDispNode = pDispNode->GetNextFlowNode();
         pDispNode;
         pDispNode = pDispNode->GetNextFlowNode())
    {
        if (this == pDispNode->GetDispClient())
        {
            *piliFinish = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
            break;
        }
    }
}


//+----------------------------------------------------------------------------
//
//    Member:     GetPositionInFlow
//
//    Synopsis:    Return the position of a layout derived from its position within
//                the document text flow
//
//    Arguments:    pElement - element to position
//                ppt      - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------
void
CFlowLayout::GetPositionInFlow(
    CElement *    pElement,
    CPoint     *    ppt)
{
    CLinePtr rp(&_dp);
    CTreePos *    ptpStart;

    Assert(pElement);
    Assert(ppt);

    if(pElement->IsRelative() && !pElement->ShouldHaveLayout())
    {
        GetFlowPosition(pElement, ppt);
    }
    else
    {
        BOOL fRTLFlow = IsRTLFlowLayout();
    
        ppt->x = ppt->y = 0;

        // get the tree extent of the element of the layout passed in
        pElement->GetTreeExtent(&ptpStart, NULL);

        if (_dp.RenderedPointFromTp(ptpStart->GetCp(), ptpStart, FALSE, *ppt, &rp, TA_TOP, NULL, &fRTLFlow) < 0)
            return;

        if(pElement->ShouldHaveLayout())
        {
            CLayout *pLayout = pElement->GetUpdatedLayout(LayoutContext());
            
            ppt->y += pLayout->GetYProposed();
            
            // RTL: adjust position for flow direction
            if (fRTLFlow)
            {
                ppt->x -= pLayout->GetApparentWidth() - 1;
            }
        }
        ppt->y += rp->GetYTop(rp->oi());
    }
}


//----------------------------------------------------------------------------
//
//    Member:     CFlowLayout::BranchFromPoint, public
//
//    Synopsis:    Does a hit test against our object, determining where on the
//                object it hit.
//
//    Arguments:    [pt]           -- point to hit test in local coordinates
//                [ppNodeElement]   -- return the node hit
//
//    Returns:    HTC
//
//    Notes:        The node returned is guaranteed to be in the tree
//                so it is legal to look at the parent for this element.
//
//----------------------------------------------------------------------------

HTC
CFlowLayout::BranchFromPoint(
    DWORD            dwFlags,
    POINT            pt,
    CTreeNode     ** ppNodeBranch,
    HITTESTRESULTS* presultsHitTest,
    BOOL            fNoPseudoHit,
    CDispNode      * pDispNode)
{
    HTC         htc = HTC_YES;
    CDisplay  * pdp =  &_dp;
    CLinePtr    rp(pdp);
    CTreePos  * ptp   = NULL;
    LONG        cp, ili, yLine;
    DWORD        dwCFPFlags = 0;
    CRect        rc(pt, pt);
    long        iliStart  = -1;
    long        iliFinish = -1;
    HITTESTRESULTS htrSave = *presultsHitTest;

    dwCFPFlags |= (dwFlags & HT_ALLOWEOL)
                    ? CDisplay::CFP_ALLOWEOL : 0;
    dwCFPFlags |= !(dwFlags & HT_DONTIGNOREBEFOREAFTER)
                    ? CDisplay::CFP_IGNOREBEFOREAFTERSPACE : 0;
    dwCFPFlags |= !(dwFlags & HT_NOEXACTFIT)
                    ? CDisplay::CFP_EXACTFIT : 0;
    dwCFPFlags |= fNoPseudoHit
                    ? CDisplay::CFP_NOPSEUDOHIT : 0;

    Assert(ElementOwner()->IsVisible(FALSE FCCOMMA LC_TO_FC(LayoutContext())) || ElementOwner()->Tag() == ETAG_BODY);

    *ppNodeBranch = NULL;

    //
    // if the current layout has multiple text nodes then compute the
    // range of lines the belong to the current dispNode
    // Note: if dispNode is a container, the whole text range of the layout apply.
    if (pdp->_fHasMultipleTextNodes && pDispNode && !pDispNode->IsContainer())

    {
        GetTextNodeRange(pDispNode, &iliStart, &iliFinish);
    }

    if (pDispNode == GetElementDispNode())
    {
        GetClientRect(&rc); 
        rc.MoveTo(pt);
    }

    ili = pdp->LineFromPos(
                          rc, &yLine, &cp, CDisplay::LFP_ZORDERSEARCH   |
                                           CDisplay::LFP_IGNORERELATIVE |
                                           CDisplay::LFP_IGNOREALIGNED  |
                                            (fNoPseudoHit
                                                ? CDisplay::LFP_EXACTLINEHIT
                                                : 0),
                                            iliStart,
                                            iliFinish);
    if(ili < 0)
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    if ((cp = pdp->CpFromPointEx(ili, yLine, cp, pt, &rp, &ptp, NULL, dwCFPFlags,
                              &presultsHitTest->_fRightOfCp, &presultsHitTest->_fPseudoHit,
                              &presultsHitTest->_cchPreChars,
                              &presultsHitTest->_fGlyphHit,
                              &presultsHitTest->_fBulletHit, NULL)) == -1 ) // fExactFit=TRUE to look at whole characters
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    if (   cp < GetContentFirstCp()
        || cp > GetContentLastCp()
       )
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    presultsHitTest->_cpHit  = cp;
    presultsHitTest->_iliHit = rp;
    presultsHitTest->_ichHit = rp.RpGetIch();

    if (IsEditable() && ptp->IsNode() && ptp->ShowTreePos()
                     && (cp + 1 == ptp->GetBranch()->Element()->GetFirstCp()))
    {
        presultsHitTest->_fWantArrow = TRUE;
        htc = HTC_YES;
        *ppNodeBranch = ptp->GetBranch();
    }
    else
    {
        if (pDispNode)
        {
            pt.y += pDispNode->GetPosition().y;
        }

        htc = BranchFromPointEx(pt, rp, ptp, NULL, ppNodeBranch, presultsHitTest->_fPseudoHit,
                                &presultsHitTest->_fWantArrow,
                                !(dwFlags & HT_DONTIGNOREBEFOREAFTER)
                                );
    }

Cleanup:
    if (htc != HTC_YES)
    {
        *presultsHitTest = htrSave;
        presultsHitTest->_fWantArrow = TRUE;
    }
    return htc;
}

extern BOOL PointInRectAry(POINT pt, CStackDataAry<RECT, 1> &aryRects);

HTC
CFlowLayout::BranchFromPointEx(
    POINT         pt,
    CLinePtr  &  rp,
    CTreePos  *  ptp,
    CTreeNode *  pNodeRelative,  // (IN) non-NULL if we are hit-testing a relative element (NOT its flow position)
    CTreeNode ** ppNodeBranch,     // (OUT) returns branch that we hit
    BOOL         fPseudoHit,     // (IN) if true, text was NOT hit (CpFromPointEx() figures this out)
    BOOL       * pfWantArrow,     // (OUT) 
    BOOL         bIgnoreBeforeAfter
    )
{
    const CCharFormat * pCF;
    CTreeNode * pNode = NULL;
    CElement * pElementStop = NULL;
    HTC         htc   = HTC_YES;
    BOOL        fVisible = TRUE;
    Assert(ptp);

    //
    // If we are on a line which contains an table, and we are not ignoring before and
    // aftrespace, then we want to hit that table...
    //
    if (!bIgnoreBeforeAfter)
    {
        CLineCore * pli = rp.CurLine();
        if (   pli
            && pli->_fSingleSite
            && pli->_cch == rp.RpGetIch()
           )
        {
            rp.RpBeginLine();
            rp.GetPdp()->FormattingNodeForLine(FNFL_NONE, rp.GetPdp()->GetFirstCp() + rp.GetCp(), NULL, pli->_cch, NULL, &ptp, NULL);
        }
    }

    // Get the branch corresponding to the cp hit.
    pNode = ptp->GetBranch();
    
    // If we hit the white space around text, then find the block element
    // that we hit. For example, if we hit in the padding of a block
    // element then it is hit.
    if (bIgnoreBeforeAfter && fPseudoHit)
    {
        CStackDataAry<RECT, 1>    aryRects(Mt(CFlowLayoutBranchFromPointEx_aryRects_pv));
        CMarkup *    pMarkup = GetContentMarkup();
        LONG        cpClipStart;
        LONG        cpClipFinish;
        DWORD        dwFlags = RFE_HITTEST;

        //
        // If a relative node is passed in, the point is already in the
        // co-ordinate system established by the relative element, so
        // pass RFE_IGNORE_RELATIVE to ignore the relative top left when
        // computing the region.
        //
        if (pNodeRelative)
        {
            dwFlags |= RFE_IGNORE_RELATIVE;
            pNode    =  pNodeRelative;
        }

        cpClipStart = cpClipFinish = rp.GetPdp()->GetFirstCp();
        rp.RpBeginLine();
        cpClipStart += rp.GetCp();
        rp.RpEndLine();
        cpClipFinish += rp.GetCp();

        // walk up the tree and find the block element that we hit.
        while (pNode && !SameScope(pNode, ElementContent()))
        {
            if (!pNodeRelative)
                pNode = pMarkup->SearchBranchForBlockElement(pNode, this);

            if (!pNode)
            {
                // this is bad, somehow, a pNodeRelavite was passed in for 
                // an element that is not under this flowlayout. How to interpret
                // this? easiest (and safest) is to just bail
                break;
            }

            _dp.RegionFromElement(pNode->Element(), &aryRects, NULL,
                                    NULL, dwFlags, cpClipStart, cpClipFinish);

            if (PointInRectAry(pt, aryRects))
            {
                break;
            }
            else if (pNodeRelative)
            {
                htc = HTC_NO;
            }

            if (pNodeRelative || SameScope(pNode, ElementContent()))
                break;

            pNode = pNode->Parent();
        }

        *pfWantArrow = TRUE;
    }

    if (!pNode)
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    // pNode now points to the element we hit, but it might be
    // hidden.    If it's hidden, we need to walk up the parent
    // chain until we find an ancestor that isn't hidden,
    // or until we hit the layout owner or a relative element
    // (we want testing to stop on relative elements because
    // they exist in a different z-plane).    Note that
    // BranchFromPointEx may be called for hidden elements that
    // are inside a relative element.

    pElementStop = pNodeRelative
                                ? pNodeRelative->Element()
                                : ElementContent();

    while (DifferentScope(pNode, pElementStop))
    {
        pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        if (pCF->IsDisplayNone() || pCF->IsVisibilityHidden())
        {
            fVisible = FALSE;
            pNode = pNode->Parent();
        }
        else
            break;
    }

    Assert(pNode);

    //
    // if we hit the layout element and it is a pseudo hit or
    // if the element hit is not visible then consider it a miss
    //

    // We want to show an arrow if we didn't hit text (fPseudoHit TRUE) OR
    // if we did hit text, but it wasn't visible (as determined by the loop
    // above which set fVisible FALSE).
    if (fPseudoHit || !fVisible)
    {
        // If we walked all the way up to the container, then we want
        // to return HTC_NO so the display tree will call HitTestContent
        // on the container's dispnode (i.e. "the background"), which will
        // return HTC_YES.

        // If it's relative, then htc was set earlier, so don't
        // touch it now.
        if ( !pNodeRelative )
            htc = SameScope( pNode, ElementContent() ) ? HTC_NO : HTC_YES;

        *pfWantArrow  = TRUE;
    }
    else
    {
        *pfWantArrow  = !!fPseudoHit;
    }

Cleanup:
    *ppNodeBranch = pNode;

    return htc;
}

//+------------------------------------------------------------------------
//
//    Member:     GetFirstLayout
//
//    Synopsis:    Enumeration method to loop thru children (start)
//
//    Arguments:    [pdw]        cookie to be used in further enum
//                [fBack]     go from back
//
//    Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFlowLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack /*=FALSE*/, BOOL fRaw /*=FALSE*/)
{
    Assert(!fRaw);

    if (ElementContent()->GetFirstBranch())
    {
        CChildIterator * pLayoutIterator = new
                CChildIterator(
                    ElementContent(),
                    NULL,
                    CHILDITERATOR_USELAYOUT);
        * pdw = (DWORD_PTR)pLayoutIterator;

        return *pdw == NULL ? NULL : CFlowLayout::GetNextLayout(pdw, fBack, fRaw);
    }
    else
    {
        // If CTxtSite is not in the tree, no need to walk through
        // CChildIterator
        //
        * pdw = 0;
        return NULL;
    }
}


//+------------------------------------------------------------------------
//
//    Member:     GetNextLayout
//
//    Synopsis:    Enumeration method to loop thru children
//
//    Arguments:    [pdw]        cookie to be used in further enum
//                [fBack]     go from back
//
//    Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFlowLayout::GetNextLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    CLayout * pLayout = NULL;

    Assert(!fRaw);

    {
        CChildIterator * pLayoutWalker =
                        (CChildIterator *) (* pdw);
        if (pLayoutWalker)
        {
            CTreeNode * pNode = fBack ? pLayoutWalker->PreviousChild()
                                    : pLayoutWalker->NextChild();
            pLayout = pNode ? pNode->GetUpdatedLayout( LayoutContext() ) : NULL;
        }
    }
    return pLayout;
}



//+---------------------------------------------------------------------------
//
//    Member : ClearLayoutIterator
// 
//----------------------------------------------------------------------------
void
CFlowLayout::ClearLayoutIterator(DWORD_PTR dw, BOOL fRaw)
{
    if (!fRaw)
    {
        CChildIterator * pLayoutWalker = (CChildIterator *) dw;
        if (pLayoutWalker)
            delete pLayoutWalker;
    }
}

//+------------------------------------------------------------------------
//
//    Member:     SetZOrder
//
//    Synopsis:    set z order for site
//
//    Arguments:    [pLayout]    set z order for this layout
//                [zorder]    to set
//                [fUpdate]    update windows and invalidate
//
//    Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFlowLayout::SetZOrder(CLayout * pLayout, LAYOUT_ZORDER zorder, BOOL fUpdate)
{
    HRESULT     hr = S_OK;

    if (fUpdate)
    {
        Doc()->FixZOrder();

        Invalidate();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//    Member:     IsElementBlockInContext
//
//    Synopsis:   Return whether the element is a block in the current context
//                In general: Elements, if marked, are blocks and sites are not.
//                The exception is CFlowLayouts which are blocks when considered
//                from within themselves and are not when considered
//                from within their parent
//
//    Arguments:
//                [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//----------------------------------------------------------------------------

BOOL
CFlowLayout::IsElementBlockInContext ( CElement * pElement )
{
    BOOL fRet = FALSE;
    
    if (pElement == ElementContent())
    {
        fRet = TRUE;
    }
    else if (!pElement->IsBlockElement(LC_TO_FC(LayoutContext())) && !pElement->IsContainer() )
    {
        fRet = FALSE;
    }
    else if (!pElement->ShouldHaveLayout(LC_TO_FC(LayoutContext())))
    {
        fRet = TRUE;
    }
    else
    {
        BOOL fIsContainer = pElement->IsContainer();

        if (!fIsContainer)
        {
            fRet = TRUE;

            //
            // God, I hate this hack ...
            //

            if (pElement->Tag() == ETAG_FIELDSET)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode)
                {
                    const CCharFormat *pCF = pNode->GetCharFormat();
                    if (  pNode->GetCascadeddisplay() != styleDisplayBlock 
                       && !pNode->GetFancyFormat()->GetLogicalWidth(
                                pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).IsNullOrEnum()) // IsWidthAuto
                    {
                        fRet = FALSE;
                    }
                }
            }
        }
        else
        {
            //
            // HACK ALERT!
            //
            // For display purposes, contianer elements in their parent context must
            // indicate themselves as block elements.  We do this only for container
            // elements who have been explicity marked as display block.
            //

            if (fIsContainer)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode && pNode->GetCascadeddisplay(LC_TO_FC(LayoutContext())) == styleDisplayBlock)
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}


//+------------------------------------------------------------------------
//
//    Member:     PreDrag
//
//    Synopsis:    Perform stuff before drag/drop occurs
//
//    Arguments:    ppDO    Data object to return
//                ppDS    Drop source to return
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::PreDrag(
    DWORD            dwKeyState,
    IDataObject **    ppDO,
    IDropSource **    ppDS)
{
    HRESULT hr = S_OK;

    CDoc* pDoc = Doc();

    CSelDragDropSrcInfo *    pDragInfo;

    // Setup some info for drag feedback
    Assert(! pDoc->_pDragDropSrcInfo);
    pDragInfo = new CSelDragDropSrcInfo( pDoc ) ;

    if (!pDragInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDragInfo->Init(ElementContent()) );
    if( hr )
        goto Cleanup;
        
    hr = THR( pDragInfo->GetDataObjectAndDropSource( ppDO, ppDS ) );
    if ( hr )
        goto Cleanup;

    pDoc->_pDragDropSrcInfo = pDragInfo;


Cleanup:

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//    Member:     PostDrag
//
//    Synopsis:    Handle the result of an OLE drag/drop operation
//
//    Arguments:    hrDrop        The hr that DoDragDrop came back with
//                dwEffect    The effect of the drag/drop
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
#ifdef MERGEFUN // Edit team: figure out better way to send sel-change notifs
    CCallMgr                callmgr(GetPed());
#endif
    HRESULT                 hr;
    CDoc*                   pDoc = Doc();
    
    CParentUndo             pu( pDoc );

    hr = hrDrop;

    if( IsEditable() )
        pu.Start( IDS_UNDODRAGDROP );

    if (hr == DRAGDROP_S_CANCEL)
    {
        //
        // TODO (Bug 13568 ashrafm) - we may have to restore selection here.
        // for now I don't think we need to.
        //

        //Invalidate();
        //pSel->Update(FALSE, this);

        hr = S_OK;
        goto Cleanup;
    }

    if (hr != DRAGDROP_S_DROP)
        goto Cleanup;

    hr = S_OK;

    switch(dwEffect)
    {
    case DROPEFFECT_NONE:
    case DROPEFFECT_COPY:
        Invalidate();
        // pSel->Update(FALSE, this);
        break ;

    case DROPEFFECT_LINK:
        break;

    case 7:
        // dropEffect ALL - do the same thing as 3

    case 3: // TODO (Bug 13568 ashrafm) - this is for TriEdit - faking out a position with Drag & Drop.
        {
            Assert(pDoc->_pDragDropSrcInfo);
            if (pDoc->_pDragDropSrcInfo &&  
                pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
            {
                CSelDragDropSrcInfo * pDragInfo;
                pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
                pDragInfo->PostDragSelect();
            }

        }
        break;

    case DROPEFFECT_MOVE:
        if (pDoc->_fSlowClick)
            goto Cleanup;

        Assert(pDoc->_pDragDropSrcInfo);
        if (pDoc->_pDragDropSrcInfo && 
            pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
        {
            CSelDragDropSrcInfo * pDragInfo;
            pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
            pDragInfo->PostDragDelete();
        }
        break;

    default:
        Assert(FALSE && "Unrecognized drop effect");
        break;
    }

Cleanup:

    pu.Finish(hr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//    Member:     Drop
//
//    Synopsis:
//
//----------------------------------------------------------------------------
#define DROPEFFECT_ALL (DROPEFFECT_NONE | DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK)

HRESULT
CFlowLayout::Drop(
    IDataObject *    pDataObj,
    DWORD            grfKeyState,
    POINTL            ptlScreen,
    DWORD *         pdwEffect)
{
    CDoc *    pDoc            = Doc();
    DWORD    dwAllowed        = *pdwEffect;
    TCHAR    pszFileType[4]    = _T("");
    CPoint    pt;
    HRESULT hr                = S_OK;
    

    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo)
    {
        *pdwEffect = DROPEFFECT_NONE ;
        return S_OK;
    }

    AddRef(); // addref ourselves incase we get whacked in the drop.

    //
    // Find out what the effect is and execute it
    // If our operation fails we return DROPEFFECT_NONE
    //
    DragOver(grfKeyState, ptlScreen, pdwEffect);

    IGNORE_HR(DropHelper(ptlScreen, dwAllowed, pdwEffect, pszFileType));


    if (Doc()->_fSlowClick && *pdwEffect == DROPEFFECT_MOVE)
    {
        *pdwEffect = DROPEFFECT_NONE ;
        goto Cleanup;
    }

    //
    // We're all ok at this point. We delegate the handling of the actual
    // drop operation to the DropTarget.
    //


    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;
    ScreenToClient( pDoc->_pInPlace->_hwnd, (POINT*) & pt );

    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    hr = THR( _pDropTargetSelInfo->Drop( this, pDataObj, grfKeyState, pt, pdwEffect ));


Cleanup:
    // Erase any feedback that's showing.
    DragHide();
    
    Assert(_pDropTargetSelInfo);
    delete _pDropTargetSelInfo;
    _pDropTargetSelInfo = NULL;

    Release();
    
    RRETURN1(hr,S_FALSE);

}


//+---------------------------------------------------------------------------
//
//  Member:     DragLeave
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::DragLeave()
{
#ifdef MERGEFUN // Edit team: figure out better way to send sel-change notifs
    CCallMgr        callmgr(GetPed());
#endif
    HRESULT         hr        = S_OK;

    if (!_pDropTargetSelInfo)
        goto Cleanup;

    hr = THR(super::DragLeave());

Cleanup:
    if (_pDropTargetSelInfo)
    {
        delete _pDropTargetSelInfo;
        _pDropTargetSelInfo = NULL;
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ParseDragData
//
//  Synopsis:   Drag/drop helper override
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::ParseDragData(IDataObject *pDO)
{
    DWORD   dwFlags = 0;
    HRESULT hr;
    CTreeNode* pNode = NULL;
    ISegmentList    *pSegmentList = NULL;

    // Start with flags set to default values.

    Doc()->_fOKEmbed = FALSE;
    Doc()->_fOKLink = FALSE;
    Doc()->_fFromCtrlPalette = FALSE;

    if (!IsEditable() || !ElementOwner()->IsEnabled())
    {
        // no need to do anything else, bcos we're read only.
        hr = S_FALSE;
        goto Cleanup;
    }

    pNode = ElementOwner()->GetFirstBranch();
    if ( ! pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Bug 101921: Check for frozen attribute.  Can't drop on a 'frozen' element.
    // Bug 104772: Should not allow drops on any frozen element.
    if (ElementOwner()->IsParentFrozen()
        || ElementOwner()->IsFrozen())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //	Bug 23063: In Whistler, shell data sources support CF_TEXT, so we need to 
    //	first check for CFSTR_SHELLIDLIST to see if the data source comes from the
    //	shell.  We don't want to handle file drops.
    if (pDO->QueryGetData(&g_rgFETC[iShellIdList]) == NOERROR)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Allow only plain text to be pasted in input text controls
    // Bug 82119: Don't allow dropping a button on another button.
    if (!pNode->SupportsHtml() || pNode->_etag == ETAG_BUTTON)
    {
        BOOL                    fSiteSelected = FALSE;
        SELECTION_TYPE          eType;
      
        hr = THR ( pDO->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
        if ( !hr && pSegmentList )
        {
            IFC( pSegmentList->GetType( &eType ));

            if ( eType == SELECTION_TYPE_Control )
            {
                fSiteSelected = TRUE;
            }
        }
        
        if (fSiteSelected || pDO->QueryGetData(&g_rgFETC[iAnsiFETC]) != NOERROR)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    {
        hr = THR(CTextXBag::GetDataObjectInfo(pDO, &dwFlags));
        if (hr)
            goto Cleanup;
    }

    if (dwFlags & DOI_CANPASTEPLAIN)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(super::ParseDragData(pDO));
    }

Cleanup:
    ReleaseInterface( pSegmentList );
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     DrawDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CFlowLayout::DrawDragFeedback(BOOL fCaretVisible)
{
    Assert(_pDropTargetSelInfo);

    _pDropTargetSelInfo->DrawDragFeedback(fCaretVisible);
}

//+------------------------------------------------------------------------
//
//  Member:     InitDragInfo
//
//  Synopsis:   Setup a struct to enable drawing of the drag feedback
//
//  Arguments:  pDO         The data object
//              ptlScreen   Screen loc of obj.
//
//  Notes:      This assumes that the DO has been parsed and
//              any appropriate data on the form has been set.
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::InitDragInfo(IDataObject *pDO, POINTL ptlScreen)
{

    CPoint      pt;
    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;

    ScreenToClient( Doc()->_pInPlace->_hwnd, (CPoint*) & pt );


    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    Assert(!_pDropTargetSelInfo);
    _pDropTargetSelInfo = new CDropTargetInfo( this, Doc(), pt );
    if (!_pDropTargetSelInfo)
        RRETURN(E_OUTOFMEMORY);


    return S_OK;

}

//+====================================================================================
//
// Method: DragOver
//
// Synopsis: Delegate to Layout::DragOver - unless we don't have a _pDropTargetSelInfo
//
//------------------------------------------------------------------------------------

HRESULT 
CFlowLayout::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo || (!g_fInAccess9 && _pDropTargetSelInfo->IsAtInitialHitPoint(pt)))
    {
        //  Bug 100514: We want to update the caret position to follow the drag only
        //  if the caret is hidden.  The caret could be hidden if we are dragging over
        //  an invalid drop point.

        if (!_pDropTargetSelInfo)
        {
            CDoc        *pDoc = Doc();
            
            if (!pDoc->IsCaretVisible())
            {
                //  Ok, caret is hidden.  We want to update its position.
                IGNORE_HR( pDoc->UpdateCaretPosition(this, pt) );
            }
        }

        *pdwEffect = DROPEFFECT_NONE ;
        return S_OK;
    }
    
    return super::DragOver( grfKeyState, pt, pdwEffect );
}

//+---------------------------------------------------------------------------
//
//  Member:     UpdateDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::UpdateDragFeedback(POINTL ptlScreen)
{
    CSelDragDropSrcInfo *pDragInfo = NULL;
    CDoc* pDoc = Doc();
    CPoint      pt;

    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo)
        return S_OK;

    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;

    ScreenToClient( pDoc->_pInPlace->_hwnd, (POINT*) & pt );

    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    if ( ( pDoc->_fIsDragDropSrc )  &&
         ( pDoc->_pDragDropSrcInfo) &&
         ( pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION ) )
    {
        pDragInfo = DYNCAST( CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo );
    }
    _pDropTargetSelInfo->UpdateDragFeedback( this, pt, pDragInfo  );

    TraceTag((tagUpdateDragFeedback, "Update Drag Feedback: pt:%ld,%ld After Transform:%ld,%ld\n", ptlScreen.x, ptlScreen.y, pt.x, pt.y ));

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     WaitForParentToRecalc
//
//  Synopsis:   Waits for a this site to finish recalcing upto cpMax/yMax.
//              If first waits for all txtsites above this to finish recalcing.
//
//  Params:     [cpMax]: The cp to calculate too
//              [yMax]:  The y position to calculate too
//              [pci]:   The CCalcInfo
//
//  Return:     HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::WaitForParentToRecalc(
    LONG cpMax,     //@parm Position recalc up to (-1 to ignore)
    LONG yMax,      //@parm ypos to recalc up to (-1 to ignore)
    CCalcInfo * pci)
{
    HRESULT hr = S_OK;

    Assert(!TestLock(CElement::ELEMENTLOCK_RECALC));

    if (!TestLock(CElement::ELEMENTLOCK_SIZING))
    {
#ifdef DEBUG
        // NOTE(sujalp): We should never recurse when we are not SIZING.
        // This code to catch the case in which we recurse when we are not
        // SIZING.
        CElement::CLock LockRecalc(ElementOwner(), CElement::ELEMENTLOCK_RECALC);
#endif
        ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);
    }

    // ENSURERECALC notification could have caused us to recalc the line array,
    // thus changing the valid cp range.  Make sure we pass a valid cpMax to WFR().
    cpMax = min(cpMax, GetContentLastCp());

    if (!_dp.WaitForRecalc(cpMax, yMax, pci))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayout
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pElementChild] -  The child element from where this call came
//              [pcp]        -  The cp in the found site where the caret
//                              should be placed.
//              [pfCaretNotAtBOL] - Is the caret at BOL?
//              [pfAtLogicalBOL] - Is the caret at the logical BOL?
//
//-----------------------------------------------------------------------------
CFlowLayout *
CFlowLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                               BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout = NULL;   // Stores the new txtsite found in the given dirn.

    Assert(pcp);
    Assert(!pElementLayout || pElementLayout->GetUpdatedParentLayout() == this);

    if (pElementLayout == NULL)
    {
        CLayout *pParentLayout = GetUpdatedParentLayout();
        // By default ask our parent to get the next flowlayout.
        if (pParentLayout && pParentLayout->IsEditable())
        {
            pFlowLayout = pParentLayout->GetNextFlowLayout(iDir, ptPosition, ElementOwner(), pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
    }
    else
    {
        CTreePos *       ptpStart;  // extent of the element
        CTreePos *       ptpFinish;

        // Start off with the txtsite found as being this one
        pFlowLayout = this;
        *pcp = 0;

        // find the extent of the element passed in.
        pElementLayout->GetTreeExtent(&ptpStart, &ptpFinish);

        switch(iDir)
        {
        case NAVIGATE_UP:
        case NAVIGATE_DOWN:
            {
                CLinePtr rp(GetDisplay()); // The line in this site where the child lives
                POINT    pt;       // The point where the site resides.
                CElement  * pElement;
                BOOL     fVertical;

                pElement = ElementOwner();
                Assert( pElement );
                fVertical = pElement->HasVerticalLayoutFlow();

                // find the line where the given layout lives.
                if (_dp.RenderedPointFromTp(ptpStart->GetCp(), ptpStart, FALSE, pt, &rp, TA_TOP, NULL, NULL) < 0)
                    goto Cleanup;

                // Now navigate from this line ... either up/down
                pFlowLayout = _dp.MoveLineUpOrDown(iDir, fVertical, rp, ptPosition, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
                break;
            }
        case NAVIGATE_LEFT:
            // position ptpStart just before the child layout
            ptpStart = ptpStart->PreviousTreePos();

            if(ptpStart)
            {
                // Now let's get the txt site that's interesting to us
                pFlowLayout = ptpStart->GetBranch()->GetFlowLayout();

                // and the cp...
                *pcp = ptpStart->GetCp();
            }
            break;

        case NAVIGATE_RIGHT:
            // Position the ptpFinish just after the child layout.
            ptpFinish = ptpFinish->PreviousTreePos();

            if(ptpFinish)
            {
                // Now let's get the txt site that's interesting to us
                pFlowLayout = ptpFinish->GetBranch()->GetFlowLayout();

                // and the cp...
                *pcp = ptpFinish->GetCp();
                break;
            }
        }
    }

Cleanup:
    return pFlowLayout;
}

//+--------------------------------------------------------------------------
//
//  Member : GetChildElementTopLeft
//
//  Synopsis : CSite virtual override, the job of this function is to
//      do the actual work in reporting the top left posisiton of elements
//      that is it resposible for.
//              This is primarily used as a helper function for CElement's::
//      GetElementTopLeft.
//
//----------------------------------------------------------------------------
HRESULT
CFlowLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    Assert(pChild && !pChild->ShouldHaveLayout());

    // handle a couple special cases. we won't hit
    // these when coming in from the OM, but if this fx is
    // used internally, we might. so here they are
    switch ( pChild->Tag())
    {
    case ETAG_MAP :
        {
            pt.x = pt.y = 0;
        }
        break;

    case ETAG_AREA :
        {
            RECT rectBound;
            DYNCAST(CAreaElement, pChild)->GetBoundingRect(&rectBound);
            pt.x = rectBound.left;
            pt.y = rectBound.top;
        }
        break;

    default:
        {
            CTreePos  * ptpStart;
            CTreePos  * ptpEnd;
            LONG        cpStart;
            LONG        cpStop;
            CElement  * pElement = ElementOwner();
            ELEMENT_TAG etag = pElement->Tag();
            BOOL        fVertical = pElement->HasVerticalLayoutFlow();
            
            pt.x = pt.y = -1;

            // get the extent of this element
            pChild->GetTreeExtent(&ptpStart, &ptpEnd);

            if (!ptpStart || !ptpEnd)
                goto Cleanup;

            cpStart = ptpStart->GetCp();
            cpStop = ptpEnd->GetCp();

            {
                CStackDataAry<RECT, 1> aryRects(Mt(CFlowLayoutGetChildElementTopLeft_aryRects_pv));

                _dp.RegionFromElement(pChild, &aryRects, NULL, NULL,
                                      RFE_ELEMENT_RECT | RFE_INCLUDE_BORDERS | RFE_NO_EXTENT,
                                      cpStart, cpStop);

                if(aryRects.Size())
                {
                    if (!fVertical)
                    {
                        pt.x = aryRects[0].left;
                        pt.y = aryRects[0].top;
                    }
                    else
                    {
                        LONG iLast = aryRects.Size() - 1;
                        pt.y = aryRects[iLast].left;
                        pt.x = _dp.GetHeight() - aryRects[iLast].bottom;
                    }
                }
            }

            // if we are for a table cell, then we need to adjust for the cell insets,
            // in case the content is vertically aligned.
            if ( (etag == ETAG_TD) || (etag == ETAG_TH) || (etag == ETAG_CAPTION) )
            {
                CDispNode * pDispNode = GetElementDispNode();
                if (pDispNode && pDispNode->HasInset())
                {
                    CSize sizeInset = pDispNode->GetInset();
                    if (fVertical)
                    {
                        sizeInset.Flip();
                    }
                    pt.x += sizeInset.cx;
                    pt.y += sizeInset.cy;
                }
            }

        }
        break;
    }

Cleanup:
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetPositionInFlowLayout
//
//  Synopsis:   For this flowlayout, find the correct position for the cp to be in
//              within this flowlayout. It may so happen that the ideal position
//              may be within a flowlayout within this one -- handle those cases too.
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pcp]        -  The cp in the found site where the caret
//                              should be placed.
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//-----------------------------------------------------------------------------
CFlowLayout *
CFlowLayout::GetPositionInFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, LONG *pcp,
                                     BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout  *pFlowLayout = this; // The txtsite we found ... by default us

    Assert(pcp);

    switch(iDir)
    {
    case NAVIGATE_UP:
    case NAVIGATE_DOWN:
    {
        CPoint   ptGlobal(ptPosition);  // The desired position of the caret
        CPoint   ptContent;
        CLinePtr rp(GetDisplay());         // The line in which the point ptPosition is
        CRect    rcClient;         // Rect used to get the client rect

        // Be sure that the point is within this site's client rect
        RestrictPointToClientRect(&ptGlobal);
        ptContent = ptGlobal;
        TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

        // Construct a point within this site's client rect (based on
        // the direction we are traversing.
        GetClientRect(&rcClient);
        rcClient.MoveTo(ptContent);

        // Find the line within this txt site where we want to be placed.
        rp = _dp.LineFromPos(rcClient,
                             (CDisplay::LFP_ZORDERSEARCH   |
                              CDisplay::LFP_IGNOREALIGNED  |
                              CDisplay::LFP_IGNORERELATIVE |
                              (iDir == NAVIGATE_UP
                                ? CDisplay::LFP_INTERSECTBOTTOM
                                : 0)));

        if (rp < 0)
        {
            *pcp = 0;
        }
        else
        {
            // Found the line ... let's navigate to it.
            pFlowLayout = _dp.NavigateToLine(iDir, rp, ptGlobal, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
        break;
    }

    case NAVIGATE_LEFT:
    {
        // We have come to this site while going left in a site outside this site.
        // So position ourselves just after the last valid character.
        *pcp = GetContentLastCp() - 1;
#ifdef DEBUG
        {
            CRchTxtPtr rtp(GetPed());
            rtp.SetCp(*pcp);
            Assert(WCH_TXTSITEEND == rtp._rpTX.GetChar());
        }
#endif
        break;
    }

    case NAVIGATE_RIGHT:
        // We have come to this site while going right in a site outside this site.
        // So position ourselves just before the first character.
        *pcp = GetContentFirstCp();
#ifdef DEBUG
        {
            CRchTxtPtr rtp(GetPed());
            rtp.SetCp(*pcp);
            Assert(IsTxtSiteBreak(rtp._rpTX.GetPrevChar()));
        }
#endif
        break;
    }

    return pFlowLayout;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleSetCursor
//
//  Synopsis:   Helper for handling set cursor
//
//  Arguments:  [pMessage]  -- message
//              [fIsOverEmptyRegion -- is it over the empty region around text?
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::HandleSetCursor(CMessage * pMessage, BOOL fIsOverEmptyRegion)
{
    HRESULT     hr              = S_OK;
    LPCTSTR     idcNew          = IDC_ARROW;
    RECT        rc;
    POINT       pt              = pMessage->pt;
    CElement*   pElement        = pMessage->pNodeHit->Element();
    BOOL        fMasterEditable =  pElement->IsMasterParentEditable();
    BOOL        fEditable       = IsEditable() || fMasterEditable ;
    BOOL        fUseSlaveCursor = FALSE;
    CElement*   pSiteSelectThis = NULL;
    
    CDoc* pDoc = Doc();
    BOOL fParentEditable = FALSE;
    
    Assert(pElement);
    //Assert( ! pDoc->_fDisableReaderMode );

    if (pDoc->_fDisableReaderMode)
    {
        return S_OK;
    }
    
    if ( CHECK_EDIT_BIT( pElement->GetMarkup(), _fOverrideCursor ))
    {
        return S_OK; // we don't touch the cursor - up to the host.        
    }

    // If the cursor is over slave content AND the master's cursor is not inherited,
    // then use the default cursor.
    if (    pElement != ElementOwner()
        &&  ElementOwner()->HasSlavePtr()
       )
    {
        CDefaults * pDefaults = ElementOwner()->GetDefaults();
        
        if(   pMessage->pNodeHit->IsConnectedToThisMarkup(ElementOwner()->GetSlavePtr()->GetMarkup())
           && pDefaults 
           && !pDefaults->GetAAviewInheritStyle()
          )
        {
            fUseSlaveCursor = TRUE;
        }
    }

    // TODO (MohanB) A hack to fix IE5 #60103; should be cleaned up in IE6.
    // MUSTFIX: We should set the default cursor (I-Beam for text, Arrow for the rest) only
    // after the message bubbles through all elements upto the root. This allows elements
    // (like anchor) which like to set non-default cursors over their content to do so.

    if (    !fEditable
        &&  !fUseSlaveCursor
        &&  ElementOwner()->TagType() == ETAG_GENERIC
       )
    {
        return S_FALSE;
    }


    fParentEditable = pElement->IsParentEditable(); 
    
    BOOL fOverEditableElement = ( fEditable &&
                                  pElement->_etag != ETAG_ROOT && 
                                  ( fParentEditable || fMasterEditable ) && 
                                  ( pDoc->_pElemCurrent && pDoc->_pElemCurrent->_etag != ETAG_ROOT ) && 
                                  ( pDoc->IsElementSiteSelectable( pElement ) ||
                                       ( pElement->IsTablePart( ) &&   // this is for mouse over borders of site-selected table-cells
                                         pDoc->IsPointInSelection( pt , pElement->GetFirstBranch() ) && 
                                         pDoc->GetSelectionType() == SELECTION_TYPE_Control )));

    if ( ! fOverEditableElement )
        GetClientRect(&rc);

    Assert(pMessage->IsContentPointValid());
    if ( fOverEditableElement || PtInRect(&rc, pMessage->ptContent) )
    {
        if (fIsOverEmptyRegion && ! fOverEditableElement )
        {
            idcNew = IDC_ARROW;
        }
        else
        {
            if (pMessage->htc == HTC_BEHAVIOR)
            {
                if ( pMessage->lBehaviorCookie )
                {                    
                    CPeerHolder *pPH = pElement->FindPeerHolder(pMessage->lBehaviorCookie);

                    if (pPH)
                    {
                        hr = pPH->SetCursor(pMessage->lBehaviorPartID);
                        goto Cleanup; // cursor is set. so we bail
                    }                        
                }
                else
                {
                    idcNew = IDC_ARROW;
                }    
            }
            else if ( fEditable  &&
                 ( pMessage->htc >= HTC_TOPBORDER || pMessage->htc == HTC_EDGE ) )
            {
                idcNew = pDoc->GetCursorForHTC( pMessage->htc );
            }        
            else if (! pDoc->IsPointInSelection( pt, pElement->GetFirstBranch()  ) )
            {
                // If CDoc is a HTML dialog, do not show IBeam cursor.

                if ( fEditable
                    || !( pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
                    ||   _fAllowSelectionInDialog
                    )
                {
                    //
                    // Adjust for Slave to make currency checkwork
                    //
                    if (pElement->HasMasterPtr())
                    {
                        pElement = pElement->GetMasterPtr();
                        if (pElement->GetUpdatedParentLayoutNode())
                        {
                            fParentEditable = pElement->GetUpdatedParentLayoutNode()->IsEditable();
                        }
                    }

                    // 
                    if (  (fParentEditable || fMasterEditable ) && 
                          pDoc->IsElementSiteSelectable( pElement , & pSiteSelectThis ) &&
                          (pSiteSelectThis->IsParentEditable() || fMasterEditable) &&
                          ( pElement->GetMarkup() != pDoc->_pElemCurrent->GetMarkup() || 
                            pElement != pDoc->_pElemCurrent          // retain the old cursor as long as currency not changed
                          )
                       )                       
                    {
                        idcNew = IDC_SIZEALL;
                    } 
                    else
                        idcNew = IDC_IBEAM;                
                }                    
            }  
            else if ( pDoc->GetSelectionType() == SELECTION_TYPE_Control )
            {
                //
                // We are in a selection. But the Adorners didn't set the HTC_CODE.
                // Set the caret to the size all - to indicate they can click down and drag.
                //
                // This is a little ambiguous - they can click in and UI activate to type
                // but they can also start a move we decided on the below.
                //
                idcNew = IDC_SIZEALL;  
            }
        }
    }
    
    
#ifdef NEVER    // GetSelectionBarWidth returns 0
    else if (GetSelectionBarWidth() && PointInSelectionBar(pt))
    {
        // The selection bar is a vertical trench on the left side of the text
        // object that allows one to select multiple lines by swiping the trench
        idcNew = MAKEINTRESOURCE(IDC_SELBAR);
    }
#endif

    if (fUseSlaveCursor)
    {
        SetCursorIDC(idcNew);
        hr = S_OK;
    }
    else
    {
        ElementOwner()->SetCursorStyle(idcNew);
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}



void
CFlowLayout::ResetMinMax()
{
    _fMinMaxValid      = FALSE;
    _dp._fMinMaxCalced = FALSE;
    MarkHasAlignedLayouts(FALSE);
}


LONG
CFlowLayout::GetMaxLineWidth()
{
    CDisplay *pdp = GetDisplay();
    return pdp->GetViewWidth() - pdp->GetCaret();
}

//+----------------------------------------------------------------------------
//
// member: ReaderModeScroll
//
//-----------------------------------------------------------------------------
void
ReaderModeScroll(CLayout * pScrollLayout, int dx, int dy)
{
    CRect   rc;
    long    cxWidth;
    long    cyHeight;

    // this is a callback from commctl32 so it is possible that the layout
    // is hanging off a passivated element and there is no dispnode (e.g.
    // navigation has happened)
    // (greglett) If this is so, since layouts aren't refcounted, could pScrollLayout be bad?
    if (   !pScrollLayout->GetElementDispNode()
        || !pScrollLayout->GetElementDispNode()->IsScroller())
        return;

    pScrollLayout->GetElementDispNode()->GetClientRect(&rc, CLIENTRECT_CONTENT);

    cxWidth  = rc.Width();
    cyHeight = rc.Height();

    //
    // Sleep() call is required for keeping another world alive.
    // See ..shell\comctl32\.. reader.c for DoReadMode message pumping loop
    // and raid bug 19537 IEv60 (mikhaill 12/17/00).
    //

    int sleepTime = 10;

    //
    //  Scroll slowly if moving in a single dimension
    //

    if (    !dx
        ||  !dy)
    {
        if (abs(dx) == 1 || abs(dy) == 1)
        {
            sleepTime = 100;
        }
        else if (abs(dx) == 2 || abs(dy) == 2)
        {
            sleepTime = 50;
        }
    }

    Sleep(sleepTime);

    //
    //  Calculate the scroll delta
    //  (Use a larger amount if the incoming delta is large)
    //

    if (abs(dx) > 10)
    {
        dx = (dx > 0
                ? cxWidth / 2
                : -1 * (cxWidth / 2));
    }
    else if (abs(dx) > 8)
    {
        dx = (dx > 0
                ? cxWidth / 4
                : -1 * (cxWidth / 4));
    }
    else
    {
        dx = dx * 2;
    }

    if (abs(dy) > 10)
    {
        dy = (dy > 0
                ? cyHeight / 2
                : -1 * (cyHeight / 2));
    }
    else if (abs(dy) > 8)
    {
        dy = (dy > 0
                ? cyHeight / 4
                : -1 * (cyHeight / 4));
    }
    else
    {
        dy = dy * 2;
    }

    //
    //  Scroll the content
    //

    pScrollLayout->ScrollBy(CSize(dx, dy));

    CDoc *  pDoc = pScrollLayout->Doc();

    if(pDoc && pDoc ->InPlace() && pDoc ->InPlace()->_hwnd)
        ::UpdateWindow(pDoc->InPlace()->_hwnd);
}

//+----------------------------------------------------------------------------
//
// _ReaderMode_OriginWndProc
// _ReaderMode_Scroll
// _ReaderMode_TranslateDispatch
//
// Reader Mode Auto-Scroll helper routines, paste from classic MSHTML code
// These are callback functions for DoReaderMode.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
_ReaderMode_OriginWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc, hdcCompat;
    HBITMAP     hbmp = NULL;
    PAINTSTRUCT ps;

    switch (msg)
    {
    case WM_PAINT:
    case WM_ERASEBKGND:
        hdc = BeginPaint(hwnd, &ps);

        if ((hbmp = (HBITMAP)GetWindowLongPtr(hwnd, 0)) != NULL &&
                (hdcCompat = CreateCompatibleDC(hdc)) != NULL)
        {
            BITMAP   bmp;
            HBITMAP  hbmpOld;
            HBRUSH   hbrushOld;
            HPEN     hpenOld, hpen;
            COLORREF crColor;

            GetObject(hbmp, sizeof(BITMAP), &bmp);
            crColor   = RGB(0, 0, 0);
            hpen      = CreatePen(PS_SOLID, 2, crColor);
            if (hpen)
            {
                hpenOld   = (HPEN) SelectObject(hdc, hpen);
                hbmpOld   = (HBITMAP) SelectObject(hdcCompat, hbmp);
                hbrushOld = (HBRUSH) SelectObject(hdc, GetStockObject(NULL_BRUSH));

                BitBlt(hdc, 0, 0, bmp.bmWidth, bmp.bmHeight, hdcCompat, 0, 0, SRCCOPY);
                Ellipse(hdc, 0, 0, bmp.bmWidth + 1, bmp.bmHeight + 1);

                SelectObject(hdcCompat, hbmpOld);
                SelectObject(hdc, hbrushOld);
                SelectObject(hdc, hpenOld);
                DeleteObject(hpen);
            }
            DeleteObject(hdcCompat);
        }
        EndPaint(hwnd, &ps);
        break;

    default:
        return (DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }


    return 0;
}

#ifndef WIN16

// (dmitryt) Because of check for LayoutPtr, not LayoutAry, this scrolling 
// mechanism will not work in layout rects (print preview).
// We don't know at the moment how to correctly scroll things with several layouts anyway.

BOOL CALLBACK
_ReaderMode_Scroll(PREADERMODEINFO prmi, int dx, int dy)
{
    CElement *pElement = (CElement *) prmi->lParam;

    if(    !pElement 
        || !pElement->HasLayoutPtr() 
        || !pElement->IsInMarkup()
        || !pElement->IsScrollingParent()
      )
        return FALSE;

    ReaderModeScroll(pElement->GetLayoutPtr(), dx, dy);
    return TRUE;
}

BOOL CALLBACK
_ReaderMode_TranslateDispatch(LPMSG lpmsg)
{
    BOOL   fResult = FALSE;
    LPRECT lprc;

    if (lpmsg->message == WM_MBUTTONUP)
    {
        // If the button up click comes within the "neutral zone" rectangle
        // around the point where the button went down then we want
        // continue reader mode so swallow the message by returning
        // TRUE.  Otherwise, let the message go through so that we cancel
        // out of panning mode.
        //
        if ((lprc = (LPRECT)GetProp(lpmsg->hwnd, TEXT("ReaderMode"))) != NULL)
        {
            POINT ptMouse = {LOWORD(lpmsg->lParam), HIWORD(lpmsg->lParam)};
            if (PtInRect(lprc, ptMouse))
            {
                fResult = TRUE;
            }
        }
    }
    return fResult;
}
#endif //ndef WIN16


//+----------------------------------------------------------------------------
//
// member: ExecReaderMode
//
// Execure ReaderMode auto scroll. Use DoReaderMode in COMCTL32.DLL
//
//-----------------------------------------------------------------------------
void
ExecReaderMode(CElement *pScrollElement, CMessage * pMessage, BOOL fByMouse)
{
#ifndef WIN16
    POINT       pt;
    RECT        rc;
    HWND        hwndInPlace = NULL;
    HBITMAP     hbmp = NULL;
    BITMAP      bmp;
    HINSTANCE   hinst;

    if(    !pScrollElement 
        || !pScrollElement->HasLayoutPtr() 
        || !pScrollElement->IsInMarkup()
        || !pScrollElement->IsScrollingParent()
      )
        return;

    CLayout   *pScrollLayout = pScrollElement->GetLayoutPtr();
    CDoc      *pDoc          = pScrollLayout->Doc();
    CDispNode *pDispNode     = pScrollLayout->GetElementDispNode();

    BOOL        fOptSmoothScroll = pDoc->_pOptionSettings->fSmoothScrolling;

    Assert(pDispNode);
    Assert(pDispNode->IsScroller());

    CSize           size;
    const CSize &   sizeContent = DYNCAST(CDispScroller, pDispNode)->GetContentSize();
    BOOL            fEnableVScroll;
    BOOL            fEnableHScroll;

    size = pDispNode->GetSize();

    fEnableVScroll = (size.cy < sizeContent.cy);
    fEnableHScroll = (size.cx < sizeContent.cx);

    READERMODEINFO rmi =
    {
        sizeof(rmi),
        NULL,
        0,
        &rc,
        _ReaderMode_Scroll,
        _ReaderMode_TranslateDispatch,
        (LPARAM) pScrollElement
    };

    // force smooth scrolling
    //
    pDoc->_pOptionSettings->fSmoothScrolling = TRUE;

    if (!pDoc->InPlace() || !pDoc->InPlace()->_hwnd)
    {
        // not InPlace Activated yet, unable to do auto-scroll reader mode.
        //
        goto Cleanup;
    }

    rmi.hwnd = hwndInPlace = pDoc->InPlace()->_hwnd;

    hinst = (HINSTANCE) GetModuleHandleA("comctl32.dll");
    Assert(hinst && "GetModuleHandleA(COMCTL32) returns NULL");
    if (hinst)
    {
        if (fEnableVScroll && fEnableHScroll)
        {
            hbmp = LoadBitmap(hinst, MAKEINTRESOURCE(IDB_2DSCROLL));
        }
        else if (fEnableVScroll || fEnableHScroll)
        {
            rmi.fFlags |= (fEnableVScroll)
                            ? (RMF_VERTICALONLY) : (RMF_HORIZONTALONLY);
            hbmp = LoadBitmap(
                    hinst,
                    MAKEINTRESOURCE( (fEnableVScroll)
                                     ? (IDB_VSCROLL) : (IDB_HSCROLL)));
        }
    }
    if (!hbmp)
    {
        // 1) no scroll bars are enabled, no need for auto-scroll reader mode.
        // 2) LoadBitmap fails, unable to do auto-scroll reader mode.
        //
        goto Cleanup;
    }

    if (fByMouse)
    {
        pt.x = LOWORD(pMessage->lParam);
        pt.y = HIWORD(pMessage->lParam);
        SetRect(&rc, pt.x, pt.y, pt.x, pt.y);
    }
    else
    {
        GetWindowRect(hwndInPlace, &rc);
        MapWindowPoints(NULL, hwndInPlace, (LPPOINT) &rc, 2);
        SetRect(&rc, rc.left + rc.right / 2, rc.top  + rc.bottom / 2,
                     rc.left + rc.right / 2, rc.top  + rc.bottom / 2);
        rmi.fFlags |= RMF_ZEROCURSOR;
    }

    // Make the "neutral zone" be the size of the origin bitmap window.
    //
    GetObject(hbmp, sizeof(BITMAP), &bmp);
    InflateRect(&rc, bmp.bmWidth / 2, bmp.bmHeight / 2);

    SetProp(hwndInPlace, TEXT("ReaderMode"), (HANDLE)&rc);

    {
#define ORIGIN_CLASS TEXT("MSHTML40_Origin_Class")

        HWND     hwndT, hwndOrigin;
        WNDCLASS wc;
        HRGN     hrgn;

        hwndT = GetParent(hwndInPlace);

        if (!(::GetClassInfo(GetResourceHInst(), ORIGIN_CLASS, &wc)))
        {
            wc.style         = CS_SAVEBITS;
            wc.lpfnWndProc   = _ReaderMode_OriginWndProc;
            wc.cbClsExtra    = 0;
            wc.cbWndExtra    = sizeof(LONG_PTR);
            wc.hInstance     = GetResourceHInst(),
            wc.hIcon         = NULL;
            wc.hCursor       = NULL;
            wc.lpszMenuName  = NULL;
            wc.hbrBackground = NULL;
            wc.lpszClassName = ORIGIN_CLASS;
            RegisterClass(&wc);
        }
        MapWindowPoints(hwndInPlace, hwndT, (LPPOINT)&rc, 2);
        hwndOrigin = CreateWindowEx(
                0,
                ORIGIN_CLASS,
                NULL,
                WS_CHILD | WS_CLIPSIBLINGS,
                rc.left,
                rc.top,
                rc.right - rc.left,
                rc.bottom - rc.top,
                hwndT,
                NULL,
                wc.hInstance,
                NULL);
        if (hwndOrigin)
        {
            // Shove the bitmap into the first window long so that it can
            // be used for painting the origin bitmap in the window.
            //
            SetWindowLongPtr(hwndOrigin, 0, (LONG_PTR)hbmp);
            hrgn = CreateEllipticRgn(0, 0, bmp.bmWidth + 1, bmp.bmHeight + 1);
            SetWindowRgn(hwndOrigin, hrgn, FALSE);

            MapWindowPoints(hwndT, hwndInPlace, (LPPOINT)&rc, 2);

            SetWindowPos(
                    hwndOrigin,
                    HWND_TOP,
                    0,
                    0,
                    0,
                    0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
            UpdateWindow(hwndOrigin);

            DoReaderMode(&rmi);

            DestroyWindow(hwndOrigin);
        }

        DeleteObject(hbmp);

        // USER owns the hrgn, it will clean it up
        //
        // DeleteObject(hrgn);
    }
    RemoveProp(hwndInPlace, TEXT("ReaderMode"));

Cleanup:
    pDoc->_pOptionSettings->fSmoothScrolling = !!fOptSmoothScroll;
#endif // ndef WIN16
    return;
}

#ifndef WIN16
//
// helper function: determine how many lines to scroll per mouse wheel
//
LONG
WheelScrollLines()
{
    LONG uScrollLines = 3; // reasonable default

    if ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
            || (g_dwPlatformID == VER_PLATFORM_WIN32_NT
                            && g_dwPlatformVersion < 0x00040000))
    {
        HKEY hKey;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Control Panel\\Desktop"),
                0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            TCHAR szData[128];
            DWORD dwKeyDataType;
            DWORD dwDataBufSize = ARRAY_SIZE(szData);

            if (RegQueryValueEx(hKey, _T("WheelScrollLines"), NULL,
                        &dwKeyDataType, (LPBYTE) &szData, &dwDataBufSize)
                    == ERROR_SUCCESS)
            {
                uScrollLines = _tcstoul(szData, NULL, 10);
            }
            RegCloseKey(hKey);
        }
    }
    else if (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                 g_dwPlatformVersion >= 0x00040000)
    {
        ::SystemParametersInfo(
                   SPI_GETWHEELSCROLLLINES,
                   0,
                   &uScrollLines,
                   0);
    }

    return uScrollLines;
}

HRESULT
HandleMouseWheel(CLayout * pScrollLayout, CMessage * pMessage)
{
    // WM_MOUSEWHEEL       - line scroll mode
    // CTRL+WM_MOUSEWHEEL  - increase/decrease baseline font size.
    // SHIFT+WM_MOUSEWHEEL - navigate backward/forward
    //
    HRESULT hr          = S_FALSE;
    BOOL    fControl    = (pMessage->dwKeyState & FCONTROL)
                        ? (TRUE) : (FALSE);
    BOOL    fShift      = (pMessage->dwKeyState & FSHIFT)
                        ? (TRUE) : (FALSE);
    BOOL    fEditable   = pScrollLayout->IsEditable(TRUE);
    short   zDelta;
    short   zDeltaStep;
    short   zDeltaCount;

    const static LONG idmZoom[] = { IDM_BASELINEFONT1,
                                    IDM_BASELINEFONT2,
                                    IDM_BASELINEFONT3,
                                    IDM_BASELINEFONT4,
                                    IDM_BASELINEFONT5,
                                    0 };
    short       iZoom;
    MSOCMD      msocmd;

    CDispNode   *pDispNode = pScrollLayout->GetElementDispNode();
    if (!pDispNode || !pDispNode->IsScroller())
        goto Cleanup;

    if (!fControl && !fShift)
    {
        // Do not scroll if vscroll is disallowed. This prevents content of
        // frames with scrolling=no does not get scrolled (IE5 #31515).
        CDispNodeInfo   dni;
        pScrollLayout->GetDispNodeInfo(&dni);
        if (!dni.IsVScrollbarAllowed())
            goto Cleanup;

        // mousewheel scrolling, allow partial circle scrolling.
        //
        zDelta = (short) HIWORD(pMessage->wParam);

        if (zDelta != 0)
        {
            long uScrollLines = WheelScrollLines();
            LONG yPercent = (uScrollLines >= 0)
                          ? ((-zDelta * PERCENT_PER_LINE * uScrollLines) / WHEEL_DELTA)
                          : ((-zDelta * PERCENT_PER_PAGE * abs(uScrollLines)) / WHEEL_DELTA);

            if (pScrollLayout->ScrollByPercent(0, yPercent, MAX_SCROLLTIME))
            {
                hr = S_OK;
            }
        }
    }
    else
    {
        CDoc *  pDoc = pScrollLayout->Doc();

        // navigate back/forward or zoomin/zoomout, should wait until full
        // wheel circle is accumulated.
        //
        zDelta = ((short) HIWORD(pMessage->wParam)) + pDoc->_iWheelDeltaRemainder;
        zDeltaStep = (zDelta < 0) ? (-1) : (1);
        zDeltaCount = zDelta / WHEEL_DELTA;
        pDoc->_iWheelDeltaRemainder  = zDelta - zDeltaCount * WHEEL_DELTA;

        for (; zDeltaCount != 0; zDeltaCount = zDeltaCount - zDeltaStep)
        {
            if (fShift)
            {
                hr = pDoc->Exec(
                        (GUID *) &CGID_MSHTML,
                        (zDelta > 0) ? (IDM_GOFORWARD) : (IDM_GOBACKWARD),
                        0,
                        NULL,
                        NULL);
                if (hr)
                    goto Cleanup;
            }
            else // fControl
            {
                if (!fEditable)
                {
                    // get current baseline font size
                    //
                    for (iZoom = 0; idmZoom[iZoom]; iZoom ++)
                    {
                        msocmd.cmdID = idmZoom[iZoom];
                        msocmd.cmdf  = 0;
                        hr = THR(pDoc->QueryStatusHelper(
                                pScrollLayout->ElementOwner()->Document(),
                                (GUID *) &CGID_MSHTML,
                                1,
                                &msocmd,
                                NULL));
                        if (hr)
                            goto Cleanup;

                        if (msocmd.cmdf == MSOCMDSTATE_DOWN)
                            break;
                    }

                    Assert(idmZoom[iZoom] != 0);
                    if (!idmZoom[iZoom])
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }

                    iZoom -= zDeltaStep;

                    if (iZoom >= 0 && idmZoom[iZoom])
                    {
                        // set new baseline font size
                        //
                        hr = THR(pDoc->Exec(
                                (GUID *) &CGID_MSHTML,
                                idmZoom[iZoom],
                                0,
                                NULL,
                                NULL));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
#endif // ndef WIN16

HRESULT BUGCALL
CFlowLayout::HandleMessage(
    CMessage * pMessage)
{
    HRESULT    hr    = S_FALSE;
    CDoc     * pDoc  = Doc();

    // TODO (13569 - actLayout): This must go into TLS!! (brendand)
    //
    static BOOL     g_fAfterDoubleClick = FALSE;

    BOOL        fLbuttonDown;
    BOOL        fInBrowseMode = !IsEditable();
    CDispNode * pDispNode     = GetElementDispNode();
    BOOL        fIsScroller   = (pDispNode && pDispNode->IsScroller());

    //
    //  Prepare the message for this layout
    //

    PrepareMessage(pMessage);

    // First, forward mouse messages to the scrollbars (if any)
    // (Keyboard messages are handled below and then notify the scrollbar)
    //
    if (    fIsScroller
        &&  (   pMessage->htc == HTC_VSCROLLBAR || pMessage->htc == HTC_HSCROLLBAR )
        &&  (   pMessage->pNodeHit->Element() == ElementOwner() )
        &&  (   (  pMessage->message >= WM_MOUSEFIRST
#ifndef WIN16
                &&  pMessage->message != WM_MOUSEWHEEL
#endif
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU))
    {
        hr = HandleScrollbarMessage(pMessage, ElementOwner());
        if (hr != S_FALSE)
            goto Cleanup;
    }

    //
    //  In Edit mode, if no element was hit, resolve to the closest element
    //

    if (    !fInBrowseMode
        &&  !pMessage->pNodeHit
        &&  (   (   pMessage->message >= WM_MOUSEFIRST
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU)
       )
    {
        CTreeNode * pNode;
        HTC         htc;

        pMessage->resultsHitTest._fWantArrow = FALSE;
        pMessage->resultsHitTest._fRightOfCp = FALSE;

        htc = BranchFromPoint(HT_DONTIGNOREBEFOREAFTER,
                            pMessage->ptContent,
                            &pNode,
                            &pMessage->resultsHitTest);

        if (HTC_YES == htc && pNode)
        {
            HRESULT hr2 = THR( pMessage->SetNodeHit(pNode) );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
        }
    }

    switch(pMessage->message)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        g_fAfterDoubleClick = TRUE;
        hr = HandleButtonDblClk(pMessage);
        break;

    case WM_MBUTTONDOWN:
#ifdef UNIX
        if (!fInBrowseMode && pMessage->pNodeHit->IsEditable())
        {
            // Perform a middle button paste
            VARIANTARG varTextHandle;
            V_VT(&varTextHandle) = VT_EMPTY;
            g_uxQuickCopyBuffer.GetTextSelection(NULL, FALSE, &varTextHandle);
            
            if (V_VT(&varTextHandle) == VT_EMPTY )
            {
                hr = S_OK; // NO data
            }
            else
            {
                //Convert to V_BSTR
                HGLOBAL hUnicode = TextHGlobalAtoW(V_BYREF(&varTextHandle));
                TCHAR *pszText = (LPTSTR)GlobalLock(hUnicode);
                if (pszText)
                {
                    VARIANTARG varBSTR;
                    TCHAR* pT = pszText;
                    
                    while (*pT) // Filter reserved chars
                    {
                        if (!IsValidWideChar(*pT))
                            *pT = _T('?');
                        pT++;
                    }
                    V_VT(&varBSTR) = VT_BSTR;
                    V_BSTR(&varBSTR) = SysAllocString(pszText);
                    hr = THR(pDoc->Exec((GUID*)&CGID_MSHTML, IDM_PASTE, IDM_PASTESPECIAL, &varBSTR, NULL));
                    SysFreeString(V_BSTR(&varBSTR));
                }
                GlobalUnlock(hUnicode);
                GlobalFree(hUnicode);
            }
            goto Cleanup;
        }
#endif

        if (
                pDispNode
            &&  pDispNode->IsScroller()
            &&  !Doc()->_fDisableReaderMode
            )
        {
            CDispNodeInfo   dni;
            GetDispNodeInfo(&dni);

            if (dni.IsVScrollbarAllowed())
            {
                //ExecReaderMode runs message pump, so element can be destroyed
                //during it. AddRef helps.
                CElement * pElement = ElementOwner();
                pElement->AddRef();
                ExecReaderMode(pElement, pMessage, TRUE);
                pElement->Release();
            }
            hr = S_OK;
        }
        break;

#ifdef UNIX
    case WM_GETTEXTPRIMARY:
        hr = S_OK;

        // Give Mainwin the data currently selected so it can
        // provide it to X for a middle button paste.
       
        // Or, give MSHTML a chance to update selected data, this comes from
        // Trident DoSelection done.
        if (pMessage->lParam == IDM_CLEARSELECTION) 
        {
            CMessage theMessage;
            SelectionMessageToCMessage((SelectionMessage *)pMessage->wParam, &theMessage);
            {
                CDoc *pSelDoc = theMessage.pNodeHit->Element()->Doc(); 
                g_uxQuickCopyBuffer.NewTextSelection(pSelDoc); 
            }
            goto Cleanup;
        }
        
        // Retrieve Text to caller.
        {
            // Check to see if we're selecting a password, in which case
            // don't copy it.
            // 
            CElement *pEmOld = pDoc->_pElemCurrent;
            if (pEmOld && pEmOld->Tag() == ETAG_INPUT &&
                (DYNCAST(CInput, pEmOld))->GetType() == htmlInputPassword)
            {
                *(HANDLE *)pMessage->lParam = (HANDLE) NULL;
                goto Cleanup;
            }

            VARIANTARG varTextHandle;
            V_VT(&varTextHandle) = VT_EMPTY;
            
            hr = pDoc->Exec((GUID*)&CGID_MSHTML, IDM_COPY, 0, NULL, &varTextHandle);
            if (hr == S_OK && V_ISBYREF(&varTextHandle))
            {
                *(HANDLE *)pMessage->lParam = (HANDLE)V_BYREF(&varTextHandle);
            }
            else
            {
                *(HANDLE *)pMessage->lParam = (HANDLE) NULL;
                hr = E_FAIL;
            }
        }
        break;

    case WM_UNDOPRIMARYSELECTION:
        // Under Motif only one app can have a selection active
        // at a time. Clear selection here.
        {
            //  NOTE - This is not really a legal operation (and therefore is 
            //   no longer supported).  In order to clear selection, we must 
            //  communicate with the editor.  See marka or johnthim for details.
            //
            //  CMarkup *pMarkup = pDoc->GetCurrentMarkup();
            //  if (pMarkup) // Clear selection 
            //      pMarkup->ClearSegments(TRUE);
            g_uxQuickCopyBuffer.ClearSelection();
        }
        break;
#endif

    case WM_MOUSEMOVE:
        fLbuttonDown = !!(GetKeyState(VK_LBUTTON) & 0x8000);

        if (fLbuttonDown && pDoc->_state >= OS_INPLACE)
        {
            // if we came in with a lbutton down (lbuttonDown = TRUE) and now
            // it is up, it might be that we lost the mouse up event due to a
            // DoDragDrop loop. In this case we have to UI activate ourselves
            //
            if (!(GetKeyState(VK_LBUTTON) & 0x8000))
            {
                hr = THR(ElementOwner()->BecomeUIActive());
                if (hr)
                    goto Cleanup;
            }
        }
        break;
#ifndef WIN16
    case WM_MOUSEWHEEL:
        hr = THR(HandleMouseWheel(this, pMessage));
        break;
#endif // ndef WIN16
    case WM_CONTEXTMENU:
    {
        ISegmentList            *pSegmentList = NULL;
        ISelectionServices      *pSelSvc = NULL;
        ISegmentListIterator    *pIter = NULL;     
        HRESULT                 hrSuccess = S_OK;
        
        hrSuccess = Doc()->GetSelectionServices(&pSelSvc);
        if( !hrSuccess )
            hrSuccess = pSelSvc->QueryInterface(IID_ISegmentList, (void **)&pSegmentList );
        if( !hrSuccess )
            hrSuccess = pSegmentList->CreateIterator( &pIter );

        if( FAILED(hrSuccess ) )            
        {
            AssertSz(FALSE, "Cannot get segment list");
            hr = S_OK;
        }
        else
        {
            switch(pDoc->GetSelectionType())
            {               
                case SELECTION_TYPE_Control:
                    // Pass on the message to the first element that is selected
                    {
                        ISegment        *pISegment = NULL;
                        IElementSegment *pIElemSegment = NULL;               
                        IHTMLElement    *pIElemSelected  = NULL;
                        CElement        *pElemSelected   = NULL;

                        // Get the current segment (the first one) and retrieve its
                        // associated element
                        if( S_OK == pIter->Current(&pISegment)                                              &&
                            S_OK == pISegment->QueryInterface(IID_IElementSegment, (void **)&pIElemSegment) &&
                            S_OK == pIElemSegment->GetElement(&pIElemSelected)                              &&
                            S_OK == pIElemSelected->QueryInterface( CLSID_CElement, (void**)&pElemSelected) )
                        {
                            // if the site-selected element is different from the owner, pass the message to it
                            Assert(pElemSelected);
                            if (pElemSelected != ElementOwner())
                            {
                                // Call HandleMessage directly because we do not bubbling here
                                hr = pElemSelected->HandleMessage(pMessage);
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "Cannot get selected element");                            
                            hr = S_OK;
                        }

                        ReleaseInterface(pISegment);
                        ReleaseInterface(pIElemSegment);
                        ReleaseInterface(pIElemSelected);
                    }
                    break;

                case SELECTION_TYPE_Text:
                    // Display special menu for text selection in browse mode
                    // (dmitryt) Elements that have "contentEditable" default to 
                    // CONTEXT_MENU_CONTROL. We just bail out of here and super::HandleMessage() 
                    // will do the right thing.
                    if (!IsEditable())  
                    {
                        int cx, cy;

                        cx = (short)LOWORD(pMessage->lParam);
                        cy = (short)HIWORD(pMessage->lParam);

                        if (cx == -1 && cy == -1) // SHIFT+F10
                        {
                            ISegment       *    pISegment   = NULL;
                            IMarkupPointer *    pIStart     = NULL;
                            IMarkupPointer *    pIEnd       = NULL;
                            CMarkupPointer *    pStart      = NULL;
                            CMarkupPointer *    pEnd        = NULL;

                            // Retrieve the selection segment
                            if( pIter->Current(&pISegment) == S_OK )
                            {
                                // Compute position at whcih to display the menu
                                if (    S_OK == pDoc->CreateMarkupPointer(&pStart)
                                    &&  S_OK == pDoc->CreateMarkupPointer(&pEnd)
                                    &&  S_OK == pStart->QueryInterface(IID_IMarkupPointer, (void**)&pIStart)
                                    &&  S_OK == pEnd->QueryInterface(IID_IMarkupPointer, (void**)&pIEnd)
                                    &&  S_OK == pISegment->GetPointers(pIStart, pIEnd) )
                                {
                                    CMarkupPointer * pmpSelMin;
                                    POINT            ptSelMin;

                                    ReleaseInterface(pIStart);
                                    ReleaseInterface(pIEnd);
                                    
                                    if (OldCompare( pStart, pEnd ) > 0)
                                        pmpSelMin = pEnd;
                                    else
                                        pmpSelMin = pStart;

                                    if (_dp.PointFromTp(
                                            pmpSelMin->GetCp(), NULL, FALSE, FALSE, ptSelMin, NULL, TA_BASELINE) != -1)
                                    {
                                        RECT rcWin;

                                        GetWindowRect(pDoc->InPlace()->_hwnd, &rcWin);
                                        cx = ptSelMin.x - GetXScroll() + rcWin.left - CX_CONTEXTMENUOFFSET;
                                        cy = ptSelMin.y - GetYScroll() + rcWin.top  - CY_CONTEXTMENUOFFSET;
                                    }
                                    
                                    ReleaseInterface(pStart);
                                    ReleaseInterface(pEnd);
                                }
                            }

                            ReleaseInterface(pISegment);
                        }
                        hr = THR(ElementOwner()->OnContextMenu(cx, cy, CONTEXT_MENU_TEXTSELECT));
                    }
                    break;

            } // Switch
        }
        
        ReleaseInterface(pSelSvc);
        ReleaseInterface(pIter);
        ReleaseInterface(pSegmentList);
    }
    break;
    

    case WM_SETCURSOR:
        // Are we over empty region?
        //
        hr = THR(HandleSetCursor(
                pMessage,
                pMessage->resultsHitTest._fWantArrow
                              && fInBrowseMode));
        break;

    case WM_SYSKEYDOWN:
        hr = THR(HandleSysKeyDown(pMessage));
        break;
    }

    // Remember to call super
    if (hr == S_FALSE)
    {
        hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


ExternTag(tagPaginate);

class CStackPageBreaks
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CStackPageBreaks))
    CStackPageBreaks();

    HRESULT Insert(long yPosTop, long yPosBottom, long xWidthSplit);
    long GetSplit();

    CStackPtrAry<LONG_PTR, 20> _aryYPos;
    CStackPtrAry<LONG_PTR, 20> _aryXWidthSplit;
};


CStackPageBreaks::CStackPageBreaks() : _aryYPos(Mt(CStackPageBreaks_aryYPos_pv)),
                                       _aryXWidthSplit(Mt(CStackPageBreaks_aryXWidthSplit_pv))
{
}

HRESULT
CStackPageBreaks::Insert(long yPosTop, long yPosBottom, long xWidthSplit)
{
    int     iStart = 0, iEnd = 0, cRanges = _aryYPos.Size() - 1, iCount, iSize;

    HRESULT hr = S_OK;

    Assert(yPosTop <= yPosBottom);
    Assert(xWidthSplit >= 0);


    // 0. Insert first range.
    if (!_aryYPos.Size())
    {
        hr = _aryYPos.Insert(0, yPosTop);
        if (hr)
            goto Cleanup;

        hr = _aryYPos.Insert(1, yPosBottom);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(0, xWidthSplit);

        // Done.
        goto Cleanup;
    }

    // 1. Find beginning of range.
    while (iStart < cRanges && yPosTop > (LONG)_aryYPos[iStart])
        iStart++;

    // If necessary, beginning creates new range.
    if (yPosTop < (LONG)_aryYPos[iStart])
    {
        hr = _aryYPos.Insert(iStart, yPosTop);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(iStart, (LONG)_aryXWidthSplit[iStart-1]);
        if (hr)
            goto Cleanup;

        cRanges++;
    }

    // 2. Find end of range.
    iEnd = iStart;

    while (iEnd < cRanges && yPosBottom > (LONG)_aryYPos[iEnd+1])
        iEnd++;

    // If necessary, end creates new range.
    if (iEnd < cRanges && yPosBottom < (LONG)_aryYPos[iEnd+1])
    {
        hr = _aryYPos.Insert(iEnd+1, yPosBottom);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(iEnd+1, (LONG)_aryXWidthSplit[iEnd]);
        if (hr)
            goto Cleanup;

        cRanges++;
    }

    // 3. Increment the ranges covered.
    iSize = _aryXWidthSplit.Size(); // protecting from overflowing the split array
    for (iCount = iStart ; iCount <= iEnd && iCount < iSize ; iCount++)
    {
        _aryXWidthSplit[iCount] += xWidthSplit;
    }

#if DBG == 1
    if (IsTagEnabled(tagPaginate))
    {
        TraceTag((tagPaginate, "Dumping page break ranges:"));
        for (int iCount = 0; iCount < _aryXWidthSplit.Size(); iCount++)
        {
            TraceTag((tagPaginate, "%d - %d : %d", iCount, (LONG)_aryYPos[iCount], (LONG)_aryXWidthSplit[iCount]));
        }
    }
#endif

Cleanup:

    RRETURN(hr);
}


long
CStackPageBreaks::GetSplit()
{
    if (!_aryYPos.Size())
    {
        Assert(!"Empty array");
        return 0;
    }

    int iPosMin = _aryXWidthSplit.Size()-1, iCount;
    long xWidthSplitMin = (LONG)_aryXWidthSplit[iPosMin];

    for (iCount = iPosMin-1 ; iCount > 0 ; iCount--)
    {
        if ((LONG)_aryXWidthSplit[iCount] < xWidthSplitMin)
        {
            xWidthSplitMin = (LONG)_aryXWidthSplit[iCount];
            iPosMin = iCount;
        }
    }

    return (LONG)_aryYPos[iPosMin+1]-1;
}


//+---------------------------------------------------------------------------
//
//  Member:     AppendNewPage
//
//  Synopsis:   Adds a new page to the print doc.  Called by Paginate.  This
//              is a helper function used to reuse code and clean up paginate.
//
//  Arguments:  paryPP               Page array to add to
//              pPP                  New page
//              pPPHeaderFooter      Header footer buffer page
//              yHeader              Height of header to be repeated
//              yFooter              Height of footer
//              yFullPageHeight      Height of a full (new) page
//              xMaxPageWidthSofar   Width of broken line (max sofar)
//              pyTotalPrinted       Height of content paginated sofar
//              pySpaceLeftOnPage    Height of y-space left on page
//              pyPageHeight         Height of page
//              pfRejectFirstFooter  Should the first repeated footer be rejected
//
//----------------------------------------------------------------------------

HRESULT AppendNewPage(CDataAry<CPrintPage> * paryPP,
                      CPrintPage * pPP,
                      CPrintPage * pPPHeaderFooter,
                      long yHeader,
                      long yFooter,
                      long yFullPageHeight,
                      long xMaxPageWidthSofar,
                      long * pyTotalPrinted,
                      long * pySpaceLeftOnPage,
                      long * pyPageHeight,
                      BOOL * pfRejectFirstFooter)
{
    HRESULT hr = S_OK;

    Assert(pfRejectFirstFooter && paryPP && pPP &&
           pPPHeaderFooter && pyTotalPrinted && pySpaceLeftOnPage && pyPageHeight);

    TraceTag((tagPaginate, "Appending block of size %d", pPP->yPageHeight));

    if (yFooter)
    {
        pPP->fReprintTableFooter = !(*pfRejectFirstFooter);
        pPP->pTableFooter = pPPHeaderFooter->pTableFooter;
        pPP->rcTableFooter = pPPHeaderFooter->rcTableFooter;
        *pfRejectFirstFooter = FALSE;
    }

    hr = THR(paryPP->AppendIndirect(pPP));
    if (hr)
        goto Cleanup;

    *pyTotalPrinted += pPP->yPageHeight;
    pPP->yPageHeight = 0;
    pPP->xPageWidth = xMaxPageWidthSofar;
    *pySpaceLeftOnPage = *pyPageHeight = yFullPageHeight - yHeader - yFooter;
    pPP->fReprintTableFooter = FALSE;

    if (yHeader)
    {
        pPP->fReprintTableHeader = TRUE;
        pPP->pTableHeader = pPPHeaderFooter->pTableHeader;
        pPP->rcTableHeader = pPPHeaderFooter->rcTableHeader;
    }

Cleanup:

    RRETURN(hr);
}




#if DBG == 1
BOOL
CFlowLayout::IsInPlace()
{
    // lie if in a printdoc.
    return Doc()->IsPrintDialogNoUI() || Doc()->_state >= OS_INPLACE;
}
#endif

HRESULT
CFlowLayout::HandleButtonDblClk(CMessage *pMessage)
{
    // Repaint window to show any exposed portions
    //
    ViewChange(Doc()->_state >= OS_INPLACE ? TRUE : FALSE);
    return S_OK;
}

WORD ConvVKey(WORD vKey);
void TestMarkupServices(CElement *pElement);
void TestSelectionRenderServices( CMarkup* pMarkup, CElement* pTestElement);
void DumpFormatCaches();

HRESULT
CFlowLayout::HandleSysKeyDown(CMessage *pMessage)
{
    HRESULT    hr    = S_FALSE;

#if DBG == 1
    CMarkup * pMarkup   = GetContentMarkup();
#endif

    // NOTE: (anandra) Most of these should be handled as commands
    // not keydowns.  Use ::TranslateAccelerator to perform translation.
    //

    if(pMessage->wParam == VK_BACK && (pMessage->lParam & SYS_ALTERNATE))
    {
        Sound();
        hr = S_OK;
    }
#if DBG == 1
    else if ((pMessage->wParam == VK_F4) && !(pMessage->dwKeyState & MK_ALT)
            && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
#ifdef MERGEFUN // iRuns
         CTreePosList & eruns = GetList();
         LONG iStart, iEnd, iDelta, i;
         CElement * pElement;

        if (GetKeyState(VK_SHIFT) & 0x8000)
        {
            iStart = 0;
            iEnd = eruns.Count() - 1;
            iDelta = +1;
        }
        else
        {
            iStart = eruns.Count() - 1;
            iEnd = 0;
            iDelta = -1;
        }

        pElement = NULL;
        for (i=iStart; i != iEnd; i += iDelta)
        {
            if (eruns.GetRunAbs(i).Cch())
            {
                pElement = eruns.GetRunAbs(i).Branch()->ElementOwner();
                break;
            }
        }
        if (pElement)
        {
            SCROLLPIN sp = (iDelta > 0) ? SP_TOPLEFT : SP_BOTTOMRIGHT;
            hr = ScrollElementIntoView( pElement, sp, sp );
        }
        else
        {
            hr = S_OK;
        }
#endif
    }
    else if (   pMessage->wParam == VK_F9
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        Doc()->DumpLayoutRects();
        hr = S_OK;
    }
    // Used by the TestSelectionRenderServices test
    else if (   pMessage->wParam == VK_F10
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            // Used by the TestSelectionRenderServices
            TestSelectionRenderServices(pMarkup, ElementOwner());
        hr = S_OK;
    }
    else if (   pMessage->wParam == VK_F11
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            TestMarkupServices(ElementOwner());
        else
            pMarkup->DumpTree();
        hr = S_OK;
    }
    else if (   pMessage->wParam == VK_F12
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            TestMarkupServices(ElementOwner());
        else
            DumpLines();
        hr = S_OK;
    }

    else if (   pMessage->wParam == VK_F9
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        extern int g_CFTotalCalls;
        extern int g_CFAttemptedSteals;
        extern int g_CFSuccessfulSteals;

        if (InitDumpFile())
        {
            WriteHelp(g_f, _T("\r\nTotal: <0d> - "), (long)g_CFTotalCalls);
            WriteHelp(g_f, _T("\r\nAttempts to steal: <0d> - "), (long)g_CFAttemptedSteals);
            WriteHelp(g_f, _T("\r\nSuccess: <0d> - "), (long)g_CFSuccessfulSteals);
            CloseDumpFile();
        }

#ifdef MERGEFUN // iRuns
        CTreePosList & elementRuns = GetList();

        CNotification  nf;

        for (int i = 0; i < long(elementRuns.Count()); i++)
        {
            elementRuns.VoidCachedInfoOnBranch(elementRuns.GetBranchAbs(i));
        }
        pDoc->InvalidateTreeCache();

        nf.CharsResize(
                0,
                pMarkup->GetContentTextLength(),
                0,
                elementRuns.NumRuns(),
                GetFirstBranch());
        elementRuns.Notify(nf);
#endif
        hr = S_OK;
    }
    else if(   pMessage->wParam == VK_F8
            && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        pMarkup->DumpClipboardText( );
    }
#endif

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CFlowLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CHitTestInfo *  phti            = (CHitTestInfo *)pClientData;
    CDispNode    *  pDispElement    = GetElementDispNode();
    HTC             htcLocal        = HTC_NO;

    BOOL            fHitTestContent = (   !pDispElement->IsContainer()
                                       || pDispElement != pDispNode
                                       || (phti->_grfFlags & HT_HTMLSCOPING));
    BOOL        fHackedHitForStrict = FALSE;
    
    // Skip nested markups if asked to do so
    if (phti->_grfFlags & HT_SKIPSITES)
    {
        CElement *pElement = ElementContent();
        if (   pElement
            && pElement->HasSlavePtr()
            && !SameScope(pElement, phti->_pNodeElement)
           )
        {
            phti->_htc = HTC_NO;
            goto Cleanup;
        }
    }
        
    if (fHitTestContent)
    {
        //
        //  If allowed, see if a child element is hit
        //  NOTE: Only check content when the hit display node is a content node
        //
        CTreeNode * pNodeHit = NULL;

        htcLocal = BranchFromPoint(phti->_grfFlags,
                                     *pptHit,
                                     &pNodeHit,
                                     phti->_phtr,
                                     TRUE,                  // ignore pseudo hit's
                                     pDispNode);

        // NOTE (donmarsh) - BranchFromPoint was written before the Display Tree
        // was introduced, so it might return a child element that already rejected
        // the hit when it was called directly from the Display Tree.  Therefore,
        // if BranchFromPoint returned an element that has its own layout, and if
        // that layout has its own display node, we reject the hit.
        //
        // But non-display tree callers (like moveToPoint) need this hit returned, since
        // they don't care about z-ordering or positioning.
        //
        // if the node hit is already registered in the hti, then we don't have to worry 
        // about this.
        if (    htcLocal == HTC_YES
            &&  pNodeHit != NULL
            && !phti->_phtr->_fGlyphHit
            &&  pNodeHit->Element() != ElementOwner()
            &&  pNodeHit->ShouldHaveLayout(LC_TO_FC(LayoutContext()))
            && !(phti->_grfFlags & HT_HTMLSCOPING)
            && pNodeHit != phti->_pNodeElement
            )
        {
            htcLocal = HTC_NO;
            pNodeHit = NULL;
        }

        // If we pseudo-hit a flow-layer dispnode that isn't the "bottom-most"
        // (i.e. "first") flow-layer dispnode for this element, then we pretend
        // we really didn't hit it.  This allows hit testing to "drill through"
        // multiple flow-layer dispnodes in order to support hitting through
        // non-text areas of display nodes generated by -ve margins.
        // Bug #
        else if (   htcLocal == HTC_YES 
                 && phti->_phtr->_fPseudoHit == TRUE
                 && pDispNode->IsFlowNode()
                 && !phti->_phtr->_fBulletHit
                )
        {
            if (pDispNode->GetPreviousFlowNode())
            {
                htcLocal = HTC_NO;
            }
        }

        if (   pNodeHit 
            && htcLocal != HTC_NO
           )
        {
            // At this point if we hit an element w/ layout, it better
            // be the the owner of this layout; otherwise the display
            // tree should have called us on the HitTestContent of that
            // layout!! 
            Assert(   phti->_phtr->_fGlyphHit
                   || (pNodeHit->Element()->ShouldHaveLayout(LC_TO_FC(LayoutContext())) ?
                       pNodeHit->Element() == ElementOwner() :
                       TRUE
                      )
                   || (phti->_grfFlags & HT_HTMLSCOPING)
                   || pNodeHit == phti->_pNodeElement
                  );

            //
            //  Save the point and CDispNode associated with the hit
            //
            phti->_pNodeElement = pNodeHit;
            phti->_htc = HTC_YES;
            SetHTILayoutContext( phti );
            phti->_ptContent    = *pptHit;
            phti->_pDispNode    = pDispNode;

            // keep hitttesting if htcLocal==NO. Note this is the opposite locic 
            // from the return below
            return (   pDispNode->HasBackground()
                    || htcLocal == HTC_YES);    
        }
        
        if (   htcLocal == HTC_NO
            && !pDispNode->HasBackground()
           )
        {
            Assert(fHitTestContent);
            CElement *pElement = ElementOwner();
            if (   ETAG_BODY == pElement->Tag()
                && pElement->GetMarkup()->IsStrictCSS1Document()
               )
            {
                fHackedHitForStrict = TRUE;
            }
        }

        if (   htcLocal == HTC_NO
            && pDispElement->IsContainer()
            && (phti->_grfFlags & HT_HTMLSCOPING)
            && pDispNode->HasBackground()
           )
        {
            fHitTestContent = FALSE;
        }
    }


    //
    // Do not call super if we are hit testing content and the current
    // element is a container. DisplayTree calls back with a HitTest
    // for the background after hittesting the -Z content.
    //
    if (   !fHitTestContent
        || fHackedHitForStrict
        || !pDispElement->IsContainer()
        || (   phti->_grfFlags & HT_HTMLSCOPING
            && phti->_pNodeElement == NULL
            && pDispElement == pDispNode))
    {
        //
        //  If no child and no peer was hit, use default handling
        //  Don't override hit info if something was already registered as the 
        //  psuedoHit element
        //
        HitTestContentWithOverride(pptHit, pDispNode, pClientData, FALSE, fDeclinedByPeer); 

        //
        // if there is a background set, we are opaque and should register
        // the hit as "hard", otherwise, cache the info but keep hittesting
        //

        return pDispNode->HasBackground() || fHackedHitForStrict;
    }
    
Cleanup:

    return (htcLocal != HTC_NO);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::NotifyScrollEvent
//
//  Synopsis:   Respond to a change in the scroll position of the display node
//
//----------------------------------------------------------------------------

void
CFlowLayout::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    super::NotifyScrollEvent(prcScroll, psizeScrollDelta);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::DumpDebugInfo
//
//  Synopsis:   Dump debugging information for the given display node.
//
//  Arguments:  hFile           file handle to dump into
//              level           recursive tree level
//              childNumber     number of this child within its parent
//              pDispNode       pointer to display node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CFlowLayout::DumpDebugInfo(
        HANDLE hFile,
        long level,
        long childNumber,
        CDispNode const* pDispNode,
        void *cookie)
{
    if (pDispNode->IsOwned())
    {
        super::DumpDebugInfo(hFile, level, childNumber, pDispNode, cookie);
    }
    
    if (pDispNode->IsLeafNode())
    {
        CStr cstr;
        ElementOwner()->GetPlainTextInScope(&cstr);
        if (cstr.Length() > 0)
        {
            WriteString(hFile, _T("<content><![CDATA["));
            if (cstr.Length() > 50)
                cstr.SetLengthNoAlloc(50);
            WriteString(hFile, (LPTSTR) cstr);
            WriteString(hFile, _T("]]></content>\r\n"));
        }
    }
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//
//  Returns:    Pointer to the element CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CFlowLayout::GetElementDispNode( CElement *  pElement ) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
                    : pElement->IsRelative()
                        ? ((CFlowLayout *)this)->_dp.FindElementDispNode(pElement)
                        : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     SetElementDispNode
//
//  Synopsis:   Set the display node for an element
//              NOTE: This is only supported for elements with layouts or
//                    those that are relatively positioned
//
//-----------------------------------------------------------------------------
void
CFlowLayout::SetElementDispNode( CElement *  pElement, CDispNode * pDispNode )
{
    if (    !pElement
        ||  pElement == ElementOwner())
    {
        super::SetElementDispNode(pElement, pDispNode);
    }
    else
    {
        Assert(pElement->IsRelative());
        Assert(!pElement->ShouldHaveLayout());
        _dp.SetElementDispNode(pElement, pDispNode);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CFlowLayout::GetContentSize
//
//  Synopsis:   Return the width/height of the content
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CFlowLayout::GetContentSize(
    CSize * psize,
    BOOL    fActualSize)
{
    if (fActualSize)
    {
        psize->cx = _dp.GetWidth();
        psize->cy = _dp.GetHeight();
    }
    else
    {
        super::GetContentSize(psize, fActualSize);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CFlowLayout::GetContainerSize
//
//  Synopsis:   Return the width/height of the container
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CFlowLayout::GetContainerSize(
    CSize * psize)
{
    psize->cx = _dp.GetViewWidth();
    psize->cy = _dp.GetHeight();
}


//+-------------------------------------------------------------------------
//
//  Method:     YieldCurrencyHelper
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pElemNew    New site that wants currency
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::YieldCurrencyHelper(CElement * pElemNew)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     BecomeCurrentHelper
//
//  Synopsis:   Force currency on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become current.
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::BecomeCurrentHelper(long lSubDivision, BOOL *pfYieldFailed, CMessage * pMessage)
{
    BOOL    fOnSetFocus = ::GetFocus() == Doc()->_pInPlace->_hwnd;
    HRESULT hr          = S_OK;

    // Call OnSetFocus directly if the doc's window already had focus. We
    // don't need to do this if the window didn't have focus because when
    // we take focus in BecomeCurrent, the window message handler does this.
    //
    if (fOnSetFocus)
    {
        // if our inplace window did have the focus, then fire the onfocus
        // only if onblur was previously fired and the body is becoming the
        // current site and currency did not change in onchange or onpropchange
        //
        if (ElementOwner() == Doc()->_pElemCurrent && ElementOwner() == ElementOwner()->GetMarkup()->GetElementClient())
        {
            Doc()->GetCurrentWindow()->Post_onfocus();
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Function: GetNestedElementCch
//
// Synopsis: Returns the number of characters that correspond to the element
//           under the current layout context
//
//-----------------------------------------------------------------------------
LONG
CFlowLayout::GetNestedElementCch(CElement  *pElement,       // IN:  The nested element
                                 CTreePos **pptpLast,       // OUT: The pos beyond pElement 
                                 LONG       cpLayoutLast,   // IN:  This layout's last cp
                                 CTreePos  *ptpLayoutLast)  // IN:  This layout's last pos
{
    CTreePos * ptpStart;
    CTreePos * ptpLast;
    long       cpElemStart;
    long       cpElemLast;

    if (cpLayoutLast == -1)
        cpLayoutLast = GetContentLastCp();
    Assert(cpLayoutLast == GetContentLastCp());
    if (ptpLayoutLast == NULL)
    {
        ElementContent()->GetTreeExtent(NULL, &ptpLayoutLast);
    }
#if DBG==1
    {
        CTreePos *ptpLastDbg;
        ElementContent()->GetTreeExtent(NULL, &ptpLastDbg);
        Assert(ptpLayoutLast == ptpLastDbg);
    }
#endif
    
    pElement->GetTreeExtent(&ptpStart, &ptpLast);

    Assert(ptpStart && ptpLast); //we should not layout elements that are not in the tree...

    cpElemStart = ptpStart->GetCp();
    cpElemLast  = ptpLast->GetCp();

    if(cpElemLast > cpLayoutLast)
    {
        if(pptpLast)
        {
            ptpLast = ptpLayoutLast->PreviousTreePos();
            while(!ptpLast->IsNode())
            {
                Assert(ptpLast->GetCch() == 0);
                ptpLast = ptpLast->PreviousTreePos();
            }
        }

        // for overlapping layout limit the range to
        // parent layout's scope.
        cpElemLast = cpLayoutLast - 1;
    }

    if(pptpLast)
        *pptpLast = ptpLast;

    return(cpElemLast - cpElemStart + 1);
}

void
CFlowLayout::ShowSelected( CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected,  BOOL fLayoutCompletelyEnclosed )
{
    Assert(ptpStart && ptpEnd && ptpStart->GetMarkup() == ptpStart->GetMarkup());
    CElement* pElement = ElementOwner();

    // If this has a slave, but the selection is in the main markup, then
    // select the element (as opposed to part or all of its content)
    if  ( pElement->HasSlavePtr()
           &&  ptpStart->GetMarkup() != ElementOwner()->GetSlavePtr()->GetMarkup() )
    {
        SetSelected( fSelected, TRUE );
    }
    else
    {
        if(
#ifdef  NEVER
           ( pElement->_etag == ETAG_HTMLAREA ) ||
#endif
           ( pElement->_etag == ETAG_BUTTON ) ||
           ( pElement->_etag == ETAG_TEXTAREA ) )
        {
            if (( fSelected && fLayoutCompletelyEnclosed ) ||
                ( !fSelected && ! fLayoutCompletelyEnclosed ) )
                SetSelected( fSelected, TRUE );
            else
            {
                                _dp.ShowSelected( ptpStart, ptpEnd, fSelected);
            }
        }
        else
                        _dp.ShowSelected( ptpStart, ptpEnd, fSelected);
    }      
}

//----------------------------------------------------------------------------
//  RegionFromElement
//
//  DESCRIPTION:
//      This is a virtual wrapper function to wrap the RegionFromElement that is
//      also implemented on the flow layout.
//      The RECT returned is in client coordinates.
//
//----------------------------------------------------------------------------

void
CFlowLayout::RegionFromElement( CElement       * pElement,
                                CDataAry<RECT> * paryRects,
                                RECT           * prcBound,
                                DWORD            dwFlags)
{
    Assert( pElement);
    Assert( paryRects );

    if ( !pElement || !paryRects )
        return;

    // Is the element passed the same element with the owner?
    if ( _pElementOwner == pElement )
    {
        // call CLayout implementation.
        super::RegionFromElement( pElement, paryRects, prcBound, dwFlags);
    }
    else
    {
        // Delegate the call to the CDisplay implementation
        _dp.RegionFromElement( pElement,          // the element
                               paryRects,         // rects returned here
                               NULL,              // offset the rects returned
                               NULL,              // ask RFE to get CFormDrawInfo
                               dwFlags,           // coord w/ respect to the client rc.
                               -1,                // Get the complete focus
                               -1,                //
                               prcBound);         // bounds of the element!
    }
}

//----------------------------------------------------------------------------
//  SizeDispNode
//
//  DESCRIPTION:
//      Size disp node, with adjustments specific to flow layout
//
//----------------------------------------------------------------------------

void
CFlowLayout::SizeDispNode(
    CCalcInfo *     pci,
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    
    super::SizeDispNode(pci, size, fInvalidateAll);
    
    if (IsRTLFlowLayout())
    {
        SizeRTLDispNode(_pDispNode, FALSE);
    }

    if (IsBodySizingForStrictCSS1Needed())
    {
        BodySizingForStrictCSS1Doc(_pDispNode);
    }
}

void
CFlowLayout::SizeContentDispNode(
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    BOOL fDoBodyWork = IsBodySizingForStrictCSS1Needed();
    
    if (!_dp._fHasMultipleTextNodes)
    {
        super::SizeContentDispNode(size, fInvalidateAll);

        if (IsRTLFlowLayout())
        {
            SizeRTLDispNode(GetFirstContentDispNode(), TRUE);
        }

        if (fDoBodyWork)
        {
            BodySizingForStrictCSS1Doc(GetFirstContentDispNode());
        }
    }
    else
    {
        CDispNode * pDispNode = GetFirstContentDispNode();

        // we better have a content dispnode
        Assert(pDispNode);

        for (; pDispNode; pDispNode = pDispNode->GetNextFlowNode())
        {
            CDispClient * pDispClient = this;

            if (pDispNode->GetDispClient() == pDispClient)
            {
                pDispNode->SetSize(CSize(size.cx, size.cy - (pDispNode->GetPosition()).y), NULL, fInvalidateAll);
                
                if (IsRTLFlowLayout())
                {
                    SizeRTLDispNode(pDispNode, TRUE);
                }
                if (fDoBodyWork)
                {
                    BodySizingForStrictCSS1Doc(GetFirstContentDispNode());
                }
            }
        }
    }
}

void
CFlowLayout::BodySizingForStrictCSS1Doc(CDispNode *pDispNode)
{
    CRect rc(CRect::CRECT_EMPTY);
    LONG leftV, rightV;

    GetExtraClipValues(&leftV, &rightV);
    rc.left = leftV;
    rc.right = rightV;
    pDispNode->SetExpandedClipRect(rc);
}

//----------------------------------------------------------------------------
//  SizeRTLDispNode
//
//  DESCRIPTION:
//      Store additional sizing information on RTL display node
//
//----------------------------------------------------------------------------
void
CFlowLayout::SizeRTLDispNode(CDispNode * pDispNode, BOOL fContent)
{
    // RTL layout may have a non-zero content origin caused by lines stretching to the left
    Assert(IsRTLFlowLayout());
    
    if(pDispNode && pDispNode->HasContentOrigin())
    {
        // set content origin to the difference between provisional layout width (cxView)
        // and actual layout width (cxLayout)
        int cxView = GetDisplay()->GetViewWidth();
        int cxLayout = GetDisplay()->GetWidth();
        int cxOffset = max(0, cxLayout - cxView);

        pDispNode->SetContentOrigin(CSize(0, 0), cxView);

        // Offset content disp nodes nodes to match container's origin offset
        if (fContent)
        {
            CPoint ptPosition(-cxOffset, 0);
            pDispNode->SetPosition(ptPosition);
        }
    }
    else
    {
        // If we have a disp node, it must have content origin allocated.
        // If it doesn't, it means that GetDispNodeInfo() is buggy
        AssertSz(!pDispNode, "No content origin on an RTL flow node ???");
    }
}


HRESULT
CFlowLayout::MovePointerToPointInternal(
    CElement *          pElemEditContext,
    POINT               tContentPoint,
    CTreeNode *         pNode,
    CLayoutContext *    pLayoutContext,     // layout context corresponding to pNode
    CMarkupPointer *    pPointer,
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp,
    BOOL                fScrollIntoView,
    CLayout*            pContainingLayout ,
    BOOL*               pfValidLayout,
    BOOL                fHitTestEndOfLine,
    BOOL*               pfHitGlyph,
    CDispNode*          pDispNode
)
{
    HRESULT         hr = S_OK;
    LONG            cp = 0;
    BOOL            fNotAtBOL;
    BOOL            fAtLogicalBOL;
    BOOL            fRightOfCp;
    CMarkup *       pMarkup = NULL;
    BOOL            fPtNotAtBOL = FALSE;
    CPoint          ptHit(tContentPoint);
    CPoint          ptGlobal;

#if DBG == 1
    CElement* pDbgElement = pNode->Element();
    ELEMENT_TAG eDbgTag = pDbgElement->_etag;    
    TraceTag((tagViewServicesShowEtag, "MovePointerToPointInternal. _etag:%d", eDbgTag));
#endif

    {
        CDisplay * pdp = GetDisplay();
        CLinePtr rp( pdp );
        CLayout *pLayoutOriginal = pNode->GetUpdatedLayout( pLayoutContext );
        LONG cchPreChars = 0;

        //
        // NOTE: (johnbed) this is a completely arbitrary hack, but I have to
        // improvise since I don't know what line I'm on
        //
        fPtNotAtBOL = ptHit.x > 15;   

        if (pLayoutOriginal && this != pLayoutOriginal)
        {
            //
            // NOTE - right now - hit testing over the TR or Table is broken
            // we simply fail this situation. Selection then effectively ignores this point
            //
            if ( pLayoutOriginal->ElementOwner()->_etag == ETAG_TABLE ||
                   pLayoutOriginal->ElementOwner()->_etag == ETAG_TR )
            {
                hr = CTL_E_INVALIDLINE;
                goto Cleanup;
            }
        }

        pdp->WaitForRecalc(-1, ptHit.y );

        ptGlobal = ptHit;
        TransformPoint(&ptGlobal, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL, pDispNode);

        // NOTE (dmitryt) Passed rp is based on current CDisplay. CpFromPointReally can
        // get cp from some other markup (viewslaved for example) and use this found cp
        // to set cp of passed rp. this may be incorrect.

        cp = pdp->CpFromPointReally(    ptGlobal,       // Point
                                        &rp,            // Line Pointer
                                        &pMarkup,    // if not-NULL returned, use this markup for cp
                                        fHitTestEndOfLine ? CDisplay::CFP_ALLOWEOL : 0 ,
                                        &fRightOfCp,
                                        &cchPreChars,
                                        pfHitGlyph);
        if (cp == -1)
            goto Error;

        if(!pMarkup) 
            pMarkup = pNode->GetMarkup();

        if(!pMarkup)
            goto Error;

        TraceTag(( tagViewServicesCpHit, "ViewServices: cpFromPoint:%d\n", cp));

        // Note: (dmitryt) this forces cp back inside of ElementOwner...
        // This is all wrong, because we could easily be moved into a markup of a view slave,
        // with cp pointing into view slave and "this" flow layout and its elementOwner have 
        // nothing to do with it. Also, rp is set wrong in viewlinking case.
        // This function, because it can go across markups, should not
        // be on CFlowLayout. 
        // I commented this code during IE5.5 because it should not happen.
        // But it still happen in some weird situations so I'm adding Check().
        // We should be able to call "CFlowLayout::HitTestContent() from
        // here, or better yet, remove CFlowLayout::MovePointerToPointInternal totally because
        // it can be replaced at the point of call with CFlowLayout::HitTestContent()/MoveToCp pair.

        CheckSz(   cp >= 1 
                && cp < pMarkup->Cch(),
                "Please let Dmitry know ASAP if you see this assert firing! (dmitryt, x69876)");

        // (dmitryt, IE6) now I'm openeing this hack again because we hit this sometimes in stress.
        // It never happens in a debug code, some timing is involved. For now I reopen this and
        // hope someone will eventually be given time to implement a correct hittesting...
        
        if(pMarkup == GetContentMarkup())
        {
            LONG cpMin = GetContentFirstCp();
            LONG cpMax = GetContentLastCp();

            if( cp < cpMin )
            {
                cp = cpMin;
                rp.RpSetCp( cp , fPtNotAtBOL);
            }
            else if ( cp > cpMax )
            {
                cp = cpMax;
                rp.RpSetCp( cp , fPtNotAtBOL);
            }
        }

        fNotAtBOL = rp.RpGetIch() != 0;     // Caret OK at BOL if click
        fAtLogicalBOL = rp.RpGetIch() <= cchPreChars;
    }
    
    //
    // If we are positioned on a line that contains no text, 
    // then we should be at the beginning of that line
    //

    // TODO - Implement this in today's world

    //
    // Prepare results
    //
    
    if( pfNotAtBOL )
        *pfNotAtBOL = fNotAtBOL;

    if ( pfAtLogicalBOL )
        *pfAtLogicalBOL = fAtLogicalBOL;
    
    if( pfRightOfCp )
        *pfRightOfCp = fRightOfCp;

    hr = pPointer->MoveToCp( cp, pMarkup );
    if( hr )
        goto Error;
        
#if DBG == 1 // Debug Only

    //
    // Test that the pointer is in a valid position
    //
    
    {
        CTreeNode * pTst = pPointer->CurrentScope(MPTR_SHOWSLAVE);
        
        if( pTst )
        {
            if(  pTst->Element()->Tag() == ETAG_ROOT )
                TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- Root element "));
        }
        else
        {
            TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- current scope is null "));
        }
    }
#endif // DBG == 1 

    //
    // Scroll this point into view
    //
    
    if( fScrollIntoView && OK( hr ) )
    {

        //
        // TODO (Bug 13568 - ashrafm) - take the FlowLayout off of the ElemEditContext.
        //


        if ( pElemEditContext && pElemEditContext->GetFirstBranch() )
        {
            // $$ktam: Need layout context for pElemEditContext; where can we get it?
            CFlowLayout* pScrollLayout = NULL;        
            if ( pElemEditContext->HasMasterPtr() )
            {
                pScrollLayout = pElemEditContext->GetMasterPtr()->GetFlowLayout();
            }
            else
                pScrollLayout = pElemEditContext->GetFlowLayout();
                
            Assert( pScrollLayout );
            if ( pScrollLayout )
            {   
                if ( pScrollLayout != this )
                {
                    TransformPoint(&ptHit, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
                    pScrollLayout->TransformPoint(&ptHit, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
                }
                     
                {
                    //
                    // TODO (Bug 13568 - ashrafm): This scrolls the point into view - rather than the pointer we found
                    // unfotunately - scroll range into view is very jerky.
                    //
                    CRect r( ptHit.x - scrollSize, ptHit.y - scrollSize, ptHit.x + scrollSize, ptHit.y + scrollSize );            
                    pScrollLayout->ScrollRectIntoView( r, SP_MINIMAL, SP_MINIMAL );
                }
            }
        }
    }

    goto Cleanup;
    

Error:
    TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- Failed "));
    return( E_UNEXPECTED );
    
Cleanup:
    if ( pfValidLayout )
        *pfValidLayout = ( this == pContainingLayout );
        
    RRETURN(hr);
}

HRESULT
CFlowLayout::GetLineInfo(
    CMarkupPointer *pPointerInternal,
    BOOL fAtEndOfLine,
    HTMLPtrDispInfoRec *pInfo,
    CCharFormat const *pCharFormat )
{
    HRESULT hr = S_OK;
    POINT pt;
    CLinePtr   rp(GetDisplay());
    LONG cp = pPointerInternal->GetCp();
    CCalcInfo CI(this);
    BOOL fComplexLine;
    BOOL fRTLFlow;

    //
    // Query Position Info
    //
    
    if (-1 == _dp.PointFromTp( cp, NULL, fAtEndOfLine, FALSE, pt, &rp, TA_BASELINE, &CI, 
                                                      &fComplexLine, &fRTLFlow ))
    {
        /*
        //
        //  We should not return error because nobody is expecting this function 
        //  to fail with this return value!!!  Feed it with some valid information
        //  
        //  (zhenbinx)
        //  
        // 
            hr = OLE_E_BLANK;
            goto Cleanup;
        */
        CTreePos * ptp  = GetContentMarkup()->TreePosAtCp(cp, NULL, TRUE);
        Assert( ptp );
        pInfo->fRTLLine = ptp->GetBranch()->GetParaFormat()->HasRTL(TRUE);
        pInfo->fRTLFlow = pInfo->fRTLLine;

        pInfo->lXPosition           = 0;
        pInfo->lBaseline            = 0;

        pInfo->fAligned             = TRUE;
        pInfo->fHasNestedRunOwner   = FALSE;
        
        pInfo->lLineHeight          = 0;
        pInfo->lDescent             = 0;
        pInfo->lTextHeight          = 1;
        goto Cleanup;
    }

    pInfo->lXPosition = pt.x;
    pInfo->lBaseline = pt.y;
    pInfo->fRTLLine = rp->_fRTLLn;
    pInfo->fRTLFlow = fRTLFlow;
    pInfo->fAligned = ENSURE_BOOL( rp->_fHasAligned );
    pInfo->fHasNestedRunOwner = ENSURE_BOOL( rp->_fHasNestedRunOwner);
    
    Assert( ElementOwner()->Tag() != ETAG_ROOT );
    
    if( ElementOwner()->Tag() != ETAG_ROOT )
    {
        pInfo->lLineHeight = rp->_yHeight;
        pInfo->lDescent = rp.oi()->_yDescent;
        pInfo->lTextHeight = rp->_yHeight - rp.oi()->_yDescent;
    }
    else
    {
        pInfo->lLineHeight = 0;
        pInfo->lDescent = 0;
        pInfo->lTextHeight = 1;
    }

    //
    // try to compute true text height
    //
    {
        CCcs      ccs;
        const CBaseCcs *pBaseCcs;
        
        if (!fc().GetCcs(&ccs, CI._hdc, &CI, pCharFormat))
            goto Cleanup;

        pBaseCcs = ccs.GetBaseCcs();
        pInfo->lTextHeight = pBaseCcs->_yHeight;
        pInfo->lTextDescent = pBaseCcs->_yDescent;
        ccs.Release();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CFlowLayout::LineStart(
                       LONG *pcp, BOOL *pfNotAtBOL, BOOL *pfAtLogicalBOL, BOOL fAdjust )
{
    // ensure calculated view
    _dp.WaitForRecalc( *pcp, -1 );    
    LONG cpNew;
    LONG cchSkip;
    LONG cp = *pcp;
    CLineCore *pli;
    HRESULT hr = S_OK;
    CLinePtr rp(GetDisplay());
    rp.RpSetCp( cp , *pfNotAtBOL );
    
    cp = cp - rp.GetIch();
    pli = rp.CurLine();
    
    // Check that we are sane
    if( cp < 1 || cp >= _dp.GetMarkup()->Cch() )
    {
        hr = E_FAIL;
        goto Cleanup;            
    }

    if( fAdjust && pli )
    {
        // See comment for LineEnd()
        _dp.WaitForRecalc( max(min(cp + pli->_cch, GetContentLastCp()), 
                                         GetContentFirstCp()),
                                     -1 );
        // WaitForRecalc can cause the line array memory to be reallocated
        pli = rp.CurLine();

        if(pli)
        {
            rp.GetPdp()->FormattingNodeForLine(FNFL_STOPATGLYPH, cp, NULL, pli->_cch, &cchSkip, NULL, NULL);
        }
        else
        {
            cchSkip = 0;
        }

        cpNew = cp + cchSkip;
    }
    else
    {
        cpNew = cp;
    }
    
    *pfNotAtBOL = cpNew != cp;
    *pfAtLogicalBOL = TRUE;
    *pcp = cpNew;

Cleanup:
    RRETURN( hr );
}

HRESULT
CFlowLayout::LineEnd(
                     LONG *pcp, BOOL *pfNotAtBOL, BOOL *pfAtLogicalBOL, BOOL fAdjust )
{
    // ensure calculated view up to current position
    _dp.WaitForRecalc( *pcp, -1 );    
    CLineCore * pli;
    LONG cpLineBegin;
    LONG cp = *pcp;
    HRESULT hr = S_OK;
    CLinePtr rp(GetDisplay());
    rp.RpSetCp( cp , *pfNotAtBOL );
    
    cpLineBegin = cp - rp.GetIch();
    pli = rp.CurLine();

    if( pli != NULL )
    {
        // Compute min using GetContentLastCp() instead of GetContentLastCp() - 1
        // because the dirty range on the layout could begin on the last cp.
        // (IE #87036).
        _dp.WaitForRecalc( max(min(cpLineBegin + pli->_cch, GetContentLastCp()), 
                                         GetContentFirstCp()),
                                     -1 );    
        // WaitForRecalc can cause the line array memory to be reallocated
        pli = rp.CurLine();

        if( fAdjust )
            cp = cpLineBegin + rp.GetAdjustedLineLength();
        else
            cp = cpLineBegin + pli->_cch;
    }
    else
    {
        cp = cpLineBegin;
    }
    
    // Check that we are sane
    if( cp < 1 || cp >= _dp.GetMarkup()->Cch() )
    {
        hr = E_FAIL;
        goto Cleanup;       
    }
        
    *pfNotAtBOL = cp != cpLineBegin ;
    *pfAtLogicalBOL = cp == cpLineBegin;
    *pcp = cp;

Cleanup:
    RRETURN( hr );
}

HRESULT
CFlowLayout::MoveMarkupPointer(
    CMarkupPointer *    pPointerInternal,
    LONG                cp,
    LAYOUT_MOVE_UNIT    eUnit, 
    POINT               ptCurReally, 
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL)
{
    HRESULT hr = S_OK;
    BOOL fAdjusted = TRUE;

    switch (eUnit)
    {
        case LAYOUT_MOVE_UNIT_OuterLineStart:
            fAdjusted = FALSE;
            // fall through
        case LAYOUT_MOVE_UNIT_CurrentLineStart:
        {
            hr = THR( LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, fAdjusted) );
            if (hr)
                goto Cleanup;
                
            // move pointer to new position
            // Note: the markup to use can be a slave markup if the flow layout 
            //       is actually a viewlink master
            hr = pPointerInternal->MoveToCp(cp, ElementContent()->GetMarkup());
            break;
        }
        
       case LAYOUT_MOVE_UNIT_OuterLineEnd:
            fAdjusted = FALSE;
            // fall through
       case LAYOUT_MOVE_UNIT_CurrentLineEnd:
        {
            hr = THR( LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, fAdjusted) );
            if (hr)
                goto Cleanup;
                
            // move pointer to new position
            // Note: the markup to use can be a slave markup if the flow layout 
            //       is actually a viewlink master
            hr = pPointerInternal->MoveToCp(cp, ElementContent()->GetMarkup());
            break;
        }
        
        case LAYOUT_MOVE_UNIT_PreviousLine:
        case LAYOUT_MOVE_UNIT_PreviousLineEnd:
        {
            CLinePtr rp(GetDisplay());
            CFlowLayout *pFlowLayout = NULL;
            CElement *pElement;
            BOOL     fVertical;
            
            // Move one line up. This may cause the txt site to be different.

            if( !GetMultiLine() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            rp.RpSetCp( cp , *pfNotAtBOL );

            // TODO (Bug 13568 - ashrafm): why is this code here?

            if (ptCurReally.x <= 0)
                ptCurReally.x = 12;
            
            if (ptCurReally.y <= 0)
                ptCurReally.y = 12;

            pElement = ElementOwner();
            Assert(pElement);
            fVertical = pElement->HasVerticalLayoutFlow();
            pFlowLayout = _dp.MoveLineUpOrDown(NAVIGATE_UP, fVertical, rp, ptCurReally, &cp, pfNotAtBOL, pfAtLogicalBOL);
            if( !pFlowLayout)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            Assert( pFlowLayout );
            Assert( pFlowLayout->ElementContent() );
            Assert( pFlowLayout->ElementContent()->GetMarkup() );
            // Check that we are sane
            if( cp < 1 || cp >= pFlowLayout->ElementContent()->GetMarkup()->Cch() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }


            {
                CLinePtr rpNew(pFlowLayout->GetDisplay());
                rpNew.RpSetCp(cp, *pfNotAtBOL);

                if (rpNew.RpGetIch() == 0)
                    hr = THR(pFlowLayout->LineStart( &cp, pfNotAtBOL, pfAtLogicalBOL, TRUE ));
                else if (rpNew.RpGetIch() == rpNew->_cch)
                    hr = THR(pFlowLayout->LineEnd( &cp, pfNotAtBOL, pfAtLogicalBOL, TRUE ));
                if (hr)
                    goto Cleanup;
            }

            if( eUnit == LAYOUT_MOVE_UNIT_PreviousLineEnd )
            {
                hr = THR( pFlowLayout->LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE) );
                if( hr )
                    goto Cleanup;
            }
            
            // move pointer to new position
            //
            // IEV6-5393-2000/08/01-zhenbinx:
            // as of current design, CDisplay::MoveLineUpOrDown can cross layout. 
            // Since we are native frame now, that translated into moving into
            // differnt markup. So the cp we have should be in a the layout's
            // markup
            //
            // IEV6-8506-2000/08/12-zhenbinx
            // 
            // We should use the content markup instead of ElementOwner markup
            
            hr = pPointerInternal->MoveToCp(cp, pFlowLayout->ElementContent()->GetMarkup());
            break;
        }
        
        case LAYOUT_MOVE_UNIT_NextLine:
        case LAYOUT_MOVE_UNIT_NextLineStart:
        {
            CLinePtr rp(GetDisplay());
            CFlowLayout *pFlowLayout = NULL;
            CElement *pElement;
            BOOL     fVertical;
            
            // Move down line up. This may cause the txt site to be different.
            if( !GetMultiLine() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            rp.RpSetCp( cp , *pfNotAtBOL );

            // TODO (Bug 13568 - ashrafm): why is this code here?

            if (ptCurReally.x <= 0)
                ptCurReally.x = 12;
            
            if (ptCurReally.y <= 0)
                ptCurReally.y = 12;
            
            pElement = ElementOwner();
            Assert(pElement);
            fVertical = pElement->HasVerticalLayoutFlow();
            pFlowLayout = _dp.MoveLineUpOrDown(NAVIGATE_DOWN, fVertical, rp, ptCurReally, &cp, pfNotAtBOL, pfAtLogicalBOL);

            if( !pFlowLayout )
            {
                hr = E_FAIL;
                goto Cleanup;
            }                
            
            Assert( pFlowLayout );
            Assert( pFlowLayout->ElementContent() );
            Assert( pFlowLayout->ElementContent()->GetMarkup() );
            // Check that we are sane
            if( cp < 1 || cp >= pFlowLayout->ElementContent()->GetMarkup()->Cch() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            {
                CLinePtr rpNew(pFlowLayout->GetDisplay());
                rpNew.RpSetCp(cp, *pfNotAtBOL);

                if (rpNew.RpGetIch() == 0)
                    hr = THR(pFlowLayout->LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE));
                else if (rpNew.RpGetIch() == rpNew->_cch)
                    hr = THR(pFlowLayout->LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE));
                if (hr)
                    goto Cleanup;
            }
            
            if( eUnit == LAYOUT_MOVE_UNIT_NextLineStart )
            {
                hr = THR( pFlowLayout->LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE) );
                if( hr )
                    goto Cleanup;
            }
            
            // move pointer to new position
            //
            // IEV6-5393-2000/08/01-zhenbinx:
            // as of current design, CDisplay::MoveLineUpOrDown can cross layout. 
            // Since we are native frame now, that translated into moving into
            // differnt markup. So the cp we have should be in a the layout's
            // markup
            //
            // IEV6-8506-2000/08/12-zhenbinx
            // 
            // We should use the content markup instead of ElementOwner markup
            //
            //
            hr = pPointerInternal->MoveToCp(cp, pFlowLayout->ElementContent()->GetMarkup());

            break;
        }
        default:
            hr = E_NOTIMPL;
    }
Cleanup:
    RRETURN(hr);
}

BOOL
CFlowLayout::IsCpBetweenLines( LONG cp )
{
    // Clip incoming cp to content

    LONG cpMin = GetContentFirstCp();
    LONG cpMax = GetContentLastCp();
    
    if( cp < cpMin )
        cp = cpMin;
    if( cp >= cpMax )
        return TRUE;

    CLinePtr   rp1(GetDisplay());
    CLinePtr   rp2(GetDisplay());
    rp1.RpSetCp( cp , TRUE );
    rp2.RpSetCp( cp , FALSE );

    // if IRuns are different, then we are between lines
    return (rp1.GetIRun() != rp2.GetIRun() );
}

BOOL
CFlowLayout::GetFontSize(CCalcInfo * pci, SIZE * psizeFontForShortStr, SIZE * psizeFontForLongStr)
{
    BOOL fRet = FALSE;
    CCcs ccs;
    const CBaseCcs * pBaseCcs;

    fc().GetCcs(&ccs, pci->_hdc, pci, GetFirstBranch()->GetCharFormat());
    pBaseCcs = ccs.GetBaseCcs();
    
    if (pBaseCcs && pBaseCcs->HasFont())
    {
        if (psizeFontForShortStr)
        {
            psizeFontForShortStr->cx = pBaseCcs->_xMaxCharWidth;
            psizeFontForShortStr->cy = pBaseCcs->_yHeight;
        }
            
        if (psizeFontForLongStr)
        {
            psizeFontForLongStr->cx  = pBaseCcs->_xAveCharWidth;
            psizeFontForLongStr->cy  = pBaseCcs->_yHeight;
        }

        fRet = TRUE;
    }
    ccs.Release();

    return fRet;
}

BOOL
CFlowLayout::GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar)
{
    BOOL fRet = _dp.GetAveCharSize(pci, psizeChar);
    if (!fRet)
    {
        fRet = GetFontSize(pci, NULL, psizeChar);
    }
    return fRet;
}

//+====================================================================================
//
// Method:      AllowVScrollbarChange
//
// Synopsis:    Return FALSE if we need to recalc before adding/removing the scrollbar.
//
//-------------------------------------------------------------------------------------
BOOL
CFlowLayout::AllowVScrollbarChange(BOOL fVScrollbarNeeded)
{
    // If a vertical scrollbar needs to be added/removed and the element
    // has overflow-y:auto, then the content of the element needs to be
    // remeasured, after leaving room for the scrollbar.


    if (!_fNeedRoomForVScrollBar != !fVScrollbarNeeded)
    {
        CTreeNode * pNode = GetFirstBranch();

        if (pNode)
        {
            const CFancyFormat *    pFF         = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat *     pCF         = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            BOOL                    fVertical   = pCF->HasVerticalLayoutFlow();
            BOOL                    fWM         = pCF->_fWritingModeUsed;
            
            if (   !ForceVScrollbarSpace()
                && pFF->GetLogicalOverflowY(fVertical, fWM)==styleOverflowAuto)
            {
                _fNeedRoomForVScrollBar = fVScrollbarNeeded;

                // Can't directly call RemeasureElement() here! If we do that, and if we
                // are in the scope of EnsureView(), the Remeasure task added to the view
                // gets deleted before the task gets processed! Instead, we add this to
                // the event queue, and call Remeasure on it in the next EnsureView.
                // The use of STDPROPID_XOBJ_WIDTH as the dispid is arbitrary and can be
                // changed in the future with little impact. The only reason it got picked
                // was because width is somewhat related to size/measurement.
                Doc()->GetView()->AddEventTask(ElementOwner(), STDPROPID_XOBJ_WIDTH, 0);
                return FALSE;
            }
        }
    }
    return TRUE;
}

long
CFlowLayout::GetContentFirstCpForBrokenLayout()
{
    CLayoutContext *pLayoutContext = LayoutContext();
    
    if (   !pLayoutContext 
        || !pLayoutContext->ViewChain() )
    {
        // not a broken layout
        return GetContentFirstCp();
    }
    
    CLayoutBreak  *pLayoutBreak;

    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            return DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();
    }
    
    return GetContentFirstCp();
}

long
CFlowLayout::GetContentLastCpForBrokenLayout()
{
    CLayoutContext *pLayoutContext = LayoutContext();
    
    if (   !pLayoutContext 
        || !pLayoutContext->ViewChain() )
    {
        // not a broken layout
        return GetContentLastCp();
    }
    
    CLayoutBreak  *pLayoutBreak;

    pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            return DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();
    }
    
    return GetContentLastCp();
}

#if DBG
void
CFlowLayout::DumpLayoutInfo( BOOL fDumpLines )
{
    super::DumpLayoutInfo( fDumpLines );

    CloseDumpFile();

    if ( fDumpLines )
    {
        DumpLines();
    }

    InitDumpFile();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\fslyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       fslyt.cxx
//
//  Contents:   Implementation of CLegendLayout, CFieldSetLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FSLYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

MtDefine(CLegendLayout, Layout, "CLegendLayout")
MtDefine(CFieldSetLayout, Layout, "CFieldSetLayout")

const CLayout::LAYOUTDESC CLegendLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CLegendLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    GetDisplay()->SetWordWrap(FALSE);

    // Field Sets can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CLegendLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CParentInfo     PRI;
    long            lDefMargin;

    if (!ppri)
    {
        PRI.Init(this);
        ppri = &PRI;
    }
    lDefMargin = ppri->DeviceFromDocPixelsX(FIELDSET_CAPTION_OFFSET
                                            + FIELDSET_BORDER_OFFSET);

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    if (plLMargin)
    {
        *plLMargin += lDefMargin;
    }
    if (plRMargin)
    {
        *plRMargin += lDefMargin;
    }
}


void
CLegendLayout::GetLegendInfo(SIZE *pSizeLegend, POINT *pPosLegend)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode)
    {
        *pSizeLegend = pDispNode->GetApparentSize();
        *pPosLegend = pDispNode->GetPosition();
    }
    else
    {
        *pSizeLegend = g_Zero.size;
    }
}

void
CFieldSetLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CFieldSetElement *pElem = DYNCAST(CFieldSetElement, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
 
    Assert(pClientData);

    super::DrawClient(prcBounds, prcRedraw, pDispSurface, pDispNode, cookie, pClientData, dwFlags);

    if (DYNCAST(CFieldSetElement, ElementOwner())->GetLegendLayout() && !hTheme)
    {
        CBorderInfo bi;

        DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = TRUE;
        if (ElementOwner()->GetBorderInfo(pDI, &bi, TRUE) != DISPNODEBORDER_NONE)
        {
            long lBdrLeft= bi.aiWidths[SIDE_LEFT];

            // only draws the top border
            bi.wEdges = BF_TOP;
            bi.aiWidths[SIDE_LEFT] = 0;
            bi.aiWidths[SIDE_RIGHT] = 0;
            bi.aiWidths[SIDE_BOTTOM] = 0;

            if (bi.sizeCaption.cx > lBdrLeft)
            {
                bi.sizeCaption.cx -= lBdrLeft;
                bi.sizeCaption.cy -= lBdrLeft;
            }

            ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

            DrawBorder(pDI, &pDI->_rc, &bi);
        }
        DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = FALSE;
    }
}

void CFieldSetLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = TRUE;
    CFieldSetElement *pElem = DYNCAST(CFieldSetElement, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    if (hTheme)
    {
        XHDC    hdc    = pDI->GetDC(TRUE);
        CRect   rc(pDI->_rc);
        CSize   sizeOffset(g_Zero.size);
        CBorderInfo bi;
        CRect   rcLegend;
        int     iClipSaveKind = 0;
        int     iClipKind = RGN_ERROR;
        HRGN    hrgnClipLegend = 0;
        HRGN    hrgnFieldset = 0;
        BOOL    fRetVal;
        CLegendLayout *pLayoutLegend = pElem->GetLegendLayout();


        if (pLayoutLegend)
        { 
            pLayoutLegend->GetRect(&rcLegend, COORDSYS_PARENT);

            hrgnClipLegend  = CreateRectRgnIndirect(&rcLegend);
            hrgnFieldset    = CreateRectRgnIndirect(prcRedraw);

            if (hrgnClipLegend && hrgnFieldset)
            {
                CRegion rgnFieldset(hrgnFieldset);

                iClipSaveKind = hdc.GetClipRgn(hrgnFieldset);
                rgnFieldset.Subtract(hrgnClipLegend);
                iClipKind = hdc.SelectClipRgn(rgnFieldset.GetRegionForLook());
            }
        }

        Verify(pElem->GetBorderInfo(pDI, &bi, TRUE));

        rc.top += bi.offsetCaption;

        fRetVal = hdc.DrawThemeBackground(  hTheme,
                                            BP_GROUPBOX,
                                            0,
                                            &rc,
                                            NULL);

        if (RGN_ERROR != iClipKind)
        {
            if (iClipSaveKind == 1)
                hdc.SelectClipRgn(hrgnFieldset);
            else
                hdc.SelectClipRgn(NULL);
        }

        if (hrgnClipLegend)
        {
            ::DeleteRgn(hrgnClipLegend);
        }

        if (hrgnFieldset)
        {
            ::DeleteRgn(hrgnFieldset);
        }

        if (fRetVal == FALSE)
        {
            CBorderInfo     bi;

            pElem->_fDrawing = TRUE;
            Verify(pElem->GetBorderInfo(pDI, &bi, TRUE));
            pElem->_fDrawing = FALSE;

            ::DrawBorder(pDI, (RECT *)prcBounds, &bi);

        }
    }
    else
    {
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
    DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\hrlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       hrlyt.cxx
//
//  Contents:   Implementation of CHRLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_EHR_HXX_
#define X_EHR_HXX_
#include "ehr.hxx"
#endif

MtDefine(CHRLayout, Layout, "CHRLayout")
ExternTag(tagCalcSize);

const CLayout::LAYOUTDESC CHRLayout::s_layoutdesc =
{
    0, // _dwFlags
};

//+-------------------------------------------------------------------------
//
//  Method:     CHRLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------
#define MAX_HR_SIZE         100L // 100 pixels
#define MIN_HR_SIZE         1L   // 1 pixel
#define DEFAULT_HR_SIZE     2L
#define MIN_LEGAL_WIDTH     1L
#define MAX_HR_WIDTH        32000L

DWORD
CHRLayout::CalcSizeVirtual( CCalcInfo * pci,
                            SIZE      * psize,
                            SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CHRLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CSize           sizeOriginal;
    DWORD           grfReturn;

    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    // Handle sizing and min/max requests here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
       )
    {
        const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

        // First, calculate the correct width
        // (Treat missing widths as if this object is percentage-sized. While not precisely
        //  correct, since such HRs simply take on the size of their parent, it does ensure
        //  the parent container will recalc the HR when their own size changes.)
        const CUnitValue & cuvWidth = pFF->GetLogicalWidth(fVertical, fWritingModeUsed);
        CPeerHolder      * pPH = ElementOwner()->GetLayoutPeerHolder();
        POINT              pt;

        pt.x = pt.y = 0;

        //
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                             pPH, pci, *psize, &pt, psize);

            // now that we have the size, set the dispnode (below)
        }
        else
        {
            switch (pci->_smMode)
            {
            case SIZEMODE_MMWIDTH:
                psize->cx =
                psize->cy = (cuvWidth.IsNullOrEnum() || PercentWidth()
                                    ? MIN_LEGAL_WIDTH
                                    : min(cuvWidth.XGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvWidth)),
                                          (LONG)USHRT_MAX));

                break;

            case SIZEMODE_NATURAL:
            case SIZEMODE_NATURALMIN:
                {
                    LONG    cxParent;

                    // Always use the available space.  We used to use the parent's
                    // size in case of a percent width.  The old code looked as follows:
                    // cxParent = max(1L, (_fWidthPercent ? pci->_sizeParent.cx : psize->cx));
                    // This was changed because of compatibility issues explained in bug 22948.
                    // In either case, "pin" the value to greater than or equal to 1
                    cxParent = max(1L, psize->cx);

                    // If the user did not supply a value or it is wider than the parent, use parent's width
                    if (cuvWidth.IsNull())
                    {
                        psize->cx = cxParent;
                    }

                    // Otherwise, take value from the user settings
                    else
                    {
                        LONG cx = cuvWidth.XGetPixelValue(pci, cxParent, pNode->GetFontHeightInTwips(&cuvWidth));

                        // If less than zero, then "pin" to zero
                        // If greater than zero, use what the user specified
                        // If equal to zero, use zero if width is a percentage
                        //                   otherwise, use parent's width

                        if(cx < 0)
                            psize->cx = 0;
                        else if(cx > 0)
                        {
                            LONG  cxMax = pci->DeviceFromDocPixelsX(MAX_HR_WIDTH);
                            psize->cx = min(cx, cxMax);
                        }
                        else
                            psize->cx = 1;

                        // Finally, ensure the size does not exceed the maximum
                        LONG  cxMin = pci->DeviceFromDocPixelsX(MIN_LEGAL_WIDTH);
                        psize->cx = max(cxMin, psize->cx);
                    }
                }
                break;

            case SIZEMODE_MINWIDTH:
                psize->cx = (cuvWidth.IsNullOrEnum() || PercentWidth()
                                ? MIN_LEGAL_WIDTH
                                : cuvWidth.XGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvWidth)));
                break;

    #if DBG==1
            default:
                Assert(FALSE);
                break;
    #endif
            }

            // Then, for all but min/max modes, determine the correct height
            if (pci->_smMode != SIZEMODE_MMWIDTH)
            {
                const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVertical, fWritingModeUsed);

                // Determine the user specified height (if any) and the default height
                // (HR height can only be in pixels, so no need to pass the parent size)
                LONG    cyDefault = pci->DeviceFromDocPixelsY(DEFAULT_HR_SIZE);
                LONG    cy        = cuvHeight.YGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvHeight));

                // If less than the default, use the default size
                // Otherwise, "pin" to the maximum
                // NOTE: The calculated default can be less than DEFAULT_HR_SIZE
                //       when zooming is in effect. We must still "pin" to
                //       DEFAULT_HR_SIZE as the minimum height.
                // NOTE: Height is "pin'd" to a maximum here, rather than in the PDL,
                //       so we can accept sizes greater than DEFAULT_HR_SIZE

                if(cuvHeight.IsNull())
                    psize->cy = max(cyDefault, DEFAULT_HR_SIZE);
                else
                {
                    LONG    cyMin = pci->DeviceFromDocPixelsY(MIN_HR_SIZE);
                    if(cy < cyMin)
                       psize->cy = cyMin;
                    else
                    {
                        LONG    cyMax = pci->DeviceFromDocPixelsY(MAX_HR_SIZE);
                        if(cy > cyMax)
                            psize->cy = min(max(cy, DEFAULT_HR_SIZE), cyMax);
                        else
                            psize->cy = cy;
                    }
                }
            }

            // at this point the size has been computed, so try to delegate 
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, pci, *psize, &pt, psize);
            }
        }

        // Finally, set _sizeProposed (if appropriate)
        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
            {
                grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }

            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize);
            }

            //if there is a map size peer (like glow filter) that silently modifies the size of
            //the disp node, ask what the size is..
            if(HasMapSizePeer())
                GetApparentSize(psize);
        }
        else if(   pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH
               )
        {
            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = psize->cx;
                
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cy = psize->cx = rectMapped.Width();
                }
            }

            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CHRLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CHRLayout::Draw (CFormDrawInfo * pDI, CDispNode *)
{
    DrawRule(pDI,
             pDI->_rc,
             DYNCAST(CHRElement, ElementOwner())->GetAAnoShade(),
             GetFirstBranch()->GetCascadedcolor(LC_TO_FC(LayoutContext())),
             ElementOwner()->GetBackgroundColor());
}

//+---------------------------------------------------------------------------
//
//  Function:     DrawRule
//
//  Synopsis:   Draw the rule with specified parameters
//
//----------------------------------------------------------------------------

static HRESULT
DrawRule(CFormDrawInfo * pDI, const RECT &rc, BOOL fNoShade, const CColorValue &cvCOLOR, COLORREF colorBack)
{
    HGDIOBJ     hBrush = NULL;
    XHDC        hdc = pDI->GetDC(TRUE);
    HPEN        hOrigPen;

    int oneX = pDI->DeviceFromDocPixelsX(1);
    int oneY = pDI->DeviceFromDocPixelsY(1);

    Assert(!IsRectEmpty(&rc));

    // When a color value is specified the 3d effect must be off
    if(!fNoShade && cvCOLOR.IsDefined())
    {
        fNoShade = TRUE;
    }

    if(fNoShade)
    {
        HBRUSH      hOrigBrush;

        if(cvCOLOR.IsDefined())
        {
            Verify(hBrush = CreateSolidBrush(cvCOLOR.GetColorRef()));
        }
        else
        {
            Verify(hBrush = CreateSolidBrush(GetSysColorQuick(COLOR_3DSHADOW)));
        }

        if (hBrush)
        {
            hOrigBrush = (HBRUSH)SelectObject(hdc, hBrush);
            hOrigPen = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
            Rectangle(hdc, rc.left, rc.top, rc.right+oneX, rc.bottom+oneY);
            SelectObject(hdc, hOrigBrush);
            SelectObject(hdc, hOrigPen);
            DeleteObject(hBrush);
        }
    }
    else
    {
        // Draw the ruler with 3d effect
        COLORREF    lightColor;
        COLORREF    darkColor;
        if (   pDI->_pMarkup 
            && !pDI->_pMarkup->IsPrintMedia())
        {
            COLORREF colorBtnFace = GetSysColorQuick(COLOR_BTNFACE);

            darkColor = GetSysColorQuick(COLOR_3DSHADOW);
            // for IE3/Nav3 compatibility
            // If the background color is the same as the border
            // color, Nav3 choose a different color than ButtonFace
            // This is the case in WC3 test page.
            // we do the same thing here
            if ((colorBack & CColorValue::MASK_COLOR) == colorBtnFace)
            {
                lightColor = RGB(230, 230, 230);
            }
            else
            {
                lightColor = colorBtnFace;
            }
        }
        else
        {
            // When printing
            darkColor  = RGB(128, 128, 128);
            lightColor = RGB(0, 0, 0);
        }

        CRect rcr = rc;
        int height = pDI->DocPixelsFromDeviceY(rcr.Height());

        CBorderInfo bi;                     // site\base\csite.hxx
        bi.wEdges = height < 2 ? BF_TOP     // public\sdk\inc\winuser.h
                  : height > 2 ? BF_RECT
                  : BF_BOTTOM | BF_TOP;

        bi.abStyles[SIDE_TOP   ] =          // site\include\cfpf.hxx
        bi.abStyles[SIDE_RIGHT ] =
        bi.abStyles[SIDE_BOTTOM] =
        bi.abStyles[SIDE_LEFT  ] = fmBorderStyleSingle;  // core\include\cdutil.hxx

        bi.aiWidths[SIDE_TOP   ] =
        bi.aiWidths[SIDE_BOTTOM] = oneY;
        bi.aiWidths[SIDE_RIGHT ] =
        bi.aiWidths[SIDE_LEFT  ] = oneX;

        bi.acrColors[SIDE_TOP   ][0] =
        bi.acrColors[SIDE_LEFT  ][0] = darkColor;
        bi.acrColors[SIDE_RIGHT ][0] =
        bi.acrColors[SIDE_BOTTOM][0] = lightColor;

        DrawBorder(pDI, &rcr, &bi);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\framelyt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       frameset.cxx
//
//  Contents:   Implementation of CFrameSetLayout
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx" // needed for EVENTPARAM
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif


#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

enum XorYLoop { XDirection = 0, YDirection = 1, Terminate = 2 };

MtDefine(CFrameSetLayout, Layout, "CFrameSetLayout")
MtDefine(CFrameSetLayout_aryResizeRecords_pv, CFrameSetLayout, "CFrameSetLayout::_aryResizeRecords::_pv")
MtDefine(CFrameSetLayoutCalcPositions_aryPosX_pv, Locals, "CFrameSetLayout::CalcPositions aryPosX::_pv")
MtDefine(CFrameSetLayoutCalcPositions_aryPosY_pv, Locals, "CFrameSetLayout::CalcPositions aryPosY::_pv")

ExternTag(tagCalcSize);
ExternTag(tagLayoutTasks);

const CLayout::LAYOUTDESC CFrameSetLayout::s_layoutdesc =
{
    0,          // _dwFlags
};

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::CFrameSetLayout, public
//
//  Synopsis:   CFrameSetLayout ctor
//
//----------------------------------------------------------------------------
CFrameSetLayout::CFrameSetLayout (CElement * pElement, CLayoutContext *pLayoutContext) :
    CLayout(pElement, pLayoutContext),
    _aryResizeRecords(Mt(CFrameSetLayout_aryResizeRecords_pv))
{
};

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//              (See CLayout::CalcSize for details)
//
//--------------------------------------------------------------------------

DWORD
CFrameSetLayout::CalcSizeVirtual( CCalcInfo * pci,
                                  SIZE *      psize,
                                  SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFrameSetLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(FrameSetElement(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    DWORD           grfReturn;
    CLayoutContext *pLayoutContext = pci->GetLayoutContext();

    Assert(pci);
    Assert(psize);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    // CLayout::CalcSizeVirtual (called below) requires SizeThis to be set to update size.
    // I believe this won't impact perf, because it just causes a few minor extra calculations
    // in CLayout::CalcSizeVirtual (not exactly complicated or intensive).
    SetSizeThis(TRUE);

    // super::CSV is usually going to size the frameset to the sizePar in the
    // pci.  For top-level framesets, this is usually the host window size,
    // for nested framesets it's usually the containing frame's size.
    // If a frameset is contained inside a layout rect or iframe (which
    // can be thought of as always having an explicit size that is unaffected
    // by content), then it's up to those layouts to make sure they call
    // into CFrameSetLayout::CalcSize* with pci's sizePar set to their size.

    grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    if (    grfReturn & (LAYOUT_HRESIZE | LAYOUT_VRESIZE)           // FRAMESET size has changed
        ||  GetDirtyFramePositions()                        )       // Dirtied when the FRAME row/col array changes
    {

        Assert(pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_SET);
        CalcPositions(pci, *psize);
        SetDirtyFramePositions(FALSE);
    }

    // Framesets fire OnLayoutComplete when they finish calc'ing inside a context..
    // that would be now.
    if ( pLayoutContext && pLayoutContext != GUL_USEFIRSTLAYOUT )
        GetView()->AddEventTask( pLayoutContext->GetLayoutOwner()->ElementOwner(), DISPID_EVMETH_ONLAYOUTCOMPLETE );

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFrameSetLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::GetManualResizeTravel
//
//  Synopsis:   Search the manual resize records for one
//              that matches a particular edge
//
//--------------------------------------------------------------------------

int CFrameSetLayout::GetManualResizeTravel(BOOL fVerticalTravel, int iEdge)
{
    int i;
    ManualResizeRecord *pmrr = _aryResizeRecords;
    for (i = _aryResizeRecords.Size();
         i > 0;
         i--, pmrr++)
    {
        if (pmrr->fVerticalTravel == fVerticalTravel &&
            pmrr->iEdge == iEdge)
            return pmrr->iTravel;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::CancelManualResizeTravel
//
//  Synopsis:   Eliminate the manual resize record for
//              a particular edge
//
//--------------------------------------------------------------------------

BOOL CFrameSetLayout::CancelManualResize(BOOL fVerticalTravel)
{
    BOOL retVal = FALSE;
    int i;
    ManualResizeRecord *pmrr = _aryResizeRecords;
    for (i = _aryResizeRecords.Size();
         i > 0;
         i--, pmrr++)
    {
        if (pmrr->fVerticalTravel == fVerticalTravel)
        {
            if (pmrr->iTravel != 0)
            {
                retVal = TRUE;
                pmrr->iTravel = 0;
            }
        }
    }
    return retVal;
}

#define MIN_RESIZE_SIZE 10

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::CalcPositions, public
//
//  Synopsis:   Calculates the positions of all the embedded frames.
//
//  Arguments:  [pci]       -- Pointer to CCalcInfo
//              [sizeSet]   -- Size of the FRAMESET
//
//----------------------------------------------------------------------------

void
CFrameSetLayout::CalcPositions(
    CCalcInfo * pci,
    SIZE        sizeSet)
{
    CSaveCalcInfo   sci(pci);
    int             iFixedWidth; // Pixels used up by percentage or pixel values
    int             iSizeRel;    // Number of pixels for "relative-sized" values
                                 //  This value is the size of "1*". Also used
                                 //  if the sum of percentages and pixels is greater
                                 //  than the total available width.
    int             iSumPercents = 0;   // sum of pixel values from percent unit values

    XorYLoop        dir;
    int             i=0, j=0;

    CDataAry<CUnitValue> *paryValues; // Ptr to array of values parsed in Init2
    CUnitValue *          puv;        // Ptr to current value
    CDataAry<DWORD>       aryPosX(Mt(CFrameSetLayoutCalcPositions_aryPosX_pv));    // Array of X coordinates for frames
    CDataAry<DWORD>       aryPosY(Mt(CFrameSetLayoutCalcPositions_aryPosY_pv));    // Array of Y coordinates for frames
    CDataAry<DWORD>      *paryPos;    // Pointer to current coordinate array
    DWORD                 pos;        // Current position to be stored in array
    int                   cRel;       // Count of "relative-sized" values
    int                   cStar;      // Count of "*"'s (e.g. "2*" is 2)
    int                   iTotal;     // # of pixels representing 100%
    BOOL                  fAdjust;    // If TRUE, the sum of values is not
                                      //  equal to the total width and we must
                                      //  proportionately size-down or up the
                                      //  values
    int                   iFrameSpacing;  // value of the frameSpacing attribute
    int                   iTopDelta=0;    // amount of travel for the top edge
    int                   iLeftDelta=0;   // amount of travel for the left edge

    SIZE                  origSizeSet = sizeSet;     // original sizeSet
    DWORD_PTR             dw = 0;

    AssertSz( ElementOwner()->Tag() == ETAG_FRAMESET, "CFrameSetSiteLayout's owner must be a CFrameSetSite!" );
    CFrameSetSite *       pFSS = FrameSetElement();

    CDispContainer* pDispContainer = DYNCAST(CDispContainer, GetElementDispNode());

    //
    // No need to do anything if we don't have any sites yet.
    // (or if we are in low mem condition and didn't get our dispnode - IE6 18081)
    if (!ContainsChildLayout() || !pDispContainer)
        return;

    {
        // Reduce the amount of space available to dole out (sizeSet) by our own
        // border size.
        CBorderInfo borderInfo;

        if (FrameSetElement()->GetBorderInfo(pci, &borderInfo, FALSE, FALSE))
        {
            sizeSet.cx -= borderInfo.aiWidths[SIDE_RIGHT] + borderInfo.aiWidths[SIDE_LEFT];
            sizeSet.cy -= borderInfo.aiWidths[SIDE_TOP] + borderInfo.aiWidths[SIDE_BOTTOM];
        }

        // Now reduce the sizeSet by the amount of space to be taken up by
        // the framespacing.  This will cause the contained sites to be
        // positioned incorrectly (but with the right size!) -- this will get
        // fixed up when we actually tell the sites where they're positioned.
        iFrameSpacing = FrameSetElement()->GetFrameSpacing();
        if (iFrameSpacing > min(sizeSet.cx, sizeSet.cy))
           iFrameSpacing = min(sizeSet.cx, sizeSet.cy);

        if (FrameSetElement()->_aryCols.Size() > 1)
            sizeSet.cx -= iFrameSpacing * (FrameSetElement()->_aryCols.Size() - 1);
        if (FrameSetElement()->_aryRows.Size() > 1)
            sizeSet.cy -= iFrameSpacing * (FrameSetElement()->_aryRows.Size() - 1);
    }

    {
        // Now adjust the sizeSet by the amount of travel of the
        // top/left/bottom/right edges.  This amount will be reversed
        // later, after the distribution of space to the contained sites.
        // This can only happen when the frameset is nested within another
        // frameset which has moved one of our edges.

        int j;
        ManualResizeRecord *pmrr = _aryResizeRecords;
        for (j = _aryResizeRecords.Size();
             j > 0;
             j--, pmrr++)
        {
            if (pmrr->iEdge == 0 )
            {
                if (pmrr->fVerticalTravel)
                {
                    iTopDelta = pmrr->iTravel;
                    sizeSet.cy += iTopDelta;
                }
                else
                {
                    iLeftDelta = pmrr->iTravel;
                    sizeSet.cx += iLeftDelta;
                }
            }
            else if (pmrr->iEdge == pFSS->_iNumActualRows && pmrr->fVerticalTravel)
                sizeSet.cy -= pmrr->iTravel;
            else if (pmrr->iEdge == pFSS->_iNumActualCols && !pmrr->fVerticalTravel)
                sizeSet.cx -= pmrr->iTravel;
        }
    }

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        if (dir == XDirection)
        {
            paryValues = &(FrameSetElement()->_aryCols);
            paryPos    = &aryPosX;
            iTotal     = sizeSet.cx;
            pos        = 0;
        }
        else
        {
            paryValues = &(FrameSetElement()->_aryRows);
            paryPos    = &aryPosY;
            iTotal     = sizeSet.cy;
            pos        = 0;
        }

        iFixedWidth = 0;
        cRel        = 0;
        cStar       = 0;

        // Store the starting x or y position as the first element in the
        //  coordinate array.
        paryPos->AppendIndirect(&pos);

        // No need to do a bunch of calculations if there's 0 or 1 values
        if (paryValues->Size() <= 1)
        {
            iTotal += pos;
            paryPos->AppendIndirect((DWORD*)&iTotal);
            continue;
        }

        //
        // Compute the amount of space taken up by "fixed-sized" values
        // (percent or pixel values), and also the number of "relative-sized"
        // values that we must divide the remaining space between.
        //
        for (i=paryValues->Size(), puv = *paryValues;
             i > 0;
             i--, puv++)
        {
            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                cStar += puv->GetTimesRelative();
                cRel++;
            }
            else
            {
                long iPixel = puv->GetPixelValue(
                                        pci,
                                        ((dir == XDirection)
                                            ? CUnitValue::DIRECTION_CX
                                            : CUnitValue::DIRECTION_CY),
                                        iTotal);
                iFixedWidth += iPixel;
                if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT)
                {
                    iSumPercents += iPixel;
                }
            }
        }

        fAdjust = FALSE;

        if (cStar && (iFixedWidth < iTotal))
        {
            // We have relative-sized values, plus some space left over to give
            // them. Compute the size of "1*".
            //
            iSizeRel = (iTotal - iFixedWidth) / cStar;
        }
        else if (iFixedWidth != iTotal && iTotal >= 0)
        {
            // One of the following is true:
            //    - The sum of all "fixed-width" (percents and pixels) values
            //      is greater than our total space. Any relative-sized values
            //      in this case are given a size of zero.
            //    - The sum of all "fixed-width" values is less than our
            //      total available space and there are no "relative-sized"
            //      values.
            //
            // For both these cases, we must shrink or enlarge all regions by
            // a fixed amount to make them fit. iSizeRel is negative if
            // we're shrinking, and positive if we're enlarging.
            //
            Assert(cRel < paryValues->Size());

            iSizeRel = (iTotal - iFixedWidth) / (paryValues->Size() - cRel);
            fAdjust  = TRUE;
        }
        else
        {
            // The total of "fixed-width" values is exactly equal to the
            // window width. Any "relative-sized" values are given a size of
            // zero.
            //
            iSizeRel = 0;
        }

        //
        // Compute actual pixel positions and store them into the aryPos array
        //
        for (j=paryValues->Size(), puv = *paryValues;
             j > 0;
             j--, puv++)
        {
            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                if (!fAdjust)
                {
                    pos += puv->GetPixelValue(
                                     pci,
                                     ((dir == XDirection)
                                       ? CUnitValue::DIRECTION_CX
                                       : CUnitValue::DIRECTION_CY),
                                     iSizeRel);
                }
                // else preserve the previous value of "pos", giving this
                // relative-sized frame a dimension of zero.
            }
            else
            {
                int iPixelValue = puv->GetPixelValue(pci,
                                          ((dir == XDirection)
                                            ? CUnitValue::DIRECTION_CX
                                            : CUnitValue::DIRECTION_CY),
                                          iTotal);
                pos += iPixelValue;
                if (fAdjust)
                {
                    if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT ||
                        iSumPercents == 0)
                    {
                        // iRemainder is the total amount that needs
                        // to be adjusted (added or deleted)
                        long iRemainder = iTotal - iFixedWidth;

                        // our percentage is computed as follows:
                        // if there are > 0 "percentage" frames
                        //     our size divided by the sum of all percentage frames
                        // else
                        //     our size divided by the sum of all fixed width frames

                        long iAdjustment;

                        if (iSumPercents > 0)
                            iAdjustment = (iRemainder * iPixelValue) / iSumPercents;
                        else if (iFixedWidth > 0)
                            iAdjustment = (iRemainder * iPixelValue) / iFixedWidth;
                        else
                        {
                            // We haven't dolled anything out because there
                            // aren't any times-relative or fixed width.
                            // So, let's pretend that each of the "zeros"
                            // are divided evenly.
                            iAdjustment = iTotal / paryValues->Size();
                        }

                        pos += iAdjustment;
                    }
                }
            }

            paryPos->AppendIndirect(&pos);
        }
    }

    i = j = 0;

    //
    // Tweak the far-right and bottom pixel values to account for rounding
    // error by just setting them to the right and bottom of our rect.
    aryPosX[aryPosX.Size()-1] = sizeSet.cx;
    aryPosY[aryPosY.Size()-1] = sizeSet.cy;

    CDispNode * pDispNodeSibling = NULL;
    CDispNode * pDispNode;
    CPoint      pt;
    SIZE        size;

    i = -1;

    // Iterate through all contained sites and re-size all (if this site re-sized)
    // or those which requested re-sizing (themselves or a descendent)

    for (CLayout * pLayout = GetFirstLayout(&dw, FALSE, FALSE), *pPrevLayout = NULL;
        pLayout;
        pPrevLayout = pLayout, pLayout = GetNextLayout(&dw, FALSE, FALSE))
    {

        if (pLayout->ElementOwner()->_etag != ETAG_FRAME &&
            pLayout->ElementOwner()->_etag != ETAG_FRAMESET)
        {
            pLayout->SetYProposed(0);
            pLayout->SetXProposed(0);
            continue;
        }

        i++;
        if (i >= aryPosX.Size() - 1)
        {
            j++;
            i = 0;
        }

        if (j >= aryPosY.Size()-1)
        {
            // There's more <FRAME> tags than they gave values for.
            // Put it at (0,0) with zero width and height.
            pLayout->SetYProposed(0);
            pLayout->SetXProposed(0);
            size = g_Zero.size;
            pt   = g_Zero.pt;
        }
        else
        {
            Assert(i < aryPosX.Size()-1);

            pLayout->SetXProposed(aryPosX[i]);
            pLayout->SetYProposed(aryPosY[j]);
            size.cx = aryPosX[i+1] - pLayout->GetXProposed();
            size.cy = aryPosY[j+1] - pLayout->GetYProposed();


            // adjusted the origin for pLayout based on the amount
            // we reduced sizeSet above to compensate for frameSpacing
            pLayout->SetXProposed(pLayout->GetXProposed() + (i * iFrameSpacing));
            pLayout->SetYProposed(pLayout->GetYProposed() + (j * iFrameSpacing));
            pt.x = aryPosX[i] + (i * iFrameSpacing);
            pt.y = aryPosY[j] + (j * iFrameSpacing);
            {
                // Adjust the proposed pt and size for the current
                // size based on the manual resize records.  This
                // adjustment corresponds to the adjustment to the
                // sizeSet made up top.

                int iTravel;
                iTravel = GetManualResizeTravel(FALSE, i);
                if (iTravel != 0)
                {
                    // moving the left edge
                    pLayout->SetXProposed(pLayout->GetXProposed() + iTravel);
                    pt.x    += iTravel;
                    size.cx -= iTravel;
                }

                iTravel = GetManualResizeTravel(FALSE, i+1);
                if (iTravel != 0)
                {
                    // moving the right edge
                    size.cx += iTravel;
                }

                iTravel = GetManualResizeTravel(TRUE, j);
                if (iTravel != 0)
                {
                    // moving the top edge
                    pLayout->SetYProposed(pLayout->GetYProposed() + iTravel);
                    pt.y    += iTravel;
                    size.cy -= iTravel;
                }

                iTravel = GetManualResizeTravel(TRUE, j+1);
                if (iTravel != 0)
                {
                    // moving the bottom edge
                    size.cy += iTravel;
                }
                // if the top/left edge moved then we need
                // to shift things over by the amount they
                // moved.  this isn't a problem if the right/bottom
                // edges moved
                pLayout->SetYProposed(pLayout->GetYProposed() - iTopDelta);
                pLayout->SetXProposed(pLayout->GetXProposed() - iLeftDelta);
                pt.x -= iLeftDelta;
                pt.y -= iTopDelta;
                if (size.cx < 0 || size.cy < 0)
                {
                    // Check to see if we went negative.  This can
                    // happen if the user resized a frame to be small
                    // and then made the window smaller.
                    // For now just toss the resize info and recurse.
                    // It's possible we could do better.

                    if ( CancelManualResize(FALSE) || // cancelling horizontal
                         CancelManualResize(TRUE) )   // cancelling vertical
                    {
                        CalcPositions(pci, origSizeSet);
                        goto Cleanup;
                    }
#if !defined(WIN16) && !defined(WINCE) && DBG == 1
                    else
                    {
                        TCHAR buffer[100];
                        if (GetEnvironmentVariable(_T("NegativeFrameSizeDebug"),
                                                   buffer,
                                                   sizeof(buffer)/sizeof(buffer[0])))
                            DebugBreak();
                        TraceTag((tagWarning,
                                 "computed negative size for frame"));
                    }
#endif // !defined(WIN16) && !defined(WINCE)
                }
            }
        }

        pci->SizeToParent(&size);
        pLayout->CalcSize(pci, &size);
        pLayout->SetPosition(pt);

        pDispNode = pLayout->GetElementDispNode();

        if (pDispNode)
        {
            if (pDispNodeSibling)
            {
                if (pDispNodeSibling->GetNextSiblingNode() != pDispNode)
                {
                    GetView()->ExtractDispNode(pDispNode);
                    pDispNodeSibling->InsertSiblingNode(pDispNode, CDispNode::after);
                }
            }
            else
            {
                if (pDispContainer->GetFirstChildNode() != pDispNode)
                {
                    GetView()->ExtractDispNode(pDispNode);
                    DYNCAST(CDispContainer, GetElementDispNode())->InsertFirstChildInFlow(pDispNode);
                }
            }

            pDispNodeSibling = pDispNode;
        }
    }

    pFSS->_iNumActualRows = j+1;
    pFSS->_iNumActualCols = i+1;

Cleanup:
    ClearLayoutIterator(dw, FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::MaxTravelForEdge
//
//  Synopsis:   Determine the maximum travel for a resize of a particular
//              edge.  This requires us to look at the contained sites and,
//              if a contained site is a frameset we must recurse.
//
//-------------------------------------------------------------------------

BOOL CFrameSetLayout::MaxTravelForEdge(int iEdge, BOOL fVerticalTravel,
                                     int *pMinTravel, int *pMaxTravel)
{
    int iMaxTravel = INT_MAX;
    int iMinTravel = INT_MIN;

    int iHorz    = 0;
    int iVert    = 0;

    DWORD_PTR dw;

    for (CLayout *pLayout = GetFirstLayout(&dw, FALSE);
         pLayout;
         pLayout = GetNextLayout(&dw, FALSE))
    {
        CFrameSetLayout *pfss;
        CSize           size;

        pLayout->GetApparentSize(&size);

        switch (pLayout->ElementOwner()->_etag)
        {
        case ETAG_FRAMESET:
            pfss = DYNCAST(CFrameSetLayout, pLayout);
            break;

        case ETAG_FRAME:
            pfss = NULL;
            break;

        default:
            continue;
        }

        if (fVerticalTravel)
        {
            if (iVert == iEdge-1)
            {
                // motion limited upward by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(pfss->FrameSetElement()->_iNumActualRows,
                                                fVerticalTravel,
                                                &iMin,
                                                &iMax))
                        goto Retfalse;
                    iMinTravel = max(iMinTravel, iMin);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMinTravel = max(iMinTravel,
                                     min(0, (INT) -size.cy + MIN_RESIZE_SIZE));
                }
            }
            else if (iVert == iEdge)
            {
                // motion limited downward by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(0, fVerticalTravel,
                                           &iMin, &iMax))
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel, iMax);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel,
                                     max(0, (INT) size.cy - MIN_RESIZE_SIZE));
                }
            }
        }
        else
        {
            if (iHorz == iEdge-1)
            {
                // motion limited to the left by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(pfss->FrameSetElement()->_iNumActualCols,
                                           fVerticalTravel,
                                           &iMin,
                                           &iMax))
                        goto Retfalse;
                    iMinTravel = max(iMinTravel, iMin);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMinTravel = max(iMinTravel,
                                     min(0, (INT) -size.cx + MIN_RESIZE_SIZE));
                }
            }
            else if (iHorz == iEdge)
            {
                // motion limited to the right by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(0, fVerticalTravel,
                                           &iMin, &iMax))
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel, iMax);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel,
                                     max(0, (INT) size.cx - MIN_RESIZE_SIZE));
                }
            }
        }
        if (++iHorz == FrameSetElement()->_iNumActualCols)
        {
            iHorz = 0;
            iVert++;
        }
    }
    ClearLayoutIterator(dw, FALSE);
    if (pMaxTravel)
        *pMaxTravel = iMaxTravel;
    if (pMinTravel)
        *pMinTravel = iMinTravel;
    return TRUE;
    
Retfalse:
    ClearLayoutIterator(dw, FALSE);
    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::GetResizeInfo
//
//  Synopsis:   Record information about where the user clicked so that
//              subsequent mouse moves can do the appropriate resizing
//
//-------------------------------------------------------------------------

BOOL CFrameSetLayout::GetResizeInfo(POINT pt, FrameResizeInfo *pFRI)
{
    DWORD_PTR   dw;
    BOOL        retVal   = FALSE;
    CLayout    *pPrev    = NULL;
    CLayout    *pLayout  = GetFirstLayout(&dw, FALSE);
    int         iHorz    = 0;
    int         iVert    = 0;

    pFRI->vertical.iEdge = pFRI->horizontal.iEdge = -1;

    while (pLayout) {

        if (pLayout->ElementOwner()->_etag != ETAG_FRAMESET &&
            pLayout->ElementOwner()->_etag != ETAG_FRAME)
            goto next;

        if (pPrev)
        {
            CRect   rcPrev;
            CRect   rcCurr;

            pPrev->GetRect(&rcPrev, COORDSYS_GLOBAL);
            pLayout->GetRect(&rcCurr, COORDSYS_GLOBAL);
            InflateRect(&rcPrev, -2, -2);
            InflateRect(&rcCurr, -2, -2);

            //TODO (lmollico): Is -2 the size of the border?

            if (rcPrev.top == rcCurr.top)
            {
                // checking horizinally at this point
                iHorz++;
                if (pFRI->horizontal.iEdge == -1) // once is enough
                {
                    if (pt.x >= rcPrev.right && pt.x <= rcCurr.left)
                    {
                        if (MaxTravelForEdge(iHorz,
                                             FALSE,
                                             &pFRI->horizontal.iMinTravel,
                                             &pFRI->horizontal.iMaxTravel))
                        {
                            pFRI->horizontal.iEdge = iHorz;
                            pFRI->horizontal.rcEdge.top    = rcPrev.top;
                            pFRI->horizontal.rcEdge.left   = rcPrev.right;
                            pFRI->horizontal.rcEdge.right  = rcCurr.left;
                            pFRI->horizontal.rcEdge.bottom = rcCurr.bottom;
                          //  InflateRect(&pFRI->horizontal.rcEdge, -2, 0);
                            retVal = TRUE;
                        }
                    }
                }
            }
            else
            {
                // checking vertically at this point
                iHorz = 0;
                iVert++;
                if (pFRI->vertical.iEdge == -1) // once is enough
                {
                    if (pt.y >= rcPrev.bottom && pt.y <= rcCurr.top)
                    {
                        if (MaxTravelForEdge(iVert,
                                             TRUE,
                                             &pFRI->vertical.iMinTravel,
                                             &pFRI->vertical.iMaxTravel))
                        {
                            pFRI->vertical.iEdge = iVert;
                            pFRI->vertical.rcEdge.top    = rcPrev.bottom;
                            pFRI->vertical.rcEdge.left   = rcPrev.left;
                            pFRI->vertical.rcEdge.right  = rcCurr.right;
                            pFRI->vertical.rcEdge.bottom = rcCurr.top;
                            //InflateRect(&pFRI->vertical.rcEdge, 0, -2);
                            retVal = TRUE;
                        }
                    }
                }
            }
//#define MULTI_DIRECTIONAL_RESIZING
#ifndef MULTI_DIRECTIONAL_RESIZING
            if (retVal)
                goto Cleanup;
#endif
        }
        pPrev = pLayout;

    next:

        pLayout = GetNextLayout(&dw, FALSE);

    }
Cleanup:
    ClearLayoutIterator(dw, FALSE);
    return retVal;
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetLayout::Resize
//
//  Synopsis:   Resizes the contained sites based on a
//              ManualResizeRecord
//
//---------------------------------------------------------------

void CFrameSetLayout::Resize(const ManualResizeRecord *pmr)
{
    // Process, as follows:
    // (1) if we've moved this edge before, then merge this into the previous
    // (2) record this ManualResize object to be used in CalcPositions
    // (3) determine whether the edge in question borders another FrameSet
    //     and if so, propagate this change down to it
    // (4) in CalcPositions()
    //    a. take the SizeSet and adjust it according to those edge
    //       MR's which effect the left/right/top/bottom edges only
    //    b. proceed as normal, allocating the space to the children
    //    c. process the recorded MR's as follows:
    //         abuts the edge being processed.  note that this may not
    //       - adjust the size/position of all children whose rect
    //         be totally possible if things have shrunk due to the window
    //         having been made smaller (what to do?)

    ManualResizeRecord mr = *pmr;
    if (mr.iEdge == -1)
        mr.iEdge = mr.fVerticalTravel ? FrameSetElement()->_iNumActualRows : FrameSetElement()->_iNumActualCols;

    int i = _aryResizeRecords.Size();
    ManualResizeRecord *pMRList = _aryResizeRecords;
    while (--i >= 0)
    {
        if (pMRList->iEdge == mr.iEdge && pMRList->fVerticalTravel == mr.fVerticalTravel)
        {
            pMRList->iTravel += mr.iTravel;
            break;
        }
        pMRList++;
    }
    if (i == -1)
    {
        _aryResizeRecords.AppendIndirect(&mr);
    }

    DWORD_PTR dw;
    CLayout *pLayout = GetFirstLayout(&dw, FALSE);
    int iHorz = 0;
    int iVert = 0;

    while (pLayout)
    {
        CFrameSetLayout *pfss;

        switch (pLayout->ElementOwner()->_etag)
        {
        case ETAG_FRAMESET:
            pfss = DYNCAST(CFrameSetLayout, pLayout);
            break;

        case ETAG_FRAME:
            pfss = NULL;
            break;

        default:
            goto next;
        }

        if (pfss)
        {
            BOOL fDoit = FALSE;
            ManualResizeRecord mrTmp;
            if ( (mr.iEdge == iVert &&  mr.fVerticalTravel) ||
                 (mr.iEdge == iHorz && !mr.fVerticalTravel) )
            {
                mrTmp = mr;
                mrTmp.iEdge = 0;
                fDoit = TRUE;
            }
            else if ( (mr.iEdge-1 == iVert &&  mr.fVerticalTravel) ||
                      (mr.iEdge-1 == iHorz && !mr.fVerticalTravel) )
            {
                mrTmp = mr;
                mrTmp.iEdge = -1;
                fDoit = TRUE;
            }
            if (fDoit)
            {
                pfss->Resize(&mrTmp);  // recurse
            }
        }
        if (++iHorz == FrameSetElement()->_iNumActualCols)
        {
            iHorz = 0;
            iVert++;
        }

    next:

        pLayout = GetNextLayout(&dw, FALSE);
    }

    ClearLayoutIterator(dw, FALSE);

    SetDirtyFramePositions(TRUE);
    ElementOwner()->ResizeElement();
}


//+--------------------------------------------------------------
//
//  Function:   ResizeWndProc
//
//  Synopsis:   Window proc for the window which is displayed
//              during frame resizing
//
//---------------------------------------------------------------

LRESULT CALLBACK
ResizeWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_PAINT:
        {
            HBRUSH hbr = (HBRUSH)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            FillRect(ps.hdc, &ps.rcPaint, hbr);
            EndPaint(hwnd, &ps);
        }
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+--------------------------------------------------------------
//
//  Function:   CreateDitherBrush
//
//  Synopsis:   Used for drawing the resize bar
//
//  Notes:      stolen from ie3 which stole it from comctl132
//
//+--------------------------------------------------------------

static HBRUSH CreateDitherBrush(void)
{
    HBRUSH  hbrDitherBrush = NULL;
    HBITMAP hbmTemp;
    static WORD graybits[] = {0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555};

    // build the dither brush.  this is a fixed 8x8 bitmap
    hbmTemp = CreateBitmap(8, 8, 1, 1, graybits);
    if (hbmTemp)
    {
        // now use the bitmap for what it was really intended...
        hbrDitherBrush = CreatePatternBrush(hbmTemp);
        DeleteObject(hbmTemp);
    }

    return( hbrDitherBrush );
}

void
CFrameSetLayout::AdjustFrameSize(CDataAry<CUnitValue> * paryValues,
                                 CDataAry<long> *       paryPos,
                                 long                   lSum)
{
    Assert(paryValues->Size() >= paryPos->Size()); 

    for (int i = 0; i < paryValues->Size(); i++)
    {
        CUnitValue::UNITVALUETYPE uvType = (*paryValues)[i].GetUnitType();
    
        if (uvType == CUnitValue::UNIT_PERCENT || uvType == CUnitValue::UNIT_TIMESRELATIVE)
        {
            (*paryValues)[i].SetPercent(MulDivQuick((*paryPos)[i], 100, lSum));
        }
        else
        {
            (*paryValues)[i].SetValue((*paryPos)[i], CUnitValue::UNIT_PIXELS);
        }
    }

}

void
CFrameSetLayout::CalcRowsCols(int iVerticalEdge, int iHorizontalEdge)
{
    HRESULT                 hr;
    DWORD_PTR               dw = 0;
    CLayout *               pLayout;
    CSize                   size;
    CFrameSetSite *         pFrameSetElement = FrameSetElement();
    CDataAry<long>          aryPosX(Mt(CFrameSetLayoutCalcPositions_aryPosX_pv));
    CDataAry<long>          aryPosY(Mt(CFrameSetLayoutCalcPositions_aryPosY_pv));
    CDataAry<long> *        paryPos;
    CDataAry<CUnitValue> *  paryValues;
    CUnitValue *            puv;
    long                    lSumX = 0;
    long                    lSumY = 0;
    long                    lSum;
    int                     i;
    XorYLoop                dir;
    TCHAR                   ach[256];
    int                     iEdge;

    if (pFrameSetElement->GetAAcols() && pFrameSetElement->GetAArows()) // (lmollico): not supported yet
        goto Cleanup;

    for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
    {
        pLayout->GetSize(&size);
        aryPosX.AppendIndirect(&size.cx);
        aryPosY.AppendIndirect(&size.cy);
        lSumX += size.cx;
        lSumY += size.cy;
    }

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        CStr cstrRowsCols;

        if (dir == XDirection)
        {
            paryValues = &pFrameSetElement->_aryColsResize;
            paryPos = &aryPosX;
            lSum = lSumX;
            iEdge = iHorizontalEdge;
        }
        else
        {
            paryValues = &pFrameSetElement->_aryRowsResize;
            paryPos = &aryPosY;
            lSum = lSumY;
            iEdge = iVerticalEdge;
        }

        if (iEdge == -1)
            continue;

/* (dmitryt) If we move bar between to 'n*'-sized frames, why shouldn't we 
             convert both of them into percent-sized? If we only do it with the first,
             then the 'n*'-sized neighbour should be raclculated to reflect
             updated width available to all 'n*'-sized to share...

             Now, we only update sizes of frames adjacent to a bar that user is dragging.
             We don't recalc all frames to re-distribute width between them.
             So we have to convert both adjacent frames to non-automatic (non 'n*'-sized)
             to be visually consistent.

             IE6 bug 16127

        if (    (*paryValues)[iEdge - 1].GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE
            &&  (*paryValues)[iEdge    ].GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
        {
            AdjustFrameSize(paryValues, iEdge - 1, iEdge - 1, paryPos, lSum);
        }
        else
*/        
        if (iEdge < paryValues->Size())
            AdjustFrameSize(paryValues, paryPos, lSum);

        for (i = paryValues->Size(), puv = *paryValues;
             i > 0;
             i--, puv++)
        {
            if (cstrRowsCols.Length())
            {
                hr = cstrRowsCols.Append(_T(","));
                if (hr)
                    goto Cleanup;
            }

            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                hr = cstrRowsCols.Append(_T("*"));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT)
                    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>%"), puv->GetPercent());
                else
                    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), puv->GetPixelValue());
                if (hr)
                    goto Cleanup;

                hr = cstrRowsCols.Append(ach);
                if (hr)
                    goto Cleanup;
            }
        }

        if (dir == XDirection)
            hr = pFrameSetElement->SetAAcols(cstrRowsCols);
        else
            hr = pFrameSetElement->SetAArows(cstrRowsCols);
        if (hr)
            goto Cleanup;
    }

    Doc()->_lDirtyVersion = MAXLONG;

Cleanup:
    ClearLayoutIterator(dw, FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetLayout::HandleMessage
//
//  Synopsis:   Handle the resizing of frames.  Otherwise, pass
//              it to super.
//
//  Notes:      This method uses a number of static variables
//              making it non-thread-safe.  Presumably this won't
//              be an issue since there's only one mouse.
//
//---------------------------------------------------------------

HRESULT BUGCALL
CFrameSetLayout::HandleMessage(CMessage * pMessage)
{
    static FrameResizeInfo s_fri;
    static BOOL s_fResizing = FALSE;
    static POINT s_ptMouseDown;
    static POINT s_ptPrevious;
    static POINT s_ptOrigin;
    static SIZE  s_size;
    static HBRUSH s_hbrOld;
    static HDC s_hdcScreen;
    HRESULT  hr = S_FALSE;

    BOOL fDynamicResize = FALSE;
#ifndef WINCE
    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &fDynamicResize, 0);
#endif // WINCE

    switch (pMessage->message)
    {
        case WM_LBUTTONDOWN:
            if (GetResizeInfo(pMessage->pt, &s_fri))
            {
                FrameSetElement()->TakeCapture(TRUE);
                s_fResizing = TRUE;
                // hang on to this so we know
                // how far we've moved
                s_ptPrevious = s_ptMouseDown = pMessage->pt;

                if (!fDynamicResize)
                {
                    // compute the position, in screen coordinates, of the
                    // resize bar.  then draw it.  subsequent 'move' events
                    // will cause the previous location to be inverted
                    // and the new location to be redrawn (inverted)

                    RECT rc = s_fri.vertical.iEdge == -1 ? s_fri.horizontal.rcEdge
                                                     : s_fri.vertical  .rcEdge;
                    s_ptOrigin.x = rc.left;
                    s_ptOrigin.y = rc.top;
                    s_size.cx  = rc.right - rc.left;
                    s_size.cy  = rc.bottom - rc.top;

                    ClientToScreen(Doc()->_pInPlace->_hwnd, &s_ptOrigin);
                    s_hdcScreen = ::GetDC(NULL);
                    s_hbrOld = (HBRUSH)SelectObject(s_hdcScreen, CreateDitherBrush());
                    if (s_hbrOld)
                    {
                        PatBlt(s_hdcScreen, s_ptOrigin.x,
                               s_ptOrigin.y,
                               s_size.cx,
                               s_size.cy,
                               PATINVERT);
                    }
                    else
                        hr = E_FAIL;
                }
                hr = S_OK;
            }
            break;

        case WM_LBUTTONUP:
        case WM_KILLFOCUS:
            if (s_fResizing)
            {
                if (!fDynamicResize)
                {
                    // undo the last inversion
                    if (s_hbrOld)
                    {
                        PatBlt(s_hdcScreen, s_ptOrigin.x,
                               s_ptOrigin.y,
                               s_size.cx,
                               s_size.cy,
                               PATINVERT);

                        // put back the old brush and delete the current,
                        // temporary, one
                        DeleteObject(SelectObject(s_hdcScreen, s_hbrOld));
                    }

                    if (s_fri.vertical.iEdge != -1)
                    {
                        FrameResizeInfo1 *frr1 = &s_fri.vertical;

                        int iTravel = pMessage->pt.y - s_ptMouseDown.y;
                        iTravel = min(iTravel, frr1->iMaxTravel);
                        iTravel = max(iTravel, frr1->iMinTravel);

                        ManualResizeRecord mrr = { (SHORT)iTravel, (SHORT)frr1->iEdge, TRUE };
                        Resize(&mrr);
                    }
                    if (s_fri.horizontal.iEdge != -1)
                    {
                        FrameResizeInfo1 *frr1 = &s_fri.horizontal;

                        int iTravel = pMessage->pt.x - s_ptMouseDown.x;
                        iTravel = min(iTravel, frr1->iMaxTravel);
                        iTravel = max(iTravel, frr1->iMinTravel);

                        ManualResizeRecord mrr = { (SHORT)iTravel, (SHORT)frr1->iEdge, FALSE };
                        Resize(&mrr);
                    }

                    FrameSetElement()->WaitForRecalc();
                }

                FrameSetElement()->TakeCapture(FALSE);

                s_fResizing = FALSE;
                // allow WM_KILLFOCUS to bubble up to the root
                if (pMessage->message != WM_KILLFOCUS)
                {
                    hr = S_OK;
                }

                CalcRowsCols(s_fri.vertical.iEdge, s_fri.horizontal.iEdge);
            }
            break;

        case WM_SETCURSOR:
            if (!s_fResizing)
            {
                if (GetResizeInfo(pMessage->pt, &s_fri))
                {
                    LPCTSTR idcResize = NULL;
                    if (   s_fri.vertical.iEdge != -1
                        && s_fri.horizontal.iEdge != -1)
                        idcResize = IDC_SIZEALL;
                    else if ( s_fri.vertical.iEdge != -1 )
                        idcResize = IDC_SIZENS;
                    else if ( s_fri.horizontal.iEdge != -1 )
                        idcResize = IDC_SIZEWE;

                    FrameSetElement()->SetCursorStyle(idcResize);
                }
                else
                {
                    FrameSetElement()->SetCursorStyle(IDC_ARROW);
                }
            }
            hr = S_OK;
            break;

#ifndef WIN16
        case WM_MOUSEWHEEL:
            {
                CLayout *   pLayout;
                DWORD_PTR   dw;
                CDoc *      pDoc    = Doc();

                // NEWTREE  MonsterWalk should build these site arrays
                //          with branches instead of sites

                for (pLayout = GetFirstLayout(&dw, FALSE); pLayout;
                                pLayout = GetNextLayout(&dw, FALSE))
                {   
                    // Two cases:
                    //
                    // 1) _pElemCurrent is _pSiteRoot or the current frameset site,
                    //    in this case, need to check all child sites, be it
                    //    CFrameSetSite or CFrameElement.
                    // 2) _pElemCurrent is one of the child site, HandleMessage is
                    //    called up through the parent chain from _pElemCurrent, no
                    //    need to pass down to _pElemCurrent again to avoid
                    //    potential infinite call chain.
                    //
                    if (pLayout->ElementOwner() != pDoc->_pElemCurrent)
                    {
                        // Call HandleMessage directly because we do not bubbling here
                        hr = THR(pLayout->ElementOwner()->HandleMessage(pMessage));
                        if (hr != S_FALSE)
                            break;
                    }
                }
                ClearLayoutIterator(dw, FALSE);
            }
            break;
#endif // ndef WIN16

        case WM_MOUSEMOVE:
            if (s_fResizing)
            {
				// the following code causes the screen resize/update to
                // occur during the mouse drag operation rather than at
                // the mouse up.

                if (!fDynamicResize)
                    PatBlt(s_hdcScreen, s_ptOrigin.x,
                                        s_ptOrigin.y,
                                        s_size.cx,
                                        s_size.cy,
                                        PATINVERT);

                POINT pt = pMessage->pt;
                if (s_fri.vertical.iEdge != -1)
                {
                    FrameResizeInfo1 *frr1 = &s_fri.vertical;

                    pt.y = min((LONG)pt.y, (LONG)(s_ptMouseDown.y + frr1->iMaxTravel));
                    pt.y = max((LONG)pt.y, (LONG)(s_ptMouseDown.y + frr1->iMinTravel));

                    s_ptOrigin.y += pt.y - s_ptPrevious.y;

                    if (fDynamicResize)
                    {
                        ManualResizeRecord mrr = { (SHORT)(pt.y - s_ptPrevious.y),
                                                   (SHORT)(frr1->iEdge),
                                                   TRUE };
                        Resize(&mrr);
                    }
                }
                if (s_fri.horizontal.iEdge != -1)
                {
                    FrameResizeInfo1 *frr1 = &s_fri.horizontal;

                    pt.x = min((LONG)pt.x, (LONG)(s_ptMouseDown.x + frr1->iMaxTravel));
                    pt.x = max((LONG)pt.x, (LONG)(s_ptMouseDown.x + frr1->iMinTravel));

                    s_ptOrigin.x += pt.x - s_ptPrevious.x;

                    if (fDynamicResize)
                    {
                        ManualResizeRecord mrr = { (SHORT)(pt.x - s_ptPrevious.x),
                                                   (SHORT)(frr1->iEdge),
                                                   FALSE };
                        Resize(&mrr);
                    }
                }
                s_ptPrevious = pt;

                if (!fDynamicResize)
                {
                    PatBlt(s_hdcScreen, s_ptOrigin.x,
                                        s_ptOrigin.y,
                                        s_size.cx,
                                        s_size.cy,
                                        PATINVERT);
                }
                hr = S_OK;
            }
            break;

    }

    if (hr == S_FALSE)
    {
        hr = THR(super::HandleMessage(pMessage));
    }

    RRETURN1(hr, S_FALSE);
}

int CFrameSetLayout::iPixelFrameHighlightWidth = 0;
int CFrameSetLayout::iPixelFrameHighlightBuffer = 0;

//+----------------------------------------------------------------------------
//
// Member: CheckFrame3DBorder
//
// Synopsis: Based on current 3D border setting b3DBorder, determine which
//           extra 3D border edges are needed for pDoc, which can be a CDoc
//           inside one of the CFrameElement in this CFrameSetLayout
//
//-----------------------------------------------------------------------------
BOOL
CFrameSetLayout::CheckFrame3DBorder(CWindow * pWindow, BYTE b3DBorder)
{
    int  cRows   = max(FrameSetElement()->_aryRows.Size(), 1);
    int  cCols   = max(FrameSetElement()->_aryCols.Size(), 1);
    int  iRow    = 0;
    int  iCol    = 0;
    BOOL fResult = FALSE;

    DWORD_PTR         dw;
    BYTE              b3DBorderCurrent;
    CLayout       *   pLayout;
    CFrameElement *   pFrame;
    CWindow       *   pWindowCurrent;

    CDocInfo          DCIFrameSet(FrameSetElement());
    CBorderInfo       borderinfo;
    int               iBorderWidthMin;

    // need to exclude those 3D border drawn by outmost CFrameSetLayout
    //
    if (    FrameSetElement()->IsInMarkup()
        &&  FrameSetElement() == FrameSetElement()->GetMarkup()->GetElementClient() )
    {
        iBorderWidthMin = 2;
        FrameSetElement()->GetMarkup()->GetCanvasElement()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE);
    }
    else
    {
        iBorderWidthMin = 0;
        FrameSetElement()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE);
    }

    // if there is extra border space (top/left/bottom/right) needed for
    // CFrameSetLayout, need to draw 3D border edge for them
    //
    if (borderinfo.aiWidths[SIDE_TOP] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_TOP;
    }
    if (borderinfo.aiWidths[SIDE_LEFT] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_LEFT;
    }
    if (borderinfo.aiWidths[SIDE_BOTTOM] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_BOTTOM;
    }
    if (borderinfo.aiWidths[SIDE_RIGHT] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_RIGHT;
    }

    // loop through all CFrameElement and CFrameSetLayout inside current
    // CFrameSetLayout until we find pDoc
    //
    for (pLayout = GetFirstLayout(&dw, FALSE);
            pLayout && !fResult;
            pLayout = GetNextLayout(&dw, FALSE))
    {
        ELEMENT_TAG eTag = (ELEMENT_TAG) pLayout->ElementOwner()->_etag;

        pWindowCurrent = NULL;

        switch (eTag)
        {
        case ETAG_FRAME:
            pFrame = DYNCAST(CFrameElement, pLayout->ElementOwner());
            break;
        case ETAG_FRAMESET:
            pFrame = NULL;
            break;
        default:
            continue;
        }

        if (pFrame)
        {
            pWindowCurrent = pFrame->_pWindow ? pFrame->_pWindow->Window() : NULL;
        }

        if (eTag == ETAG_FRAMESET || pWindow == pWindowCurrent)
        {
            b3DBorderCurrent = b3DBorder;

            // If we are not the first row and there are more than one rows,
            // we should need to draw top 3D border edge
            //
            if ((iRow != 0) && (cRows > 1))
                b3DBorderCurrent |= NEED3DBORDER_TOP;

            // If we are not the last row and there are more than one rows,
            // we should need to draw bottom 3D border edge
            //
            if ((iRow != cRows - 1) && (cRows > 1))
                b3DBorderCurrent |= NEED3DBORDER_BOTTOM;

            // If we are not the first column and there are more than one
            // columns, we should need to draw left 3D border edge
            //
            if ((iCol != 0) && (cCols > 1))
                b3DBorderCurrent |= NEED3DBORDER_LEFT;

            // If we are not the first column and there are more than one
            // columns, we should need to draw right 3D border edge
            //
            if ((iCol != cCols - 1) && (cCols > 1))
                b3DBorderCurrent |= NEED3DBORDER_RIGHT;

            if (eTag == ETAG_FRAMESET)
            {
                // propogate down CFrameSetLayout to see if pDoc is inside there
                //
                fResult = DYNCAST(CFrameSetLayout, pLayout)->CheckFrame3DBorder(pWindow, b3DBorderCurrent);
            }
            else
            {
                CDocInfo DCIFrame(pFrame);

                // if there is extra border space (top/left/bottom/right)
                // needed for CFrameElement, need to draw 3D border edge then
                //
                memset(&borderinfo, 0, sizeof(borderinfo));
                pFrame->GetBorderInfo(&DCIFrame, &borderinfo, FALSE, FALSE);
                if (borderinfo.aiWidths[SIDE_TOP] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_TOP;
                }
                if (borderinfo.aiWidths[SIDE_LEFT] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_LEFT;
                }
                if (borderinfo.aiWidths[SIDE_BOTTOM] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_BOTTOM;
                }
                if (borderinfo.aiWidths[SIDE_RIGHT] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_RIGHT;
                }

                pWindow->_b3DBorder = b3DBorderCurrent;
                fResult          = TRUE;
            }
        }

        iCol ++;
        if (iCol == cCols)
        {
            iCol = 0;
            iRow ++;
        }
    }
    ClearLayoutIterator(dw, FALSE);

    return fResult;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetBackgroundInfo
//
//  Synopsis:   Generate the background information for a framesite
//
//-------------------------------------------------------------------------
BOOL
CFrameSetLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{
    Assert(pDI || !fAll);

    CColorValue ccv = FrameSetElement()->BorderColorAttribute();
    COLORREF    cr;
    CLayout   * pLayout;
    DWORD_PTR   dw;
    CColorValue ccvFrame;
    CDoc      * pDoc = Doc();

    // TODO (JHarding): 
    // There are some cases with merging frame border colors, that
    // Netscape handles and we don't.  Additionally, checks need to be done
    // for existence/color on a border-by-border basis for existence/color,
    // because we can have a case where one frameset has several non-
    // intersecting borders of different colors, widths, and existence.
    //
    // First, do we have a border or not?  If we don't have a border,
    // we shouldn't look for bordercolor attrs on <FRAME>s.
    //
    if (!pDoc->_fFrameBorderCacheValid)
    {
        // we can not assume that this is in the tree at this exact moment.
        // or. more accurately, the doc may have a body, and the frameset is added
        // through the DOM. thus the primaryElementClient may, validly, not be a frameset
        CElement * pElemClient = FrameSetElement()->GetMarkup()->GetElementClient();

        if (pElemClient->Tag() == ETAG_FRAMESET)
        {
            DYNCAST(CFrameSetSite, pElemClient)->FrameBorderAttribute(TRUE, FALSE);
            pDoc->_fFrameBorderCacheValid = TRUE;
        }
    }

    if(FrameSetElement()->IsSeamlessEdit())
    {
        cr = GetSysColorQuick(COLOR_ACTIVECAPTION);
    }
    else if(!FrameSetElement()->_fFrameBorder)
    {
        cr = pDoc->PrimaryRoot()->GetBackgroundColor();
    }
    else
    {
        if(ccv.IsDefined())
        {
            // First, if they gave us a border color, let's use it.
            //
            cr = ccv.GetColorRef();
        }
        else
        {
            // Otherwise, use the 3d button face color so we
            // match the window frame.
            //
            cr = GetSysColorQuick(COLOR_3DFACE);
        }

        // test if one of the frames has borderColor defined. If it is the case,
        // set borderColor to the first defined and use for all borders.
        //
        for (pLayout = GetFirstLayout(&dw, FALSE);
             pLayout;
             pLayout = GetNextLayout(&dw, FALSE))
        {
            if (pLayout->ElementOwner()->_etag == ETAG_FRAME)
            {
                ccvFrame = (DYNCAST(CFrameElement, pLayout->ElementOwner()))->GetAAborderColor();
                if (ccvFrame.IsDefined())
                {
                    cr = ccvFrame.GetColorRef();
                    break;
                }
            }
        }
        ClearLayoutIterator(dw, FALSE);
    }

    super::GetBackgroundInfo(pDI, pbginfo, fAll);
    pbginfo->crBack = cr;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFrameSetLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack /*=FALSE*/, BOOL fRaw /*=FALSE*/)
{
    if (ElementOwner()->GetFirstBranch())
    {
        CChildIterator *    pLayoutIterator;
        static ELEMENT_TAG   atagStop = ETAG_FRAMESET;
        static ELEMENT_TAG   atagChild[2] = { ETAG_FRAMESET, ETAG_FRAME };
        
        pLayoutIterator = new CChildIterator(
            ElementOwner(),
            NULL,
            CHILDITERATOR_USETAGS,
            &atagStop, 1,
            atagChild, ARRAY_SIZE(atagChild));
        
        *pdw = (DWORD_PTR)pLayoutIterator;
        
        return *pdw == NULL ? NULL : CFrameSetLayout::GetNextLayout(pdw, fBack, fRaw);
    }
    
    // if CFrameSetSite is not in the tree, no need to walk through
    // CChildIterator
    //
    * pdw = 0;
    return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFrameSetLayout::GetNextLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    CLayout *           pLayout = NULL;
    CChildIterator *    pLayoutWalker;

    pLayoutWalker = (CChildIterator *) (*pdw);
    if (pLayoutWalker)
    {
        CTreeNode * pNode = fBack ? pLayoutWalker->PreviousChild()
                                : pLayoutWalker->NextChild();
        pLayout = pNode ? pNode->GetUpdatedLayout( LayoutContext() ) : NULL;
    }
    return pLayout;
}


//+---------------------------------------------------------------------------
//
//  Member : ClearLayoutIterator
// 
//----------------------------------------------------------------------------
void
CFrameSetLayout::ClearLayoutIterator(DWORD_PTR dw, BOOL fRaw)
{
    if (!fRaw)
    {
        CChildIterator * pLayoutWalker = (CChildIterator *) dw;
        if (pLayoutWalker)
            delete pLayoutWalker;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     SetZOrder
//
//  Synopsis:   set z order for site
//
//  Arguments:  [pLayout]   set z order for this layout
//              [zorder]    to set
//              [fUpdate]   update windows and invalidate
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetLayout::SetZOrder(CLayout * pLayout, LAYOUT_ZORDER zorder, BOOL fUpdate)
{
    HRESULT     hr = S_OK;

    if (fUpdate)
    {
        Doc()->FixZOrder();
        Invalidate();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::SelectSite
//
//  Synopsis:   Selects the site based on the flags passed in
//
//
//  Arguments:  [pLayout]       -- The layout to select (for parent layouts)
//              [dwFlags]       -- Action flags:
//                  SS_ADDTOSELECTION       add it to the selection
//                  SS_REMOVEFROMSELECTION  remove it from selection
//                  SS_KEEPOLDSELECTION     keep old selection
//                  SS_SETSELECTIONSTATE    set flag according to state
//
//  Returns:    HRESULT
//
//  Notes:      This method will call parent objects or children objects
//              depending on the action and passes the child/parent along
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetLayout::SelectSite(CLayout * pLayout, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    AssertSz(0,"This method doesn't do anything anymore - and will be deleted soon");
    
#ifdef NEVER
    if (pLayout == this && (dwFlags & SS_SETSELECTIONSTATE))
    {
        if (dwFlags & SS_CLEARSELECTION)
        {
            SetSelected(FALSE);
        }
        else if (!ElementOwner()->IsEditable() && GetParentLayout()
                                          && ElementOwner()->IsInMarkup())
        {
            Verify(!GetParentLayout()->SelectSite(this, dwFlags));
        }

        // call state on all children
        {
            DWORD_PTR dw;
            CLayout * pLayout;

            for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
            {
                Verify(!pLayout->SelectSite(pLayout, dwFlags));
            }
            ClearLayoutIterator(dw, FALSE);
        }
    }
    else
    {
        hr = super::SelectSite(pLayout, dwFlags);
    }
#endif    
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Initiate a re-layout of the table
//
//  Arguments:  grfFlags - LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CFrameSetLayout::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFrameSetLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    //
    //  If the element is not hidden, layout its content
    //

    if (!IsDisplayNone())
    {
        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
        CCalcInfo       CI(this);
        CSize           size;

        GetSize(&size);
        CI.SizeToParent(&size);

        CI._grfLayout |= grfLayout;

        //
        //  Layout child FRAMESETs and FRAMEs
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            // we want to do this each time inorder to
            // properly pick up things like opacity.
            if (_fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            EnsureDispNode(&CI, !!(CI._grfLayout & LAYOUT_FORCE));

            CalcSizeVirtual(&CI, &size, NULL);

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, size);
        }
    }

    //
    //  Otherwise, clear dirty state and dequeue the layout request
    //

    else
    {
        FlushRequests();
        Reset(TRUE);
    }

    Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFrameSetLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}


//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a tree notification
//
//  Arguments:  pnf - Pointer to the tree notification
//
//-----------------------------------------------------------------------------
void
CFrameSetLayout::Notify(
    CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    super::Notify(pnf);

    if(pnf->IsTextChange())
    {
        if (!pnf->IsHandled())
        {
                pnf->SetHandler(ElementOwner());

                //
                //  Ignore the notification if already "dirty"
                //  Otherwise, post a layout request
                //

                if (    !IsSizeThis()
                    &&  !TestLock(CElement::ELEMENTLOCK_SIZING))
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFrameSetLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                    //possibly got new children, need to recalc positions
                    SetDirtyFramePositions(TRUE);
                }
        }

    }
    else if(   pnf->Type() == NTYPE_ELEMENT_RESIZE
            || pnf->Type() == NTYPE_ELEMENT_REMEASURE
           )
    {
        if (!pnf->IsHandled() && pnf->Element())
        {
            if(pnf->Element() != ElementOwner())
            {
                pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                pnf->SetHandler(ElementOwner());

                //
                //  Ignore the notification if already "dirty"
                //  Otherwise, post a layout request
                //

                if (    !IsSizeThis()
                    &&  !TestLock(CElement::ELEMENTLOCK_SIZING))
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFrameSetLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                    //our child gets resized, need to recalc positions
                    SetDirtyFramePositions(TRUE);
                }
            }
            
        }
    }
    else if(pnf->Type() == NTYPE_SELECT_CHANGE)
    {
        // Fire this onto the form
        Doc()->OnSelectChange();
    }
    else if(pnf->Type() == NTYPE_ELEMENT_INVAL_Z_DESCENDANTS)
    {
        const CFancyFormat * pFF = GetFirstBranch()->GetFancyFormat();
        if (    pFF->_fPositioned   
            &&  (pFF->IsWidthPercent() || pFF->IsHeightPercent()))
        {
            ElementOwner()->RepositionElement();
        }
    }
    
#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}


#if DBG == 1
//+------------------------------------------------------------------------
//
//  Member:     IsInPageTransition
//
//  Synopsis:   Returns TRUE if this element is involved in a page transition.
//              Only needed for an assert in CDispNode::GetDrawProgram.
//
//-------------------------------------------------------------------------

BOOL
CFrameSetLayout::IsInPageTransitionApply() const
{
    CElement *pElement          = ElementOwner();
    CDocument *pDoc             = pElement  ? pElement->DocumentOrPendingDocument() : NULL;
    CPageTransitionInfo *pInfo  = pDoc      ? pDoc->GetPageTransitionInfo()         : NULL;
    CMarkup *pMarkup            = pInfo     ? pInfo->GetTransitionFromMarkup()      : NULL;

    return (pMarkup &&
            pInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_REQUESTED
            && pMarkup->GetElementClient() == pElement);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\htmllyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       htmllyt.cxx
//
//  Contents:   Implementation of CHtmlLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_HTMLYT_HXX_
#define X_HTMLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

MtDefine(CHtmlLayout, Layout, "CHtmlLayout")
DeclareTag(tagDisplayInnerHTMLNode,"Layout: Show InnerHTMLLyt Node",   "Gives the inner HTML node a background");
ExternTag(tagLayoutTasks);
ExternTag(tagCalcSizeDetail);

const CLayout::LAYOUTDESC CHtmlLayout::s_layoutdesc =
{
    0, // _dwFlags
};

CHtmlLayout::~CHtmlLayout()
{
    // (greglett) This is the wrong place to do this - the element disp node is waxed in CLayout::Detach
    if (_pInnerDispNode)
    {
        // Inner display node is never a scroller: No need to detach scrollbar container.
        Verify(OpenView());
        _pInnerDispNode->Destroy();
        _pInnerDispNode = NULL;
    }
}

void
CHtmlLayout::Notify(CNotification * pnf)
{
    BOOL fHandle = FALSE;

    Assert(!pnf->IsReceived(_snLast) || pnf->Type() == NTYPE_ELEMENT_ENSURERECALC);

    //
    //  Handle position change notifications
    //   
    if (IsPositionNotification(pnf))
    {
        fHandle = HandlePositionNotification(pnf);
    }    
    else if (IsInvalidationNotification(pnf))
    {
        //
        //  Invalidate the entire layout if the associated element initiated the request
        //
        if (   ElementOwner() == pnf->Element() 
            || pnf->IsType(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS))
        {
            Invalidate();
        }
    }
#ifdef ADORNERS    
    //
    //  Handle adorner notifications
    //
    else if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
    {
        fHandle = HandleAddAdornerNotification(pnf);
    }
#endif // ADORNERS
    else if (pnf->IsTextChange())
    {
        //do nothing. Should not happen because HTML does not have text content.
    }
    else if (!pnf->IsHandled() && pnf->IsLayoutChange() && pnf->Element())
    {

        CElement * pElemNotify = pnf->Element();

        if(pElemNotify != ElementOwner())
        {
            fHandle = TRUE;
            pElemNotify->DirtyLayout(pnf->LayoutFlags());
        }
        else
        {
            if (pnf->IsFlagSet(NFLAGS_FORCE))
            {
                _fForceLayout = TRUE;
            }
            pnf->ClearFlag(NFLAGS_FORCE);
        }
        
        if(!IsSizeThis())
        {
            //our child changed and we are not scheduled for calc by parent
            //post request to ourself
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CHTMLLayout::Notify() [n=%S srcelem=0x%x,%S]",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber,
                        pnf->Name(),
                        pElemNotify,
                        pElemNotify->TagName()));
            PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
        }

    }
    else
    {
        super::Notify(pnf);
    }

    if (fHandle)
    {
        pnf->SetHandler(ElementOwner());
    }
}



void UpdateScrollInfo(CDispNodeInfo * pdni, const CLayout * pLayout );

void
CHtmlLayout::GetDispNodeInfo(
    BOOL            fCanvas,                             
    CDispNodeInfo * pdni,
    CDocInfo *      pdci  ) const
{
    CElement *              pElement    = ElementOwner();
    CTreeNode *             pTreeNode   = pElement->GetFirstBranch();
    const CFancyFormat *    pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *    pCF         = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const BOOL  fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    const BOOL  fWritingModeUsed        = pCF->_fWritingModeUsed;
    BOOL                    fThemed     =    GetThemeClassId() != THEME_NO       
                                          && pElement->GetTheme(GetThemeClassId());
    CBackgroundInfo         bi;

    //
    //  Get general information
    //

    pdni->_etag                 = pElement->Tag();
    pdni->_layer                = DISPNODELAYER_FLOW;
    pdni->_fHasInset            = FALSE;
    pdni->_fIsOpaque            = FALSE;
    pdni->_fRTL                 = IsRTL();
    pdni->_fHasUserClip         = FALSE;
    pdni->_fHasExpandedClip     = FALSE;

    if (fCanvas)
    {
        pdni->_fHasUserTransform    = FALSE;
        pdni->_visibility           = VISIBILITYMODE_INHERIT;
        pdni->_fHasContentOrigin    = TRUE;

        //
        //  Determine background information
        //

        const_cast<CHtmlLayout *>(this)->GetBackgroundInfo(NULL, &bi, FALSE);

        pdni->_fHasBackground      = (bi.crBack != COLORREF_NONE || bi.pImgCtx) ||
                                      const_cast<CHtmlLayout *>(this)->IsShowZeroBorderAtDesignTime() ; // we always call DrawClientBackground when ZEROBORDER is on

        pdni->_fHasFixedBackground =        (bi.fFixed && !!bi.pImgCtx)
                                       ||   fThemed && pdni->_etag != ETAG_FIELDSET;


        // if there is a background image that doesn't cover the whole site, then we cannont be
        // opaque
        //
        // (carled) we are too close to RC0 to do the full fix.  Bug #66092 is opened for the ie6
        // timeframe to clean this up.  the imagehelper fx (above) should be REMOVED!! gone. bad
        // instead we need a virtual function on CLayout called BOOL CanBeOpaque(). The def imple
        // should contain the if stmt below. CImageLayout should override and use the contents
        // of CImgHelper::IsOpaque, (and call super). Framesets could possibly override and set
        // to false.  Input type=Image should override and do the same things as CImageLayout
        //
        pdni->_fIsOpaque  = (      pdni->_fIsOpaque
                            || bi.crBack != COLORREF_NONE && !fThemed
                            ||  (   !!bi.pImgCtx
                                 &&  !!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE))
                                 &&  pFF->GetBgPosX().GetRawValue() == 0 // Logical/physical does not matter
                                 &&  pFF->GetBgPosY().GetRawValue() == 0 // since we check both X and Y here.
                                 &&  pFF->GetBgRepeatX()                 // Logical/physica does not matter
                                 &&  pFF->GetBgRepeatY())                // since we check both X and Y here.
                            );
        //
        //  Determine overflow, scroll and scrollbar direction properties
        //

        pdni->_overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
        pdni->_overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);
        pdni->_fIsScroller = pTreeNode->IsScrollingParent(LC_TO_FC(LayoutContext()));

        if (    GetOwnerMarkup()->GetElementClient()
            &&  GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY
            && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
        {
            UpdateScrollInfo(pdni, this);
        }
        else
        {
            GetDispNodeScrollbarProperties(pdni);
        }

        //
        //  Get border information
        //
        Assert(pdci);

        pdni->_dnbBorders = (DISPNODEBORDER)pElement->GetBorderInfo(pdci, &(pdni->_bi), FALSE, FALSE FCCOMMA LC_TO_FC(((CLayout *)this)->LayoutContext()));

        Assert( pdni->_dnbBorders == DISPNODEBORDER_NONE
            ||  pdni->_dnbBorders == DISPNODEBORDER_SIMPLE
            ||  pdni->_dnbBorders == DISPNODEBORDER_COMPLEX);

        pdni->_fIsOpaque = pdni->_fIsOpaque
                            && (pdni->_dnbBorders == DISPNODEBORDER_NONE
                                || (    pdni->_bi.IsOpaqueEdge(SIDE_TOP)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_LEFT)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_BOTTOM)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_RIGHT)) );

        // Check if need to disable 'scroll bits' mode
        pdni->_fDisableScrollBits =   pdni->_fHasFixedBackground 
                               || (pFF->GetTextOverflow() != styleTextOverflowClip);
    
    }
    else
    {
        pdni->_overflowX   = styleOverflowVisible;
        pdni->_overflowY   = styleOverflowVisible;
        pdni->_dnbBorders  = DISPNODEBORDER_NONE;
        pdni->_fIsScroller = FALSE;
        pdni->_fHasBackground       = FALSE;
        pdni->_fHasFixedBackground  = FALSE;
        pdni->_fDisableScrollBits   = FALSE;        
        pdni->_fHasContentOrigin    = FALSE;

#if DBG==1
        if (IsTagEnabled(tagDisplayInnerHTMLNode))
            pdni->_fHasBackground = TRUE;
#endif

        GetDispNodeScrollbarProperties(pdni);
       
        //
        //  Determine if custom transformations are required
        //
        pdni->_fHasUserTransform = GetElementTransform(NULL, NULL, NULL);

        pdni->_visibility   = VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility(LC_TO_FC(((CLayout *)this)->LayoutContext())));
    }
}


DWORD
CHtmlLayout::CalcSizeVirtual( CCalcInfo * pci,
                              SIZE *      psize,
                              SIZE *      psizeDefault)
{
    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CLayout *       pChildLayout = GetChildLayout();
    CSize           sizeOriginal;
    CSize szTotal = *psize;
    CDispNodeInfo   dni, dni2;
    DWORD           grfReturn;

    // (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    //
    //  Calc (essentially set) size of our first (canvas) display node
    //
    GetSize(&sizeOriginal);
    GetDispNodeInfo(TRUE, &dni, pci);
    GetDispNodeInfo(FALSE, &dni2, pci);

    if (_fForceLayout)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "_fForceLayout is on"));
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "LAYOUT_FORCE is on"));
        SetSizeThis( TRUE );
        //_fAutoBelow        = FALSE;
        //_fPositionSet      = FALSE;
        //_fContainsRelative = FALSE;
    }

    //
    // Ensure the view/canvas display node is correct
    // (If they change, then force measuring since borders etc. may need re-sizing)
    //    
    if (EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni, &_pDispNode) == S_FALSE)
    {
        grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        SetSizeThis( TRUE );
    }
    

    // FULL LayoutPeer CalcSize delegation would go HERE 
    // MODIFYNATURAL LayoutPeer CalcSize delegation would go HERE

    grfReturn  |=   LAYOUT_THIS |
                      (psize->cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0)  |
                      (psize->cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);


    //
    //  Calc the size and position of our child
    //
    if (pChildLayout)
    {
        CTreeNode * pChildNode          = pChildLayout->GetFirstBranch(); 
        const CFancyFormat * pFF        = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        CSize szParentSizeForChild;
        CRect rcContent(*psize);
        CRect rcPaddings(CRect::CRECT_EMPTY);
        CRect rcChildMargins(CRect::CRECT_EMPTY);
        long  cxParentWidth;
        BOOL  fChildMarginLeftAuto      = FALSE;
        BOOL  fChildMarginRightAuto     = FALSE;
        BOOL  fChildPositioned          = !pChildNode->IsPositionStatic();
        BOOL  fChildIsAbsolute          = pChildNode->IsAbsolute();
        BOOL  fRTL                      = IsRTL();
        BOOL  fInViewLink               = ElementOwner()->IsInViewLinkBehavior(TRUE);

        // Get size minus border/scrollbar
        SubtractClientRectEdges(&rcContent, pci);
        rcContent.GetSize(&szParentSizeForChild); 

        {
            CUnitValue  cuvPadding;

            cuvPadding = pFF->GetPadding(SIDE_LEFT);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.left = cuvPadding.XGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            cuvPadding = pFF->GetPadding(SIDE_RIGHT);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.right = cuvPadding.XGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));            
            }

            cuvPadding = pFF->GetPadding(SIDE_TOP);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.top = cuvPadding.YGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            cuvPadding = pFF->GetPadding(SIDE_BOTTOM);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.bottom = cuvPadding.YGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            // Constrain each padding to [0, SHRT_MAX]
            for (int i=0; i<3; i++)
            {
                if (rcPaddings[i] > SHRT_MAX)
                    rcPaddings[i] = SHRT_MAX;
                else if (rcPaddings[i] < 0)
                    rcPaddings[i] = 0;
            }

            szParentSizeForChild.cx -= rcPaddings.left + rcPaddings.right;
            szParentSizeForChild.cy -= rcPaddings.top + rcPaddings.bottom;
        }
        
        //  Parent Size = Our size - Our Border - Our Padding
        pci->SizeToParent(&szParentSizeForChild);

        {
            const CFancyFormat *pChildFF = pChildNode->GetFancyFormat(LC_TO_FC(pChildLayout->LayoutContext()));
            BOOL fWritingModeUsed        = pChildNode->GetCharFormat(LC_TO_FC(pChildLayout->LayoutContext()))->_fWritingModeUsed;
            CUnitValue cuvMargin;

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_LEFT, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.left   = cuvMargin.XGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
                fChildMarginLeftAuto  = (cuvMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (cuvMargin.GetUnitValue() == styleAutoAuto);
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_RIGHT, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.right  = cuvMargin.XGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
                fChildMarginRightAuto = (cuvMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (cuvMargin.GetUnitValue() == styleAutoAuto);
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_TOP, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.top    = cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_BOTTOM, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.bottom = cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
            }
        }

        szParentSizeForChild.cx -= rcChildMargins.left + rcChildMargins.right;
        szParentSizeForChild.cy -= rcChildMargins.top + rcChildMargins.bottom;
        
        cxParentWidth = szParentSizeForChild.cx;

        if(!pChildLayout->IsDisplayNone())
            grfReturn |= pChildLayout->CalcSize(pci, &szParentSizeForChild);
        else
            szParentSizeForChild = g_Zero.size;

        //
        // If size changed, resize display nodes
        // Note: if in view link, we size to content, ignore automargins, RTL, scrolling
        // and any positioning of the child layout. It is temporary solution until we
        // figure out what to do when we "size to content" in case of view linked behavior
        // Basically, we just show the body/frameset with margins and HTML's padding
        if(fInViewLink)
        {
            if (grfReturn & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                CSize szHtmlSize;

                //szParentSizeForChild is calculated size of inner child (BODY or FRAMESET)
                //add HTML paddings and BODY margins
                szHtmlSize  =   szParentSizeForChild 
                            +   rcPaddings.TopLeft().AsSize() + rcPaddings.BottomRight().AsSize()
                            +   rcChildMargins.TopLeft().AsSize() + rcChildMargins.BottomRight().AsSize();
         
                //HTML border occupies some space - add it
                CBorderInfo    bi;
                DISPNODEBORDER dnbBorders = 
                    (DISPNODEBORDER)ElementOwner()->GetBorderInfo(
                                    pci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

                if (dnbBorders != DISPNODEBORDER_NONE)
                {
                    szHtmlSize.cx   += bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
                    szHtmlSize.cy   += bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];
                }

                SizeDispNode(pci, szHtmlSize);

                if(!pChildLayout->IsDisplayNone())
                {
                       //  Ensure & Size the internal HTML node
                    EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni2, &_pInnerDispNode);
                    _pInnerDispNode->SetPosition(g_Zero.pt);        
                    _pInnerDispNode->SetSize(szHtmlSize, NULL, FALSE);

                    // Calculate the flow position of our child
                    _ptChildPosInFlow = rcPaddings.TopLeft() + rcChildMargins.TopLeft().AsSize();

                    //position child in flow here
                    pChildLayout->SetPosition(_ptChildPosInFlow);
                }
                *psize = szHtmlSize;
            }
        }
        else
        {
            CSize  szInnerNode;
            CPoint ptInnerNodePos(g_Zero.pt);
            
            if (   GetElementDispNode()
                && (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
            {
                    SizeDispNode(pci, *psize);
            }

            if(!pChildLayout->IsDisplayNone())
            {
                // Handle Automargins if our child is in flow
                if (    !fChildIsAbsolute
                    &&  (fChildMarginLeftAuto || fChildMarginRightAuto)
                    &&  (cxParentWidth - szParentSizeForChild.cx) > 0   )
                {
                    long xWidthToDistribute = cxParentWidth - szParentSizeForChild.cx;

                    if (fChildMarginLeftAuto == fChildMarginRightAuto)
                    {
                        rcChildMargins.left  += xWidthToDistribute / 2;
                        rcChildMargins.right += xWidthToDistribute - xWidthToDistribute / 2;
                    }
                    else if (fChildMarginLeftAuto) 
                    {
                        rcChildMargins.left += xWidthToDistribute;
                    }
                    else 
                    {
                        rcChildMargins.right += xWidthToDistribute;
                    }
                }
                

                // Calculate the flow position of our inner display node.
                // Leave it zero if we're LTR, otherwise figure it out...
                if (fRTL)
                {
                    ptInnerNodePos.x = cxParentWidth - szParentSizeForChild.cx;

                    CDispNode * pCanvasDispNode = GetElementDispNode();
                    Assert(pCanvasDispNode->HasContentOrigin());

                    if(pCanvasDispNode->HasContentOrigin())
                        pCanvasDispNode->SetContentOrigin(CSize(0, 0), rcContent.Width());
                }                    

                // Calculate the flow position of our child
                _ptChildPosInFlow = rcPaddings.TopLeft();

                // Absolute elements account for margin in HandlePositionRequest
                // Do not add them on here.
                if (!fChildIsAbsolute)
                    _ptChildPosInFlow += rcChildMargins.TopLeft().AsSize();

                _ptChildPosInFlow += ptInnerNodePos.AsSize();

                if (fChildPositioned)   //positioned child, queue request
                {
                    pChildLayout->ElementOwner()->RepositionElement();
                }        
                else                    //static child, position it in flow here
                    pChildLayout->SetPosition(_ptChildPosInFlow);


                //
                //  Ensure & Size the internal HTML node
                //  This node serves as a 'placeholder' for BODY margins/HTML padding so that
                //  we could scroll to this space. If nothing was occupying this space, 
                //  outer scroller node would not reserve scrolling range to go there.
                //  szParentSizeForChild currently contains the size of the child (BODY) layout.
                //
                EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni2, &_pInnerDispNode);
                GetInnerDispNode()->SetPosition(ptInnerNodePos);        

                //
                //  Size our "Inner" HTML node.
                //

                // If the child is in flow (takes up space), we need to be at least as big as it plus
                // the margins and padding we subtracted off earlier.
                if (!fChildIsAbsolute)
                {
                    szInnerNode =   szParentSizeForChild 
                                +   rcPaddings.TopLeft().AsSize() + rcPaddings.BottomRight().AsSize()
                                +   rcChildMargins.TopLeft().AsSize() + rcChildMargins.BottomRight().AsSize();
                }
                else 
                {
                    szInnerNode.cx =
                    szInnerNode.cy = 0;     // Node is irrelevant for ABS positioning.

                }
         
                GetInnerDispNode()->SetSize(szInnerNode, NULL, FALSE);
            }            

        }

        //
        //  Hook up the display nodes
        //

        CDispParentNode * pCanvasDispNode = (CDispParentNode *) GetElementDispNode();
        CDispParentNode * pHtmlDispNode =  (CDispParentNode *) GetInnerDispNode();
        CDispNode * pDispNode = pChildLayout->GetElementDispNode();

        if (    pCanvasDispNode
            &&  pHtmlDispNode
            &&  pDispNode        )
        {                        
            //  Hook up the HTML disp node under the canvas disp node
            if (pHtmlDispNode->GetParentNode() != pCanvasDispNode)
                pCanvasDispNode->InsertChildInFlow(pHtmlDispNode);
            
            //  Hook up the BODY/FRAMESET disp node
            if (pDispNode->GetParentNode() != pCanvasDispNode)
                pCanvasDispNode->InsertChildInFlow(pDispNode);

        }

    }
    else //no child layout. Strange but lets just size into psize...
    {
        if (GetElementDispNode())
            SizeDispNode(pci, *psize);
        *psize = g_Zero.size;
    }

    SetSizeThis(FALSE);
    return grfReturn;
}

//  Mousewheel scrolling defines.
void    ExecReaderMode(CElement * pScrollElement, CMessage * pMessage, BOOL fByMouse);
void    ReaderModeScroll(CLayout * pScrollLayout, int dx, int dy);
HRESULT HandleMouseWheel(CLayout * pScrollLayout, CMessage * pMessage);

HRESULT BUGCALL
CHtmlLayout::HandleMessage(
    CMessage * pMessage)
{
    HRESULT     hr            = S_FALSE;

    Assert(!GetOwnerMarkup() || GetOwnerMarkup()->IsHtmlLayout());

    switch(pMessage->message)
    {

        case WM_SETCURSOR:
            hr = ElementOwner()->SetCursorStyle(IDC_ARROW);
            break;
            
#ifndef WIN16
    case WM_MOUSEWHEEL:
        hr = THR(HandleMouseWheel(this, pMessage));
        break;

    case WM_MBUTTONDOWN:
        if (    GetElementDispNode()
            &&  !Doc()->_fDisableReaderMode
            &&  GetElementDispNode()->IsScroller())
        {
            //ExecReaderMode runs message pump, so element can be destroyed
            //during it. AddRef helps.
            CElement * pElement = ElementOwner();
            pElement->AddRef();
            ExecReaderMode(pElement, pMessage, TRUE);
            pElement->Release();

            hr = S_OK;
        }
        break;
            
#endif // ndef WIN16
    }

    // Remember to call super
    if (hr == S_FALSE)
    {
        hr = super::HandleMessage(pMessage);
    }

    RRETURN1(hr, S_FALSE);
}


BOOL
CHtmlLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{
    Assert(pDI || !fAll);
    Assert(GetOwnerMarkup()->IsHtmlLayout());

    if (    DYNCAST(CHtmlElement, ElementOwner())->ShouldStealBackground()
        &&  GetOwnerMarkup()->GetElementClient() )
    {                
        // We need to try and steal a background from the BODY/FRAMESET.
        // NB: Call GetBackgroundInfoHelper, because
        //      1) CFramesetLayout/CBodyLayout::GetBackgroundInfo will return transparent (it's being stolen)
        //      2) We don't want to calc the image dimensions for the child layout.
        CLayout * pLayout = GetOwnerMarkup()->GetElementClient()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        pLayout->GetBackgroundInfoHelper(pbginfo);

        // We need to calc background image dimensions using *our* layout information, not the BODY/FRAMESETs
        if (    fAll
            &&  pbginfo->pImgCtx)
        {
            GetBackgroundImageInfoHelper(pDI, pbginfo);
        }

        // Do we need to ensure a background color?
        if (    GetOwnerMarkup() == Doc()->PrimaryMarkup()
            &&  pbginfo->crBack == COLORREF_NONE )
        {
            pbginfo->crBack = GetOwnerMarkup()->Root()->GetBackgroundColor();
            Assert(pbginfo->crBack != COLORREF_NONE);
        }
    }
    else
    {
        super::GetBackgroundInfo(pDI, pbginfo, fAll);
    }

    return TRUE;
}

void 
CHtmlLayout::GetPositionInFlow(CElement *pElement, CPoint *ppt)
{
    if (!ppt)
    {
        return;
    }

    *ppt = g_Zero.pt;

    if (    !pElement 
        ||  pElement != ElementOwner()->GetMarkup()->GetElementClient() )
    {
        return;
    }

    *ppt = _ptChildPosInFlow;
}

BOOL CHtmlLayout::IsRTL() const
{
    CElement           *pElement  = ElementOwner();
    Assert(pElement);

    CTreeNode          *pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat *pFF       = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *pCF       = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

    //if HTML has explicitly specified direction, use it..
    if(pFF->HasExplicitDir())
    {
        return pCF->_fRTL;
    }
    else //otherwise, steal direction on BODY if it has it secified..
    {
        CElement *pClientElement = GetOwnerMarkup()->GetElementClient();
        if(pClientElement && pClientElement->Tag() == ETAG_BODY)
        {
            CTreeNode          *pTreeNode = pClientElement->GetFirstBranch();
            const CFancyFormat *pFF = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
            const CCharFormat  *pCF = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

            return pFF->HasExplicitDir() && pCF->_fRTL;
        }
    }

    //nobody has direction specified, return default (LTR)
    return FALSE;
}

// This is used by bookmark code to impatiently ask if we are already done..
// If BODY was not yet loaded, return FALSE - caller should wait (dmitryt)
BOOL CHtmlLayout::FRecalcDone()
{
    CLayout *pChildLayout = GetChildLayout();
    return pChildLayout ? pChildLayout->FRecalcDone() : FALSE; 
}


#if DBG == 1
//+------------------------------------------------------------------------
//
//  Member:     IsInPageTransition
//
//  Synopsis:   Returns TRUE if this element is involved in a page transition.
//              Only needed for an assert in CDispNode::GetDrawProgram.
//
//-------------------------------------------------------------------------

BOOL
CHtmlLayout::IsInPageTransitionApply() const
{
    CElement *pElement          = ElementOwner();
    CDocument *pDoc             = pElement  ? pElement->DocumentOrPendingDocument() : NULL;
    CPageTransitionInfo *pInfo  = pDoc      ? pDoc->GetPageTransitionInfo()         : NULL;
    CMarkup *pMarkup            = pInfo     ? pInfo->GetTransitionFromMarkup()      : NULL;

    return (pMarkup &&
            pInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_REQUESTED
            && pMarkup->GetHtmlElement() == pElement);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\imglyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       imglyt.cxx
//
//  Contents:   Implementation of CImageLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif


MtDefine(CImgElementLayout, Layout, "CImgElementLayout")
MtDefine(CInputImageLayout, Layout, "CInputImageLayout")
ExternTag(tagImgTrans);

//extern void SetCachedImageSize(LPCTSTR pchURL, SIZE size);
extern BOOL GetCachedImageSize(LPCTSTR pchURL, SIZE *psize);

extern HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO);


class CImgDragDropSrcInfo : public CDragDropSrcInfo
{
public:
    CImgDragDropSrcInfo() : CDragDropSrcInfo()
    {
        _srcType = DRAGDROPSRCTYPE_IMAGE;
    }

    CGenDataObject *    _pImgDO;    // Data object for the image being dragged
};

const CLayout::LAYOUTDESC CImageLayout::s_layoutdesc =
{
    0, // _dwFlags
};

//+-------------------------------------------------------------------------
//
//  Method:     CImageLayout::CalcSizeVirtual
//
//  Synopsis   : This function adjusts the size of the image
//               it uses the image Width and Height if present
//
//--------------------------------------------------------------------------

DWORD
CImgElementLayout::CalcSizeVirtual( CCalcInfo * pci,
                                    SIZE      * psize,
                                    SIZE      * psizeDefault)
{
    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CScopeFlag        csfCalcing(this);
    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo     sci(pci, this);
    DWORD             grfReturn;

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }
    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis(IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE));

    // If sizing is needed or it is a min/max request, handle it here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
        )
    {
        HRESULT hr;
        CImgHelper * pImage;
        CSize sizeOriginal;

        GetSize(&sizeOriginal);

        pImage = DYNCAST(CImgElement, ElementOwner())->_pImage;
        Assert(pImage);
        pImage->CalcSize(pci, psize);

        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (   IsSizeThis()
                && (SUCCEEDED(hr = EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE))))
               )
            {
                if (pImage->_pBitsCtx)
                {
                    SetPositionAware();
                }

                if (hr == S_FALSE)
                {
                    grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
                }
            }
            SetSizeThis(FALSE);


            {
#define MIN_ALLOWED_WIDTH_DEFINED_BY_CWILSO     5
#define MAX_ALLOWED_HEIGHT_DEFINED_BY_CWILSO    75

                CLayoutContext *pLayoutContext = pci->GetLayoutContext();

                // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
                // that prohibit layout breaking in Page View. This approach is not suffitient 
                // enouth for editable Page View there we want this property to be calculated 
                // dynamically depending on layout type and layout nesting position (if parent 
                // has it child should inherit). 
                // This work also will enable CSS attribute page-break-inside support.
                
                //
                //  this is a hack to handle lo-o-ong images used as a border inside table in PPV. 
                //
                if (
                    //  if there is a layout context ...
                        pLayoutContext
                    //  ... and if the image is inside table ...
                    &&  pci->_fTableCalcInfo    )
                {
                    long lScreenPixelsWidth;
                    long lScreenPixelsHeight;

                    //  get image size in screen pixels
                    // (mikhaill: being more exact - in conventional document pixels)
                    if (pLayoutContext->GetMedia() != mediaTypeNotSet)
                    {
                        lScreenPixelsWidth  = pci->DocPixelsFromDeviceX(psize->cx);
                        lScreenPixelsHeight = pci->DocPixelsFromDeviceY(psize->cy);
                    }
                    else 
                    {
                        lScreenPixelsWidth  = psize->cx;
                        lScreenPixelsHeight = psize->cy;
                    }

                    //  ... and the image is narrow and long (the definition of "narrow" and "long" 
                    //  given by CWilso in description of bug # 97596) ...
                    if (    lScreenPixelsWidth  < MIN_ALLOWED_WIDTH_DEFINED_BY_CWILSO
                        &&  lScreenPixelsHeight > MAX_ALLOWED_HEIGHT_DEFINED_BY_CWILSO  )
                    {
                        //  if this is not compatible layout context ...
                        if (pLayoutContext->ViewChain()) 
                        {
                            //  ... cut the height beyond available height 
                            if (psize->cy > pci->_cyAvail)
                            {
                                psize->cy = pci->_cyAvail;
                            }
                        }
                        else
                        //  check if this is a compatible layout context 
                        {
                            CMarkup *pMarkup = GetContentMarkup();
                            AssertSz(pMarkup, "Layout MUST have markup pointer!!!"); 

                            if (pMarkup && pMarkup->GetCompatibleLayoutContext() == pLayoutContext)
                            {
                                //  table will be messed up if compatible layout of a table cell 
                                //  will be longer than real one. To prevent it lets return some 
                                //  reasonable height...
                                psize->cy = 1;
                            }
                        }
                    }
                }
            }


            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0) 
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize, (grfReturn & LAYOUT_FORCE));
                pImage->SetActivity();
            }

            //  At this point we want to update psize with a new information accounting filter 
            if (HasMapSizePeer())
                 GetApparentSize(psize); // from DispNode

        }
        else if (   pci->_smMode == SIZEMODE_MMWIDTH
                 || pci->_smMode == SIZEMODE_MINWIDTH
                )
        {
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cx = rectMapped.Width();
                    psize->cy = rectMapped.Height();
                }
            }

            if (pci->_smMode == SIZEMODE_MMWIDTH)
                psize->cy = psize->cx;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    return grfReturn;
}


//+----------------------------------------------------------------------------
//
// Member: GetMarginInfo
//
//  add hSpace/vSpace to the margin
//
//-----------------------------------------------------------------------------
void
CImgElementLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CImgElement *      pImg            = DYNCAST(CImgElement, ElementOwner());

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
    Assert(pImg && pImg->_pImage);
    pImg->_pImage->GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
}

//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CImgElementLayout::Draw(CFormDrawInfo *pDI, CDispNode *pDispNode)
{
    CImgElement *   pImg = DYNCAST(CImgElement, ElementOwner());

    
#if DBG==1
    BOOL fLayoutOpaque = IsOpaque();
    BOOL fDispNodeOpaque = pDispNode->IsOpaque();
    if (fDispNodeOpaque && !fLayoutOpaque)
    {
        CBackgroundInfo bi;
        GetBackgroundInfo(NULL, &bi, FALSE); 
        AssertSz(bi.crBack != COLORREF_NONE, "Display node and layout disagree about image opacity");
    }

    if (IsTagEnabled(tagImgTrans) && IsOpaque() && !pDispNode->IsOpaque())
    {
        TraceTag((tagImgTrans, "CImgElementLayout %x is opaque, dispnode %x isn't (perf)",
                    this, pDispNode));
    }
#endif

    // draw the image
    pImg->_pImage->Draw(pDI);

    // Draw the map if in edit mode
    if (IsEditable(TRUE))
    {
        pImg->EnsureMap();
        if (pImg->_pMap)
        {
            pImg->_pMap->Draw(pDI, pImg);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CInputImageLayout::Draw(CFormDrawInfo *pDI, CDispNode *pDispNode)
{
    CInput *   pImg = DYNCAST(CInput, ElementOwner());

#if DBG==1
    BOOL fLayoutOpaque = IsOpaque();
    BOOL fDispNodeOpaque = pDispNode->IsOpaque();
    if (fDispNodeOpaque && !fLayoutOpaque)
    {
        CBackgroundInfo bi;
        GetBackgroundInfo(NULL, &bi, FALSE); 
        AssertSz(bi.crBack != COLORREF_NONE, "Display node and layout disagree about image opacity");
    }

    if (IsTagEnabled(tagImgTrans) && IsOpaque() && !pDispNode->IsOpaque())
    {
        TraceTag((tagImgTrans, "CInputImageLayout %x is opaque, dispnode %x isn't (perf)",
                    this, pDispNode));
    }
#endif

    // draw the image
    pImg->_pImage->Draw(pDI);
}


HRESULT
CImgElementLayout::PreDrag(DWORD          dwKeyState,
                    IDataObject ** ppDO,
                    IDropSource ** ppDS)
{
    HRESULT                 hr          = S_OK;
    CImgDragDropSrcInfo *   pDragInfo   = NULL;
    CGenDataObject *        pDO         = NULL;
    CImgElement *           pImgElem    = DYNCAST(CImgElement, ElementOwner());
    CImgHelper *            pImg        = pImgElem->_pImage;

    Assert(!Doc()->_pDragDropSrcInfo);

    pDragInfo = new CImgDragDropSrcInfo;
    if (!pDragInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(CreateImgDataObject(Doc(), pImg->_pImgCtx, pImg->_pBitsCtx, ElementOwner(), &pDO));
    if (hr)
    {
        goto Cleanup;
    }
    Assert(pDO);
    pDO->SetBtnState(dwKeyState);

    hr = pDO->QueryInterface(IID_IDataObject,(void **)ppDO);
    if (hr)
        goto Cleanup;

    hr = pDO->QueryInterface(IID_IDropSource,(void **)ppDS);
    if (hr)
        goto Cleanup;

    pDragInfo->_pImgDO = pDO;
    Doc()->_pDragDropSrcInfo = pDragInfo;

Cleanup:
    if (hr)
    {
        if (pDragInfo)
        {
            delete pDragInfo;
        }
        if (pDO)
        {
            pDO->Release();
        }
    }
    RRETURN(hr);
}


HRESULT
CImgElementLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
    Assert(Doc()->_pDragDropSrcInfo);
    //
    // possible for not to be image - via dragElement calls via OM.
    //
    if ( Doc()->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_IMAGE  )
    {    
        DYNCAST(CImgDragDropSrcInfo, Doc()->_pDragDropSrcInfo)->_pImgDO->Release();
    }        
    RRETURN(S_OK);
}





//+----------------------------------------------------------------------------
//
// Member: GetMarginInfo
//
//  add hSpace/vSpace to the margin
//
//-----------------------------------------------------------------------------
void
CInputImageLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CInput *      pImg            = DYNCAST(CInput, ElementOwner());

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
    Assert(pImg && pImg->_pImage);
    pImg->_pImage->GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
}

DWORD
CInputImageLayout::CalcSizeVirtual( CCalcInfo * pci,
                                    SIZE *      psize,
                                    SIZE *      psizeDefault)
{
    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CInput          * pImg = DYNCAST(CInput, ElementOwner());
    CScopeFlag        csfCalcing(this);
    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSize             sizeOriginal;
    DWORD             grfReturn;
    HRESULT           hr;

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    // If sizing is needed or it is a min/max request, handle it here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
        )
    {
        Assert(pImg->_pImage);
        pImg->_pImage->CalcSize(pci, psize);

        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (SUCCEEDED(hr = EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)))))
            {
                if (pImg->_pImage->_pBitsCtx)
                {
                    SetPositionAware();
                }

                if (hr == S_FALSE)
                    grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }
            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize, (grfReturn & LAYOUT_FORCE));

                pImg->_pImage->SetActivity();
            }

            if(HasMapSizePeer())
                GetApparentSize(psize);

        }
        else if (   pci->_smMode == SIZEMODE_MMWIDTH
                 || pci->_smMode == SIZEMODE_MINWIDTH
                )
        {
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cx = rectMapped.Width();
                    psize->cy = rectMapped.Height();
                }
            }

            if (pci->_smMode == SIZEMODE_MMWIDTH)
                psize->cy = psize->cx;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    return grfReturn;
}

HRESULT
CInputImageLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;
    CRectShape *    pShape;
    HRESULT         hr = S_FALSE;

    *ppShape = NULL;

    GetClientRect(&rc);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        *ppShape = NULL;
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_rect.InflateRect(1, 1);
    *ppShape = pShape;

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_OK);
}

CImgHelper *
CImageLayout::GetImgHelper()
{
    CElement * pElement = ElementOwner();
    CImgHelper * pImgHelper = NULL;

    Assert(pElement);
    if (pElement->Tag() == ETAG_IMG)
        pImgHelper = DYNCAST(CImgElement, pElement)->_pImage;
    else if (pElement->Tag() == ETAG_INPUT)
        pImgHelper = DYNCAST(CInput, pElement)->_pImage;

    Assert(pImgHelper);

    return pImgHelper;
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
CImageLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    CImgHelper * pImg = GetImgHelper();

    if (!pImg->_fVideoPositioned)
    {
        pImg->_fVideoPositioned = TRUE;
        pImg->SetVideo();
    }

    if (pImg->_hwnd)
    {           
        CRect rcClip(*prcClip);
        UINT uFlags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS;

        if (flags & VCF_INVIEWCHANGED)
            uFlags |= (flags & VCF_INVIEW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;

// NOTE (lmollico): setting SWP_NOREDRAW causes some problems: the activemovie window paints itself
// between our ScrollDC and EndDeferWindowPos
/*        else if (flags & VCF_NOREDRAW)
            uFlags |= SWP_NOREDRAW;*/

        DeferSetWindowPos(pImg->_hwnd, (RECT *) prcClient, uFlags, NULL);

        rcClip.OffsetRect(-((const CRect*)prcClient)->TopLeft().AsSize());
        SetWindowRgn(pImg->_hwnd, &rcClip, !(flags & VCF_NOREDRAW));

        if (pImg->_pVideoObj)
        {
            RECT rcImg;

            rcImg.top = 0;
            rcImg.left = 0;
            rcImg.bottom = prcClient->bottom - prcClient->top;
            rcImg.right = prcClient->right - prcClient->left;
            pImg->_pVideoObj->SetWindowPosition(&rcImg);
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   PercentSize
//
//  Synopsis:   Handy helper to check for percentage dimensions
//
//----------------------------------------------------------------------------
BOOL
CImageLayout::PercentSize()
{
    BOOL fPercentSize = super::PercentSize();

    //  If rendering in CSS1 strict mode image is allowed to have a padding. 
    //  Report if padding is defined in percents. 
    if (    !fPercentSize 
        &&  ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        const CFancyFormat *pFF = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        fPercentSize = pFF->HasPercentHorzPadding() || pFF->HasPercentVertPadding();
    }
    
    return fPercentSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\inputlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       inputlyt.cxx
//
//  Contents:   Implementation of layout class for <INPUT> controls.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

MtDefine(CInputLayout,       Layout, "CInputLayout")
MtDefine(CInputTextLayout,   Layout, "CInputTextLayout")
MtDefine(CInputFileLayout,   Layout, "CInputFileLayout")
MtDefine(CInputFileLayout_pchButtonCaption,   CInputFileLayout, "CInputFileLayout::_pchButtonCaption")
MtDefine(CInputButtonLayout, Layout, "CInputButtonLayout")

ExternTag(tagCalcSize);

extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);


const CLayout::LAYOUTDESC CInputLayout::s_layoutdesc =
{
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_FLOWLAYOUT,      // _dwFlags
};

const CLayout::LAYOUTDESC CInputFileLayout::s_layoutdesc =
{
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_NOTALTERINSET    |
    LAYOUTDESC_NEVEROPAQUE      |
    LAYOUTDESC_FLOWLAYOUT,      // _dwFlags
};

const CLayout::LAYOUTDESC CInputButtonLayout::s_layoutdesc =
{
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};


HRESULT
CInputTextLayout::OnTextChange(void)
{
    CInput * pInput  = DYNCAST(CInput, ElementOwner());

    if (!pInput->IsEditable(TRUE))
        pInput->_fTextChanged = TRUE;

    if (pInput->_fFiredValuePropChange)
    {
        pInput->_fFiredValuePropChange = FALSE;
    }
    else
    {
        pInput->OnPropertyChange(DISPID_CInput_value, 
                                 0, 
                                 (PROPERTYDESC *)&s_propdescCInputvalue); // value change
    }

    return S_OK;
}



CInputTextLayout::CInputTextLayout(CElement * pElementLayout, CLayoutContext *pLayoutContext)
                                : super(pElementLayout, pLayoutContext)
{
}

//+------------------------------------------------------------------------
//
//  Member:     CInputTextLayout::PreDrag
//
//  Synopsis:   Prevent dragging text out of Password control
//
//-------------------------------------------------------------------------

HRESULT
CInputTextLayout::PreDrag(
    DWORD           dwKeyState,
    IDataObject **  ppDO,
    IDropSource **  ppDS)
{
    HRESULT hr;

    if (DYNCAST(CInput, ElementOwner())->GetType() == htmlInputPassword)
        hr = S_FALSE;
    else
        hr = super::PreDrag(dwKeyState, ppDO, ppDS);
    RRETURN1(hr, S_FALSE);
}

void 
CInputTextLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{    
    CInput *        pElem  = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(GetThemeClassId());

    Assert(pClientData);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;        
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);               

        if (!hdc.DrawThemeBackground(    hTheme,
                                         EP_EDITTEXT,
                                         pElem->GetThemeState(),
                                         &pDI->_rc,
                                         NULL))
        {
            super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
        }
        

    }
    else
    {
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
} 

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::Init
//
//  Synopsis:   Loads the button caption for the "Browse..." button.
//
//----------------------------------------------------------------------------

HRESULT
CInputFileLayout::Init()
{
    HRESULT hr;
    TCHAR achTemp[128];

    //  Clear existing caption
    if (_pchButtonCaption)
    {
        MemFree(_pchButtonCaption);
    }
    
    //  Load the caption string
    hr = LoadString(GetResourceHInst(),
           IDS_BUTTONCAPTION_UPLOAD,
           achTemp,              
           ARRAY_SIZE(achTemp));
            
    if (FAILED(hr))
    {
        // TODO: Handle OOM here
        hr = MemAllocString(Mt(CInputFileLayout_pchButtonCaption), s_achUploadCaption, &_pchButtonCaption);
        _cchButtonCaption = ARRAY_SIZE(s_achUploadCaption) - 1;
    }
    else
    {
        // TODO: Handle OOM here
        hr = MemAllocString(Mt(CInputFileLayout_pchButtonCaption), achTemp, &_pchButtonCaption);
        _cchButtonCaption = _tcslen(achTemp);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInputFileLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;    
    CRectShape *    pShape;
    CBorderInfo     biButton;
    CInput *        pInputFile = DYNCAST(CInput, ElementOwner());
    HRESULT         hr = S_FALSE;
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    HTHEME          hTheme = ElementOwner()->GetTheme(THEME_BUTTON);

    *ppShape = NULL;

    if (!pInputFile->_fButtonHasFocus)
        goto Cleanup;

    GetRect(&rc, COORDSYS_FLOWCONTENT);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(!fRightToLeft)
        rc.left = rc.right - _sizeButton.cx;
    else
        rc.right = rc.left + _sizeButton.cx;

    if (hTheme)
    {
        CRect           rcTheme;

        hr = THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            BP_PUSHBUTTON, 
                                            pInputFile->GetThemeState(), 
                                            &g_Zero.rc, 
                                            &rcTheme
                                        ));

        if(hr)
            goto Cleanup;

        rc.top     += pdci->DeviceFromDocPixelsY(-rcTheme.top);
        rc.left    += pdci->DeviceFromDocPixelsX(-rcTheme.left);
        rc.bottom  -= pdci->DeviceFromDocPixelsY(rcTheme.bottom);
        rc.right   -= pdci->DeviceFromDocPixelsX(rcTheme.right);
    }
    else
    {
        ComputeInputFileBorderInfo(pdci, biButton);

        rc.top     = rc.top + biButton.aiWidths[SIDE_TOP];
        rc.left    = rc.left + biButton.aiWidths[SIDE_LEFT];
        rc.bottom  = rc.bottom - biButton.aiWidths[SIDE_BOTTOM];
        rc.right   = rc.right - biButton.aiWidths[SIDE_RIGHT];

    }

    // Compensate for xyFlat
    rc.InflateRect(pdci->DeviceFromDocPixelsX(-1), pdci->DeviceFromDocPixelsY(-1));

    pShape->_rect = rc;
    *ppShape = pShape;
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInputButtonLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInputButtonLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;    
    CBorderInfo     bi;
    CRectShape *    pShape;
    HRESULT         hr = S_FALSE;
    CInput       *  pButton = DYNCAST(CInput, ElementOwner());

    *ppShape = NULL;
    
    pButton->GetBorderInfo(pdci, &bi);
    GetRect(&rc, COORDSYS_FLOWCONTENT);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_rect.top     += bi.aiWidths[SIDE_TOP];
    pShape->_rect.left    += bi.aiWidths[SIDE_LEFT];
    pShape->_rect.bottom  -= bi.aiWidths[SIDE_BOTTOM];
    pShape->_rect.right   -= bi.aiWidths[SIDE_RIGHT];    

    // Exclude xflat border
    // (Themed buttons don't have this!!!)
    pShape->_rect.InflateRect(pdci->DeviceFromDocPixelsX(-1), pdci->DeviceFromDocPixelsY(-1));

    *ppShape = pShape;
    hr = S_OK;

    // IE6 bug 33042
    // For some reason, only the area inside the focus adorner is being invalidated
    // for submit inputs. This matters in the theme case because we need the border
    // to be invalidated in order to redraw the control. We're going to go ahead
    // and invalidate the whole dispnode here in order to ensure that the control
    // is properly drawn. This is only a problem for themed buttons.

    if (pButton->GetTheme(THEME_BUTTON))
        _pDispNode->Invalidate();
   
Cleanup:
    RRETURN1(hr, S_FALSE);
}
    
void
CInputButtonLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    super::DrawClient( prcBounds,
                       prcRedraw,
                       pDispSurface,
                       pDispNode,
                       cookie,
                       pClientData,
                       dwFlags);

    // (bug 49150) Has the button just appeared? Should it be the default element
    
    CInput * pButton = DYNCAST(CInput, ElementOwner());
    const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();
    Assert(pButton && pCF);

    if (pButton->GetBtnWasHidden() && pButton->GetType() == htmlInputSubmit
        && !pCF->IsDisplayNone() && !pCF->IsVisibilityHidden())
    {
        pButton->SetDefaultElem();
        pButton->SetBtnWasHidden( FALSE );
    }
 
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.

void CInputButtonLayout::DrawClientBackground(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    CInput *       pButton = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);

    if (hTheme)
        return;

    super::DrawClientBackground(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
}

void CInputButtonLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CDoc *          pDoc = Doc();
    CBorderInfo     bi;
    BOOL            fDefaultAndCurrent =    pDoc 
                                        &&  ElementOwner()->_fDefault
                                        &&  ElementOwner()->IsEnabled()
                                        &&  pDoc->HasFocus();
    XHDC            hdc    = pDI->GetDC();
    CInput *        pButton = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);

        if (hdc.DrawThemeBackground(   hTheme,
                                        BP_PUSHBUTTON,
                                        pButton->GetThemeState(),
                                        &pDI->_rc,
                                        NULL))
        {
            return;
        }
    }

    Verify(pButton->GetNonThemedBorderInfo(pDI, &bi, TRUE));

    // draw default if necessary
    bi.acrColors[SIDE_TOP][1]    = 
    bi.acrColors[SIDE_RIGHT][1]  = 
    bi.acrColors[SIDE_BOTTOM][1] = 
    bi.acrColors[SIDE_LEFT][1]   = fDefaultAndCurrent 
                                            ? RGB(0,0,0)
                                            : ElementOwner()->GetInheritedBackgroundColor();

    //  NOTE (greglett) : This xyFlat scheme won't work for outputting to devices 
    //  without a square DPI. Luckily, we never do this.  I think. When this is fixed, 
    //  please change CButtonLayout::DrawClientBorder and CInputButtonLayout::DrawClientBorder 
    //  by removing the following assert and these comments.
    Assert(pDI->IsDeviceIsotropic());
    bi.xyFlat = pDI->DeviceFromDocPixelsX(fDefaultAndCurrent ? -1 : 1);
    //bi.yFlat = pDI->DeviceFromDocPixelsY(fDefaultAndCurrent ? -1 : 1);

    ::DrawBorder(pDI, (RECT *)prcBounds, &bi);
}

CBtnHelper * CInputButtonLayout::GetBtnHelper()
{
    CElement * pElement = ElementOwner();
    Assert(pElement);
    CInput * pButton = DYNCAST(CInput, pElement);
    return pButton->GetBtnHelper();
}

#define TEXT_INSET_DEFAULT_TOP      1
#define TEXT_INSET_DEFAULT_BOTTOM   1
#define TEXT_INSET_DEFAULT_RIGHT    1
#define TEXT_INSET_DEFAULT_LEFT     1

HRESULT
CInputLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    // Input layout can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

htmlInput
CInputLayout::GetType() const
{
    return DYNCAST(CInput, ElementOwner())->GetType();
}

BOOL
CInputLayout::GetMultiLine() const
{
    return IsTypeMultiline(GetType());
}

BOOL 
CInputLayout::GetAutoSize() const
{
    switch(GetType())
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
        return TRUE;
    default:
        return FALSE;
    }
}

THEMECLASSID
CInputLayout::GetThemeClassId() const
{
    CInput *    pInput = DYNCAST(CInput, ElementOwner());
    return pInput->GetInputThemeClsId();
}

//+------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::GetMinSize
//
//  Synopsis:   Get minimum size of the input file control
//
//              the min size of the input file controls should be
//              the default browse button size + 0 char wide input box
//
//-------------------------------------------------------------------------
void
CInputFileLayout::GetMinSize(SIZE * pSize, CCalcInfo * pci)
{
    pSize->cx = pSize->cy = 0;
    AdjustSizeForBorder(pSize, pci, TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInputTextLayout::CalcSizeHelper
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CInputFileLayout::CalcSizeHelper(
    CCalcInfo * pci,
    SIZE *      psize)
{
    DWORD           grfReturn    = (pci->_grfLayout & LAYOUT_FORCE);
    CTreeNode *     pNode        = GetFirstBranch();
    BOOL            fMinMax      = (     pci->_smMode == SIZEMODE_MMWIDTH
                                     ||  pci->_smMode == SIZEMODE_MINWIDTH );
    SIZE            sizeMin;

    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    BOOL fWidthNotSet            = cuvWidth.IsNullOrEnum();
    BOOL fHeightNotSet           = cuvHeight.IsNullOrEnum();

    GetMinSize(&sizeMin, pci);

    if (fWidthNotSet || fHeightNotSet)
    {
        long    rgPadding[SIDE_MAX];
        SIZE    sizeFontForShortStr;
        SIZE    sizeFontForLongStr;
        int     charX       = DYNCAST(CInput, ElementOwner())->GetAAsize();
        int     charY       = 1;
        
        Assert(charX > 0);

        GetDisplay()->GetPadding(pci, rgPadding, fMinMax);
        GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);

        Assert(sizeFontForShortStr.cx && sizeFontForShortStr.cy && sizeFontForLongStr.cx && sizeFontForLongStr.cy);

        psize->cx = (charX -1) * sizeFontForLongStr.cx
                    + sizeFontForShortStr.cx
                    + rgPadding[SIDE_LEFT]
                    + rgPadding[SIDE_RIGHT];
        psize->cy = charY * sizeFontForLongStr.cy
                    + rgPadding[SIDE_TOP]
                    + rgPadding[SIDE_BOTTOM];

        // for textboxes, the border and scrollbars go outside
        AdjustSizeForBorder(psize, pci, TRUE);
    }

    if (!fWidthNotSet)
    {
        psize->cx = (!fMinMax || !PercentWidth()
                        ? cuvWidth.XGetPixelValue(pci,
                                               pci->_sizeParent.cx,
                                               pNode->GetFontHeightInTwips(&cuvWidth) )
                        : 0);
        if (psize->cx < sizeMin.cx)
        {
            psize->cx = sizeMin.cx;
        }
    }
    if (!fHeightNotSet)
    {
        psize->cy = (!fMinMax || !PercentHeight()
                        ? cuvHeight.YGetPixelValue(pci,
                                        pci->_sizeParent.cy,
                                        pNode->GetFontHeightInTwips(&cuvHeight))
                        : 0);
        if (psize->cy < sizeMin.cy)
        {
            psize->cy = sizeMin.cy;
        }
    }

    return grfReturn;
}


//+-------------------------------------------------------------------------
//
//  Method:     CInputFileLayout::CalcSizeCore
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CInputFileLayout::CalcSizeCore(CCalcInfo * pci, 
                               SIZE      * psize, 
                               SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CInputFileLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    Assert(ElementOwner());
    htmlInput       typeInput   = GetType();

    Assert(typeInput == htmlInputFile);

    CSaveCalcInfo   sci(pci, this);
    CSize           sizeOriginal;
    DWORD           grfReturn;
    BOOL            fRecalcText = FALSE;
    BOOL            fNormalMode = pci->IsNaturalMode() && (pci->_smMode != SIZEMODE_SET);
    BOOL            fWidthChanged;
    BOOL            fHeightChanged;
#ifdef  NEVER
    BOOL            fIsButton   =   typeInput == htmlInputButton
                                ||  typeInput == htmlInputReset
                                ||  typeInput == htmlInputSubmit;
#endif
    CScopeFlag  csfCalcing(this);

    Listen();

    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }


#ifdef  NEVER
    if (fIsButton)
    {
        fNormalMode = fNormalMode || pci->_smMode == SIZEMODE_SET;
    }
#endif

    fWidthChanged  = (fNormalMode
                                ? psize->cx != sizeOriginal.cx
                                : FALSE);
    fHeightChanged = (fNormalMode
                                ? psize->cy != sizeOriginal.cy
                                : FALSE);

    fRecalcText = (fNormalMode && (   IsDirty()
                                ||  IsSizeThis()
                                ||  fWidthChanged
                                ||  fHeightChanged))
            ||  (pci->_grfLayout & LAYOUT_FORCE)
            ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
            ||  (pci->_smMode == SIZEMODE_MINWIDTH && (!_fMinMaxValid || _sizeMin.cu < 0));

    // If this site is in need of sizing, then size it
    if (fRecalcText)
    {
        SIZE sizeText;

        if (typeInput == htmlInputFile)
        {
            // calculate button size of input file
            IGNORE_HR(DYNCAST(CInputFileLayout, this)->ComputeInputFileButtonSize(pci));
        }

        //
        // If dirty, ensure display tree nodes exist
        //

        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // to make input file work
        //
        grfReturn |= CalcSizeHelper(pci, psize);
        _fContentsAffectSize = FALSE;
        sizeText = *psize;
        grfReturn |= super::CalcSizeCore(pci, &sizeText, psizeDefault);
        if (!fNormalMode && PercentWidth())
        {
            *psize = sizeText;
        }

        if (psizeDefault)
        {
            *psizeDefault = *psize;
        }

        grfReturn |= LAYOUT_THIS  |
                    (psize->cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0) |
                    (psize->cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);

        //
        // If size changes occurred, size the display nodes
        //

        if (    fNormalMode
            &&  _pDispNode
            &&  grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
        {
            CSize sizeContent(_dp.GetMaxWidth(), _dp.GetHeight());

            SizeDispNode(pci, *psize);

            // (paulnel) Make sure the max of the content cell has the borders
            // removed. Taking the full container size will cause scrolling on
            // selection.
            CRect rcContainer;
            GetClientRect(&rcContainer);
            sizeContent.Max(rcContainer.Size());
            SizeContentDispNode(sizeContent);

            if (HasRequestQueue())
            {
                long xParentWidth;
                long yParentHeight;

                _dp.GetViewWidthAndHeightForChild(
                    pci,
                    &xParentWidth,
                    &yParentHeight,
                    pci->_smMode == SIZEMODE_MMWIDTH);

                //
                //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
                //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
                //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
                //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
                //  See bugs 69335, 72059, et. al. (greglett)
                //
                CCalcInfo       CI(pci);
                CI._grfLayout |= LAYOUT_MEASURE;

                ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
            }

            Reset(FALSE);
            Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cx, -1);
            psize->cy = psize->cx;

            _fMinMaxValid = TRUE;
        }
        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }

    }
    else
    {
        grfReturn = super::CalcSizeCore(pci, psize);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CInputFileLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

LONG
CInputLayout::GetMaxLength()
{
    switch (GetType())
    {
    case htmlInputText:
    case htmlInputPassword:
        return DYNCAST(CInput, ElementOwner())->GetAAmaxLength();
    default:
        return super::GetMaxLength();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::MeasureInputFileCaption
//
//  Synopsis:   Measure the button's caption for Input File.
//
//  Note:       Measuring needs to be done by ourselves as there's no underlying
//              TextSite for this faked button.
//
//----------------------------------------------------------------------------
HRESULT
CInputFileLayout::MeasureInputFileCaption(SIZE * psize, CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    int i;
    long lWidth, lCharWidth;
    TCHAR * pch;
    CCcs ccs;

    Assert(psize);
    Assert(GetType() == htmlInputFile);

    CInput          *pInputFile     = DYNCAST(CInput, ElementOwner());

    if ( -1 == pInputFile->_icfButton )
    {
        CCharFormat cf = *GetFirstBranch()->GetCharFormat();
        LOGFONT lf;
        LONG icf;

        DefaultFontInfoFromCodePage( g_cpDefault, &lf, pci->_pDoc );

        cf.SetFaceName(lf.lfFaceName);

        cf._fBold = lf.lfWeight >= FW_BOLD;
        cf._fItalic = lf.lfItalic;
        cf._fUnderline = lf.lfUnderline;
        cf._fStrikeOut = lf.lfStrikeOut;

        cf._wWeight = (WORD)lf.lfWeight;

        cf._lcid = GetUserDefaultLCID();
        cf._bCharSet = lf.lfCharSet;
        cf._fNarrow = IsNarrowCharSet(lf.lfCharSet);
        cf._bPitchAndFamily = lf.lfPitchAndFamily;

        cf._bCrcFont = cf.ComputeFontCrc();
        cf._fHasDirtyInnerFormats = !!cf.AreInnerFormatsDirty();

        hr = TLS( _pCharFormatCache )->CacheData( & cf, & icf );

        if (hr)
            goto Cleanup;

        pInputFile->_icfButton = SHORT(icf);
    }

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, GetCharFormatEx(pInputFile->_icfButton)))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lWidth = 0;
    for ( i = _cchButtonCaption,
            pch = _pchButtonCaption;
          i > 0;
          i--, pch++ )
    {
        if ( ! ccs.Include(*pch, lCharWidth) )
        {
            Assert(0 && "Char not in font!");
        }

        lWidth += lCharWidth;
    }

    psize->cx = lWidth;
    psize->cy = ccs.GetBaseCcs()->_yHeight;

    ccs.Release();

Cleanup:
    RRETURN(hr);
}
void
CInputFileLayout::ComputeInputFileBorderInfo(CDocInfo *pdci, CBorderInfo & BorderInfo)
{
    CInput *    pInput  = DYNCAST(CInput, ElementOwner());
    CDocInfo    DocInfo;
    int         i;

    if (!pdci)
    {
        pdci = &DocInfo;
        pdci->Init(pInput);
    }

    pInput->_fRealBorderSize = TRUE;
    pInput->GetBorderInfo( pdci, &BorderInfo);
    pInput->_fRealBorderSize = FALSE;

    Assert(SIDE_TOP < SIDE_RIGHT);
    Assert(SIDE_RIGHT < SIDE_LEFT);
    Assert(SIDE_TOP < SIDE_BOTTOM);
    Assert(SIDE_BOTTOM < SIDE_LEFT);

    for (i = SIDE_TOP; i <= SIDE_LEFT; i ++)
    {
        if (BorderInfo.abStyles[i] != fmBorderStyleSunken)
            continue;
        if (!BTN_PRESSED(pInput->_wBtnStatus))
        {
            BorderInfo.abStyles[i]= fmBorderStyleRaised;
        }
    }

    BorderInfo.wEdges = BF_RECT | BF_SOFT;

    GetBorderColorInfoHelper( GetFirstBranch()->GetCharFormat(), GetFirstBranch()->GetFancyFormat(), &GetFirstBranch()->GetFancyFormat()->_bd, pdci, &BorderInfo, FALSE);    // Need to pick up the colors, etc.
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::ComputeButtonSize
//
//  Synopsis:   Measure the button's caption.
//
//  Note:       Measuring needs to be done by ourselves as there's no underlying
//              TextSite for this faked button.
//
//----------------------------------------------------------------------------
HRESULT
CInputFileLayout::ComputeInputFileButtonSize(CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    SIZE        sizeText;
    CBorderInfo bInfo;
    int         uitotalBXWidth;
    // default horizontal offset size is 4 logical pixels
    int         uiMinInsetH = pci->DeviceFromDocPixelsX(4);
    HTHEME      hTheme = ElementOwner()->GetTheme(THEME_BUTTON);

    CInput *    pInput = DYNCAST(CInput, ElementOwner());
    
    hr = THR(MeasureInputFileCaption(&sizeText, pci));
    if ( hr )
        goto Error;

    if (hTheme)
    {
        CRect           rcTheme;

        hr = THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            BP_PUSHBUTTON, 
                                            DYNCAST(CInput, ElementOwner())->GetThemeState(), 
                                            &g_Zero.rc, 
                                            &rcTheme
                                        ));

        if(hr)
            goto Cleanup;

        bInfo.aiWidths[SIDE_LEFT]   = pci->DeviceFromDocPixelsX(-rcTheme.left);
        bInfo.aiWidths[SIDE_RIGHT]  = pci->DeviceFromDocPixelsX(rcTheme.right);
        bInfo.aiWidths[SIDE_TOP]    = pci->DeviceFromDocPixelsY(-rcTheme.top);
        bInfo.aiWidths[SIDE_BOTTOM] = pci->DeviceFromDocPixelsY(rcTheme.bottom);

    }
    else
    {
        pInput->_fRealBorderSize = TRUE;
        pInput->GetBorderInfo(pci, &bInfo, FALSE, FALSE);
        pInput->_fRealBorderSize = FALSE;
    }

    uitotalBXWidth = bInfo.aiWidths[SIDE_RIGHT] + bInfo.aiWidths[SIDE_LEFT];    

    _xCaptionOffset = sizeText.cx / 2 - uitotalBXWidth;

    // we should have a min offset
    if (_xCaptionOffset < uiMinInsetH)
    {
        _xCaptionOffset = uiMinInsetH;
    }

    _sizeButton.cx = sizeText.cx + _xCaptionOffset + uitotalBXWidth;

    // only remember the text height of the button
    _sizeButton.cy = sizeText.cy;;

    _xCaptionOffset = _xCaptionOffset >> 1;

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::RenderInputFileButtonContent
//
//  Synopsis:   Render.
//
//  Note:       We draw the fake button image here
//
//----------------------------------------------------------------------------

void
CInputFileLayout::RenderInputFileButton(CFormDrawInfo *pDI)
{
    CBorderInfo BorderInfo;
    RECT rcClip;
    RECT rcCaption;
    CRect rcButton;
    SIZE sizeClient;
#ifdef WIN16
    GDIRECT rc, *pRect;
    pRect = &rc;
#else
    RECT *pRect = &rcClip;
#endif
    XHDC hdc = pDI->GetDC(TRUE);
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    CMarkup * pMarkupOwner = GetOwnerMarkup();

    CInput          *pInput = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pInput->GetTheme(THEME_BUTTON);
    BOOL            fThemed = FALSE;

    long lOffsetX, lOffsetY;
    CCcs ccs;
    DWORD dwDCObjType       = GetObjectType(hdc);
    const CCharFormat * pcf = GetCharFormatEx( pInput->_icfButton );

    if (!fc().GetCcs(&ccs, hdc, pDI, pcf ))
        return;

    ComputeInputFileBorderInfo(pDI, BorderInfo);    // Need to pick up the colors, etc.

    FONTIDX hfontOld = ccs.PushFont(hdc);

    GetSize(&sizeClient);

    if(!fRightToLeft)
    {
        rcButton.left = sizeClient.cx - _sizeButton.cx;
        rcButton.right = sizeClient.cx;
    }
    else
    {
        // when RTL the button goes on the left the the text input
        rcButton.left = 0;
        rcButton.right = _sizeButton.cx;
    }

    rcButton.top = 0;
    rcButton.bottom = sizeClient.cy;

    if (    hTheme 
        &&  hdc.DrawThemeBackground(   hTheme,
                                        BP_PUSHBUTTON,
                                        pInput->GetThemeState(),
                                        &rcButton,
                                        NULL))
    {
        fThemed = TRUE;
    }
    else
    {
        ::DrawBorder(pDI, &rcButton, &BorderInfo);
        SetBkColor  (hdc, GetSysColorQuick(COLOR_BTNFACE));
    }

    if(!fRightToLeft)
    {
        rcCaption.left = sizeClient.cx - _sizeButton.cx
                        + BorderInfo.aiWidths[SIDE_LEFT];
        rcCaption.right = sizeClient.cx - BorderInfo.aiWidths[SIDE_RIGHT];
    }
    else
    {
        rcCaption.left = BorderInfo.aiWidths[SIDE_LEFT];
        rcCaption.right = _sizeButton.cx - BorderInfo.aiWidths[SIDE_RIGHT];
    }

    rcCaption.top = BorderInfo.aiWidths[SIDE_TOP];
    rcCaption.bottom = sizeClient.cy - BorderInfo.aiWidths[SIDE_BOTTOM];

    lOffsetX = _xCaptionOffset
             + pDI->DeviceFromDocPixelsX(BTN_PRESSED(pInput->_wBtnStatus) ? 1 : 0);

    lOffsetY = max (0L, (LONG)((rcCaption.bottom - rcCaption.top - _sizeButton.cy) / 2))
             + pDI->DeviceFromDocPixelsY(BTN_PRESSED(pInput->_wBtnStatus) ? 1 : 0);
    IntersectRect(&rcClip, &rcCaption, pDI->ClipRect());

    // fix for printing

    if (   pMarkupOwner
        && pMarkupOwner->IsPrintMedia()
        && pMarkupOwner->PaintBackground()
        && (dwDCObjType == OBJ_ENHMETADC || dwDCObjType == OBJ_METADC)
       )
    {
        BitBlt(hdc,
                    rcCaption.left,
                    rcCaption.top,
                    rcCaption.right  - rcCaption.left,
                    rcCaption.bottom - rcCaption.top,
                    hdc, 0, 0, WHITENESS);
        PatBltBrush(hdc,
                    &rcCaption, PATCOPY,
                    GetSysColorQuick(COLOR_BTNFACE));
    }


    if (!pInput->IsEnabled())
    {
        SetTextColor(hdc,  GetSysColorQuick(COLOR_3DHILIGHT));
        VanillaTextOut(&ccs,
                        hdc,
                        rcCaption.left + lOffsetX + 1,
                        rcCaption.top + lOffsetY + 1,
                        fThemed ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED,
                        pRect,
                        _pchButtonCaption
                            ? _pchButtonCaption
                            : g_Zero.ach,
                        _cchButtonCaption,
                        g_cpDefault,
                        NULL);
        SetTextColor(hdc, GetSysColorQuick(COLOR_3DSHADOW));
    }
    else
    {
        SetTextColor(hdc, GetSysColorQuick(COLOR_BTNTEXT));
    }   

    VanillaTextOut( &ccs,
                    hdc,
                    rcCaption.left + lOffsetX,
                    rcCaption.top + lOffsetY,
                    fThemed ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED,
                    pRect,
                    _pchButtonCaption
                        ? _pchButtonCaption
                        : g_Zero.ach,
                    _cchButtonCaption,
                    g_cpDefault,
                    NULL);
    
    ccs.PopFont(hdc, hfontOld);
    ccs.Release();
}


void CInputFileLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{    
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CBorderInfo     bi;
    RECT            rc, rcButton;
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    HTHEME          hTheme = ElementOwner()->GetTheme(THEME_EDIT);

    DYNCAST(CInput, ElementOwner())->_fRealBorderSize = TRUE;
    Verify(ElementOwner()->GetBorderInfo(pDI, &bi, TRUE));
    DYNCAST(CInput, ElementOwner())->_fRealBorderSize = FALSE;
    
    rc = rcButton = *prcBounds;
    
    if(!fRightToLeft)
    {
        rc.right = rc.right - _sizeButton.cx 
                            - pDI->DeviceFromDocPixelsX(CInput::cxButtonSpacing);
        rcButton.left = rc.right;
    }
    else
    {
        rc.left = rc.left + _sizeButton.cx 
                            + pDI->DeviceFromDocPixelsX(CInput::cxButtonSpacing);
        rcButton.right = rc.left;
    }

    if (hTheme)
    {
        XHDC            hdc     = pDI->GetDC(TRUE);               
        RECT            rcTheme = rc;
        
        hdc.DrawThemeBackground(hTheme, EP_EDITTEXT, ETS_NORMAL, &rcTheme, NULL);
    }
    else
    {
        ::DrawBorder(pDI, &rc, &bi);
    }

    RenderInputFileButton(pDI);

    // We only want to paint selection on the button rect in this part
    // The client portion of the selection is handled in the DrawClient
    // method of this class. This way any text in the client will be
    // correctly painted with the selection.
    if (_fTextSelected)
    {
        DrawTextSelectionForRect(pDI->GetDC(), (CRect *)& rcButton ,& pDI->_rcClip , _fSwapColor);
    }


}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::DrawClient
//
//  Synopsis:   Draw client rect part of the controls
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CInputFileLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    {
        // we set draw surface information separately for Draw() and
        // the stuff below, because the Draw method of some subclasses
        // (like CFlowLayout) puts pDI into a special device coordinate
        // mode
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        Draw(pDI);
    }

    {
        // see comment above
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

        // We only want to paint selection on the client rect in this part
        // The button portion of the selection is handled in the DrawClientBorder
        // method of this class
        if (_fTextSelected)
        {
            DrawTextSelectionForRect(pDI->GetDC(), (CRect *)prcRedraw ,& pDI->_rcClip , _fSwapColor);
        }


        // just check whether we can draw zero border at design time
        if (IsShowZeroBorderAtDesignTime())
        {
            CLayout* pParentLayout = GetUpdatedParentLayout();

            if ( pParentLayout && pParentLayout->IsEditable() )
            {
                 DrawZeroBorder(pDI);
            }
        }
    }
}

void
CInputFileLayout::GetButtonRect(RECT *prc)
{
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);

    Assert(prc);
    GetRect(prc, COORDSYS_BOX);
    if(!fRightToLeft)
        prc->left = prc->right - _sizeButton.cx;
    else
        prc->right = prc->left + _sizeButton.cx;
}

//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a tree notification
//
//  Arguments:  pnf - Pointer to the tree notification
//
//-----------------------------------------------------------------------------
void
CInputFileLayout::Notify(CNotification * pnf)
{
    if (pnf->IsTextChange())
    {
        // NOTE (jbeda): this may not be reliable -- what if a script
        // in a different frame (or a child frame) pushes a message loop
        // and we continue parsing...  Better safe than sorry, I guess.
        Assert(ElementOwner()->GetWindowedMarkupContext()->GetWindowPending());
        if (ElementOwner()->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript())
        {
            DYNCAST(CInput, ElementOwner())->_fDirtiedByOM = TRUE;
        }
    }
    super::Notify(pnf);
}

void CInputTextLayout::GetDefaultSize(CCalcInfo *pci, SIZE &psize, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    long            rgPadding[SIDE_MAX];
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CInput        * pInput = DYNCAST(CInput, ElementOwner());
    int             charX = 1;
    int             charY = 1;
    BOOL            fMinMax =   (   pci->_smMode == SIZEMODE_MMWIDTH 
                                ||  pci->_smMode == SIZEMODE_MINWIDTH   );
    charX = pInput->GetAAsize();
    Assert(charX > 0);

    if (    ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        GetDisplay()->GetPadding(pci, rgPadding, fMinMax);
    }
    else
    {
        // 
        // (olego) In compat rendering mode always apply default padding (==1)
        // Reasons : 
        // 1) backward copmatibility with IE 5.5
        // 2) CDisplay::GetPadding() returns bogus result when paddings are %'s;
        // 
        rgPadding[SIDE_LEFT]    = 
        rgPadding[SIDE_RIGHT]   = pci->DeviceFromDocPixelsX(1);
        rgPadding[SIDE_TOP]     = 
        rgPadding[SIDE_BOTTOM]  = pci->DeviceFromDocPixelsY(1);
    }

    GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);

    psize.cx = (charX -1) * sizeFontForLongStr.cx
                    + sizeFontForShortStr.cx
                    + rgPadding[SIDE_LEFT]
                    + rgPadding[SIDE_RIGHT];
    psize.cy = charY * sizeFontForLongStr.cy
                    + rgPadding[SIDE_TOP]
                    + rgPadding[SIDE_BOTTOM];

    AdjustSizeForBorder(&psize, pci, TRUE);

    *fHasDefaultWidth = TRUE;
    *fHasDefaultHeight= TRUE;
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.
BOOL
CInputButtonLayout::GetInsets(SIZEMODE smMode, SIZE &size, SIZE &sizeText, BOOL fw, BOOL fh, const SIZE &sizeBorder)
{
    CCalcInfo       CI(this);
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CBtnHelper *    pBtnHelper = GetBtnHelper();
    
    GetFontSize(&CI, &sizeFontForShortStr, &sizeFontForLongStr);

    // if half of text size is less than the size of the netscape border
    // we need to make sure we display at least one char
    if (!fw && (sizeText.cx - sizeBorder.cx - sizeFontForLongStr.cx < 0))
    {
        sizeText.cx = sizeFontForLongStr.cx + CI.DeviceFromDocPixelsX(2) + sizeText.cx;
    }
    else
    {
        size.cx = max((long)CI.DeviceFromDocPixelsX(2), fw ? (size.cx - sizeText.cx)
                             : ((sizeText.cx - sizeBorder.cx)/2 - CI.DeviceFromDocPixelsX(6)));

        if (!fw)
        {
            sizeText.cx = size.cx + sizeText.cx;
        }
    }

    //
    // text centering is done through alignment
    //

    size.cx = 0;
    pBtnHelper->_sizeInset.cx = 0;

    if (smMode == SIZEMODE_MMWIDTH)
    {
        sizeText.cy = sizeText.cx;
        pBtnHelper->_sizeInset = g_Zero.size;
    }
    else
    {
        // vertical inset is 1/2 of font height
        size.cy = fh    ? (size.cy - sizeText.cy)
            : (sizeFontForShortStr.cy/2 - (sizeBorder.cy ? CI.DeviceFromDocPixelsY(6) : CI.DeviceFromDocPixelsY(4)));

        size.cy = max((long)CI.DeviceFromDocPixelsY(1), size.cy);
            
        sizeText.cy =   max(sizeText.cy, sizeFontForShortStr.cy + sizeBorder.cy)        
            + size.cy;

           
        if (size.cy < CI.DeviceFromDocPixelsY(3) && !fh)
        {        
            // for netscape compat            
            size.cy = 0;
        }

        pBtnHelper->_sizeInset.cy = size.cy / 2;
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInputButtonLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the button layout contains the point
//
//----------------------------------------------------------------------------

BOOL
CInputButtonLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CInput  *       pElem = DYNCAST(CInput, ElementOwner());
    CHitTestInfo *  phti = (CHitTestInfo *) pClientData;
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    BOOL            fRet = TRUE;
    RECT            rcClient;
    WORD            wHitTestCode;
    HRESULT         hr = S_OK;

    if (!hTheme)
    {
        fRet = super::HitTestContent(   pptHit,
                                        pDispNode,
                                        pClientData,
                                        fDeclinedByPeer);
        goto Cleanup;
    }

    Assert(pElem);

    GetClientRect(&rcClient);

    hr = HitTestThemeBackground(    hTheme,
                                    NULL,
                                    BP_PUSHBUTTON,
                                    pElem->GetThemeState(),
                                    0,
                                    &rcClient,
                                    NULL,
                                    *pptHit,
                                    &wHitTestCode);

    if (SUCCEEDED(hr) && wHitTestCode == HTNOWHERE)
    {
        fRet = FALSE;
        phti->_htc = HTC_NO;
        goto Cleanup;
    }

    fRet = super::HitTestContent(pptHit,
                                pDispNode,
                                pClientData,
                                fDeclinedByPeer);

Cleanup:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\olelyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       olelyt.cxx
//
//  Contents:   Implementation of COleayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_EOBJECT_HXX
#define X_EOBJECT_HXX
#include "eobject.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#define ALWAYS_DEFER_SET_WINDOW_RGN

DeclareTag(tagOleRgn, "OleLayout", "Fill window region");
#if defined(ALWAYS_DEFER_SET_WINDOW_RGN)
DeclareTag(tagDeferSetWindowRgn, "OleLayout", "Don't defer SetWindowRgn");
#else
DeclareTag(tagDeferSetWindowRgn, "OleLayout", "Always defer SetWindowRgn");
#endif

MtDefine(COleLayout, Layout, "COleLayout");

ExternTag(tagOleSiteRect);
ExternTag(tagViewHwndChange);
ExternTag(tagCalcSize);

extern BOOL IntersectRectE (RECT * prRes, const RECT * pr1, const RECT * pr2);


const CLayout::LAYOUTDESC COleLayout::s_layoutdesc =
{
    0, // _dwFlags
};


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Reset
//
//  Synopsis:   Remove the object's HWND from the view's caches.
//
//----------------------------------------------------------------------------

void
COleLayout::Reset(BOOL fForce)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    HWND hwnd = pSiteOle->GetHwnd();
    
    if (hwnd != NULL)
    {
        GetView()->CleanupWindow(hwnd);
    }
    
    super::Reset(fForce);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Draw
//
//  Synopsis:   Draw the object.
//
//----------------------------------------------------------------------------

void
COleLayout::Draw(CFormDrawInfo * pDI, CDispNode *)
{
    CDoc     *  pDoc     = Doc();
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    INSTANTCLASSINFO * pici;
    BOOL fInplacePaint = pDI->_fInplacePaint && IsInplacePaintAllowed();

    
    Assert(pSiteOle);

    // inplace paint should be disabled if we have print delegate here.
    if (pSiteOle->_hemfSnapshot)
        fInplacePaint= FALSE;
    
    ////
    //
    // IN_PLACE PAINT
    //
    ////
    if (fInplacePaint)
    {
        Assert(pDI->_dwDrawAspect == DVASPECT_CONTENT);

        if (pSiteOle->_state == OS_OPEN)
        {
#ifndef WINCE
            XHDC    hdc = pDI->GetGlobalDC(TRUE);
            HBRUSH  hbr;

            hbr = CreateHatchBrush(
                            HS_DIAGCROSS,
                            GetSysColorQuick(COLOR_WINDOWFRAME));
            if (hbr)
            {
                FillRect(hdc, &pDI->_rc, hbr);
                DeleteObject(hbr);
            }
#endif // WINCE
            goto Cleanup;
        }
        else if (pSiteOle->_state >= OS_INPLACE &&
                 !pSiteOle->_fWindowlessInplace)
        {
            TraceTagEx((tagOLEWatch,
                TAG_NONAME,
                "TRIDENT Draw with _state >= OS_INPLACE && !_fWindowlessInplace, site %x",
                pSiteOle));

#if DBG==1
            if (IsTagEnabled(tagOleRgn))
            {
                HWND    hwnd = pSiteOle->GetHwnd();
                HDC     hdc  = ::GetDC(hwnd);
                HBRUSH  hbr  = ::CreateSolidBrush((COLORREF)0x000000FF);
                HRGN    hrgn = ::CreateRectRgnIndirect(&g_Zero.rc);

                ::GetWindowRgn(hwnd, hrgn);
                ::FillRgn(hdc, hrgn, hbr);

                ::DeleteObject(hrgn);
                ::DeleteObject(hbr);
                ::ReleaseDC(hwnd, hdc);
            }
#endif

            goto Cleanup;
        }
    }

    ////
    //
    // not in-place
    //
    ////

    Assert((pDI->_rc.right - pDI->_rc.left)
        && (pDI->_rc.bottom - pDI->_rc.top));
    
    // Don't draw unless:
    //
    //  1)  Object is windowless inplace...  or...
    //  2)  Baseline state is less than OS_INPLACE... or...
    //  3)  We're not drawing into the inplace dc (someone else called
    //      IVO::Draw on trident itself)... or...
    //  4)  The control is oc96 or greater.  This is because atl has
    //      a bug where it totally ignores the pfNoRedraw argument of
    //      IOleInPlaceSiteEx::OnInPlaceActivateEx.  If we didn't do
    //      the IVO::Draw here, the control would never paint.
    //      ie4 bug 54603.  (anandra)
    //  5)  There is a metafile snapshot to be used in printing or print preview
    //
    // Otherwise calling IVO::Draw would likely leave a "ghost" image
    // that would soon be replaced when activation occurs - leading to
    // flicker...  (philco)
    //
    pici = pSiteOle->GetInstantClassInfo();

    //
    // If we have a metafile snapshot, just play it!
    //
    if (pSiteOle->_hemfSnapshot)
    {
        XHDC    hdc = pDI->GetGlobalDC(!ElementOwner()->GetMarkupPtr()->IsPrintMedia());
        
        // CAUTION: getting raw DC. We must be careful with what we do to it.
        HDC rawHDC = hdc.GetOleDC();
        // who knows what the control will do to the DC?  The Windows Media
        // Player changes the palette, for example (bug 76819)
        int nSavedDC = ::SaveDC(rawHDC);
        Assert(nSavedDC);
        
        // XHDC::PlayEnhMetafile() takes care of transformations.
        Assert(!fInplacePaint);

        // Let's assert that rect is zero-based. 
        // It would be easy to handle an offset, but it doesn't look like we ever have it.
        Assert(pDI->_rc.TopLeft() == g_Zero.pt);

        CDocInfo const *pdciDefault  = &Doc()->_dciRender;
        CRect           rcBoundsPlay;
        ENHMETAHEADER   emfh = {EMR_HEADER, sizeof(emfh)};

        if (GetEnhMetaFileHeader(pSiteOle->_hemfSnapshot, sizeof(emfh), &emfh))
        {
            extern CRect ComputeEnhMetaFileBounds(ENHMETAHEADER *pemh);

            RECTL rcFrameHM = emfh.rclFrame;
            long  lFrameWidth = rcFrameHM.right - rcFrameHM.left;
            long  lFrameHeight = rcFrameHM.bottom - rcFrameHM.top;

            rcBoundsPlay = ComputeEnhMetaFileBounds(&emfh);

            // convert to layout resolution
            CSize const& defRes = pdciDefault->GetResolution();
            rcBoundsPlay.left   = IntNear(double(rcBoundsPlay.left  ) * HIMETRIC_PER_INCH / defRes.cx * pDI->_rc.Width()  / lFrameWidth );
            rcBoundsPlay.top    = IntNear(double(rcBoundsPlay.top   ) * HIMETRIC_PER_INCH / defRes.cy * pDI->_rc.Height() / lFrameHeight);
            rcBoundsPlay.right  = IntNear(double(rcBoundsPlay.right ) * HIMETRIC_PER_INCH / defRes.cx * pDI->_rc.Width()  / lFrameWidth );
            rcBoundsPlay.bottom = IntNear(double(rcBoundsPlay.bottom) * HIMETRIC_PER_INCH / defRes.cy * pDI->_rc.Height() / lFrameHeight);
        }

        //
        // Play metafile
        //
        WHEN_DBG(BOOL f = )
                PlayEnhMetaFile(hdc, pSiteOle->_hemfSnapshot, &rcBoundsPlay);
        AssertSz(f, "PlayEnhMetaFile");
        WHEN_DBG(GetLastError();)
        
        // restore DC
        Verify(::RestoreDC(rawHDC, nSavedDC));
    }
    //
    // Do the work to Call IViewObject::Draw
    //
    else if (   pSiteOle->_pVO
             && (   pSiteOle->_fWindowlessInplace
                 || (pSiteOle->BaselineState(pDoc->State()) < OS_INPLACE)
                 || !fInplacePaint
                 || (pici && pici->IsOC96()
                )))
    {
        XHDC    hdc = pDI->GetGlobalDC(!ElementOwner()->GetMarkupPtr()->IsPrintMedia());
        POINT   ptBrushOriginSave, ptViewportOrigin, ptNewBrushOrigin;
        BOOL    fBrushOrgChanged;

        ptBrushOriginSave = g_Zero.pt;  // this is just to appease the LINT (alexa)
        Assert( !_pElementOwner->_fSurface ||  pDI->IsMemory() ||  ElementOwner()->GetMarkupPtr()->IsPrintMedia() 
               || pDI->_fIsMetafile);
        Assert(!(pSiteOle->OlesiteTag() == COleSite::OSTAG_APPLET && ElementOwner()->GetMarkupPtr()->IsPrintMedia()));

        
        // NOTE: The marshalling code for IViewObject::Draw was
        //   not updated to the oc96 spec and thus does not know
        //   about the pvAspect usage.  It returns E_INVALIDARG if
        //   a non-NULL pvAspect is passed in.  So we check to see
        //   if we're talking to an OLE proxy and pass in NULL then.
        //   Otherwise we pass in the default value.
        //   (anandra) Apr-16-97.
        //
        // The MultiMedia Structured Graphics control mmsgrfxe.ocx
        // expects us to manage their brush origin.  Although the
        // contract does not state we have to, and MSDN in fact states
        // they should not count on the brush origin, it is fairly
        // easy for us to do it here so we extend this nice gesture.
        //
        // The issue is that whenever they move about on the screen
        // the brush origin must move with them so that any patterns
        // which are brushed onto their images remain aligned.  Also,
        // our off-screen rendering into a memory DC complicates things
        // by moving the viewport origin.
        //
        fBrushOrgChanged = GetViewportOrgEx(hdc, &ptViewportOrigin);
        if (fBrushOrgChanged)
        {
            ptNewBrushOrigin.x = (ptViewportOrigin.x + pDI->_rc.left) % 8;
            if( ptNewBrushOrigin.x < 0 )
                ptNewBrushOrigin.x += 8;
            ptNewBrushOrigin.y = (ptViewportOrigin.y + pDI->_rc.top) % 8;
            if( ptNewBrushOrigin.x < 0 )
                ptNewBrushOrigin.y += 8;

            fBrushOrgChanged = SetBrushOrgEx(
                            hdc,
                            ptNewBrushOrigin.x,
                            ptNewBrushOrigin.y,
                            &ptBrushOriginSave );
        }

        //
        // Save DC
        //
        
        // CAUTION: getting raw DC. We must be careful with what we do to it.
        HDC rawHDC = hdc.GetOleDC();
        
        // who knows what the control will do to the DC?  The Windows Media
        // Player changes the palette, for example (bug 76819)
        int nSavedDC = ::SaveDC(rawHDC);
        Assert(nSavedDC);

        // a windowless in-place control expects to render at the coordinates
        // it was given in SetObjectRects.  We oblige by manipulating the
        // viewport origin so it will render in the correct place.  This is
        // especially important for filtered controls, since the offscreen
        // buffer kept by the filter has a different coordinate system than
        // the one that was used when SetObjectRects was called.
        BOOL fCompatNeetsZeroBasedDrawRect = pici && (pici->dwCompatFlags & COMPAT_NEEDSZEROBASEDDRAWRECT);
        BOOL fSetViewportOrg = (fInplacePaint || pDI->_fIsMetafile) 
                             && (pSiteOle->_fWindowlessInplace || fCompatNeetsZeroBasedDrawRect);
        RECTL* prc;
        if (fSetViewportOrg)
        {
            prc = NULL;
            CPoint ptOrg = 
                pDI->_rc.TopLeft() + (CSize&)ptViewportOrigin
                - _rcWnd.TopLeft().AsSize();
            ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
        }
        else
        {
            prc = (RECTL*) &pDI->_rc;
        }

        // Transform rectangles.
        // Unfortunately, we have to do it here, since there is no way to 
        // automatically apply transformations IViewObject::Draw
        CRect rcBounds, *prcBounds = (CRect *) prc;
        CRect rcWBounds, *prcWBounds = (CRect *) pDI->_prcWBounds;
        CPoint ptOrg(0,0);

        if (hdc.HasTransform())
        {
            // Note: for rotation, we'll rotate the rectangle, but not the image.
            // In case of non-90 degree rotation, it won't do any good, so this needs more work
            AssertSz(hdc.transform().GetAngle() % 900 == 0, "Non-trivial rotation in COleLayout::Draw");
        
            if (prcBounds)
            {
                rcBounds = *prcBounds;
                hdc.transform().Transform(&rcBounds);
                prcBounds = &rcBounds;
            }
            else
            {
                // If there is no prc, need to apply viewport origin 
                // (see the call to SetViewportOrgEx above, and bugs 90270, 90276). 
                HDC hdcTranslate = NULL; // keep compiler happy
                CSize sizeTranslate = g_Zero.size; // keep compiler happy
                if (hdc.GetTranslatedDC(&hdcTranslate, &sizeTranslate))
                {
                    // offset by translation amount
                    // TODO (donmarsh) -- adding to the viewport org is dangerous under Win9x,
                    // because we might silently exceed GDI's 16-bit limitation.  We just ignore
                    // that possibility for now.
                    Assert(rawHDC == hdcTranslate);
                    ::OffsetViewportOrgEx(rawHDC, sizeTranslate.cx, sizeTranslate.cy, &ptOrg);
                }
                else
                    AssertSz(FALSE, "Can't draw windowless OLE control with complex transformation");
            }

            if (prcWBounds)
            {
                rcWBounds = *prcWBounds;
                hdc.transform().Transform(&rcWBounds);
                prcWBounds = &rcWBounds;
            }
        }

        // some controls don't work if the rcBounds.topleft isn't (0,0).  To
        // accommodate them, we offset the rectangles and the viewport origin.
        if (!prcBounds 
            && fCompatNeetsZeroBasedDrawRect    // app compat hack for home publisher... (bug 99738)
            && !pSiteOle->_fWindowlessInplace)  // ...but not for in-place media player (bug 104531)
        {
            rcBounds.SetRect(CPoint(0,0), pDI->_rc.Size());
            prcBounds = &rcBounds;
        }

        //
        // IViewObject::Draw()
        //        
        THR_OLE( pSiteOle->_pVO->Draw(
            pDI->_dwDrawAspect,
            pDI->_lindex,
            pSiteOle->IsOleProxy()
                ? NULL
                : pDI->_pvAspect,
            pDI->_ptd,
            pDI->_hic.GetOleDC(),
            rawHDC,
            (const RECTL *)prcBounds,
            (const RECTL *)prcWBounds,
            pDI->_pfnContinue,
            pDI->_dwContinue));


        //
        // Restore DC (this restores viewport and brush origins too)
        //
        Verify(::RestoreDC(rawHDC, nSavedDC));

        if (fBrushOrgChanged)
        {
            SetBrushOrgEx(
                    hdc,
                    ptBrushOriginSave.x,
                    ptBrushOriginSave.y,
                    NULL);
        }
    }
    else
    {
        // no _pVO
        //
        if (!(pSiteOle->_pUnkCtrl))
        {
            // object hasn't been created, so we show placeholder for it
            //
            XHDC hdc = pDI->GetGlobalDC(TRUE);
            SIZE sizePrint;
            SIZE sizeGrab = {GRABSIZE, GRABSIZE};
            BOOL fPrint = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
            if (fPrint)
            {
                GetPlaceHolderBitmapSize(
                        pSiteOle->_fFailedToCreate,
                        &sizePrint);
                sizePrint.cx = pDI->DeviceFromDocPixelsX(sizePrint.cx);
                sizePrint.cy = pDI->DeviceFromDocPixelsY(sizePrint.cy);
                sizeGrab.cx = pDI->DeviceFromDocPixelsX(GRABSIZE);
                sizeGrab.cy = pDI->DeviceFromDocPixelsY(GRABSIZE);
            }
            
            DrawPlaceHolder(
                    pDI,
                    hdc,
                    pDI->_rc,
                    NULL, CP_UNDEFINED, 0, 0,  // no alt text
                    &sizeGrab,
                    pSiteOle->_fFailedToCreate,
                    0,
                    pSiteOle->GetBackgroundColor(),
                    fPrint ? &sizePrint : NULL,
                    FALSE,
                    pDI->DrawImageFlags());
        }
        else
        {
            // this is created object does not support _pVO
            if (IsEditable())
            {
                // Draw a rectangle so that we don't see garbage in the site
                //
                XHDC hdc = pDI->GetGlobalDC(TRUE);
                HBRUSH hbrOld;

                hbrOld = (HBRUSH) SelectObject(
                                hdc,
                                GetStockObject(LTGRAY_BRUSH));
                Rectangle(
                        hdc,
                        pDI->_rc.left,
                        pDI->_rc.top,
                        pDI->_rc.right,
                        pDI->_rc.bottom);
                SelectObject(hdc, hbrOld);
            }
            else
            {
                TraceTagEx((tagOLEWatch,
                    TAG_NONAME,
                    "TRIDENT Attempt to draw when ViewObject is NULL, site %x",
                    pSiteOle));
            }
        }
    }

Cleanup:

    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     COleLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------
DWORD
COleLayout::CalcSizeVirtual( CCalcInfo * pci,
                             SIZE *      psize,
                             SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(pci);
    Assert(psize);
    Assert(ElementOwner());
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CScopeFlag      csfCalcing(this);
    CDoc          * pDoc         = Doc();
    CSize           sizeOriginal;
    COleSite *      pSiteOle     = DYNCAST(COleSite, ElementOwner());
    RECT            tmpRect      = { 0, 0, 2048, 2048 };
    int             cxBorder;
    int             cyBorder;
    DWORD           grfReturn;
    INSTANTCLASSINFO * pici;

    CSaveCalcInfo   sci(pci, this);

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    SubtractClientRectEdges(&tmpRect, pci);
    cxBorder = (2048 - tmpRect.right)  + (tmpRect.left - 0);
    cyBorder = (2048 - tmpRect.bottom) + (tmpRect.top  - 0);

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    //
    // If sizing or retrieving min/max, handle it here
    //  otherwise, let super handle it.
    //
    if (!(   IsSizeThis()
          || pci->_smMode == SIZEMODE_MMWIDTH
          || pci->_smMode == SIZEMODE_MINWIDTH
          || pci->_smMode == SIZEMODE_SET)
       )
    {
        DWORD dwRet = super::CalcSizeVirtual(pci, psize, psizeDefault);

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return dwRet;
    }


    {
        IOleObject *    pObject       = NULL;
        BOOL            fHaveWidth    = FALSE;
        BOOL            fHaveHeight   = FALSE;
        BOOL            fDelaySetForPercentInTable = FALSE;
        SIZEL           sizel;
        HRESULT         hr;
        
        CTreeNode * pNode            = GetFirstBranch();
        const CFancyFormat * pFF     = pNode->GetFancyFormat();
        const CCharFormat  * pCF     = pNode->GetCharFormat();
        BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        CPeerHolder      * pPH       = ElementOwner()->GetLayoutPeerHolder();
        POINT              ptDelegateOffset;

        ptDelegateOffset.x = ptDelegateOffset.y = 0;
        sizel = g_Zero.size;

        _fContentsAffectSize = (cuvWidth.IsNullOrEnum() || cuvHeight.IsNullOrEnum());

        //
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                             pPH, pci, *psize, &ptDelegateOffset, psize);

            // now that we have the size, worry about setting the dispnode
            goto SetTheControlSize;
        }

        switch (pci->_smMode)
        {
        case SIZEMODE_MMWIDTH:
        case SIZEMODE_MINWIDTH:
            // If the user didn't specify a size in the html,
            // ask the control for it's preferred size.
            //
            if(PercentWidth())
            {
                psize->cx = 0;
                fHaveWidth = TRUE;
            }

            if(PercentHeight())
            {
                psize->cy = 0;
                fHaveHeight = TRUE;
            }

            // Fall min/max requests through
            // (This is done to allow user specified settings to override
            //  the object's preferred size. Additionally, if the object
            //  does not have a preferred or user set size, the min/max are
            //  the object's current size.)

        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
            // If this control is marked invisible at run time, and we're in
            // browse mode, give it zero size.
            //           
            if ((pSiteOle->_fInvisibleAtRuntime && !IsEditable()) || pSiteOle->_fHidden)
            {
                fHaveWidth = fHaveHeight = TRUE;
                psize->cx = psize->cy = 0;
            }

            // Now see if we can get something directly from the html
            //
            if (!cuvWidth.IsNullOrEnum() && !fHaveWidth)
            {
                psize->cx  = max(0L,
                                 cuvWidth.XGetPixelValue(
                                         pci,
                                         psize->cx,  // Use available space.
                                         pNode->GetFontHeightInTwips(&cuvWidth)));
                psize->cx += cxBorder;
                fHaveWidth = TRUE;
            }
            if (!cuvHeight.IsNullOrEnum() && !fHaveHeight)
            {
                psize->cy   = max(0L,
                                  cuvHeight.YGetPixelValue(
                                         pci,
                                         pci->_sizeParent.cy,
                                         pNode->GetFontHeightInTwips(&cuvHeight)));
                psize->cy += cyBorder;
                fHaveHeight = TRUE;
            }

            // If either the width or height value is missing,
            // fill it in with the object's current size
            //
            if (!fHaveWidth || !fHaveHeight)
            {
                SIZE    size;

                if (!pSiteOle->_hemfSnapshot)
                {
                    hr = THR_OLE(pSiteOle->QueryControlInterface(
                            IID_IOleObject,
                             (void **)&pObject));
                    if (    !hr 
                        &&  pObject )   // (olego) S_OK does not guarantee that pObject is correct. 
                    {
                        hr = THR_OLE(pObject->GetExtent(DVASPECT_CONTENT, &sizel));
                        if (hr && pSiteOle->_state < OS_RUNNING)
                        {
                            hr = THR(pSiteOle->TransitionTo(OS_RUNNING));
                            if (OK(hr))
                            {
                                hr = THR_OLE(pObject->GetExtent(
                                                DVASPECT_CONTENT,
                                                &sizel));
                            }
                        }
                    }
                }
                else
                {
                    ENHMETAHEADER emfh = {EMR_HEADER, sizeof(emfh)};

                    if (GetEnhMetaFileHeader(pSiteOle->_hemfSnapshot, sizeof(emfh), &emfh))
                    {
                        CRect rc(*(RECT *)&emfh.rclFrame);
                        sizel = rc.Size();
                    }

                    hr = S_OK;
                }

                // Use a default size if the request failed
                //
                if (hr)
                {
                    sizel.cx = HimetricFromHPix(16);
                    sizel.cy = HimetricFromVPix(16);
                    hr = S_OK; // so the error does not get propagated
                }

                pci->DeviceFromHimetric(size, sizel);
                size.cx += cxBorder;
                size.cy += cyBorder;

                if (!fHaveWidth)
                {
                    psize->cx = size.cx;
                }
                if (!fHaveHeight)
                {
                    psize->cy = size.cy;
                }
            }

            //
            //  FALL THROUGH
            //

        case SIZEMODE_SET:

            // now that we have a size proposed for the control, we need to 
            // determine if we need to delegate to a layoutBehavior
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                 pPH, pci, *psize, &ptDelegateOffset, psize);
            }

            // This is here because we likely fell through from the above two cases
            // SIZEMODE_NATURAL requests shoudl continue through to set the object's size
            // SIZEMODE_MM/MINWIDTH requests, however, stop here.
            // all four modes (mm, NATURAL, SET) needed to be delegated to the layoutBehavior
            //
            if (   pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
            {
                psize->cy = psize->cx;

                //  At this point we want to update psize with a new information accounting filter 
                //  for MIN MAX Pass inside table cell.
                if (HasMapSizePeer())
                {
                    //  At this point we want to update psize with a new information accounting filter 
                    CRect rectMapped(CRect::CRECT_EMPTY);
                    // Get the possibly changed size from the peer
                    if(DelegateMapSize(*psize, &rectMapped, pci))
                    {
                        psize->cy = psize->cx = rectMapped.Width();
                    }
                }

                if(pci->_smMode == SIZEMODE_MINWIDTH)
                    psize->cy = 0;

                break;
            }

            // If we are asking for something different than last time,
            // then we negotiate with the control.
            //
SetTheControlSize: 
            // for delegation calls, we come here with the size given by the
            // layoutBehavior, and we treat it in just the same manner as if it
            // was a height=? or width=? specification.
            pci->HimetricFromDevice(sizel,
                                    max(0L,(LONG)(psize->cx - cxBorder)),
                                    max(0L,(LONG)(psize->cy - cyBorder)));

            // Spare the effort of size negotiations if the current size 
            // matches the size we have set to the control last time 
            if (sizel.cx != _sizelLast.cx ||
                sizel.cy != _sizelLast.cy)
            {
                Assert(sizel.cx >= 0);
                Assert(sizel.cy >= 0);


                // if we came from a metafile, then there is no need to negotiate for the size.
                // since it will scale into whatever we give it.
                if (!pSiteOle->_hemfSnapshot)
                {
                    // Need to be running to set the size.
                    //
                    if (!pObject)
                    {
                        pSiteOle->QueryControlInterface(
                                IID_IOleObject,
                                (void **)&pObject);
                    }

                    if (pObject)
                    {

                        // Control must be at least running to set the extent.
                        if (pSiteOle->State() < OS_RUNNING)
                        {
                            IGNORE_HR(pSiteOle->TransitionTo(OS_RUNNING));
                        }

                        // The CDK implementation of IOleObject::SetExtent calls
                        // IOleInplaceSite::OnPosRectChange with the old position
                        // of the control.  We note that we are setting the extent
                        // in order to give OnPosRectChange a reasonable answer.
                        //
                        _sizelLast = sizel;

                        //
                        // percent sized objects in tables often come through on the 
                        // first calc pass with a 0 size.  then on the set pass they get
                        // their real size.  Doing 2 setextents on a windowed control
                        // causes really ugly flashing. This hack is here to not do the 
                        // setextent to a 0 size, and is dependent on the second calc
                        // coming through and giving us a size.  we ONLY bail if this is 
                        // not the setPosition pass.  that way we are gaurenteed to ensure
                        // the dispnode and transition the control
                        //
                        fDelaySetForPercentInTable =    fHaveHeight
                                                     && cuvHeight.IsPercent()
                                                     && pci->_fTableCalcInfo
                                                     && ((CTableCalcInfo*)pci)->_pRowLayout //  this means that we are inside TD or TH 
                                                                                            //  but not a caption or TC.
                                                     && !((CTableCalcInfo*)pci)->_fSetCellPosition;

                        if (!fDelaySetForPercentInTable)
                        {

                            pici = pSiteOle->GetInstantClassInfo();

                            // If pici is NULL, we don't know if COMPAT_NO_SETEXTENT
                            // is set. If this is the case, do not set the extent.
                            //
                            if (pici && !(pici->dwCompatFlags & COMPAT_NO_SETEXTENT))
                            {
                                SIZEL   sizelTemp;

                                {
                                    CElement::CLock lock1(pSiteOle, CElement::ELEMENTLOCK_RECALC);
                                    COleSite::CLock lock2(pSiteOle, COleSite::OLESITELOCK_SETEXTENT);

                                    hr = THR_OLE(pObject->SetExtent(
                                            DVASPECT_CONTENT,
                                            &sizel));
                                }

                                // Some controls don't listen to what we tell them,
                                // so ask the control again about how large it wants
                                // to be.  Basically the control has veto power
                                // over what the html says
                                //
                                if (OK(THR_OLE(pObject->GetExtent(
                                            DVASPECT_CONTENT,
                                            &sizelTemp))))
                                {
                                    _sizelLast = sizel = sizelTemp;
                                }

                                // Reset sizel to zero if we're invisibleatruntime
                                // The ms music control responds with non-zero extent
                                // even after SetExtent(0).  IE4 bug 36598. (anandra)
                                //
                                if ((pSiteOle->_fInvisibleAtRuntime && !IsEditable()) || pSiteOle->_fHidden)
                                {
                                    sizel.cx = sizel.cy = 0;
                                }
                            }
                        }
                    }
                }
            }

            // Take whatever we have at this point as the size.
            //
            pci->DeviceFromHimetric(*psize, sizel);

            // Add in any hspace/vspace and borders.
            //
            psize->cx += cxBorder;
            psize->cy += cyBorder;

            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
            {
                SetPositionAware();
                SetInsertionAware();

                grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }

            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize);
            }

            //if there is a map size peer (like glow filter) that silently modifies the size of
            //the disp node, ask what the size is..
            if(HasMapSizePeer())
                GetApparentSize(psize);

            //
            //  Ensure baseline state
            //
            
            if (pSiteOle->_pUnkCtrl && !fDelaySetForPercentInTable) 
            {
                OLE_SERVER_STATE os = pSiteOle->BaselineState(pDoc->State());

                if (os > pSiteOle->State())
                    pDoc->GetView()->DeferTransition(pSiteOle);
            }

            break;

        default:
            Assert(0);
            break;
        }

        ReleaseInterface(pObject);
    }

    //(dmitryt) call and ignore result - it will use "window detection" code in GetHwnd
    //some tricky (ie smart) controls postpone creation of their window after Activate() 
    //call until container tells them their extent. So they get a window at this point, 
    //after we told then their size. GetHwnd() has a code that catches newborn window
    //and sets some internal vars.
    pSiteOle->GetHwnd();

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+------------------------------------------------------------------------
//
//  Member:     GetMarginInfo
//
//  Synopsis:   add hspace/vspace into the CSS margin
//
//-------------------------------------------------------------------------

void
COleLayout::GetMarginInfo(CParentInfo * ppri,
                          LONG        * plLMargin,
                          LONG        * plTMargin,
                          LONG        * plRMargin,
                          LONG        * plBMargin)
{
    super::GetMarginInfo(ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        CObjectElement * pObject = DYNCAST(CObjectElement, ElementOwner());
        BOOL fParentVertical = pObject->GetFirstBranch()->IsParentVertical();
        LONG lhMargin = fParentVertical ? pObject->GetAAvspace() : pObject->GetAAhspace();
        LONG lvMargin = fParentVertical ? pObject->GetAAhspace() : pObject->GetAAvspace();

        if (lhMargin < 0)
            lhMargin = 0;
        if (lvMargin < 0)
            lvMargin = 0;

        lhMargin = ppri->DeviceFromDocPixelsX(lhMargin);
        lvMargin = ppri->DeviceFromDocPixelsY(lvMargin);

        if (plLMargin)
            *plLMargin += lhMargin;
        if (plRMargin)
            *plRMargin += lhMargin;
        if (plTMargin)
            *plTMargin += lvMargin;
        if (plBMargin)
            *plBMargin += lvMargin;
    }
}

#if 1
// TODO (donmarsh) - IE 4 used the following routine to handle extra
// invalidation, which is necessary if we have an asynchronously-drawn OLE
// control.  This actually causes performance degradation for scrolling of
// all OLE controls (not just asynchronous ones), and visible flashing.
// To fix, we need to grab a lock that prevents anything from drawing to the
// screen before our deferred set object rects call is complete.  There isn't
// enough time to make such a drastic change before our beta 2 release, we
// should review this for RTM version.

//+-----------------------------------------------------------------------------
//
// Synopsis:   in assumption that rcOld rectangle was shifted along one axis to
//             rectangle rcNew, this function finds the rectangle of difference
//             between rcOld and rcNew. [if the shift was along 2 axes then the
//             difference will be non-rectangular area]
//
//------------------------------------------------------------------------------
static BOOL
FindRectAreaDifference (CRect * prcRes, const CRect& rcOld, const CRect& rcNew)
{
    Assert (prcRes);

    // if size of prOld is different from size of prNew
    //
    if (rcOld.Width() != rcNew.Width() || rcOld.Height() != rcNew.Height())
    {
        return FALSE;
    }

    if (rcNew.top < rcOld.top)
    {
        // rect was shifted up
        // if also shifted along the other axis
        //
        if (rcNew.left != rcOld.left)
            return FALSE;

        prcRes->SetRect(rcNew.left, rcNew.bottom, rcNew.right, rcOld.bottom);
    }
    else if (rcOld.top < rcNew.top)
    {
        // rect was shifted down
        // if also shifted along the other axis
        //
        if (rcNew.left != rcOld.left)
            return FALSE;

        prcRes->SetRect(rcNew.left, rcOld.top, rcNew.right, rcNew.top);
    }
    else if (rcNew.left < rcOld.left)
    {
        // rect was shifted to the left
        // if also shifted along the other axis
        //
        if (rcNew.top != rcOld.top)
            return FALSE;

        prcRes->SetRect(rcNew.right, rcNew.top, rcOld.right, rcNew.bottom);
    }
    else if (rcOld.left < rcNew.left)
    {
        // rect was shifted to the right
        // if also shifted along the other axis
        //
        if (rcNew.top != rcOld.top)
            return FALSE;

        prcRes->SetRect(rcOld.left, rcNew.top, rcNew.left, rcNew.bottom);
    }
    else
    {
        // position was not changed - set rect to empty
        //
        prcRes->SetRectEmpty();
    }

    return TRUE;
}
#endif


#if DBG==1
extern CLSID CLSID_MPIT_MenuDBG;
#endif 

//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
COleLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    HWND        hwnd;
    BOOL fInvalidate = FALSE;
    
    if (pSiteOle->_state < OS_INPLACE)
    {
        _rcWnd = *prcClient;
        return;
    }
    
    hwnd = pSiteOle->GetHwnd();
    if (hwnd == NULL)
    {
        _rcWnd = *prcClient;
    }
    else
    {
        CTreeNode * pTreeNode = pSiteOle->GetFirstBranch();
        CRect* prcInvalid = NULL;
        CRect rcInvalid;

        if (    pTreeNode->IsVisibilityHidden()
            ||  pTreeNode->IsDisplayNone())
        {
            flags |= VCF_INVIEWCHANGED;
            flags &= ~VCF_INVIEW;
        }
        
        // When positioning objects, we move the object
        // hwnd from under it.  This is for two reasons: it
        // reduces flicker when scrolling because we don't invalidate,
        // and we can then draw the bits on the screen directly as
        // well.  That way when the object calls MoveWindow in response
        // to SetObjectRects, nothing happens.
        
        DWORD positionChangeFlags = SWP_NOACTIVATE | SWP_NOZORDER;
        CRect rcTarget = *prcClient;
        CRect rcWndBefore;
        BOOL fIsClippingOuterWindow = GetView()->IsClippingOuterWindow(hwnd);

        // if it's an MFC-like control, move directly to the clipping rect
        if (fIsClippingOuterWindow)
        {
            rcTarget = *prcClip;
        }
        
        GetView()->GetHWNDRect(hwnd, &rcWndBefore);
        if (!fIsClippingOuterWindow || rcWndBefore.Size() == rcTarget.Size())
        {
            positionChangeFlags |= SWP_NOSIZE;
        }

        if (flags & VCF_INVIEWCHANGED)
        {
            positionChangeFlags |=
                (flags & VCF_INVIEW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
            DeferSetWindowPos(hwnd, &rcTarget, positionChangeFlags, NULL);
        }
        else
        {
            BOOL fClipMoved = ! (rcWndBefore.Size() == CRect(*prcClip).Size() &&
                     (rcWndBefore.TopLeft() - _rcWnd.TopLeft()) ==
                     (CRect(*prcClip).TopLeft() - CRect(*prcClient).TopLeft()));
            if (flags & VCF_NOREDRAW)
            {
                if (!fIsClippingOuterWindow || !fClipMoved)
                {
                    positionChangeFlags |= SWP_NOREDRAW;
                }
                else
                {
                    fInvalidate = TRUE;
                }
#if 1
// TODO (donmarsh) - IE 4 did the following extra invalidation, which
// is necessary to clean up something that gets drawn asynchronously in the
// wrong position before our set object rects call completes.  See comment
// above FindRectAreaDifference.
                if (FindRectAreaDifference(&rcInvalid, _rcWnd, (const CRect&) *prcClient))
                    prcInvalid = &rcInvalid;
#endif
            }
      
            DeferSetWindowPos(hwnd, &rcTarget, positionChangeFlags, prcInvalid);
        }
        
        // remember our new "theoretical" rect to allow subsequent
        // DeferSetWindowPos call above
        _rcWnd = *prcClient;
        
        // (alexz) (anandra)
        // set window region to clip rectangle. This eliminates
        // flickering for several controls - e.g. several of ncompass
        // controls or proto view treeview. These controls flicker
        // if rcClip is different from rc in SetObjectRects,
        // which, however, gets fixed by proper call to SetWindowRgn.
        // rc can be different from rcClip very often - during
        // scrolling when object is only partially visible.
        // NOTE: This used to be done only for a known set of controls (via a compatibility flag).
        //       However, it turns out that more controls need it so now it is done all the
        //       time. (brendand)
        // Bugs: # 37662, 43877, 43885.

        //
        //  NOTE: The call to SetWindowRgn has been changed from asynch to synch since the asynch form
        //        results in the 3rd party application, FirstAid, faulting! (brendand/kensy)
        //

        {
            CRect rcClip(*prcClip);
            rcClip.OffsetRect(-rcTarget.TopLeft().AsSize());
            // prevent reentry of Display Tree if the following calls cause
            // a WM_ERASEBKGND message to be sent
            CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

#if defined(ALWAYS_DEFER_SET_WINDOW_RGN)
            BOOL fDeferSWR = TRUE;
            
#  if DBG == 1
            if (IsTagEnabled(tagDeferSetWindowRgn))
            {
                INSTANTCLASSINFO * pici = pSiteOle->GetInstantClassInfo();
                fDeferSWR = (pici && (pici->dwCompatFlags & COMPAT_ALWAYSDEFERSETWINDOWRGN));
            }
#  endif
            if (fDeferSWR)
#else
            INSTANTCLASSINFO * pici = pSiteOle->GetInstantClassInfo();

            if ((pici && (pici->dwCompatFlags & COMPAT_ALWAYSDEFERSETWINDOWRGN))
#  if DBG == 1
                    ||  IsTagEnabled(tagDeferSetWindowRgn)
#  endif
                )
#endif
            {
                DeferSetWindowRgn(hwnd, &rcClip, !prcInvalid);
            }
            else
            {
                SetWindowRgn(hwnd, &rcClip, !prcInvalid);
            }
        }
    }

    // 
    // (olego) apphack fix for IE6 bug 25970. Due to incorrect implementation 
    // of MPIT.Menu control, call to IOleInPlaceObject::SetObjectRects would 
    // reposition its window to (0, 0)...
    // 
    if (pSiteOle->_fAppHack_MPIT_Menu)
    {
        Assert(pSiteOle->_clsid == CLSID_MPIT_MenuDBG);
        return;
    }
    
    CRect rcClient(*prcClient);
    CRect rcClip(*prcClip);

    if (pSiteOle->IsDisplayNone() || pSiteOle->IsVisibilityHidden())
        rcClient.SetRect(-1, -1, -1, -1);

    if (pSiteOle->ClipViaHwndOnly())
        rcClip = rcClient;

    DeferSetObjectRects(
        pSiteOle->_pInPlaceObject,
        (RECT*) &rcClient,
        (RECT*) &rcClip,
        hwnd,
        fInvalidate);

}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::WantsToBeObscured
//              
//  Synopsis:   Should this control be obscured by content higher up in
//              the z-order (which requires clipping its window)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
COleLayout::WantsToBeObscured(CDispNode *pDispNode) const
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        HWND hwnd = pSiteOle->GetHwnd();
        if (hwnd && pDispNode == GetElementDispNode())
        {
            return TRUE;
        }
    }

    // don't need special clipping if there's no HWND
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Obscure
//              
//  Synopsis:   Obscure the control, by clipping it to the given region
//              
//----------------------------------------------------------------------------

void
COleLayout::Obscure(CRect *prcgClient, CRect *prcgClip, CRegion2 *prgngVisible)
{
    HWND hwnd = NULL;
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        hwnd = pSiteOle->GetHwnd();
    }
    
    AssertSz(hwnd, "No window for obscured control");
    if (!hwnd)
        return;

    HRGN hrgn = prgngVisible->ConvertToWindows();
    CRect rcgTarget = GetView()->IsClippingOuterWindow(hwnd) ? *prcgClip : *prcgClient;
    CRect *prcClip = NULL;
    CRect rcClip;

    // We're about to clip the control's window via SetWindowRgn.
    // Update the pending SetObjectRects clipping rect as best we
    // can (if we're using SOR to clip at all).  This eliminates some
    // flashing (bug 108347).
    if (!pSiteOle->ClipViaHwndOnly())
    {
        if (prgngVisible->GetBoundingRect(rcClip))
        {
            rcClip.OffsetRect(-rcgTarget.left, -rcgTarget.top);
        }
        else
        {
            rcClip.SetRectEmpty();
        }
        prcClip = &rcClip;
    }

    if (::OffsetRgn(hrgn, -rcgTarget.left, -rcgTarget.top) != ERROR)
    {
        DeferSetWindowRgn(hwnd, hrgn, prcClip, TRUE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::ProcessDisplayTreeTraversal
//              
//  Synopsis:   Add our window to the z order list.
//              
//  Arguments:  pClientData     window order information
//              
//  Returns:    TRUE to continue display tree traversal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
COleLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        HWND hwnd = pSiteOle->GetHwnd();
        if (hwnd)
        {
            CView::CWindowOrderInfo* pWindowOrderInfo =
                (CView::CWindowOrderInfo*) pClientData;
            pWindowOrderInfo->AddWindow(hwnd);
        }
    }
    
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
COleLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    CHitTestInfo *  phti = (CHitTestInfo *) pClientData;
    HTC htc = HTC_YES;
    BOOL fRet = TRUE;

    Assert(pSiteOle);

    if (pSiteOle->_fUseViewObjectEx)
    {
        DWORD dwHitResult = HITRESULT_OUTSIDE;

        if (pSiteOle->_pVO)
        {
            RECT rcClient;

            GetClientRect(&rcClient);

            if (FAILED(((IViewObjectEx *) (pSiteOle->_pVO))->QueryHitPoint(
                                                    DVASPECT_CONTENT,
                                                    &rcClient,
                                                    *pptHit,
                                                    0,
                                                    &dwHitResult)))
                dwHitResult = HITRESULT_OUTSIDE;
        }

        if (dwHitResult == HITRESULT_OUTSIDE)
        {
            htc = HTC_NO;
            fRet = FALSE;
        }
        else if (dwHitResult != HITRESULT_HIT)   // HITRESULT_TRANSPARENT or HITRESULT_CLOSE
        {
            fRet = FALSE;
        }
    }

    if ((phti->_htc == HTC_NO) || fRet)
    {
        phti->_htc = htc;

        if (htc == HTC_YES)
        {
            phti->_pNodeElement = ElementContent()->GetFirstBranch();
            phti->_ptContent    = *pptHit;
            phti->_pDispNode    = pDispNode;
            phti->_phtr->_fWantArrow = TRUE;
        }
    }

    return(fRet);
}

//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragEnter
//
//  Synopsis:   This is called when an object is started to be dragged over this 
//              layout area. If the inplace object is a windowless control, then 
//              the call is delegated to the control. Otherwise, the call is 
//              delegated to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragEnter(
                    IDataObject *pDataObj,
                    DWORD grfKeyState,
                    POINTL pt,
                    DWORD *pdwEffect)
{
    HRESULT             hr;
    IDropTarget *       pDT = NULL;
    COleSite    *       pSiteOle = DYNCAST(COleSite, ElementOwner());
    IPointerInactive *  pPI = NULL;
    DWORD               dwPolicy = 0;

    // check if the control needs to be activated because of the drag drop operation
    if (pSiteOle->_state < OS_INPLACE)
    {
        // the control is not inplace active, inplace activation is needed.

        if (!THR_NOTRACE(pSiteOle->QueryControlInterface(IID_IPointerInactive, (void **) &pPI)))
        {
            hr = THR(pPI->GetActivationPolicy(&dwPolicy));
            if (hr)
                goto Cleanup;

            // should we activate the control if not active?
            if (dwPolicy & POINTERINACTIVE_ACTIVATEONDRAG)
            {
                hr = THR(pSiteOle->TransitionTo(OS_INPLACE, NULL));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)
        {

            
// CONSIDERATION: (ferhane)
// In the call below, if the DragEnter is returning S_FALSE then it means that 
// the control is trying to delegate the call to us. We could immediately drop step and 
// call the super for the hr==S_FALSE case, instead of returning S_FALSE to the caller.
// However, that would require us to keep track of which data types was refused by this
// control, so that we could not call it but process the call ourselves for the following 
// DragOver and Drop calls that we would receive.
// According to spec, there is no guarantee that any of the IDropTarget methods other than
// the DragEnter would return S_FALSE. So, we are the ones ending up tracking this ... 

            //delegate the call
            hr = THR_OLE(pDT->DragEnter(pDataObj, grfKeyState, pt, pdwEffect));
                goto Cleanup;            
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragEnter(pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);
    ReleaseInterface(pPI);

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragOver
//
//  Synopsis:   This is called when an object is being dragged over this layout 
//              area. If the inplace object is a windowless control, then the 
//              call is delegated to the control. Otherwise, the call is delegated 
//              to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->DragOver( grfKeyState, pt, pdwEffect));
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragOver( grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     COleLayout::Drop
//
//  Synopsis:   This is called when an object is dropped on this layout area.
//              If the inplace object is a windowless control, then the call is 
//              delegated to the control. Otherwise, the call is delegated to the 
//              super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::Drop(   IDataObject *pDataObj,
                    DWORD grfKeyState,
                    POINTL pt,
                    DWORD *pdwEffect)
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->Drop( pDataObj, grfKeyState, pt, pdwEffect));
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::Drop( pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragLeave
//
//  Synopsis:   This is called when an object that was being dragged over this area 
//              leaves the area. If the inplace object is a windowless control, then the 
//              call is delegated to the control. Otherwise, the call is delegated 
//              to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragLeave()
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->DragLeave());
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragLeave());

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\scrollbar.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       scrollbar.cxx
//
//  Contents:   Class to render default horizontal and vertical scrollbars.
//
//  Classes:    CScrollbar
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifdef UNIX
#ifndef X_UNIXCTLS_HXX_
#define X_UNIXCTLS_HXX_
#include "unixctls.hxx"
#endif
#endif // UNIX

#ifdef _MAC
#ifndef X_MACCONTROLS_HXX_
#define X_MACCONTROLS_HXX_
#include "maccontrols.h"
#endif
#endif


//+---------------------------------------------------------------------------
//
//  Member:     GetThemedScrollbarButtonCode
//              
//  Synopsis:   return the button part constant for themed scrollbars
//              
//  Arguments:  fButtonDisabled        TRUE if button is to be painted in disabled state
//              fButtonPressed         TRUE if button is to be painted in pressed state
//              nDirScrollbar          0 for horizontal, 1 for vertical
//              fVertLayout            TRUE if we are painting scroll bars in writing-mode:TB-RL
//              nWhichButton           0 is LEFT or UP and 1 is RIGHT or DOWN
//----------------------------------------------------------------------------

static int 
GetThemedScrollbarButtonCode(BOOL fButtonDisabled, BOOL fButtonPressed, int nDirScrollbar, BOOL fVertLayout, int nWhichButton)
{
    int nPartState;

    if(fVertLayout)
    {
        if(fVertLayout && nDirScrollbar == 1)
        {
            Assert(nWhichButton == 0 || nWhichButton == 1);
            // For vertical layout mode left and right buttons should be swapped
            //  on the vertical scrollbar (that becomes horizontal in that mode)
            nWhichButton = !nWhichButton;
        }
        Assert(nDirScrollbar == 0 || nDirScrollbar == 1);
        nDirScrollbar = !nDirScrollbar;
    }

    if(fButtonDisabled)
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTDISABLED : ABS_RIGHTDISABLED; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPDISABLED : ABS_DOWNDISABLED;
    }
    else if(fButtonPressed)
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTPRESSED : ABS_RIGHTPRESSED; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPPRESSED : ABS_DOWNPRESSED;
    }
    else
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTNORMAL : ABS_RIGHTNORMAL; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPNORMAL : ABS_DOWNNORMAL;
    }
    return nPartState;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetThemedScrollbarPartState
//              
//  Synopsis:   return the disabled/pressed/normal code for given themed scrollbar part
//                to be used by the theme functions
//              
//  Arguments:  fDisabled              TRUE if the part is to be painted in disabled state
//              nPartPressed           The part that is pressed
//              nPart                  The part who's state we want to get
//----------------------------------------------------------------------------

static int
GetThemedScrollbarPartState(BOOL fDisabled, int nPartPressed, int nPart)
{
    int nPartState;

    if(fDisabled)
        nPartState = SCRBS_DISABLED;
    else if(nPartPressed == nPart)
        nPartState = SCRBS_PRESSED;
    else
        nPartState = SCRBS_NORMAL;

    return nPartState;
}



//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::Draw
//              
//  Synopsis:   Draw the scroll bar in the given direction.
//              
//  Arguments:  direction           0 for horizontal, 1 for vertical
//              rcScrollbar         bounds of entire scroll bar
//              rcRedraw            bounds to be redrawn
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of area to scroll within
//              scrollAmount        amount that the content is scrolled
//              partPressed         which part, if any, is pressed
//              hdc                 DC to draw into
//              params              customizable scroll bar parameters
//              pDI                 draw info
//              dwFlags             rendering flags
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::Draw(
        int direction,
        const CRect& rcScrollbar,
        const CRect& rcRedraw,
        long contentSize,
        long containerSize,
        long scrollAmount,
        CScrollbar::SCROLLBARPART partPressed,
        XHDC hdc,
        const CScrollbarParams& params,
        CDrawInfo *pDI,
        DWORD dwFlags)
{
    BOOL    fDisabled;
    int     nVerticalLayoutDirThemed;
    long    scaledButtonWidth;
    BOOL    fUseThemes;
    int     nPartState;

    Assert(hdc != NULL);
    // for now, we're using CDrawInfo, which should have the same hdc
    Assert(pDI->_hdc == hdc);

    // trivial rejection if nothing to draw
    if (!rcScrollbar.Intersects(rcRedraw))
        return;
    
#ifdef _MAC
    DrawMacScrollbar(pDI, direction, (RECT*) &rcScrollbar,
                    contentSize, containerSize, scrollAmount);
    return;
#endif

    fDisabled = (params._fForceDisabled) || (containerSize >= contentSize);
    scaledButtonWidth = GetScaledButtonWidth(direction, rcScrollbar, params._buttonWidth);
    
    // compute rects for buttons and track
    CRect rcTrack(rcScrollbar);
    rcTrack[direction] += scaledButtonWidth;
    rcTrack[direction+2] -= scaledButtonWidth;

    CScrollbarThreeDColors& colors = *params._pColors;

    // If even one color is set through CSS we disable the theming
    fUseThemes = (params._hTheme != NULL) && (!colors.IsAnyColorSet());

    if(fUseThemes && dwFlags & DISPSCROLLBARHINT_VERTICALLAYOUT)
    {
        nVerticalLayoutDirThemed = !direction;
    }
    else
    {
        nVerticalLayoutDirThemed = direction;
    }

    // draw buttons unless requested not to (it's expensive to draw these!)
    if ((dwFlags & DISPSCROLLBARHINT_NOBUTTONDRAW) == 0)
    {
        CRect rcButton[2];
        rcButton[0] = rcScrollbar;
        rcButton[0][direction+2] = rcTrack[direction];
        rcButton[1] = rcScrollbar;
        rcButton[1][direction] = rcTrack[direction+2];
        
        // draw the buttons
        //=======================================================================================
        CSize sizeButton;
        pDI->HimetricFromDevice(
            sizeButton, rcButton[0].Width(), rcButton[0].Height());

        for (int i = 0; i < 2; i++)
        {
            if (rcRedraw.Intersects(rcButton[i]))
            {
                BOOL fButtonPressed =
                    (i == 0 && partPressed == SB_PREVBUTTON) ||
                    (i == 1 && partPressed == SB_NEXTBUTTON);
                
                if(fUseThemes)
                {
                    nPartState = GetThemedScrollbarButtonCode(fDisabled, fButtonPressed, 
                                        direction, !!(dwFlags & DISPSCROLLBARHINT_VERTICALLAYOUT), i);
 
                    Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, SBP_ARROWBTN,
                                                nPartState, &rcButton[i], NULL)));
                }
                else
                {
                    CUtilityButton scrollButton(params._pColors, params._fFlat);
                    scrollButton.DrawButton(
                        pDI,
                        NULL,   // no hwnd, we don't want to invalidate
                        (direction == 0
                            ? (i == 0 ? BG_LEFT : BG_RIGHT)
                            : (i == 0 ? BG_UP : BG_DOWN)),
                        fButtonPressed,
                        !fDisabled,
                        FALSE,  // never focused
                        rcButton[i],
                        sizeButton,
                        0);     // assume both button glyphs are the same size
                }
            }
        }
    }
    
    // draw track
    if (rcRedraw.Intersects(rcTrack))
    {
        if (fDisabled)
        {
        // draw the disabled scrollbar
        //=======================================================================================
           if(fUseThemes)
           {
                Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                         SCRBS_DISABLED, &rcTrack, NULL)));
           }
           else
           {
               DrawTrack(rcTrack, rcTrack.TopLeft(), FALSE, fDisabled, hdc, params);
           }
        }        
        else
        {
            // calculate thumb rect
            CRect rcThumb;
            GetPartRect(&rcThumb, SB_THUMB, direction, rcScrollbar, contentSize, containerSize,
                scrollAmount, params._buttonWidth, pDI);
                
            // can track contain the thumb?
            if (!rcTrack.Contains(rcThumb))
            {
               if(fUseThemes)
               {
                   // Draw the track
                    Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                    (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                    (fDisabled) ? SCRBS_DISABLED : SCRBS_NORMAL, &rcTrack, NULL)));

               }
               else
               {
                    DrawTrack(rcTrack, rcTrack.TopLeft(), FALSE, fDisabled, hdc, params);
               }
            }
            
            else
            {
                //=======================================================================================
                // draw previous track, normal case
                CRect rcTrackPart(rcTrack);
                rcTrackPart[direction+2] = rcThumb[direction];
                if (rcRedraw.Intersects(rcTrackPart))
                {
                   if(fUseThemes)
                   {
                       int nTrackState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_PREVTRACK);
                       Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_UPPERTRACKHORZ : SBP_UPPERTRACKVERT,
                                        nTrackState, &rcTrackPart, NULL)));
                   }
                   else
                   {
                        DrawTrack(rcTrackPart, rcTrack.TopLeft(), partPressed == SB_PREVTRACK,
                              fDisabled, hdc, params);
                   }
                }
                
                //=======================================================================================
                // draw thumb
                if (rcRedraw.Intersects(rcThumb))
                {
                   if(fUseThemes)
                   {
                       int nThumbState;
                       int nPartId;

                       // DRAW the thumb
                        nThumbState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_THUMB);
                        nPartId = (nVerticalLayoutDirThemed == 0) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, nPartId,
                                         nThumbState, &rcThumb, NULL)));

                        // Draw the little thingy on the thumb (gripper)
                        nPartId = (nVerticalLayoutDirThemed == 0) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, nPartId, 
                                         nThumbState, &rcThumb, NULL)));
                   }
                   else
                   {
                       DrawThumb(rcThumb, partPressed == SB_THUMB, hdc, params, pDI );
                   }
                }
                
                //=======================================================================================
                // draw next track
                rcTrackPart = rcTrack;
                rcTrackPart[direction] = rcThumb[direction+2];
                if (rcRedraw.Intersects(rcTrackPart))
                {
                    if(fUseThemes)
                    {
                        int nTrackState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_NEXTTRACK);
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                        nTrackState, &rcTrackPart, NULL)));
                    }
                    else
                    {
                        DrawTrack(rcTrackPart, rcTrack.TopLeft(), partPressed == SB_NEXTTRACK,
                              fDisabled, hdc, params);
                    }
                }
            }
        }
    }
#ifdef UNIX
    //
    // Kind of a copout, but it works
    // We draw the 3D border around the whole scroll bar anytime
    // any part of the scroll bar is updated
    //
    
    IGNORE_HR(BRDrawBorder (
        pDI, (RECT *) &rcScrollbar, fmBorderStyleSunken,
        0, params._pColors, BRFLAGS_MONO ));
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::DrawTrack
//              
//  Synopsis:   Draw the scroll bar track.
//              
//  Arguments:  rcTrack     bounds of track
//              ptOffset    point used to anchor dither pattern
//              fPressed    TRUE if this portion of track is pressed
//              fDisabled   TRUE if scroll bar is disabled
//              hdc         HDC to draw into
//              params      customizable scroll bar parameters
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::DrawTrack(
        const CRect& rcTrack,
        const CPoint& ptOffset,
        BOOL fPressed,
        BOOL fDisabled,
        XHDC hdc,
        const CScrollbarParams& params)
{
#ifdef _MAC
    return;
#endif
#ifdef UNIX
    {
        ScrollBarInfo info;
        info.lStyle = params._bDirection ? SB_VERT : SB_HORZ;
        info.bDisabled = FALSE;
        MwPaintMotifScrollRect(hdc,
                                LeftTopThumbRect, // It draws both sides.
                                (LPRECT)&rcTrack,
                                FALSE,
                                &info);
        return;
    }
#endif
    
    CScrollbarThreeDColors& colors = *params._pColors;
    HBRUSH       hbr;
    BOOL        fDither = TRUE;
    COLORREF    color1, color2 = 0;
    BOOL        fUseBmpBrush = FALSE;

    fDither = GetDeviceCaps(hdc, BITSPIXEL) < 8 ||            
                colors.BtnHighLight() != GetSysColorQuick(COLOR_SCROLLBAR);
    if(colors.IsTrackColorSet())
    {
        //Use the track color, it has been explicitly set
        color1 = colors.GetTrackColor();
    }
    else if(params._fFlat)
    {
        color1 = colors.BtnFace();
        color2 = (fPressed) ? colors.BtnShadow() : colors.BtnHighLight();
        fUseBmpBrush = TRUE;
    }
    else if(fDither)
    {
        color1 = colors.BtnFace();
        color2 = colors.BtnHighLight();
        if (fPressed)
        {
            color1 ^= 0x00ffffff;
            color2 ^= 0x00ffffff;
        }
        fUseBmpBrush = TRUE;
    }
    else
    {
        color1 = colors.BtnHighLight();
    }

    if(fUseBmpBrush)
    {
        hbr = GetCachedBmpBrush(IDB_DITHER);
        SetTextColor(hdc, color1);
        SetBkColor(hdc, color2);

        // For bitmap brushes need to set the right Brush Origin
        CPoint pt;
        ::GetViewportOrgEx(hdc, &pt);
        pt += ptOffset.AsSize();
#ifndef WINCE
        // not supported on WINCE
        ::UnrealizeObject(hbr);
#endif
        ::SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8), POSITIVE_MOD(pt.y,8), NULL);
    }
    else
    {
        if (fPressed)
            color1 ^= 0x00ffffff;
        hbr = ::GetCachedBrush(color1);
    }
    
    HBRUSH hbrOld = (HBRUSH)::SelectObject(hdc, hbr);
    
    ::PatBlt(
           hdc,
           rcTrack.left, rcTrack.top,
           rcTrack.Width(), rcTrack.Height(),
           PATCOPY);
    
    ::SelectObject(hdc, hbrOld);

    // Release only the non-bitmap brushes
    if (!fUseBmpBrush)
        ::ReleaseCachedBrush(hbr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::DrawThumb
//              
//  Synopsis:   Draw scroll bar thumb.
//              
//  Arguments:  rcThumb         bounds of thumb
//              fThumbPressed   TRUE if thumb is pressed
//              hdc             HDC to draw into
//              params          customizable scroll bar parameters
//              pDI             draw info
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::DrawThumb(
        const CRect& rcThumb,
        BOOL fThumbPressed,
        XHDC hdc,
        const CScrollbarParams& params,
        CDrawInfo* pDI)
{
#ifdef _MAC
    return;
#endif

#ifdef UNIX
    {
        ScrollBarInfo info;
        info.lStyle = params._bDirection ? SB_VERT : SB_HORZ;
        info.bDisabled = FALSE;
        MwPaintMotifScrollRect( hdc,
                                ThumbButton,
                                (LPRECT)&rcThumb,
                                FALSE,
                                &info);
        return;
    }
#endif
    
    CRect rcInterior(rcThumb);

    //
    // Draw the border of the thumb
    //

    IGNORE_HR(BRDrawBorder (
        pDI, (RECT *) &rcThumb, fmBorderStyleRaised,
        0, params._pColors,
        (params._fFlat ? BRFLAGS_MONO : 0 )));

    //
    // Calculate the interior of the thumb
    //

    IGNORE_HR(BRAdjustRectForBorder(
        pDI, &rcInterior,
        (params._fFlat ? fmBorderStyleSingle : fmBorderStyleRaised )));

    //
    // Here we draw the interior border of the scrollbar thumb.
    // We assume that the edge is two pixels wide.
    //

    HBRUSH hbr = params._pColors->BrushBtnFace();
    HBRUSH hbrOld = (HBRUSH)::SelectObject(hdc, hbr);
    ::PatBlt(hdc, rcInterior.left, rcInterior.top,
             rcInterior.Width(), rcInterior.Height(), PATCOPY );
    ::SelectObject(hdc, hbrOld);
    ::ReleaseCachedBrush(hbr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetPart
//              
//  Synopsis:   Return the scroll bar part hit by the given test point.
//              
//  Arguments:  direction       0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar     scroll bar bounds
//              ptHit           test point
//              contentSize     size of content controlled by scroll bar
//              containerSize   size of container
//              scrollAmount    current scroll amount
//              buttonWidth     width of scroll bar buttons
//              
//  Returns:    The scroll bar part hit, or SB_NONE if nothing was hit.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CScrollbar::SCROLLBARPART
CScrollbar::GetPart(
        int direction,
        const CRect& rcScrollbar,
        const CPoint& ptHit,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDrawInfo* pDI)
{
    if (!rcScrollbar.Contains(ptHit))
        return SB_NONE;
    
#ifdef _MAC
    return GetMacScrollPart(pDI, direction, ptHit);
#endif
   
    // adjust button width if there isn't room for both buttons at full size
    long scaledButtonWidth =
        GetScaledButtonWidth(direction, rcScrollbar, buttonWidth);
    
    // now test just the axis that matters
    long x = ptHit[direction];
    
    if (x < rcScrollbar.TopLeft()[direction] + scaledButtonWidth)
        return SB_PREVBUTTON;
    
    if (x >= rcScrollbar.BottomRight()[direction] - scaledButtonWidth)
        return SB_NEXTBUTTON;
    
    // NOTE: if there is no thumb, return SB_TRACK
    CRect rcThumb;
    GetPartRect(
        &rcThumb,
        SB_THUMB,
        direction,
        rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDI);
    if (rcThumb.IsEmpty())
        return SB_TRACK;
     
    if (x < rcThumb.TopLeft()[direction])
        return SB_PREVTRACK;
    if (x >= rcThumb.BottomRight()[direction])
        return SB_NEXTTRACK;
    
    return SB_THUMB;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetPartRect
//              
//  Synopsis:   Return the rect bounding the given scroll bar part.
//              
//  Arguments:  prcPart         returns part rect
//              part            which scroll bar part
//              direction       0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar     scroll bar bounds
//              contentSize     size of content controlled by scroll bar
//              containerSize   size of container
//              scrollAmount    current scroll amount
//              buttonWidth     width of scroll bar buttons
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::GetPartRect(
        CRect* prcPart,
        CScrollbar::SCROLLBARPART part,
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDrawInfo* pDI)
{
    // adjust button width if there isn't room for both buttons at full size
    long scaledButtonWidth =
        GetScaledButtonWidth(direction, rcScrollbar, buttonWidth);
    
    switch (part)
    {
    case SB_NONE:
        AssertSz(FALSE, "CScrollbar::GetPartRect called with no part");
        prcPart->SetRectEmpty();
        break;
        
    case SB_PREVBUTTON:
        *prcPart = rcScrollbar;
        (*prcPart)[direction+2] = rcScrollbar[direction] + scaledButtonWidth;
        break;
        
    case SB_NEXTBUTTON:
        *prcPart = rcScrollbar;
        (*prcPart)[direction] = rcScrollbar[direction+2] - scaledButtonWidth;
        break;
        
    case SB_TRACK:
    case SB_PREVTRACK:
    case SB_NEXTTRACK:
    case SB_THUMB:
        {
            if (contentSize <= containerSize && part != SB_TRACK)
            {
                prcPart->SetRectEmpty();
                break;
            }
            
            *prcPart = rcScrollbar;
            (*prcPart)[direction] += scaledButtonWidth;
            (*prcPart)[direction+2] -= scaledButtonWidth;
            if (part == SB_TRACK)
                break;
            
            // calculate thumb size
            long trackSize = prcPart->Size(direction);
            long thumbSize = GetThumbSize(
                direction, rcScrollbar, contentSize, containerSize, buttonWidth, pDI);
            long thumbOffset = GetThumbOffset(
                contentSize, containerSize, scrollAmount, trackSize, thumbSize);
            
            if (part == SB_THUMB)
            {
                (*prcPart)[direction] += thumbOffset;
                (*prcPart)[direction+2] = (*prcPart)[direction] + thumbSize;
            }
            else if (part == SB_PREVTRACK)
            {
                    (*prcPart)[direction+2] = (*prcPart)[direction] + thumbOffset;
            }
            else
            {
                    (*prcPart)[direction] += thumbOffset + thumbSize;
            }
        }
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::InvalidatePart
//              
//  Synopsis:   Invalidate and immediately redraw the indicated scrollbar part.
//              
//  Arguments:  part                part to redraw
//              direction           0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar         scroll bar bounds
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of container
//              scrollAmount        current scroll amount
//              buttonWidth         width of scroll bar buttons
//              pDispNodeToInval    display node to invalidate
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::InvalidatePart(
        CScrollbar::SCROLLBARPART part,
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDispScroller* pDispNodeToInval,
        CDrawInfo* pDI)
{
    // find bounds of part
    CRect rcPart;
    GetPartRect(
        &rcPart,
        part,
        direction,
        rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDI);

    pDispNodeToInval->Invalidate(rcPart, COORDSYS_BOX, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetThumbSize
//              
//  Synopsis:   Calculate the thumb size given the adjusted button width.
//              
//  Arguments:  direction           0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar         scroll bar bounds
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of container
//              buttonWidth         width of scroll bar buttons
//              
//  Returns:    width of thumb in pixels
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

long
CScrollbar::GetThumbSize(
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long buttonWidth,
        CDrawInfo* pDI)
{
#ifdef _MAC
    return 16; // fixed size thumb
#endif
    long thumbSize = direction == 0
             ? pDI->DeviceFromHimetricX(HIMETRIC_PER_INCH*8/72)
             : pDI->DeviceFromHimetricY(HIMETRIC_PER_INCH*8/72);

    long trackSize = GetTrackSize(direction, rcScrollbar, buttonWidth);
    // minimum thumb size is 8 points for
    // compatibility with IE4.
    
    // [alanau] For some reason, I can't put two ternery expressions in a "max()", so it's coded this clumsy way:
    //
    if (contentSize) // Avoid divide-by-zero fault.
    {
        int t = IntFloor(double(trackSize) * containerSize / contentSize);
                // NOTE: (mikhaill) -- IntNear() is more natural but Robovision machines do not agree
        if (thumbSize < t)
            thumbSize = t;
    }
    return (thumbSize <= trackSize ? thumbSize : 0);
}



// This class holds colors used for scrollbar painting
CScrollbarThreeDColors::CScrollbarThreeDColors(CTreeNode *pNode, XHDC *pxhdc, OLE_COLOR coInitialBaseColor) 
    :   ThreeDColors(pxhdc, coInitialBaseColor)
{
    _fBaseColorSet = _fFaceColorSet = _fLightColorSet = _fArrowColorSet =
            _fShadowColorSet = _fHighLightColorSet = _fDkShadowColorSet = 
            _fTrackColorSet = 0;
    Assert(pNode != NULL);
    if(!g_fHighContrastMode && pNode && pNode->GetCascadedhasScrollbarColors())
    {
        CColorValue cv;
        
        cv = pNode->GetScrollbarBaseColor();
        if(cv.IsDefined())
        {
            SetBaseColor(cv.GetOleColor());
        }
        cv = pNode->GetScrollbarArrowColor();
        if(cv.IsDefined())
        {
            _fArrowColorSet = TRUE;
            _coArrowColor = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarTrackColor();
        if(cv.IsDefined())
        {
            _fTrackColorSet = TRUE;
            _coTrackColor = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarFaceColor();
        if(cv.IsDefined())
        {
            _fFaceColorSet = TRUE;
            _coBtnFace = cv.GetColorRef();
        }
        cv = pNode->GetScrollbar3dLightColor();
        if(cv.IsDefined())
        {
            _fLightColorSet = TRUE;
            _coBtnLight = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarShadowColor();
        if(cv.IsDefined())
        {
            _fShadowColorSet = TRUE;
            _coBtnShadow = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarDarkShadowColor();
        if(cv.IsDefined())
        {
            _fDkShadowColorSet = TRUE;
            _coBtnDkShadow = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarHighlightColor();
        if(cv.IsDefined())
        {
            _fHighLightColorSet = TRUE;
            _coBtnHighLight = cv.GetColorRef();
        }
    }
    
}


COLORREF 
CScrollbarThreeDColors::BtnFace(void)
{
    if(_fFaceColorSet)
        return _coBtnFace;

    return ThreeDColors::BtnFace();
}

COLORREF 
CScrollbarThreeDColors::BtnLight(void)
{
    if(_fLightColorSet )
        return _coBtnLight;

    return ThreeDColors::BtnLight();
}

COLORREF
CScrollbarThreeDColors::BtnShadow(void)
{
    if(_fShadowColorSet)
        return _coBtnShadow;

    return ThreeDColors::BtnShadow();
}

COLORREF
CScrollbarThreeDColors::BtnHighLight(void)
{
    if(_fHighLightColorSet)
        return _coBtnHighLight;

    return ThreeDColors::BtnHighLight();
}

COLORREF
CScrollbarThreeDColors::BtnDkShadow(void)
{
    if(_fDkShadowColorSet)
        return _coBtnDkShadow;

    return ThreeDColors::BtnDkShadow();
}


// This is used as the Arrow color for the scroll bar
COLORREF 
CScrollbarThreeDColors::BtnText ( void )
{ 
    if(_fArrowColorSet)
        return _coArrowColor;
    // Use the system value
     return ThreeDColors::BtnText();
}


// This override just saves the color so that the currentStyle can get it
// and then calls the parent
void 
CScrollbarThreeDColors::SetBaseColor(OLE_COLOR clr)
{
    _fBaseColorSet = TRUE;
    _coBaseColor = clr;
    ThreeDColors::SetBaseColor(clr);
}
    

CColorValue
CTreeNode::GetScrollBarComponentColorHelper(DISPID dispid)
{
    HRESULT     hr;
    CVariant    var;
    CColorValue cv;
    
    if(!GetCascadedhasScrollbarColors())
       // No scroll bar colors are set
        goto Cleanup;
    
    // Climb up the element tree applying the style to find a match for diven dispid
    hr = THR(Element()->ComputeExtraFormat(dispid, 
            ComputeFormatsType_GetInheritedIntoTableValue, this, &var));
    if(hr)
        goto Cleanup;

    if(!var.IsEmpty())
    {
       cv = (CColorValue&) V_I4(&var);
    }

Cleanup:
    return cv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\layout.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       layout.cxx
//
//  Contents:   Implementation of CLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_DRAWINFO_HXX_
#define X_DRAWINFO_HXX_
#include "drawinfo.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#define INIT_GUID
#include <initguid.h>
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ELEMENTP_HXX
#define X_ELEMENTP_HXX
#include "elementp.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx" // needed for EVENTPARAM
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ADORNER_HXX_
#define X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_CONTLYT_HXX_
#define X_CONTLYT_HXX_
#include "contlyt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif


MtDefine(CLayout, Layout, "CLayout")
MtDefine(CRequest, Layout, "CRequest")
MtDefine(CBgRecalcInfo, Layout, "CBgRecalcInfo")
MtDefine(CLayout_aryRequests_pv, Layout, "CLayout RequestQueue")
MtDefine(CLayout_aryDispNodes_pv, Layout, "CLayout DispNode Array")
MtDefine(CLayoutDetach_aryChildLytElements_pv, Locals, "CLayout::Detach aryChildLytElements::_pv")
MtDefine(CLayoutScopeFlag, Locals, "CLayout::CScopeFlag")

MtDefine(LayoutMetrics, Metrics, "Layout Metrics")

DeclareTag(tagCalcSize,           "CalcSize:",       "Trace calls to CalcSize");
DeclareTag(tagCalcSizeDetail,     "CalcSize:",       "Additional CalcSize info");
DeclareTag(tagShowZeroGreyBorder,    "Edit",         "Show Zero Grey Border in Red");

DeclareTag(tagLayoutTasks,        "Layout: Reqs and Tasks",   "Trace layout requests and tasks");
DeclareTag(tagLayoutQueueDump,    "Layout: Dump Queue",       "Dumps layout request queue on QueueRequest() and ProcessRequests()");
DeclareTag(tagLayoutPositionReqs, "Layout: Pos Reqs",         "Traces handling of position requests");
DeclareTag(tagLayoutMeasureReqs,  "Layout: Meas Reqs",        "Traces handling of measure requests");
DeclareTag(tagLayoutAdornerReqs,  "Layout: Adorn Reqs",       "Traces handling of adorner requests");

DeclareTag(tagNoZOrderSignal,   "Layout",   "Don't notify view about ZOrder changes");
DeclareTag(tagZOrderChange,     "Layout",   "trace ZOrder changes");

// This tag allows us to log when GetUpdatedLayout is being called w/o
// context on an element that only has layouts w/ context (these are
// situations where we need to figure out how to supply context or
// make context unnecessary).
// NOTE: This tag should eventually be useless.
DeclareTag(tagLayoutAllowGULBugs, "Layout: Allow GUL bugs",   "Permits and traces buggy calls to GetUpdatedLayout");

// This allows tracking
DeclareTag(tagLayoutTrackMulti,   "Layout: Multi Layout",     "Track suspicious use of multiple layouts");

PerfDbgTag(tagLayoutCalcSize,     "Layout", "Trace CLayout::CalcSize")

ExternTag(tagLayout);
ExternTag(tagLayoutNoShort);
ExternTag(tagImgTrans);
ExternTag(tagDisplayInnerHTMLNode);


PerfDbgExtern(tagPaintWait);

const COLORREF ZERO_GREY_COLOR = RGB(0xC0,0xC0,0xC0);

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeElement
//
//  Synopsis:   Return the element associated with a display node
//
//-----------------------------------------------------------------------------

CElement *
GetDispNodeElement(
    CDispNode const* pDispNode)
{
    CElement *  pElement;

    Assert(pDispNode);

    pDispNode->GetDispClient()->GetOwner(pDispNode, (void **)&pElement);

#ifdef ADORNERS
    if (!pElement)
    {
        pElement = DYNCAST(CAdorner, (CAdorner *)pDispNode->GetDispClient())->GetElement();
    }
#endif // ADORNERS

    Assert(pElement);
    Assert(DYNCAST(CElement, pElement));

    return pElement;
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::CRequest/~CRequest
//
//  Synopsis:   Construct/destruct a CRequest object
//
//-----------------------------------------------------------------------------

inline
CRequest::CRequest(
    REQUESTFLAGS    rf,
    CElement *      pElement)
{
    Assert(pElement);

    pElement->AddRef();

    _cRefs    = 1;
    _pElement = pElement;
    _grfFlags = rf;
}

inline
CRequest::~CRequest()
{
    _pElement->DelRequestPtr();
    _pElement->Release();

#ifdef ADORNERS
    if (_pAdorner)
    {
        _pAdorner->Release();
    }
#endif // ADORNERS
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::AddRef/Release
//
//  Synopsis:   Maintain CRequest reference count
//
//-----------------------------------------------------------------------------

inline DWORD
CRequest::AddRef()
{
    Assert(_cRefs > 0);
    return ++_cRefs;
}

inline DWORD
CRequest::Release()
{
    Assert(_cRefs > 0);
    --_cRefs;
    if (!_cRefs)
    {
        delete this;
        return 0;
    }
    return _cRefs;
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::SetFlag/ClearFlag/IsFlagSet
//
//  Synopsis:   Manage CRequest flags
//
//-----------------------------------------------------------------------------

inline void
CRequest::SetFlag(REQUESTFLAGS rf)
{
    _grfFlags |= rf;
}

inline void
CRequest::ClearFlag(REQUESTFLAGS rf)
{
    _grfFlags &= ~rf;
}

inline BOOL
CRequest::IsFlagSet(REQUESTFLAGS rf) const
{
    return _grfFlags & rf;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRequest::QueuedOnLayout/DequeueFromLayout/GetLayout/SetLayout
//
//  Synopsis:   Manage CRequest layout pointers
//
//-----------------------------------------------------------------------------

inline BOOL
CRequest::QueuedOnLayout(
    CLayout *   pLayout) const
{
    return  _pLayoutMeasure  == pLayout
        ||  _pLayoutPosition == pLayout
        ||  _pLayoutAdorner  == pLayout;
}

// See header for description of differences between DequeueFromLayout
// and RemoveFromLayouts.
void
CRequest::DequeueFromLayout(
    CLayout *   pLayout)
{
    if (_pLayoutMeasure == pLayout)
    {
        _pLayoutMeasure = NULL;
    }

    if (_pLayoutPosition == pLayout)
    {
        _pLayoutPosition = NULL;
    }

    if (_pLayoutAdorner == pLayout)
    {
        _pLayoutAdorner = NULL;
    }
}

void
CRequest::RemoveFromLayouts()
{
    int nReleases = 0;

    // Various layouts could have us queued.  Recall
    // that these ptrs may point to 3 different layouts,
    // or all to the same layout.  We need to figure out
    // how many distinct layouts were holding onto us; this
    // is equivalent to the # of refs that are held on us.
    // We do the releases all at the end, because we'll
    // self-destruct when the last release happens!
    if (_pLayoutMeasure)
    {
        nReleases += _pLayoutMeasure->FlushRequest( this );
    }

    if (_pLayoutPosition)
    {
        nReleases += _pLayoutPosition->FlushRequest( this );
    }

    if (_pLayoutAdorner)
    {
        nReleases += _pLayoutAdorner->FlushRequest( this );
    }

    // Can't touch "this" after this loop; we'll be deleted.
    while (nReleases)
    {
        Release();
        nReleases--;
    }
}

CLayout *
CRequest::GetLayout(
    REQUESTFLAGS    rf) const
{
    switch (rf)
    {
    default:
    case RF_MEASURE:    return _pLayoutMeasure;
    case RF_POSITION:   return _pLayoutPosition;
    case RF_ADDADORNER: return _pLayoutAdorner;
    }
}

inline void
CRequest::SetLayout(
    REQUESTFLAGS    rf,
    CLayout *       pLayout)
{
    switch (rf)
    {
    case RF_MEASURE:    _pLayoutMeasure  = pLayout; break;
    case RF_POSITION:   _pLayoutPosition = pLayout; break;
    case RF_ADDADORNER: _pLayoutAdorner  = pLayout; break;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::GetElement/GetAdorner/SetAdorner/GetAuto/SetAuto
//
//  Synopsis:   Various CRequest accessors
//
//-----------------------------------------------------------------------------

#ifdef ADORNERS
inline CAdorner *
CRequest::GetAdorner() const
{
    return _pAdorner;
}

inline void
CRequest::SetAdorner(CAdorner * pAdorner)
{
    Assert(pAdorner);

    if (pAdorner != _pAdorner)
    {
        if (_pAdorner)
        {
            _pAdorner->Release();
        }

        pAdorner->AddRef();
        _pAdorner = pAdorner;
    }
}

#endif // ADORNERS

inline CElement *
CRequest::GetElement() const
{
    return _pElement;
}

inline CPoint &
CRequest::GetAuto()
{
    return _ptAuto;
}

void
CRequest::SetAuto(const CPoint & ptAuto, BOOL fAutoValid)
{
    if (fAutoValid)
    {
        _ptAuto    = ptAuto;
        _grfFlags |= RF_AUTOVALID;
    }
    else
    {
        _grfFlags &= ~RF_AUTOVALID;
    }
}

#if DBG==1
inline void
CRequest::DumpRequest(void)
{
    TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                "\t Req=0x%x f=0x%x e=[0x%x,%S sn=%d] pt=%d,%d Mly=0x%x [e=0x%x,%S sn=%d] Ply=0x%x [e=0x%x,%S sn=%d] Aly=0x%x [e=0x%x,%S sn=%d] refs=%d",
                this,
                _grfFlags,
                _pElement, _pElement->TagName(), _pElement->_nSerialNumber,
                _ptAuto.x, _ptAuto.y,
                _pLayoutMeasure, (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner : 0), (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner->TagName() : _T("")), (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner->_nSerialNumber : 0),
                _pLayoutPosition, (_pLayoutPosition ? _pLayoutPosition->_pElementOwner : 0), (_pLayoutPosition ? _pLayoutPosition->_pElementOwner->TagName() : _T("")), (_pLayoutPosition ? _pLayoutPosition->_pElementOwner->_nSerialNumber : 0),
                _pLayoutAdorner, (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner : 0), (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner->TagName() : _T("")), (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner->_nSerialNumber : 0),
                _cRefs
              ));
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::CLayout
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//---------------------------------------------------------------

CLayout::CLayout(CElement * pElementLayout, CLayoutContext * pLayoutContext) :
    CLayoutInfo( pElementLayout )
{
    Assert(_pDocDbg && _pDocDbg->AreLookasidesClear( this, LOOKASIDE_LAYOUT_NUMBER ) );

    _ulRefs = 1;

    SetSizeThis( TRUE );
    _fContentsAffectSize = TRUE;
    _fAutoBelow          = FALSE;
    _fPositionSet        = FALSE;
    _fPositionedOnce     = FALSE;
    _fContainsRelative   = FALSE;
    _fEditableDirty      = TRUE;
    _fHasMarkupPtr       = FALSE;

    _fAllowSelectionInDialog = FALSE;

    _yDescent = -1;

    if (pLayoutContext)
        SetLayoutContext(pLayoutContext);
}

CLayout::~CLayout()
{
    Assert(!_pDispNode);
}

CDoc *
CLayout::Doc() const
{
    Assert( _pDocDbg == ( _fHasMarkupPtr ? _pMarkup->Doc() : _pDoc ) );
    return _fHasMarkupPtr ? _pMarkup->Doc() : _pDoc;
}

CFlowLayout *
CElement::HasFlowLayout( CLayoutContext * pLayoutContext )
{
    CLayout     * pLayout = GetUpdatedLayout( pLayoutContext );

    return (pLayout ? pLayout->IsFlowLayout() : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     Init, virtual
//
//  NOTE:       every derived class overriding it should call super::Init
//
//-----------------------------------------------------------------------------

HRESULT
CLayout::Init()
{
    HRESULT         hr = S_OK;

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   Dequeue the pending layout request (if any)
//
//-----------------------------------------------------------------------------
HRESULT
CLayout::OnExitTree()
{
    Reset(TRUE);

    DestroyDispNode();

    //
    // Make sure we do a full recalc if we get added back into a tree somewhere.
    //
    SetSizeThis( TRUE );

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     Reset
//
//  Synopsis:   Dequeue the pending layout request (if any)
//
//  Arguments:  fForce - TRUE to always reset, FALSE only reset if there are no pending requests
//
//-----------------------------------------------------------------------------
void
CLayout::Reset(
    BOOL    fForce)
{
    if (fForce)
    {
        RemoveLayoutRequest();
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Prepares the layout for destruction.  After detaching, there
//              should be no one pointing to us, and we should no longer be
//              holding any resources.
//
//-----------------------------------------------------------------------------
void
CLayout::Detach()
{
    // Destroy the primary display node
    DestroyDispNode();

    // Flush requests HELD by this layout (it's now incapable of servicing them)
    FlushRequests();

    // Flush requests MADE by this layout on the view (it no longer needs them to be serviced)
    Reset( TRUE );

    if ( HasLayoutContext() )
    {
        // layout may have array of cloned disp node in print view.
        // NOTE: destrying should be done before layout context deletion !!!
        DestroyDispNodeArray();

        // We were in a layout context, which may or may not be invalid at this point.

        // Flush requests MADE ON this layout (for positioned elements) in
        // its viewchain.
        // Recall compatible contexts never have viewchains.
        // If this layout is in an invalid context, it will be unable to get a viewchain;
        //   however, it might have still have entries in the viewchain's queue.  This is safe
        //   because the viewchain will check for a layout's context's validity during queue
        //   processing.
        //
        // Note, this should only have significance if we are the position parent
        // for positioned elements.  It is safe (though unnecessary) to make this
        // call anyhow.  under dynamic view templates we may want to try to make
        // this more intelligent.
        CViewChain *pViewChain = LayoutContext()->ViewChain();
        if ( pViewChain )
        {
            pViewChain->FlushRequests( this );
        }
        // FUTURE : Figure out what asserts can go in an 'else' clause here.

        // Stop being in layout context
        DeleteLayoutContext();
    }

    if ( HasDefinedLayoutContext() )
    {
        // Stop defining a layout context
        DeleteDefinedLayoutContext();
    }

    // we are detached, no longer maintain a pointer to our element
    _pElementOwner = NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------
HRESULT
CLayout::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown)
    {
        *ppv = this;
    }

    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     UpdateScrollbarInfo, protected
//
//  Synopsis:   Update CDispNodeInfo to reflect the correct scroll-related settings
//
//-------------------------------------------------------------------------
void
UpdateScrollInfo(CDispNodeInfo * pdni, const CLayout * pLayout )
{
    Assert(pLayout);
    Assert(     pLayout->ElementOwner()->Tag() == ETAG_HTML
            ||  pLayout->ElementOwner()->Tag() == ETAG_BODY );
    BOOL      fBody         = (pLayout->ElementOwner()->Tag() == ETAG_BODY);
    CMarkup * pMarkup       = pLayout->GetOwnerMarkup();
    CElement* pBody         = NULL;

    Assert(pMarkup);
    Assert(pMarkup->GetElementClient());
    Assert(!pLayout->ElementOwner()->IsInViewLinkBehavior( TRUE ));

    // Find a BODY.
    // While we may want to do some of this for an HTML node containing a BODY, this is more of a departure from existing behavior.
    pBody = fBody ?  pLayout->ElementOwner() : pMarkup->GetElementClient();
    Assert(pBody && pBody->Tag() == ETAG_BODY);     // Only BODY's, right now.  SHould have been checked by caller.

    DWORD     dwFrameOptions;
    CDoc    * pDoc = pMarkup->Doc();
    Assert(pDoc);

    //
    //  Treat the top-level print document as having clipping
    //
    if (pMarkup->IsPrintMedia())
    {
        CElement * pRoot = pMarkup->Root();
        CElement * pMaster = pRoot ? pRoot->GetMasterPtr() : NULL;

        // check that this is not document inside frame 
        if (pMaster == NULL || (pMaster->Tag() != ETAG_FRAME && pMaster->Tag() != ETAG_IFRAME))
        {
            pdni->_overflowX =
            pdni->_overflowY = styleOverflowHidden;
        }
    }


    dwFrameOptions =    pMarkup->GetFrameOptions()
                            &  (    FRAMEOPTIONS_SCROLL_NO                                                           
                                |   FRAMEOPTIONS_SCROLL_YES
                                |   FRAMEOPTIONS_SCROLL_AUTO );

    //
    //  If overflow was not set or there are related frame options
    //
    if (    pdni->_overflowX == styleOverflowNotSet
        ||  pdni->_overflowY == styleOverflowNotSet
        ||  dwFrameOptions )
    {
        
        if (    pMarkup->IsPrimaryMarkup()
            &&  pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_SCROLL_NO)
        {
            dwFrameOptions = FRAMEOPTIONS_SCROLL_NO;
        }
        else
        {
            switch (((CBodyElement *)pBody)->GetAAscroll())
            {
            case bodyScrollno:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_NO;
                break;

            case bodyScrollyes:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_YES;
                break;

            case bodyScrollauto:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_AUTO;
                break;

            case bodyScrolldefault:
                if (!dwFrameOptions && !pDoc->_fViewLinkedInWebOC)
                {
                    dwFrameOptions = FRAMEOPTIONS_SCROLL_YES;
                }
                break;
            }
        }

        switch (dwFrameOptions)
        {
        // scrollAuto case cares about the current overflow values whereas scrollNo case
        // does not. If scrollNo is set, then we are overriding any other setting.
        case FRAMEOPTIONS_SCROLL_NO:
            pdni->_overflowX = styleOverflowHidden;
            pdni->_overflowY = styleOverflowHidden;
            if (fBody)
                ((CBodyLayout *)pLayout)->SetForceVScrollBar(FALSE);
            break;

        case FRAMEOPTIONS_SCROLL_AUTO:      
            if (pdni->_overflowX == styleOverflowNotSet)
                pdni->_overflowX = styleOverflowAuto;
            if (pdni->_overflowY == styleOverflowNotSet)
            {
                if (fBody)
                    ((CBodyLayout *)pLayout)->SetForceVScrollBar(TRUE);
                pdni->_overflowY = styleOverflowAuto;
            }
            break;

        case FRAMEOPTIONS_SCROLL_YES:
        default:
            pdni->_sp._fHSBAllowed = TRUE;
            pdni->_sp._fHSBForced  = FALSE;
            pdni->_sp._fVSBAllowed = TRUE;
            pdni->_sp._fVSBForced  = (dwFrameOptions == FRAMEOPTIONS_SCROLL_YES) || !pDoc->_fViewLinkedInWebOC;
            break;
        }
    }

    //
    //  If an overflow value was set or generated, set the scrollbar properties using it
    //

    if (    pdni->_overflowX != styleOverflowNotSet
        ||  pdni->_overflowY != styleOverflowNotSet)
    {
        pLayout->GetDispNodeScrollbarProperties(pdni);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::SubtractClientRectEdges
//
//  Synopsis:   Takes a rectangle of indeterminate size and subtracts off 
//              room for borders and/or scrollbar.
//
//              This used to be:  GetClientRect(prc, cs, CLIENTRECT_USERECT, pdci)
//              However, since one isn't actually getting a rect (just subtracting off
//              allocated space), this is now a separate function.
//
//
//  Arguments:  prc  - Input rectangle; border/scrollbar space will be subtracted from each side
//              pdci - doc calc info
//
//-------------------------------------------------------------------------
void
CLayout::SubtractClientRectEdges(
    CRect *             prc,
    CDocInfo *          pdci)
{
    Assert(prc);
    Assert(pdci);

    //Theoretically we should call GetDispNodeInfo here but it's too expensive.
    //Some code from there was moved here as a result.

    //first, get border widths
    CElement *     pElement = ElementOwner();
    CBorderInfo    bi;
    DISPNODEBORDER dnbBorders = ( pElement->Tag() == ETAG_SELECT
                            ? DISPNODEBORDER_NONE
                            : (DISPNODEBORDER)pElement->GetBorderInfo(
                                    pdci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext())));

    Assert( dnbBorders == DISPNODEBORDER_NONE
        ||  dnbBorders == DISPNODEBORDER_SIMPLE
        ||  dnbBorders == DISPNODEBORDER_COMPLEX);

    //border occupies some space - subtract it
    if (dnbBorders != DISPNODEBORDER_NONE)
    {
        prc->left   += bi.aiWidths[SIDE_LEFT];
        prc->top    += bi.aiWidths[SIDE_TOP];
        prc->right  -= bi.aiWidths[SIDE_RIGHT];
        prc->bottom -= bi.aiWidths[SIDE_BOTTOM];
    }

    //now, let's see if we need to subtract scrollbars width
    //these two bits..
    BOOL fVScrollbarForced;
    BOOL fHScrollbarForced;

    //will be gotten from back-end store here... (simplified code from GetDispNodeInfo)
    {   
        //  Never allow scroll bars on an object.  The object is responsible for that.
        //  Bug #77073  (greglett)
        if (pElement->Tag() == ETAG_OBJECT)
        {
            fVScrollbarForced = FALSE;
            fHScrollbarForced = FALSE;
        }
        else 
        {
            CDispNodeInfo       dni;
            CTreeNode *         pTreeNode   = pElement->GetFirstBranch();
            const BOOL          fHTMLLayout = IsHtmlLayoutHelper(GetOwnerMarkup());
            const CFancyFormat *pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  *pCF         = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            const BOOL  fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
            const BOOL  fWritingModeUsed    = pCF->_fWritingModeUsed;

            dni._overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
            dni._overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);

            // In design mode, we want to treat overflow:hidden containers as overflow:visible
            // so editors can get to all their content.  This fakes out the display tree
            // so it creates CDispContainer*'s instead of CDispScroller, and hence doesn't
            // clip as hidden normally does. (KTam: #59722)
            // The initial fix is too aggressive; text areas implicitly set overflowX hidden
            // if they're in wordwrap mode.  Fix is to not do this munging for text areas..
            // Need to Revisit this
            // (carled) other elements (like inputText & inputButton) aslo implicitly set this property. (82287)
            if (   pElement->IsDesignMode()
                && pElement->Tag() != ETAG_TEXTAREA
                && pElement->Tag() != ETAG_INPUT
                && pElement->Tag() != ETAG_BUTTON)
            {
                if ( dni._overflowX  == styleOverflowHidden )
                {
                    dni._overflowX = styleOverflowVisible;
                }
                if ( dni._overflowY == styleOverflowHidden )
                {
                    dni._overflowY = styleOverflowVisible;
                }
            }

            if (((   !fHTMLLayout
                     && pElement->Tag() == ETAG_BODY )
                 || (   fHTMLLayout
                     && pElement->Tag() == ETAG_HTML
                     && GetOwnerMarkup()->GetElementClient()
                     && GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY )
                   )
                 && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
            {
                UpdateScrollInfo(&dni, this);
            }
            else
            {   
                GetDispNodeScrollbarProperties(&dni);
            }

            fVScrollbarForced = dni.IsVScrollbarForced();
            fHScrollbarForced = dni.IsHScrollbarForced();    
        }
    }

    if (    fVScrollbarForced
        ||  ForceVScrollbarSpace()
        ||  _fNeedRoomForVScrollBar)
    {
        prc->right -= pdci->DeviceFromHimetricX(g_sizelScrollbar.cx);
    }

    if (fHScrollbarForced)
    {
        prc->bottom -= pdci->DeviceFromHimetricY(g_sizelScrollbar.cy);
    }

    prc->MoveToOrigin();

    if (prc->right < prc->left)
    {
        prc->right = prc->left;
    }
    if (prc->bottom < prc->top)
    {
        prc->bottom = prc->top;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientRect
//
//  Synopsis:   Return client rectangle
//
//              This routine, by default, returns the rectangle in which
//              content should be measured/rendered, the region inside
//              the borders (and scrollbars - if a vertical scrollbar is
//              allowed, space for it is always removed, even if it is not
//              visible).
//              The coordinates are relative to the top of the content -
//              meaning that, for scrolling layouts, the scroll offset is
//              included.
//
//              The following flags can be used to modify this behavior:
//
//                  COORDSYS_xxxx   - Target coordinate system
//                  CLIENTRECT_CONTENT     - Return standard client rectangle (default)
//                  CLIENTRECT_BACKGROUND  - Return the rectangle for the background
//                                    (This generally the same as the default rectangle
//                                     except no space is reserved for the vertical
//                                     scrollbar)
//
//  Arguments:  pDispNode - the dispNode to be examined
//              prc  - returns the client rect
//              cs   - COORDSYS_xxxx
//              crt  - CLIENTRECT_xxxx
//
//  Inline this?  Called frequently, but not in large/tight loops.
//
//-------------------------------------------------------------------------
void
CLayout::GetClientRect(
    const CDispNode *   pDispNode,                        
    CRect *             prc,
    COORDINATE_SYSTEM   cs,
    CLIENTRECT          crt) const
{
    Assert(prc);

    if (pDispNode)
    {
        pDispNode->GetClientRect(prc, crt);

        // NOTE(Donmarsh+Sujalp): This used to be COORDSYS_FLOWCONTENT, instead of the current
        // COORDSYS_CONTENT. FLOWCONTENT was incorrect, because the rect going in was a
        // CONTENT rect and not a FLOWCONTENT rect. That's because GetClientRect returns a
        // CONTENT rect and not a FLOWCONTENT rect. This bug was exposed in bug 83091.
        pDispNode->TransformRect(*prc, COORDSYS_CONTENT, prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member: CLayout::RestrictPointToClientRect
//
//  Params: [ppt]: The point to be clipped to the client rect of the elements
//                 layout. The point coming in is assumed to be in global
//                 client window coordinates.
//
//  Descr:  This function converts a point in site relative coordinates
//          to global client window coordinates.
//
//----------------------------------------------------------------------------
void
CLayout::RestrictPointToClientRect(POINT *ppt)
{
    RECT rcClient;

    Assert(ppt);

    GetClientRect(&rcClient, COORDSYS_GLOBAL);

    ppt->x = max(ppt->x, rcClient.left);
    ppt->x = min(ppt->x, (long)(rcClient.right - 1));
    ppt->y = max(ppt->y, rcClient.top);
    ppt->y = min(ppt->y, (long)(rcClient.bottom - 1));
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::GetClippedClientRect
//
//  Synopsis:   Return the clipped client rectangle
//
//              This routine functions the same as GetClientRect
//
//  Arguments:  prc  - returns the client rect
//              cs   - COORDSYS_xxxx
//              crt  - CLIENTRECT_xxxx
//
//-------------------------------------------------------------------------

void
CLayout::GetClippedClientRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs,
    CLIENTRECT          crt) const
{
    Assert(prc);

    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode)
    {
        pDispNode->GetClippedClientRect(prc, crt);
        pDispNode->TransformRect(*prc, COORDSYS_FLOWCONTENT, prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CLayout::CalcSize
//
//  Synopsis:   Calculate the size of the object
//
//              Container elements call this on children whenever they need the size
//              of the child during measuring. (The child may or may not measure its
//              contents in response.)
//
//              NOTE: There is no standard helper for assisting containers with
//                    re-sizing immediate descendents. Each container must implement
//                    its own algorithms for sizing children.
//
//  Arguments:  pci       - Current device/transform plus
//                  _smMode     - Type of size to calculate/return
//                                  SIZEMODE_NATURAL  - Return object size using pDI._sizeParent,
//                                                      available size, user specified values,
//                                                      and object contents as input
//                                  SIZEMODE_MMWIDTH  - Return the min/maximum width of the object
//                                  SIZEMODE_SET      - Override/set the object's size
//                                                      (must be minwidth <= size.cx <= maxwidth)
//                                  SIZEMODE_PAGE     - Return object size on the current page
//                                  SIZEMODE_MINWIDTH - Return the minimum width of the object
//                  _grfLayout  - One or more LAYOUT_xxxx flags
//                  _hdc        - Measuring HDC (cannot be used for rendering)
//                  _sizeParent - Size of parent site
//                  _yBaseLine  - y offset of baseline (returned for SIZEMODE_NATURAL)
//              psize     - Varies with passed SIZEMODE
//                          NOTE: Available size is usually that space between the where
//                                the site will be positioned and the right-hand edge. Percentage
//                                sizes are based upon the parent size, all others use available
//                                size.
//                              SIZEMODE_NATURAL  - [in]  Size available to the object
//                                                  [out] Object size
//                              SIZEMODE_MMWIDTH  - [in]  Size available to the object
//                                                  [out] Maximum width in psize->cx
//                                                        Minimum width in psize->cy
//                                                        (If the minimum cannot be calculated,
//                                                         psize->cy will be less than zero)
//                              SIZEMODE_SET      - [in]  Size object should become
//                                                  [out] Object size
//                              SIZEMODE_PAGE     - [in]  Available space on the current page
//                                                  [out] Size of object on the current page
//                              SIZEMODE_MINWIDTH - [in]  Size available to the object
//                                                  [out] Minimum width in psize->cx
//              psizeDefault - Default size (optional)
//
//  Returns:    S_OK if the calcsize is successful
//
//--------------------------------------------------------------------------
//
// NOTE: CalcSize vs. CalcSizeVirtual
//
// CalcSize is a non-virtual method, defined on CLayout only. It should not ever be overridden.
// CalcSizeVirtual does most of actual work, it is virtual, and is defined on CLayout and most
// derivatives.
//
// Everybody interested in an element's size should call CalcSize.
// CalcSizeVirtual is only doing the work that is *different* in various layout classes, and
// is designed to only be called from CLayout and its derivatives (it is protected for that reason).
//
//--------------------------------------------------------

MtDefine( CalcSize, LayoutMetrics, "CalcSize called" );

DWORD
CLayout::CalcSize( CCalcInfo * pci,
                   SIZE * psize,
                   SIZE * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::CalcSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    PerfDbgLog(tagLayoutCalcSize, this, "+CLayout::CalcSize");
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    MtAdd( Mt(CalcSize), 1, 0 );

    // Check that we don't get called recursively on same layout. We'll hang if it happens
    AssertSz(_cNestedCalcSizeCalls == 0, "Nested call to CalcSize! Must be a misuse of CalcSize vs. CalcSizeVirtual.");
    WHEN_DBG(_cNestedCalcSizeCalls++);

    AssertSz(CHK_CALCINFO_PPV(pci), "PPV members of CCalcInfo should stay untouched in browse mode !");

    CCalcInfo calcinfoLocal;
    CCalcInfo *pciOrig = NULL;
    BOOL fResolutionChange = FALSE;
    CLayoutContext * pLayoutContext        = pci->GetLayoutContext();
    CLayoutContext * pDefinedLayoutContext = DefinedLayoutContext();
    BOOL             fViewChain = (pLayoutContext && pLayoutContext->ViewChain());

#if DBG==1
    int cyAvailableHeightDbg = pci->_cyAvail;
#endif

    // For resolution nodes, Initialize local calc info to a different resolution
    // Note: we don't need to do anything if a parent has defined resolution. It is passed in pci.
    if (pDefinedLayoutContext && pDefinedLayoutContext->GetMedia() != mediaTypeNotSet)
    {
        fResolutionChange = TRUE;
        // NOTE (olego) : in a case when pci is CTableCalcInfo all children layouts will never get 
        // this information so at least two pieces of functionality will be broken: 
        // 1) CTableCalcInfo->_fDontSaveHistory will never be set (potential history navigation bug); 
        // 2) counter of table nesting will be wrong;
        calcinfoLocal.Init(pci);

        CUnitInfo const* pUnitInfo = GetView()->GetMeasuringDevice(pDefinedLayoutContext->GetMedia())->GetUnitInfo();
        calcinfoLocal.SetUnitInfo(pUnitInfo);

        pci = &calcinfoLocal;

        // TODO LRECT 112511: this is being done in Container layout anyway, will not be needed when merged.
        pci->SetLayoutContext( pDefinedLayoutContext );

    }

    // save pre-transform sizes
    CSize sizeOrgTransformed = *psize;
    CSize sizeDefaultOrgTransformed = psizeDefault ? *psizeDefault : CSize(0,0);

    // transform input sizes to content coordinates
    CRect rc(*psize); // note: origin unimportant for size transformations
    CDispTransform transform;
    BOOL fTransform = GetElementTransform(&rc, &transform, NULL) && !transform.IsOffsetOnly();
    if (fTransform)
    {
        CSize sizeAvail(0, 0);

        if (fViewChain)
        {
            sizeAvail.cx = psize->cx;
            sizeAvail.cy = pci->_cyAvail;
        }

        if (pci != &calcinfoLocal)
        {
            calcinfoLocal.Init(pci);
            pciOrig = pci;
            pci = &calcinfoLocal;
        }

        transform.GetWorldTransform()->Untransform((CSize *)&pci->_sizeParentForVert);
        transform.GetWorldTransform()->Untransform((CSize *)&pci->_sizeParent);
        transform.GetWorldTransform()->Untransform((CSize *)psize);
        transform.GetWorldTransform()->Untransform((CSize *)&sizeAvail);
        pci->_cyAvail        = sizeAvail.cy;
        pci->_cxAvailForVert = sizeAvail.cx;
        if (psizeDefault)
            transform.GetWorldTransform()->Untransform((CSize *)psizeDefault);
    }

    // save untransformed sizes
    CSize sizeOrg = *psize;
    CSize sizeDefaultOrg = psizeDefault ? *psizeDefault : CSize(0,0);

    DWORD dwResult = CalcSizeVirtual(pci, psize, psizeDefault);



    // save calculated sizes before transformations
    CSize sizeNew = *psize;
    CSize sizeDefaultNew = psizeDefault ? *psizeDefault : CSize(0,0);

    // transform result to parent coordinates
    if (fTransform)
    {
        transform.GetWorldTransform()->Transform((CSize *)psize);

        // in min/max mode size is not a size, but an array of 2 widths.
        // rotation would do wrong thing there, hence special case
        if (pci->_smMode == SIZEMODE_MMWIDTH &&
            transform.GetWorldTransform()->GetAngle() % 1800)
        {
            // It is unlear what to do with min/max info on an arbitrary rotated cell.
            // For now, only handle 90 degrees
            Assert(transform.GetWorldTransform()->GetAngle() % 900 == 0);

            // restore proper order of min and max in psize
            ((CSize *)psize)->Flip();
        }


        if (psizeDefault)
            transform.GetWorldTransform()->Transform((CSize *)psizeDefault);

        // copy ppv information back to original pci
        if (pciOrig)
        {
            pciOrig->_fLayoutOverflow |= pci->_fLayoutOverflow;
            pciOrig->_fHasContent |= pci->_fHasContent;
        }
    }

    // Make sure we are not loosing precision in two-way transforms when sizes don't change
    if (sizeNew == sizeOrg)
        *psize = sizeOrgTransformed;

    if (psizeDefault && sizeDefaultNew == sizeDefaultOrg)
        *psizeDefault = sizeDefaultOrgTransformed;


    // update display node transform if needed
    // TODO 15040: node transform is also set from CalcSizeVirtual. 
    //                 100% of node sizing logic should be here.
    if (fTransform && _pDispNode && _pDispNode->HasUserTransform()
        && (pci->_smMode == SIZEMODE_NATURAL ||
            pci->_smMode == SIZEMODE_SET ||
            pci->_smMode == SIZEMODE_FULLSIZE))

    {
        // NOTE: we currently need this here because CalcSizeVirtual doesn't know if
        //       transformation has changed when pre-transform size is same
        CSize sizeDN;
        GetApparentSize(&sizeDN);
        if (sizeDN != *psize)
        {
            Assert(_pDispNode);
            SizeDispNodeUserTransform(pci, sizeNew, _pDispNode);
        }
    }

    Assert(pciOrig || cyAvailableHeightDbg == pci->_cyAvail);

    if (    pLayoutContext
        &&  pLayoutContext->ViewChain()
        &&  pci->_smMode != SIZEMODE_MMWIDTH
        &&  pci->_smMode != SIZEMODE_MINWIDTH
        &&  ElementCanBeBroken())
    {
        CLayoutBreak *pLayoutBreak;
        pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);

        if (pLayoutBreak)
        {
            pLayoutBreak->CacheAvailHeight(pci->_cyAvail);
        }
    }

    WHEN_DBG(_cNestedCalcSizeCalls--);
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::CalcSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    PerfDbgLog3(tagLayoutCalcSize, this, "-CLayout::CalcSize (%S, %S, m:%d)", ElementOwner()->TagName(), ElementOwner()->GetIdentifier() ? ElementOwner()->GetIdentifier() : L"", pci->_smMode);
    return dwResult;
}

DWORD
CLayout::CalcSizeVirtual( CCalcInfo * pci,
                          SIZE * psize,
                          SIZE * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(pci);
    Assert(psize);
    Assert(ElementOwner());
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CSize           size(0,0);
    SIZE            sizeOriginal;
    CTreeNode     * pTreeNode = GetFirstBranch();
    DWORD           grfReturn;
    CPeerHolder   * pPH = ElementOwner()->GetLayoutPeerHolder();
    CSize           sizeZero(0,0); // not static to favour data locality; not g_Zero because psizeDefault isn't const*


    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "_fForceLayout is on"));
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "LAYOUT_FORCE is on"));
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    //
    // Ensure the display nodes are correct
    // (If they change, then force measuring since borders etc. may need re-sizing)
    //

    if (    pci->IsNaturalMode()
        &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
    {
        grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        SetSizeThis( TRUE );
    }

    //
    // If this object needs sizing, then determine its size
    //-----------------------------------------------------
    if (   pPH
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // There is a peer layout that wants full_delegation of the sizing.
        POINT pt;

        pt.x = pt.y = 0;

        //NOTE: It doesn't make sense to honor the offsetPoint here
        DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                         pPH, pci, size, &pt, &size);
    }
    else
    {
        if (pci->_smMode != SIZEMODE_SET)
        {
            if ( IsSizeThis() )
            {
                const CFancyFormat * pFF     = pTreeNode->GetFancyFormat();
                const CCharFormat  * pCF     = pTreeNode->GetCharFormat();
                BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
                const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);

                // If no defaults are supplied, assume zero as the default
                if (!psizeDefault)
                {
                    psizeDefault = &sizeZero;
                }

                // Set size from user specified or default values
                // (Also, "pin" user specified values to nothing less than zero)
                size.cx = (cuvWidth.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                ? psizeDefault->cx
                                : max(0L, cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                            pTreeNode->GetFontHeightInTwips(&cuvWidth))));

                size.cy = (cuvHeight.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                ? psizeDefault->cy
                                : max(0L, cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pTreeNode->GetFontHeightInTwips(&cuvHeight))));

                if (ElementOwner()->Tag() == ETAG_ROOT)
                {
                    _fContentsAffectSize = FALSE;
                }
                else if (ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_BODY))
                {
                    Assert(ElementOwner()->Tag() == ETAG_FRAMESET); // BODY should not get here.

                    if (!GetOwnerMarkup()->IsHtmlLayout())
                    {
                        size.cx = max(size.cx, pci->_sizeParent.cx);
                        size.cy = max(size.cy, pci->_sizeParent.cy);
                    }
                    else
                    {
                        //  We really should set this as psizeDefault...
                        if (cuvWidth.IsNullOrEnum())
                            size.cx = psize->cx;
                        if (cuvHeight.IsNullOrEnum())
                            size.cy = psize->cy;
                    }

                    _fContentsAffectSize = FALSE;
                }
                else
                {
                    _fContentsAffectSize = (    (   cuvWidth.IsNullOrEnum()
                                                ||  cuvHeight.IsNullOrEnum())
                                            &&  !(pci->_grfLayout & LAYOUT_USEDEFAULT));
                }
            }
            else
            {
                GetSize(&size);
            }
        }
        else
        {
            // If the object's size is being set, take the passed size
            size = *psize;
        }


        // at this point the size has been computed, but only delgate if we had to compute
        // the size, and they didn't also ask for full delegation
        if (   pPH
            && IsSizeThis()
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            // There is a peer layout that wants to modify the natural sizing
            POINT pt;

            pt.x = pt.y = 0;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, pci, size, &pt, &size);
        }
    } // end else, not full delegation


    // Return the size of the object (as per the request type)
    switch (pci->_smMode)
    {
    case SIZEMODE_NATURAL:
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_FULLSIZE:

        SetSizeThis( FALSE );

        grfReturn  |= LAYOUT_THIS |
                      (size.cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0)  |
                      (size.cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);

        //
        // If size changed, resize display nodes
        //

        if (   _pDispNode
            && (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
        {
            SizeDispNode(pci, size);

            if (ElementOwner()->IsAbsolute())
            {
                ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
            }
        }

        //if there is a map size peer (like glow filter) that silently modifies the size of
        //the disp node, ask what the size is..
        if(HasMapSizePeer())
            GetApparentSize(psize);
        else
            *psize = size;

        break;

    case SIZEMODE_MMWIDTH:
    case SIZEMODE_MINWIDTH:
        // Use the object's width, unless it is a percentage, then use zero
        {
            const CCharFormat *pCF = pTreeNode->GetCharFormat();
            const CUnitValue & cuvWidth = pTreeNode->GetFancyFormat()->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            psize->cx = psize->cy = cuvWidth.IsPercent() ? 0 : size.cx;

            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cy = psize->cx = rectMapped.Width();
                }
            }

            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
        break;

    case SIZEMODE_PAGE:
        // Use the object's size if it fits, otherwise use zero
        psize->cx = (size.cx < psize->cx
                            ? size.cx
                            : 0);
        psize->cy = (size.cy < psize->cy
                            ? size.cy
                            : 0);
        break;

    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

//+---------------------------------------------------------------------------
//
//  Member : DelegateCalcSize
//
//  synopsis : INternal helper to encapsulate the logic of delegating the
//      calcsize to the layoutBehavior
//
//----------------------------------------------------------------------------
void
CLayout::DelegateCalcSize( BEHAVIOR_LAYOUT_INFO eMode,
                           CPeerHolder        * pPH,
                           CCalcInfo          * pci,
                           SIZE                 sizeNatural,
                           POINT              * pptOffset ,
                           SIZE               * psizeRet )
{
    LONG  lMode;

    Assert(pPH && pci);
    Assert(   ElementOwner()->HasPeerHolder() 
           || ElementOwner()->Tag()==ETAG_BODY
           || ElementOwner()->Tag()==ETAG_FRAMESET 
           || ElementOwner()->Tag()==ETAG_HTML);

    Assert(pptOffset && psizeRet && " internal helper needs return parameters");

    // set the mode enum to pass to the behavior, note the value of MMWidth
    lMode = (pci->_smMode == SIZEMODE_NATURAL) ? BEHAVIORLAYOUTMODE_NATURAL
                : (pci->_smMode == SIZEMODE_MMWIDTH) ? BEHAVIORLAYOUTMODE_MINWIDTH
                : (pci->_smMode == SIZEMODE_MINWIDTH) ? BEHAVIORLAYOUTMODE_MINWIDTH
                : (pci->_smMode == SIZEMODE_SET) ? BEHAVIORLAYOUTMODE_NATURAL
                : (pci->_smMode == SIZEMODE_NATURALMIN) ? BEHAVIORLAYOUTMODE_NATURAL
                : 0;

    if (pci->_fPercentSecondPass)
    {
        lMode |= BEHAVIORLAYOUTMODE_FINAL_PERCENT;
    }

    if (   pci->GetLayoutContext()                  // are we paginateing?
        && pci->GetLayoutContext()->ViewChain()     // and we are not in tables compat-pass
        && pci->GetLayoutContext()->GetMedia() == mediaTypePrint)
                                                    // and we are in print media
    {
        lMode |= BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION;
    }

    // for safety lets only make the call if it is a calcmode that we recognize
    if (lMode)
    {
        POINT                            ptTranslate = {0};
        CPeerHolder::CPeerHolderIterator iter;

        // OM protection code. IMPORTANT. also important: clear this.
        Doc()->GetView()->BlockViewForOM(TRUE);

        //
        // since multiple peers may be attached to this element, we need to provide
        // each of them with this call.  However, for fullDelegation, only the first wins.
        //  the other delgation modes all get multiple callouts.
        //
        if (eMode == BEHAVIORLAYOUTINFO_FULLDELEGATION)
        {
            pPH->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, psizeRet);
        }
        else
        {
            for (iter.Start(ElementOwner()->GetPeerHolder());
                 !iter.IsEnd();
                 iter.Step())
            {
                if (   iter.PH()->IsLayoutPeer()
                    && iter.PH()->TestLayoutFlags(eMode))
                {
                    iter.PH()->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, psizeRet);
                }
            }
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            //
            // in this case only, we just made a minsize call above, and now need
            // to call a second time asking for max size. In order to keep this
            // interface function clean, we do not expose the MM pass as a single
            // call the way it is handled internally. Instead we make two calls,
            // and munge the results together into the (internal) return value.
            // as a result, the behavior may be setting a min and max HEIGHT which
            // (today) we ignore.
            //
            lMode = BEHAVIORLAYOUTMODE_MAXWIDTH;
            CSize sizeMax;

            sizeMax.cx = psizeRet->cx;
            sizeMax.cy = psizeRet->cy;

            if (eMode == BEHAVIORLAYOUTINFO_FULLDELEGATION)
            {
                // important, not the different last paramenter, compared to the above call
                pPH->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, &sizeMax);
            }
            else
            {
                for (iter.Start(ElementOwner()->GetPeerHolder());
                     !iter.IsEnd();
                     iter.Step())
                {
                    if (   iter.PH()->IsLayoutPeer()
                        && iter.PH()->TestLayoutFlags(eMode))
                    {
                        // important, not the different last paramenter, compared to the above call
                        iter.PH()->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, &sizeMax);
                    }
                }
            }

            // if the user did not change the sizeMax, then the psizeRet remains the same.
            // and everything works as expected
            if ( psizeRet->cx != sizeMax.cx )
            {
                // otherwise use the behavior supplied width as the new max
                psizeRet->cy = sizeMax.cx;
            }
        }

        // get text descent
        LONG lTextDescent = 0;
        if (S_OK == pPH->GetTextDescent(&lTextDescent))
        {
            _yDescent = lTextDescent;
        }

        // cache ptTranslate in the layoutbag
        Assert( pPH->_pLayoutBag);
        pPH->_pLayoutBag->_ptTranslate = ptTranslate;

        // Clear the View state
        Doc()->GetView()->BlockViewForOM( FALSE );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::CalcAbsoluteSize
//
//  Synopsis:   Computes width and height of absolutely positioned element
//
//----------------------------------------------------------------------------
void
CLayout::CalcAbsoluteSize(CCalcInfo * pci,
                          SIZE * psize,
                          CRect * rcSize)
{
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CTreeNode   *pContext      = GetFirstBranch();
    const CFancyFormat * pFF   = pContext->GetFancyFormat();
    const CCharFormat  * pCF   = pContext->GetCharFormat();
    BOOL fVerticalLayoutFlow   = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed      = pCF->_fWritingModeUsed;
    styleDir bDirection        = pContext->GetCascadedBlockDirection();

    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvTop    = pFF->GetLogicalPosition(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvBottom = pFF->GetLogicalPosition(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvLeft   = pFF->GetLogicalPosition(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvRight  = pFF->GetLogicalPosition(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);

    BOOL  fLeftAuto   = cuvLeft.IsNullOrEnum();
    BOOL  fRightAuto  = cuvRight.IsNullOrEnum();
    BOOL  fWidthAuto  = cuvWidth.IsNullOrEnum();
    BOOL  fTopAuto    = cuvTop.IsNullOrEnum();
    BOOL  fBottomAuto = cuvBottom.IsNullOrEnum();
    BOOL  fHeightAuto = cuvHeight.IsNullOrEnum();

    Assert(rcSize);
    if (!rcSize)
        return;

    rcSize->SetRect(*psize);

/*
    POINT        ptPos         = g_Zero.pt;
    if (    (   fHeightAuto
            &&  fBottomAuto)
        ||  (   fLeftAuto
            &&  bDirection == htmlDirLeftToRight)
        ||  (   fRightAuto
            &&  bDirection == htmlDirRightToLeft))
    {
        GetUpdatedParentLayout()->GetPositionInFlow(ElementOwner(), &ptPos);
    }
*/

    if(fWidthAuto)
    {
        rcSize->left = !fLeftAuto
                        ? cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft))
                        : 0;

        rcSize->right = !fRightAuto
                        ? psize->cx -
                          cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight))
                        : psize->cx;
    }
    else
    {
        long offsetX = 0;
        rcSize->SetWidth(cuvWidth.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvWidth)));

        if (bDirection == htmlDirLeftToRight)
        {
            if (!fLeftAuto)
            {
                offsetX = cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft));
            }
            else if (!fRightAuto)
            {
                offsetX = psize->cx - rcSize->right
                          - cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight));
            }
        }
        else
        {
            if (!fRightAuto)
            {
                offsetX = psize->cx - rcSize->right
                          - cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight));
            }
            else if (!fLeftAuto)
            {
                offsetX = cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft));
            }
        }

        rcSize->OffsetX(offsetX);
    }


    if(fHeightAuto)
    {

        rcSize->top = !fTopAuto
                        ? cuvTop.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvTop))
                        : 0;

        rcSize->bottom = !fBottomAuto
                        ? psize->cy -
                          cuvBottom.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvBottom))
                        : psize->cy;
    }
    else
    {
        long offsetY = 0;
        rcSize->SetHeight(cuvHeight.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvHeight)));

        if (!fTopAuto)
        {
            offsetY = cuvTop.YGetPixelValue(
                            pci,
                            psize->cy,
                            pContext->GetFontHeightInTwips(&cuvTop));
        }
        else if (!fBottomAuto)
        {
            offsetY = psize->cy - rcSize->bottom
                      - cuvBottom.YGetPixelValue(
                            pci,
                            psize->cy,
                            pContext->GetFontHeightInTwips(&cuvBottom));
        }

        rcSize->OffsetY(offsetY);
    }
}




//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetRect
//
//  Synopsis:   Return the current rectangle of the layout
//
//  Arguments:  psize - Pointer to CSize
//              cs    - Coordinate system for returned values
//              dwBlockID - Layout block ID
//
//-----------------------------------------------------------------------------

void
CLayout::GetRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs
    ) const
{
    Assert(prc);
    CDispNode *pdn = _pDispNode;
    if (pdn)
    {
        pdn->GetBounds(prc, cs);
    }
        else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClippedRect
//
//  Synopsis:   Return the current clipped rectangle of the layout
//
//  Arguments:  prc   - Pointer to CRect
//              cs    - Coordinate system for returned values
//              dwBlockID - Layout block ID
//
//-----------------------------------------------------------------------------

void
CLayout::GetClippedRect(CRect *             prc,
                        COORDINATE_SYSTEM   cs    ) const
{
    Assert(prc);

    CDispNode *pdn =  _pDispNode;
    if (pdn)
    {
        pdn->GetClippedBounds(prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetExpandedRect
//
//  Synopsis:   Return the current expanded rectangle of the layout
//
//  Arguments:  prc - Pointer to CRect
//              cs    - Coordinate system for returned values
//
//-----------------------------------------------------------------------------

void
CLayout::GetExpandedRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs
    ) const
{
    Assert(prc);
    CDispNode *pdn = _pDispNode;
    if (pdn)
    {
        pdn->GetExpandedBounds(prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetSize
//
//  Synopsis:   Return the current width/height of the layout
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetSize(CSize * psize) const
{
    Assert(psize);

// NOTE: The following would be a nice assert. Unfortunately, it's not easily wired in right now
//         we should do the work to make it possible (brendand)
//    Assert((((CLayout *)this)->TestLock(CElement::ELEMENTLOCK_SIZING)) || !IsSizeThis());

    CDispNode *pdn = _pDispNode;

    *psize = (pdn) ? pdn->GetSize() : g_Zero.size;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetApparentSize
//
//  Synopsis:   Return the current width/height of the layout, taking
//              transformations into account.
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetApparentSize( CSize * psize ) const
{
    Assert(psize);

// NOTE: The following would be a nice assert. Unfortunately, it's not easily wired in right now
//         we should do the work to make it possible (brendand)
//    Assert((((CLayout *)this)->TestLock(CElement::ELEMENTLOCK_SIZING)) || !IsSizeThis());

    CDispNode *pdn =  _pDispNode;

    *psize = (pdn) ? pdn->GetApparentSize() : g_Zero.size;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetContentSize
//
//  Synopsis:   Return the width/height of the content
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetContentSize(
    CSize * psize,
    BOOL    fActualSize)
{
    CDispNode * pDispNode = GetElementDispNode();

    Assert(psize);

    if (pDispNode)
    {
        if (pDispNode->IsScroller())
        {
            DYNCAST(CDispScroller, pDispNode)->GetContentSize(psize);
        }
        else
        {
            CRect   rc;

            GetClientRect(&rc);

            psize->cx = rc.Width();
            psize->cy = rc.Height();
        }
    }
    else
    {
        *psize = g_Zero.size;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetContainerSize
//
//  Synopsis:   Return the width/height of the container
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetContainerSize(
    CSize * psize)
{
    // default implementation returns size of the content
    GetContentSize(psize);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetPosition
//
//  Synopsis:   Return the top/left of a layout relative to its container
//
//  Arguments:  ppt     - Pointer to CPoint
//              cs    - Coordinate system for returned values
//
//-----------------------------------------------------------------------------

void
CLayout::GetPosition(
    CPoint *            ppt,
    COORDINATE_SYSTEM   cs) const
{
    Assert(ppt);
    if (    _pDispNode
        &&  _pDispNode->HasParent())
    {
        _pDispNode->TransformPoint(_pDispNode->GetPosition(), COORDSYS_PARENT, ppt, cs);
    }

    else if (ElementOwner()->Tag() == ETAG_TR)
    {
        CElement *  pElement = ElementOwner();
        CLayout *   pLayout  = (CLayout *)this;

        if (cs != COORDSYS_PARENT)
        {
            *ppt = g_Zero.pt;

            Assert(cs == COORDSYS_GLOBAL);

            if (pElement)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode)
                {
                    CElement * pElementZParent = pNode->ZParent();

                    if (pElementZParent)
                    {
                        CLayout  *  pParentLayout = pElementZParent->GetUpdatedNearestLayout();
                        CDispNode * pDispNode     = pParentLayout->GetElementDispNode(pElementZParent);

                        if (pDispNode)
                        {
                            pDispNode->TransformPoint(*ppt, COORDSYS_FLOWCONTENT, ppt, COORDSYS_GLOBAL);
                        }
                    }
                }
            }
        }
        else
        {
            ppt->x = pLayout->GetXProposed();
            ppt->y = pLayout->GetYProposed();

            // TODO RTL 112514: it is unlear in what direction XProposed is stored, 
            //                  and what is its meaning for a table row.
            //                  We may need to do a coordinate converson sort of like this:
#ifdef NEEDED
            // Because of the ridiculuous way xProposed is used,
            // we need to determine if the layout's parent is RTL, just so we can have
            // a reasonable guess for its meaning.
            if (pElement)
            {
                CLayout *pParentLayout = pElement->GetUpdatedParentLayout();
                long xParentWidth = pParentLayout->GetContainerWidth();

                if (pParentLayout->IsRightToLeft())
                    ppt->x = xParentWidth - ppt->x - pLayout->GetApparentWidth();
            }
#endif
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::SetPosition
//
//  Synopsis:   Set the top/left of a layout relative to its container
//
//  Arguments:  ppt     - Pointer to CPoint
//
//-----------------------------------------------------------------------------

void
CLayout::SetPosition(const CPoint &  pt,
                     BOOL            fNotifyAuto)
{
    CPoint      ptOriginal;
    CDispNode * pdn =  _pDispNode;
    if(!pdn)
        return;

    ptOriginal = pdn->GetPosition();

    pdn->SetPosition(pt);

    if (    fNotifyAuto
        &&  _fPositionSet
        &&  pt != ptOriginal
        &&  (_fAutoBelow || _fContainsRelative)
        &&  !ElementOwner()->IsZParent())
    {
        CSize size(pt.x - ptOriginal.x, pt.y - ptOriginal.y);

        if (_fAutoBelow)
        {
            long    cpStart, cpEnd;

            ElementOwner()->GetFirstAndLastCp(&cpStart, &cpEnd);
            NotifyTranslatedRange(size, cpStart, cpEnd);
        }

        if (_fContainsRelative)
        {
            TranslateRelDispNodes(size);
        }
    }

    // if this layout has a window, tell the view that it will have to
    // reorder windows according to Z order
    if (ElementOwner()->GetHwnd())
    {
        GetView()->SetFlag(CView::VF_DIRTYZORDER);
    }

    _fPositionSet = TRUE;
    
    if (ElementOwner()->ShouldFireEvents())
    {
// TODO (IE6 Bug 13574): Queue and fire these after the measuring pass is complete (brendand)
        if (pt.x != ptOriginal.x)
        {
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETLEFT);
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTLEFT);
        }

        if (pt.y != ptOriginal.y)
        {
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETTOP);
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTTOP);
        }

        if (   _fPositionedOnce
            && (   pt.y != ptOriginal.y
                || pt.x != ptOriginal.x))
        {
            GetView()->AddEventTask(ElementOwner(), DISPID_EVMETH_ONMOVE);
        }
    }

    _fPositionedOnce = TRUE;
}


//+--------------------------------------------------------------------------
//
// Member:      CLayout::HandleTranslatedRange
//
// Synopsis:    Update the position of the current layout if it is a zparent
//              or any relative children if the content before the current
//              layout changes.
//
// Arguments:   size - size by which the current layout/relative children
//              need to be offset by.
//
//---------------------------------------------------------------------------
void
CLayout::HandleTranslatedRange(
    const CSize &   size)
{
    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));

    Assert(_fContainsRelative || ElementOwner()->IsZParent());

    if (   _fContainsRelative
        ||  pFF->_fAutoPositioned)
    {
        CRequest * pRequest = ElementOwner()->GetRequestPtr();

        if (!pRequest || !pRequest->IsFlagSet(CRequest::RF_POSITION))
        {
            if (_fPositionSet)
            {
                Assert(ElementOwner()->GetMarkup()->Root());

                // (Bug 93785) -- abs pos elements that have top/bottom set are auto x-positiond,
                // but NOT auto y-positioned.  And likewise for having right/left set and not top/bottom.
                // to handle this properly, we need to detect this situation and mask the size that we
                // are using to adjust the position.
                CSize sizeTemp(size);

                if (pFF->_bPositionType == stylePositionabsolute)
                {
                    BOOL  fVertical = pCF->HasVerticalLayoutFlow();
                    BOOL  fWritingMode = pCF->_fWritingModeUsed;

                    if (!(   pFF->GetLogicalPosition(SIDE_TOP,
                                                     fVertical,
                                                     fWritingMode).IsNullOrEnum()
                          && pFF->GetLogicalPosition(SIDE_BOTTOM,
                                                     fVertical,
                                                     fWritingMode).IsNullOrEnum()))
                    {
                        // if either top or bottom are set then
                        // we are not auto for this dimension and should not be translated
                        sizeTemp.cy = 0;
                    }

                    if (!(  pFF->GetLogicalPosition(SIDE_LEFT,
                                                    fVertical,
                                                    fWritingMode).IsNullOrEnum()
                        && pFF->GetLogicalPosition(SIDE_RIGHT,
                                                   fVertical,
                                                   fWritingMode).IsNullOrEnum()))
                    {
                        // if either right or left are set then
                        // we are not auto for this dimension and should not be translated
                        sizeTemp.cx = 0;
                    }
                }


                // Normally, if the ElementOwner is a zparent we want to reset the position.
                // However, bodyTags at the root of an IFRAME are carried along by the
                // dispnode of the element in the main tree and should not be adjusted
                // in addition to their parent being moved. bug 88498, et al.
                if(   ElementOwner()->IsZParent()
                        // if we are a body in an iframe, TranslateRelDispNodes
                   && !(   ElementOwner()->Tag() == ETAG_BODY
                        && ElementOwner()->GetMarkup()->Root()->HasMasterPtr()
                        && ElementOwner()->GetMarkup()->Root()->GetMasterPtr()->TagType() == ETAG_IFRAME )
                  )
                {
                    CPoint pt;

                    GetPosition(&pt);
                    SetPosition(pt + sizeTemp);
                }
                else if (_fContainsRelative)
                {
                    Assert(!pRequest);

                    TranslateRelDispNodes(sizeTemp);
                }
            }
        }
        else if (pRequest && pRequest->IsFlagSet(CRequest::RF_AUTOVALID))
        {
            pRequest->ClearFlag(CRequest::RF_AUTOVALID);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     CLayout::QueueRequest
//
//  Synopsis:   Add a request to the request queue
//
//  Arguments:  rf       - Request type
//              pElement - Element to queue
//
//-----------------------------------------------------------------------------

CRequest *
CLayout::QueueRequest(
    CRequest::REQUESTFLAGS  rf,
    CElement *              pElement)
{
    Assert(pElement);

    //
    //  It is illegal to queue measuring requests while handling measuring requests,
    //  to queue measuring or positioning requests while handling positioning requests,
    //  to queue any requests while handling adorner requests
    //

    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSMEASURE)  || rf != CRequest::RF_MEASURE);
    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSPOSITION) || (    rf != CRequest::RF_MEASURE
                                                                &&  rf != CRequest::RF_POSITION));
    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSADORNERS));
    CRequests * pRequests     = RequestQueue();
    CRequest *  pRequest      = NULL;
    BOOL        fQueueRequest = TRUE;

    //
    //  If no request queue exists, create one
    //

    if (!pRequests)
    {
        pRequests = new CRequests();

        if (!pRequests ||
            !SUCCEEDED(AddRequestQueue(pRequests)))
        {
            delete pRequests;
            goto Error;
        }
    }

    //
    //  Add a request for the element
    //  If the element does not have a request, create one and add to the queue
    //  If the request is already in our queue, just update its state
    //

    pRequest = pElement->GetRequestPtr();

    if (!pRequest)
    {
        pRequest = new CRequest(rf, pElement);

        if (    !pRequest
            ||  !SUCCEEDED(pElement->SetRequestPtr(pRequest)))
        {
            goto Error;
        }
    }
    else
    {
        if (!pRequest->QueuedOnLayout(this))
        {
            pRequest->AddRef();
        }
        else
        {
            fQueueRequest = FALSE;
        }

        pRequest->SetFlag(rf);
    }

    if (    fQueueRequest
        &&  !SUCCEEDED(pRequests->Append(pRequest)))
        goto Error;

    //
    //  Save the layout responsible for the request type
    //

    pRequest->SetLayout(rf, this);

#if DBG==1
    // Support for dumping request queue in debug
    if ( IsTagEnabled( tagLayoutQueueDump ) )
    {
        int cRequests = pRequests->Size();
        CRequest **ppRequest;

        TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                    "Layout Queue Dump (in QueueRequest()): ly=0x%x, queue size=%d",
                    this,
                    cRequests));

        for (ppRequest = &pRequests->Item(0);
            cRequests;
            ppRequest++, cRequests--)
        {
            (*ppRequest)->DumpRequest();
        }
    }
#endif

    //
    //  Post an appropriate layout task
    //

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::QueueRequest() [should be preceded by QueueRequest tracemsg]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber));

    PostLayoutRequest(rf == CRequest::RF_MEASURE
                            ? LAYOUT_MEASURE
                            : rf == CRequest::RF_POSITION
                                    ? LAYOUT_POSITION
                                    : LAYOUT_ADORNERS);

Cleanup:
    return pRequest;

Error:
    if (pRequest)
    {
        pRequest->DequeueFromLayout(this);
        pRequest->Release();
        pRequest = NULL;
    }
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     CLayout::FlushRequests
//
//  Synopsis:   Empty the request queue
//
//-----------------------------------------------------------------------------
void
CLayout::FlushRequests()
{
    if (HasRequestQueue())
    {
        CRequests * pRequests = DeleteRequestQueue();
        CRequest ** ppRequest;
        int         cRequests;

        for (ppRequest = &pRequests->Item(0), cRequests = pRequests->Size();
             cRequests;
             ppRequest++, cRequests--)
        {
            AssertSz( (*ppRequest)->QueuedOnLayout(this), "If the request is in our queue, it better think it's queued on us!" );
            (*ppRequest)->DequeueFromLayout(this);
            (*ppRequest)->Release();
        }

        delete pRequests;
    }

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Queue flushed for ly=0x%x", this));
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::FlushRequest
//
//  Synopsis:   Searches the request queue for the specified request and removes it
//              Returns 1 if the request was actually in the layout's queue
//              (signifying this layout was holding a ref to the request),
//              otherwise returns 0.
//
//-----------------------------------------------------------------------------
int
CLayout::FlushRequest(CRequest *pRequest)
{
    if (HasRequestQueue())
    {
        CRequests * pRequests = RequestQueue();

        // DeleteByValue() returns true if the request is found & deleted from
        // the queue.
        if ( pRequests->DeleteByValue( pRequest ) )
        {
            // Return 1 signifying that this layout was holding a ref
            return 1;
        }
        // NOTE (KTam): maybe delete the queue here if it's empty?
    }
    // We weren't holding a ref (either because we didn't have a queue,
    // or the queue didn't have the request), so return 0.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::ProcessRequest
//
//  Synopsis:   Process a single request
//
//  Arguments:  pci      - Current CCalcInfo
//              pRequest - Request to process
//                  - or -
//              pElement - CElement whose outstanding request should be processed
//
//-----------------------------------------------------------------------------
#pragma warning(disable:4702)           // Unreachable code (invalidly occurs on the IsFlagSet/GetLayout inlines)

BOOL
CLayout::ProcessRequest(
    CCalcInfo * pci,
    CRequest  * pRequest)
{
    Assert(pci);
    Assert(pci->_grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));
    Assert(pRequest);

    BOOL    fCompleted = TRUE;

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Processing: Req=0x%x", pRequest));
    //
    // NOTE (EricVas)
    //
    // Sometimes the element has already left the tree, but the detach of its
    // layout has not been called to dequeue the requests...
    //
    // When Srini fixes this for real, replace this test with an assert that
    // the element in in the tree.
    //
    // Also, beware of elements jumping from tree to tree.
    //
    if (pRequest->GetElement()->IsInMarkup())
    {
        if (    pRequest->IsFlagSet(CRequest::RF_MEASURE)
            &&  pRequest->GetLayout(CRequest::RF_MEASURE) == this)
        {
            if (pci->_grfLayout & LAYOUT_MEASURE)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSMEASURE);
                HandleElementMeasureRequest(pci,
                                            pRequest->GetElement(),
                                            IsEditable(TRUE));
                pRequest->ClearFlag(CRequest::RF_MEASURE);
            }
            else
            {
                fCompleted = FALSE;
            }
        }

        if (    pRequest->IsFlagSet(CRequest::RF_POSITION)
            &&  pRequest->GetLayout(CRequest::RF_POSITION) == this)
        {
            if (pci->_grfLayout & LAYOUT_POSITION)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSPOSITION);
                HandlePositionRequest(pci,
                                      pRequest->GetElement(),
                                      pRequest->GetAuto(),
                                      pRequest->IsFlagSet(CRequest::RF_AUTOVALID));
                pRequest->ClearFlag(CRequest::RF_POSITION);
            }
            else
            {
                fCompleted = FALSE;
            }
        }

#ifdef ADORNERS
        if (    pRequest->IsFlagSet(CRequest::RF_ADDADORNER)
            &&  pRequest->GetLayout(CRequest::RF_ADDADORNER) == this)
        {
            if (pci->_grfLayout & LAYOUT_ADORNERS)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSADORNERS);
                HandleAddAdornerRequest(pRequest->GetAdorner());
                pRequest->ClearFlag(CRequest::RF_ADDADORNER);
            }
            else
            {
                fCompleted = FALSE;
            }
        }
#endif // ADORNERS
    }

    return fCompleted;
}

#pragma warning(default:4702)           // Unreachable code

void
CLayout::ProcessRequest(
    CElement *  pElement)
{
    if (    pElement
        &&  !pElement->IsPositionStatic())
    {
        CRequest * pRequest = pElement->GetRequestPtr();

        if (pRequest)
        {
            CCalcInfo   CI(this);

            CI._grfLayout |= LAYOUT_MEASURE | LAYOUT_POSITION;

            // NOTE (KTam): Every place we call any version of
            // ProcessRequest() we need to make sure we size the calcinfo
            // correctly; it's different for flow lyts than for others.
            // We ought to reorg this code so this is more transparent.
            SizeCalcInfoForChild( &CI );

            ProcessRequest(&CI, pRequest);

            if (!pRequest->IsFlagSet(CRequest::RF_ADDADORNER))
            {
                CRequests * pRequests = RequestQueue();

                if (    pRequests
                    &&  pRequests->DeleteByValue(pRequest))
                {
                    pRequest->DequeueFromLayout(this);
                    pRequest->Release();
                }

                if (    pRequests
                    &&  !pRequests->Size())
                {
                    DeleteRequestQueue();
                    delete pRequests;
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::ProcessRequests
//
//  Synopsis:   Process each pending request in the request queue
//
//  Arguments:  pci  - Current CCalcInfo
//              size - Size available to the child element
//
//-----------------------------------------------------------------------------

void
CLayout::ProcessRequests(
    CCalcInfo *     pci,
    const CSize &   size)
{
    Assert(pci);
    Assert(HasRequestQueue());
    Assert(GetView());

    CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_PROCESSREQUESTS);
    CElement::CLock LockRequests(ElementOwner(), pci->_grfLayout & LAYOUT_MEASURE
                                                        ? CElement::ELEMENTLOCK_PROCESSMEASURE
                                                        : pci->_grfLayout & LAYOUT_POSITION
                                                                ? CElement::ELEMENTLOCK_PROCESSPOSITION
                                                                : CElement::ELEMENTLOCK_PROCESSADORNERS);

    CSaveCalcInfo   sci(pci);
    CRequests *     pRequests;
    CRequest **     ppRequest;
    int             cRequests;
    BOOL            fCompleted = TRUE;

    pci->SizeToParent((SIZE *)&size);

    pRequests = RequestQueue();

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Processing: Entered CLayout::ProcessRequests() for ly=0x%x [e=0x%x,%S sn=%d]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber));

#if DBG==1
    if ( IsTagEnabled( tagLayoutQueueDump ) )
    {
        int cRequests = pRequests->Size();
        CRequest **ppRequest;

        TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                    "Layout Queue Dump (in ProcessRequests()): ly=0x%x, queue size=%d",
                    this,
                    cRequests));

        for (ppRequest = &pRequests->Item(0);
            cRequests;
            ppRequest++, cRequests--)
        {
            (*ppRequest)->DumpRequest();
        }
    }
#endif


    if (pRequests)
    {
        cRequests = pRequests->Size();

        if (cRequests)
        {
            for (ppRequest = &pRequests->Item(0);
                cRequests;
                ppRequest++, cRequests--)
            {
                if (ProcessRequest(pci, (*ppRequest)))
                {
                    (*ppRequest)->DequeueFromLayout(this);
                }
                else
                {
                    fCompleted = FALSE;
                }
            }
        }

        if (fCompleted)
        {
            pRequests = DeleteRequestQueue();

            cRequests = pRequests->Size();

            if (cRequests)
            {
                for (ppRequest = &pRequests->Item(0);
                    cRequests;
                    ppRequest++, cRequests--)
                {
                    (*ppRequest)->Release();
                }
            }

            delete pRequests;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestPoint
//
//  Synopsis:   Determines if the passed CPoint hits the layout and/or one of its
//              contained elements
//
//  Arguments:  ppNodeElement - Location at which to return CTreeNode of hit element
//              grfFlags      - HT_ flags
//
//  Returns:    HTC
//
//----------------------------------------------------------------------------

HTC
CLayout::HitTestPoint(
    const CPoint &  pt,
    CTreeNode **    ppNodeElement,
    DWORD           grfFlags)
{
    Assert(ppNodeElement);
    return HTC_NO;
}


HRESULT
CLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
//Commenting out this assert because script operation 
// (like asking offsetTop of <BR> can get us here easily)
//  Assert(0&&"WE should never get here");
    pt.x = pt.y = -1;
    return S_OK;
}

void
CLayout::GetMarginInfo(CParentInfo *ppri,
                       LONG * plLeftMargin, LONG * plTopMargin,
                       LONG * plRightMargin, LONG *plBottomMargin)
{
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CFancyFormat * pFF = pNodeLayout->GetFancyFormat(LC_TO_FC(LayoutContext()));
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat(LC_TO_FC(LayoutContext()));
    const CCharFormat *  pCF = pNodeLayout->GetCharFormat(LC_TO_FC(LayoutContext()));

    Assert(plLeftMargin || plRightMargin || plTopMargin || plBottomMargin);

    if (plTopMargin)
        *plTopMargin = 0;

    if (plBottomMargin)
        *plBottomMargin = 0;

    if (plLeftMargin)
        *plLeftMargin = 0;

    if (plRightMargin)
        *plRightMargin = 0;

    if (!pFF->_fHasMargins)
        return;

    //
    // For block elements, top & bottom margins are treated as
    // before & afterspace, left & right margins are accumulated into the
    // indent's. So, ignore margin's since they are already factored in.
    // For the BODY, margins are never factored in because there is no
    // "higher level" flow layout.
    //
    if (    !ElementOwner()->IsBlockElement(LC_TO_FC(LayoutContext()))
        ||  !ElementOwner()->IsInlinedElement()
        ||  (   (   Tag() == ETAG_BODY          // Primary element clients are not in a flow layout and do not have before/after space.
                 || Tag() == ETAG_FRAMESET )
            &&  GetOwnerMarkup()->IsHtmlLayout() ))
    {
        CLayout * pParentLayout = GetUpdatedParentLayout(LayoutContext());
        const CCharFormat *pCFParent = pParentLayout ? pParentLayout->GetFirstBranch()->GetCharFormat(LC_TO_FC(pParentLayout->LayoutContext())) : NULL;
        BOOL fParentVertical = pCFParent ? pCFParent->HasVerticalLayoutFlow() : FALSE;
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

        const CUnitValue & cuvMarginLeft   = pFF->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginRight  = pFF->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginTop    = pFF->GetLogicalMargin(SIDE_TOP, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginBottom = pFF->GetLogicalMargin(SIDE_BOTTOM, fParentVertical, fWritingModeUsed);

        if (plLeftMargin && !cuvMarginLeft.IsNull())
        {
            *plLeftMargin =  cuvMarginLeft.XGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }
        if (plRightMargin && !cuvMarginRight.IsNull())
        {
            *plRightMargin = cuvMarginRight.XGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }

        if (plTopMargin && !cuvMarginTop.IsNull())
        {
            *plTopMargin = cuvMarginTop.YGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);

        }
        if(plBottomMargin && !cuvMarginBottom.IsNull())
        {
            *plBottomMargin = cuvMarginBottom.YGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }
    }
}

#ifdef ADORNERS
//+------------------------------------------------------------------------
//
//  Method:     SetIsAdorned
//
//  Synopsis:   Mark or clear a layout as adorned
//
//  Arguments:  fAdorned - TRUE/FALSE value
//
//-------------------------------------------------------------------------

VOID
CLayout::SetIsAdorned(BOOL fAdorned)
{
    _fAdorned = fAdorned;
}
#endif // ADORNERS

//+------------------------------------------------------------------------
//
//  Member:     CLayout::PreDrag
//
//  Synopsis:   Prepares for an OLE drag/drop operation
//
//  Arguments:  dwKeyState  Starting key / button state
//              ppDO        Data object to return
//              ppDS        Drop source to return
//
//-------------------------------------------------------------------------

HRESULT
CLayout::PreDrag(DWORD dwKeyState,
                 IDataObject **ppDO,
                 IDropSource **ppDS)
{
    RRETURN(E_FAIL);
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::PostDrag
//
//  Synopsis:   Cleans up after an OLE drag/drop operation
//
//  Arguments:  hrDrop      The hr that DoDragDrop came back with
//              dwEffect    The effect of the drag/drop
//
//-------------------------------------------------------------------------

HRESULT
CLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
    RRETURN(E_FAIL);
}

static HRESULT
CreateDataObject(CDoc * pDoc,
                 IUniformResourceLocator * pUrlToDrag,
                 IDataObject ** ppDataObj)
{
    HRESULT hr = S_OK ;
    IDataObject * pLinkDataObj = NULL;
    CGenDataObject * pDataObj;

    if ( pUrlToDrag )
    {
        hr = THR(pUrlToDrag->QueryInterface(IID_IDataObject, (void **) &pLinkDataObj));
        if (hr)
            goto Cleanup;
    }

    pDataObj = new CGenDataObject(pDoc);
    if (!pDataObj)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( pLinkDataObj )
        pDataObj->_pLinkDataObj = pLinkDataObj;
    pLinkDataObj = NULL;

    *ppDataObj = pDataObj;

Cleanup:
    ReleaseInterface(pLinkDataObj);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::DoDrag
//
//  Synopsis:   Start an OLE drag/drop operation
//
//  Arguments:  dwKeyState   Starting key / button state
//              pURLToDrag   Specifies the URL data object if we are
//                           dragging a URL (from <A> or <AREA>).
//
//-------------------------------------------------------------------------

HRESULT
CLayout::DoDrag(DWORD dwKeyState,
                IUniformResourceLocator * pURLToDrag /* = NULL */,
                BOOL fCreateDataObjOnly /* = FALSE */,
                BOOL *pfDragSucceeded /*=NULL*/ ,
                BOOL  fCheckSelection /*=FALSE*/)
{
    HRESULT         hr          = NOERROR;

    LPDATAOBJECT    pDataObj    = NULL;
    LPDROPSOURCE    pDropSource = NULL;
    DWORD           dwEffect, dwEffectAllowed ;
    CElement::CLock Lock(ElementOwner());
    HWND            hwndOverlay = NULL;
    CDoc *          pDoc        = Doc();
#ifndef NO_EDIT
    CParentUndoUnit * pPUU = NULL;
    CDragStartInfo * pDragStartInfo = pDoc->_pDragStartInfo;

    if (!fCreateDataObjOnly)
        pPUU = pDoc->OpenParentUnit( pDoc, IDS_UNDODRAGDROP );
#endif // NO_EDIT

    if ( pfDragSucceeded )
        *pfDragSucceeded = TRUE;

    Assert(ElementOwner()->IsInMarkup());


    if (fCreateDataObjOnly || !pDragStartInfo || !pDragStartInfo->_pDataObj )
    {
        Assert(!pDoc->_pDragDropSrcInfo);

        if ( pURLToDrag ||
            ( ( fCheckSelection || fCreateDataObjOnly ) && ( !pDoc->HasSelection() || pDoc->IsEmptySelection() ) )
           )
        {
            pDoc->_pDragDropSrcInfo = new CDragDropSrcInfo;
            if (!pDoc->_pDragDropSrcInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pDoc->_pDragDropSrcInfo->_srcType = pURLToDrag ? DRAGDROPSRCTYPE_URL : DRAGDROPSRCTYPE_MISC;

            hr = CreateDataObject(pDoc, pURLToDrag, &pDataObj);
            if (!hr)
                hr = THR(CDummyDropSource::Create(dwKeyState, pDoc, &pDropSource));
        }
        else
            hr = THR(PreDrag(dwKeyState, &pDataObj, &pDropSource));
        if (hr)
        {
            if (S_FALSE == hr)
                hr = S_OK;
            if ( pfDragSucceeded )
                *pfDragSucceeded = FALSE;
            goto Cleanup;
        }

        {
            CElement * pElement = ElementOwner();
            CWindow *  pWindow = pElement->GetCWindowPtr();

            Assert(pWindow);

            IGNORE_HR(pWindow->SetDataObjectSecurity(pDataObj));
        }

        if (pDragStartInfo)
        {
            pDragStartInfo->_pDataObj = pDataObj;
            pDragStartInfo->_pDropSource = pDropSource;
            pDataObj->AddRef();
            pDropSource->AddRef();
            if (fCreateDataObjOnly)
                goto Cleanup;
        }
    }
    else
    {
        pDataObj = pDragStartInfo->_pDataObj;
        pDropSource = pDragStartInfo->_pDropSource;
        pDataObj->AddRef();
        pDropSource->AddRef();
    }

    // Setting this makes checking for self-drag easier
    pDoc->_fIsDragDropSrc = TRUE;
    pDoc->_fIsDragDropSrc = TRUE;

    // Make sure that no object has capture because OLE will want it
    pDoc->SetMouseCapture(NULL, NULL);

    // Force a synchronous redraw; this is necessary, since
    // the drag-drop feedback is drawn with an XOR pen.
    pDoc->UpdateForm();

    // Throw an overlay window over the current site in order
    // to prevent a move of a control into the same control.

    if (IsEditable(TRUE) &&
        pDoc->_pElemCurrent &&
        pDoc->_pElemCurrent->GetHwnd())
    {
        hwndOverlay = pDoc->CreateOverlayWindow(pDoc->_pElemCurrent->GetHwnd());
    }

    if (pDragStartInfo && pDragStartInfo->_dwEffectAllowed != DROPEFFECT_UNINITIALIZED)
        dwEffectAllowed = pDragStartInfo->_dwEffectAllowed;
    else
    {
        if (pURLToDrag)
            dwEffectAllowed = DROPEFFECT_LINK;
        else if (ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE))
            dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_MOVE;
        else // do not allow move if the site cannot be edited
            dwEffectAllowed = DROPEFFECT_COPY;
    }

    hr = THR(DoDragDrop(
            pDataObj,
            pDropSource,
            dwEffectAllowed,
            &dwEffect));

    if (pDragStartInfo)
        pDragStartInfo->_pElementDrag->Fire_ondragend(0, dwEffect);

    // Guard against unexpected drop-effect (e.g. VC5 returns DROPEFFECT_MOVE
    // even when we specify that only DROPEFFECT_COPY is allowed - bug #39911)
    if (DRAGDROP_S_DROP == hr &&
        DROPEFFECT_NONE != dwEffect &&
        !(dwEffect & dwEffectAllowed))
    {
        CheckSz(FALSE, "Unexpected drop effect returned by the drop target");

        if (DROPEFFECT_LINK == dwEffectAllowed)
        {
            dwEffect = DROPEFFECT_LINK;
        }
        else
        {
            Check(DROPEFFECT_COPY == dwEffectAllowed && DROPEFFECT_MOVE == dwEffect);
            dwEffect = DROPEFFECT_COPY;
        }
    }
    else if (DRAGDROP_S_CANCEL == hr || (DRAGDROP_S_DROP == hr && DROPEFFECT_NONE == dwEffect))
    {
        //  Bug 103279: If the drop didn't succeed due to a cancel or drop with DROPEFFECT_NONE,
        //  then we want to mark this as not succeeded and exit.
        if (pfDragSucceeded)
            *pfDragSucceeded = FALSE;
        hr = S_OK;
        goto Cleanup;
    }

    if (hwndOverlay)
    {
        DestroyWindow(hwndOverlay);
    }

    // NOTE (a-rmead):  The layout can become detached durring the previous DoDragDrop.
    // Happens when the innerHTML is removed or changed by an ondrag binding.
    // <SPAN ondrag='document.body.innerHTML="xx"' STYLE=width:100>DragThisText</SPAN>
    if (    !pURLToDrag
        &&  ElementOwner() && ElementOwner()->IsInMarkup())
    {
        hr = THR(PostDrag(hr, dwEffect));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // DoDragDrop returns either DRAGDROP_S_DROP (for successful drops)
        // or some code for failure/user-cancel. We don't care, so we just
        // set hr to S_OK
        hr = S_OK;

    }

Cleanup:

    if (!fCreateDataObjOnly)
    {
#ifndef NO_EDIT
        pDoc->CloseParentUnit(pPUU, S_OK);
#endif // NO_EDIT

        if (pDoc->_pDragDropSrcInfo)
        {
            //
            // TODO (IE6 bug 13568) marka - SelDragDropSrcInfo is now refcounted.
            // to do - make normal DragDropSrcInfo an object too
            //
            if(DRAGDROPSRCTYPE_SELECTION == pDoc->_pDragDropSrcInfo->_srcType)
            {
                CSelDragDropSrcInfo * pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
                pDragInfo->Release();
            }
            else
            {
                delete pDoc->_pDragDropSrcInfo;
            }

            pDoc->_pDragDropSrcInfo = NULL;
        }
    }
    ReleaseInterface(pDataObj);
    ReleaseInterface(pDropSource);

    pDoc->_fIsDragDropSrc = FALSE;
    Assert(fCreateDataObjOnly || !pDoc->_pDragDropSrcInfo);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::DropHelper
//
//  Synopsis:   Start an OLE drag/drop operation
//
//  Arguments:  ptlScreen   Screen loc of obj.
//              dwAllowed   Allowed list of drop effects
//              pdwEffect   The effect of the drop
//
//  Notes:      For now, this just handles right button dragging, but any
//              other info can be added here later.
//
//-------------------------------------------------------------------------

HRESULT
CLayout::DropHelper(POINTL ptlScreen, DWORD dwAllowed, DWORD *pdwEffect, LPTSTR lptszFileType)
{
    HRESULT hr = S_OK;

    if (Doc()->_fRightBtnDrag)
    {
        int     iSelection;

        *pdwEffect = DROPEFFECT_NONE;

        if (!Doc()->_fSlowClick)
        {
            hr = THR(Doc()->ShowDragContextMenu(ptlScreen, dwAllowed, &iSelection, lptszFileType));
            if (S_OK == hr)
            {
                *pdwEffect = iSelection;
            }
            else if (S_FALSE == hr)
            {
                hr = S_OK; // no need to propagate S_FALSE
            }
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragEnter
//
//  Synopsis:   Setup for possible drop
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragEnter(
        IDataObject *pDataObj,
        DWORD grfKeyState,
        POINTL ptlScreen,
        DWORD *pdwEffect)
{
    HRESULT hr;

    Doc()->_fDragFeedbackVis = FALSE;

    if (!IsEditable(FALSE /*fCheckContainerOnly*/, TRUE /*fUseSlavePtr*/))
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    hr = THR(ParseDragData(pDataObj));
    if ( hr == S_FALSE )
    {
        //
        // S_FALSE is returned by ParseData - if the DragDrop cannot accept the HTML
        // you want to paste.
        //
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    if (hr)
        goto Cleanup;

    hr = THR(InitDragInfo(pDataObj, ptlScreen));
    if (hr)
        goto Cleanup;

    hr = THR(DragOver(grfKeyState, ptlScreen, pdwEffect));

    if (hr)
    {
        hr = THR(DragLeave());
    }

Cleanup:

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ParseDragData
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CLayout::ParseDragData(IDataObject *pDataObj)
{
    TCHAR   szText[MAX_PATH];
    HRESULT hr = S_FALSE;


    // Start with flags set to default values.

    Doc()->_fOKEmbed = FALSE;
    Doc()->_fOKLink = FALSE;
    Doc()->_fFromCtrlPalette = FALSE;


    // Now set flags based on content of data object.

    if (OK(GetcfCLSIDFmt(pDataObj, szText)))
    {
        //
        //  Special combination of flags means copy from control box
        //
        Doc()->_fFromCtrlPalette = 1;
        hr = S_OK;
    }
    else
    {
        OBJECTDESCRIPTOR objdesc;

        // The explicit check for S_OK is required here because
        // OleQueryXXXFromData() returns other success codes.
        Doc()->_fOKEmbed = OleQueryCreateFromData(pDataObj) == S_OK;
        Doc()->_fOKLink = OleQueryLinkFromData(pDataObj) == S_OK;

        // NOTE: (anandra) Try to get the object descriptor immediately
        // to see if we can create a site for this thing.  This will
        // eventually change when we want to support dragging of html
        // files into the form

        if (!OK(GetObjectDescriptor(pDataObj, &objdesc)))
        {
            Doc()->_fOKEmbed = FALSE;
            Doc()->_fOKLink = FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragOver
//
//  Synopsis:   Determine whether this would be a move, copy, link
//              or null operation and manage UI feedback
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragOver(DWORD grfKeyState, POINTL ptlScreen, LPDWORD pdwEffect)
{
    HRESULT hr      = S_OK;

    CDoc* pDoc = Doc();
    Assert(pdwEffect != NULL);

    grfKeyState &= MK_CONTROL | MK_SHIFT;

    if (!IsEditable(FALSE /*fCheckContainerOnly*/, TRUE /*fUseSlavePtr*/))
    {
        *pdwEffect = DROPEFFECT_NONE;               // No Drop into design mode
    }
    else if (pDoc->_fFromCtrlPalette)
    {
        *pdwEffect &= DROPEFFECT_COPY;              // Drag from Control Palette
    }
    else if (grfKeyState == (MK_CONTROL | MK_SHIFT) &&
            pDoc->_fOKLink &&
            (*pdwEffect & DROPEFFECT_LINK))
    {
        *pdwEffect = DROPEFFECT_LINK;               // Control-Shift equals create link
    }
    else if (grfKeyState == MK_CONTROL &&
            (*pdwEffect & DROPEFFECT_COPY))
    {
        *pdwEffect = DROPEFFECT_COPY;               // Control key = copy.
    }
    else if (*pdwEffect & DROPEFFECT_MOVE)
    {
        *pdwEffect = DROPEFFECT_MOVE;               // Default to move
    }
    else if (*pdwEffect & DROPEFFECT_COPY)
    {
        *pdwEffect = DROPEFFECT_COPY;               // If can't move, default to copy
    }
    else if ((pDoc->_fOKLink) &&
            (*pdwEffect & DROPEFFECT_LINK))
    {
        *pdwEffect = DROPEFFECT_LINK;               // If can't copy, default to link
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }


    //
    // Drag & Drop with pointers in the same flow layout will do a copy not a move
    // ( as a delete across flow layouts is not allowed).
    //
    if ( *pdwEffect & DROPEFFECT_MOVE &&
         pDoc->_pDragDropSrcInfo &&
         DRAGDROPSRCTYPE_SELECTION == pDoc->_pDragDropSrcInfo->_srcType)
    {
        CSelDragDropSrcInfo * pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
        if ( ! pDragInfo->IsInSameFlow() )
        {
            *pdwEffect = DROPEFFECT_COPY;
        }
    }

    //
    // Draw or erase feedback as appropriate.
    //
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        // Erase previous feedback.
        DragHide();
    }
    else
    {
        hr = THR(UpdateDragFeedback( ptlScreen ));
        if (pDoc->_fSlowClick)
        {
            *pdwEffect = DROPEFFECT_NONE ;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragLeave
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragLeave()
{
    DragHide();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragHide
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

void
CLayout::DragHide()
{
    if (Doc()->_fDragFeedbackVis)
    {
        DrawDragFeedback(FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawZeroBorder
//
//  Synopsis:   Draw the "Zero Grey Border" around the input.
//
//----------------------------------------------------------------------------

void
CLayout::DrawZeroBorder(CFormDrawInfo *pDI)
{
    Assert(GetUpdatedParentLayout()->IsEditable() && IsShowZeroBorderAtDesignTime());

    CColorValue cv        = ElementOwner()->GetFirstBranch()->GetCascadedbackgroundColor();
    CDispNode * pDispNode = GetElementDispNode(ElementOwner());
    pDI->_hdc = NULL;       // Whack the DC so we force client clipping.
    XHDC        hdc       = pDI->GetDC(TRUE);
    COLORREF    cr;

    if ( cv._dwValue == 0 )
    {
        cr = 0x00ffffff & (~(cv.GetColorRef()));
    }
    else
    {
        cr = ZERO_GREY_COLOR ;
    }

#if DBG == 1
    if ( IsTagEnabled(tagShowZeroGreyBorder))
    {
        cr = RGB(0xFF,0x00,0x00);
    }
#endif

    if ( ! pDispNode->HasBorder() )
    {
        HBRUSH hbr, hbrOld;
        hbr = ::CreateSolidBrush(cr );
        hbrOld = (HBRUSH) ::SelectObject( hdc, hbr );


        RECT rcContent;
        // bug fix:100405(chandras) : GetClientRect changed to DispNode->GetClientRect as one
        //                    transformation was done extra in GetClientRect before
        //
        pDispNode->GetClientRect(& rcContent, CLIENTRECT_CONTENT);

        if (Tag() == ETAG_TABLE)
            rcContent.bottom -= GetCaptionHeight(ElementOwner());

        PatBltRect( hdc, (RECT*) &rcContent , 1, PATCOPY );
        SelectBrush( hdc, hbrOld );
        DeleteBrush( hbr );
    }
    else
    {
        HPEN hPen, hPenOld;
        CRect rcBorder;
        pDispNode->GetBorderWidths( &rcBorder );

        hPen = CreatePen( PS_SOLID, 1, cr );
        hPenOld = SelectPen( hdc, hPen );
        RECT rcContent;

        // bug fix : 72161(chandras) GetRect changed to GetClientRect as one
        //                           transformation was done extra in GetRect before
        //
        pDispNode->GetClientRect(& rcContent, CLIENTRECT_CONTENT);

        if (Tag() == ETAG_TABLE)
            rcContent.bottom -= GetCaptionHeight(ElementOwner());

        int left, top, bottom, right;
        left = rcContent.left;
        top = rcContent.top;
        right = rcContent.right;
        bottom = rcContent.bottom;

        if ( rcBorder.left == 0 )
        {
            MoveToEx(  hdc, left, top , NULL );
            LineTo( hdc, left , bottom );
        }
        if ( rcBorder.right == 0 )
        {
            MoveToEx(  hdc, (right-left), top , NULL );
            LineTo( hdc, (right-left), bottom );
        }
        if ( rcBorder.top == 0 )
        {
            MoveToEx(  hdc, left , top, NULL );
            LineTo( hdc, (right-left), top );
        }
        if ( rcBorder.bottom == 0 )
        {
            MoveToEx(  hdc, left , bottom, NULL );
            LineTo( hdc, (right-left) , bottom );
        }
        SelectPen( hdc, hPenOld );
        DeletePen( hPen );
    }
}

void
DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor)
{
    static short bBrushBits [8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55} ;
    HBITMAP hbm;
    HBRUSH hBrush, hBrushOld;
    COLORREF crOldBk, crOldFg;
    CPoint ptOrg;

    // Text selection feedback for sites is painting every other pixel
    // with the color being used for painting the background for selections.

    // Select the color we want to paint evey other pixel with
    crOldBk = SetBkColor (hdc, GetSysColor (
                                            fSwapColor ? COLOR_HIGHLIGHTTEXT : COLOR_HIGHLIGHT));

    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits);
    hBrush = CreatePatternBrush (hbm);

    ptOrg = prc->TopLeft();
    if (ptOrg.x != 0)
    {
        ptOrg.x -= ptOrg.x % 8;
    }
    if (ptOrg.y != 0)
    {
        ptOrg.y -= ptOrg.y % 8;
    }

    SetBrushOrgEx( hdc, ptOrg.x, ptOrg.y, NULL );

    hBrushOld = (HBRUSH)SelectObject (hdc, hBrush);

    // Now, for monochrome bitmap brushes, 0: foreground, 1:background.
    // We've set the background color to the selection color, set the fg
    // color to black, so that when we OR, every other screen pixel will
    // retain its color, and the remaining with have the selection color
    // OR'd into them.
    crOldFg = SetTextColor (hdc, RGB(0,0,0));

    PatBlt (hdc, prc->left, prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            DST_PAT_OR);

    // Now, set the fg color to white so that when we AND, every other screen
    // pixel still retains its color, while the remaining have just the
    // selection in them. This gives us the effect of transparency.
    SetTextColor (hdc, RGB(0xff,0xff,0xff));

    PatBlt (hdc, prc->left, prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            DST_PAT_AND);   
    SelectObject (hdc, hBrushOld);
    DeleteObject (hBrush);
    DeleteObject (hbm);

    SetTextColor (hdc, crOldFg);
    SetBkColor   (hdc, crOldBk);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawTextSelectionForSite
//
//  Synopsis:   Draw the text selection feed back for the site
//
//----------------------------------------------------------------------------
void
CLayout::DrawTextSelectionForSite(CFormDrawInfo *pDI, const RECT *prcfClip)
{
    if (_fTextSelected)
    {
        CRect rcContent;
        GetClippedRect( & rcContent, COORDSYS_FLOWCONTENT );

        DrawTextSelectionForRect(pDI->GetDC(), &rcContent, &pDI->_rcClip, _fSwapColor);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::Draw
//
//  Synopsis:   Draw the site and its children to the screen.
//
//----------------------------------------------------------------------------

void
CLayout::Draw(CFormDrawInfo *pDI, CDispNode *)
{
    return;
}


void
CLayout::DrawBackground(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    RECT *              prcDraw)
{
    CRect       rcBackground;
    SIZE        sizeImg;
    CDoc    *   pDoc      = Doc();
    BOOL        fPrintDoc = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
    XHDC        hdc;
    COLORREF    crBack    = pbginfo->crBack;
    CImgCtx *   pImgCtx   = pbginfo->pImgCtx;
    ULONG       ulState;

    if (pImgCtx)
    {
        ulState = pImgCtx->GetState(FALSE, &sizeImg);
    }
    else
    {
        ulState = 0;
        sizeImg = g_Zero.size;
    }

    Assert(pDoc);

    if (!(ulState & IMGLOAD_COMPLETE))
    {
        pImgCtx = NULL;
    }

    Assert(prcDraw);

    rcBackground = *prcDraw;

    IntersectRect(&rcBackground, &pDI->_rcClip, &rcBackground);

    hdc = pDI->GetDC();

        {
                // N.B. (johnv) We only blt the background if we do not have an
                // image, or if the image rect is not identical to the clip rectangle.
                // We can also blt four times (around the image) if this turns out
                // to be faster.
                if (    crBack != COLORREF_NONE
                        &&  (   !pImgCtx
                                ||  !(ulState & IMGTRANS_OPAQUE)
                                ||  !EqualRect(&rcBackground, &pbginfo->rcImg)))
                {
                        PatBltBrush(hdc, &rcBackground, PATCOPY, crBack);
                }
        }

        if (pImgCtx )
        {
                sizeImg.cx = pDI->DeviceFromDocPixelsX(sizeImg.cx);
                sizeImg.cy = pDI->DeviceFromDocPixelsY(sizeImg.cy);

                if (sizeImg.cx == 0 || sizeImg.cy == 0)
                        return;

                if (crBack == COLORREF_NONE)
                        crBack = pbginfo->crTrans;

        CSize sizeLayout = pDI->_rc.Size();

        // We need to pass the physical (non-memory) DC to the finction because on
        // the multimonitor W2k computers CreateCompatibleBitmap produces strange
        //  resutls (unless the Hardware acceleration of the primary monitor card is lowered).
        pImgCtx->TileEx(hdc,
                    &pbginfo->ptBackOrg,
                    &pbginfo->rcImg,
                    (fPrintDoc || pDI->IsDeviceScaling())
                        ? &sizeImg
                        : NULL,
                    crBack,
                    pDoc->GetImgAnimState(pbginfo->lImgCtxCookie),
                    pDI->DrawImageFlags(),
                    GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow(),
                    sizeLayout, sizeImg, &(pDI->_hic));
    }

    WHEN_DBG(CDebugPaint::PausePaint(tagPaintWait));
}

HRESULT
CLayout::GetDC(LPRECT prc, DWORD dwFlags, HDC *phDC)
{
    CDoc    * pDoc = Doc();

    Assert(pDoc);
    Assert((dwFlags & 0xFF00) == 0);

    dwFlags |=  (   (pDoc->_bufferDepth & OFFSCR_BPP) << 16)
                |   (pDoc->_cSurface   ? OFFSCR_SURFACE   : 0)
                |   (pDoc->_c3DSurface ? OFFSCR_3DSURFACE : 0);

    return pDoc->GetDC(prc, dwFlags, phDC);
}


HRESULT
CLayout::ReleaseDC(HDC hdc)
{
    return Doc()->ReleaseDC(hdc);
}


//+-----------------------------------------------------------------------
//
//  Function:   Invalidate
//
//  Synopsis:   Invalidate the passed rectangle or region
//
//------------------------------------------------------------------------
void
CLayout::Invalidate(
    const RECT&         rc,
    COORDINATE_SYSTEM   cs)
{
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        && _pDispNode)
    {
        _pDispNode->Invalidate((const CRect&) rc, cs);
    }
}


void
CLayout::Invalidate(
    LPCRECT prc,
    int     cRects,
    LPCRECT prcClip)
{
    CDispNode * pdn = _pDispNode;
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        &&  pdn)
    {
        if (!prc)
        {
            pdn->Invalidate();
        }
        else
        {
            Assert( !cRects
                ||  prc);
            for (int i=0; i < cRects; i++, prc++)
            {
                pdn->Invalidate((CRect &)*prc, COORDSYS_FLOWCONTENT);
            }
        }
    }
}

void
CLayout::Invalidate(
    HRGN    hrgn)
{
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        &&  _pDispNode)
    {
        _pDispNode->Invalidate(hrgn, COORDSYS_FLOWCONTENT);
    }
}


extern void CalcBgImgRect(CTreeNode * pNode, CFormDrawInfo * pDI,
                          const SIZE * psizeObj, const SIZE * psizeImg,
                          CPoint *pptBackOrig, CBackgroundInfo *pbginfo);

//+------------------------------------------------------------------------
//
//  Member:     GetBackgroundInfo
//
//  Synopsis:   Fills out a background info for which has details on how
//              to display a background color &| background image.
//
//-------------------------------------------------------------------------

BOOL
CLayout::GetBackgroundImageInfoHelper(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo )
{
    CPoint      ptBackOrig;
    CSize       sizeImg;
    CSize       sizeClient;

    Assert(pDI);
    Assert(pbginfo->pImgCtx);

    pbginfo->pImgCtx->GetState(FALSE, &sizeImg);

    if (    pDI->IsDeviceScaling() 
        ||  (   LayoutContext()
            &&  LayoutContext()->GetMedia() != mediaTypeNotSet) )
    {
        // transform sizeImage to physical coordinates
        sizeImg.cx = pDI->DeviceFromDocPixelsX(sizeImg.cx);
        sizeImg.cy = pDI->DeviceFromDocPixelsY(sizeImg.cy);
    }

    // client size, for the purposes of background image positioning,
    // is the greater of our content size or our client rect
    CRect rcClient;
    GetClientRect(&rcClient, CLIENTRECT_BACKGROUND );

    if (!pbginfo->fFixed)
    {
        GetContentSize(&sizeClient, FALSE);
        sizeClient.Max(rcClient.Size());
    }
    else
    {
        // note: background rectangle is different for fixed background, but here we only need its size
        sizeClient = rcClient.Size();
    }

    // figure out background image rectangle and origin
    CalcBgImgRect(GetFirstBranch(), pDI, &sizeClient, &sizeImg, &ptBackOrig, pbginfo);

    // Translate background rectangle
    if (pbginfo->fFixed)
    {
        // translate image rectangle and origin to scroll amount.
        // this ensures that background doesn't move relative to scroller
        TransformRect(&pbginfo->rcImg, COORDSYS_SCROLL, COORDSYS_CONTENT);
        TransformPoint(&ptBackOrig, COORDSYS_SCROLL, COORDSYS_CONTENT);
    }
    else
    {
        // translate background rectangle and origin point to the top left
        // of bounding rect (which is not zero in RTL)
        OffsetRect(&pbginfo->rcImg, pDI->_rc.left, pDI->_rc.top);
        ptBackOrig.x += pDI->_rc.left;
        ptBackOrig.y += pDI->_rc.top;
    }

    pbginfo->ptBackOrg.x = ptBackOrig.x;
    pbginfo->ptBackOrg.y = ptBackOrig.y;

    IntersectRect(&pbginfo->rcImg, pDI->ClipRect(), &pbginfo->rcImg);

    return TRUE;
}


BOOL
CLayout::GetBackgroundInfoHelper(
    CBackgroundInfo *    pbginfo)
{
    const CFancyFormat *    pFF   = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
          CColorValue       cv    = (CColorValue)(pFF->_ccvBackColor);

    pbginfo->pImgCtx       = ElementOwner()->GetBgImgCtx(LC_TO_FC(LayoutContext()));
    pbginfo->lImgCtxCookie = pFF->_lImgCtxCookie;
    pbginfo->fFixed        = (  pbginfo->pImgCtx
                            &&  pFF->_fBgFixed);

    pbginfo->crBack  = cv.IsDefined()
                            ? cv.GetColorRef()
                            : COLORREF_NONE;
    pbginfo->crTrans = COLORREF_NONE;

    GetBgImgSettings(pFF, pbginfo);

    return TRUE;
}

BOOL
CLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{   
    Assert(pDI || !fAll);

    // Assert that pDI->rc is zero-based, unless there is a content offset.
    // If that is not true, we need to understand why, and probably make other adjustments to rcImg
    AssertSz(pDI == NULL ||
             pDI->_rc.left == 0 && pDI->_rc.top == 0 ||
             _pDispNode && _pDispNode->HasContentOrigin() &&
             _pDispNode->GetContentOrigin().cx == -pDI->_rc.left &&
             _pDispNode->GetContentOrigin().cy == -pDI->_rc.top,
             "Non-zero based bounding rect in GetBackgroundInfo");
    
    GetBackgroundInfoHelper(pbginfo);

    if (    fAll
        &&  pbginfo->pImgCtx)
    {
        GetBackgroundImageInfoHelper(pDI, pbginfo);
    }

    return TRUE;
}


//
// Scrolling
//

//+------------------------------------------------------------------------
//
//  Member:     Attach/DetachScrollbarController
//
//  Synopsis:   Manage association between this CLayout and the CScrollbarController
//
//-------------------------------------------------------------------------

void
CLayout::AttachScrollbarController(
    CDispNode * pDispNode,
    CMessage *  pMessage)
{
    CScrollbarController::StartScrollbarController(
        this,
        DYNCAST(CDispScroller, pDispNode),
        Doc(),
        g_uiDisplay.DeviceFromHimetricX(g_sizelScrollbar.cx),
        pMessage);
}

void
CLayout::DetachScrollbarController(
    CDispNode * pDispNode)
{
    CScrollbarController *  pSBC = TLS(pSBC);

    if (    pSBC
        &&  pSBC->GetLayout() == this)
    {
        CScrollbarController::StopScrollbarController();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ScrollElementIntoView
//
//  Synopsis:   Scroll the element into view
//
//-------------------------------------------------------------------------

HRESULT
CLayout::ScrollElementIntoView( CElement *  pElement,
                                SCROLLPIN   spVert,
                                SCROLLPIN   spHorz)
{
    Assert(ElementOwner()->IsInMarkup());

    if (!pElement)
    {
        pElement = ElementOwner();
    }

    //
    //  NOTE:
    //  This code should NOT test for CFlowLayout, using CElement::GetBoundingRect should suffice. Unfortunately,
    //  deep underneath this funtion (specifically in CDisplay::RegionFromElement) that behaves differently when
    //  called from a "scroll into view" routine. CFlowLayout::ScrollRangeIntoView can and does pass the correct
    //  flags such that everything works right - but CElement::GetBoundingRect cannot and does not so the rectangle
    //  it gets differs slightly thus affecting scroll into view. Blah!
    //
    //  Eventually, CDisplay::RegionFromElement should not have such odd dependencies or they should be formalized.
    //  Until then, this dual branch needs to exist. (brendand)
    //

    if (IsFlowLayout())
    {
        long    cpMin;
        long    cpMost;

        if (pElement != ElementOwner())
        {
            if (!pElement->IsAbsolute() || pElement->Tag() == ETAG_UNKNOWN)
            {
                cpMin  = max(GetContentFirstCp(), pElement->GetFirstCp());
                cpMost = min(GetContentLastCp(),  pElement->GetLastCp());
            }
            else
            {
                // since this layout is absolutely positioned, we don't want
                // to use the CPs, since these position its location-in-source.
                // instead it is just as simple to get the rect, and scroll
                // that into view directly.
                CRect rc;

                Assert(pElement->GetUpdatedLayout() && " youre about to crash");
                pElement->GetUpdatedLayout()->GetExpandedRect(&rc, COORDSYS_PARENT);

                ScrollRectIntoView(rc, spVert, spHorz);
                return S_OK;
            }
        }
        else
        {
            cpMin  =
            cpMost = -1;
        }

        RRETURN1(ScrollRangeIntoView(cpMin, cpMost, spVert, spHorz), S_FALSE);
    }

    else
    {
        CRect   rc;

        if (S_OK != pElement->EnsureRecalcNotify())
            return E_FAIL;

        pElement->GetBoundingRect(&rc);
        ScrollRectIntoView(rc, spVert, spHorz);
        return S_OK;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ScrollRangeIntoView
//
//  Synopsis:   Scroll the given range into view
//
//  Arguments:  cpStart     First cp of range
//              cpEnd       Last cp of range
//              spVert      vertical scroll pin option
//              spHorz      horizontal scroll pin option
//
//----------------------------------------------------------------------------

HRESULT
CLayout::ScrollRangeIntoView( long        cpMin,
                              long        cpMost,
                              SCROLLPIN   spVert,
                              SCROLLPIN   spHorz)
{
    CSize   size;

    ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);

    GetSize(&size);

    ScrollRectIntoView(CRect(size), spVert, spHorz);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ScrollRectIntoView
//
//  Synopsis:   Scroll the given rectangle (in content coordinates) into view.
//
//  Arguments:  rc          rect in content coordinates
//              spVert      vertical scroll pin option
//              spHorz      horizontal scroll pin option
//
//----------------------------------------------------------------------------

void
CLayout::ScrollRectIntoView( const CRect & rc,
                             SCROLLPIN     spVert,
                             SCROLLPIN     spHorz)
{
    Assert(spVert != SP_MAX && spHorz != SP_MAX);
    CPaintCaret hc( ElementOwner()->Doc()->_pCaret ); // Hide the caret for scrolling
    if (_pDispNode)
    {
        if (OpenView(FALSE, TRUE))
        {
            _pDispNode->ScrollRectIntoView(
                rc,
                COORDSYS_FLOWCONTENT,
                spVert,
                spHorz);

            EndDeferred();
        }
    }
    else
    {
        CLayout *   pLayout = GetUpdatedParentLayout();

        if (pLayout)
        {
            pLayout->ScrollElementIntoView(ElementOwner(), spVert, spHorz);
        }
    }
}


HRESULT BUGCALL
CLayout::HandleMessage(CMessage  * pMessage)
{
    HRESULT     hr          = S_FALSE;
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fIsScroller = (pDispNode && pDispNode->IsScroller());
    CDoc*       pDoc        = Doc();

    BOOL        fInBrowse   = !IsDesignMode();

    if (!ElementOwner()->CanHandleMessage())
    {
        // return into ElementOwner()'s HandleMessage
        goto Cleanup;
    }

    //
    //  Handle scrollbar messages
    //

    if (    fIsScroller
        &&  (   (pMessage->htc == HTC_HSCROLLBAR && pMessage->pNodeHit->Element() == ElementOwner())
            ||  (pMessage->htc == HTC_VSCROLLBAR && pMessage->pNodeHit->Element() == ElementOwner()))
        &&  (   (  pMessage->message >= WM_MOUSEFIRST
#ifndef WIN16
                &&  pMessage->message != WM_MOUSEWHEEL
#endif
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU ))
    {
        hr = HandleScrollbarMessage(pMessage, ElementOwner());
        if (hr != S_FALSE)
            goto Cleanup;
    }

    switch (pMessage->message)
    {
    case WM_CONTEXTMENU:
        if (!pDoc->_pInPlace->_fBubbleInsideOut)
        {
            int iContextMenu = CONTEXT_MENU_DEFAULT;

            // If the element is editable, we want to
            // display the same context menu we show
            // for editable intinsics (bug 84886)
            if ( IsEditable(/*fCheckContainerOnly*/FALSE) && fInBrowse)
            {
                iContextMenu = CONTEXT_MENU_CONTROL;
            }

            hr = THR(ElementOwner()->OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    iContextMenu));
        }
        else
            hr = S_OK;
        break;

#ifndef NO_MENU
    case WM_MENUSELECT:
        hr = THR(ElementOwner()->OnMenuSelect(
                GET_WM_MENUSELECT_CMD(pMessage->wParam, pMessage->lParam),
                GET_WM_MENUSELECT_FLAGS(pMessage->wParam, pMessage->lParam),
                GET_WM_MENUSELECT_HMENU(pMessage->wParam, pMessage->lParam)));
        break;

    case WM_INITMENUPOPUP:
        hr = THR(ElementOwner()->OnInitMenuPopup(
                (HMENU) pMessage->wParam,
                (int) LOWORD(pMessage->lParam),
                (BOOL) HIWORD(pMessage->lParam)));
        break;
#endif // NO_MENU

    case WM_KEYDOWN:
        hr = THR(HandleKeyDown(pMessage, ElementOwner()));
        break;

    case WM_HSCROLL:
        if (fIsScroller)
        {
            hr = THR(OnScroll(
                    0,
                    LOWORD(pMessage->wParam),
                    HIWORD(pMessage->wParam),
                    FALSE));
        }
        break;

    case WM_VSCROLL:
        if (fIsScroller)
        {
            hr = THR(OnScroll(
                    1,
                    LOWORD(pMessage->wParam),
                    HIWORD(pMessage->wParam),
                    FALSE));
        }
        break;

    case WM_CHAR:
        if (pMessage->wParam == VK_RETURN && fInBrowse)
        {
            hr = THR(pDoc->ActivateDefaultButton(pMessage));
            if (S_OK != hr && ElementOwner()->GetParentForm())
            {
                MessageBeep(0);
            }
            break;
        }

        if (    fInBrowse
            &&  pMessage->wParam == VK_SPACE
            &&  fIsScroller)
        {
            CDispNodeInfo   dni;
            GetDispNodeInfo(&dni);

            if (dni.IsVScrollbarAllowed())
            {
                OnScroll(
                    1,
                    pMessage->dwKeyState & MK_SHIFT
                            ? SB_PAGEUP
                            : SB_PAGEDOWN,
                    0,
                    FALSE,
                    (pMessage->wParam&0x4000000)
                            ? 50  // TODO (IE6 bug 13575): For now we are using the mouse delay - should use Api to find system key repeat rate set in control panel.
                            : MAX_SCROLLTIME);
            }
            hr = S_OK;
            break;
        }
        break;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     PrepareMessage
//
//  Synopsis:   Prepare the CMessage for the layout (e.g., ensure the
//              content point exists)
//
//  Arguments:  pMessage  - CMessage to prepare
//              pDispNode - CDispNode to use (defaults to layout display node)
//
//--------------------------------------------------------------------------

void
CLayout::PrepareMessage(
    CMessage *  pMessage,
    CDispNode * pDispNode)
{
    if (!pMessage->IsContentPointValid())
    {
        if (!pDispNode)
            pDispNode = GetElementDispNode();

        if (pDispNode)
        {
            pMessage->pDispNode = pDispNode;
            pDispNode->TransformPoint(pMessage->pt,
                                      COORDSYS_GLOBAL,
                                      &pMessage->ptContent,
                                      COORDSYS_FLOWCONTENT);
            pMessage->coordinateSystem = COORDSYS_FLOWCONTENT;
        }
    }
}


ExternTag(tagMsoCommandTarget);

void
CLayout::AdjustSizeForBorder(SIZE * pSize, CDocInfo * pdci, BOOL fInflate)
{
    CBorderInfo bInfo;

    if (ElementOwner()->GetBorderInfo(pdci, &bInfo, FALSE, FALSE))
    {
        int iXWidths = bInfo.aiWidths[SIDE_RIGHT] + bInfo.aiWidths[SIDE_LEFT];
        int iYWidths = bInfo.aiWidths[SIDE_TOP] + bInfo.aiWidths[SIDE_BOTTOM];

        pSize->cx += fInflate ? iXWidths : -iXWidths;
        pSize->cy += fInflate ? iYWidths : -iYWidths;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   PercentSize
//              PercentWidth
//              PercentHeight
//
//  Synopsis:   Handy helpers to check for percentage dimensions
//
//----------------------------------------------------------------------------

BOOL
CLayout::PercentSize()
{
    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext())); 
    return (pFF->IsWidthPercent() || pFF->IsHeightPercent());
}

BOOL
CLayout::PercentWidth()
{
    CTreeNode * pNode = GetFirstBranch();
    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    return pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->IsLogicalWidthPercent(
        pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
}

BOOL
CLayout::PercentHeight()
{
    CTreeNode * pNode        = GetFirstBranch();
    const CCharFormat *pCF   = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    return pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->IsLogicalHeightPercent(
        pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSite::Move
//
//  Synopsis:   Move and/or resize the control
//
//  Arguments:  [rc]      -- New position
//              [dwFlags] -- Specifies flags
//
//  Notes:      prcpixels is in parent content relative coords of the site.
//              Move will take into account to offset it appropriately
//              with it's region parent.
//
//----------------------------------------------------------------------------

HRESULT
CLayout::Move(RECT *prcpixels, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    RECT            rcWindow;
    CDocInfo        DCI(ElementOwner());
    CBorderInfo     borderinfo;
    int             xWidth2, yWidth2;
    BOOL            fChanged = FALSE;
    DWORD           dwNotificationFlags;
    CRect           rcContainer;


    // Only call RequestLayout if we're just moving the object, to minimize
    // repainting.

    dwNotificationFlags = (dwFlags & SITEMOVE_NORESIZE)
                          ? ELEMCHNG_SITEPOSITION | ELEMCHNG_CLEARCACHES
                          : ELEMCHNG_SIZECHANGED  | ELEMCHNG_CLEARCACHES;

#ifndef NO_EDIT
    {
        CUndoPropChangeNotificationPlaceHolder
                notfholder( !(dwFlags & SITEMOVE_NOFIREEVENT) &&
                            Doc()->LoadStatus() == LOADSTATUS_DONE,
                            ElementOwner(), DISPID_UNKNOWN, dwNotificationFlags );
#endif // NO_EDIT

    Assert(prcpixels);

    // we need to see if we are in a right to left situation
    // if we are we will need to set our left at a correct distance from our
    // parent's left
    CTreeNode * pParentNode = GetFirstBranch()->GetUpdatedParentLayoutNode();

    CLayout* pParentLayout = GetFirstBranch()->GetUpdatedParentLayout();

    // We might not get a pParentLayout at this point: e.g. an OBJECT tag in
    // the HEAD (recall <HTML> has no layout) (bug #70791), in which
    // case we play it safe and init rcContainer to a 0 pixel rect
    // (it shouldn't be used in any meaningful way anyways).

    // if we have scroll bars, we need to take of the size of the scrolls.
    if ( pParentLayout )
    {
        if(pParentLayout->GetElementDispNode() &&
           pParentLayout->GetElementDispNode()->IsScroller())
        {
            pParentLayout->GetClientRect(&rcContainer);
        }
        else
        {
            Assert(pParentNode);

            hr = THR(pParentNode->Element()->EnsureRecalcNotify());
            if (hr)
                goto Cleanup;

            pParentNode->Element()->GetBoundingRect(&rcContainer);
        }
    }
    else
    {
        rcContainer.top = rcContainer.left = 0;
        rcContainer.bottom = rcContainer.right = 0;
    }

    //
    // Account for any zooming.
    //
    rcWindow.left   = DCI.DocPixelsFromDeviceX(prcpixels->left);
    rcWindow.right  = DCI.DocPixelsFromDeviceX(prcpixels->right);
    rcWindow.top    = DCI.DocPixelsFromDeviceY(prcpixels->top);
    rcWindow.bottom = DCI.DocPixelsFromDeviceY(prcpixels->bottom);

    //
    // Finally rcWindow is in parent site relative document coords.
    //

    if (ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_EXBORDRINMOV))
    {
        // We want untransformed border sizes (right?), so we pass in a NULL docinfo.
        ElementOwner()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE );

        xWidth2 = borderinfo.aiWidths[SIDE_RIGHT] + borderinfo.aiWidths[SIDE_LEFT];
        yWidth2 = borderinfo.aiWidths[SIDE_TOP] + borderinfo.aiWidths[SIDE_BOTTOM];
    }
    else
    {
        xWidth2 = 0;
        yWidth2 = 0;
    }


    if (!(dwFlags & SITEMOVE_NORESIZE))
    {
        // If the ELEMENTDESC flag is set

        // (ferhane)
        //  Pass in 1 when the size is not defined as a percent. If the size is defined as a
        //  percentage of the container, then the CUnitValue::SetFloatValueKeepUnits needs the
        //  container size to be passed for the proper percentage calculation.
        //
        if (!PercentWidth())
        {
            rcContainer.right = 1;
            rcContainer.left = 0;
        }

        if (!PercentHeight())
        {
            rcContainer.bottom = 1;
            rcContainer.top = 0;
        }

        // Set Attributes
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_HEIGHT,
                            (float)(rcWindow.bottom - rcWindow.top - yWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.bottom - rcContainer.top,
                            NULL,
                            FALSE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_WIDTH,
                            (float)(rcWindow.right - rcWindow.left - xWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.right - rcContainer.left,
                            NULL,
                            FALSE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        // Set In-line style
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_HEIGHT,
                            (float)(rcWindow.bottom - rcWindow.top - yWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.bottom - rcContainer.top,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_WIDTH,
                            (float)(rcWindow.right - rcWindow.left - xWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.right - rcContainer.left,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;
    }

//TODO (IE6 bug 13576): (FerhanE)
//          We will make the TOP and LEFT behavior for percentages the same with the
//          behavior for width and height above in the 5.x tree. 5.0 is not changed for
//          these attributes.
//
    if (!(dwFlags & SITEMOVE_RESIZEONLY))
    {
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_TOP,
                            (float)rcWindow.top,
                            CUnitValue::UNIT_PIXELS,
                            1,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_LEFT,
                            (float)rcWindow.left,
                            CUnitValue::UNIT_PIXELS,
                            1,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;
    }

    // Only fire off a change notification if something changed
    if (fChanged && !(dwFlags & SITEMOVE_NOFIREEVENT))
    {
        ElementOwner()->OnPropertyChange( DISPID_UNKNOWN, dwNotificationFlags );
    }

Cleanup:

#ifndef NO_EDIT
        notfholder.SetHR( fChanged ? hr : S_FALSE );
    }
#endif // NO_EDIT

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::TransformPoint
//
//  Synopsis:   Transform a point from the source coordinate system to the
//              destination coordinate system
//
//  Arguments:  ppt             point to transform
//              source          source coordinate system
//              destination     destination coordinate system
//
//----------------------------------------------------------------------------

void
CLayout::TransformPoint(
    CPoint *            ppt,
    COORDINATE_SYSTEM   source,
    COORDINATE_SYSTEM   destination,
    CDispNode *         pDispNode) const
{
    if(!pDispNode)
        pDispNode = GetElementDispNode();

    if(pDispNode)
    {
        pDispNode->TransformPoint(*ppt, source, ppt, destination);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::TransformRect
//
//  Synopsis:   Transform a rect from the source coordinate system to the
//              destination coordinate system with optional clipping.
//
//  Arguments:  prc             rect to transform
//              source          source coordinate system
//              destination     destination coordinate system
//              fClip           TRUE to clip the rectangle
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::TransformRect(
    RECT *              prc,
    COORDINATE_SYSTEM   source,
    COORDINATE_SYSTEM   destination,
    CDispNode *         pDispNode) const
{
    if (!pDispNode)
        pDispNode = _pDispNode;

    if (pDispNode)
    {
        pDispNode->TransformRect((CRect&)*prc, source, (CRect *)prc, destination);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     SetSiteTextSelection
//
//  Synopsis:   Set's a sites text selection status
//
//  Arguments:  none
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
void
CLayout::SetSiteTextSelection (BOOL fSelected, BOOL fSwap)
{
    _fTextSelected = fSelected ;
    _fSwapColor = fSwap;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleKeyDown
//
//  Synopsis:   Helper for keydown handling
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CLayout::HandleKeyDown(CMessage * pMessage, CElement * pElemChild)
{
    BOOL    fRunMode = !IsEditable(TRUE);
    BOOL    fAlt     = pMessage->dwKeyState & FALT;
    BOOL    fCtrl    = pMessage->dwKeyState & FCONTROL;
    HRESULT hr       = S_FALSE;

    if (    fRunMode
        &&  !fAlt)
    {
        CDispNode * pDispNode   = GetElementDispNode();
        BOOL        fIsScroller = pDispNode && pDispNode->IsScroller();
        BOOL        fDirect     = pElemChild == NULL;

        if (fIsScroller)
        {
            if (    !fDirect
                ||  SUCCEEDED(hr))
            {
                hr = HandleScrollbarMessage(pMessage, pElemChild);
            }
        }
    }

    if (    hr == S_FALSE
        &&  !fAlt
        &&  !fCtrl)
    {
        switch (pMessage->wParam)
        {
        case VK_RETURN:
            break;

        case VK_ESCAPE:
            if (fRunMode)
            {
                hr = THR(Doc()->ActivateCancelButton(pMessage));
            }
            break;
        }
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetTheme
//
//  Synopsis:   Return the theme to use for painting or NULL is theme 
//              not present or not active
//
//----------------------------------------------------------------------------

HTHEME 
CLayout::GetTheme(THEMECLASSID themeId)
{
    HTHEME     hTheme = NULL;
    CElement * pElementOwner = ElementOwner();

    if(pElementOwner)
    {
        CMarkup *pMarkup = pElementOwner->GetMarkupPtr();
        if(pMarkup)
            hTheme = pMarkup->GetTheme(themeId);
    }
    return hTheme;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetOwner
//
//  Synopsis:   Return the logical owner of the CDispClient interface - This
//              is always either a CElement or NULL
//
//  Arguments:  ppv - Location at which to return the owner
//
//----------------------------------------------------------------------------

void
CLayout::GetOwner(
    CDispNode const* pDispNode,
    void **     ppv)
{
    Assert(pDispNode);
    Assert(pDispNode == GetElementDispNode());
    Assert(ppv);
    *ppv = ElementOwner();
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClient
//
//  Synopsis:   Draw display leaf nodes
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    BOOL            fRestoreDIContext = FALSE;
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    // if we are asked to draw w/o a layoutcontext, and this layout has one,
    // then use our context for the callstack below us.
    if (   !pDI->GetLayoutContext()
        && LayoutContext())
    {
        pDI->SetLayoutContext(LayoutContext());
        fRestoreDIContext = TRUE;
    }

    Draw(pDI, pDispNode);
    DrawTextSelectionForSite(pDI, prcRedraw);
    if (fRestoreDIContext)
        pDI->SetLayoutContext(NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientBackground
//
//  Synopsis:   Draw the background
//
//  Arguments:  prcBounds       bounding rect of display leaf
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientBackground(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CBackgroundInfo bi;

    GetBackgroundInfo(pDI, &bi, TRUE);

#if DBG==1
    if (    IsTagEnabled(tagDisplayInnerHTMLNode)
        &&  ElementOwner()->Tag() == ETAG_HTML
        &&  _pDispNode != pDispNode )
    {
        bi.crBack     = RGB(0x80,0xff,0xff);
        bi.crTrans    = RGB(0,0,0);
    }
#endif

    if (bi.crBack != COLORREF_NONE || bi.pImgCtx)
        DrawBackground(pDI, &bi, (RECT *)&pDI->_rc);

    if ( IsShowZeroBorderAtDesignTime() &&
         Tag() != ETAG_CAPTION )
    {
        CLayout* pParentLayout = GetUpdatedParentLayout();
        if ( pParentLayout && pParentLayout->IsEditable() )
        {
            DrawZeroBorder(pDI);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientBorder
//
//  Synopsis:   Draw the border
//
//  Arguments:  prcBounds       bounding rect of display leaf
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    CBorderInfo     bi;
    CLayoutContext *pOldLC  = pDI->GetLayoutContext();
    CLayoutContext *pThisLC = LayoutContext();

    AssertSz( ((pOldLC) ? (pThisLC != NULL) : (TRUE)), "If we came in with a context, we must have one ourselves" );

    pDI->SetLayoutContext( pThisLC );

    ElementOwner()->GetBorderInfo(pDI, &bi, TRUE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

    // If we're a broken layout, we may only be displaying part of
    // pElement, so we might not want to draw the top or bottom border.
    if ( pThisLC )
    {
        AdjustBordersForBreaking( &bi );
    }

    ::DrawBorder(pDI, &(pDI->_rc), &bi);

    pDI->SetLayoutContext( pOldLC );
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientScrollbar
//
//  Synopsis:   Draw horizontal/vertical scrollbar
//
//  Arguments:  iDirection      0 for horizontal scrollbar, 1 for vertical
//              prcBounds       bounding rect of the scrollbar
//              prcRedraw       rect to be redrawn
//              contentSize     size of content
//              containerSize   size of container that displays the content
//              scrollAmount    current scroll position
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientScrollbar(
    int            iDirection,
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    long           contentSize,
    long           containerSize,
    long           scrollAmount,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    CFormDrawInfo * pDI;
    CFormDrawInfo   DI;

    if (!pClientData)
    {
        DI.Init(this);
        DI._hdc = NULL;
        pDI = &DI;
    }
    else
    {
        pDI = (CFormDrawInfo *)pClientData;
    }

    CSetDrawSurface         sds(pDI, prcBounds, prcRedraw, pDispSurface);

    XHDC                    hdc  = pDI->GetDC(TRUE);
    CScrollbarController *  pSBC = TLS(pSBC);
    CScrollbarParams        params;
    CRect                   rcHimetricBounds;
    CTreeNode            *  pTreeNode   = ElementOwner()->GetFirstBranch();
    // When passing a xhdc pointer to this class make sure you do not delete ot before
    // this object is gone. It might try to use it.
    CScrollbarThreeDColors  colors(pTreeNode, &hdc);

    Assert(pSBC != NULL);

    const CCharFormat  *pCF  = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));

    if(pCF != NULL &&  pCF->HasVerticalLayoutFlow())
    {
        // Set a special flag so that the themed buttons will appear right
        dwFlags |= DISPSCROLLBARHINT_VERTICALLAYOUT;
    }

    params._pColors = &colors;
    params._buttonWidth = ((const CRect*)prcBounds)->Size(1-iDirection);
    params._fFlat       = Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_FLAT_SCROLLBAR;
    params._fForceDisabled = ! ElementOwner()->IsEnabled();
    params._hTheme = GetTheme(THEME_SCROLLBAR);
#ifdef UNIX // Used for Motif scrollbar
    params._bDirection = iDirection;
#endif

    CScrollbar::Draw(
        iDirection,
        pDI->_rc,
        pDI->_rcClip,
        contentSize,
        containerSize,
        scrollAmount,
        ((iDirection==pSBC->GetDirection() && pSBC->GetLayout() == this)
            ? pSBC->GetPartPressed()
            : CScrollbar::SB_NONE),
        hdc,
        params,
        pDI,
        dwFlags);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientScrollbarFiller
//
//  Synopsis:   Draw dead region between scrollbars, that is also called corner
//
//  Arguments:  prcBounds       bounding rect of the dead region
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    HDC            hdc;

    if (SUCCEEDED(pDispSurface->GetDC(&hdc)))
    {
        XHDC        xhdc(hdc, pDispSurface);
        HBRUSH      hbr = NULL;

        // Ideally there should have been a part definition for the scrollbar code in the
        // theme APIs and we should have called GetTheme and used DrawThemeBackground if theming is on.
        // Even if they did the same thing as we do here it would provide a necessary level
        // of abstraction.

        CScrollbarThreeDColors  colors(ElementOwner()->GetFirstBranch(), &xhdc);

        pDispSurface->SetClip(*prcRedraw);
        
        hbr = colors.BrushBtnFace();
        FillRect(xhdc, prcRedraw, hbr);
        ReleaseCachedBrush(hbr);
    }
}


  


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestScrollbar
//
//  Synopsis:   Process a "hit" on a scrollbar
//
//  Arguments:  iDirection      0 for horizontal scrollbar, 1 for vertical
//              pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestScrollbar(
    int            iDirection,
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    CHitTestInfo *  phti;

    Assert(pClientData);

    phti = (CHitTestInfo *)pClientData;

    if (phti->_grfFlags & HT_IGNORESCROLL)
        return FALSE;

    phti->_htc          = (iDirection == 0) ? HTC_HSCROLLBAR : HTC_VSCROLLBAR;
    phti->_pNodeElement = GetFirstBranch();
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestScrollbarFiller
//
//  Synopsis:   Process a "hit" on a scrollbar filler
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestScrollbarFiller(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    CHitTestInfo *  phti;

    Assert(pClientData);

    phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_NO;
    phti->_pNodeElement = ElementContent() ? ElementContent()->GetFirstBranch() : NULL;
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestContentWithOverride
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//              fOverrideHitInfo This is TRUE by default. Direct calls to CLayout::HTC
//                  will count as hard hits (e.g. image, hr..) but calls coming from
//                  super (e.g. w/in bounding rect but NOT on content) will only count
//                  as hits if nothing else has already said hit.  We rely on the display
//                  tree to call in the proper z-order so that the first thing that hits
//                  sets up the CHitTestInfo Structure.
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestContentWithOverride(
                const POINT * pptHit,
                CDispNode *   pDispNode,
                void *        pClientData,
                BOOL          fOverrideHitInfo,
                BOOL          fDeclinedByPeer)
{
    //
    // NOTE (michaelw)
    //
    // For compat reasons hit testing always succeeds when an element
    // has layout, even if the content is 100% transparent.  Yum.
    //
    // The only time that ElementOwner and ElementContent are not the
    // same is when we have a view slave.  The only time the view slave's
    // layout (and its dispnode) doesn't completely cover the master
    // layout is (according to ktam) in the rect peer (CContainerLayout).
    // In that case, we should fire the event on the rect instead of the
    // slave.  For this reason we use ElementOwner and not ElementContent.
    //
    // We should consider changing this behavior for platform use
    //
    // NOTE (CARLED) we have changed this a bit. a hit on CLayout directly is
    // considered a "hard" hit and hit testing should return TRUE. However, if we
    // get here from a derived class, that means that we are really only doing a
    // boundingBox check and we then need to deal with the distinction of "soft"
    // hits - hits that are w/in our bounds but not over content.  The way this works
    // is that soft-hits do NOT fill in the HitTestInfo if there is already a
    // _pNodeElement (since someone higher up inthe Z-order has already registered a soft
    // hit.  (had there been a "hard" hit the hit testing would have stopped with a return true).
    // if the _pNodeElement is empty then this is the first element to find a soft hit
    // and it will register itself.
    //
    // fOverride is TRUE by default (so calls to this Fx directly (e.g. Image or HR) will be
    // hard-hits if w/in the bounds.
    //
    // NOTE (carled) but (bug 104782) - if a renderingBehavior has declined the hit
    // (phti->_htc == HTC_BEHAVIOR && !phti->_pNodeElement) but the
    // dispnode HasBackground, we are going to return TRUE and stop hittesting
    // however, with the peer declinig we have no element to return at this time.
    // so we *have* to return this
    //

    Assert(pClientData);

    CHitTestInfo *phti = (CHitTestInfo *)pClientData;

    if (   fDeclinedByPeer
        && !fOverrideHitInfo
        && !pDispNode->HasBackground())
    {
        //
        // if we get here with no override, then we are being called from a
        // derieved layout class and in a non-content hittest pass.  If the
        // _htc is HTC_BEAHVIOR then this is a peer'd elementOwner() and if
        // _pNodeElement is NULL, then the peer has declined the hit,which
        // requires that we ignore it here to.
        //
        phti->_htc = HTC_NO;
    }
    else
    {
        phti->_htc          = HTC_YES;

        if (   fOverrideHitInfo
            || !phti->_pNodeElement)
            return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestContentCleanup
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestContentCleanup(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    CHitTestInfo *  phti,
    CElement *      pElement)
{
    Assert(pptHit);
    Assert(pDispNode);
    POINT ptNodeHit = *pptHit;


    Assert(phti->_htc != HTC_NO);
    phti->_pNodeElement = pElement->GetFirstBranch();
    phti->_ptContent    = ptNodeHit;
    phti->_pDispNode    = pDispNode;

    phti->_phtr->_fWantArrow = TRUE;

    SetHTILayoutContext( phti );

    Assert( ElementOwner()->HasLayoutAry() ? phti->_pLayoutContext != NULL : TRUE );

#if DBG
    // At this point if we hit an element w/ layout, it better
    // be the the owner of this layout; otherwise the display
    // tree should have called us on the HitTestContent of that
    // layout!!
    Assert( phti->_pNodeElement->Element()->ShouldHaveLayout() ?
            phti->_pNodeElement->Element() == ElementOwner() :
            TRUE );
#endif

    return (phti->_htc != HTC_NO);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestPeer
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              cookie          which peer to test
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestPeer(
    const POINT *   pptHit,
    COORDINATE_SYSTEM cs,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    BOOL            fHitContent,
    CDispHitContext *pContext,
    BOOL *pfDeclinedHit)
{
    Assert(pptHit);
    Assert(pClientData);

    POINT          ptNodeHit   = *pptHit;
    CPeerHolder  * pPeerHolder = NULL;
    CHitTestInfo * phti        = (CHitTestInfo *)pClientData;

    if (pfDeclinedHit)
        *pfDeclinedHit = FALSE;

    if (cookie == NULL)
    {
        pPeerHolder = ElementOwner()->GetRenderPeerHolder();
    }
    else
    {
        // make sure the cookie points to a PH that still exists
        CPeerHolder * pPH = (CPeerHolder*) cookie;
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (pPH == iter.PH())
            {
                pPeerHolder = pPH;
                break;
            }
        }

        if(!pPeerHolder && 
            (ElementOwner()->Tag() == ETAG_BODY 
                || ElementOwner()->Tag() == ETAG_FRAMESET 
                || ElementOwner()->Tag() == ETAG_HTML))
        {
            Assert(ElementOwner()->Tag() != ETAG_HTML || GetOwnerMarkup()->IsHtmlLayout());
            // If this peer holder was not found it could be because we were in the middle
            // of a page transition, and we need to delegate to page transitionthe peer on
            // the root element
            CMarkup * pMarkup = ElementOwner()->GetMarkupPtr();
            if(pMarkup)
            {
                CDocument * pDocument = pMarkup->Document();
                if(pDocument && pDocument->HasPageTransitions())
                {
                    for (iter.Start(pMarkup->Root()->GetPeerHolder());
                         !iter.IsEnd();
                         iter.Step())
                    {
                        if (pPH == iter.PH())
                        {
                            pPeerHolder = pPH;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (pPeerHolder &&
        pPeerHolder->TestPainterFlags(HTMLPAINTER_HITTEST))
    {
        //
        // delegate hit testing to peer
        //

        HRESULT hr;
        BOOL    fHit;

        // (treat hr error as no hit)
        CLayoutContext * pLayoutContext = LayoutContext();
        if(pLayoutContext)
            pContext->PushLayoutContext(pLayoutContext);

        hr = THR(pPeerHolder->HitTestPoint(pContext, fHitContent, &ptNodeHit, &fHit));
        if(pLayoutContext)
            pContext->PopLayoutContext();

        if (hr)
            goto Cleanup;

        // regardless of the hit or no, we want to honor the peers setting.
        if(fHit)
        {
            // First we need to determine if this hit actually happened on this peer
            // or if it was the result of a nested hit test via the filter
            // CPeerHolder::HitTestPoint doesn't set _htc so if the hit test succeeded
            // and _htc is empty, this hit really does belong to this behavior
            // if a previous behavior declined the hit, then we are free to override
            // at this point.

            if (    phti->_htc == HTC_NO
                || (   phti->_htc == HTC_BEHAVIOR
                    && phti->_pNodeElement ==NULL))
            {
                phti->_htc = HTC_BEHAVIOR;
                // hit on the peer itself, set return info for this element
                pContext->SetHitTestCoordinateSystem(cs);
                return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
            }
            else
            {
                // if the hit is handled by some child of (filter) peer, return info
                // is already set
                //
                // otherwise, It must be a psuedo hit on a postioned object (109680)
                // and it is safe to override.
                if (   ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE)
                   || ElementOwner()->IsDesignMode() )
                {
                    // we are editing and the info in the phti is for a descendant,
                    // then use it
                    if (   phti->_htc != HTC_NO
                        && phti->_pNodeElement
                        && (   phti->_pNodeElement->Element() == ElementOwner()
                            || GetFirstBranch()->AmIAncestorOrMasterOf(phti->_pNodeElement)
                           )
                        )
                    {
                        return TRUE;
                    }
                    else
                    {
                        // The hit is on a non-relative, or ancestor, so our claim to the hit
                        // is stronger, so use us.
                        phti->_htc = HTC_BEHAVIOR;
                        // hit on the peer itself, set return info for this element
                        pContext->SetHitTestCoordinateSystem(cs);
                        return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
                    }
                }
                else
                {
                    return TRUE;
                }
            }
        }
        else if (   ElementOwner()->Doc()->_fPeerHitTestSameInEdit
                 || (   !ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE)
                     && !ElementOwner()->IsDesignMode() 
                    )
                )
        {
            // if Editable or design mode, don't do this clearing.
            //
            //this is NOT a hit on the peer, so return FALSE (to continue the
            //  hit test search) but also clear the HitTestInfo.
            //
            // BUT WAIT, only clear the HTI if the _pNodeElement is ours! why?
            // because someone higher in the z-order may have already registered for the
            // hit.  if so, we don't necessarily want to blow them away.
            if (   phti->_pNodeElement
                && phti->_pNodeElement == GetFirstBranch())
            {
                phti->_htc = HTC_BEHAVIOR;
                phti->_pNodeElement = NULL;
                phti->_pDispNode    = NULL;
            }

        if (pfDeclinedHit)
            *pfDeclinedHit = TRUE;
        }
    }

Cleanup:
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestFuzzy
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHitInBoxCoords       hit test point in box coordinates
//              pDispNode               pointer to display node
//              pClientData             client-specified data for hit testing
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestFuzzy(
    const POINT *   pptHitInBoxCoords,
    CDispNode *     pDispNode,
    void *          pClientData)
{
    Assert(pptHitInBoxCoords);
    Assert(pDispNode);
    Assert(pClientData);

    // HitTestFuzzy shouldn't be called unless we're in design mode
    Assert(DoFuzzyHitTest());

    CHitTestInfo *  phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_YES;
    phti->_pNodeElement = ElementContent()->GetFirstBranch();
    phti->_phtr->_fWantArrow = TRUE;

    SetHTILayoutContext( phti );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestBorder
//
//  Synopsis:   Hit test the border for this layout.
//
//  Arguments:  pptHit          point to hit test
//              pDispNode       display node
//              pClientData     client data
//
//  Returns:    TRUE if the given point hits this node's border.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestBorder(
        const POINT *pptHit,
        CDispNode *pDispNode,
        void *pClientData)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CHitTestInfo *  phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_YES;
    phti->_pNodeElement = GetFirstBranch();
    phti->_phtr->_fWantArrow = TRUE;
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestBoxOnly, CDispClient
//
//  Synopsis:   Hook to do hit testing against the box only (as opposed to the content)
//
//  Arguments:  none
//
//  Returns:    TRUE if hit
//
//  Notes:      this is a hack to support VID's "frozen" attribute
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestBoxOnly(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData)
{
    if (ElementOwner()->IsFrozen())
    {
        CHitTestInfo *phti = (CHitTestInfo *)pClientData;

        phti->_htc          = HTC_YES;
        return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ProcessDisplayTreeTraversal
//
//  Synopsis:   Process results of display tree traversal.
//
//  Arguments:  pClientData     pointer to data defined by client
//
//  Returns:    TRUE to continue traversal
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    return TRUE;
}

CTreeNode *
GetTopmostAbsoluteZParent(CTreeNode *pBaseNode)
{
    CTreeNode * pHeadNode;
    CTreeNode * pRearNode = pBaseNode;
    CTreeNode * pCanvasNode = pBaseNode->GetMarkup()->GetCanvasElement()->GetFirstBranch();

    Assert(pRearNode);

    pHeadNode = pRearNode->ZParentBranch();

    while (     pHeadNode
            &&  !pHeadNode->IsPositionStatic()
            &&  pHeadNode != pCanvasNode )
    {
        pRearNode = pHeadNode;
        pHeadNode = pHeadNode->ZParentBranch();
    }

    return pRearNode;
}

void
PopulateAbsoluteZParentAry(CPtrAry<CTreeNode *> *pary, CTreeNode *pBaseNode)
{
    CTreeNode *pNode = pBaseNode;
    CTreeNode *pCanvasNode = pBaseNode->GetMarkup()->GetCanvasElement()->GetFirstBranch();
    Assert(pary);
    Assert(pNode);

   while (     pNode
            &&  !pNode->IsPositionStatic()
            &&  pNode != pCanvasNode )
    {
        pary->Append(pNode);
        pNode = pNode->ZParentBranch();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetZOrderForSelf
//
//  Synopsis:   Return Z order for this container.
//
//  Returns:    Z order for this container.
//
//----------------------------------------------------------------------------
LONG
CLayout::GetZOrderForSelf(CDispNode const* pDispNode)
{
    Assert(!GetFirstBranch()->IsPositionStatic());

    return ReparentedZOrder()
                ?   GetTopmostAbsoluteZParent(GetFirstBranch())->GetCascadedzIndex()
                :   GetFirstBranch()->GetCascadedzIndex();
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::CompareZOrder
//
//  Synopsis:   Compare the z-order of two display nodes
//
//  Arguments:  pDispNode1 - Display node owned by this display client
//              pDispNode2 - Display node to compare against
//
//  Returns:    Greater than zero if pDispNode1 is greater
//              Less than zero if pDispNode1 is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------
MtDefine(CompareZOrder_ary1_pv, Locals, "CLayout::CompareZOrder::aryNode1::CTreeNode*")
MtDefine(CompareZOrder_ary2_pv, Locals, "CLayout::CompareZOrder::aryNode2::CTreeNode*")

LONG
CLayout::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    Assert(pDispNode1);
    Assert(pDispNode2);

    CElement *  pElement1 = ElementOwner();
    CElement *  pElement2 = ::GetDispNodeElement(pDispNode2);


    // If we've reparented the display nodes involved,
    if (    ReparentedZOrder()
        &&  pDispNode2->GetDispClient()->ReparentedZOrder() )
    {
        // TODO (IE6 bug 13584) (greglett) PERF
        // We can collapse the IsParent tests into the ZParentAry checking easily.
        // We should actually get rid off all the reparentd zindex code, and somehow
        // frontload the work.

        // A child automatically beats a parent.  Z-Index is heirarchical.
        if (pElement1->IsParent(pElement2))
            return 1;

        if (pElement2->IsParent(pElement1))
            return -1;

        //  Otherwise, the topmost positioned zparent of each child should
        //  be compared.  Find it, and set pElement accordingly.
        //  Unfortunately, this top-down approach would require us to repeatedly
        //  walk the tree, so we store the results in arrays to ward off O(n^2) for O(2n).
        CPtrAry<CTreeNode *> aryNode1(Mt(CompareZOrder_ary1_pv));
        CPtrAry<CTreeNode *> aryNode2(Mt(CompareZOrder_ary2_pv));
        int n1, n2;
        PopulateAbsoluteZParentAry(&aryNode1, pElement1->GetFirstBranch());
        PopulateAbsoluteZParentAry(&aryNode2, pElement2->GetFirstBranch());

        n1 = aryNode1.Size() - 1;
        n2 = aryNode2.Size() - 1;
        while (     n1 >= 0
                &&  n2 >= 0
                &&  aryNode1[n1] == aryNode2[n2])
        {
            n1--;
            n2--;
        }

        if (n1 >= 0 && n2 >= 0)
        {
            pElement1 = aryNode1[n1]->SafeElement();
            pElement2 = aryNode2[n2]->SafeElement();
        }

        Assert(pElement1);
        Assert(pElement2);
    }
    // TODO (IE6 bug 13584) (greglett) This code really should be in the other CompareZOrder
    // implementations, also.
    else if (ReparentedZOrder())
    {
        // Our parent should be the one who compares.
        pElement1 = GetTopmostAbsoluteZParent(GetFirstBranch())->SafeElement();
    }
    else if (pDispNode2->GetDispClient()->ReparentedZOrder())
    {
        // Out parent should be the one who compares.
        pElement2 = GetTopmostAbsoluteZParent(pElement2->GetFirstBranch())->SafeElement();
    }

    //
    //  Compare element z-order
    //  If the same element is associated with both display nodes,
    //  then the second display node is for an adorner (which always come
    //  on top of the element)
    //

    return pElement1 != pElement2
                ? pElement1->CompareZOrder(pElement2)
                : -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HandleViewChange
//
//  Synopsis:   Respond to changes of this layout's in-view status.
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------

void
CLayout::HandleViewChange(
     DWORD          flags,
     const RECT *   prcClient,
     const RECT *   prcClip,
     CDispNode *    pDispNode)
{
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyScrollEvent
//
//  Synopsis:   A scroll has occured in the display and now we can do
//              something with this information, like fire the script
//              event
//
//  Arugments:  prcScroll        - Rectangle scrolled
//              psizeScrollDelta - Amount scrolled
//
//----------------------------------------------------------------------------

void
CLayout::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    CDoc * pDoc = Doc();

    pDoc->GetView()->AddEventTask(ElementOwner(), DISPID_EVMETH_ONSCROLL, 0);

    pDoc->DeferSetCursor();

    if (pDoc->_pCaret)
    {
        // Update caret only if it is in this markup (#67170)
        Assert(ElementOwner()->IsInMarkup());
        Assert(pDoc->_pElemCurrent && pDoc->_pElemCurrent->IsInMarkup());
        if (pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup(ElementOwner()->GetMarkup()))
        {
            pDoc->_pCaret->UpdateCaret(FALSE, FALSE);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetPeerPainterInfo
//
//  Synopsis:   Return peer rendering layers
//
//-----------------------------------------------------------------------------

DWORD
CLayout::GetPeerPainterInfo(CAryDispClientInfo *pAryClientInfo)
{
    CElement     * pElem;
    CPeerHolder  * pPeerHolder = NULL;

    Assert(pAryClientInfo && pAryClientInfo->Size() == 0);

    pElem = ElementOwner();
    if(pElem->HasPeerHolder())
    {
        pPeerHolder = pElem->GetPeerHolder();
    }

    // Append the info that is delegated to the Root if needed
    // The peer is on the root when we are in the middle of a page transition
    if((pElem->Tag() == ETAG_BODY || pElem->Tag() == ETAG_FRAMESET || pElem->Tag() == ETAG_HTML))
    {
        CMarkup * pMarkup = pElem->GetMarkupPtr();
        if(pMarkup)
        {
            CDocument *pDocument = pMarkup->Document();
            if(pDocument && pDocument->HasPageTransitions() &&  pMarkup->Root()->HasPeerHolder())
            {
                // Peers for the page transition are attached to the root element
                CPeerHolder * pRootPeerHolder = pElem->GetMarkupPtr()->Root()->GetPeerHolder();
                CPeerHolder::CPeerHolderIterator iter;

                for (iter.Start(pRootPeerHolder);
                     !iter.IsEnd();
                     iter.Step())
                {
                    // All the peers that delegate to the root are filters
                    if (!iter.PH()->_pRenderBag->_fInFilterCallback)
                    {
                        CDispClientInfo *pInfo = pAryClientInfo->Append();
                        if (pInfo)
                        {
                            pInfo->_sInfo = iter.PH()->_pRenderBag->_sPainterInfo;
                            pInfo->_pvClientData = (void*) iter.PH();
                        }
                    }
                }
            }
        }
    }

    if (pPeerHolder)
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pPeerHolder);
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsRenderPeer() && !iter.PH()->_pRenderBag->_fInFilterCallback)
            {
                CDispClientInfo *pInfo = pAryClientInfo->Append();
                if (pInfo)
                {
                    pInfo->_sInfo = iter.PH()->_pRenderBag->_sPainterInfo;
                    pInfo->_pvClientData = (void*) iter.PH();
                }
            }
        }
    }


    return pAryClientInfo->Size() ? pAryClientInfo->Item(0)._sInfo.lZOrder
                                   : HTMLPAINT_ZORDER_NONE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientPainterInfo
//
//  Synopsis:   Return client rendering layers
//
//-----------------------------------------------------------------------------

DWORD
CLayout::GetClientPainterInfo(  CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if ( _pDispNode    != pDispNodeFor)     // if draw request is for nodes other then primary
        return 0;                       // no layers

    return GetPeerPainterInfo(pAryClientInfo);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientLayers
//
//  Synopsis:   Give a peer a chance to render
//
//-----------------------------------------------------------------------------

void
CLayout::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CDispDrawContext * pContext = (CDispDrawContext *)pClientData;
    CFormDrawInfo * pDI         = (CFormDrawInfo *)pContext->GetClientData();
    CPeerHolder * pPeerHolder = NULL;
    CPeerHolder * pPeerHolderPageTransition = NULL;
    CElement    * pElemOwner = ElementOwner();

    BOOL    fNeedPageTransitionRedirect =
            (     pElemOwner->Tag() == ETAG_BODY 
               || pElemOwner->Tag() == ETAG_FRAMESET
               || pElemOwner->Tag() == ETAG_HTML
            ) &&
            pElemOwner->HasMarkupPtr() &&
            pElemOwner->GetMarkupPtr()->Root()->HasPeerHolder();

    Assert(!fNeedPageTransitionRedirect || pElemOwner->GetMarkupPtr()->Document());
    // If root has a peerholder, we must have page transitions
    Assert(!fNeedPageTransitionRedirect || pElemOwner->GetMarkupPtr()->Document()->HasPageTransitions());

    Assert(pDI);
    Assert(pElemOwner->HasPeerHolder() || fNeedPageTransitionRedirect);

    if (cookie == NULL)
    {
        if(fNeedPageTransitionRedirect)
        {
            pPeerHolderPageTransition = pElemOwner->GetMarkupPtr()->Root()->GetRenderPeerHolder();
        }
        pPeerHolder = pElemOwner->GetRenderPeerHolder();
    }
    else
    {
        // make sure the cookie points to a PH that still exists
        CPeerHolder * pPH = (CPeerHolder*) cookie;
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pElemOwner->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (pPH == iter.PH())
            {
                pPeerHolder = pPH;
                break;
            }
        }

        if(fNeedPageTransitionRedirect)
        {
            // Peers for the page transition are attached to the root element
            for (iter.Start(pElemOwner->GetMarkup()->Root()->GetPeerHolder());
                 !iter.IsEnd();
                 iter.Step())
            {
                if (pPH == iter.PH())
                {
                    pPeerHolderPageTransition = pPH;
                    break;
                }
            }
        }
    }

    Assert(pPeerHolder || pPeerHolderPageTransition);

    if (pPeerHolder)
    {
        Assert(pPeerHolder->_pRenderBag);
        CRect rcBounds = *prcBounds;
        CRect rcClip = *prcRedraw;

        pContext->IntersectRedrawRegion(&rcClip);
        CSetDrawSurface sds(pDI, &rcBounds, &rcClip, pDispSurface);

        // Save the layout draw context into the pContext
        // It will be needed when the filter calls back, so we can decide
        // which one fo the multiple layoutes the call goes to
        CLayoutContext * pLayoutContext = LayoutContext();
        if(pLayoutContext)
            pContext->PushLayoutContext(pLayoutContext);

        pPeerHolder->Draw(pContext, dwFlags);

        if(pLayoutContext)
            pContext->PopLayoutContext();
    }

    if (pPeerHolderPageTransition)
    {
        Assert(pPeerHolderPageTransition->_pRenderBag);
        CRect rcBounds = *prcBounds;
        CRect rcClip = *prcRedraw;

        pContext->IntersectRedrawRegion(&rcClip);
        CSetDrawSurface sds(pDI, &rcBounds, &rcClip, pDispSurface);

        pPeerHolderPageTransition->Draw(pContext, dwFlags);
    }


}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::HasFilterPeer, per CDispClient
//
//  Synopsis:   Return true if there's a filter peer for the given dispnode
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HasFilterPeer(CDispNode *pDispNode)
{
    BOOL    fPageTransitonRedirect = FALSE;
    if (pDispNode == _pDispNode)
    {
        CPeerHolder * pPeerHolder = ElementOwner()->GetFilterPeerHolder(TRUE, &fPageTransitonRedirect);
        if(fPageTransitonRedirect && !pPeerHolder)
        {
            pPeerHolder = ElementOwner()->GetFilterPeerHolder(FALSE);
        }

        return (pPeerHolder != NULL);
    }
    else
    {
        return FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::HasOverlayPeer, per CDispClient
//
//  Synopsis:   Return true if there's an overlay peer for the given dispnode
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HasOverlayPeer(CDispNode *pDispNode)
{
    if (pDispNode == _pDispNode)
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsOverlayPeer())
                return TRUE;
        }
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::MoveOverlayPeers, per CDispClient
//
//  Synopsis:   Notify overlay peers that they have moved
//
//-----------------------------------------------------------------------------

void
CLayout::MoveOverlayPeers(CDispNode *pDispNode, CRect *prcgBounds, CRect *prcScreen)
{
    if (pDispNode == _pDispNode)
    {
        CInPlace *pInPlace = Doc()->_pInPlace;

        if (pInPlace)
        {
            // translate to screen coordinates
            CPoint ptTopLeft = prcgBounds->TopLeft();
            CPoint ptBottomRight = prcgBounds->BottomRight();

            ClientToScreen(pInPlace->_hwnd, &ptTopLeft);
            ClientToScreen(pInPlace->_hwnd, &ptBottomRight);

            CRect rcScreen(ptTopLeft, ptBottomRight);

            // if it moved, notify the peers
            if (rcScreen != *prcScreen)
            {
                CPeerHolder::CPeerHolderIterator iter;

                for (iter.Start(ElementOwner()->GetPeerHolder());
                     !iter.IsEnd();
                     iter.Step())
                {
                    if (iter.PH()->IsOverlayPeer())
                    {
                        iter.PH()->OnMove(&rcScreen);
                    }
                }
            }

            // update last known position
            *prcScreen = rcScreen;
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::InvalidateFilterPeer
//
//  Synopsis:   Send invalidation into the filter behavior
//
//-----------------------------------------------------------------------------

HRESULT
CLayout::InvalidateFilterPeer(
                const RECT* prc,
                HRGN hrgn,
                BOOL fSynchronousRedraw)
{
    BOOL            fPageTransitonRedirect;
    HRESULT         hr = S_FALSE;

    CPeerHolder   * pPeerHolder = ElementOwner()->GetFilterPeerHolder(TRUE, &fPageTransitonRedirect);

    if (pPeerHolder)
    {
        pPeerHolder->InvalidateFilter(prc, hrgn, fSynchronousRedraw);
        hr = S_OK;
    }

    if(fPageTransitonRedirect)
    {
        pPeerHolder = ElementOwner()->GetFilterPeerHolder(FALSE);
        if (pPeerHolder)
        {
            pPeerHolder->InvalidateFilter(prc, hrgn, fSynchronousRedraw);
            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DumpDebugInfo
//
//  Synopsis:   Dump debugging information for the given display node.
//
//  Arguments:  hFile           file handle to dump into
//              level           recursive tree level
//              childNumber     number of this child within its parent
//              pDispNode       pointer to display node
//              cookie          cookie value (only if present)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DumpDebugInfo(
        HANDLE hFile,
        long level,
        long childNumber,
        CDispNode const* pDispNode,
        void *cookie)
{
    if (pDispNode->IsOwned())
    {
        WriteHelp(hFile, _T("<<tag><0s><</tag>\r\n"), ElementOwner()->TagName());
    }
}
#endif


//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//              There are up to two display nodes associated with a layout:
//              The display node that directly represents the layout to its
//              parent and the display node that establishes the container
//              coordinate system for the layout (the primary display node).
//
//              The first of these is always kept in _pDispNode while the second
//              will be different when a filter is active. Parents that need
//              the display node to anchor into the display tree should never
//              request the primary display node (that is, fPrimary should be
//              FALSE for these uses). However, the layout itself should always
//              request the primary display node when accessing its own display
//              node.
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//              fForParent - If TRUE (the default), return the display node a parent
//                           inserts into the tree. Otherwise, return the primary
//                           display node.
//                           NOTE: This only makes a difference with layouts that
//                                 have a filter.
//
//  Returns:    Pointer to the layout CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CLayout::GetElementDispNode( CElement *  pElement ) const
{
    Assert(   !pElement
           || pElement == ElementOwner());

    return _pDispNode;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetElementDispNode
//
//  Synopsis:   Set the display node for an element
//              NOTE: This is only supported for elements with layouts or
//                    those that are relatively positioned
//
//-----------------------------------------------------------------------------
void
CLayout::SetElementDispNode( CElement *  pElement, CDispNode * pDispNode )
{
    Assert( !pElement
        ||  pElement == ElementOwner());

    _pDispNode = pDispNode;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetFirstContentDispNode
//
//  Synopsis:   Return the first content node
//
//              Only container-type display nodes have child content nodes.
//              This routine will return the first, unowned content node in the
//              flow layer under a container display or NULL.
//
//  Arguments:  pDispNode - Parent CDispNode (defaults to layout display node)
//              dwBlockID - Layout block ID.
//
//  Returns:    Pointer to flow CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispLeafNode *
CLayout::GetFirstContentDispNode( CDispNode * pDispNode ) const
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (!pDispNode)
        return NULL;

    if (!pDispNode->IsContainer())
        return NULL;

    pDispNode = pDispNode->GetFirstFlowChildNode();

    if (!pDispNode)
        return NULL;

    while (pDispNode->IsOwned())
    {
        pDispNode = pDispNode->GetNextFlowNode();
        if (!pDispNode)
            return NULL;
    }

    Assert(pDispNode && pDispNode->IsLeafNode() && !pDispNode->IsOwned());

    return CDispLeafNode::Cast(pDispNode);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetElementTransform
//
//  Synopsis:   Determine if custorm transformations are required, and fill
//              CWorldTransform if yes.
//
//  Arguments:  CDispTransform * ptransform - transformation descriptor to fill
//
//  Returns:    TRUE if transformations are required (ptransform filled)
//              FALSE if no transformations are required (ptransform ignored)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::GetElementTransform(
    const CRect    * prcSrc,              // Can be NULL
    CDispTransform * ptransform,          // Can be NULL
    BOOL           * pfResolutionChange  // Can be NULL
    ) const
{
    BOOL   fHasUserTransform = FALSE;

    if (pfResolutionChange)
        *pfResolutionChange = FALSE;

    CTreeNode *pNode = ElementOwner()->GetFirstBranch();
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

    // Note (azmyh) we assume the rotation angle to be in degrees
    // if we need more resolution we should make the changes here
    ANG ang = AngFromDeg(pNode->GetRotationAngle(pFF FCCOMMA LC_TO_FC(this->LayoutContext())));

    FLOAT flZoomFactor = 1.0;

    if (pFF->_flZoomFactor != 0)
    {
        flZoomFactor = pFF->_flZoomFactor;
    }

    // Add scaling for resolution change. The idea is to scale 1 printer inch to 1 screen inch
    CLayoutContext * pDefinedLayoutContext = DefinedLayoutContext();
    if (   pDefinedLayoutContext)
    {
        // We need to scale when parent context resolution is different from ours
        CLayoutContext * pLayoutContext = LayoutContext();
        CSize sizeInchParent = pLayoutContext 
                             ? pLayoutContext->GetMeasureInfo()->GetResolution()
                             : GetView()->GetMeasuringDevice(mediaTypeNotSet)->GetResolution();
                             
        CSize sizeInch = (pDefinedLayoutContext->IsValid())
                            ? pDefinedLayoutContext->GetMeasureInfo()->GetResolution()
                            : sizeInchParent;

        if (sizeInchParent != sizeInch)
        {
            flZoomFactor *= sizeInchParent.cx;
            flZoomFactor /= sizeInch.cx;

            if (pfResolutionChange)
                *pfResolutionChange = TRUE;
        }
    }

    if (flZoomFactor != 1.0 || ang != 0)
    {
        fHasUserTransform = TRUE;

        if (ptransform)
        {

            // define custom transformation *relative to parent*
            ptransform->SetToIdentity();

            CWorldTransform *pWorldTransform = ptransform->GetWorldTransform();

            if (ang)
            {

                Assert(prcSrc);

                 //rotate stuff

                pWorldTransform->AddRotation(ang);

                //add offset to move content back into bounds after rotation

                CRect rectBound;
                pWorldTransform->GetBoundingRectAfterTransform(prcSrc, &rectBound, FALSE /*changed from TRUE for bug 93619*/);

#if 0
                // our rects include the pixels underneath the top and
                // left edges, but not under the bottom and right edges.
                // Adjust for that here.  We decide which adjustments are
                // necessary by transforming the point (1,1) and seeing which
                // quadrant it ends up in.  This has the effect of adjusting x
                // for angles between 135 and 315 degrees, and y for angles
                // between 45 and 225 degrees (mod 360, of course).
                // We do this in a clever way just for the fun of avoiding
                // multiplications.
                if (!pWorldTransform->IsOffsetOnly())
                {
                    const XFORM *pXform = pWorldTransform->GetXform();
                    if (pXform->eM11 + pXForm->eM21 < 0.0)
                        rectBound.top += 1;
                    if (pXForm->eM12 + pXForm->eM22 < 0.0)
                        rectBound.left += 1;
                }
#endif

                pWorldTransform->AddPostTranslation( prcSrc->TopLeft() - rectBound.TopLeft());


#if DBG ==1
// this is the original code, we'll run it as well to see if the new code gives
// the right answer.  The new code is slightly more efficient, and avoids some
// obvious roundoff problems, so we expect it to give slightly different
// answers from the old code. (SamBent)
            {
                CWorldTransform worldTransform, *pWorldTransform1=&worldTransform;

                 //rotate stuff around the center (prcSrc has an untransformed(unzoomed) rect in container coords)

                pWorldTransform1->AddRotation(prcSrc, ang);

                //add offset to move content back into bounds after rotation

                CSize sizeBound, size(prcSrc->Size());
                pWorldTransform1->GetBoundingSizeAfterTransform(prcSrc, &sizeBound);

                if (sizeBound != size)
                    pWorldTransform1->AddPostTranslation((sizeBound - size) / 2);

                CPoint pt(0,0), pt1(0,0);
                pWorldTransform->Transform(&pt);
                pWorldTransform1->Transform(&pt1);
                pt -= pt1.AsSize();

                Assert(pWorldTransform->GetAngle() == pWorldTransform1->GetAngle() &&
                    Abs(pt.x) <= 2 && Abs(pt.y) <= 2);
            }
#endif
            }

            if (flZoomFactor != 1.0)
            {
                pWorldTransform->AddScaling(flZoomFactor, flZoomFactor);
            }
        }

    }

    if (   ElementOwner()->GetLayoutPeerHolder()
        && ElementOwner()->GetLayoutPeerHolder()->IsLayoutPeer())
    {

        if (ptransform)
        {
            CPoint ptOffset = ElementOwner()->GetLayoutPeerHolder()->_pLayoutBag->_ptTranslate;

            if ( ptOffset != g_Zero.pt)
            {
                // define custom transformation *relative to parent*
                ptransform->SetToIdentity();

                CWorldTransform *pWorldTransform = ptransform->GetWorldTransform();

                pWorldTransform->AddPostTranslation( ptOffset.AsSize() );
            }
        }

        fHasUserTransform  = TRUE;
    }


    return  fHasUserTransform;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeInfo
//
//  Synopsis:   Retrieve values useful for determining what type of display
//              node to create
//
//  Arguments:  pdni     - Pointer to CDispNodeInfo to fill
//              pdci     - Current CDocInfo (only required when fBorders == TRUE)
//              fBorders - If TRUE, retrieve border information
//              dwBlockID - Layout block ID.
//
//-----------------------------------------------------------------------------

void
CLayout::GetDispNodeInfo(
    CDispNodeInfo * pdni,
    CDocInfo *      pdci,
    BOOL            fBorders ) const
{
    CElement *              pElement    = ElementOwner();
    CTreeNode *             pTreeNode   = pElement->GetFirstBranch();
    const CFancyFormat *    pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *    pCF         = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CParaFormat  *    pPF       = pTreeNode->GetParaFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const BOOL  fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    const BOOL  fWritingModeUsed        = pCF->_fWritingModeUsed;
    BOOL                    fThemed     =    GetThemeClassId() != THEME_NO       
                                          && pElement->GetTheme(GetThemeClassId());
    BOOL                    fHTMLLayout = GetOwnerMarkup()->IsHtmlLayout();
    CBackgroundInfo         bi;

    //
    //  Get general information
    //

    pdni->_etag  = pElement->Tag();

    pdni->_layer =  (   !fHTMLLayout
                     && (   pdni->_etag == ETAG_BODY
                         || pdni->_etag == ETAG_FRAMESET
                         || pdni->_etag == ETAG_FRAME ))
                ||  (   fHTMLLayout
                     && pdni->_etag == ETAG_HTML )
                ||  (stylePosition)pFF->_bPositionType == stylePositionstatic
                ||  (stylePosition)pFF->_bPositionType == stylePositionNotSet
                            ? DISPNODELAYER_FLOW
                            : pFF->_lZIndex >= 0
                                    ? DISPNODELAYER_POSITIVEZ
                                    : DISPNODELAYER_NEGATIVEZ;

    //
    //  Determine if custom transformations are required
    //
    pdni->_fHasUserTransform = GetElementTransform(NULL, NULL, NULL);

    //
    //  Determine if insets are required
    //

    if (TestLayoutDescFlag(LAYOUTDESC_TABLECELL))
    {
        htmlCellVAlign  fVAlign;

        fVAlign = (htmlCellVAlign)pPF->_bTableVAlignment;

        pdni->_fHasInset = (    fVAlign != htmlCellVAlignNotSet
                            &&  fVAlign != htmlCellVAlignTop);
    }
    else
    {
        pdni->_fHasInset = TestLayoutDescFlag(LAYOUTDESC_HASINSETS);
    }

    //
    //  Determine background information
    //

    const_cast<CLayout *>(this)->GetBackgroundInfo(NULL, &bi, FALSE);

    pdni->_fHasBackground      = (bi.crBack != COLORREF_NONE || bi.pImgCtx) ||
                                  const_cast<CLayout *>(this)->IsShowZeroBorderAtDesignTime() ; // we always call DrawClientBackground when ZEROBORDER is on

    pdni->_fHasFixedBackground =        (bi.fFixed && !!bi.pImgCtx)
                                   ||   fThemed && pdni->_etag != ETAG_FIELDSET;


    pdni->_fIsOpaque = FALSE;

    if (   (pdni->_etag == ETAG_IMAGE)
        || (pdni->_etag == ETAG_IMG)
        || (   (pdni->_etag == ETAG_INPUT)
            && (DYNCAST(CInput, pElement)->GetType() == htmlInputImage)))
    {
        WHEN_DBG( const void *pvImgCtx = NULL; )
        WHEN_DBG( const void *pvInfo = NULL; )

        // These elements can have a flow layout if they have a slave. Check for this
        // before trying to cast to CImageLayout
        if (!((CLayout*)this)->IsFlowLayout())
        {
            CImageLayout *pImgLayout = const_cast<CImageLayout *>(DYNCAST(const CImageLayout, this));
            pdni->_fIsOpaque = pImgLayout->IsOpaque();

            WHEN_DBG( pvImgCtx = pImgLayout->GetImgHelper()->_pImgCtx; )
            WHEN_DBG( if (pvImgCtx) pvInfo = pImgLayout->GetImgHelper()->_pImgCtx->GetDwnInfoDbg(); )
        }

        TraceTag((tagImgTrans, "img layout %x ctx %x info %x  dni is %s",
                    this, pvImgCtx, pvInfo,
                    (!!(pdni->_fIsOpaque) ? "opaque" : "trans")));
    }

    // if there is a background image that doesn't cover the whole site, then we cannont be
    // opaque
    //
    // todo (IE5x BUG 66092) (carled) we are too close to RC0 to do the full fix.  Bug #66092 is opened for the ie6
    // timeframe to clean this up.  the imagehelper fx (above) should be REMOVED!! gone. bad
    // instead we need a virtual function on CLayout called BOOL CanBeOpaque(). The def imple
    // should contain the if stmt below. CImageLayout should override and use the contents
    // of CImgHelper::IsOpaque, (and call super). Framesets could possibly override and set
    // to false.  Input type=Image should override and do the same things as CImageLayout
    //
    pdni->_fIsOpaque  =    !TestLayoutDescFlag(LAYOUTDESC_NEVEROPAQUE)
                       &&  (   pdni->_fIsOpaque
                            || bi.crBack != COLORREF_NONE && !fThemed
                            ||  (   !!bi.pImgCtx
                                 &&  !!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE))
                                 &&  pFF->GetBgPosX().GetRawValue() == 0 // Logical/physical does not matter
                                 &&  pFF->GetBgPosY().GetRawValue() == 0 // since we check both X and Y here.
                                 &&  pFF->GetBgRepeatX()                 // Logical/physica does not matter
                                 &&  pFF->GetBgRepeatY())                // since we check both X and Y here.
                            );

    if ( Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME )
    {
        pdni->_fIsOpaque = DYNCAST(CFrameSite, pElement)->IsOpaque();
    }

    // NOTE (donmarsh) - treat elements with HWND as transparent.
    // This is pessimistic, but it's only a
    // small perf hit if the window is opaque and the display node is
    // transparent.  On the other hand, it is a rendering
    // bug if the window is transparent and the display node is opaque.
    if (pdni->_fIsOpaque && pElement->GetHwnd() != NULL)
        pdni->_fIsOpaque = FALSE;

#if DBG == 1
    if (bi.pImgCtx)
    {
        TraceTag((tagImgTrans, "layout %x  imgctx %x is %s  dni is %s",
                    this, bi.pImgCtx,
                    (!!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE)) ? "opaque" : "trans"),
                    (!!(pdni->_fIsOpaque) ? "opaque" : "trans")));
    }
#endif

    //
    //  Determine overflow, scroll and scrollbar direction properties
    //

    pdni->_overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
    pdni->_overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);
    pdni->_fIsScroller = pTreeNode->IsScrollingParent(LC_TO_FC(LayoutContext()));
    pdni->_fRTL = pTreeNode->GetCascadedBlockDirection(LC_TO_FC(LayoutContext())) == styleDirRightToLeft;

    // PERF note: not all nodes in RTL need this, only flow, and in fact, only if it is too wide.
    //            However, it is impossible to predict if an RTL node will eventually have
    //            an overflow, and display tree doesn't allow adding extras on the fly.
    //            Therefore, we have to make RTL disp nodes more expensive by an integer.
    pdni->_fHasContentOrigin = pdni->_fRTL
                                && ((CLayout*)this)->IsFlowLayout(); // only flow layout knows how to use it

    // In design mode, we want to treat overflow:hidden containers as overflow:visible
    // so editors can get to all their content.  This fakes out the display tree
    // so it creates CDispContainer*'s instead of CDispScroller, and hence doesn't
    // clip as hidden normally does. (KTam: #59722)
    // The initial fix is too aggressive; text areas implicitly set overflowX hidden
    // if they're in wordwrap mode.  Fix is to not do this munging for text areas..
    // Need to Revisit this
    // (carled) other elements (like inputText & inputButton) aslo implicitly set this property. (82287)
    if ( ((CLayout*)this)->IsDesignMode()
        && pdni->_etag != ETAG_TEXTAREA
        && pdni->_etag != ETAG_INPUT
        && pdni->_etag != ETAG_BUTTON)
    {
        if ( pdni->_overflowX  == styleOverflowHidden )
        {
            pdni->_overflowX = styleOverflowVisible;
            pdni->_fIsScroller = FALSE;
        }
        if ( pdni->_overflowY == styleOverflowHidden )
        {
            pdni->_overflowY = styleOverflowVisible;
            pdni->_fIsScroller = FALSE;
        }
    }

    if (pdni->_etag == ETAG_OBJECT)
    {
        //  Never allow scroll bars on an object.  The object is responsible for that.
        //  Bug #77073  (greglett)
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  =
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = FALSE;
    }
    else if (((   !fHTMLLayout
                 && pdni->_etag == ETAG_BODY )
             || (   fHTMLLayout
                 && pdni->_etag == ETAG_HTML
                 && GetOwnerMarkup()->GetElementClient()
                 && GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY )
               )
             && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
    {
        UpdateScrollInfo(pdni, this);
    }
    else
    {
        GetDispNodeScrollbarProperties(pdni);
    }

    //
    //  Determine appearance properties
    //

    pdni->_fHasUserClip = ( pdni->_etag != ETAG_BODY
                        &&  (stylePosition)pFF->_bPositionType == stylePositionabsolute

                            // Do not care about physical/logical here since all TBLR are checked.
                        &&  (   !pFF->GetClip(SIDE_TOP).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_BOTTOM).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_LEFT).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_RIGHT).IsNullOrEnum()));

    pdni->_fHasExpandedClip = pElement->IsBodySizingForStrictCSS1Needed();

    pdni->_visibility   = VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility(LC_TO_FC(((CLayout *)this)->LayoutContext())));

    //
    //  Get border information (if requested)
    //

    if (fBorders)
    {
        Assert(pdci);

        pdni->_dnbBorders = pdni->_etag == ETAG_SELECT
                                ? DISPNODEBORDER_NONE
                                : (DISPNODEBORDER)pElement->GetBorderInfo(pdci, &(pdni->_bi), FALSE, FALSE FCCOMMA LC_TO_FC(((CLayout *)this)->LayoutContext()));

        Assert( pdni->_dnbBorders == DISPNODEBORDER_NONE
            ||  pdni->_dnbBorders == DISPNODEBORDER_SIMPLE
            ||  pdni->_dnbBorders == DISPNODEBORDER_COMPLEX);

        pdni->_fIsOpaque = pdni->_fIsOpaque
                            && (pdni->_dnbBorders == DISPNODEBORDER_NONE
                                || (    pdni->_bi.IsOpaqueEdge(SIDE_TOP)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_LEFT)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_BOTTOM)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_RIGHT)) );
    }

    // Check if need to disable 'scroll bits' mode
    pdni->_fDisableScrollBits =   pdni->_fHasFixedBackground 
                               || (pFF->GetTextOverflow() != styleTextOverflowClip);

    // external painters may override some of the information we've computed
    if (pElement->HasPeerHolder())
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsRenderPeer())
            {
                HTML_PAINTER_INFO *pInfo = &iter.PH()->_pRenderBag->_sPainterInfo;

                // if painter is in charge of background, we're only opaque if
                // he says so
                if (!(pInfo->lFlags & HTMLPAINTER_OPAQUE) &&
                        (pInfo->lZOrder == HTMLPAINT_ZORDER_REPLACE_BACKGROUND ||
                         pInfo->lZOrder == HTMLPAINT_ZORDER_REPLACE_ALL))
                {
                    pdni->_fIsOpaque = FALSE;
                }

                // if painter doesn't allow scrollbits, neither should we
                if ((pInfo->lFlags & HTMLPAINTER_NOSCROLLBITS) &&
                    pInfo->lZOrder != HTMLPAINT_ZORDER_NONE)
                {
                    pdni->_fDisableScrollBits = TRUE;
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeScrollbarProperties
//
//  Synopsis:   Set the scrollbar related properties of a CDispNodeInfo
//
//  Arguments:  pdni - Pointer to CDispNodeInfo
//
//-----------------------------------------------------------------------------

void
 CLayout::GetDispNodeScrollbarProperties(
    CDispNodeInfo * pdni) const
{
    switch (pdni->_overflowX)
    {
    case styleOverflowNotSet:
    case styleOverflowVisible:
    case styleOverflowHidden:
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  = FALSE;
        break;

    case styleOverflowAuto:
        pdni->_sp._fHSBAllowed = TRUE;
        pdni->_sp._fHSBForced  = FALSE;
        break;

    case styleOverflowScroll:
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  = TRUE;
        break;

#if DBG==1
    default:
        AssertSz(FALSE, "Illegal value for overflow style attribute!");
        break;
#endif
    }

    switch (pdni->_overflowY)
    {
    case styleOverflowNotSet:
    case styleOverflowVisible:
    case styleOverflowHidden:
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = FALSE;
        break;

    case styleOverflowAuto:
        pdni->_sp._fVSBAllowed = TRUE;
        pdni->_sp._fVSBForced  = FALSE;
        break;

    case styleOverflowScroll:
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = TRUE;
        break;

#if DBG==1
    default:
        AssertSz(FALSE, "Illegal value for overflow style attribute!");
        break;
#endif
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNode
//
//  Synopsis:   Ensure an appropriate display node exists
//
//              For all but FRAMESET, if a container node is created, a single
//              CDispLeafNode will also be created and inserted as the first
//              child in the flow layer.
//
//  Arugments:  pdci   - Current CDocInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed/changed in a significant way
//              E_FAIL  otherwise
//
//-----------------------------------------------------------------------------
HRESULT
CLayout::EnsureDispNodeCore(
    CCalcInfo *             pci,
    BOOL                    fForce,
    const CDispNodeInfo &   dni,
    CDispNode **            ppDispNodeElement
    )
{
    Assert(pci);
    Assert(ppDispNodeElement);
    
    CDispNode *     pDispNodeElement    = *ppDispNodeElement;
    CDispNode *     pDispNodeContent    = NULL;
    BOOL            fWasRTLScroller     = FALSE;
    BOOL            fHTMLLayout         = GetOwnerMarkup()->IsHtmlLayout();
    BOOL            fCloneDispNode      = pci->_fCloneDispNode && (!pci->_fTableCalcInfo || !((CTableCalcInfo *)pci)->_fSetCellPosition);
    HRESULT         hr                  = S_OK;

    //
    //  If the wrong type of display node exists, replace it
    //
    //  A new display is needed when:
    //      a) No display node exists
    //      b) If being forced to create a display node
    //      c) A different type of border is needed (none vs. simple vs. complex)
    //      d) The type of display node does not match current inset/scrolling/user-clip settings
    //
    //  Assert for print view positioned elements pagination support
    Assert(!fCloneDispNode || pDispNodeElement);

    


    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::EnsureDispNode L(0x%x, %S) Force=%d Clone=%d CurrentDN:0x%x", this, ElementOwner()->TagName(), fForce, fCloneDispNode, pDispNodeElement ));

    if (    !pDispNodeElement
        ||  fForce
        ||  fCloneDispNode
        ||  dni.GetBorderType() != pDispNodeElement->GetBorderType()
        ||  dni.HasInset()      != pDispNodeElement->HasInset()
        ||  dni.IsScroller()    != pDispNodeElement->IsScroller()
        ||  dni.HasUserClip()   != pDispNodeElement->HasUserClip()
        ||  dni.HasExpandedClip() != pDispNodeElement->HasExpandedClipRect()
        ||  dni.HasUserTransform()!= pDispNodeElement->HasUserTransform()
        ||  dni.HasContentOrigin()!= pDispNodeElement->HasContentOrigin()

        // note: IsRTLScroller() is always equal to (IsScroller() && HasContentOrigin()),
        //       unless there is a different reason for content origin
        ||  dni.IsRTLScroller()!= (pDispNodeElement->IsScroller() &&
                                     DYNCAST(CDispScroller, pDispNodeElement)->IsRTLScroller()))
    {
        CDispNode * pDispNode;
        BOOL        fRequireContainer;
        CDispClient * pDispClient = this;

        DWORD extras = 0;

        if (dni.GetBorderType() == DISPNODEBORDER_SIMPLE)
            extras |= DISPEX_SIMPLEBORDER;
        else if (dni.GetBorderType() == DISPNODEBORDER_COMPLEX)
            extras |= DISPEX_COMPLEXBORDER;
        
        if (dni.HasInset())
            extras |= DISPEX_INSET;
            
        if (dni.HasUserClip() || dni.HasExpandedClip())
            extras |= DISPEX_USERCLIP;
        if (dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        if (dni.HasContentOrigin())
            extras |= DISPEX_CONTENTORIGIN;
        else if (pDispNodeElement && pDispNodeElement->HasContentOrigin() && pDispNodeElement->IsScroller())
            fWasRTLScroller = TRUE;

        //
        //  Create the appropriate type of display node
        //
        fRequireContainer = ((      pDispNodeElement
                                &&  pDispNodeElement->IsContainer()
                                &&  DYNCAST(CDispContainer, pDispNodeElement)->CountChildren() > 1)
                            ||  ElementOwner()->IsLinkedContentElement()
                            ||  (   fHTMLLayout
                                 && dni.IsTag(ETAG_HTML) )
                            ||  dni.IsTag(ETAG_BODY)
// TODO (lmollico): what about the ETAG_FRAME?
                            ||  dni.IsTag(ETAG_IFRAME)
                            ||  dni.IsTag(ETAG_TABLE)
                            ||  dni.IsTag(ETAG_FRAMESET)
                            ||  dni.IsTag(ETAG_TR) );

        pDispNode = (dni.IsScroller()
                        ? (CDispNode *)CDispScroller::New(pDispClient, extras)
                        :   fRequireContainer
                            ? (CDispNode *)CDispContainer::New(pDispClient,
                                                                        dni.IsTag(ETAG_TR)
                                                                          ? (extras & ~DISPEX_ANYBORDER)
                                                                          : extras)
                            : (CDispNode *)CDispLeafNode::New(pDispClient, extras));

        if (!pDispNode)
            goto Error;

        TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Created DN: 0x%x", pDispNode ));

        // If RTL, and it is a scroller, scroll bar should be on the left
        if (dni.IsScroller() && dni.IsRTLScroller())
        {
            DYNCAST(CDispScroller, pDispNode)->SetRTLScroller(TRUE);
        }
        else
            Assert(!dni.IsRTLScroller()); // we won't want left scrollbar if it ain't scroller

        // We will later set the correct values, now just lets set empty so that the flags get setup correctly
        // in the display tree.
        if (dni.HasUserClip())
            pDispNode->SetUserClip(g_Zero.rc);
        else if (dni.HasExpandedClip())
        {
            CRect erc(CRect::CRECT_EMPTY);
            pDispNode->SetExpandedClipRect(erc);
        }
        
        // since this is a new node, mark the layout as not having not been SetPosition'ed
        _fPositionSet = FALSE;

        //
        //  Mark the node as owned and possibly filtered
        //

        pDispNode->SetOwned();

        //
        //  Anchor the display node
        //  (If a display node previously existed, the new node must take its place in the tree.
        //   Otherwise, just save the pointer.)
        //

        if (pDispNodeElement)
        {
            if (fCloneDispNode)
            {
                Assert(pci->GetLayoutContext());
                AddDispNodeToArray(pDispNode);
            }
            else
            {
                TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Replacing old DN: 0x%x", pDispNodeElement ));

                CDispNode *pdn =  *ppDispNodeElement;
                Assert(pdn);
                Assert(pdn == pDispNodeElement);

                // if we're replacing a scroller with another scroller, copy the
                // scroll offset
                if (dni.IsScroller() && pDispNodeElement->IsScroller())
                {
                    CDispScroller* pOldScroller = DYNCAST(CDispScroller, pDispNodeElement);
                    CDispScroller* pNewScroller = DYNCAST(CDispScroller, pDispNode);
                    pNewScroller->CopyScrollOffset(pOldScroller);
                }

                DetachScrollbarController(pDispNodeElement);

                pDispNode->SetLayerTypeSame(pDispNodeElement);
                pDispNode->ReplaceNode(pDispNodeElement);

                if (pdn == pDispNodeElement)
                {
                    *ppDispNodeElement = pDispNode;
                }
            }
        }
        else
        {
            Assert(!*ppDispNodeElement);
            *ppDispNodeElement = pDispNode;
        }

        pDispNodeElement = pDispNode;

        hr = S_FALSE;
    }

    //
    //  The display node is the right type, but its borders may have changed
    //

    else if (pDispNodeElement->HasBorder())
    {
        CRect   rcBordersOld;
        CRect   rcBordersNew;

        pDispNodeElement->GetBorderWidths(&rcBordersOld);
        dni.GetBorderWidths(&rcBordersNew);

        if (rcBordersOld != rcBordersNew)
        {
            hr = S_FALSE;
        }
    }

    //
    //  Ensure a single content node if necessary
    //  NOTE: This routine never removes content nodes
    //

    if (    pDispNodeElement->IsContainer()
        &&  !dni.IsTag(ETAG_FRAMESET)
        &&  !dni.IsTag(ETAG_HTML)
        &&  !dni.IsTag(ETAG_TR))
    {
        CDispNode * pDispNodeCurrent;
        CDispClient * pDispClient = this;

        pDispNodeCurrent =
        pDispNodeContent = GetFirstContentDispNode();

        if (    !pDispNodeContent
            ||  fForce
            ||  fCloneDispNode
            ||  dni.HasContentOrigin() != pDispNodeContent->HasContentOrigin()
            ||  dni.HasExpandedClip()  != pDispNodeContent->HasExpandedClipRect()
           )
        {
            DWORD dwExtras = 0;
            CSize sizeMove(0,0);
            if (dni.HasContentOrigin())
                dwExtras |= DISPEX_CONTENTORIGIN;
            if (dni.HasExpandedClip())
                dwExtras |= DISPEX_USERCLIP;

            else if (pDispNodeCurrent && pDispNodeCurrent->HasContentOrigin())
            {
                // When replacing RTL node with LTR node, we want to
                // adjust it position according to RTL overflow
                // (usually that means up moving it to 0,0)
                // Note that the LTR->RTL case is handled by SizeRTLDispNode()
                sizeMove = pDispNodeCurrent->GetContentOrigin();
            }

            pDispNodeContent = CDispLeafNode::New(pDispClient, dwExtras);

            if (!pDispNodeContent)
                goto Error;

            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Created content DN: 0x%x for container", pDispNodeContent ));

            pDispNodeContent->SetOwned(FALSE);
            pDispNodeContent->SetLayerFlow();

            if (dni.HasExpandedClip())
            {
                CRect erc(CRect::CRECT_EMPTY);
                pDispNodeContent->SetExpandedClipRect(erc);
            }
            
            Assert((CPoint &)pDispNodeContent->GetPosition() == (CPoint &)g_Zero.pt);

            if (    !pDispNodeCurrent
                ||  fCloneDispNode )
            {
                DYNCAST(CDispParentNode, pDispNodeElement)->InsertChildInFlow(pDispNodeContent);
            }
            else
            {
                Assert(!pDispNodeCurrent->IsDrawnExternally());
                pDispNodeContent->ReplaceNode(pDispNodeCurrent);
            }

            if (!sizeMove.IsZero())
            {
                pDispNodeContent->SetPosition(pDispNodeContent->GetPosition() + sizeMove);
            }

            Assert(pDispNodeElement->GetFirstFlowChildNode() == pDispNodeContent);

            hr = S_FALSE;
        }
    }

    //
    //  Set the display node properties
    //  NOTE: These changes do not require notifying the caller since they do not affect
    //        the size or position of the display node
    //

    EnsureDispNodeLayer(dni, pDispNodeElement);
    EnsureDispNodeBackground(dni, pDispNodeElement);
    EnsureDispNodeVisibility(dni.GetVisibility(), ElementOwner(), pDispNodeElement);

    EnsureDispNodeAffectsScrollBounds( (!ElementOwner()->IsRelative(LC_TO_FC(LayoutContext()))
                                                &&  !ElementOwner()->IsInheritingRelativeness(LC_TO_FC(LayoutContext())))
                                           ||  IsEditable(TRUE),
                                       pDispNodeElement);

    if (dni.IsScroller())
    {
        EnsureDispNodeScrollbars(pci, dni, pDispNodeElement);

        BOOL fClipX = dni._overflowX != styleOverflowVisible && dni._overflowX != styleOverflowNotSet;
        BOOL fClipY = dni._overflowY != styleOverflowVisible && dni._overflowY != styleOverflowNotSet;

        // FRAME, IFRAME, and BODY must clip
        if (dni._etag == ETAG_BODY
            ||  dni._etag == ETAG_FRAMESET
            ||  dni._etag == ETAG_FRAME
            ||  dni._etag == ETAG_IFRAME)
        {
            // NOTE: This code is trying to honor styleOverflowVisible on BODY, FRAME, etc.
            // It may be that we want these elements to clip *no matter what*.  If so,
            // just set fClipX/fClipY to TRUE unconditionally.
            if (dni._overflowX == styleOverflowNotSet)
                fClipX = TRUE;
            if (dni._overflowY == styleOverflowNotSet)
                fClipY = TRUE;
        }

        CDispScroller* pDispScroller = CDispScroller::Cast(pDispNodeElement);
        pDispScroller->SetClipX(fClipX);
        pDispScroller->SetClipY(fClipY);

        if (fWasRTLScroller && !dni.IsRTLScroller())
        {
            // direction change RTL->LTR: reset scrollbars
            // LTR->RTL is handled elsewhere (it is already a special case for everyone).
            pDispScroller->SetScrollOffset(CSize(0,0), FALSE);
        }

        pDispNodeElement->SetDisableScrollBits(dni._fDisableScrollBits);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::EnsureDispNode L(0x%x, %S) Force=%d", this, ElementOwner()->TagName(), fForce ));
    return hr;

Error:
    if (pDispNodeContent)
    {
        pDispNodeContent->Destroy();
    }

    if (pDispNodeElement)
    {
        pDispNodeElement->Destroy();
    }

    *ppDispNodeElement = NULL;

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::EnsureDispNode L(0x%x, %S) ERROR - FAILURE", this, ElementOwner()->TagName() ));
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeLayer
//
//  Synopsis:   Set the layer type of the container display node
//
//              NOTE: If a filter node exists, it is given the same layer type
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeLayer(
    DISPNODELAYER           layer,
    CDispNode *             pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->GetLayerType() != layer)
    {
        GetView()->ExtractDispNode(pDispNode);
        pDispNode->SetLayerType(layer);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeBackground
//
//  Synopsis:   Set the background characteristics of the container display node
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeBackground(
    const CDispNodeInfo &   dni,
    CDispNode *             pDispNode)
{
    if (!pDispNode)
    {
        if (Tag() == ETAG_TABLE)
        {   // NOTE: table might have a caption, and we don't want to set background image on the main
            // display node of the table that contains the caption display node. (bug #65617)
            // therefore we ensure backround only on the table's GRID node.
            CTableLayoutBlock *pTableLayout = DYNCAST(CTableLayoutBlock, this);
            pDispNode = pTableLayout->GetTableOuterDispNode();
        }
        else
        {
            pDispNode = GetElementDispNode();
        }
    }

    if (pDispNode)
    {
        // Suppress backgrounds when printing unless explicitly asked for.
        BOOL fPaintBackground = dni.HasBackground()
                                && (ElementOwner()->GetMarkupPtr()->PaintBackground()
                                    || Tag() == ETAG_BUTTON
                                    ||  (    Tag() == ETAG_INPUT
                                         &&  (   DYNCAST(CInput, ElementOwner())->IsButton()
                                              || ElementOwner()->GetTheme( DYNCAST(CInput, ElementOwner())->GetInputThemeClsId() ))));

        // Fixed backgrounds imply backgrounds.
        Assert(!dni.HasFixedBackground() || dni.HasBackground());

        pDispNode->SetBackground(fPaintBackground);

        if (pDispNode->IsScroller())
        {
            pDispNode->SetFixedBackground(dni.HasFixedBackground() && fPaintBackground);
        }
        pDispNode->SetOpaque(dni.IsOpaque());
    }
}

//+----------------------------------------------------------------------------
//
// Synposis:    Given a dispnode container, create a child flow node if one
//              does not exist.
//
//-----------------------------------------------------------------------------
CDispNode *
EnsureContentNode(CDispNode * pDispNode)
{
    Assert(pDispNode->IsContainer());

    CDispContainer * pDispContainer = DYNCAST(CDispContainer, pDispNode);
    CDispNode      * pDispContent = pDispContainer->GetFirstFlowChildNode();

// NOTE: srinib (what if the first child node is not a flow node
// but a layout node in flow layer).
    if(!pDispContent)
    {
        CSize size = pDispContainer->GetSize();

        DWORD dwContentExtras = 0;
        if (pDispContainer->HasContentOrigin())
        {
            dwContentExtras |= DISPEX_CONTENTORIGIN;
        }

        pDispContent = CDispLeafNode::New(pDispContainer->GetDispClient(), dwContentExtras);

        if (!pDispContent)
            goto Error;

        pDispContent->SetOwned(FALSE);
        pDispContent->SetLayerFlow();
        pDispContent->SetSize(size, NULL, FALSE);
        if (!pDispNode->IsScroller())
        {
            pDispContent->SetAffectsScrollBounds(pDispNode->AffectsScrollBounds());
        }
        pDispContent->SetVisible(pDispContainer->IsVisible());

        // transfer content origin from the container
        if (pDispContainer->HasContentOrigin())
        {
            pDispContent->SetContentOrigin(pDispContainer->GetContentOrigin(),
                                           pDispContainer->GetContentOffsetRTL());

            // note that SetContentOrigin calculates origin based on size and right offset,
            // so we should us the content's oringin for position rather than cash container's
            // (even though they will probably be always same at this point).
            pDispContent->SetPosition(pDispContent->GetPosition() - pDispContent->GetContentOrigin());
        }

        pDispContainer->InsertChildInFlow(pDispContent);

        Assert(pDispContainer->GetFirstFlowChildNode() == pDispContent);
    }

Error:
    return pDispContent;
}

//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeIsContainer
//
//  Synopsis:   Ensure that the display node is a container display node
//              NOTE: This routine is not a replacement for EnsureDispNode and
//                    only works after calling EnsureDispNode.
//
//              For all layouts but FRAMESETs, if a container node is created, a
//              single CDispLeafNode will also be created and inserted as the
//              first child in the flow layer.
//
//  Returns:    Pointer to CDispContainer if successful, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispContainer *
CLayout::EnsureDispNodeIsContainer( CElement *  pElement)
{
    Assert(   !pElement
           || pElement->GetUpdatedNearestLayout(LayoutContext()) == this);
    Assert( !pElement
        ||  pElement == ElementOwner()
        ||  !pElement->ShouldHaveLayout());

    CDispNode *         pDispNodeOld = GetElementDispNode(pElement);
    CDispContainer *    pDispNodeNew = NULL;
    CRect               rc;

    if (!pDispNodeOld)
        goto Cleanup;

    if (pDispNodeOld->IsContainer())
    {
        pDispNodeNew = CDispContainer::Cast(pDispNodeOld);
        goto Cleanup;
    }

    //
    //  Create a basic container using the properties of the current node as a guide
    //

    Assert(pDispNodeOld->IsLeafNode());
    Assert( (   pElement
            &&  pElement != ElementOwner())
        ||  !GetFirstContentDispNode());

    pDispNodeNew = CDispContainer::New(CDispLeafNode::Cast(pDispNodeOld));

    if (!pDispNodeNew)
        goto Cleanup;

    //
    //  Set the background flag on display nodes for relatively positioned text
    //  (Since text that has a background is difficult to detect, the code always
    //   assumes a background exists and lets the subsequent calls to draw the
    //   background handle it)
    //

    if (    pElement
        &&  pElement != ElementOwner())
    {
        Assert( !pElement->ShouldHaveLayout()
            &&  pElement->IsRelative());
        pDispNodeNew->SetBackground(TRUE);
    }

    //
    //  Replace the existing node
    //

    pDispNodeNew->ReplaceNode(pDispNodeOld);
    SetElementDispNode(pElement, pDispNodeNew );

    //
    //  Ensure a single flow node if necessary
    //

    if (ElementOwner()->Tag() != ETAG_FRAMESET)
    {
        if(!EnsureContentNode(pDispNodeNew))
            goto Cleanup;
    }

Cleanup:
    return pDispNodeNew;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeScrollbars
//
//  Synopsis:   Set the scroller properties of a display node
//              NOTE: The call is ignored if CDispNode is not a CDispScroller
//
//  Arguments:  sp        - CScrollbarProperties object
//              pDispNode - CDispNode to set (default to the layout display node)
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureDispNodeScrollbars(
    CDocInfo *                      pdci,
    const CScrollbarProperties &    sp,
    CDispNode *                     pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        Assert(!sp._fHSBForced || sp._fHSBAllowed);
        Assert(!sp._fVSBForced || sp._fVSBAllowed);

        long cySB = pdci->DeviceFromHimetricY(sp._fHSBAllowed ? g_sizelScrollbar.cy : 0);
        long cxSB = pdci->DeviceFromHimetricX(sp._fVSBAllowed ? g_sizelScrollbar.cx : 0);

        DYNCAST(CDispScroller, pDispNode)->SetHorizontalScrollbarHeight(cySB, sp._fHSBForced);
        DYNCAST(CDispScroller, pDispNode)->SetVerticalScrollbarWidth(cxSB, sp._fVSBForced);
    }

#if DBG==1
    else if (pDispNode)
    {
        Assert(!sp._fHSBAllowed);
        Assert(!sp._fVSBAllowed);
        Assert(!sp._fHSBForced);
        Assert(!sp._fVSBForced);
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeVisibility
//
//  Synopsis:   Set the visibility mode on display node corresponding to
//              this layout
//
//              NOTE: If a filter node exists, it is given the same visibility mode
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeVisibility(CElement *pElement, CDispNode * pDispNode)
{
    if (!pElement)
        pElement = ElementOwner();

    if (pElement && pElement->GetFirstBranch())
    {
        VISIBILITYMODE vm;

        vm = VisibilityModeFromStyle(pElement->GetFirstBranch()->GetCascadedvisibility(LC_TO_FC(LayoutContext())));

        EnsureDispNodeVisibility( vm, pElement, pDispNode);
    }
}



void
CLayout::EnsureDispNodeVisibility(
    VISIBILITYMODE  visibilityMode,
    CElement *      pElement,
    CDispNode *     pDispNode)
{
    Assert(pElement);

    if (!pDispNode)
        pDispNode = GetElementDispNode(pElement);

    if (pDispNode)
    {
        CTreeNode*  pNode = pElement->GetFirstBranch();

        Verify(OpenView());

        if (visibilityMode == VISIBILITYMODE_INHERIT)
        {
            visibilityMode = pNode->GetCharFormat(LC_TO_FC(LayoutContext()))->_fVisibilityHidden
                                    ? VISIBILITYMODE_INVISIBLE
                                    : VISIBILITYMODE_VISIBLE;
        }

        if ( (visibilityMode == VISIBILITYMODE_INVISIBLE) &&
             (pNode->IsParentEditable() && !pElement->GetMarkup()->IsRespectVisibilityInDesign() ) )
        {
            visibilityMode = VISIBILITYMODE_VISIBLE;
        }

        Assert(visibilityMode != VISIBILITYMODE_INHERIT);
        pDispNode->SetVisible(visibilityMode == VISIBILITYMODE_VISIBLE);

        EnsureContentVisibility(pDispNode, visibilityMode == VISIBILITYMODE_VISIBLE);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureContentVisibility
//
//  Synopsis:   Ensure the visibility of the content node is correct
//
//  Arguments:  pDispNode - Parent CDispNode of the content node
//              fVisible  - TRUE to make visible, FALSE otherwise
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureContentVisibility(
    CDispNode * pDispNode,
    BOOL        fVisible)
{
    CDispNode * pContentNode = GetFirstContentDispNode(pDispNode);

    if (pContentNode)
    {
        pContentNode->SetVisible(fVisible);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeAffectsScrollBounds
//
//  Synopsis:   Ensure the "affects scroll bounds" flag of the disp node is correct
//
//  Arguments:  pDispNode - Parent CDispNode of the content node
//              fVisible  - TRUE to make visible, FALSE otherwise
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureDispNodeAffectsScrollBounds(
    BOOL        fAffectsScrollBounds,
    CDispNode * pDispNode)
{
    CDispNode * pContentNode = GetFirstContentDispNode(pDispNode);

    pDispNode->SetAffectsScrollBounds(fAffectsScrollBounds);

    if (pContentNode)
    {
        pContentNode->SetAffectsScrollBounds(
                            pDispNode->IsScroller() ? TRUE : fAffectsScrollBounds);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     ExtractDispNodes
//
//  Synopsis:   Remove all children in the range from the tree
//
//  Arguments:  pDispNodeStart   - First node to adjust, NULL starts with first child
//              pDispNodeEnd     - Last node to adjust, NULL ends with last child
//              fRestrictToLayer - Restrict search to starting layer (ignore if pDispNodeStart is NULL)
//
//-----------------------------------------------------------------------------

void
CLayout::ExtractDispNodes(
    CDispNode * pDispNodeStart,
    CDispNode * pDispNodeEnd,
    BOOL        fRestrictToLayer)
{
    CDispNode * pDispNode = GetElementDispNode();

    //
    //  If there is nothing to do, exit
    //

    if (!pDispNode)
        goto Cleanup;

    if (!pDispNode->IsContainer())
        goto Cleanup;

    //
    //  Determine the start node (if none was supplied)
    //

    if (!pDispNodeStart)
    {
        pDispNodeStart   = pDispNode->GetFirstChildNode();
        fRestrictToLayer = FALSE;
    }

    if (!pDispNodeStart)
        goto Cleanup;

    //
    //  Find the end node (if none was supplied)
    //

    if (!pDispNodeEnd)
    {
        if (!fRestrictToLayer)
        {
            pDispNodeEnd = pDispNode->GetLastChildNode();
        }
        else
        {
            pDispNodeEnd = pDispNodeStart->GetLastInSameLayer();
        }
    }
    Assert(pDispNodeEnd);

    //
    //  Extract the nodes
    //

    GetView()->ExtractDispNodes(pDispNodeStart, pDispNodeEnd);

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetPositionAware
//
//  Synopsis:   Set/clear the position aware flag on the display node
//
//              NOTE: If a filter node exists, it is given the same position awareness
//
//  Arguments:  fPositionAware - Value to set
//              pDispNode      - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SetPositionAware(
    BOOL        fPositionAware,
    CDispNode * pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    pDispNode->SetPositionAware(fPositionAware);
}


//+----------------------------------------------------------------------------
//
//  Member:     SetInsertionAware
//
//  Synopsis:   Set/clear the insertion aware flag on the display node
//
//              NOTE: If a filter node exists, it is given the same position awareness
//
//  Arguments:  fInsertionAware - Value to set
//              pDispNode       - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SetInsertionAware(
    BOOL        fInsertionAware,
    CDispNode * pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    pDispNode->SetInsertionAware(fInsertionAware);
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNode
//
//  Synopsis:   Adjust the size of the container display node
//
//  Arugments:  pci            - Current CCalcInfo
//              size           - The width/height of the entire layout
//              fInvalidateAll - If TRUE, force a full invalidation
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNode(
    CCalcInfo *     pci,
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    CDoc *          pDoc                = NULL;
    CElement *      pElement            = NULL;
    CDispNode *     pDispNodeElement    = NULL;
    CRect *         prcpMapped          = NULL;
    CRect           rcpMapped;
    CSize           sizeOriginal;
    ELEMENT_TAG     etag;
    DISPNODEBORDER  dnb;
    CBorderInfo     bi;

    Assert(pci);

    if (!_pDispNode)
        goto Cleanup;

    pDispNodeElement = GetElementDispNode();

    //
    //  Set the border size (if any)
    //  NOTE: These are set before the size because a change in border widths
    //        forces a full invalidation of the display node. If a full
    //        invalidation is necessary, less code is executed when the
    //        display node's size is set.
    //

    pDoc           = Doc();
    pElement       = ElementOwner();
    etag           = pElement->Tag();
    dnb            = pDispNodeElement->GetBorderType();
    fInvalidateAll = !pDispNodeElement->IsContainer();

    sizeOriginal = pDispNodeElement->GetSize();

    if (dnb != DISPNODEBORDER_NONE)
    {
        CRect       rcBorderWidths;
        CRect       rc;

        pDispNodeElement->GetBorderWidths(&rcBorderWidths);

        pElement->GetBorderInfo(pci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

        rc.left   = bi.aiWidths[SIDE_LEFT];
        rc.top    = bi.aiWidths[SIDE_TOP];
        rc.right  = bi.aiWidths[SIDE_RIGHT];
        rc.bottom = bi.aiWidths[SIDE_BOTTOM];

        if (rc != rcBorderWidths)
        {
            if (dnb == DISPNODEBORDER_SIMPLE)
            {
                pDispNodeElement->SetBorderWidths(rc.top);
            }
            else
            {
                pDispNodeElement->SetBorderWidths(rc);
            }

            fInvalidateAll = TRUE;
        }
    }

    //
    //  If there are any behaviors that want to map the size, find out the details
    //  now so we can tell the disp node.
    //

    if (DelegateMapSize(size, &rcpMapped, pci))
    {
        prcpMapped = &rcpMapped;
    }

    //
    //  Determine if a full invalidation is necessary
    //  (A full invalidation is necessary only when there is a fixed
    //   background located at a percentage of the width/height)
    //

    if (    !fInvalidateAll
        &&  pDispNodeElement->HasBackground())
    {
        const CFancyFormat *    pFF = pElement->GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));

        // Logical/physical does not matter since we check both X and Y here.
        fInvalidateAll =    pFF->_lImgCtxCookie
                    &&  (   pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT
                        ||  pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
    }

    //
    //  Size the display node
    //  NOTE: Set only the width/height since top/left are managed
    //        by the layout engine which inserts this node into the
    //        display tree.
    //

    pDispNodeElement->SetSize(size, prcpMapped, fInvalidateAll);

    // Note: we are not dealing with HasContentOrigin here because it is handled
    // in CFlowLayout/CHtmlLayout, the only layouts using a content origin.

    Assert(     IsFlowLayout()
            ||  ElementOwner()->Tag() == ETAG_HTML
            ||  !pDispNodeElement->HasContentOrigin() );

    //
    //  If the display node has an explicit user transformation, set details
    //

    if (pDispNodeElement->HasUserTransform())
    {
        // _rctBounds is updated as part of user transform calculations
        SizeDispNodeUserTransform(pci, size, pDispNodeElement);
    }

    //
    //  If the display node has an explicit user clip, size it
    //

    if (pDispNodeElement->HasUserClip())
    {
        SizeDispNodeUserClip(pci, size, pDispNodeElement);
    }


    //  Any borders that have spacing dependant on their length need to be invalidated here.
    //  Currently, only marker edges (dotted/dashed) are dependant on their length (for spacing).
    //  e.g.  If the element increases in width, the top and bottom borders need to be invalidated.
    //  Use COORDSYS_BOX because it includes borders & scrollbars.

    if (    !fInvalidateAll
        &&  dnb != DISPNODEBORDER_NONE )
    {
        if (sizeOriginal.cx != size.cx)
        {
            if  ( bi.IsMarkerEdge(SIDE_TOP) )
                Invalidate(CRect(0, 0, size.cx, bi.aiWidths[SIDE_TOP]), COORDSYS_BOX);
            if  ( bi.IsMarkerEdge(SIDE_BOTTOM) )
                Invalidate(CRect(0, size.cy - bi.aiWidths[SIDE_BOTTOM], size.cx, size.cy), COORDSYS_BOX);
        }

        if (sizeOriginal.cy != size.cy)
        {
            if  ( bi.IsMarkerEdge(SIDE_LEFT) )
                Invalidate(CRect(0, 0, bi.aiWidths[SIDE_LEFT], size.cy), COORDSYS_BOX);
            if  ( bi.IsMarkerEdge(SIDE_RIGHT) )
                Invalidate(CRect(size.cx - bi.aiWidths[SIDE_RIGHT], 0, size.cx, size.cy), COORDSYS_BOX);
        }
    }

    //
    //  Fire related events
    //

    if (    (CSize &)size != sizeOriginal
        &&  !IsDisplayNone()
        &&  pDoc->_state >= OS_INPLACE
        &&  pElement->GetWindowedMarkupContext()->HasWindow()
        &&  pElement->GetWindowedMarkupContext()->Window()->_fFiredOnLoad)
    {
        bool skipAddEvent =
            pElement->HasLayoutAry() &&
            HasLayoutContext() &&
            LayoutContext()->GetMedia() == mediaTypePrint;
        if (!skipAddEvent)
            GetView()->AddEventTask(pElement, DISPID_EVMETH_ONRESIZE);
    }

    // TODO (IE6 Bug 13574) (michaelw) should the code below be moved to happen at the
    //                   same time as the above onresize?

    if (pElement->ShouldFireEvents())
    {
        if (size.cx != sizeOriginal.cx)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETWIDTH);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTWIDTH);
        }

        if (size.cy != sizeOriginal.cy)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETHEIGHT);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTHEIGHT);
        }
    }

Cleanup:

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DelegateMapSize (helper)
//
//  Synopsis:   Collect information from peers that want to map the size
//
//  Arguments:  sizeBasic       [in] original size
//              prcpMapped      [out] accumulated mapped size
//
//  Returns:    TRUE            if one or more peers request a non-trivial mapping
//              FALSE           otherwise
//
//-----------------------------------------------------------------------------
BOOL
CLayout::DelegateMapSize(CSize                      sizeBasic, 
                         CRect *                    prcpMapped, 
                         const CCalcInfo * const    pci)
{
    CPeerHolder::CPeerHolderIterator    iter;
    BOOL                                fMappingRequested   = FALSE;
    bool                                fFilterPrint        = false;
    bool                                fFilterHighRes      = false;
    CElement *                          pElemOwner          = ElementOwner();
    CRect                               rcpMappedThis       = g_Zero.rc; // keep compiler happy
    CRect                               rcOriginal(sizeBasic);

    Assert(prcpMapped != NULL);
    Assert(pci != NULL);

    // 2001/03/28 mcalkins:
    // Instead of HasFilterPeer, we really want to know if this element has a 
    // peer that has request to draw onto a DirectDraw surface.

    if (HasFilterPeer(GetElementDispNode()))
    {
        // If we're a filter and we're printing, set the fFilterPrint flag.
        // If we're a filter and we're rendering to a high resolution display,
        // set the fFilterHighRes flag.
        
        // Checking to see if the mediaTypePrint flag is set is the definitive way
        // to see if we're measuring in high resolution.  IsPrintMedia() is not.

        if (   const_cast<CCalcInfo *>(pci)->GetLayoutContext()
            && (const_cast<CCalcInfo *>(pci)->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
            && (const_cast<CCalcInfo *>(pci)->GetLayoutContext()->GetMedia() & mediaTypePrint))
        {
            fFilterPrint = true;
        }
        else if (g_uiDisplay.IsDeviceScaling())
        {
            fFilterHighRes = true;
        }
    }

    // If we're printing or print previewing and this element is filtered we
    // need to convert the size to display coordinates, ask the filter if it
    // wants to change the size, and if it does then convert the size back to
    // virtual coordinates and save them.  

    if (fFilterPrint)
    {
        pci->TargetFromDevice(sizeBasic, g_uiDisplay);

        rcOriginal.SetSize(sizeBasic);
    }
    else if (fFilterHighRes)
    {
        g_uiDisplay.DocPixelsFromDevice(sizeBasic, sizeBasic);

        rcOriginal.SetSize(sizeBasic);
    }

    // Loop through peers holders to map size.

    for (iter.Start(pElemOwner->GetPeerHolder());
         !iter.IsEnd();
         iter.Step())
    {
        if (   iter.PH()->IsLayoutPeer()
            && iter.PH()->TestLayoutFlags(BEHAVIORLAYOUTINFO_MAPSIZE))
        {
            // If the call to MapSize succeeds and the mapped rect is different
            // than the original rect then save the new mapped rect.

            if (   (S_OK == iter.PH()->MapSize(&sizeBasic, &rcpMappedThis)) 
                     && (rcpMappedThis != rcOriginal))
            {
                // If we did a coordinate system change for a filter, we need to
                // undo it to save the mapped size in virtual coordinates.

                if (fFilterPrint || fFilterHighRes)
                {
                    Assert((0 == rcpMappedThis.top) && (0 == rcpMappedThis.left));

                    CSize sizeTemp = rcpMappedThis.Size();

                    if (fFilterPrint)
                    {
                        g_uiDisplay.TargetFromDevice(sizeTemp, *(pci->GetUnitInfo()));
                    }
                    else
                    {
                        g_uiDisplay.DeviceFromDocPixels(sizeTemp, sizeTemp);
                    }

                    rcpMappedThis.SetSize(sizeTemp);
                }

                // Save the mapped size.

                if (!fMappingRequested)
                {
                    fMappingRequested   = TRUE;
                    *prcpMapped         = rcpMappedThis;
                }
                else
                {
                    prcpMapped->Union(rcpMappedThis);
                }
            }
        }
    }

    // for top-level layouts, don't use the information.  [We still have to
    // call MapSize, so that filters get initialized properly.]

    if (   (pElemOwner->Tag() == ETAG_BODY)
        || (pElemOwner->Tag() == ETAG_FRAMESET)
        || (pElemOwner->Tag() == ETAG_HTML && GetOwnerMarkup()->IsHtmlLayout()))
    {
        fMappingRequested = FALSE;
    }

    return fMappingRequested;
}


//+----------------------------------------------------------------------------
//
//  Member:     HasMapSizePeer (helper)
//
//  Synopsis:   Do I have a peer that asks for MapSize calls?
//
//  Arguments:  none
//
//  Returns:    TRUE            if yes
//              FALSE           otherwise
//
//-----------------------------------------------------------------------------
BOOL
CLayout::HasMapSizePeer() const
{
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(ElementOwner()->GetPeerHolder());
         !iter.IsEnd();
         iter.Step())
    {
        if (   iter.PH()->IsLayoutPeer()
            && iter.PH()->TestLayoutFlags(BEHAVIORLAYOUTINFO_MAPSIZE))
        {
            return TRUE;
        }
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Member:     OnResize
//
//  Synopsis:   Informs behaviors of size changes
//
//-----------------------------------------------------------------------------
void CLayout::OnResize(SIZE size, CDispNode *pDispNode)
{
    // If the notification doesn't come from my principal disp node, fuhgeddaboudit.
    // (This is probably what Artak was talking about in the next comment.
    if (GetElementDispNode() != pDispNode)
        return;

    // If the layout is on a frame inside a frameset I am seeing
    // two calls to this function, one with the right size and the
    // with he size of the whole window, still on the same layout
    // It does not matter for page transition, because the filter
    // behaviors ignores the onResize, but could be a problem for other things
    CElement * pElem = ElementOwner();
    if (pElem->HasPeerHolder())
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pElem->GetPeerHolder()) ; !iter.IsEnd(); iter.Step())
        {
            CPeerHolder *pPH = iter.PH();
            if (pPH && pPH->IsRenderPeer())
            {
                pPH->OnResize(size);
            }
        }
    }

    if (pElem->Tag() != ETAG_BODY && pElem->Tag() != ETAG_FRAMESET && pElem->Tag() != ETAG_HTML)
        return;

    // block to grab the document
    {
        CDocument *pDocument = pElem->GetMarkupPtr()->Document();
        if(!pDocument || !pDocument->HasPageTransitions())
            return;

        // Page transition peers have to be redirected
        CPageTransitionInfo * pPgTransInfo = pDocument->GetPageTransitionInfo();
        pElem = pPgTransInfo->GetTransitionToMarkup()->Root();
    }

    Assert(pElem->HasPeerHolder());
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(pElem->GetPeerHolder()) ; !iter.IsEnd(); iter.Step())
    {
        CPeerHolder *pPH = iter.PH();

        if (pPH  && pPH->IsRenderPeer() )
        {
            pPH->OnResize(size);
        }
    }

}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeInsets
//
//  Synopsis:   Size the insets of the display node
//
//  Arguments:  va        - CSS verticalAlign value
//              cy        - Content height or baseline delta
//              pDispNode - CDispNode to set (defaults to the layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeInsets(
    styleVerticalAlign  va,
    long                cy,
    CDispNode *         pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->HasInset())
    {
        CSize sizeInset;
        long  cyHeight  = pDispNode->GetSize().cy;

        Assert(  (va == styleVerticalAlignBaseline || cy >= 0)
               || (va ==styleVerticalAlignMiddle && cy != 0));
        
        // NOTE: Assert removed for NT5 B3 (bug #75434)
        // IE6: Reenable for IE6+
        // AND DISABLE FOR NETDOCS!
        // Assert(cy <= cyHeight);

        switch (va)
        {
        case styleVerticalAlignTop:
            sizeInset = g_Zero.size;
            break;

        case styleVerticalAlignMiddle:
            sizeInset.cx = 0;
            sizeInset.cy = (cyHeight - cy) / 2;
            break;

        case styleVerticalAlignBottom:
            sizeInset.cx = 0;
            sizeInset.cy = cyHeight - cy;
            break;

        case styleVerticalAlignBaseline:
            sizeInset.cx = 0;
            sizeInset.cy = cy;
            break;
        }

        pDispNode->SetInset(sizeInset);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeUserClip
//
//  Synopsis:   Calculate and set the user clip based on user settings
//              The default is infinite (represented by LONG_MIN/MAX) and all values
//              are relative to the origin (0,0)
//
//  Arguments:  pdci      - Current CDocInfo
//              size      - Current width/height
//              pDispNode - Display node on which to set the user clip (defaults to the layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeUserClip(
    const CDocInfo *pdci,
    const CSize &   size,
    CDispNode *     pDispNode)
{
    CElement *  pElement  = ElementOwner();
    BOOL        fVerticalLayoutFlow = pElement->HasVerticalLayoutFlow();
    CTreeNode * pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat *pFF = pTreeNode->GetFancyFormat();
    BOOL        fWritingModeUsed = pTreeNode->GetCharFormat()->_fWritingModeUsed;
    CRect       rc;
    CUnitValue  uv;

    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (!pDispNode)
        goto Cleanup;

    Assert(pdci);
    Assert(pTreeNode);
    Assert(pDispNode->HasUserClip());

    rc.SetRect(LONG_MIN, LONG_MIN, LONG_MAX, LONG_MAX);

    uv = pFF->GetLogicalClip(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.left = uv.XGetPixelValue(pdci, size.cx, pTreeNode->GetFontHeightInTwips(&uv));
    }

    uv = pFF->GetLogicalClip(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.right = uv.XGetPixelValue(pdci, size.cx, pTreeNode->GetFontHeightInTwips(&uv));
    }

    uv = pFF->GetLogicalClip(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.top = uv.XGetPixelValue(pdci, size.cy, pTreeNode->GetFontHeightInTwips(&uv));
        if (fVerticalLayoutFlow)
        {
            CSize sz = pDispNode->GetSize();
            rc.top = sz.cy - rc.top;
        }
    }

    uv = pFF->GetLogicalClip(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.bottom = uv.XGetPixelValue(pdci, size.cy, pTreeNode->GetFontHeightInTwips(&uv));
        if (fVerticalLayoutFlow)
        {
            CSize sz = pDispNode->GetSize();
            rc.bottom = sz.cy - rc.bottom;
        }
    }

    pDispNode->SetUserClip(rc);

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeUserTransform
//
//  Synopsis:   Calculate and set custom transformation if anything other than
//              offset needs to be applied to this node
//
//  Arguments:  pci       - Current CCalcInfo
//              sizep     - Current width/height (pre-transform)
//              pDispNode - Display node on which to set the stuff
//
//  Returns:    size of transformed bounds
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeUserTransform(
    CCalcInfo *     pci,
    const CSize &   sizep,
    CDispNode *     pDispNode) const
{
    // Check that we don't do unnecessary work
    Assert(pDispNode->HasUserTransform());

    CDispTransform  transform;
    BOOL            fResolutionChange;
    CSize           sizetBound;
    CRect           rcp(sizep);

    // Get transform info, rotation center, if any, will be the center of rc.
    GetElementTransform(&rcp, &transform, &fResolutionChange);

    transform.GetWorldTransform()->GetBoundingSizeAfterTransform(&rcp, &sizetBound);

    // Update element size.
    pDispNode->SetUserTransform(&transform);

    // Set resolution if changing
    if (fResolutionChange)
    {
        CExtraTransform *pExtraTransform = pDispNode->GetExtraTransform();
        pExtraTransform->_fResolutionChange = TRUE;
        pExtraTransform->_pUnitInfo = pci->GetUnitInfo();
        
        // verify that the resolution in pci matches the defined resolution of this element
        Assert(DefinedLayoutContext());
        Assert(ElementOwner()->GetFirstBranch()->GetFancyFormat()->GetMediaReference() != mediaTypeNotSet);
        Assert(ElementOwner()->GetFirstBranch()->GetFancyFormat()->GetMediaReference() == DefinedLayoutContext()->GetMedia());
        Assert((CSize) pci->GetResolution() == GetView()->GetMeasuringDevice(DefinedLayoutContext()->GetMedia())->GetResolution());
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeContentDispNode
//
//  Synopsis:   Adjust the size of the content node (if it exists)
//              NOTE: Unlike SizeDispNode above, this routine assumes that
//                    the passed size is correct and uses it unmodified
//
//  Arugments:  size           - The width/height of the content node
//              fInvalidateAll - If TRUE, force a full invalidation
//
//-----------------------------------------------------------------------------
void
CLayout::SizeContentDispNode(
    const SIZE &    size,
    BOOL            fInvalidateAll )
{
    CDispLeafNode * pDispContent;
    CSize           sizeContent;

    pDispContent = GetFirstContentDispNode();
    sizeContent  = size;

    if (pDispContent)
    {
        CDispNode * pDispElement;
        CSize       sizeOriginal;
        CRect       rc;

        Assert(GetView());
        
        pDispElement = GetElementDispNode();
        pDispElement->GetClientRect(&rc, CLIENTRECT_CONTENT);
        sizeOriginal = pDispContent->GetSize();

        //
        //  Ensure the passed size is correct
        //
        //    1) Scrolling containers always use the passed size
        //    2) Non-scrolling containers limit the size their client rectangle
        //    3) When editing psuedo-borders are enabled, ensure the size no less than the client rectangle
        //

        if (!pDispElement->IsScroller()
            // TODO RTL 112514: if we arbitrary resize an RTL node, its content gets totally messed up.
            //                 It is possible to do a combination of resize and positioning, 
            //                 but it looks like we manage to get away with just not doing this.
            //                 Somehow, this is called inconsistently on nodes with same exact properties
            //                 (e.g. table cells with overflow:hidden), so it looks like it is not really
            //                 required (or not needed for flow layout, which is fine, since only flow layout
            //                 can have a content origin (so far...).
            //                 If this code is really optional, why don't we nuke it?
            && !pDispContent->HasContentOrigin())
        {
            sizeContent = rc.Size();
        }

        if ( IsShowZeroBorderAtDesignTime() && IsEditable())
        {
            sizeContent.Max(rc.Size());
        }

        //
        //  If the size differs, set the new size
        //  (Invalidate the entire area for all changes to non-CFlowLayouts
        //   or anytime the width changes)
        //

        if (sizeOriginal != sizeContent)
        {
            fInvalidateAll =    fInvalidateAll
                            ||  !TestLayoutDescFlag(LAYOUTDESC_FLOWLAYOUT)
                            ||  sizeOriginal.cx != sizeContent.cx;

            pDispContent->SetSize(sizeContent, NULL, fInvalidateAll);
        }
        else if (fInvalidateAll)
        {
            pDispContent->Invalidate();
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     TranslateDispNodes
//
//  Synopsis:   Adjust the position of a range of display nodes by the passed amount
//
//  Arguments:  size             - Amount by which to adjust
//              pDispNodeStart   - First node to adjust, NULL starts with first child
//              pDispNodeEnd     - Last node to adjust, NULL ends with last child
//              fRestrictToLayer - Restrict search to starting layer (ignore if pDispNodeStart is NULL)
//
//-----------------------------------------------------------------------------
void
CLayout::TranslateDispNodes(
    const SIZE &    size,
    CDispNode *     pDispNodeStart,
    CDispNode *     pDispNodeEnd,
    BOOL            fRestrictToLayer,
    BOOL            fExtractHidden)
{
    CDispNode * pDispNode = GetElementDispNode();

    //
    //  If there is nothing to do, exit
    //

    if (!pDispNode)
        goto Cleanup;

    if (    !pDispNode->IsContainer()
        ||  !DYNCAST(CDispContainer, pDispNode)->CountChildren())
        goto Cleanup;

    if (    !size.cx
        &&  !size.cy
        &&  !fExtractHidden)
        goto Cleanup;

    //
    //  Check for reasonable values
    //

    Assert(size.cx > (LONG_MIN / 2));
    Assert(size.cx < (LONG_MAX / 2));
    Assert(size.cy > (LONG_MIN / 2));
    Assert(size.cy < (LONG_MAX / 2));

    //
    //  Determine the start node (if none was supplied)
    //

    if (!pDispNodeStart)
    {
        pDispNodeStart   = pDispNode->GetFirstChildNode();
        if (!pDispNodeStart)
            goto Cleanup;
        fRestrictToLayer = FALSE;
    }

    //
    //  Translate the nodes
    //

    {
        pDispNode = pDispNodeStart;

        while (pDispNode)
        {
            CDispNode * pDispNodeCur = pDispNode;

            void *      pvOwner;
            CDispClient * pDispClient = this;

            pDispNode = fRestrictToLayer ? pDispNode->GetNextInSameLayer()
                                         : pDispNode->GetNextSiblingNode();

            //
            // if the current disp node is a text flow node or if the disp node
            // owner is not hidden then translate it or extract the disp node
            //
            if(pDispNodeCur->GetDispClient() == pDispClient)
            {
                pDispNodeCur->SetPosition(pDispNodeCur->GetPosition() + size);
            }
            else
            {
                pDispNodeCur->GetDispClient()->GetOwner(pDispNodeCur, &pvOwner);

                if (pvOwner)
                {
                    CElement *  pElement = DYNCAST(CElement, (CElement *)pvOwner);

                    if(fExtractHidden && pElement->IsDisplayNone())
                    {
                        GetView()->ExtractDispNode(pDispNodeCur);
                    }
                    else if (size.cx || size.cy)
                    {
                        if(pElement->ShouldHaveLayout())
                        {
                            pElement->GetUpdatedLayout()->SetPosition(pDispNodeCur->GetPosition() + size);
                        }
                        else
                        {
                            pDispNodeCur->SetPosition(pDispNodeCur->GetPosition() + size );
                        }
                   }
                }
            }

            if (pDispNodeCur == pDispNodeEnd)
                break;
        }
    }

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyDispNode
//
//  Synopsis:   Disconnect/destroy all display nodes
//              NOTE: This only needs to destroy the container node since
//                    all other created nodes will be destroyed as a by-product.
//
//-----------------------------------------------------------------------------
void
CLayout::DestroyDispNode()
{
    if (_pDispNode)
    {
        DetachScrollbarController(_pDispNode);
        Verify(OpenView());
        _pDispNode->Destroy();
        _pDispNode = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleScrollbarMessage
//
//  Synopsis:   Process a possible message for the scrollbar
//
//  Arguments:  pMessage - Message
//              pElement - Target element
//
//----------------------------------------------------------------------------
HRESULT
CLayout::HandleScrollbarMessage(
    CMessage *  pMessage,
    CElement *  pElement)
{
extern SIZE g_sizeScrollButton;

    CDispNode * pDispNode = GetElementDispNode();
    CDoc *      pDoc      = Doc();
    HRESULT     hr        = S_FALSE;

    if (    !pDispNode
        ||  !ElementOwner()->IsEnabled())
        return hr;

    Assert(pDispNode->IsScroller());

    switch (pMessage->message)
    {
    case WM_SETCURSOR:
        SetCursorIDC(IDC_ARROW);
        hr = S_OK;
        break;

    //
    //  Ignore up messages to simple fall-through
    //  ("Real" up messages are sent to the scrollbar directly
    //   since it captures the mouse on the cooresponding down message)
    //
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        break;

#ifndef UNIX
    case WM_MBUTTONDOWN:
#endif
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
        break;

    case WM_LBUTTONDBLCLK:
        pDoc->_fGotDblClk = FALSE;

#ifdef UNIX
    case WM_MBUTTONDOWN:
#endif
    case WM_LBUTTONDOWN:
    case WM_CONTEXTMENU:
        AttachScrollbarController(pDispNode, pMessage);
        hr = S_OK;
        break;

    case WM_KEYDOWN:
        Assert(VK_PRIOR < VK_DOWN);
        Assert(VK_NEXT  > VK_PRIOR);
        Assert(VK_END   > VK_PRIOR);
        Assert(VK_HOME  > VK_PRIOR);
        Assert(VK_LEFT  > VK_PRIOR);
        Assert(VK_UP    > VK_PRIOR);
        Assert(VK_RIGHT > VK_PRIOR);

        if (    !(pMessage->dwKeyState & FALT)
            &&  pMessage->wParam >= VK_PRIOR
            &&  pMessage->wParam <= VK_DOWN)
        {
            UINT            uCode;
            long            cAmount;
            int             iDirection;
            CDispNodeInfo   dni;

            GetDispNodeInfo(&dni);

            uCode      = SB_THUMBPOSITION;
            cAmount    = 0;
            iDirection = 1;

            switch (pMessage->wParam)
            {
            case VK_END:
                cAmount = LONG_MAX;

            case VK_HOME:
                uCode = SB_THUMBPOSITION;
                break;

            case VK_NEXT:
                uCode = SB_PAGEDOWN;
                break;

            case VK_PRIOR:
                uCode = SB_PAGEUP;
                break;

            case VK_LEFT:
                iDirection = 0;
                // falling through

            case VK_UP:
                uCode = SB_LINEUP;
                break;

            case VK_RIGHT:
                iDirection = 0;
                // falling through

            case VK_DOWN:
                uCode = SB_LINEDOWN;
                break;
            }

            // Scroll only if scolling is allowed (IE5 #67686)
            if (    iDirection == 1 && dni.IsVScrollbarAllowed()
                ||  iDirection == 0 && dni.IsHScrollbarAllowed()
               )
            {
                hr = OnScroll(iDirection, uCode, cAmount, FALSE, (pMessage->wParam&0x4000000)
                                                                    ? 50  // TODO (IE6 bug 13575): For now we are using the mouse delay - should use Api to find system key repeat rate set in control panel.
                                                                    : MAX_SCROLLTIME);
            }
        }
        break;
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     OnScroll
//
//  Synopsis:   Compute scrolling info.
//
//  Arguments:  iDirection  0 - Horizontal scrolling, 1 - Vertical scrolling
//              uCode       scrollbar event code (SB_xxxx)
//              lPosition   new scroll position
//              fRepeat     TRUE if the previous scroll action is repeated
//              lScrollTime time in millisecs to scroll (smoothly)
//
//  Return:     HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CLayout::OnScroll(
    int     iDirection,
    UINT    uCode,
    long    lPosition,
    BOOL    fRepeat,
    LONG    lScrollTime)
{
extern WORD wConvScroll(WORD wparam);
extern SIZE g_sizeSystemChar;

    HRESULT hr = S_OK;

    //
    //  Ignore requests that arrive while the document is not in-place active
    //

    if (    Doc()->_state < OS_INPLACE
        &&  !Doc()->IsPrintDialogNoUI())
    {
        hr = OLE_E_INVALIDRECT;
    }

    //
    //  Scroll the appropriate direction
    //

    else
    {
        //
        //  Scroll the appropriate amount
        //

        switch (uCode)
        {
        case SB_LINEUP:
        case SB_LINEDOWN:
            if (iDirection)
            {
                ScrollByLine(CSize(0, (uCode == SB_LINEUP ? -1 : 1)), lScrollTime);
            }
            else
            {
                ScrollBy(CSize(uCode == SB_LINEUP ? -g_sizeSystemChar.cx : g_sizeSystemChar.cx, 0), lScrollTime);
            }
            break;

        case SB_PAGEUP:
        case SB_PAGEDOWN:
            {
                if (iDirection)
                {
                    ScrollByPage(CSize(0, (uCode == SB_PAGEUP ? -1 : 1)), lScrollTime);
                }
                else
                {
                    CRect   rc;
                    CSize   size;

                    GetClientRect(&rc);

                    size             = g_Zero.size;
                    size[iDirection] = (uCode == SB_PAGEUP ? -1 : 1) *
                                            max(1L,
                                            rc.Size(iDirection) - (((CSize &)g_sizeSystemChar)[iDirection] * 2L));

                    ScrollBy(size, lScrollTime);
                }
            }
            break;

        case SB_TOP:
            if (iDirection)
            {
                ScrollToY(-LONG_MAX);
            }
            else
            {
                ScrollToX(-LONG_MAX);
            }
            break;

        case SB_BOTTOM:
            if (iDirection)
            {
                ScrollToY(LONG_MAX);
            }
            else
            {
                ScrollToX(LONG_MAX);
            }
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            if (iDirection)
            {
                ScrollToY(lPosition);
            }
            else
            {
                ScrollToX(lPosition);
            }
            break;

        case SB_ENDSCROLL:
            break;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollByLine
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollByLine(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;
    CSize       sizeOffset;
    long        incY = -1;
    long        lUnitHeight;
    CDefaults * pDefaults   = ElementOwner()->GetDefaults();

    if (    !pDispNode
        ||  !pDispNode->IsScroller()
        ||  sizeDelta == g_Zero.size
        )
    {
        return fRet;
    }

    if (pDefaults)
    {
        incY = pDefaults->GetAAscrollSegmentY();
    }

    if (incY < 0)
    {
        Assert(abs(sizeDelta.cy) * 125 <= 1000);
        return ScrollByPercent(CSize(sizeDelta.cx, sizeDelta.cy * 125), lScrollTime);
    }
    else if (incY == 0 || incY == 1)
    {
        return fRet;
    }

    DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

    Assert(incY > 1);

    lUnitHeight    = GetContentHeight() / incY;

    sizeOffset.cy = sizeOffset.cy + sizeDelta.cy * lUnitHeight;
    sizeOffset.cx += sizeDelta.cx;

    return ScrollTo(sizeOffset, lScrollTime);
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollByPage
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollByPage(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;
    CSize       sizeOffset;
    long        incY = -1;
    long        lUnitHeight;
    CRect       rc;
    CDefaults * pDefaults    = ElementOwner()->GetDefaults();

    Assert(abs(sizeDelta.cy) == 1);

    if (    !pDispNode
        ||  !pDispNode->IsScroller()
        ||  sizeDelta == g_Zero.size
        )
    {
        return fRet;
    }

    if (pDefaults)
    {
        incY = pDefaults->GetAAscrollSegmentY();
    }

    if (incY < 0)
    {
        return ScrollByPercent(CSize(sizeDelta.cx, sizeDelta.cy * 875), lScrollTime);
    }
    else if (incY == 0 || incY == 1)
    {
        return fRet;
    }

    DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

    Assert(incY > 1);

    lUnitHeight    = GetContentHeight() / incY;
    pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);

    if (lUnitHeight == 0)
        return fRet;

    sizeOffset.cy = sizeOffset.cy + sizeDelta.cy * (rc.Height() - lUnitHeight);
    sizeOffset.cx += sizeDelta.cx;

    return ScrollTo(sizeOffset, lScrollTime);
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollBy
//              ScrollByPercent
//              ScrollTo
//              ScrollToX
//              ScrollToY
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollBy(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;


    if (    pDispNode
        &&  pDispNode->IsScroller()
        &&  sizeDelta != g_Zero.size)
    {
        CSize   sizeOffset;
        long    incY = -1;

        if (sizeDelta.cy)
        {
            CDefaults *pDefaults = ElementOwner()->GetDefaults();
            if (pDefaults)
            {
                incY = pDefaults->GetAAscrollSegmentY();
            }

            if (incY == 0 || incY == 1)
            {
                return fRet;
            }
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        if (incY > 1)
        {
            long lDeltaY = sizeDelta.cy;
            long lUnitHeight = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return fRet;

            if (lDeltaY != 0)
            {
                lDeltaY = lDeltaY > 0 ? max(lDeltaY, lUnitHeight) + lUnitHeight/2 : min(lDeltaY, -lUnitHeight) - lUnitHeight/2;
                lDeltaY = (lDeltaY / lUnitHeight) * lUnitHeight;
            }
            sizeOffset.cx += sizeDelta.cx;
            sizeOffset.cy += lDeltaY;
        }
        else
        {
            sizeOffset += sizeDelta;
        }

        fRet = ScrollTo(sizeOffset, lScrollTime);
    }
    return fRet;
}


BOOL
CLayout::ScrollByPercent(
    const CSize &   sizePercent,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;

    if ( pDispNode &&
         pDispNode->IsScroller() &&
         sizePercent != g_Zero.size)
    {
        CRect   rc;
        CSize   sizeOffset;
        CSize   sizeDelta;
        long    incY = -1;

        pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);

        sizeDelta.cy = (sizePercent.cy
                            ? (rc.Height() * sizePercent.cy) / 1000L
                            : 0);

        if (sizeDelta.cy)
        {
            CDefaults * pDefaults = ElementOwner()->GetDefaults();
            if (pDefaults)
            {
                incY = pDefaults->GetAAscrollSegmentY();
            }

            if (incY == 0 || incY == 1)
            {
                return fRet;
            }
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        sizeDelta.cx = (sizePercent.cx
                            ? (rc.Width() * sizePercent.cx) / 1000L
                            : 0);

        if (incY > 1)
        {
            long lUnitHeight    = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return fRet;

            if (sizeDelta.cy != 0)
            {
                sizeDelta.cy = sizeDelta.cy > 0
                                    ?   (max(sizeDelta.cy, lUnitHeight) + lUnitHeight/2)
                                    :   (min(sizeDelta.cy, -lUnitHeight) - lUnitHeight/2);
                sizeDelta.cy = (sizeDelta.cy / lUnitHeight) * lUnitHeight;
            }
        }
        else
        {
            sizeDelta.cy = (sizePercent.cy
                            ? (rc.Height() * sizePercent.cy) / 1000L
                            : 0);
        }

        sizeOffset += sizeDelta;

        fRet = ScrollTo(sizeOffset, lScrollTime);
    }
    return fRet;
}


BOOL
CLayout::ScrollTo(
    const CSize &   sizeOffset,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;

    if (pDispNode && pDispNode->IsScroller() && OpenView(FALSE, TRUE))
    {
        CView *     pView        = GetView();
        CElement *  pElement     = ElementOwner();
        BOOL        fLayoutDirty = pView->HasLayoutTask(this);
        BOOL        fScrollBits  = !fLayoutDirty && lScrollTime >= 0;
        CSize       sizeOffsetCurrent;
        CPaintCaret hc( pElement->Doc()->_pCaret ); // Hide the caret for scrolling

        //
        //  If layout is needed, perform it prior to the scroll
        //  (This ensures that container and content sizes are correct before
        //   adjusting the scroll offset)
        //

        if (fLayoutDirty)
        {
            DoLayout(pView->GetLayoutFlags() | LAYOUT_MEASURE);

            // Recompute pDispNode since it may have changed!
            pDispNode = GetElementDispNode();
            if (!pDispNode || !pDispNode->IsScroller())
                return fRet;
        }

        //
        // If the incoming offset has is different, scroll and fire the event
        //

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffsetCurrent);

        if (sizeOffset != sizeOffsetCurrent)
        {
            AddRef();
            //
            //  Set the new scroll offset
            //  (If no layout work was pending, do an immediate scroll)
            //  NOTE: Setting the scroll offset will force a synchronous invalidate/render
            //

            fRet = pView->SmoothScroll(
                sizeOffset,
                this,
                fScrollBits,
                lScrollTime);

        //
            //  Ensure all deferred calls are executed
            //

            EndDeferred();

            Release();
        }
    }
    return fRet;
}


void
CLayout::ScrollToX(
    long    x,
    LONG    lScrollTime)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode && pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        sizeOffset.cx = x;

        ScrollTo(sizeOffset, lScrollTime);
    }
}


void
CLayout::ScrollToY(
    long    y,
    LONG    lScrollTime)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode && pDispNode->IsScroller())
    {
        CSize   sizeOffset;
        long    incY = -1;
        CDefaults * pDefaults = ElementOwner()->GetDefaults();

        if (pDefaults)
        {
            incY = pDefaults->GetAAscrollSegmentY();
        }

        if (incY == 0 || incY == 1)
        {
            return;
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        if (incY > 1)
        {
            long lUnitHeight    = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return;

            y = y > 0   ?   (max(y,  lUnitHeight) + lUnitHeight/2)
                        :   (min(y, -lUnitHeight) - lUnitHeight/2);
            y = (y / lUnitHeight) * lUnitHeight;
        }

        sizeOffset.cy = y;

        ScrollTo(sizeOffset, lScrollTime);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     GetXScroll
//              GetYScroll
//
//  Synopsis:   Helpers to retrieve scroll offsets
//
//-----------------------------------------------------------------------------
long
CLayout::GetXScroll() const
{
    CDispNode * pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);
        return sizeOffset.cx;
    }
    else
        return 0;
}

long
CLayout::GetYScroll() const
{
    CDispNode * pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);
        return sizeOffset.cy;
    }
    else
        return 0;
}


//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Perform layout
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CLayout::DoLayout(DWORD grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    //
    //  If the element is not hidden, layout its content
    //

    if (!IsDisplayNone())
    {
        CCalcInfo   CI(this);
        CSize       size;

        GetSize(&size);

        CI._grfLayout |= grfLayout;

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            if (_fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            CalcSize(&CI, &size);

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, size);
        }
    }

    //
    //  Otherwise, clear dirty state and dequeue the layout request
    //

    else
    {
        FlushRequests();
        Reset(TRUE);
    }

    Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}


//+----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a notification
//
//  Arguments:  pnf - Notification sent
//
//-----------------------------------------------------------------------------
void
CLayout::Notify(
    CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    if (!TestLock(CElement::ELEMENTLOCK_SIZING))
    {
        // If the the current layout is hidden, then forward the current notification
        // to the parent as a resize notfication so that parents keep track of the dirty
        // range.
        if(    !pnf->IsFlagSet(NFLAGS_DESCENDENTS)
           &&  (   pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                || pnf->IsType(NTYPE_ELEMENT_RESIZE)
                || pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                || pnf->IsType(NTYPE_CHARS_RESIZE))
           &&  IsDisplayNone())
        {
            pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
        }
        else switch (pnf->Type())
        {
            case NTYPE_ELEMENT_RESIZE:
                if (!pnf->IsHandled())
                {
                    Assert(pnf->Element() != ElementOwner());

                    //  Always "dirty" the layout associated with the element
                    pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                    //  Handle absolute elements by noting that one is dirty
                    if (pnf->Element()->IsAbsolute())
                    {
                        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                    "Layout Request: Queueing RF_MEASURE on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                    this,
                                    _pElementOwner,
                                    _pElementOwner->TagName(),
                                    _pElementOwner->_nSerialNumber,
                                    pnf->Name(),
                                    pnf->Element(),
                                    pnf->Element() ? pnf->Element()->TagName() : _T("")));
                        QueueRequest(CRequest::RF_MEASURE, pnf->Element());

                        if (pnf->IsFlagSet(NFLAGS_ANCESTORS))
                        {
                            pnf->SetHandler(ElementOwner());
                        }
                    }
                }
                break;

            case NTYPE_ELEMENT_REMEASURE:
                pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                break;

            case NTYPE_CLEAR_DIRTY:
                SetSizeThis( FALSE );
                break;

            case NTYPE_TRANSLATED_RANGE:
                Assert(pnf->IsDataValid());
                HandleTranslatedRange(pnf->DataAsSize());
                break;

            case NTYPE_ZPARENT_CHANGE:
                if (!ElementOwner()->IsPositionStatic())
                {
                    ElementOwner()->ZChangeElement();
                }
                else if (_fContainsRelative)
                {
                    ZChangeRelDispNodes();
                }
                break;

            case NTYPE_DISPLAY_CHANGE :
            case NTYPE_VISIBILITY_CHANGE:
                HandleVisibleChange(pnf->IsType(NTYPE_VISIBILITY_CHANGE));
                break;

            case NTYPE_ZERO_GRAY_CHANGE:
                HandleZeroGrayChange( pnf );
                break;

            default:
                if (IsInvalidationNotification(pnf))
                {
                    Invalidate();

                    // We've now handled the notification, so set the handler
                    // (so we can know not to keep sending it if SENDUNTILHANDLED
                    // is true.
                    pnf->SetHandler(ElementOwner());
                }
                break;
        }
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     GetAutoPosition
//
//  Synopsis:   Get the auto position of a given layout for which, this is the
//              z-parent
//
//  Arguments:  pLayout - Layout to position
//              ppt     - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------
void
CLayout::GetAutoPosition(
    CElement  *  pElement,
    CElement  *  pElementZParent,
    CDispNode ** ppDNZParent,
    CLayout   *  pLayoutParent,
    CPoint    *  ppt,
    BOOL         fAutoValid)
{
    CElement  * pElementLParent = pLayoutParent->ElementOwner();
    CDispNode * pDispNodeParent;

    Assert(pLayoutParent);

    //
    // get the inflow position relative to the layout parent, if the pt
    // passed in is not valid.
    //
    if(!fAutoValid)
    {
        pLayoutParent->GetPositionInFlow(pElement, ppt);

        //
        // GetPositionInFlow may have caused a recalc, which may have
        // replaced the dispnode. So, we need to grab the new dispnode ptr.
        //
        *ppDNZParent = pElementZParent->GetUpdatedNearestLayout(LayoutContext())->GetElementDispNode(pElementZParent);
    }

    //
    // if the ZParent is ancestor of the LParent, then translate the point
    // to ZParent's coordinate system.
    // TODO (IE6 bug 13585) (srinib) - We are determining if ZParent is an ancesstor of
    // LParent here by comparing the source order. Searching the branch
    // could be cheaper
    //
    if(     pElementZParent == pElementLParent
        ||  (       pElementZParent->GetMarkup() == pElementLParent->GetMarkup()
                &&  pElementZParent->GetFirstCp() < pElementLParent->GetFirstCp())
        ||  (       pElementZParent->HasSlavePtr()
                &&  pElementZParent->GetSlavePtr() == pElementLParent->GetMarkup()->Root()
                &&  pElementZParent->GetSlavePtr()->GetFirstCp() < pElementLParent->GetFirstCp())
       )
    {
// TODO (IE6 bug 13585) - donmarsh when you have a routine to translate from one
// dispnode to another, please replace this code.(srinib)
        if(pElementZParent != pElementLParent)
        {
            pDispNodeParent = pLayoutParent->GetElementDispNode();

            while(  pDispNodeParent
                &&  pDispNodeParent != *ppDNZParent)
            {
                pDispNodeParent->TransformPoint(*ppt, COORDSYS_FLOWCONTENT, ppt, COORDSYS_PARENT);
                pDispNodeParent = pDispNodeParent->GetParentNode();
            }
        }
    }
    else
    {
        CPoint pt = g_Zero.pt;

        Assert(pElementZParent->IsRelative() && !pElementZParent->ShouldHaveLayout());

        pElementZParent->GetUpdatedParentLayout(pLayoutParent->LayoutContext())->GetFlowPosition(*ppDNZParent, &pt);

        ppt->x -= pt.x;
        ppt->y -= pt.y;
    }

}


//+----------------------------------------------------------------------------
//
//  Member:     HandleVisibleChange
//
//  Synopsis:   Respond to a change in the display or visibility property
//
//-----------------------------------------------------------------------------

void
CLayout::HandleVisibleChange(BOOL fVisibility)
{
    CView *     pView        = Doc()->GetView();
    CElement *  pElement     = ElementOwner();
    CTreeNode * pTreeNode    = pElement->GetFirstBranch();
    HWND        hwnd         = pElement->GetHwnd();
    BOOL        fDisplayNone = pTreeNode->IsDisplayNone();
    BOOL        fHidden      = pTreeNode->IsVisibilityHidden();

    pView->OpenView();

    if(fVisibility)
    {
        EnsureDispNodeVisibility(VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility()), pElement);
    }

    if (hwnd && Doc()->_pInPlace)
    {
        CDispNode * pDispNode = GetElementDispNode(pElement);
        CRect       rc;
        UINT        uFlags = (  !fDisplayNone
                            &&  !fHidden
                            &&  (   !pDispNode
                                ||  pDispNode->IsInView())
                                        ? SWP_SHOWWINDOW
                                        : SWP_HIDEWINDOW);

        ::GetWindowRect(hwnd, &rc);
        ::MapWindowPoints(HWND_DESKTOP, Doc()->_pInPlace->_hwnd, (POINT *)&rc, 2);
        pView->DeferSetWindowPos(hwnd, &rc, uFlags, NULL);
    }

    // Special stuff for OLE sites
    if (pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
    {
        COleSite *  pSiteOle    = DYNCAST(COleSite, pElement);

        if (fHidden || fDisplayNone)
        {
            // When an OCX without a hwnd goes invisible, we need to call
            // SetObjectsRects with -ve rect. This lets the control hide
            // any internal windows (IE5 #66118)
            if (!hwnd)
            {
                RECT rcNeg = { -1, -1, -1, -1 };

                DeferSetObjectRects(
                    pSiteOle->_pInPlaceObject,
                    &rcNeg,
                    &g_Zero.rc,
                    NULL,
                    FALSE);
            }
        }
        else
        {
            //
            // transition up to at least baseline state if going visible.
            // Only do this if going visible cuz otherwise it causes
            // problems with the deskmovr. MikeSch has details. (anandra)
            //

            OLE_SERVER_STATE    stateBaseline   = pSiteOle->BaselineState(Doc()->State());
            if (pSiteOle->State() < stateBaseline)
            {
                pView->DeferTransition(pSiteOle);
            }
        }
    }

    if(!fVisibility)
    {
        if (ElementOwner()->IsPositioned() && !fDisplayNone)
        {
            pElement->ZChangeElement(0, NULL, LayoutContext());
        }
        else if (fDisplayNone)
        {
            CDispNode * pDispNode = GetElementDispNode();

            if (pDispNode)
            {
                // bug IE6 2282 (dmitryt) Only unlink nodes that are still
                // connected to the root. 
                // We are trying to unlink only first nodes on the way
                // down the tree, keeping all chldren of them intact so we
                // can avoid costly deep recalculation later.
                // If the "root" node returned by GetRootNode() 
                // (the one with _pParent==NULL) 
                // is not the real DispRoot, it means we belong to already
                // unlinked subtree.
                CDispNode *pRootNode = pDispNode->GetRootNode();
                if(pRootNode->IsDispRoot())
                {
                    pView->ExtractDispNode(pDispNode);
                }
            }
        }

        if (    !fDisplayNone
            &&  IsDirty()
            &&  !IsSizeThis())
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandleVisibleChange()",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber));
            PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}

//+====================================================================================
//
// Method: HandleZeroGrayChange
//
// Synopsis: The ZeroGrayBorder bit on the view has been toggled. We either flip on that
//           we have a background or not on our dispnode accordingly.
//
//------------------------------------------------------------------------------------

VOID
CLayout::HandleZeroGrayChange( CNotification* pnf )
{
    CBackgroundInfo  bi;
    CDispNode      * pdn = _pDispNode;

    if ( IsShowZeroBorderAtDesignTime() )
    {
        if ( pdn &&
             ElementOwner()->_etag != ETAG_OBJECT &&
             ElementOwner()->_etag != ETAG_BODY ) // don't draw for Object tags - it may interfere with them
        {
            pdn->SetBackground( TRUE );
        }
    }
    else
    {
        //
        // Only if we don't have a background will we clear the bit.
        //
        if ( pdn )
        {
            GetBackgroundInfo(NULL, &bi, FALSE);

            BOOL fHasBack = (bi.crBack != COLORREF_NONE || bi.pImgCtx);
            if ( ! fHasBack )
                pdn->SetBackground( FALSE );
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     HandleElementMeasureRequest
//
//  Synopsis:   Respond to a request to measure an absolutely positioned element
//              NOTE: Due to property changes, it is possible for the element
//                    to no longer be absolutely positioned by the time the
//                    request is handled
//
//  Arguments:  pci        - CCalcInfo to use
//              pElement   - Element to position
//              fEditable  - TRUE the element associated with this layout is editable,
//                           FALSE otherwise
//
//-----------------------------------------------------------------------------
MtDefine(CLayout_HandleElementMeasureRequest, LFCCalcSize, "Calls to HandleElementMeasureRequest" )

void
CLayout::HandleElementMeasureRequest(
    CCalcInfo * pci,
    CElement *  pElement,
    BOOL        fEditable)
{
    Assert(pci);
    Assert(pElement);

    MtAdd( Mt(CLayout_HandleElementMeasureRequest), +1, 0 );

    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_INDENT, "(Layout Position Reqs: HandleElementMeasureRequest() ly=0x%x pci(%d,%d) e=0x%x,%s editable=%s",
                this, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0, pElement, pElement->TagName(), fEditable ? "Y" : "N" ));

    CTreeNode *     pTreeNode = pElement->GetFirstBranch();
    CLayout *       pLayout   = pElement->GetUpdatedLayout(pci->GetLayoutContext());
    CNotification   nf;

    if (    pLayout
        &&  pTreeNode->IsAbsolute(LC_TO_FC(pci->GetLayoutContext()) ) )
    {
        if (   !pTreeNode->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext()))
            || fEditable)
        {
            CalcAbsolutePosChild(pci, pLayout);

            nf.ElementSizechanged(pElement);
            GetView()->Notify(&nf);

            pElement->ZChangeElement(0,
                                     NULL,
                                     pci->GetLayoutContext()
                                     FCCOMMA LC_TO_FC(pci->GetLayoutContext()));
        }

        else
        {
            // NOTE (KTam): This notification is odd -- why not just clear our _fSizeThis directly?
            nf.ClearDirty(ElementOwner());
            ElementOwner()->Notify(&nf);

            if (    pLayout
                &&  pLayout->GetElementDispNode())
            {
                pLayout->GetView()->ExtractDispNode(pLayout->GetElementDispNode());
            }
        }

        // if this absolute element, has a height specified in
        // percentages, we need a flag to be set the parent flowlayout
        // in order for this resized during a vertical-only resize
        if (IsFlowLayout())
        {
            // Set flags relative to this layout's coordinate system

            const CFancyFormat *pFFChild  = pTreeNode->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));
            BOOL  fChildWritingModeUsed   = pTreeNode->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->_fWritingModeUsed;
            BOOL  fThisVerticalLayoutFlow = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()))->HasVerticalLayoutFlow();

            if (pFFChild->IsLogicalHeightPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
            {
                DYNCAST(CFlowLayout, this)->SetVertPercentAttrInfo(TRUE);
            }

            if (pFFChild->IsLogicalWidthPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
            {
                DYNCAST(CFlowLayout, this)->SetHorzPercentAttrInfo(TRUE);
            }
        }
    }
}


void
CLayout::CalcAbsolutePosChild(CCalcInfo *pci, CLayout *pChildLayout)
{
    CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    SIZE    sizeLayout = pci->_sizeParent;

    pChildLayout->CalcSize(pci, &sizeLayout);

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     HandlePositionNotification/Request
//
//  Synopsis:   Respond to a z-order or position change notification
//
//  Arguments:  pElement   - Element to position
//              ptAuto     - Top/Left values for "auto"
//              fAutoValid - TRUE if ptAuto is valid, FALSE otherwise
//
//  Returns:    TRUE if handled, FALSE otherwise
//
//-----------------------------------------------------------------------------
MtDefine(CLayout_HandlePositionNotification, LFCCalcSize, "Calls to HandlePositionNotification" )

BOOL
CLayout::HandlePositionNotification(CNotification * pnf)
{
    MtAdd( Mt(CLayout_HandlePositionNotification), +1, 0 );

// TODO (IE6 bug 13586): Handle if z-parent or _fContainsRelative (brendand)
    BOOL    fHandle = ElementOwner()->IsZParent();

    if (fHandle)
    {
        // Let the display tree know about z-index changes
        if (pnf->IsType(NTYPE_ELEMENT_ZCHANGE) &&
            pnf->Element()->GetUpdatedLayout(pnf->LayoutContext()))
        {
            CDispNode *pDispNode = pnf->Element()->GetUpdatedLayout(pnf->LayoutContext())->GetElementDispNode();

            if (pDispNode)
            {
                // Adjust pDispNode's layer type
                LONG zOrder = 0;
                if (!pDispNode->IsFlowNode())
                {
                    zOrder = pDispNode->GetZOrder();
                    pDispNode->SetLayerPositioned(zOrder);
                }

                WHEN_DBG(BOOL fZOrderChanged = )
                        pDispNode->RestoreZOrder(zOrder);
#if DBG == 1
                CLayout * pLayout = pnf->Element()->GetUpdatedLayout(pnf->LayoutContext());
                LONG lZOrder = pLayout->GetFirstBranch()->IsPositionStatic() ? 0 :
                                pLayout->GetZOrderForSelf(pDispNode);

                TraceTag((tagZOrderChange, "%ls %ld zorder changed to %ld   dispnode %x dispChange = %d",
                        pnf->Element()->TagName(), pnf->Element()->SN(),
                        lZOrder, pDispNode, fZOrderChanged));
#endif
            }
        }

        if (    !TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS)
            ||  TestLock(CElement::ELEMENTLOCK_PROCESSMEASURE))
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request: Queueing RF_POSITION on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandlePositionNotification() [n=%S srcelem=0x%x,%S]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber,
                pnf->Name(),
                pnf->Element(),
                pnf->Element() ? pnf->Element()->TagName() : _T("")));

            CViewChain *pViewChain = HasLayoutContext() ? LayoutContext()->ViewChain() : NULL;
            CElement *  pRoot;
            CElement *  pMaster;

            if (    pViewChain
                &&  pViewChain->ElementContent()->GetMarkupPtr() == GetOwnerMarkup()
                &&  pnf->Element()
                && (pnf->Element()->IsAbsolute() || pnf->Element()->IsRelative())
                && (pRoot = ElementOwner()->GetMarkupPtr()->Root(),
                    pMaster = pRoot ? pRoot->GetMasterPtr() : NULL,
                    pMaster == NULL || (pMaster->Tag() != ETAG_FRAME && pMaster->Tag() != ETAG_IFRAME)) )
            {
                pViewChain->QueuePositionRequest(this, pnf->Element(), pnf->DataAsPoint(), pnf->IsDataValid());
            }
            else
            {
                CRequest *  pRequest = QueueRequest(CRequest::RF_POSITION, pnf->Element());

                if (pRequest)
                {
                    pRequest->SetAuto(pnf->DataAsPoint(), pnf->IsDataValid());
                }
            }
        }
        else
        {
            CRequest * pRequest = pnf->Element()->GetRequestPtr();

            if(!pRequest || !pRequest->IsFlagSet(CRequest::RF_POSITION))
            {
                // This initializes CCalcInfo with resolution taken from this layout's context
                CCalcInfo CI(this);
                HandlePositionRequest(&CI, pnf->Element(), pnf->DataAsPoint(), pnf->IsDataValid());
            }
            else if (pRequest && pRequest->IsFlagSet(CRequest::RF_AUTOVALID))
            {
                pRequest->ClearFlag(CRequest::RF_AUTOVALID);
            }
        }
    }

    return fHandle;
}

MtDefine(CLayout_HandlePositionRequest, LFCCalcSize, "Calls to HandlePositionRequest" )

BOOL
CLayout::HandlePositionRequest(
    CCalcInfo *     pci,
    CElement *      pElement,
    const CPoint &  ptAuto,
    BOOL            fAutoValid)
{

    // TODO (IE6 bug 13586): Handle if z-parent or _fContainsRelative (brendand)
    Assert(ElementOwner()->IsZParent());
    Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    Assert(GetElementDispNode());
    Assert(pElement->GetFirstBranch());

    MtAdd( Mt(CLayout_HandlePositionRequest), +1, 0 );

#if DBG==1
    {
        long    cp  = pElement->GetFirstCp() - GetContentFirstCp();
        long    cch = pElement->GetElementCch();

        Assert( !IsDirty()
            ||  (   IsFlowLayout()
                &&  DYNCAST(CFlowLayout, this)->IsRangeBeforeDirty(cp, cch)));
    }
#endif
          CLayoutContext * pLayoutContext = pci->GetLayoutContext();
          
          CTreeNode    * pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat * pFF = pTreeNode->GetFancyFormat();
    const CCharFormat  * pCF = pTreeNode->GetCharFormat();
          BOOL           fRelative = pFF->IsRelative();
          BOOL           fAbsolute = pFF->IsAbsolute();


    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_INDENT, "(Layout Position Reqs: HandlePositionRequest() ly=0x%x pci(%d,%d) e=0x%x,%s pt(%d,%d) ptValid=%s",
                this, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0, pElement, pElement->TagName(), ptAuto.x, ptAuto.y, fAutoValid ? "T" : "F" ));

    //
    // Layouts inside relative positioned elements do not know their
    // relative position untill the parent is measured. So, they fire
    // a z-change notification to get positioned into the tree.
    // fRelative is different from pCF->_fRelative, fRelative means
    // is the current element relative. pCF->_fRelative is true if
    // an element is inheriting relativeness from an ancestor the
    // does not have layoutness (an image inside a relative span,
    // if the span has layoutness then the image does not inherit
    // relativeness).
    //
    if (    !IsDisplayNone()
        &&  !pCF->IsDisplayNone()
        &&  (fAbsolute || pCF->_fRelative || fRelative))
    {
        // TODO (IE6 bug 13586): Re-write this: If _fContainsRelative, then get the element z-parent and its
        //         display node. Then use that node as the parent for all other processing.
        //         (brendand)
        CLayout   * pLayout         = pElement->GetUpdatedNearestLayout(pLayoutContext);
        CElement  * pElementZParent = pTreeNode->ZParent();
        CLayout   * pLayoutZParent  = pElementZParent->GetUpdatedNearestLayout(pLayoutContext);
        CDispNode * pDNElement;
        CDispNode * pDNZParent;

        pDNZParent = pLayoutZParent->EnsureDispNodeIsContainer(pElementZParent);

        if (pDNZParent)
        {
            Assert(pLayout);

            pDNElement = pLayout->GetElementDispNode(pElement);

            Assert(pDNZParent->IsContainer());

            if(pDNElement)
            {
                BOOL            fThisVertical = GetFirstBranch()->GetCharFormat(LC_TO_FC(pLayoutContext))->HasVerticalLayoutFlow();
                BOOL            fChildWM = pCF->_fWritingModeUsed;
                const CUnitValue & cuvTop     = pFF->GetLogicalPosition(SIDE_TOP, fThisVertical, fChildWM);
                const CUnitValue & cuvBottom  = pFF->GetLogicalPosition(SIDE_BOTTOM, fThisVertical, fChildWM);
                const CUnitValue & cuvLeft    = pFF->GetLogicalPosition(SIDE_LEFT, fThisVertical, fChildWM);
                const CUnitValue & cuvRight   = pFF->GetLogicalPosition(SIDE_RIGHT, fThisVertical, fChildWM);
                BOOL            fTopAuto      = cuvTop.IsNullOrEnum();
                BOOL            fBottomAuto   = cuvBottom.IsNullOrEnum();
                BOOL            fLeftAuto     = cuvLeft.IsNullOrEnum();
                BOOL            fRightAuto    = cuvRight.IsNullOrEnum();
                BOOL            fLeftPercent  = cuvLeft.IsPercent();
                BOOL            fTopPercent   = cuvTop.IsPercent();
                CLayout       * pLayoutParent = pElement->GetUpdatedParentLayout(pLayoutContext);
                long            lFontHeight   = pTreeNode->GetCharFormat()->GetHeightInTwips(Doc());
                long            xLeftMargin   = 0;
                long            yTopMargin    = 0;
                long            xRightMargin  = 0;
                long            yBottomMargin = 0;
                CPoint          pt(g_Zero.pt);
                CRect           rc(g_Zero.rc);
                CDocInfo      * pdciMeasure   = pci;
                CSize size;

                CElement  * pParent         = pLayoutParent->ElementOwner();

                if ( pParent->Tag() == ETAG_TR )
                {
                    if (pElement->Tag() == ETAG_TD || pElement->Tag() == ETAG_TH)
                    {
                        if (pParent->IsPositionStatic())  // if row itself is not postioned
                        {
                            // the parent layout should be the table
                            pLayoutParent = pParent->GetUpdatedParentLayout(pLayoutContext);
                        }
                    }
                }

                // We need to know if the parent is RTL to decide if we need to honor
                // right:XXX or left:XXX first
                BOOL fRTLParent = FALSE;
                {
                    CFlowLayout *pFL = pLayoutParent->IsFlowLayout();
                    if (pFL)
                    {
                        fRTLParent = pFL->IsRTLFlowLayout();
                    }
                    else
                    {
                        // This is a more expensive way to determine if a layout is
                        // RTL, but we only need this if a non-flow layout is a
                        // parent of something positoned, and that's exotic.
                        // (greglett)  Not so exotic anymore.  Under the CSS DTS most
                        //             elements will be positioned wrt the HTML layout.
                        fRTLParent = pLayoutParent->IsRightToLeft();
                    }

                    // In RTL, if Right is set, it has priority
                    if (fRTLParent)
                    {
                        if (!fRightAuto)
                            fLeftAuto = TRUE;
                    }
                }


                if (    !fAbsolute
                    ||  fLeftAuto
                    ||  fTopAuto)
                {
                    CFlowLayout * pFL = pLayoutParent->IsFlowLayout();

                    // GetAutoPosition returns bogus (0, 0) pt in situation when pLayoutParent 
                    // is calculated in background and pElement is not in calculated part yet... 
                    if (    pFL && pFL->HasBgRecalcInfo()
                        &&  pFL->GetMaxCpCalced() <= pElement->GetFirstCp())
                    {
                        goto Cleanup;
                    }

                    pt = ptAuto;

                    GetAutoPosition(pElement, pElementZParent, &pDNZParent, pLayoutParent, &pt, fAutoValid);

                    //
                    // Get auto position may have caused a calc which might result in
                    // morphing the display node for the current element.
                    //
                    pDNElement = pLayout->GetElementDispNode(pElement);
                }

                size = pDNElement->GetApparentSize();

                //
                // if the we are positioning an absolute element with top/left specified
                // then clear the auto values.
                //
                if (fAbsolute)
                {
                    if (!fLeftAuto || !fRightAuto)
                    {
                        pt.x = 0;
                        if (pLayoutZParent->IsFlowLayout())
                        {
                            CDispClient* pDispClient = pDNZParent->GetDispClient();
                            if (pDispClient)
                            {
                                CPoint anchor;
                                BOOL ok = pDispClient->GetAnchorPoint(pDNZParent, &anchor);
                                if (ok)
                                    pt.x = anchor.x;
                            }

                        }
                    }

                    if (!fTopAuto)
                        pt.y = 0;
                //}
                // Used to be: fAbsolute || Tag() == ETAG_BODY || Tag() == ETAG_FRAMESET
                //if (fAbsolute)
                //{
                    // Account for margins on absolute elements.
                    // Margins is already added onto relatively positioned elements.
                    // Due to the algorithm we need to have
                    // margin info available for absolute in opposite flows.
                    // Margins are also not added into BODY/FRAMESET, because HTML is not a flow layout.
                    // (greglett) However: BackCompat BODY/FRAMESET should not care about margins!
                    if (pLayout->ElementOwner() == pElement)
                    {
                        CCalcInfo CI(pdciMeasure, pLayoutParent);

                        pLayout->GetMarginInfo(&CI,
                                               &xLeftMargin,
                                               &yTopMargin,
                                               &xRightMargin,
                                               &yBottomMargin);

                        // Depending on flow direction, margins contribute differently
                        // TODO RTL 112514: this will not do the right thing in a run of opposite flow
                        //                  that is not explicitly marked as "dir=???". We should be 
                        //                  calling CalculateXPositionOfCp() or an equivalent, or cache
                        //                  the result of a previous call (since we have ptAuto, we have 
                        //                  called it before). But that is more change than I want to do 
                        //                  now, and this is not a regression from IE5.0
                        if(!fRTLParent)
                            pt.x += xLeftMargin;
                        else
                            pt.x -= xRightMargin;
                        pt.y += yTopMargin;
                    }
                }

                // (dmitryt) Perf optimization for the case when we have lots of positioned objects 
                // in a line. In this case, we get position request for each of them (N) and InsertChildInZLayer
                // is NlogN operation, so we have N*N*logN behavior.
                // Because of this, lets store the old position of dispnode and:
                // 1. if new position is the same - don't move dispnode.
                // 2. if _pParent is not NULL - don't try to insert the node into the tree.

                CPoint ptOldPos = pDNElement->GetPosition();
 
                //
                // if the element is positioned, compute the top/left based
                // on the top/left/right/bottom styles specified for the element
                //
                if (pFF->IsPositioned())
                {
                    //
                    //  Get the client rectangle used for percent and auto positioning
                    //  NOTE: Sanitize the rectangle so that each direction is even
                    //        (The extra pixel is given to the size of the object over the location)
                    //
                    if (    fLeftPercent
                        ||  fTopPercent
                        || !fRightAuto
                        || !fBottomAuto)
                    {
                        CLayout *pPositioningParent = fRelative ? pLayoutParent : pLayoutZParent;

                        pPositioningParent->GetClientRect(&rc);

                        // In RTL layout, positioning rectangle shouldn't be adjusted for scrolling.
                        // Absolute positioning from left and right behaves somewhat differently in RTL
                        // (and that's what it did in IE5): 'right:N' positions from right edge of layout, not
                        // from right edge of window; 'left:N' positions from left edge of original window.
                        // 'Left:N' behavior is probably bogus, but we need to investigate if it is a
                        // compatibility before changing it.
                        // (see bug 102699)
                        if (   fRTLParent 
                            && pPositioningParent->_pDispNode 
                            && pPositioningParent->_pDispNode->IsScroller())
                        {
                            // NOTE: this is only correct for scroller.
                            // leaf nodes and containers may have negative left of
                            // client area because of RTL overflow.
                            rc.MoveTo(0,0);
                        }

                        rc.right  &= ~0x00000001;
                        rc.bottom &= ~0x00000001;
                    }

                    // in RTL, do right offset first, otherwise, start with leftthere is no left offsetting the right offset
                    if(!fLeftAuto)
                    {
                        // adjust left position
                        pt.x += cuvLeft.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                    }
                    else if(!fRightAuto)
                    {
                        if(fRelative)
                        {
                            // adjust the relative position in the flow
                            // kind of redundant to get the right x and then get
                            // the left again so just adjust the left
                            pt.x -= cuvRight.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                        }
                        else
                        {
                            pt.x = rc.right;
                            pt.x -= cuvRight.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                            pt.x -= xRightMargin;
                            //place the top/left now
                            pt.x -= size.cx;
                        }
                    }

                    // adjust top position
                    pt.y += cuvTop.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);

                    if(!fBottomAuto)
                    {

                        // It is possible that we are overconstrained. Give top priority and
                        // don't go in here
                        if(fTopAuto)
                        {
                            if(fRelative)
                            {
                                // adjust the relative position in the flow
                                pt.y -= cuvBottom.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);
                            }
                            else
                            {
                                pt.y = rc.bottom;
                                pt.y -= cuvBottom.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);
                                pt.y -= yBottomMargin;
                                pt.y -= size.cy;
                            }
                        }
                    }

                    if (   (fAbsolute || fRelative)
                        && pLayoutContext
                        && pLayoutContext->ViewChain()
                        && pLayoutContext->ViewChain()->ElementContent()->GetMarkupPtr() == GetOwnerMarkup())
                    {
                        //  Reparenting absolute positioned element's disp node.

                        CLayoutContext * pLayoutContextDst;
                        CElement *       pElementContent;
                        CLayout *        pLayoutContent;
                        CViewChain *     pViewChain;
                        const CFancyFormat * pFFParent;
                        styleOverflow    overflowX;
                        styleOverflow    overflowY;
                        LONG             lZIndex;

                        pFFParent = ElementOwner()->GetFirstBranch()->GetFancyFormat();
                        overflowX = pFFParent->GetLogicalOverflowX(fThisVertical, fChildWM);
                        overflowY = pFFParent->GetLogicalOverflowY(fThisVertical, fChildWM);
                        lZIndex = GetTopmostAbsoluteZParent(pLayout->GetFirstBranch())->GetCascadedzIndex();

                        pViewChain = pLayoutContext->ViewChain();

                        pElementContent = pViewChain->ElementContent();
                        Assert(pElementContent);

                        if (   (pElementZParent == pElementContent
                                || (   pDNZParent->GetParentNode()
                                    && ((CLayout *)pDNZParent->GetParentNode()->GetDispClient())->ElementOwner() == pElementContent))
                            && (    overflowX == styleOverflowVisible
                                 || overflowX == styleOverflowNotSet
                                 || overflowY == styleOverflowVisible
                                 || overflowY == styleOverflowNotSet)   
                            &&  !HasFilterPeer(_pDispNode)  )
                        {
                            //  find the stitched pt
                            if (pElementZParent != pElementContent)
                            {
                                pt += pDNZParent->GetPosition().AsSize();

                                pDNZParent = pDNZParent->GetParentNode();
                                Assert(pDNZParent);
                                if (pDNZParent)
                                {
                                    pLayoutContent = (CLayout *)pDNZParent->GetDispClient();
                                    Assert(pLayoutContent
                                        &&  pLayoutContent->ElementOwner() == pElementContent
                                        &&  pLayoutContent->LayoutContext());

                                    pt.y += pLayoutContent->LayoutContext()->YOffset();
                                }
                            }
                            else if (   fRelative
                                    //  (bug # 99215; # 105475)
                                    ||  (fAutoValid && fTopAuto && fBottomAuto)  )
                            {
                                //  if this is a relative element add global y offset to get stitched coords
                                pt.y += pLayoutContext->YOffset();
                            }

                            CPoint ptStitched(pt);  //  at this point we have stitched pt

                            for (;;)
                            {
                                pt = ptStitched;

                                pLayoutContextDst = pViewChain->LayoutContextFromPoint(pLayout, &pt,
                                    //  If (pLayout->ElementOwner() != pElement) current disp node is
                                    //  rel disp node. And it should appear on the first page always (bug #106079)
                                    pLayout->ElementOwner() != pElement);

                                if (pLayoutContextDst == NULL)
                                {
                                    //  there is no page yet
                                    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
                                    return FALSE;
                                }

                                pLayoutContent = pElementContent->GetUpdatedLayout(pLayoutContextDst);

                                // We don't print HTML layout right now...
                                Assert(!GetOwnerMarkup()->IsHtmlLayout());

                                pDNZParent = pLayoutContent->EnsureDispNodeIsContainer(pElementContent);
                                
                                if (pDNZParent == NULL)
                                {
                                    //  this may happen if we have static template (not real print preview tempalte),
                                    //  in this case layout context exists but is not calaulted yet
                                    //  and doesn't have a disp node.
                                    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
                                    return FALSE;
                                }

                                // if view chain adjust to offset of the page
                                pt.y -= pLayoutContextDst->YOffset();

                                pLayout->_fDispNodeReparented = TRUE;

                                // NOTE : this is a code duplication should keep it in sync with what 
                                // we have below in this function.
                                pDNElement->SetLayerPositioned(lZIndex);
                                DYNCAST(CDispContainer, pDNZParent)->InsertChildInZLayer(pDNElement, lZIndex);

                                if (pElement->ShouldHaveLayout())
                                {
                                    pLayout->SetPosition(pt);

                                    //  pt.y less than zero if this is not the first block.
                                    //  Notification should be sent only for the first block.
                                    if (pt.y >= 0)
                                    {
                                        CNotification   nf;

                                        nf.ElementPositionchanged(pElement);
                                        GetView()->Notify(&nf);
                                    }
                                }
                                else
                                    pDNElement->SetPosition(pt);

                                ELEMENT_TAG etag = pLayout->Tag();

                                // Check if disp node doesn't fit into layout rect
                                if (    (ptStitched.y + size.cy) > (pLayoutContextDst->YOffset() + pLayoutContextDst->Height())
                                    //  Check that the element has its own layout. Otherwise this is a inline relative element.
                                    && pLayout->ElementOwner() == pElement
                                    &&  etag != ETAG_TR
                                    &&  etag != ETAG_THEAD
                                    &&  etag != ETAG_TFOOT  )
                                {
                                    // Set display break ...
                                    pViewChain->SetDisplayBreak(pLayoutContextDst, pLayout, (new CBreakBase()));

                                    // Clone disp nodes ... 

                                    // TODO (112506, olego): 
                                    // We do not have robust way to clone the display sub-tree. 
                                    // Now the full calcsize pass is ussed for that purpose. 
                                    // DisplayTree should have the functionality to clone its 
                                    // sub-tree starting from given display node.

                                    CCalcInfo   CI(pLayout);
                                    CSize       sizeLayout(size);

                                    Assert( CI.GetLayoutContext()
                                        &&  CI.GetLayoutContext()->ViewChain() );

                                    CI._fCloneDispNode = TRUE;
                                    CI._grfLayout = LAYOUT_MEASURE | LAYOUT_FORCE;
                                    CI._sizeParentForVert = CI._sizeParent;

                                    Assert(!pElement->IsAbsolute() || !pLayout->ElementCanBeBroken());

                                    //  Init available height for PPV
                                    if (pLayout->ElementCanBeBroken())
                                    {
                                        CLayoutBreak *pLayoutBreak;
                                        CI.GetLayoutContext()->GetEndingLayoutBreak(pElement, &pLayoutBreak);
                                        Assert(pLayoutBreak);

                                        if (pLayoutBreak)
                                        {
                                            CI._cyAvail = pLayoutBreak->AvailHeight();
                                        }
                                    }
                                    else
                                    {
                                        CI._cyAvail = pViewChain->HeightForContext( CI.GetLayoutContext() );
                                    }

                                    if (etag == ETAG_TD ||  etag == ETAG_TH)
                                    {
                                        CI._smMode = SIZEMODE_SET;
                                    }

                                    pLayout->SetSizeThis(TRUE);

                                    pLayout->CalcSize(&CI, (SIZE *)&sizeLayout);


                                    Assert(sizeLayout == size);

                                    pDNElement = pLayout->GetElementDispNode(pElement);
                                }
                                else
                                {
                                    return TRUE;
                                }
                            }
                        }
                    }


                    //if it's a newly created dispnode or ExtractFromTree was called during CalcSize,
                    //the parent will be NULL. This is the only case when we should Insert the dispnode
                    //into the tree (dmitryt)
                    CDispNode *pDisplayParent = pLayoutZParent->EnsureDispNodeIsContainer(pElementZParent);
                    if(pDNElement->GetParentNode() != pDisplayParent)
                    {
                        pDNElement->SetLayerPositioned(pFF->_lZIndex);
                        DYNCAST(CDispContainer, pDisplayParent)->InsertChildInZLayer(pDNElement, pFF->_lZIndex);
                    }
                }
                else
                {
                    DYNCAST(CDispContainer, pDNZParent)->InsertChildInFlow(pDNElement);
                }

                //if position actually changed, reposition dispnode
                if(ptOldPos != pt)
                {
                    if (pElement->ShouldHaveLayout())
                    {
                        pLayout->SetPosition(pt);

                        if (pFF->IsPositioned())
                        {
                            CNotification   nf;

                            nf.ElementPositionchanged(pElement);
                            GetView()->Notify(&nf);
                        }
                    }
                    else
                        pDNElement->SetPosition(pt);
                }
                else if (pElement->ShouldHaveLayout())
                    pLayout->_fPositionSet = TRUE;
            }
        }

        // The positioned element might have a caret inside that needs to move.
        CCaret *pCaret = Doc()->_pCaret;
        BOOL     fCaretVisible = FALSE;
        long     cpFirst, cpLast, cpCaret;

        if ( pCaret )
        {
            pCaret->IsVisible( &fCaretVisible );
            if ( fCaretVisible )
            {
                // If the markups are different, then we can't easily tell whether
                // the caret is affected by the element's position change, so just update.
                // If the markups are the same, we only need to update if the caret lies
                // within the cp range of the positioned element.
                if (    pCaret->GetMarkup() != pElement->GetMarkup()
                   || (  pElement->GetFirstAndLastCp( &cpFirst, &cpLast )
                      && ((cpCaret = pCaret->GetCp(NULL)) != 0)
                      && ( cpCaret >= cpFirst && cpCaret <= cpLast ) )
                   )
                {
                    pCaret->UpdateCaret();
                }
            }
        }
    }

Cleanup:
    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
    return TRUE;
}

#ifdef ADORNERS
//+----------------------------------------------------------------------------
//
//  Member:     HandleAddAdornerNotification/Request
//
//  Synopsis:   Insert the display node for a adorner
//
//  Arguments:  pAdorner - CAdorner whose display node is to be inserted
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HandleAddAdornerNotification(
    CNotification * pnf)
{
    CElement *  pElement  = ElementOwner();
    CTreeNode * pTreeNode = pElement->GetFirstBranch();
    BOOL        fHandle   = FALSE;

    //
    //  Adorners for BODYs or FRAMESETs are always anchored at the absolute top of that element
    //  (since there is no parent element in the current design under which to anchor them)
    //
    if (pnf->Element() == pElement)
    {
        Assert(GetOwnerMarkup());
        if(    pElement->Tag() == ETAG_BODY         //check for tags because there could be both 
            || pElement->Tag() == ETAG_FRAMESET     //BODY and FRAMESET in html file...
            || pElement == GetOwnerMarkup()->GetCanvasElement()) //this is for CSS1 case to check for ETAG_HTML
        {
            Assert(pnf->DataAsPtr());
            DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr())->GetDispNode()->SetExtraCookie((void *)ADL_ALWAYSONTOP);
            fHandle = TRUE;
        }
    }

    //
    //  Adorners are handled by the layout that owns the display node under which they are to be anchored
    //  This divides into several cases:
    //
    //      1) Adorners anchored at the "absolute" top are anchored under the first scrolling or
    //         filtered parent (since they mark a logical top within the display tree)
    //
    //      2) Adorners anchored on the element itself are anchored under the positioned parent
    //         (since that is the same parent under which the associated element is anchored)
    //         NOTE: Adorners anchored on an element are currently reserved for positioned elements -
    //               If that changes, then these rules will need appropriate modification
    //
    //      3) Adorners for the flow layer are anchored under either the first scrolling
    //         parent, first filtered parent, or first positioned parent found
    //         (since they establish the nearest flow layer)
    //
    //  These rules are modified slightly when the positioned parent does not have its own layout (such
    //  as with a relatively positioned element). In that case, while the adorner is still anchored under
    //  the positioned parent, it is the nearest layout of that positioned parent which handles the
    //  request
    //
    else
    {
        //
        //  Determine if this layout is at a logical top or is a z-parent
        //
        //      1) All clipping  elements mark a logical top
        //      2) The layout is (logically) a z-parent if it is a logical top,
        //         is itself a z-parent, or is the nearest layout to the actual
        //         z-parent
        //

        CDispNode * pElementDispNode = GetElementDispNode();

        BOOL        fAtTop    = (pElementDispNode ? pElementDispNode->IsClipNode() : FALSE);
        BOOL        fZParent  = fAtTop
                        ||  pTreeNode->IsZParent()
                        ||  (   (   !pnf->Element()->IsPositionStatic()
                                ||  pnf->Element()->IsInheritingRelativeness())
                            &&  pnf->Element()->GetFirstBranch()->ZParent()->GetUpdatedNearestLayout() == this);

        if (    fAtTop
            ||  fZParent)
        {
            CAdorner *      pAdorner  = DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr());
            CDispNode *     pDispNode = pAdorner->GetDispNode();
            ADORNERLAYER    adl       = (ADORNERLAYER)(DWORD)(DWORD_PTR)pDispNode->GetExtraCookie();

            fHandle =   (   adl == ADL_ALWAYSONTOP
                        &&  fAtTop)
                    ||  (   adl == ADL_ONELEMENT
                        &&  fZParent)
                    ||  adl == ADL_TOPOFFLOW;
        }
    }

    if (fHandle)
    {
        if (!TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS))
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Request: Queuing RF_ADDADORNERS on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandleAddAdornerNotification() [n=%S srcelem=0x%x,%S]",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber,
                        pnf->Name(),
                        pnf->Element(),
                        pnf->Element() ? pnf->Element()->TagName() : _T("")));
            CRequest *  pRequest = QueueRequest(CRequest::RF_ADDADORNER, pnf->Element());

            if (pRequest)
            {
                pRequest->SetAdorner(DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr()));
            }
        }
        else
        {
            HandleAddAdornerRequest(DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr()));
        }
    }

    return fHandle;
}

void
CLayout::HandleAddAdornerRequest(
    CAdorner *  pAdorner)
{
    Assert(pAdorner);
    Assert(pAdorner->GetElement());
    Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    Assert(GetElementDispNode());
    Assert(TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS));
#if DBG==1
    {
        long    cp  = pAdorner->GetElement()->GetFirstCp() - GetContentFirstCp();
        long    cch = pAdorner->GetElement()->GetElementCch();

        Assert( !IsDirty()
            ||  (   IsFlowLayout()
                &&  DYNCAST(CFlowLayout, this)->IsRangeBeforeDirty(cp, cch)));
    }
#endif

    TraceTagEx((tagLayoutAdornerReqs, TAG_NONAME, "Layout Adorner Reqs: HandleAddAdornerRequest() called"));

    CDispNode * pDispAdorner = pAdorner->GetDispNode();
    CElement *  pElement     = pAdorner->GetElement();

    if (pDispAdorner)
    {
        switch ((ADORNERLAYER)(DWORD)(DWORD_PTR)pDispAdorner->GetExtraCookie())
        {

        //
        //  Anchor "always on top" adorners as the last node(s) of the current postive-z layer
        //

        default:
        case ADL_ALWAYSONTOP:
            {
                CDispParentNode *   pDispParent = EnsureDispNodeIsContainer();
                Assert (pDispParent);
                pDispParent->InsertChildInZLayer(pDispAdorner, pAdorner->GetZOrderForSelf(pDispAdorner));
            }
            break;

        //
        //  Anchor adorners that sit on the element as the element's next sibling
        //

        case ADL_ONELEMENT:
            {
                Assert(pElement->GetUpdatedNearestLayout());
                Assert(pElement->GetUpdatedNearestLayout()->GetElementDispNode(pElement));

                CLayout *   pLayout   = pElement->GetUpdatedNearestLayout();
                CDispNode * pDispNode = pLayout->GetElementDispNode(pElement);

                if (pDispNode && pDispNode->HasParent())
                {
                    pDispNode->InsertSiblingNode(pDispAdorner, CDispNode::after);
                }
            }
            break;

        //
        //  Anchor "top of flow" adorners in the flow layer of this layout or
        //  the element's positioned z-parent, whichever is closer
        //  (In either case, this layout "owns" the display node under which the
        //   adorner is added)
        //

        case ADL_TOPOFFLOW:
            {
                CElement *          pElementParent = pElement->GetFirstBranch()->ZParent();
                CDispParentNode * pDispParent;

                Assert( pElementParent == ElementOwner()
                    ||  pElementParent->IsPositionStatic()
                    ||  (   pElementParent->GetFirstBranch()->GetCascadedposition() == stylePositionrelative
                        &&  !pElementParent->GetUpdatedLayout()
                        &&  pElementParent->GetUpdatedNearestLayout() == this));

                if (pElementParent->IsPositionStatic())
                {
                    pElementParent = ElementOwner();
                }

                pDispParent = pElementParent->GetUpdatedNearestLayout()->EnsureDispNodeIsContainer(pElementParent);

                if (pDispParent)
                {
                    pDispParent->InsertChildInFlow(pDispAdorner);
                }
            }
            break;
        }

        pAdorner->PositionChanged();
    }
}
#endif // ADORNERS

HRESULT
CLayout::OnPropertyChange(DISPID dispid, DWORD dwFlags)
{
    HRESULT hr = S_OK;;

    switch(dispid)
    {
    case DISPID_A_OVERFLOW:
    case DISPID_A_OVERFLOWY:
    case DISPID_A_SCROLL   :
        // Reset this flag. Will get set if necessary in
        // the next calc pass.
        _fNeedRoomForVScrollBar = FALSE;
        break;

    case DISPID_UNKNOWN:
    case DISPID_CElement_className:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        EnsureDispNodeBackground();
        break;
    }

    RRETURN(hr);
}

CMarkup *
CLayout::GetOwnerMarkup() const
{
    // get the owner's Markup
    Assert( _pMarkupDbg == (_fHasMarkupPtr ? _pMarkup : NULL ) );
    return _fHasMarkupPtr ? _pMarkup : NULL;
}

void
CLayout::DelMarkupPtr()
{
    Assert(_fHasMarkupPtr);
    Assert( _pMarkup == _pMarkupDbg);
    WHEN_DBG(_pMarkupDbg = NULL );

    // Delete out CMarkup *
    _pDoc = _pMarkup->Doc();
    _fHasMarkupPtr = FALSE;
}

void
CLayout::SetMarkupPtr(CMarkup *pMarkup)
{
    Assert( !_fHasMarkupPtr );
    Assert( pMarkup );
    Assert( pMarkup->Doc() == _pDocDbg );

     _pMarkup = pMarkup;
     WHEN_DBG( _pMarkupDbg = pMarkup );
     _fHasMarkupPtr = TRUE;
}

CMarkup *
CLayout::GetContentMarkup() const
{
    if (ElementOwner()->HasSlavePtr())
    {
        return ElementOwner()->GetSlavePtr()->GetMarkup();
    }
    // get the owner's Markup
    Assert( _pMarkupDbg == (_fHasMarkupPtr ? _pMarkup : NULL ) );
    return _fHasMarkupPtr ? _pMarkup : NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for an element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CLayout::RegionFromElement( CElement * pElement,
                            CDataAry<RECT> * paryRects,
                            RECT * prcBound,
                            DWORD  dwFlags)
{
    Assert( pElement && paryRects);

    if (!pElement || !paryRects)
        return;

    // if the element passed is the element that owns this instance,
    if ( _pElementOwner == pElement )
    {
        CRect rect;

        if (!prcBound)
        {
            prcBound = &rect;
        }

        // If the element is not shown, bounding rectangle is all zeros.
        if ( pElement->IsDisplayNone() )
        {
            // return (0,0,0,0) if the display is set to 'none'
            *prcBound = g_Zero.rc;
        }
        else
        {
            // return the rectangle that this CLayout covers
            GetRect( prcBound, dwFlags & RFE_SCREENCOORD
                                ? COORDSYS_GLOBAL
                                : COORDSYS_PARENT);
        }

        paryRects->AppendIndirect(prcBound);
    }
    else
    {
        // we should not reach here, since anything that can have children
        // is actually a flow layout (or a table thingy) since the CLayout does not know how
        // to wrap text.
        //(dmitryt) commenting this out - script can easily ask for offsetWidth of <BR>,
        // no need to assert here.
        //AssertSz( FALSE, "CLayout::RegionFromElement should not be called");
        if(prcBound)
            *prcBound = g_Zero.rc;
   }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyMeasuredRange
//
//  Synopsis:   Send a measured range notification
//
//  Arguments:  cpStart - Starting cp of range
//              cpEnd   - Ending cp of range
//
//----------------------------------------------------------------------------

void
CLayout::NotifyMeasuredRange(
    long    cpStart,
    long    cpEnd)
{
    CNotification   nf;

    Assert( cpStart >= 0
        &&  cpEnd   >= 0);

    nf.MeasuredRange(cpStart, cpEnd - cpStart);

    GetView()->Notify(&nf);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyTranslatedRange
//
//  Synopsis:   Send a translated range notification
//
//  Arguments:  size    - Size of translation
//              cpStart - Starting cp of range
//              cpEnd   - Ending cp of range
//
//----------------------------------------------------------------------------

void
CLayout::NotifyTranslatedRange(
    const CSize &   size,
    long            cpStart,
    long            cpEnd)
{
    CNotification   nf;
    BOOL fIsMaster = ElementOwner()->HasSlavePtr();

    if (fIsMaster)
    {
        cpStart = GetContentFirstCp();
        cpEnd = GetContentLastCp();
    }

    Assert( cpStart >= 0
        &&  cpEnd   >= 0);
    Assert(cpEnd >= cpStart);

    nf.TranslatedRange(cpStart, cpEnd - cpStart);
    nf.SetData(size);

    if (_fAutoBelow && !fIsMaster)
    {
        Assert(GetContentMarkup());
        GetContentMarkup()->Notify(&nf);
    }

    GetView()->Notify(&nf);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ComponentFromPoint
//
//  Synopsis:   Return the component hit by this point.
//
//  Arguments:  x,y     coordinates of point
//
//  Returns:    the component that was hit
//
//  Notes:
//
//----------------------------------------------------------------------------

_htmlComponent
CLayout::ComponentFromPoint(long x, long y)
{
    CDispNode *pdn = _pDispNode;

    if (pdn)
    {
        CPoint pt;
        pdn->TransformPoint(
            CPoint(x,y),
            COORDSYS_GLOBAL,
            &pt,
            COORDSYS_BOX);

        CRect rcContainer(pdn->GetSize());
        if (rcContainer.Contains(pt))
        {
            if (pdn->IsScroller())
            {
                CRect rcScrollbar;
                CScrollbar::SCROLLBARPART part;
                CDispScroller* pScroller = DYNCAST(CDispScroller, pdn);
                const CSize& sizeContent = pScroller->GetContentSize();
                CSize sizeOffset;
                pScroller->GetScrollOffset(&sizeOffset);

                CFormDrawInfo DI;
                DI.Init(this);

                // check vertical scrollbar
                pScroller->GetClientRect(&rcScrollbar, CLIENTRECT_VSCROLLBAR);
                part = CScrollbar::GetPart(
                    1,
                    rcScrollbar,
                    pt,
                    sizeContent.cy,
                    rcScrollbar.Height(),
                    sizeOffset.cy,
                    rcScrollbar.Width(),
                    &DI);

                switch (part)
                {
                case CScrollbar::SB_PREVBUTTON: return htmlComponentSbUp;
                case CScrollbar::SB_NEXTBUTTON: return htmlComponentSbDown;
                case CScrollbar::SB_PREVTRACK:  return htmlComponentSbPageUp;
                case CScrollbar::SB_NEXTTRACK:  return htmlComponentSbPageDown;
                case CScrollbar::SB_THUMB:      return htmlComponentSbVThumb;
                }

                // check horizontal scrollbar
                pScroller->GetClientRect(&rcScrollbar, CLIENTRECT_HSCROLLBAR);
                part = CScrollbar::GetPart(
                    0,
                    rcScrollbar,
                    pt,
                    sizeContent.cx,
                    rcScrollbar.Width(),
                    sizeOffset.cx,
                    rcScrollbar.Height(),
                    &DI);

                switch (part)
                {
                case CScrollbar::SB_PREVBUTTON: return htmlComponentSbLeft;
                case CScrollbar::SB_NEXTBUTTON: return htmlComponentSbRight;
                case CScrollbar::SB_PREVTRACK:  return htmlComponentSbPageLeft;
                case CScrollbar::SB_NEXTTRACK:  return htmlComponentSbPageRight;
                case CScrollbar::SB_THUMB:      return htmlComponentSbHThumb;
                }
            }

            return htmlComponentClient;
        }
    }

    return htmlComponentOutside;
}

//+====================================================================================
//
// Method: ShowSelected
//
// Synopsis: The "selected-ness" of this layout has changed. We need to set it's
//           properties, and invalidate it.
//
//------------------------------------------------------------------------------------

VOID
CLayout::ShowSelected(
                        CTreePos* ptpStart,
                        CTreePos* ptpEnd,
                        BOOL fSelected,
                        BOOL fLayoutCompletelyEnclosed )
{
    SetSelected( fSelected, TRUE );
}

//+====================================================================================
//
// Method:  SetSelected
//
// Synopsis:Set the Text Selected ness of the layout
//
//------------------------------------------------------------------------------------


VOID
CLayout::SetSelected( BOOL fSelected , BOOL fInvalidate )
{
    // select the element
    const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();

    // Set the site text selected bits appropriately
    SetSiteTextSelection (
        fSelected,
        pCF->SwapSelectionColors());

    if ( fInvalidate )
        Invalidate();
}

//+====================================================================================
//
// Method:  GetContentRect
//
// Synopsis:Get the content rect in the specified coordinate system
//
//------------------------------------------------------------------------------------
void
CLayout::GetContentRect(CRect *prc, COORDINATE_SYSTEM cs)
{
    CPoint ptTopLeft(0,0);
    CSize  sizeLayout;
    RECT   rcClient;
    CDispNode * pDispNode;

    TransformPoint(&ptTopLeft, COORDSYS_FLOWCONTENT, cs);
    GetContentSize(&sizeLayout);
    pDispNode = GetElementDispNode();



    prc->left   = ptTopLeft.x;
    prc->right  = prc->left + sizeLayout.cx;
    prc->top    = ptTopLeft.y;
    prc->bottom = prc->top + sizeLayout.cy;

    GetClientRect(&rcClient, cs);
    prc->Union(rcClient);
}

#if DBG==1
BOOL CLayout::ContainsNonHiddenChildLayout()
{
    BOOL fHasNonHiddenLayout = FALSE;
    DWORD_PTR dw=0;
    BOOL fRaw = FALSE;

    CLayout * pLayout = GetFirstLayout(&dw, FALSE, fRaw);
    while (pLayout)
    {
        if (!pLayout->IsDisplayNone())
        {
            fHasNonHiddenLayout = TRUE;
            break;
        }
        pLayout = GetNextLayout(&dw, FALSE, fRaw);
    }
    ClearLayoutIterator(dw, fRaw);
    return fHasNonHiddenLayout;
}
#endif

void
CLayout::PhysicalGlobalToPhysicalLocal(const CPoint &ptGlobalPhysical, CPoint *pptLocalPhysical)
{
    CElement  *pElement  = ElementOwner();
    CDispNode *pDispNode = GetElementDispNode();
    CPoint ptLocalLogical;
    CPoint ptClient;
    CPoint ptGlobalPhysicalHacked(ptGlobalPhysical);

    //
    // The point coming in is relative to the top/left of the frame. We need it relative to
    // the top/left of the root document.
    //
    pElement->GetClientOrigin(&ptClient);
    ptGlobalPhysicalHacked += ptClient.AsSize();


    //---------------------------------------------------------------------------------
    //
    // HACK BEGIN
    //
    // This hack is to mirror the hack in GetPosition. The problem is that the disp nodes for TR's are, for some
    // wierd reason (a this is where the real problem is), not positioned appropriately. I believe, that is to
    // have the cells position off of the table rather than the TR. But that nonsense causes us problems
    // every where we make transformations like these.
    //
    if (ETAG_TR == pElement->Tag())
    {
        CTreeNode *pNode = pElement->GetFirstBranch();
        CElement  *pElementZParent = pNode->ZParent();

        if (pElementZParent)
        {
            CLayout   *pParentLayout = pElementZParent->GetUpdatedNearestLayout();
            CDispNode *pDispNodeNew = pParentLayout->GetElementDispNode(pElementZParent);

            if (pDispNodeNew)
            {
                pElement = pElementZParent;
                pDispNode = pDispNodeNew;
            }
        }
    }
    //
    // This hack is there to support borders on selects. The problem is that for selects,
    // the display tree is unaware of the border. The old code used to manually remove the
    // border widths, now we depend on the display tree to do so. However, in this case
    // the display tree does not know about the borders and hence they need to be removed
    // manually, just like the old code. However, this causes a bug when we have border
    // set to something other than 2 on the style sheet -- the select control completely
    // ignores it, while the code which computes the offset* values pays attention to it.
    // To see what I am talking about here, load this page, and hover over the select
    // border and look at the offset* values you get back ...
    //
    // <select style="border:1000px solid red"><option>helloworld</option></select>
    //
    // Vertical layout does not matter since select is always horizontal.
    //
    else if (ETAG_SELECT == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptGlobalPhysicalHacked.x -= bi.aiWidths[SIDE_LEFT];
        ptGlobalPhysicalHacked.y -= bi.aiWidths[SIDE_TOP];
    }

    //
    // Yet another hack caused because of the possibility of 2 display nodes for tables.
    // The outer display node does not exhibit the borders which causes our current scheme
    // to fail. The correct thing would be to use the appropriate table display node
    // based on the y value coming in. But IE5 did not do it ...
    //
    if (ETAG_TABLE == pElement->Tag())
    {
        CBorderInfo bi;
        pDispNode->TransformPoint(ptGlobalPhysicalHacked, COORDSYS_GLOBAL,
                                  &ptLocalLogical,        COORDSYS_BOX);
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalLogical.x -= bi.aiWidths[SIDE_LEFT];
        ptLocalLogical.y -= bi.aiWidths[SIDE_TOP];
    }
    //
    // END HACK
    //
    //---------------------------------------------------------------------------------
    else
    {
        pDispNode->TransformPoint(ptGlobalPhysicalHacked, COORDSYS_GLOBAL,
                                  &ptLocalLogical,        COORDSYS_CONTENT);
    }

    if (!pElement->HasVerticalLayoutFlow())
    {
        *pptLocalPhysical = ptLocalLogical;
    }
    else
    {
        CSize sz;

        GetContentSize(&sz, FALSE);
        pptLocalPhysical->y = ptLocalLogical.x;
        pptLocalPhysical->x = sz.cy - ptLocalLogical.y;
    }
}

void
CLayout::PhysicalLocalToPhysicalGlobal(const CPoint &ptLocalPhysical, CPoint *pptGlobalPhysical)
{
    CElement  *pElement  = ElementOwner();
    CDispNode *pDispNode = GetElementDispNode();
    CPoint ptLocalLogical;
    CPoint ptLocalPhysicalHacked(ptLocalPhysical);
    CPoint ptClient;

    //---------------------------------------------------------------------------------
    //
    // HACK BEGIN
    //
    // This hack is to mirror the hack in GetPosition. The problem is that the disp nodes for TR's are, for some
    // wierd reason (a this is where the real problem is), not positioned appropriately. I believe, that is to
    // have the cells position off of the table rather than the TR. But that nonsense causes us problems
    // every where we make transformations like these.
    //
    if (ETAG_TR == pElement->Tag())
    {
        CTreeNode *pNode = pElement->GetFirstBranch();
        CElement  *pElementZParent = pNode->ZParent();

        if (pElementZParent)
        {
            CLayout   *pParentLayout = pElementZParent->GetUpdatedNearestLayout();
            CDispNode *pDispNodeNew = pParentLayout->GetElementDispNode(pElementZParent);

            if (pDispNodeNew)
            {
                pElement = pElementZParent;
                pDispNode = pDispNodeNew;
            }
        }
    }
    //
    // This hack is there to support borders on selects. The problem is that for selects,
    // the display tree is unaware of the border. The old code used to manually remove the
    // border widths, now we depend on the display tree to do so. However, in this case
    // the display tree does not know about the borders and hence they need to be removed
    // manually, just like the old code. However, this causes a bug when we have border
    // set to something other than 2 on the style sheet -- the select control completely
    // ignores it, while the code which computes the offset* values pays attention to it.
    // To see what I am talking about here, load this page, and hover over the select
    // border and look at the offset* values you get back ...
    //
    // <select style="border:1000px solid red"><option>helloworld</option></select>
    //
    // Vertical layout does not matter since select is always horizontal.
    //
    else if (ETAG_SELECT == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalPhysicalHacked.x += bi.aiWidths[SIDE_LEFT];
        ptLocalPhysicalHacked.y += bi.aiWidths[SIDE_TOP];
    }
    //
    // END HACK
    //
    //---------------------------------------------------------------------------------


    if (!pElement->HasVerticalLayoutFlow())
    {
        ptLocalLogical = ptLocalPhysicalHacked;
    }
    else
    {
        CSize sz;

        GetContentSize(&sz, FALSE);
        ptLocalLogical.x = ptLocalPhysicalHacked.y;
        ptLocalLogical.y = sz.cy - ptLocalPhysicalHacked.x;
    }

    //
    // Yet another hack caused because of the possibility of 2 display nodes for tables.
    // The outer display node does not exhibit the borders which causes our current scheme
    // to fail. The correct thing would be to use the appropriate table display node
    // based on the y value coming in. But IE5 did not do it ...
    //
    if (ETAG_TABLE == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalLogical.x += bi.aiWidths[SIDE_LEFT];
        ptLocalLogical.y += bi.aiWidths[SIDE_TOP];
        pDispNode->TransformPoint(ptLocalLogical,    COORDSYS_BOX,
                                  pptGlobalPhysical, COORDSYS_GLOBAL);
    }
    else
    {
        pDispNode->TransformPoint(ptLocalLogical,    COORDSYS_CONTENT,
                                  pptGlobalPhysical, COORDSYS_GLOBAL);
    }

    //
    // We need to return the point relative to the frame top/left. Converting to coordsys_global
    // takes us relative to the top/left of the root document. We need to transform it by the
    // frame's origin to get it relative to the frame.
    //
    pElement->GetClientOrigin(&ptClient);
    *pptGlobalPhysical -= ptClient.AsSize();
}

BOOL
CLayout::IsEditable(BOOL fCheckContainerOnly, BOOL fUseSlavePtr)
{
    HRESULT                 hr = S_OK;
    BOOL                    fIsEditable = FALSE;
    CElement                *pElement = ElementOwner();
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLElement            *pSlaveElement = NULL;
    IHTMLElement            *pTestElement = NULL;
    IMarkupPointer          *pStartPointer = NULL;
    IMarkupPointer          *pEndPointer = NULL;

    if (fUseSlavePtr && pElement->HasSlavePtr() &&
        (pElement->Tag() == ETAG_GENERIC || pElement->Tag() == ETAG_IFRAME))
    {
        CDoc            *pDoc  = Doc();
        CElement        *pSlave = ElementOwner()->GetSlavePtr();
        CElement        *pTest = NULL;

        hr = THR( pSlave->QueryInterface(IID_IHTMLElement, (void **)&pSlaveElement) );
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->CreateMarkupPointer(&pStartPointer) );
        if (hr)
            goto Cleanup;
        hr = THR( pDoc->CreateMarkupPointer(&pEndPointer) );
        if (hr)
            goto Cleanup;

        Assert(pSlaveElement);

        hr = THR( pDoc->GetEditingServices(& pEdServices ));
        if (hr)
            goto Cleanup;
        pEdServices->PositionPointersInMaster(pSlaveElement, pStartPointer, pEndPointer);

        hr = THR( pStartPointer->CurrentScope(&pTestElement) );
        if (hr || pTestElement == NULL)
            goto Cleanup;
        hr = THR( pTestElement->QueryInterface(CLSID_CElement, (void**)&pTest) );
        if (hr)
            goto Cleanup;

        Assert(pTest);
        fIsEditable = pTest->IsEditable(fCheckContainerOnly FCCOMMA LC_TO_FC(LayoutContext()));
    }
    else
    {
        fIsEditable = ElementOwner()->IsEditable(fCheckContainerOnly FCCOMMA LC_TO_FC(LayoutContext()));
    }

Cleanup:
    ReleaseInterface(pTestElement);
    ReleaseInterface(pSlaveElement);
    ReleaseInterface(pEdServices);
    ReleaseInterface(pStartPointer);
    ReleaseInterface(pEndPointer);

    return fIsEditable;
}

//+====================================================================================
//
// CLayoutContext methods
//
//------------------------------------------------------------------------------------
BOOL
CLayoutContext::IsEqual( CLayoutContext *pOtherLayoutContext ) const
{
    return ( this == pOtherLayoutContext );
}

CLayoutContext::CLayoutContext( CLayout *pLayoutOwner )
{
    Assert(pLayoutOwner);
    Assert( pLayoutOwner->ElementOwner()->IsLinkedContentElement()
            || !FormsStringICmp(pLayoutOwner->ElementOwner()->TagName(), _T("DEVICERECT")) );

    _cRefs = 0;
    _pLayoutOwner = pLayoutOwner;

    // inherit resolution from parent layout context.
    // If the owner layout defines its own media, it will override this setting
    CLayoutContext *pContainingLayoutContext = pLayoutOwner->LayoutContext();
    Assert( pContainingLayoutContext ? pContainingLayoutContext->IsValid() : TRUE );

    _media = pContainingLayoutContext
           ? pContainingLayoutContext->GetMedia()
           : mediaTypeNotSet;

#ifdef MULTI_FORMAT
    _pFormatContext = new CFormatContext(this);
#endif
}

CLayoutContext::~CLayoutContext()
{
    Assert( !_pLayoutOwner );    // Owner should have been NULLed out by now

#ifdef MULTI_FORMAT
    delete _pFormatContext;
#endif

}

//+====================================================================================
//
// Method:  GetLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::GetLayoutBreak(CElement *pElement, CLayoutBreak **ppLayoutBreak)
{
    Assert(ppLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (pViewChain)
    {
        return pViewChain->GetLayoutBreak(this, pElement, ppLayoutBreak, FALSE);
    }

    *ppLayoutBreak = NULL;
    return S_OK;
}

//+====================================================================================
//
// Method:  GetEndingLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::GetEndingLayoutBreak(CElement *pElement, CLayoutBreak **ppLayoutBreak)
{
    Assert(ppLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (pViewChain)
    {
        return pViewChain->GetLayoutBreak(this, pElement, ppLayoutBreak, TRUE);
    }

    *ppLayoutBreak = NULL;
    return S_OK;
}

//+====================================================================================
//
// Method:  SetLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::SetLayoutBreak(CElement *pElement, CLayoutBreak *pLayoutBreak)
{
    HRESULT         hr = S_OK;

    Assert(pElement && pLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (!pViewChain)
    {
        AssertSz(0, "SetLayoutBreak is called on a context with no chain");
        delete pLayoutBreak;
        return S_FALSE;
    }

    hr = pViewChain->SetLayoutBreak(this, pElement, pLayoutBreak);
    if (hr)
    {
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method:  RemoveLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::RemoveLayoutBreak(CElement *pElement)
{
    HRESULT hr = S_OK;

    Assert(pElement);

    CViewChain *pViewChain = ViewChain();
    if (!pViewChain)
    {
        AssertSz(0, "RemoveLayoutBreak is called on a context with no chain");
        return S_FALSE;
    }

    hr = pViewChain->RemoveLayoutBreak(this, pElement);
    if (hr)
    {
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method:  ViewChain
//
// Synopsis: If this layout context is part of a view chain, this will return it.
//           If a context is invalid, that means it's not part of a view chain.
//           Note that compatible contexts override this fn to always return NULL.
//
//------------------------------------------------------------------------------------
CViewChain *
CLayoutContext::ViewChain()
{
    if ( IsValid() )
    {
        CLayout *pLayout = GetLayoutOwner();
        return pLayout->ViewChain();
    }

    return NULL;
}

//+====================================================================================
//
// Miscelaneous
//
//------------------------------------------------------------------------------------

HRESULT
CLayout::EnsureBgRecalcInfo()
{
    if (HasBgRecalcInfo())
        return S_OK;

    // Table cells don't get a CBgRecalcInfo and that's ok (S_FALSE).
    if (!CanHaveBgRecalcInfo())
        return S_FALSE;

    CBgRecalcInfo * pBgRecalcInfo = new CBgRecalcInfo;
    Assert(pBgRecalcInfo && "Failure to allocate CLayout::CBgRecalcInfo");

    if (pBgRecalcInfo)
    {
        IGNORE_HR( SetLookasidePtr(LOOKASIDE_BGRECALCINFO, pBgRecalcInfo) );
    }

    return pBgRecalcInfo ? S_OK : E_OUTOFMEMORY;
}

void
CLayout::DeleteBgRecalcInfo()
{
    Assert(HasBgRecalcInfo());

    CBgRecalcInfo * pBgRecalcInfo = (CBgRecalcInfo *)DelLookasidePtr(LOOKASIDE_BGRECALCINFO);

    Assert(pBgRecalcInfo);
    if (pBgRecalcInfo)
    {
        delete pBgRecalcInfo;
    }
}

HRESULT
CLayout::SetLayoutContext( CLayoutContext *pLayoutContext )
{
    Assert( !HasLayoutContext() && "A layout shouldn't ever change containing contexts" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    Assert( pLayoutContext->GetLayoutOwner() != this && "You can't possibly own the layout context you're contained within" );
    Assert( ( HasDefinedLayoutContext() ? DefinedLayoutContext() != pLayoutContext : TRUE ) && "You can't be contained within the same layout context you define" );

    // Main body is not supposed to be contained. Try asserting that:
    AssertSz(_pElementOwner->Tag() != ETAG_BODY ||
             pLayoutContext->GetLayoutOwner()->GetContentMarkup() != GetContentMarkup(),
             "Main body is not supposed to use a layout context");

    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_CONTAININGCONTEXT, pLayoutContext);
}

void
CLayout::DeleteLayoutContext()
{
    Assert(HasLayoutContext());

    CLayoutContext * pLayoutContext = (CLayoutContext *)DelLookasidePtr(LOOKASIDE_CONTAININGCONTEXT);

    Assert(pLayoutContext);
    pLayoutContext->Release();
}

HRESULT
CLayout::SetDefinedLayoutContext( CLayoutContext *pLayoutContext )
{
    Assert( !HasDefinedLayoutContext() && "A layout shouldn't ever change the context it defines" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    Assert( pLayoutContext->GetLayoutOwner() == this && "You must own the layout context you define, or it's a working context" );
    Assert( ( HasLayoutContext() ? LayoutContext() != pLayoutContext : TRUE ) && "You can't be contained within the same layout context you define" );

    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_DEFINEDCONTEXT, pLayoutContext);
}

void
CLayout::DeleteDefinedLayoutContext()
{
    Assert(HasDefinedLayoutContext());

    // Make us stop pointing to the context
    CLayoutContext * pLayoutContext = (CLayoutContext *)DelLookasidePtr(LOOKASIDE_DEFINEDCONTEXT);
    AssertSz(pLayoutContext, "Better have a context if we said we had one");
    AssertSz(pLayoutContext->RefCount() > 0, "Context better still be alive");
    AssertSz(pLayoutContext->IsValid(), "Context better still be valid");
    AssertSz(pLayoutContext->GetLayoutOwner() == this, "You must own the layout context you define" );

    // Make the context stop pointing to us
    pLayoutContext->ClearLayoutOwner();

    // This release corresponds to the addref in SetDefinedLayoutContext()
    pLayoutContext->Release();

    // At this point the context may still be alive, since it might have had layouts created in it,
    // which would continue to hold refs, but it's now invalid since the we the definer have gone away.

    // TODO (112486, olego): We should re-think layout context concept 
    // and according to that new understanding correct the code. 

    // We'd like to post a task that will run through the tree looking for such invalid layouts and
    // clean them up, but unfortunately we may be unable to access any elements
    // at this point since everything may be torn down.

    // One soln to this is to implement misc tasks in CView that don't require
    // any objects to execute.  Event tasks are probably out of the question
    // since they need an element.  All the task needs to do is fire an
    // NTYPE_MULTILAYOUT_CLEANUP notification (already ready to go).

    // GetView()->AddEventTask( NULL, DISPID_EVMETH_ONMULTILAYOUTCLEANUP );
}

// TODO (112486, olego): We should re-think layout context concept 
// and according to that new understanding correct the code. 

// (original comment by ktam): Eventually make this a CContainerLayout member instead
// of CLayout; unfortunately for now we need to be able to create context for other
// kinds of layouts (E1D) due to IFRAME hack.
// At that point, also make SetDefinedLayoutContext() a CContainerLayout
// member (same reason).
HRESULT CreateLayoutContext(CLayout * pLayout)
{
    Assert( !pLayout->HasDefinedLayoutContext() && "Can't create a context for a layout that already defines context" );

    // this comes back with a 0 refcount, this is ok because it is addref'd in the
    // SetlayoutContext
    CLayoutContext * pLayoutContext = new CLayoutContext( pLayout );

    Assert(pLayoutContext && "Failure to allocate CLayoutContext");

    if (pLayoutContext)
    {
        return pLayout->SetDefinedLayoutContext( pLayoutContext );
    }

    return E_OUTOFMEMORY;
}

void
CLayout::SetHTILayoutContext( CHitTestInfo *phti )
{
    if ( !HasLayoutContext() )
    {
        Assert( phti->_pLayoutContext == NULL );
        return;
    }

    CLayoutContext *pLayoutContext = LayoutContext();
    Assert( pLayoutContext->GetLayoutOwner() != this );

    // Only set the layout context if it hasn't been done already.
    if ( !phti->_pLayoutContext )
    {
        phti->_pLayoutContext = pLayoutContext;
    }
    // Check that if we've already set context, that we're not
    // trying to change it.
    Assert( phti->_pLayoutContext == pLayoutContext );
}

void
CLayout::SetElementAsBreakable()
{
    CMarkup *  pMarkup;
    CElement * pRoot;
    CElement * pMaster;

    Assert(!ElementCanBeBroken());

    pMarkup = ElementOwner()->GetMarkupPtr();
    if (pMarkup != NULL)
    {
        pRoot = (CElement *)pMarkup->Root();
        Assert(pRoot);
        pMaster = pRoot->HasMasterPtr() ? (CElement *)pRoot->GetMasterPtr() : NULL;

        // Allow to break only content inside layout rect
        SetElementCanBeBroken(pMaster != NULL && pMaster->IsLinkedContentElement());
    }
}


LONG
CLayout::GetCaptionHeight(CElement* pElement)
{
    LONG               lHeightCaption = 0;
    IHTMLTableCaption *pICaption = NULL;
    IHTMLElement      *pICaptionElement = NULL;
    IHTMLTable        *pITable = NULL  ;
    IHTMLElement      *pIElement = NULL;

    if (SUCCEEDED(pElement->QueryInterface(IID_IHTMLElement, (void**)&pIElement)))
    {
        if (SUCCEEDED(ElementOwner()->QueryInterface(IID_IHTMLTable , (void**)&pITable)))
        {
            if (SUCCEEDED(pITable->get_caption(&pICaption)))
            {
                if (pICaption != NULL)
                {
                    if (SUCCEEDED(pICaption->QueryInterface(IID_IHTMLElement , (void**)&pICaptionElement)))
                    {
                        pICaptionElement->get_offsetHeight(&lHeightCaption);
                    }
                    ReleaseInterface(pICaptionElement);
                }
            }
            ReleaseInterface(pICaption);
        }
        ReleaseInterface(pITable);
    }
    ReleaseInterface(pIElement);

    return (lHeightCaption);
}

BOOL
CLayout::IsShowZeroBorderAtDesignTime()
{
    CMarkup *pMarkup = GetContentMarkup();
    if (pMarkup != NULL)
    {
        return pMarkup->IsShowZeroBorderAtDesignTime();
    }
    else
    {
        return FALSE;
    }
}

void
CLayout::AdjustBordersForBreaking( CBorderInfo *pBI )
{
    CLayoutContext *pLayoutContext = LayoutContext();
    CElement       *pElementOwner;
    BOOL            fLayoutFlowVertical;

    if (   !pLayoutContext
        || !pLayoutContext->ViewChain()
        || !ElementCanBeBroken() )
    {
        return;
    }

    pElementOwner = ElementOwner();
    fLayoutFlowVertical = pElementOwner->HasVerticalLayoutFlow();

    Assert(pElementOwner);
    if (!pLayoutContext->IsElementFirstBlock(pElementOwner))
    {
        if (fLayoutFlowVertical)
        {
            pBI->wEdges &= ~BF_LEFT;
        }
        else
        {
            pBI->wEdges &= ~BF_TOP;
        }
    }

    if (!pLayoutContext->IsElementLastBlock(pElementOwner))
    {
        if (fLayoutFlowVertical)
        {
            pBI->wEdges &= ~BF_RIGHT;
        }
        else
        {
            pBI->wEdges &= ~BF_BOTTOM;
        }
    }
}

void
CLayout::AddDispNodeToArray(CDispNode *pNewDispNode)
{
    AssertSz(HasLayoutContext(), "Illegal to call CLayout::AddDispNodeToArray in non PPV.");
    Assert(_pDispNode && pNewDispNode && _pDispNode != pNewDispNode);

    CAryDispNode *pDispNodeArray = DispNodeArray();

    if (!pDispNodeArray)
    {
        pDispNodeArray = new CAryDispNode();

        if (    !pDispNodeArray
            ||  !SUCCEEDED(SetDispNodeArray(pDispNodeArray )))
        {
            delete pDispNodeArray;
            goto Error;
        }
    }

    AssertSz(pDispNodeArray, "No disp node array was created." );
    AssertSz(HasDispNodeArray(), "No disp node array was added to lookaside ptr.");
    AssertSz(pDispNodeArray == DispNodeArray(), "Pointers do NOT match.");

    if (!SUCCEEDED(pDispNodeArray->Append(_pDispNode)))
    {
        goto Error;
    }

    _pDispNode = pNewDispNode;

Error:
    return;
}

void
CLayout::DestroyDispNodeArray()
{
    if (HasDispNodeArray())
    {
        Assert(HasLayoutContext());

        CAryDispNode * pDispNodeArray = DeleteDispNodeArray();
        CDispNode **   ppDispNode;
        int            cDispNodes;

        for (ppDispNode = &pDispNodeArray->Item(0), cDispNodes = pDispNodeArray->Size();
             cDispNodes;
             ppDispNode++, cDispNodes--)
        {
            DetachScrollbarController(*ppDispNode);
            Verify(OpenView());
            (*ppDispNode)->Destroy();
        }

        delete pDispNodeArray;
    }
}

// ComputeMBPWidthHelper walks up document tree and accumulates MBP for all 
// block elements between this layout and pFlowLayoutParent. 
long 
CLayout::ComputeMBPWidthHelper(CCalcInfo *pci, CFlowLayout *pFlowLayoutParent)
{
    Assert(pci && pFlowLayoutParent);

    long        cxWidthDelta = 0;
    CTreeNode * pNodeCur;
    CTreeNode * pNodeParent;
    long        cxParentWidth = pci->_sizeParent.cx;

    if (    !ElementOwner()->HasMarkupPtr() 
        ||  !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() )
    {
        // This function is called in CSS compliant mode from CFlowLayout::MeasureSite for embedded layouts to walk up the tree 
        // and sum up mbp (In IE compatible mode we only considered the (m)bp of the outer layout. I.e. we don't collapse mbp for
        // nested blocks.
        // When we come in this situation our layout belongs to an viewlink which has a differnt markup which is not under CSS
        // compliant dts. In this case we want to behave like before and we simply return 0. Going to Cleanup does it.
        goto Cleanup;
    }

    pNodeParent = pFlowLayoutParent->GetFirstBranch();
    pNodeCur    = GetFirstBranch();
    
    if (!pNodeParent || !pNodeCur)
    {
        goto Cleanup;
    }

    // 
    // The loop to iterate parent branch up the tree
    // 
    for (pNodeCur = pNodeCur->Parent(); pNodeCur && pNodeCur != pNodeParent; pNodeCur = pNodeCur->Parent())
    {
        CElement * pElement = pNodeCur->Element();

        Check(pElement && !pElement->ShouldHaveLayout());

        if (pElement && pElement->IsBlockElement())
        {
            CBorderInfo bi;

            if (pElement->GetBorderInfo(pci, &bi, FALSE, TRUE))
            {
                cxWidthDelta += bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
            }

            if (pElement->Tag() != ETAG_TC)
            {
                // we are interested in physical MBP, thus there is no need to call logical 
                // versions of methods...
                const CFancyFormat * pFF = pNodeCur->GetFancyFormat(LC_TO_FC(LayoutContext()));
                const CCharFormat  * pCF = pNodeCur->GetCharFormat(LC_TO_FC(LayoutContext()));
                long lFontHeight         = pCF->GetHeightInTwips(pNodeCur->Doc());
                const CUnitValue & cuvPaddingLeft   = pFF->GetPadding(SIDE_LEFT);
                const CUnitValue & cuvPaddingRight  = pFF->GetPadding(SIDE_RIGHT);
                const CUnitValue & cuvMarginLeft    = pFF->GetMargin(SIDE_LEFT);
                const CUnitValue & cuvMarginRight   = pFF->GetMargin(SIDE_RIGHT);

                cxWidthDelta +=   cuvPaddingLeft.XGetPixelValue(pci, cxParentWidth, lFontHeight) 
                                + cuvPaddingRight.XGetPixelValue(pci, cxParentWidth, lFontHeight)
                                + cuvMarginLeft.XGetPixelValue(pci, cxParentWidth, lFontHeight) 
                                + cuvMarginRight.XGetPixelValue(pci, cxParentWidth, lFontHeight);
            }
        }
    }

Cleanup:

    return (cxWidthDelta);
}

#if DBG
void
CLayout::DumpLayoutInfo( BOOL fDumpLines )
{
    WriteHelp(g_f, _T(" Layout (T=<0d>): 0x<1x> DC=0x<2x> CC=0x<3x>\r\n"),
              (long)_layoutType, this, DefinedLayoutContext(),
              LayoutContext() );
}

void
CLayout::SetSizeThis( unsigned u )
{
    _fSizeThis = u;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\marqlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       marqlyt.cxx
//
//  Contents:   Implementation of CMarqueeLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#include "marqlyt.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif


MtDefine(CMarqueeLayout, Layout, "CMarqueeLayout")

const CLayout::LAYOUTDESC CMarqueeLayout::s_layoutdesc =
{
    LAYOUTDESC_NOSCROLLBARS |
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CMarqueeLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    // Marquee can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CMarqueeLayout::GetMarginInfo(CParentInfo * ppri,
                              LONG        * plLMargin,
                              LONG        * plTMargin,
                              LONG        * plRMargin,
                              LONG        * plBMargin)
{
    super::GetMarginInfo(ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    CMarquee * pMarquee  = DYNCAST(CMarquee, ElementOwner());
    BOOL fParentVertical = pMarquee->GetFirstBranch()->IsParentVertical();
    LONG lhMargin = fParentVertical ? pMarquee->GetAAvspace() : pMarquee->GetAAhspace();
    LONG lvMargin = fParentVertical ? pMarquee->GetAAhspace() : pMarquee->GetAAvspace();

    if (lhMargin < 0)
        lhMargin = 0;
    if (lvMargin < 0)
        lvMargin = 0;

    lhMargin = ppri->DeviceFromDocPixelsX(lhMargin);
    lvMargin = ppri->DeviceFromDocPixelsY(lvMargin);

    if (plLMargin)
        *plLMargin += lhMargin;
    if (plRMargin)
        *plRMargin += lhMargin;
    if (plTMargin)
        *plTMargin += lvMargin;
    if (plBMargin)
        *plBMargin += lvMargin;
}

void CMarqueeLayout::GetDefaultSize(CCalcInfo *pci, SIZE &szMarquee, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    if ( pMarquee->_direction == htmlMarqueeDirectionup
            ||  pMarquee->_direction == htmlMarqueeDirectiondown)
    {
       szMarquee.cy = pci->DeviceFromDocPixelsY(200);
       *fHasDefaultHeight = TRUE;
    }
    else
    {
       szMarquee.cy = 0;
    }
}

void CMarqueeLayout::GetScrollPadding(SIZE &szMarquee)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    if ( pMarquee->_direction == htmlMarqueeDirectionup
            ||  pMarquee->_direction == htmlMarqueeDirectiondown)
    {
        szMarquee.cx = 0;
        pMarquee->_lXMargin = 0;
        pMarquee->_lYMargin = szMarquee.cy;
            
        GetDisplay()->SetWordWrap(TRUE);

    }
    else
    {
        szMarquee.cy = 0;
        pMarquee->_lYMargin = 0;
        pMarquee->_lXMargin = szMarquee.cx;

        GetDisplay()->SetWordWrap(FALSE);
    }
}

void CMarqueeLayout::SetScrollPadding(SIZE &szMarquee, SIZE &sizeText, SIZE &sizeBorder)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    pMarquee->_sizeScroll.cx    = sizeText.cx - sizeBorder.cx;
    pMarquee->_sizeScroll.cy    = sizeText.cy - sizeBorder.cy;
    pMarquee->_fToBigForSwitch  = (sizeText.cx-szMarquee.cx*2) >= szMarquee.cx;

    pMarquee->InitScrollParams();
}

void CMarqueeLayout::CalcTextSize(CCalcInfo *pci, SIZE *psize, SIZE *psizeDefault)
{
    if (   pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH)
    {
        const CFancyFormat * pFF     = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF     = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);

        if  ( cuvWidth.IsNullOrEnum())
        {
            psize->cx = 0;
            psize->cy = 0;
        }
    }
    else
    {
        super::CalcTextSize(pci, psize, psizeDefault);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\lrreg.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Layout Rect Registry implementation
//

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"
#endif

MtDefine(CLayoutRectRegistry, Mem, "CLayoutRectRegistry");
MtDefine(CLayoutRectRegistry_aryLRRE_pv, CLayoutRectRegistry, "CLayoutRectRegistry::_aryLRRE::_pv");

/////////////////////////////////////////////////
// CLayoutRectRegistry

CLayoutRectRegistry::~CLayoutRectRegistry()
{
    int nEntries = _aryLRRE.Size();
    int i;
    CLRREntry *pLRRE;

    for (i = nEntries - 1; i >= 0 ; --i)
    {
        pLRRE = & _aryLRRE[i];
        Assert( pLRRE->_pSrcElem && pLRRE->_pcstrID );
        pLRRE->_pSrcElem->SubRelease();
        delete pLRRE->_pcstrID;

        _aryLRRE.Delete( i );
    }

    Assert( _aryLRRE.Size() == 0 );
}

HRESULT
CLayoutRectRegistry::AddEntry( CElement *pSrcElem, LPCTSTR pszID )
{
    Assert( pSrcElem && pszID );

    HRESULT     hr = S_OK;
    CLRREntry   lrre;
    int         nEntries, i;

    //
    // Make sure no other element is waiting for this ID.
    //
    for (i = 0, nEntries = _aryLRRE.Size(); i < nEntries ; ++i)
    {
        CLRREntry *pLRRE = &_aryLRRE[i];

        AssertSz( pSrcElem != pLRRE->_pSrcElem, "Shouldn't have an existing entry w/ same element" );
        if ( !StrCmpI( pszID, (LPTSTR)(*(pLRRE->_pcstrID))) )
        {
            // There's already an element looking for this ID; you lose.
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // No element looking for this ID, we can create a new entry.
    //
    lrre._pcstrID = new CStr();
    if (    lrre._pcstrID == NULL 
        ||  FAILED(lrre._pcstrID->Set(pszID))   )
    {
        goto Error;
    }

    lrre._pSrcElem = pSrcElem;
    lrre._pSrcElem->SubAddRef();

    if (FAILED(_aryLRRE.AppendIndirect(&lrre)))
    {
        goto Error;
    }
    
Cleanup:
    return hr;

Error:
    if (lrre._pcstrID)
        delete lrre._pcstrID;

    if (lrre._pSrcElem)
        lrre._pSrcElem->SubRelease();

    hr = E_FAIL;
    goto Cleanup; 
}

// NOTE: Remember to SubRelease() the CElement you get back from this
// function when you're done with it.
CElement *
CLayoutRectRegistry::GetElementWaitingForTarget( LPCTSTR pszID )
{
    Assert( pszID );

    int nEntries = _aryLRRE.Size();
    int i;
    CLRREntry *pLRRE;
    CElement *pElem = NULL;

    for (i=0 ; i < nEntries ; ++i)
    {
        pLRRE = & _aryLRRE[i];
        if ( !StrCmpI( pszID, (LPTSTR)(*(pLRRE->_pcstrID))) )
        {
            // Found an entry that's looking for this ID.
            // Delete the entry, and return the element it was holding.

            // TODO (112509, olego): CLayoutRectRegistry needs conceptual 
            // and code cleanup
            // (original comment by ktam): Deliberately not releasing,
            // it here since we're going to be using the returned ptr! 
            // Think about ref-counting model.
            
            pElem = pLRRE->_pSrcElem;   // Save ptr we're going to return, but don't release it
            delete pLRRE->_pcstrID;     // CDataAry.Delete() won't clean this up, so we do it
            
            _aryLRRE.Delete( i );
            break;
        }
    }

    return pElem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\scrollbarcontroller.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       scrollbarcontroller.cxx
//
//  Contents:   Transient object to control scroll bar during user interaction.
//
//  Classes:    CScrollbarController
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_HXX_
#define X_MACCONTROLS_HXX_
#include "maccontrols.h"
#endif
#endif

//
// This is the "timer ID" which will be used when the user has pressed
// either one of the scrollbar buttons, or the paging areas, to time
// the repeat rate for scrolling.
//

#define SB_REPEAT_TIMER 1


MtDefine(THREADSTATE_pSBC, THREADSTATE, "THREADSTATE::_pSBC")


//+----------------------------------------------------------------------------
//
//  Function:   InitScrollbar
//
//  Synopsis:   Allocate scrollbar helper
//
//  Arguments:  pts - THREADSTATE for current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitScrollbar(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->pSBC = new (Mt(THREADSTATE_pSBC)) CScrollbarController();
    if (!pts->pSBC)
        RRETURN(E_OUTOFMEMORY);
    RRETURN(S_OK);
}


//+----------------------------------------------------------------------------
//
//  Function:   DeinitScrollbar
//
//  Synopsis:   Delete scrollbar helper
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void
DeinitScrollbar(
    THREADSTATE *   pts)
{
    Assert(pts);
    delete pts->pSBC;
}


//+---------------------------------------------------------------------------
//
//  Function:   InitScrollbarTiming
//
//  Synopsis:   Get scrollbar's timing info into a thread local storage
//              scrollTimeInfo structure
//
//----------------------------------------------------------------------------

void
InitScrollbarTiming()
{
    THREADSTATE * pts = GetThreadState();

    Assert (pts);
    Assert (pts->pSBC);

    pts->scrollTimeInfo.lRepeatDelay = pts->pSBC->GetRepeatDelay ();
    pts->scrollTimeInfo.lRepeatRate  = pts->pSBC->GetRepeatRate ();
    pts->scrollTimeInfo.lFocusRate   = pts->pSBC->GetFocusRate ();
}


static UINT
TranslateSBAction(CScrollbar::SCROLLBARPART part)
{
    switch (part)
    {
    case CScrollbar::SB_PREVBUTTON: return SB_LINEUP;
    case CScrollbar::SB_NEXTBUTTON: return SB_LINEDOWN;
    case CScrollbar::SB_PREVTRACK:  return SB_PAGEUP;
    case CScrollbar::SB_NEXTTRACK:  return SB_PAGEDOWN;
    case CScrollbar::SB_THUMB:      return SB_THUMBPOSITION;
    default:                        Assert(FALSE); break;
    }
    
    // here only on error
    return SB_LINEUP;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::StartScrollbarController
//              
//  Synopsis:   Start a scroll bar controller if necessary.
//              
//  Arguments:  pLayout         layout object to be called on scroll changes
//              pDispScroller   display scroller node
//              pServerHost     server host
//              buttonWidth     custom scroll bar button width
//              pMessage        message that caused creation of controller
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::StartScrollbarController(
        CLayout* pLayout,
        CDispScroller* pDispScroller,
        CServer* pServerHost,
        long buttonWidth,
        CMessage* pMessage)
{
    Assert(pLayout != NULL);
    Assert(pDispScroller != NULL);
    Assert(pServerHost != NULL);
    Assert(pMessage != NULL);
    BOOL fScrollToHere = FALSE;
    BOOL fContextMenu;

    CScrollbarController* pSBC = TLS(pSBC);
    Assert(pSBC != NULL);
   
    // just to make sure previous controller is stopped
    if (pSBC->_pLayout != NULL)
    {
        StopScrollbarController();
    }
   
#ifdef UNIX
    if (pMessage->dwKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
        if (pMessage->message == WM_MBUTTONDOWN ||
            (pMessage->dwKeyState & MK_CONTROL) != MK_CONTROL)
            return;
    }
#endif
 
    pSBC->_direction = (pMessage->htc == HTC_HSCROLLBAR ? 0 : 1);
    pSBC->_pDispScroller = pDispScroller;
    pSBC->_drawInfo.Init(pLayout->ElementOwner());
    
    // calculate scroll bar rect
    pDispScroller->GetClientRect(
        &pSBC->_rcScrollbar,
        (pSBC->_direction == 0
            ? CLIENTRECT_HSCROLLBAR
            : CLIENTRECT_VSCROLLBAR));
    Assert(pSBC->_rcScrollbar.Contains(pMessage->ptContent));
    
    LONG contentSize, containerSize, scrollAmount;
    pSBC->GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
    
    // if the scrollbar is inactive, it doesn't matter what was pressed
    if (contentSize <= containerSize)
        return;

    // what was pressed?
    pSBC->_partPressed = GetPart(
        pSBC->_direction,
        pSBC->_rcScrollbar,
        pMessage->ptContent,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pSBC->GetDrawInfo());
    Assert(pSBC->_partPressed != SB_NONE);

    // treat ContextMenu like a thumb, in case user selects ScrollToHere
    fContextMenu = (pMessage->message == WM_CONTEXTMENU);
    if (fContextMenu)
    {
        pSBC->_partPressed = SB_THUMB;
    }
    
    // if inactive track was pressed, no more work to do
    if (pSBC->_partPressed == SB_TRACK)
        return;
    
    // make scroll bar controller active
    pSBC->_partPressedStart = pSBC->_partPressed;
    pSBC->_pLayout = pLayout;
    pSBC->_pDispScroller = pDispScroller;
    pSBC->_pServerHost = pServerHost;
    pSBC->_buttonWidth = buttonWidth;
    pSBC->_ptMouse = pMessage->ptContent;
   
    LONG lScrollTime = MAX_SCROLLTIME;

    // Handle special actions
#ifndef UNIX
    if (pMessage->dwKeyState & MK_SHIFT)
    {
        switch (pSBC->_partPressed)
        {
        case CScrollbar::SB_PREVTRACK:
        case CScrollbar::SB_THUMB:
        case CScrollbar::SB_NEXTTRACK:
            // shift-click is treated just like thumb: "scroll to here"
            pSBC->_partPressedStart = pSBC->_partPressed = SB_THUMB;
            fScrollToHere = TRUE;
            break;
        default:
            break;
        }
    }
#else // Handle UNIX motif scrollbar's special actions. 
    // Is MK_CONTROL pressed?
    if (pMessage->dwKeyState & MK_CONTROL)
    {
        switch (pSBC->_partPressed)
        {
        case CScrollbar::SB_PREVBUTTON:
        case CScrollbar::SB_PREVTRACK:
            pLayout->OnScroll(pSBC->_direction, SB_TOP, 0);
            break;
        case CScrollbar::SB_NEXTBUTTON:
        case CScrollbar::SB_NEXTTRACK:
            pLayout->OnScroll(pSBC->_direction, SB_BOTTOM, 0);
            break;
        }
        return;
    }
    if (pMessage->message == WM_MBUTTONDOWN)
    {
        pSBC->MoveThumb(pMessage->pt);
        pSBC->GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
        pSBC->_partPressedStart = pSBC->_partPressed = SB_THUMB;
    }
#endif // UNIX

    // if thumbing, compute hit point offset from top of thumb
    if (pSBC->_partPressed == SB_THUMB)
    {
        long trackSize = GetTrackSize(
            pSBC->_direction, pSBC->_rcScrollbar, pSBC->_buttonWidth);
        long thumbSize = GetThumbSize(
            pSBC->_direction, pSBC->_rcScrollbar, contentSize, containerSize,
            pSBC->_buttonWidth, pSBC->GetDrawInfo());
        // _mouseInThumb is the xPos of the mouse in from the left edge of the thumb in LTR cases
        // and xPos of the mouse in from the right edge of the thumb in RTL HSCROLL cases
        if (fScrollToHere || fContextMenu)
        {
            pSBC->_mouseInThumb = thumbSize / 2;
        }
        else
        {
            pSBC->_mouseInThumb = 
                pSBC->_ptMouse[pSBC->_direction] -
                pSBC->_rcScrollbar[pSBC->_direction] -
                GetScaledButtonWidth(pSBC->_direction, pSBC->_rcScrollbar, pSBC->_buttonWidth) -
                GetThumbOffset(contentSize, containerSize, scrollAmount, trackSize, thumbSize);
        }
        Assert(pSBC->_mouseInThumb >= 0);

        // ScrollToHere works as if the thumb started in the current mouse position
        if (fScrollToHere)
        {
            pSBC->MouseMove(pMessage->pt);
        }
        
        // remember starting offset, in case mouse gets too far from scrollbar
        CSize sizeOffsetCurrent;
        pDispScroller->GetScrollOffset(&sizeOffsetCurrent);
        pSBC->_scrollOffsetStart = sizeOffsetCurrent[pSBC->_direction];
        
        // no smooth scrolling
        lScrollTime = 0;
    }

    // for ContextMenu, just popup the menu.  The callbacks take care of the rest
    if (fContextMenu)
    {
        pSBC->_partPressed = SB_CONTEXTMENU;
        IGNORE_HR(pLayout->ElementOwner()->OnContextMenu(
                (short) LOWORD(pMessage->lParam),
                (short) HIWORD(pMessage->lParam),
                pSBC->_direction ? CONTEXT_MENU_VSCROLL : CONTEXT_MENU_HSCROLL));
        StopScrollbarController();
        return;
    }
    
    // capture the mouse
    Assert(pServerHost->State() >= OS_INPLACE);
    HWND hwnd = pServerHost->_pInPlace->_hwnd;
    if (!hwnd)
    {
        IGNORE_HR(pServerHost->_pInPlace->_pInPlaceSite->GetWindow(&hwnd));
    }
#ifdef _MAC
    TrackMacScroll(pSBC, pServerHost, pMessage->ptContent, pSBC->_direction, pSBC->_partPressed);
#else
    if (FAILED(GWSetCapture(
            pSBC,
            ONMESSAGE_METHOD(CScrollbarController, OnMessage, onmessage),
            hwnd)))
    {
        pSBC->_pLayout = NULL;
        return;
    }
 
    // set timer for repeating actions
    if (pSBC->_partPressed != SB_THUMB)
    {
        // set timer for subsequent action
        // This must happen before OnScroll, in case the onscroll handler does
        // something to pump the message loop, call back to our OnMessage,
        // and try to kill the timer.
        FormsSetTimer(
            pSBC,
            ONTICK_METHOD(CScrollbarController, OnTick, ontick),
            SB_REPEAT_TIMER,
            GetRepeatDelay() );

        // perform first action
        pLayout->OnScroll(
            pSBC->_direction, TranslateSBAction(pSBC->_partPressed), 0, FALSE, lScrollTime);

        // CAUTION: the OnScroll method may cause StopScrollbarController
        // to be called, in which case we need to get outta here.
        if (pSBC->_pLayout != pLayout)
            return;
        Assert(pSBC->_pLayout->GetElementDispNode() == pSBC->_pDispScroller);

        CSize scrollOffset;
        pSBC->_pDispScroller->GetScrollOffset(&scrollOffset);
        scrollAmount = scrollOffset[pSBC->_direction];
    }
    
    // invalidate the part we hit, if necessary
    pLayout->OpenView();
    InvalidatePart(
        pSBC->_partPressed,
        pSBC->_direction,
        pSBC->_rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDispScroller,
        pSBC->GetDrawInfo());
#endif // _MAC
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::StopScrollbarController
//              
//  Synopsis:   Stop an existing scroll bar controller.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::StopScrollbarController()
{
    CScrollbarController* pSBC = TLS(pSBC);
    Assert(pSBC != NULL);
    
    if (pSBC->_pLayout != NULL)
    {
        // report scroll change to layout, which will take care of
        // invalidation

        pSBC->_pLayout->OnScroll(pSBC->_direction, SB_ENDSCROLL, 0);

        // do this before GWReleaseCapture, or StopScrollbarController
        // will be called recursively
        pSBC->_pLayout = NULL;

        // if we started from a context menu, there's no timer or capture
        if (pSBC->_partPressed == SB_CONTEXTMENU)
            return;

        if (pSBC->_partPressed != SB_THUMB)
        {
            FormsKillTimer(pSBC, SB_REPEAT_TIMER);
        }
#ifndef _MAC
        GWReleaseCapture(pSBC);
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::OnMessage
//              
//  Synopsis:   Handle messages sent to this scroll bar controller.
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

LRESULT
CScrollbarController::OnMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    //
    // If the serverhost somehow went into the running state
    // just terminate capture and bail out.  This could happen
    // because of asynchronous activation/deactivation (as in IE)
    //
    if (_pServerHost->State() < OS_INPLACE)
        goto Terminate;
    
    switch (msg)
    {
    case WM_MOUSEMOVE:
        MouseMove( CPoint( MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y ) );
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        AssertSz(FALSE, "CScrollbarController got unexpected message");
        break;

#ifdef UNIX
    case WM_MBUTTONUP:
#endif
    case WM_LBUTTONUP:
        if (_partPressed != SB_NONE)
        {
            // invalidate just the part that was pressed
            _partPressed = SB_NONE;
            CSize scrollOffset;
            _pDispScroller->GetScrollOffset(&scrollOffset);
            LONG containerSize = _rcScrollbar.Size(_direction);
            Verify(_pLayout->OpenView());
            InvalidatePart(
                _partPressedStart,
                _direction,
                _rcScrollbar,
                _pDispScroller->GetContentSize()[_direction],
                containerSize,
                scrollOffset[_direction],
                _buttonWidth,
                _pDispScroller,
                &_drawInfo);
        }
        
        // fall thru to Terminate...

    case WM_CAPTURECHANGED:
        goto Terminate;
    }
    
    return 0;
    
Terminate:
    StopScrollbarController();
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::MouseMove
//              
//  Synopsis:   Handle mouse move events.
//              
//  Arguments:  pt      new mouse location
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::MouseMove(const CPoint& pt)
{
    _pDispScroller->TransformPoint(
        pt,
        COORDSYS_GLOBAL,
        &_ptMouse,
        COORDSYS_BOX);
    
    switch (_partPressedStart)
    {
    case SB_NONE:
    case SB_TRACK:
        AssertSz(FALSE, "unexpected call to CScrollbarController::MouseMoved");
        break;
        
    case SB_THUMB:
        {
            LONG contentSize = _pDispScroller->GetContentSize()[_direction];
            Assert(contentSize >= 0);
            LONG trackSize =
                GetTrackSize(_direction, _rcScrollbar, _buttonWidth) -
                GetThumbSize(_direction, _rcScrollbar, contentSize,
                             _rcScrollbar.Size(_direction), _buttonWidth,
                             &_drawInfo);
            if (trackSize <= 0)
                break;  // can't move thumb

            // check to see if the mouse point
            // is out of range perpendicular to the scroll bar axis
            if (_ptMouse[!_direction] < _rcScrollbar[!_direction] - g_lScrollGutterRatio * _buttonWidth ||
                _ptMouse[!_direction] > _rcScrollbar[2 + !_direction] + g_lScrollGutterRatio * _buttonWidth)
            {
                // if it is, scroll back to where we started
                _pLayout->OnScroll(_direction, SB_THUMBPOSITION, _scrollOffsetStart);
                break;
            }

            LONG trackPos = _ptMouse[_direction] -
                            _rcScrollbar[_direction] -
                            GetScaledButtonWidth(_direction, _rcScrollbar, _buttonWidth) -
                            _mouseInThumb;
            
            LONG scrollOffset;
            if (trackPos <= 0)
            {
                scrollOffset = 0;
            }
            else
            {
                contentSize -= _rcScrollbar.Size(_direction);
                scrollOffset = MulDivQuick(trackPos, contentSize, trackSize);
            }
            
            _pLayout->OnScroll(_direction, SB_THUMBPOSITION, scrollOffset);
        }
        break;
        
    default:
        {
            // find out what the mouse would be pressing in its new location.
            // If it's not the same as it used to be, invalidate the part.
            SCROLLBARPART partPressedOld = _partPressed;
            LONG contentSize, containerSize, scrollAmount;
            GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
            _partPressed = GetPart(
                _direction,
                _rcScrollbar,
                _ptMouse,
                contentSize,
                containerSize,
                scrollAmount,
                _buttonWidth,
                &_drawInfo);
            if (_partPressed != _partPressedStart)
            {
                _partPressed = SB_NONE;
            }
            if (_partPressed != partPressedOld)
            {
                SCROLLBARPART invalidPart = _partPressed;
                if (_partPressed != SB_NONE)
                {
                    // perform scroll action and set timer
                    OnTick(SB_REPEAT_TIMER);
                }
                else
                {
                    invalidPart = partPressedOld;
                }
                Verify(_pLayout->OpenView());
                InvalidatePart(
                    invalidPart,
                    _direction,
                    _rcScrollbar,
                    contentSize,
                    containerSize,
                    scrollAmount,
                    _buttonWidth,
                    _pDispScroller,
                    &_drawInfo);
            }
        }
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::DoContextMenuScroll
//              
//  Synopsis:   Handle scroll commands from the context menu
//              
//  Arguments:  idm     menu command
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::DoContextMenuScroll(UINT idm)
{
    Assert(_partPressed == SB_CONTEXTMENU);
    UINT uiCode = SB_TOP;

    switch (idm)
    {
    case IDM_SCROLL_HERE:
    {
        CPoint ptgMouse;
        _pDispScroller->TransformPoint(
            _ptMouse,
            COORDSYS_BOX,
            &ptgMouse,
            COORDSYS_GLOBAL);
        MouseMove(ptgMouse);
        return;
    }
    case IDM_SCROLL_TOP:
    case IDM_SCROLL_LEFTEDGE:
        uiCode = SB_TOP;
        break;
    case IDM_SCROLL_BOTTOM:
    case IDM_SCROLL_RIGHTEDGE:
        uiCode = SB_BOTTOM;
        break;
    case IDM_SCROLL_PAGEUP:
    case IDM_SCROLL_PAGELEFT:
        uiCode = SB_PAGEUP;
        break;
    case IDM_SCROLL_PAGEDOWN:
    case IDM_SCROLL_PAGERIGHT:
        uiCode = SB_PAGEDOWN;
        break;
    case IDM_SCROLL_UP:
    case IDM_SCROLL_LEFT:
        uiCode = SB_LINEUP;
        break;
    case IDM_SCROLL_DOWN:
    case IDM_SCROLL_RIGHT:
        uiCode = SB_LINEDOWN;
        break;
    }
    
    _pLayout->OnScroll(_direction, uiCode, 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::OnTick
//              
//  Synopsis:   Handle mouse timer ticks to implement repeated scroll actions
//              and focus blinking.
//              
//  Arguments:  id      timer event type
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HRESULT
CScrollbarController::OnTick(UINT id)
{
    // for now, SB_REPEAT_TIMER is the only id we use
    Assert(id == SB_REPEAT_TIMER);
    
    // timer tick snuck through right before we disabled it
    if (_pLayout == NULL)
        return S_OK;

    if (id == SB_REPEAT_TIMER)
    {
        if (_partPressed != SB_NONE)
        {
            // while paging, thumb may have moved underneath the mouse
            if (_partPressed == SB_PREVTRACK || _partPressed == SB_NEXTTRACK)
            {
                LONG contentSize, containerSize, scrollAmount;

                GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
#if !defined(UNIX) && !defined(_MAC) //Under Unix where the thumb goes during a repetition
             // of page down makes no difference.

                _partPressed = GetPart(
                    _direction,
                    _rcScrollbar,
                    _ptMouse,
                    contentSize,
                    containerSize,
                    scrollAmount,
                    _buttonWidth,
                    &_drawInfo);
                if (_partPressed != _partPressedStart)
                {
                    _partPressed = SB_NONE;
                    Verify(_pLayout->OpenView());
                    InvalidatePart(
                        _partPressedStart,
                        _direction,
                        _rcScrollbar,
                        contentSize,
                        containerSize,
                        scrollAmount,
                        _buttonWidth,
                        _pDispScroller,
                        &_drawInfo);
                    return S_OK;
                }
#endif
            }
            
#ifndef _MAC            
            //
            // Now that at least one click has come in (to be processed right afterwards)
            // we set the timer to be the repeat rate.
            //

            FormsSetTimer(
                    this,
                    ONTICK_METHOD(CScrollbarController, OnTick, ontick),
                    SB_REPEAT_TIMER,
                    GetRepeatRate() );
#endif

            // repeat this scroll action
            _pLayout->OnScroll(_direction, TranslateSBAction(_partPressed), 0, FALSE, GetRepeatRate());
        }
    }
    
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::GetScrollInfo
//              
//  Synopsis:   Get basic size information needed to perform scrolling calcs.
//              
//  Arguments:  pContentSize        size of content to be scrolled
//              pContainerSize      size of container
//              pScrollAmount       current scroll amount
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::GetScrollInfo(
        LONG* pContentSize,
        LONG* pContainerSize,
        LONG* pScrollAmount) const
{
    Assert(_pDispScroller != NULL);
    
    // get content size
    *pContentSize = _pDispScroller->GetContentSize()[_direction];
    
    // get container size
    *pContainerSize = _rcScrollbar.Size(_direction);
    
    // get current scroll offset
    CSize scrollOffset;
    _pDispScroller->GetScrollOffset(&scrollOffset);
    *pScrollAmount = scrollOffset[_direction];
}

#ifdef UNIX // Grap codes from MouseMove
void 
CScrollbarController::MoveThumb(const CPoint& pt)
{
    LONG contentSize = _pDispScroller->GetContentSize()[_direction];
    Assert(contentSize >= 0);
    LONG thumbSize =
        GetThumbSize(_direction, _rcScrollbar, contentSize,
                     _rcScrollbar.Size(_direction), _buttonWidth,
                     &_drawInfo);
    LONG trackSize =
        GetTrackSize(_direction, _rcScrollbar, _buttonWidth) - thumbSize;
    if (trackSize <= 0)
        return;  // can't move thumb

    // NOTE: we're not currently checking to see if the mouse point
    // is out of range perpendicular to the scroll bar axis
    LONG trackPos =
        pt[_direction] - _rcScrollbar[_direction] -
        GetScaledButtonWidth(_direction, _rcScrollbar, _buttonWidth) -
        thumbSize/2; //_mouseInThumb;
    LONG scrollOffset;
    if (trackPos <= 0)
    {
        scrollOffset = 0;
    }
    else
    {
        contentSize -= _rcScrollbar.Size(_direction);
        scrollOffset = trackPos * contentSize;
        if (scrollOffset < trackPos || scrollOffset < contentSize)
        {
            // oops, it overflowed.  Do a less accurate calculation in
            // a safer order.
            scrollOffset = contentSize / trackSize * trackPos;
        }
        else
        {
            scrollOffset /= trackSize;
        }
    }
            
    // report scroll change to layout, which will take care of
    // invalidation
    _pLayout->OnScroll(_direction, SB_THUMBPOSITION, scrollOffset);
}
#endif // UNIX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\sellyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sellyt.cxx
//
//  Contents:   Implementation of CSelectLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

MtDefine(CSelectLayout, Layout, "CSelectLayout")

const CLayout::LAYOUTDESC CSelectLayout::s_layoutdesc =
{
    LAYOUTDESC_NEVEROPAQUE, // _dwFlags
};

ExternTag(tagLayoutTasks);
ExternTag(tagCalcSize);
ExternTag(tagViewHwndChange);

DeclareTag(tagSelectSetPos, "SelectPos", "Trace SELECT SetPositions");
DeclareTag(tagSelectNotify, "SelectNotify", "Trace the flat SELECT notifications");


//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Notify
//
//  Synopsis:   Hook into the layout notification. listen for any changed in the tree
//              under the SELECT
//
//
//-------------------------------------------------------------------------

void
CSelectLayout::InternalNotify(void)
{
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( !TestLock(CElement::ELEMENTLOCK_SIZING) &&
         pSelect->_fEnableLayoutRequests )
    {

        //
        //  Otherwise, accumulate the information
        //
        BOOL    fWasDirty = IsDirty();

        //
        //  If transitioning to dirty, post a layout request
        //

        _fDirty = TRUE;

        TraceTag((tagSelectNotify, "SELECT 0x%lx was dirtied", this));

        if ( !fWasDirty && IsDirty() )
        {
            TraceTag((tagSelectNotify, "SELECT 0x%lx enqueueing layout request", this));
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CSelectLayout::InternalNotify()",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber));
            PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Notify
//
//  Synopsis:   Hook into the layout notification. listen for any changed in the tree
//              under the SELECT
//
//
//-------------------------------------------------------------------------
void
CSelectLayout::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    BOOL    fWasDirty = IsDirty() || IsSizeThis();
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    super::Notify(pnf);

    if (    TestLock(CElement::ELEMENTLOCK_SIZING)
        ||  pnf->IsType(NTYPE_ELEMENT_RESIZE)
        ||  pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)
        ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE))
        goto Cleanup;

    pSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( ! pSelect->_fEnableLayoutRequests )
        goto Cleanup;

    if (IsInvalidationNotification(pnf))
    {
        if (pSelect->_hwnd)
        {
            ::InvalidateRect(pSelect->_hwnd, NULL, FALSE);
        }
    }

    // NOTE (KTam): CSelectLayout::Notify is being pretty aggressive about setting the
    // handler for notifications; right now practically all notifications are being set
    // to handled.  This seems wrong; the adorners work clearly wanted to avoid this,
    // and bug #98969 is fixed by not calling SetHandler for NTYPE_VISIBILITY_CHANGE.  See that bug
    // for more details.
    if ( pnf->IsType(NTYPE_VISIBILITY_CHANGE ) )
        goto Cleanup;
#ifdef ADORNERS
    if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
        goto Cleanup;
#endif // ADORNERS

    if ( pnf->IsHandled() )
        goto Cleanup;

    if ( !pnf->IsTextChange())
        goto Handled;

    _fDirty = TRUE;
    pSelect->_fOptionsDirty = TRUE;

    TraceTag((tagSelectNotify, "SELECT 0x%lx was dirtied", this));

    if ( !fWasDirty && IsDirty() )
    {
        TraceTag((tagSelectNotify, "SELECT 0x%lx enqueueing layout request", this));
        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                    "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CSelectLayout::Notify() [n=%S srcelem=0x%x,%S]",
                    this,
                    _pElementOwner,
                    _pElementOwner->TagName(),
                    _pElementOwner->_nSerialNumber,
                    pnf->Name(),
                    pnf->Element(),
                    pnf->Element() ? pnf->Element()->TagName() : _T("")));
        PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
    }


Handled:
    pnf->SetHandler(pSelect);

Cleanup:
    return;
}





//+-------------------------------------------------------------------------
//
//  Method:     DoLayout
//
//  Synopsis:   Layout contents
//
//  Arguments:  grfLayout   - One or more LAYOUT_xxxx flags
//
//--------------------------------------------------------------------------

void
CSelectLayout::DoLayout(DWORD grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    BOOL fTreeChanged = IsDirty();

    TraceTag((tagSelectNotify, "SELECT 0x%lx DoLayout called, flags: 0x%lx", this, grfLayout));
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CSelectLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    Assert(grfLayout & LAYOUT_MEASURE);
    Assert(!(grfLayout & LAYOUT_ADORNERS));

    if ( _fDirty )
    {
        if (pSelect->_hwnd)
            pSelect->PushStateToControl();

        _fDirty = FALSE;
        pSelect->ResizeElement();

    }

        //  Remove the request from the layout queue
    TraceTag((tagSelectNotify, "SELECT 0x%lx DEqueueing layout request", this));
    RemoveLayoutRequest();

    if ( IsSizeThis() )
    {
        CCalcInfo   CI(this);

        TraceTag((tagSelectNotify, "SELECT 0x%lx DoLayout caused EnsureDefaultSize", this));
        CI._grfLayout |= grfLayout;

        if (_fForceLayout)
        {
            CI._grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;

            EnsureDispNode(&CI, TRUE);
            SetPositionAware();
        }

        if ( fTreeChanged || (grfLayout & LAYOUT_FORCE) )
        {
            pSelect->_sizeDefault.cx = pSelect->_sizeDefault.cy = 0;
        }

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, pSelect->_sizeDefault);
        }
        
         EnsureDefaultSize(&CI);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CSelectLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::EnsureDefaultSize, protected
//
//  Synopsis:   Compute the default size of the control
//              if it hasn't been done yet.
//
//  Note:       Jiggles the window to handle integralheight listboxes correctly.
//
//-------------------------------------------------------------------------
#define CX_SELECT_DEFAULT_HIMETRIC  634L  // 1/4 logical inch

HRESULT
CSelectLayout::EnsureDefaultSize(CCalcInfo * pci)
{
    Assert(ElementOwner());

    HRESULT             hr = S_OK;
    long                lSIZE;
    CRect               rcSave;
    int                 i;
    long                lWidth, lMaxWidth;
    COptionElement *    pOption;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    SIZE &              sizeDefault = pSelect->_sizeDefault;

    if ( sizeDefault.cx && sizeDefault.cy )
        goto Cleanup;

#if DBG == 1
    _cEnsureDefaultSize++;
#endif

    lMaxWidth = 0;

    lSIZE = pSelect->GetAAsize();

    if ( lSIZE == 0 )
    {
        lSIZE = pSelect->_fMultiple ? 4 : 1;
    }

    sizeDefault.cy = pSelect->_lFontHeight * lSIZE +
                      pci->DeviceFromDocPixelsX(6);

    if (pSelect->_fWindowDirty || pSelect->_fOptionsDirty)
        pSelect->PushStateToControl();

    //  Measure the listbox lines
    for ( i = pSelect->_aryOptions.Size() - 1; i >= 0; i-- )
    {
        pOption = pSelect->_aryOptions[i];
        lWidth = pOption->MeasureLine(pci);

        if ( lWidth > lMaxWidth )
        {
            lMaxWidth = lWidth;
            pSelect->_poptLongestText = pOption;
        }
    }

    sizeDefault.cx = pci->DeviceFromHimetricX(g_sizelScrollbar.cx) +
                      lMaxWidth +
                      pci->DeviceFromDocPixelsX(6 + 4);   //  6 is magic number for borders

    if ( sizeDefault.cx < pci->DeviceFromHimetricX(CX_SELECT_DEFAULT_HIMETRIC) )
    {
        sizeDefault.cx = pci->DeviceFromHimetricX(CX_SELECT_DEFAULT_HIMETRIC);
    }

    pSelect->_lComboHeight = pSelect->_lFontHeight * DEFAULT_COMBO_ITEMS;

    pSelect->_lMaxWidth = lMaxWidth;
    _fDirty = FALSE;

Cleanup:
    RRETURN(hr);
}




//+-------------------------------------------------------------------------
//
//  Method:     CSelectLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CSelectLayout::CalcSizeVirtual( CCalcInfo * pci,
                                SIZE *      psize,
                                SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CSelectLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(ElementOwner());
    CScopeFlag          csfCalcing(this);
    CSaveCalcInfo       sci(pci);
    HRESULT             hr;
    DWORD               grfLayout = 0;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    SIZE &              sizeDefault = pSelect->_sizeDefault;

#if DBG == 1
    _cCalcSize++;
#endif

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    if(  pSelect->_fNeedMorph && pSelect->_hwnd)
    {
        // We may have changed our flow direction. Recreate the control.
        pSelect->Morph();

        if(_pDispNode)
            GetElementDispNode()->RequestViewChange();
    }

    if ( ! pSelect->_hwnd )
    {
        hr = THR(AcquireFont(pci));
        if ( FAILED(hr) )
            goto Cleanup;

        if ( Doc() && Doc()->_pInPlace && Doc()->_pInPlace->_hwnd && IsInplacePaintAllowed())
        {
            hr = THR(pSelect->EnsureControlWindow());

            if ( hr )
                goto Cleanup;
        }
    }
    else if ( pSelect->_fRefreshFont ) 
    {
        hr = THR(AcquireFont(pci));
        if ( FAILED(hr)) 
            goto Cleanup;

        Assert(pSelect->_hFont);

        // AcquireFont returns S_FALSE if the new font is the same as the old one.
        if (hr != S_FALSE)
        {
            ::SendMessage(pSelect->_hwnd, WM_SETFONT, (WPARAM)pSelect->_hFont, MAKELPARAM(FALSE,0));
            if (! pSelect->_fListbox )
            {
                pSelect->SendSelectMessage(CSelectElement::Select_SetItemHeight, (WPARAM)-1, pSelect->_lFontHeight);
            }
            pSelect->SendSelectMessage(CSelectElement::Select_SetItemHeight, 0, pSelect->_lFontHeight);
        }
        hr = S_OK;
    }

    if ( pci->_grfLayout & LAYOUT_FORCE || _fDirty)
    {
        sizeDefault.cx = sizeDefault.cy = 0;
    }

    IGNORE_HR(EnsureDefaultSize(pci));

Cleanup:

    TraceTag((tagSelectSetPos, "SELECT 0x%lx CalcSize, cx=%d, cy=%d", this, psize->cx, psize->cy));

    // if we're a combo box, ignore height set by CSS and use
    // the default height. BUT, we do use the CSS width if it 
    // has been set.
    if (! pSelect->_fListbox)
    {
        CTreeNode * pTreeNode = GetFirstBranch();
        if (pTreeNode)
        {
            const CCharFormat *pCF = pTreeNode->GetCharFormat();
            const CUnitValue & cuvWidth = pTreeNode->GetFancyFormat()->GetLogicalWidth(
                pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

            sizeDefault.cx = (cuvWidth.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                    ? sizeDefault.cx
                                    : max(0L, cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                        pTreeNode->GetFontHeightInTwips(&cuvWidth))));

            pci->_grfLayout |= LAYOUT_USEDEFAULT;
        }
    }

    grfLayout |= super::CalcSizeVirtual(pci, psize, &sizeDefault);

    //
    // If anything changed, ensure the display node is position aware
    //
    if(_pDispNode
        &&  (grfLayout & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
    {
        SetPositionAware();
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CSelectLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfLayout;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::AcquireFont, protected
//
//  Synopsis:   Beg, borrow or steal a font and set it to the control window
//
//  returns:    S_FALSE if the current font and old font are the same
//
//----------------------------------------------------------------------------

HRESULT
CSelectLayout::AcquireFont(CCalcInfo * pci)
{
    Assert(ElementOwner());

    HRESULT             hr = S_OK;
    LOGFONT             lfOld;
    LOGFONT             lf;
    CCcs                ccs;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    const CCharFormat * pcf = GetFirstBranch()->GetCharFormat();

    memset(&lfOld, 0, sizeof(lfOld));
    memset(&lf, 0, sizeof(lf));

    if ( ! pcf )
        goto Error;

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
        goto Error;

    lf = ccs.GetBaseCcs()->_lf;    //  Copy it out
    lf.lfUnderline = pcf->_fUnderline;
    lf.lfStrikeOut = pcf->_fStrikeOut;

    if (pSelect->_hFont)
    {
        ::GetObject(pSelect->_hFont, sizeof(lfOld), &lfOld);
        if (!memcmp(&lf, &lfOld, sizeof(lfOld)))
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        else
        {
            Verify(DeleteObject(pSelect->_hFont));
            pSelect->_hFont = NULL;
        }
    }
    
    pSelect->_hFont = CreateFontIndirect(&lf);
    pSelect->_lFontHeight = ccs.GetBaseCcs()->_yHeight;

    pSelect->_fRefreshFont = FALSE;

Cleanup:
    ccs.Release();
    RRETURN1(hr, S_FALSE);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::DrawControl, protected
//
//  Synopsis:   Renders the SELECT into a DC which is different
//              from the inplace-active DC.
//
//  Note:       Used mainly to print.
//
//----------------------------------------------------------------------------

void
CSelectLayout::DrawControl(CFormDrawInfo * pDI, BOOL fPrinting)
{
    XHDC                hdc             = pDI->GetDC(TRUE);
    CRect               rc              = pDI->_rc;
    CRect               rcLine;
    CRect               rcScrollbar;
    CSize               sizeInner;
    long                xOffset;
    FONTIDX             hFontOld        = HFONT_INVALID;
    int                 cColors;
    COLORREF            crText, crBack;
    COLORREF            crSelectedText  = 0x00FFFFFF, crSelectedBack=0;
    CCcs                ccs;
    COptionElement *    pOption;
    long                lSelectedIndex  = 0;
    long                cVisibleLines;
    long                lTopIndex;
    long                lItemHeight;
    long                i;
    BOOL                fPrintBW;
    CColorValue         ccv;
    CStr                cstrTransformed;
    CStr *              pcstrDisplayText;
    long                cOptions;
    BOOL                fRTL;
    CSelectElement *    pSelect         = DYNCAST(CSelectElement, ElementOwner());
    UINT                taOld = 0;
    CBorderInfo         bi;
    CTreeNode * pNode = GetFirstBranch();
    const CCharFormat * pCF             = pNode->GetCharFormat();
    const CParaFormat * pPF             = pNode->GetParaFormat();
 
    HTHEME              hThemeBorder    = GetOwnerMarkup()->GetTheme(THEME_EDIT);

    if  (   !hThemeBorder
        ||  !hdc.DrawThemeBackground(    hThemeBorder,
                                         EP_EDITTEXT,
                                         pSelect->IsEnabled() ? ETS_NORMAL : ETS_DISABLED,
                                         &rc,
                                         NULL))
    {
        if (ElementOwner()->GetBorderInfo(pDI, &bi, TRUE))
        {
            ::DrawBorder(pDI, &rc, &bi);
        }
    }

    //  Deflate the rect
    sizeInner = rc.Size();
    AdjustSizeForBorder(&sizeInner, pDI, FALSE);    //  FALSE means deflate

    rc.top += (rc.Height() - sizeInner.cy) / 2;
    rc.bottom = rc.top + sizeInner.cy;
    rc.left += (rc.Width() - sizeInner.cx) / 2;
    rc.right = rc.left + sizeInner.cx;

    xOffset = pDI->DeviceFromDocPixelsX(2);

    //  set up font, text and background colors

    cColors = GetDeviceCaps(hdc, NUMCOLORS);
    if ( !GetContentMarkup()->PaintBackground() && cColors <= 2)
    {
        fPrintBW = TRUE;
        crBack = 0x00FFFFFF;
        crText = pSelect->GetAAdisabled() ? GetSysColorQuick(COLOR_GRAYTEXT) : 0x0;
        crSelectedBack = crText;
        crSelectedText = crBack;
    }
    else
    {
        fPrintBW = FALSE;
        crText = 0x0;
        if (pNode->GetCascadedbackgroundColor().IsDefined())
        {
            crBack = pNode->GetCascadedbackgroundColor().GetColorRef();
        }
        else
        {
            crBack = GetSysColorQuick(COLOR_WINDOW);
        }
    }

    //  Fill the background with crBack

    PatBltBrush(hdc, &rc, PATCOPY, crBack);

    // find out what our reading order is.
    fRTL = pPF->HasRTL(TRUE);

    // ComplexText
    if(fRTL)
    {
        taOld = GetTextAlign(hdc);
        SetTextAlign(hdc, TA_RTLREADING | TA_RIGHT);
    }

    if ( pCF )
    {
        if (!fc().GetCcs(&ccs, hdc, pDI, pCF))
            return;

        hFontOld = ccs.PushFont(hdc);

        //  NOTE(laszlog): Underline!
    }

    if ( ! pSelect->_fMultiple )
    {
        lSelectedIndex = pSelect->GetCurSel();
    }

    if ( pSelect->_fListbox )
    {
#ifndef WIN16
                // BUGWIN16: Win16 doesn't support Select_GetTopIndex,
                // so am turning this off. is this right ?? vreddy - 7/16/97
        if ( pSelect->_hwnd )
        {
            lTopIndex = pSelect->SendSelectMessage(CSelectElement::Select_GetTopIndex, 0, 0);
        }
        else
#endif
        {
            lTopIndex = pSelect->_lTopIndex;
        }

        cVisibleLines = pSelect->GetAAsize();
        cOptions = pSelect->_aryOptions.Size();

        //  Handle the default height fudge
        if ( cVisibleLines == 0 )
        {
            cVisibleLines = 4;
        }

        if (pNode->GetFancyFormat()->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).IsNull())
        {
            lItemHeight = rc.Height() / cVisibleLines;
        }
        else
        {
            lItemHeight = pSelect->_lFontHeight;
            cVisibleLines = (rc.Height() / lItemHeight) + 1;
        }


        if ( ! pSelect->_fMultiple )
        {
            lSelectedIndex = pSelect->GetCurSel();
        }


        if ( cVisibleLines < cOptions )
        {
            rcScrollbar = rc;
            // put the scrollbar rect on the appropriate side of the control based on
            // the direction
            if(!fRTL)
            {
                rcScrollbar.left = rcScrollbar.right - pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
                rc.right = rcScrollbar.left;
            }
            else
            {
                rcScrollbar.right = rcScrollbar.left + pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
                rc.left = rcScrollbar.right;
            }

            // Draw scrollbar for listbox
            {          
                CScrollbar sb;
                CScrollbarParams        params;
                CScrollbarThreeDColors  colors(ElementOwner()->GetFirstBranch(), &hdc);
    
                params._pColors     = &colors;
                params._buttonWidth = rcScrollbar.Width();
                params._fFlat       = Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_FLAT_SCROLLBAR;
                params._fForceDisabled = FALSE;
                params._hTheme = GetTheme(THEME_SCROLLBAR);
                sb.Draw(1,
                        rcScrollbar,
                        rcScrollbar,
                        cOptions * lItemHeight,
                        rcScrollbar.Height(),
                        0,
                        CScrollbar::SB_NONE,
                        hdc,
                        params,
                        pDI,
                        0);
            }        
        }

        cVisibleLines += lTopIndex;
        cVisibleLines = min(cOptions, cVisibleLines);
    }
    else
    {
        ThreeDColors  colors(&hdc);
        CUtilityButton cub(&colors, FALSE);
        SIZEL sizel;

        rcScrollbar = rc;
        // put the scrollbar rect on the appropriate side of the control based on
        // the direction
        if(!fRTL)
        {
            rcScrollbar.left = rcScrollbar.right - pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
            rc.right = rcScrollbar.left;
        }
        else
        {
            rcScrollbar.right = rcScrollbar.left + pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
            rc.left = rcScrollbar.right;
        }

        pDI->HimetricFromDevice(sizel, rcScrollbar.Size());

        //  Draw the drop button here
        {
            HTHEME  hTheme  = GetTheme(THEME_COMBO);
            BOOL    fRetVal = FALSE;

            if (hTheme)
            {
                fRetVal = hdc.DrawThemeBackground(  hTheme,
                                                    CP_DROPDOWNBUTTON,
                                                    CBXS_NORMAL,
                                                    &rcScrollbar,
                                                    NULL);
            }

            if (!fRetVal)
            {
                cub.DrawButton(pDI, NULL,
                               BG_COMBO,
                               FALSE,
                               !pSelect->GetAAdisabled(),
                               FALSE,
                               rcScrollbar,
                               sizel,//extent
                               0);
            }
        }

        if ( lSelectedIndex == -1 )
            goto Cleanup;   //  Combobox is empty

        lTopIndex = lSelectedIndex;
        cVisibleLines = lTopIndex + 1;
        lItemHeight = rc.Height();
    }

    // Check to see if select control is empty.  No more to draw!
    if (pSelect->_aryOptions.Size() <= 0)
        goto Cleanup;

    rcLine = rc;

    for ( i = lTopIndex, rcLine.bottom = rc.top + lItemHeight;
          i < cVisibleLines;
          i++, rcLine.OffsetRect(0, lItemHeight), rcLine.bottom = min(rc.bottom, rcLine.bottom) )
    {
        int iRet = -1;

        Assert(i < pSelect->_aryOptions.Size());

        pOption = pSelect->_aryOptions[i];

        pcstrDisplayText = pOption->GetDisplayText(&cstrTransformed);


        if ( fPrintBW )
        {
            SetBkColor  (hdc, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedBack : crBack);
            SetTextColor(hdc, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedText : crText);
            PatBltBrush(hdc, &rcLine, PATCOPY, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedBack : crBack);
        }
        else
        {
            pOption->GetDisplayColors(&crText, &crBack, pSelect->_fListbox);

            SetBkColor(hdc, crBack);
            SetTextColor(hdc, crText);
            PatBltBrush(hdc, &rcLine, PATCOPY, crBack);
        }

        //  Set up clipping
#ifdef WIN16
        GDIRECT gr, *prc;
        CopyRect(&gr, &rc);
        prc = &gr;
#else
        RECT *prc = &rc;
#endif

        if ( pCF )
        {
            if ( pOption->CheckFontLinking(hdc, &ccs) )
            {
                // this option requires font linking

                iRet = FontLinkTextOut(hdc,
                                       !fRTL ? rcLine.left + xOffset : rcLine.right - xOffset,
                                       rcLine.top,
                                       ETO_CLIPPED,
                                       prc,
                                       *pcstrDisplayText,
                                       pcstrDisplayText->Length(),
                                       pDI,
                                       pCF,
                                       FLTO_TEXTOUTONLY);
            }
        }
        if (iRet < 0)
        {
            // no font linking

            VanillaTextOut(&ccs,
                           hdc,
                           !fRTL ? rcLine.left + xOffset : rcLine.right - xOffset,
                           rcLine.top,
                           ETO_CLIPPED,
                           prc,
                           *pcstrDisplayText,
                           pcstrDisplayText->Length(),
                           ElementOwner()->GetMarkup()->GetCodePage(),
                           NULL);

            if (pSelect->_hFont && g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
            {
                // Workaround for win95 gdi ExtTextOutW underline bugs.
                DrawUnderlineStrikeOut(rcLine.left + xOffset,
                                       rcLine.top,
                                       pOption->MeasureLine(NULL),
                                       hdc,
                                       pSelect->_hFont,
                                       prc);
            }
        }
    }

Cleanup:
    if (hFontOld != HFONT_INVALID)
        ccs.PopFont(hdc, hFontOld);
    if(fRTL)
        SetTextAlign(hdc, taOld);

    ccs.Release();

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::Draw
//
//  Synopsis:   Draw the site and its children to the screen.
//
//----------------------------------------------------------------------------

void
CSelectLayout::Draw(CFormDrawInfo *pDI, CDispNode *)
{
    if (pDI->_fInplacePaint && IsInplacePaintAllowed())
    {
        Assert(pDI->_dwDrawAspect == DVASPECT_CONTENT);
        //DrawBorder(pDI);

        goto Cleanup;
    }

    //  Use ExtTextOut to draw the listbox line by line

    if ( pDI->_dwDrawAspect == DVASPECT_CONTENT ||
         pDI->_dwDrawAspect == DVASPECT_DOCPRINT )
    {
        DrawControl(pDI, pDI->_dwDrawAspect == DVASPECT_DOCPRINT);
    }

Cleanup:
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::OnFormatsChange
//
//  Synopsis:   Handle formats change notification
//
//----------------------------------------------------------------------------
HRESULT
CSelectLayout::OnFormatsChange(DWORD dwFlags)
{
    CSelectElement * pElementSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( dwFlags & ELEMCHNG_CLEARCACHES )
    {
        pElementSelect->_fRefreshFont = TRUE;
    }

    HRESULT hr = THR(super::OnFormatsChange(dwFlags));

    // Invalidate the brush - when needed it will be re-computed
    pElementSelect->InvalidateBackgroundBrush();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
CSelectLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    
    BOOL fInView = !!(flags & VCF_INVIEW);
    BOOL fInViewChanged = !!(flags & VCF_INVIEWCHANGED);
    BOOL fMoved = !!(flags & VCF_POSITIONCHANGED);
    BOOL fNoRedraw = !!(flags & VCF_NOREDRAW);

    pSelect->_fWindowVisible = fInView && IsInplacePaintAllowed();
    
    // NOTE (donmarsh) - For now, CSelectElement creates its HWND
    // during CalcSize.  However, it would be a significant perf win
    // to create it here when it first becomes visible.  KrisMa will fix.
    if (_fWindowHidden && pSelect->_fWindowVisible)
    {
        pSelect->EnsureControlWindow();
        _fWindowHidden = FALSE;
    }
    Assert((pSelect->Doc() && pSelect->Doc()->State() < OS_INPLACE) ||
        pSelect->_hwnd || 
        (pSelect->Doc() && pSelect->GetMarkupPtr()->IsPrintMedia()) ||
        !IsInplacePaintAllowed());
    
    if (fInView)
    {
        if (pSelect->_fSetComboVert)
        {
            pSelect->_fSetComboVert = FALSE;

            UINT uFlags = SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOREDRAW;
      
            // this call just sets the window size
            SetWindowPos(pSelect->_hwnd,
                NULL,
                prcClient->left,
                prcClient->top,
                prcClient->right - prcClient->left,
                pSelect->_fListbox ? prcClient->bottom - prcClient->top :
                    pSelect->_lComboHeight,
                uFlags);

            // make sure we show the window
            fInViewChanged = TRUE;
        }
    }
       
    if (fMoved || fInViewChanged)
    {
        DWORD positionChangeFlags = SWP_NOACTIVATE | SWP_NOZORDER;
        if (fInViewChanged)
            positionChangeFlags |= (fInView) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
        if (fNoRedraw)
            positionChangeFlags |= SWP_NOREDRAW;
    
        CRect rcClip(*prcClip);

        rcClip.OffsetRect(-((const CRect*)prcClient)->TopLeft().AsSize());

        pSelect->SetVisibleRect(rcClip);

        CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());

        if (g_uiDisplay.IsDeviceScaling() && pSelect && !pSelect->_fListbox)
        {
            // Bug 27787: There is a bug in the combobox control where resizing the height of the
            // control may cause the combobox to resize itself incorrectly.  For some reason with
            // hidpi support our layout rects don't correspond correctly with what the combobox
            // expects and we see this bug.  So to workaround this issue we'll keep the current
            // control height and just update the width and top left positions.
            CRect rcSelectWnd;
            ::GetWindowRect(pSelect->_hwnd, &rcSelectWnd);
            rcSelectWnd.bottom = prcClient->top + (rcSelectWnd.bottom - rcSelectWnd.top);
            rcSelectWnd.left = prcClient->left;
            rcSelectWnd.top = prcClient->top;
            rcSelectWnd.right = prcClient->right;

            DeferSetWindowPos(pSelect->_hwnd, &rcSelectWnd, positionChangeFlags, NULL);
        }
        else
        {
            DeferSetWindowPos(pSelect->_hwnd, prcClient, positionChangeFlags, NULL);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Obscure
//              
//  Synopsis:   Obscure the control, by clipping it to the given region
//              
//----------------------------------------------------------------------------

void
CSelectLayout::Obscure(CRect *prcgClient, CRect *prcgClip, CRegion2 *prgngVisible)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    CRegion2 rgng = *prgngVisible;

    rgng.Offset(- prcgClient->TopLeft().AsSize() );
    pSelect->SetVisibleRegion(rgng);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::ProcessDisplayTreeTraversal
//              
//  Synopsis:   Add our window to the z order list.
//              
//  Arguments:  pClientData     window order information
//              
//  Returns:    TRUE to continue display tree traversal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CSelectLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    if (pSelect->_hwnd)
    {
        CView::CWindowOrderInfo* pWindowOrderInfo =
            (CView::CWindowOrderInfo*) pClientData;
        pWindowOrderInfo->AddWindow(pSelect->_hwnd);
    }
    
    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member : GetChildElementTopLeft
//
//  Synopsis : CLayout virtual override, the job of this function is to
//      translate Queries for the top left of an option (the only element
//      that would be a child of the select) into the top left, of the select
//      itself.
//
//----------------------------------------------------------------------------

HRESULT
CSelectLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    // Only OPTIONs can be children of SELECT
    Assert( pChild && pChild->Tag() == ETAG_OPTION );
    
    // an option's top left is reported as 0,0 (Bug #41111).
    pt.x = pt.y = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\tarealyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       tarealyt.cxx
//
//  Contents:   Implementation of layout class for <RICHTEXT> <TEXTAREA> controls.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXt_H_
#include "_text.h"
#endif

MtDefine(CTextAreaLayout, Layout, "CTextAreaLayout")
MtDefine(CRichtextLayout, Layout, "CRichtextLayout")

extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);

const CLayout::LAYOUTDESC CRichtextLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CRichtextLayout::Init()
{
    HRESULT hr = S_OK;

    hr = super::Init();

    if(hr)
        goto Cleanup;

    _fAllowSelectionInDialog = TRUE;

    // Can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CRichtextLayout::SetWrap()
{
    BOOL    fWrap = IsWrapSet();

    GetDisplay()->SetWordWrap(fWrap);
    GetDisplay()->SetWrapLongLines(fWrap);
}

BOOL
CRichtextLayout::IsWrapSet()
{
    return (DYNCAST(CRichtext, ElementOwner())->GetAAwrap() != htmlWrapOff);
}

HRESULT
CRichtextLayout::OnTextChange(void)
{
    CRichtext *     pInput  = DYNCAST(CRichtext, ElementOwner());

    if (!pInput->IsEditable(TRUE))
        pInput->_fTextChanged = TRUE;

    if (pInput->_fFiredValuePropChange)
    {
        pInput->_fFiredValuePropChange = FALSE;
    }
    else
    {
        pInput->OnPropertyChange(DISPID_CRichtext_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCRichtextvalue); // value change
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRichtextLayout::DrawClient
//
//  Synopsis:   Draw client rect part of the controls
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CRichtextLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    {
        // we set draw surface information separately for Draw() and
        // the stuff below, because the Draw method of some subclasses
        // (like CFlowLayout) puts pDI into a special device coordinate
        // mode
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        Draw(pDI);
    }

    {
        // see comment above
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

        // We only want to paint selection on the client rect in this part
        // In RTL the scrollbar is on the left and will leave extra highlighting
        // on the right side of the control if we do not adjust it here
        if (_fTextSelected)
        {
            DrawTextSelectionForRect(pDI->GetDC(), (CRect *)prcRedraw ,& pDI->_rcClip , _fSwapColor);
        }

        // just check whether we can draw zero border at design time
        if (IsShowZeroBorderAtDesignTime())
        {
            CLayout* pParentLayout = GetUpdatedParentLayout();
            if ( pParentLayout && pParentLayout->IsEditable() )
            {
                 DrawZeroBorder(pDI);
            }
        }
    }
}


void
CRichtextLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    CRichtext *     pElem = DYNCAST(CRichtext, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_EDIT);

    Assert(pClientData);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);
        CRect           rc;        

        if (hdc.DrawThemeBackground(    hTheme,
                                        EP_EDITTEXT,
                                        pElem->GetThemeState(),
                                        &pDI->_rc,
                                        NULL))
            return;
        else
            super::DrawClientBorder(prcBounds,
                                prcRedraw,
                                pDispSurface,
                                pDispNode,
                                pClientData,
                                dwFlags);

    }
    super::DrawClientBorder(prcBounds,
                                prcRedraw,
                                pDispSurface,
                                pDispNode,
                                pClientData,
                                dwFlags);
}

void
CTextAreaLayout::GetPlainTextWithBreaks(TCHAR * pchBuff)
{
    CDisplay *  pdp = GetDisplay();
    CTxtPtr     tp(pdp->GetMarkup(), GetContentFirstCp());
    long        i;
    long        c = pdp->Count();
    CLineCore  *pLine;

    for(i = 0; i < c; i++)
    {
        pLine = pdp->Elem(i);

        if (pLine->_cch)
        {
            tp.GetRawText(pLine->_cch, pchBuff);
            tp.AdvanceCp(pLine->_cch);
            pchBuff += pLine->_cch;

            // If the line ends in a '\r', we need to append a '\r'.
            // Otherwise, it must be having a soft break (unless it is
            // the last line), so we need to append a '\r\n'
            if (pLine->_fHasBreak)
            {
                Assert(*(pchBuff - 1) == _T('\r'));
                *pchBuff++ = _T('\n');
            }
            else if ( i < c - 1)
            {
                *pchBuff++ = _T('\r');
                *pchBuff++ = _T('\n');
            }
        }
    }
    // Null-terminate
    *pchBuff = 0;
}

long
CTextAreaLayout::GetPlainTextLengthWithBreaks()
{
    long        len     = 1; // for trailing '\0'
    long        i;
    CDisplay *  pdp = GetDisplay();
    long        c = pdp->Count();
    CLineCore  *pLine;

    for(i = 0; i < c; i++)
    {
        // Every line except the last must be non-empty.
        Assert(i == c - 1 || pdp->Elem(i)->_cch > 0);

        pLine = pdp->Elem(i);
        Assert(pLine);
        len += pLine->_cch;

        // If the line ends in a '\r', we need to append a '\r'.
        // Otherwise, it must be having a soft break (unless it is
        // the last line), so we need to append a '\r\n'
        if (pLine->_fHasBreak)
        {
            len++;
        }
        else if (i < c - 1)
        {
            len += 2;
        }
    }

    return len;
}

void CRichtextLayout::GetDefaultSize(CCalcInfo *pci, SIZE &psize, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CRichtext     * pTextarea = DYNCAST(CRichtext, ElementOwner());
    CTreeNode *     pTreeNode = pTextarea->GetFirstBranch();
    int             charX = 1;
    int             charY = 1;
    BOOL            fIsPrinting = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
    styleOverflow   overflow;
    extern SIZE     g_sizelScrollbar;
    const CCharFormat * pCF = pTreeNode->GetCharFormat();
    SIZE            sizeInset;

    sizeInset.cx = TEXT_INSET_DEFAULT_RIGHT + TEXT_INSET_DEFAULT_LEFT;
    sizeInset.cy = TEXT_INSET_DEFAULT_TOP   + TEXT_INSET_DEFAULT_BOTTOM;

    charX = pTextarea->GetAAcols();
    Assert(charX > 0);
    charY = pTextarea->GetAArows();
    Assert(charY > 0);

    GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);
        
    psize.cx = charX * sizeFontForLongStr.cx
                + pci->DeviceFromDocPixelsX(sizeInset.cx
                                        + (fIsPrinting ? 0 : GetDisplay()->GetCaret()));
    psize.cy = charY * sizeFontForLongStr.cy
                + pci->DeviceFromDocPixelsY(sizeInset.cy);

    overflow = pTreeNode->GetFancyFormat()->GetLogicalOverflowY(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
    if (overflow != styleOverflowHidden)
    {
        psize.cx += pci->DeviceFromHimetricX(g_sizelScrollbar.cx);
        if (!IsWrapSet())
        {
            psize.cy += pci->DeviceFromHimetricY(g_sizelScrollbar.cy);
        }
    }

    AdjustSizeForBorder(&psize, pci, TRUE);
    SetWrap();

    *fHasDefaultWidth = TRUE;
    *fHasDefaultHeight = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\misc\siteid.c ===
/*
   siteid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <siteguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\comment.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       comment.cxx
//
//  Contents:   CCommentElement
//
//  History:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "comment.hdl"

MtDefine(CCommentElement, Elements, "CCommentElement")
ExternTag(tagDontRewriteDocType);

static
HRESULT
SetTextHelper(CStr *cstrText, LPTSTR lptnewstr, long length, ELEMENT_TAG Tag )
{
    HRESULT hr;
    if(Tag == ETAG_RAW_COMMENT)
    {
        hr = THR(cstrText->Set(_T("<!--"), 4));
        if(hr)
            goto Cleanup;
        
        hr = THR(cstrText->Append(lptnewstr, length));
        if(hr)
            goto Cleanup;
        
        hr = THR(cstrText->Append(_T("-->"), 3));
        if(hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(cstrText->Set(lptnewstr, length));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------
//
//  Class: CCommentElement
//
//------------------------------------------------------------

const CElement::CLASSDESC CCommentElement::s_classdesc =
{
    {
        &CLSID_HTMLCommentElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLCommentElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLCommentElement,    // _apfnTearOff
    NULL                                    // _pAccelsRun
};



HRESULT CCommentElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr = S_OK;

    CCommentElement *pElementComment;

    Assert(ppElement);

    pElementComment = new CCommentElement(pht->GetTag(), pDoc);
    if (!pElementComment)
        return E_OUTOFMEMORY;

    pElementComment->_fAtomic = pht->Is(ETAG_RAW_COMMENT);
    
    *ppElement = (CElement *)pElementComment;
    if (pElementComment->_fAtomic)
    {
        hr = pElementComment->_cstrText.Set(pht->GetPch(), pht->GetCch());
    }
    RRETURN(hr);
}

HRESULT
CCommentElement::Save( CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd )
{
    HRESULT hr = S_OK;

    // Don't write out comments for end tags, plain text, RTF, or if
    // it's the DOCTYPE comment.
    if (    fEnd 
        ||  pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT) 
        ||  pStreamWriteBuff->TestFlag(WBF_FOR_RTF_CONV)
        || (    _cstrText.Length() >= 9 && StrCmpNIC(_T("<!DOCTYPE"), _cstrText, 9) == 0 
            &&  !Doc()->_fDontWhackGeneratorOrCharset WHEN_DBG( && !IsTagEnabled( tagDontRewriteDocType ) ) ) )
        return(hr);

    DWORD dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

    pStreamWriteBuff->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);

    // TODO: hack to preserve line breaks
    pStreamWriteBuff->BeginPre();

    if (!_fAtomic)
    {
        // Save <tagname>
        hr = THR(super::Save(pStreamWriteBuff, FALSE));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));

    if (hr)
        goto Cleanup;
    if (!_fAtomic)
    {
        // Save </tagname>
        hr = THR(super::Save(pStreamWriteBuff, TRUE));
        if (hr)
            goto Cleanup;
    }

    //TODO see above
    pStreamWriteBuff->EndPre();

    if (!hr)
    {
        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }
Cleanup:
    RRETURN(hr);
}

HRESULT
CCommentElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF(this, IHTMLCommentElement2, NULL);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

HRESULT
CCommentElement::get_data(BSTR *pbstrData)
{
    HRESULT hr = S_OK;

    if(!pbstrData)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(Tag() == ETAG_RAW_COMMENT)
        hr = FormsAllocStringLen ( _cstrText+4, _cstrText.Length()-7, pbstrData );
    else
        hr = FormsAllocStringLen ( _cstrText, _cstrText.Length(), pbstrData );

    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::put_data(BSTR bstrData)
{
    HRESULT hr = S_OK;

    hr = THR(SetTextHelper(&_cstrText, bstrData, SysStringLen(bstrData), Tag()));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::get_length(long *pLength)
{
    HRESULT hr = S_OK;

    *pLength = _cstrText.Length();
    
    if(Tag() == ETAG_RAW_COMMENT)
        *pLength -= 7;

    goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::substringData (long loffset, long lCount, BSTR* pbstrsubString)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    if(Tag() == ETAG_RAW_COMMENT) length -= 7;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(numChars > lCount)
        numChars = lCount;

    if(Tag() == ETAG_RAW_COMMENT)
        loffset+=4; //Account for Raw_Comment

    hr = THR(FormsAllocStringLen(_cstrText+loffset, numChars, pbstrsubString));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CCommentElement::appendData (BSTR bstrstring)
{
    HRESULT hr = S_OK;
    LPTSTR lptnewstr = NULL;

    if(Tag() == ETAG_RAW_COMMENT)
    {
        LPTSTR lpstr = LPTSTR(_cstrText);
        long length = _cstrText.Length();
        lptnewstr = new TCHAR[length-3];
        if(!lptnewstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        CopyMemory(lptnewstr, lpstr, (length-3)*sizeof(TCHAR));
        hr = THR(_cstrText.Set(lptnewstr, length-3));
        if(hr)
            goto Cleanup;

    }
    
    hr = THR(_cstrText.Append(bstrstring));
    if( hr )
        goto Cleanup;

    if(Tag() == ETAG_RAW_COMMENT)
    {
        hr = THR(_cstrText.Append(_T("-->")));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    if(lptnewstr)
        delete lptnewstr;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::insertData (long loffset, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT)
    {
        length -= 7;
        rawoffset = 4;
    }
    LPTSTR lptnewstr = NULL;
    long linslength = SysStringLen(bstrstring);
    long lcomvar = linslength + loffset;

    if(loffset > length || loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    length += linslength;

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, bstrstring, linslength*sizeof(TCHAR));
    CopyMemory(lptnewstr+lcomvar, _cstrText+rawoffset+loffset, (length-lcomvar)*sizeof(TCHAR));
    
    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::deleteData (long loffset, long lCount)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT) 
    {
        length -= 7;
        rawoffset = 4;
    }
    LPTSTR lptnewstr = NULL;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if(!lCount)
        goto Cleanup;
        
    if(numChars > lCount)
        numChars = lCount;

    length -= numChars;

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, _cstrText + rawoffset + loffset + numChars, (length - loffset)*sizeof(TCHAR));

    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::replaceData (long loffset, long lCount, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT) 
    {
        length -= 7;
        rawoffset = 4;
    }

    LPTSTR lptnewstr = NULL;
    long linslength = SysStringLen(bstrstring);
    long lcomvar = linslength + loffset;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(numChars > lCount)
        numChars = lCount;

    length += (linslength-numChars);

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, bstrstring, linslength*sizeof(TCHAR));

    CopyMemory(lptnewstr+lcomvar, _cstrText+loffset+numChars+rawoffset, (length-lcomvar)*sizeof(TCHAR));

    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\div.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eblock.cxx
//
//  Contents:   Div element class
//
//  Classes:    CDivElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

class CHtmTag;

#define _cxx_
#include "div.hdl"

interface IHTMLControlElement;

extern "C" const IID IID_IControl;

const CElement::CLASSDESC CDivElement::s_classdesc =
{
    {
        &CLSID_HTMLDivElement,               // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLDivElement,                // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDivElement,         // _pfnTearOff
    NULL                                     // _pAccelsRun
};

HRESULT
CDivElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DIV));
    Assert(ppElement);
    *ppElement = new CDivElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}



#ifndef NO_DATABINDING

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CDivElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDivElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CDivElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

        if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {

        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else if (iid == IID_IHTMLTextContainer)
    {
        hr = CreateTearOffThunk(this,
                                (void *)this->s_apfnIHTMLTextContainer,
                                NULL,
                                ppv);
        if (hr)
            RRETURN(hr);
    }
/*
    else if (iid == IID_IHTMLDivPosition)
    {
        hr = CreateTearOffThunk(this, 
                                s_apfnpdIHTMLDivPosition, 
                                NULL, 
                                ppv,
                                (void*)s_ppropdescsInVtblOrderIHTMLDivPosition);
        if (hr)
            RRETURN(hr);
    }
*/
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}
#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\misc\siteidpr.c ===
/*
   siteidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <siteguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\layout\viewchain.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1999
//
//  File:       VIEWCHAIN.CXX
//
//  Contents:   Implementation of CViewChain and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_VIEWCHAIN_HXX_
#define X_VIEWCHAIN_HXX_
#include "viewchain.hxx"
#endif

MtDefine(CViewChain_pv, ViewChain, "CViewChain_pv");
MtDefine(CViewChain_aryRequest_pv, ViewChain, "CViewChain_aryRequest_pv");

DeclareTag(tagVCContext, "Layout: ViewChain", "Trace Add/Remove context to ViewChain");

//============================================================================
//
//  CViewChain methods
//
//============================================================================

//----------------------------------------------------------------------------
//
//  Member: AddContext
//
//  Note:   Allocates new break table object for context document and inserts 
//          it after pLContextPrev.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::AddContext(CLayoutContext *pLContext, CLayoutContext *pLContextPrev)
{
    HRESULT     hr;
    CBreakBase *pBreakTable;

    TraceTagEx((tagVCContext, TAG_NONAME,
                "VC AddContext: this=0x%x, add=0x%x, prev=0x%x",
                this,
                pLContext, pLContextPrev ));

    Assert(pLContext != NULL);

    pBreakTable = new CBreakTable();
    if (pBreakTable == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _bt.SetBreakAfter((void *)pLContext, (void *)pLContextPrev, pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: ReleaseContext
//
//  Note:   Removes array entry (and all data) for pLContext 
//----------------------------------------------------------------------------
HRESULT 
CViewChain::ReleaseContext(CLayoutContext *pLContext)
{
    HRESULT hr;

    TraceTagEx((tagVCContext, TAG_NONAME,
                "VC ReleaseContext: this=0x%x, rel=0x%x",
                this,
                pLContext ));

    Assert(pLContext != NULL);
    
    hr = _bt.RemoveBreak((void *)pLContext);
    Assert(SUCCEEDED(hr));

    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: RemoveLayoutBreak
//
//  Note:   Removes break data for certain element in certain layout context.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::RemoveLayoutBreak(CLayoutContext *pLContext, CElement *pElement)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->RemoveBreak((void *)pElement);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: SetLayoutBreak
//
//  Note:   Sets break data for certain element in certain layout context.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::SetLayoutBreak(CLayoutContext *pLContext, 
                     CElement *pElement, CLayoutBreak *pLayoutBreak)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->SetBreak((void *)pElement, pLayoutBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: GetLayoutBreak
//
//  Note:   Retrieves break data for certain element in certain layout context.
//          Actually break data for previous layout context is returned 
//          (beginning of the rectangle is the ending of previous one). 
//----------------------------------------------------------------------------
HRESULT 
CViewChain::GetLayoutBreak(CLayoutContext *pLContext, 
                     CElement *pElement, CLayoutBreak **ppLayoutBreak, BOOL fEnding)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;
    CBreakBase      *pLayoutBreak;

    Assert( HasLayoutOwner() );
    Assert(ppLayoutBreak);

    *ppLayoutBreak = NULL;

    hr = _bt.GetBreakByIndex(_bt.GetIndex((void *)pLContext) - (fEnding ? 0 : 1), &pBreakTable);
    if (FA