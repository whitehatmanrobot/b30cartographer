put_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;

  /* Emit file header */
  switch (cinfo->out_color_space) {
  case JCS_GRAYSCALE:
    /* emit header for raw PGM format */
    fprintf(dest->pub.output_file, "P5\n%ld %ld\n%d\n",
	    (long) cinfo->output_width, (long) cinfo->output_height,
	    PPM_MAXVAL);
    break;
  case JCS_RGB:
    /* emit header for raw PPM format */
    fprintf(dest->pub.output_file, "P6\n%ld %ld\n%d\n",
	    (long) cinfo->output_width, (long) cinfo->output_height,
	    PPM_MAXVAL);
    break;
  default:
    ERREXIT(cinfo, JERR_PPM_COLORSPACE);
  }
}


/*
 * Finish up at the end of the file.
 */

METHODDEF(void)
finish_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  /* Make sure we wrote the output file OK */
  fflush(dinfo->output_file);
  if (ferror(dinfo->output_file))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * The module selection routine for PPM format output.
 */

GLOBAL(djpeg_dest_ptr)
jinit_write_ppm (j_decompress_ptr cinfo)
{
  ppm_dest_ptr dest;

  /* Create module interface object, fill in method pointers */
  dest = (ppm_dest_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(ppm_dest_struct));
  dest->pub.start_output = start_output_ppm;
  dest->pub.finish_output = finish_output_ppm;

  /* Calculate output image dimensions so we can allocate space */
  jpeg_calc_output_dimensions(cinfo);

  /* Create physical I/O buffer.  Note we make this near on a PC. */
  dest->samples_per_row = cinfo->output_width * cinfo->out_color_components;
  dest->buffer_width = dest->samples_per_row * (BYTESPERSAMPLE * SIZEOF(char));
  dest->iobuffer = (char *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, dest->buffer_width);

  if (cinfo->quantize_colors || BITS_IN_JSAMPLE != 8 ||
      SIZEOF(JSAMPLE) != SIZEOF(char)) {
    /* When quantizing, we need an output buffer for colormap indexes
     * that's separate from the physical I/O buffer.  We also need a
     * separate buffer if pixel format translation must take place.
     */
    dest->pub.buffer = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       cinfo->output_width * cinfo->output_components, (JDIMENSION) 1);
    dest->pub.buffer_height = 1;
    if (! cinfo->quantize_colors)
      dest->pub.put_pixel_rows = copy_pixel_rows;
    else if (cinfo->out_color_space == JCS_GRAYSCALE)
      dest->pub.put_pixel_rows = put_demapped_gray;
    else
      dest->pub.put_pixel_rows = put_demapped_rgb;
  } else {
    /* We will fwrite() directly from decompressor output buffer. */
    /* Synthesize a JSAMPARRAY pointer structure */
    /* Cast here implies near->far pointer conversion on PCs */
    dest->pixrow = (JSAMPROW) dest->iobuffer;
    dest->pub.buffer = & dest->pixrow;
    dest->pub.buffer_height = 1;
    dest->pub.put_pixel_rows = put_pixel_rows;
  }

  return (djpeg_dest_ptr) dest;
}

#endif /* PPM_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\wrrle.c ===
/*
 * wrrle.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to write output images in RLE format.
 * The Utah Raster Toolkit library is required (version 3.1 or later).
 *
 * These routines may need modification for non-Unix environments or
 * specialized applications.  As they stand, they assume output to
 * an ordinary stdio stream.
 *
 * Based on code contributed by Mike Lijewski,
 * with updates from Robert Hutchinson.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */

#ifdef RLE_SUPPORTED

/* rle.h is provided by the Utah Raster Toolkit. */

#include <rle.h>

/*
 * We assume that JSAMPLE has the same representation as rle_pixel,
 * to wit, "unsigned char".  Hence we can't cope with 12- or 16-bit samples.
 */

#if BITS_IN_JSAMPLE != 8
  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */
#endif


/*
 * Since RLE stores scanlines bottom-to-top, we have to invert the image
 * from JPEG's top-to-bottom order.  To do this, we save the outgoing data
 * in a virtual array during put_pixel_row calls, then actually emit the
 * RLE file during finish_output.
 */


/*
 * For now, if we emit an RLE color map then it is always 256 entries long,
 * though not all of the entries need be used.
 */

#define CMAPBITS	8
#define CMAPLENGTH	(1<<(CMAPBITS))

typedef struct {
  struct djpeg_dest_struct pub; /* public fields */

  jvirt_sarray_ptr image;	/* virtual array to store the output image */
  rle_map *colormap;	 	/* RLE-style color map, or NULL if none */
  rle_pixel **rle_row;		/* To pass rows to rle_putrow() */

} rle_dest_struct;

typedef rle_dest_struct * rle_dest_ptr;

/* Forward declarations */
METHODDEF(void) rle_put_pixel_rows
    JPP((j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
	 JDIMENSION rows_supplied));


/*
 * Write the file header.
 *
 * In this module it's easier to wait till finish_output to write anything.
 */

METHODDEF(void)
start_output_rle (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  rle_dest_ptr dest = (rle_dest_ptr) dinfo;
  size_t cmapsize;
  int i, ci;
#ifdef PROGRESS_REPORT
  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;
#endif

  /*
   * Make sure the image can be stored in RLE format.
   *
   * - RLE stores image dimensions as *signed* 16 bit integers.  JPEG
   *   uses unsigned, so we have to check the width.
   *
   * - Colorspace is expected to be grayscale or RGB.
   *
   * - The number of channels (components) is expected to be 1 (grayscale/
   *   pseudocolor) or 3 (truecolor/directcolor).
   *   (could be 2 or 4 if using an alpha channel, but we aren't)
   */

  if (cinfo->output_width > 32767 || cinfo->output_height > 32767)
    ERREXIT2(cinfo, JERR_RLE_DIMENSIONS, cinfo->output_width, 
	     cinfo->output_height);

  if (cinfo->out_color_space != JCS_GRAYSCALE &&
      cinfo->out_color_space != JCS_RGB)
    ERREXIT(cinfo, JERR_RLE_COLORSPACE);

  if (cinfo->output_components != 1 && cinfo->output_components != 3)
    ERREXIT1(cinfo, JERR_RLE_TOOMANYCHANNELS, cinfo->num_components);

  /* Convert colormap, if any, to RLE format. */

  dest->colormap = NULL;

  if (cinfo->quantize_colors) {
    /* Allocate storage for RLE-style cmap, zero any extra entries */
    cmapsize = cinfo->out_color_components * CMAPLENGTH * SIZEOF(rle_map);
    dest->colormap = (rle_map *) (*cinfo->mem->alloc_small)
      ((j_common_ptr) cinfo, JPOOL_IMAGE, cmapsize);
    MEMZERO(dest->colormap, cmapsize);

    /* Save away data in RLE format --- note 8-bit left shift! */
    /* Shifting would need adjustment for JSAMPLEs wider than 8 bits. */
    for (ci = 0; ci < cinfo->out_color_components; ci++) {
      for (i = 0; i < cinfo->actual_number_of_colors; i++) {
        dest->colormap[ci * CMAPLENGTH + i] =
          GETJSAMPLE(cinfo->colormap[ci][i]) << 8;
      }
    }
  }

  /* Set the output buffer to the first row */
  dest->pub.buffer = (*cinfo->mem->access_virt_sarray)
    ((j_common_ptr) cinfo, dest->image, (JDIMENSION) 0, (JDIMENSION) 1, TRUE);
  dest->pub.buffer_height = 1;

  dest->pub.put_pixel_rows = rle_put_pixel_rows;

#ifdef PROGRESS_REPORT
  if (progress != NULL) {
    progress->total_extra_passes++;  /* count file writing as separate pass */
  }
#endif
}


/*
 * Write some pixel data.
 *
 * This routine just saves the data away in a virtual array.
 */

METHODDEF(void)
rle_put_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		    JDIMENSION rows_supplied)
{
  rle_dest_ptr dest = (rle_dest_ptr) dinfo;

  if (cinfo->output_scanline < cinfo->output_height) {
    dest->pub.buffer = (*cinfo->mem->access_virt_sarray)
      ((j_common_ptr) cinfo, dest->image,
       cinfo->output_scanline, (JDIMENSION) 1, TRUE);
  }
}

/*
 * Finish up at the end of the file.
 *
 * Here is where we really output the RLE file.
 */

METHODDEF(void)
finish_output_rle (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  rle_dest_ptr dest = (rle_dest_ptr) dinfo;
  rle_hdr header;		/* Output file information */
  rle_pixel **rle_row, *red, *green, *blue;
  JSAMPROW output_row;
  char cmapcomment[80];
  int row, col;
  int ci;
#ifdef PROGRESS_REPORT
  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;
#endif

  /* Initialize the header info */
  header = *rle_hdr_init(NULL);
  header.rle_file = dest->pub.output_file;
  header.xmin     = 0;
  header.xmax     = cinfo->output_width  - 1;
  header.ymin     = 0;
  header.ymax     = cinfo->output_height - 1;
  header.alpha    = 0;
  header.ncolors  = cinfo->output_components;
  for (ci = 0; ci < cinfo->output_components; ci++) {
    RLE_SET_BIT(header, ci);
  }
  if (cinfo->quantize_colors) {
    header.ncmap   = cinfo->out_color_components;
    header.cmaplen = CMAPBITS;
    header.cmap    = dest->colormap;
    /* Add a comment to the output image with the true colormap length. */
    sprintf(cmapcomment, "color_map_length=%d", cinfo->actual_number_of_colors);
    rle_putcom(cmapcomment, &header);
  }

  /* Emit the RLE header and color map (if any) */
  rle_put_setup(&header);

  /* Now output the RLE data from our virtual array.
   * We assume here that (a) rle_pixel is represented the same as JSAMPLE,
   * and (b) we are not on a machine where FAR pointers differ from regular.
   */

#ifdef PROGRESS_REPORT
  if (progress != NULL) {
    progress->pub.pass_limit = cinfo->output_height;
    progress->pub.pass_counter = 0;
    (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);
  }
#endif

  if (cinfo->output_components == 1) {
    for (row = cinfo->output_height-1; row >= 0; row--) {
      rle_row = (rle_pixel **) (*cinfo->mem->access_virt_sarray)
        ((j_common_ptr) cinfo, dest->image,
	 (JDIMENSION) row, (JDIMENSION) 1, FALSE);
      rle_putrow(rle_row, (int) cinfo->output_width, &header);
#ifdef PROGRESS_REPORT
      if (progress != NULL) {
        progress->pub.pass_counter++;
        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);
      }
#endif
    }
  } else {
    for (row = cinfo->output_height-1; row >= 0; row--) {
      rle_row = (rle_pixel **) dest->rle_row;
      output_row = * (*cinfo->mem->access_virt_sarray)
        ((j_common_ptr) cinfo, dest->image,
	 (JDIMENSION) row, (JDIMENSION) 1, FALSE);
      red = rle_row[0];
      green = rle_row[1];
      blue = rle_row[2];
      for (col = cinfo->output_width; col > 0; col--) {
        *red++ = GETJSAMPLE(*output_row++);
        *green++ = GETJSAMPLE(*output_row++);
        *blue++ = GETJSAMPLE(*output_row++);
      }
      rle_putrow(rle_row, (int) cinfo->output_width, &header);
#ifdef PROGRESS_REPORT
      if (progress != NULL) {
        progress->pub.pass_counter++;
        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);
      }
#endif
    }
  }

#ifdef PROGRESS_REPORT
  if (progress != NULL)
    progress->completed_extra_passes++;
#endif

  /* Emit file trailer */
  rle_puteof(&header);
  fflush(dest->pub.output_file);
  if (ferror(dest->pub.output_file))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * The module selection routine for RLE format output.
 */

GLOBAL(djpeg_dest_ptr)
jinit_write_rle (j_decompress_ptr cinfo)
{
  rle_dest_ptr dest;

  /* Create module interface object, fill in method pointers */
  dest = (rle_dest_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                                  SIZEOF(rle_dest_struct));
  dest->pub.start_output = start_output_rle;
  dest->pub.finish_output = finish_output_rle;

  /* Calculate output image dimensions so we can allocate space */
  jpeg_calc_output_dimensions(cinfo);

  /* Allocate a work array for output to the RLE library. */
  dest->rle_row = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     cinfo->output_width, (JDIMENSION) cinfo->output_components);

  /* Allocate a virtual array to hold the image. */
  dest->image = (*cinfo->mem->request_virt_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
     (JDIMENSION) (cinfo->output_width * cinfo->output_components),
     cinfo->output_height, (JDIMENSION) 1);

  return (djpeg_dest_ptr) dest;
}

#endif /* RLE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\cjpeg\jmemmgr.c ===
#include <stdio.h>
#include <malloc.h>
#include "jpeglib.h"

void jpeg_error_exit(j_common_ptr cinfo)
{
/*    RaiseException(0, 0, 0, NULL);*/
return;
}

// Memory manager functions.  Note that the JPEG MMX codes require 64-bit
// aligned memory.  On NT malloc always returns 64-bit aligned memory,
// but on Win9x the memory is only 32-bit aligned.  So our memory manager
// guarantees 64-bit alignment on top of malloc calls.

#include "jmemsys.h"

#define ALIGN_SIZE sizeof(double)  // must be a power of 2 and 
                                   // bigger than a pointer

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
    int p = (int) malloc(sizeofobject + ALIGN_SIZE);
    int *alignedPtr = (int *) ((p + ALIGN_SIZE) & ~(ALIGN_SIZE - 1));
    alignedPtr[-1] = p;

    return (void *) alignedPtr;    
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
    free(((void **) object)[-1]);
}

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
    return jpeg_get_large(cinfo, sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
    jpeg_free_large(cinfo, object, sizeofobject);
}

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
                    long max_bytes_needed, long already_allocated)
{
  return max_bytes_needed;
}

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
    jpeg_error_exit(cinfo);
}

GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { return 0;}
GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\cmyk2rgb.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Cmyk2Rgb
*
* Abstract:
*
*   Convert an CMYK image to an RGB image
*
* Revision History:
*
*   02/20/2000 MinLiu
*       Created it.
*
* Note: If we really want to increase the performance, we can build a look up
*       table for the "f" table and all the "gC2R" table which takes 13 * 256
*       element which is not too big at all.
*
*       Also, this is not the best set of coefficient. It has too much
*       "greenish" component in it. If we can find a better table later, we need
*       just to replace the constructor of this class. That's also the reason we
*       don't need the look up table for now.
*
\**************************************************************************/

#include "precomp.hpp"
#include "cmyk2rgb.hpp"

#define MAXSAMPLE 255

// The divide macros round to nearest, the f array is pre-scaled by
// 255, the other arrays have the range 0..65535.

#define macroCMYK2RGB(p, r, i) \
   ((i < 192) ? (256*255 - (i)*(r) - 127) : \
   (256*255 - 192*(r) - (((i) - 192)*(255*(p) - 192*(r)) + 31)/63 ))

#define macroScale(x) \
   ((x) * 65793 >> 16)

#define SET(Q) \
    g ## Q[i] = macroCMYK2RGB(p ## Q, r ## Q, i);\
    g ## Q[i] = macroScale(g ## Q[i])

Cmyk2Rgb::Cmyk2Rgb(
    void
    ): f(NULL),
       gC2R(NULL),
       gC2G(NULL),
       gC2B(NULL),
       gM2R(NULL),
       gM2G(NULL),
       gM2B(NULL),
       gY2R(NULL),
       gY2G(NULL),
       gY2B(NULL)
{
    // Parameters which define the color transformation from CMYK->RGB

    const long pC2R = 256;
    const long pC2G = 103;
    const long pC2B = 12;

    const long pM2R = 48;
    const long pM2G = 256;
    const long pM2B = 144;

    const long pY2R = 0;
    const long pY2G = 11;
    const long pY2B = 228;

    const long pK2RGB = 256;

    const long rC2R = 206;
    const long rC2G = 94;
    const long rC2B = 0;

    const long rM2R = 24;
    const long rM2G = 186;
    const long rM2B = 132;

    const long rY2R = 0;
    const long rY2G = 7;
    const long rY2B = 171;

    const long rK2RGB = 223;

    UINT    uiConvertSize = (MAXSAMPLE + 1) * sizeof(UINT32);

    f    = (UINT32*)GpMalloc(uiConvertSize);
    gC2R = (UINT32*)GpMalloc(uiConvertSize);
    gC2G = (UINT32*)GpMalloc(uiConvertSize);
    gC2B = (UINT32*)GpMalloc(uiConvertSize);
    gM2R = (UINT32*)GpMalloc(uiConvertSize);
    gM2G = (UINT32*)GpMalloc(uiConvertSize);
    gM2B = (UINT32*)GpMalloc(uiConvertSize);
    gY2R = (UINT32*)GpMalloc(uiConvertSize);
    gY2G = (UINT32*)GpMalloc(uiConvertSize);
    gY2B = (UINT32*)GpMalloc(uiConvertSize);

    if ( (f == NULL)
       ||(gC2R == NULL) || (gC2G == NULL) || (gC2B == NULL)
       ||(gM2R == NULL) || (gM2G == NULL) || (gM2B == NULL)
       ||(gY2R == NULL) || (gY2G == NULL) || (gY2B == NULL) )
    {
        SetValid(FALSE);
        return;
    }
    
    // Initialize the lookup tables

    for (INT i = 0; i <= MAXSAMPLE; i++)
    {
        f[i] = macroCMYK2RGB(pK2RGB, rK2RGB, i);
        
        // Macro result is in the range 0..255*256, scale to 0..65536,
        // In debug check for overflow.
        
        SET(C2R);
        SET(C2G);
        SET(C2B);
        SET(M2R);
        SET(M2G);
        SET(M2B);
        SET(Y2R);
        SET(Y2G);
        SET(Y2B);
    }
    
    SetValid(TRUE);
}// Ctor()

Cmyk2Rgb::~Cmyk2Rgb(
    void
    )
{
    if ( f != NULL )
    {
        GpFree(f);
        f = NULL;
    }
  
    if ( gC2R != NULL )
    {
        GpFree(gC2R);
        gC2R = NULL;
    }
  
    if ( gC2G != NULL )
    {
        GpFree(gC2G);
        gC2G = NULL;
    }
    
    if ( gC2B != NULL )
    {
        GpFree(gC2B);
        gC2B = NULL;
    }
    
    if ( gM2R != NULL )
    {
        GpFree(gM2R);
        gM2R = NULL;
    }
  
    if ( gM2G != NULL )
    {
        GpFree(gM2G);
        gM2G = NULL;
    }
    
    if ( gM2B != NULL )
    {
        GpFree(gM2B);
        gM2B = NULL;
    }
    
    if ( gY2R != NULL )
    {
        GpFree(gY2R);
        gY2R = NULL;
    }
  
    if ( gY2G != NULL )
    {
        GpFree(gY2G);
        gY2G = NULL;
    }
    
    if ( gY2B != NULL )
    {
        GpFree(gY2B);
        gY2B = NULL;
    }

    SetValid(FALSE);    // so we don't use a deleted object
}// Dstor()

//----------------------------------------------------------------------------
//	Code which converts CMYK->RGB
//----------------------------------------------------------------------------

BOOL
Cmyk2Rgb::Convert(
    BYTE*   pbSrcBuf,
	BYTE*   pbDstBuf,
    UINT    uiWidth,
    UINT    uiHeight,
    UINT    uiStride
    )
{
    if ( !IsValid() )
    {
        return FALSE;
    }

    // Loop through all the rows
    
    for ( UINT j = 0; j < uiHeight; ++j )
    {
        BYTE*   pTempDst = pbDstBuf + j * uiStride;
        BYTE*   pTempSrc = pbSrcBuf + j * uiStride;

        for ( UINT i = 0; i < uiWidth; ++i )
        {
            int C = pTempSrc[2];
            int M = pTempSrc[1];
            int Y = pTempSrc[0];
            int K = pTempSrc[3];

            // process them through our mapping, the DEBUG check above
            // guarantees no overflow here.
            
            pTempDst[0] = ( ( (f[K] * gC2R[C] >> 16)
                            * gM2R[M] >> 16)
                          * gY2R[Y] >> 24);

            pTempDst[1] = ( ( (f[K] * gM2G[M] >> 16)
                            * gY2G[Y] >> 16)
                          * gC2G[C] >> 24);

            pTempDst[2] = ( ( (f[K] * gY2B[Y] >> 16)
                            * gC2B[C] >> 16)
                          * gM2B[M] >> 24);
            
            // Set it as an opaque image

            pTempDst[3] = 0xff;

            pTempDst += 4;
            pTempSrc += 4;
        }// col loop
    }// line loop

    return TRUE;
}// Convert()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\cmyk2rgb.hpp ===
#ifndef _CMYK2RGB_HPP_
#define _CMYK2RGB_HPP_

class Cmyk2Rgb
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagCmyk2Rgb) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Cmyk2Rgb");
        }
    #endif

        return (Tag == ObjectTagCmyk2Rgb);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagCmyk2Rgb : ObjectTagInvalid;
    }

public:
    Cmyk2Rgb();
    ~Cmyk2Rgb();
    BOOL Convert(BYTE*   pbSrcBuf,
	             BYTE*   pbDstBuf,
                 UINT    uiWidth,
                 UINT    uiHeight,
                 UINT    uiStride);

private:

    UINT32* f;    // Lookup table for K conversion
  
    // Lookup tables for opposite and adjacent components:

    UINT32* gC2R;
    UINT32* gC2G;
    UINT32* gC2B;
    UINT32* gM2R;
    UINT32* gM2G;
    UINT32* gM2B;
    UINT32* gY2R;
    UINT32* gY2G;
    UINT32* gY2B;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\wrtarga.c ===
/*
 * wrtarga.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to write output images in Targa format.
 *
 * These routines may need modification for non-Unix environments or
 * specialized applications.  As they stand, they assume output to
 * an ordinary stdio stream.
 *
 * Based on code contributed by Lee Daniel Crocker.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */

#ifdef TARGA_SUPPORTED


/*
 * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.
 * This is not yet implemented.
 */

#if BITS_IN_JSAMPLE != 8
  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */
#endif

/*
 * The output buffer needs to be writable by fwrite().  On PCs, we must
 * allocate the buffer in near data space, because we are assuming small-data
 * memory model, wherein fwrite() can't reach far memory.  If you need to
 * process very wide images on a PC, you might have to compile in large-memory
 * model, or else replace fwrite() with a putc() loop --- which will be much
 * slower.
 */


/* Private version of data destination object */

typedef struct {
  struct djpeg_dest_struct pub;	/* public fields */

  char *iobuffer;		/* physical I/O buffer */
  JDIMENSION buffer_width;	/* width of one row */
} tga_dest_struct;

typedef tga_dest_struct * tga_dest_ptr;


LOCAL(void)
write_header (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo, int num_colors)
/* Create and write a Targa header */
{
  char targaheader[18];

  /* Set unused fields of header to 0 */
  MEMZERO(targaheader, SIZEOF(targaheader));

  if (num_colors > 0) {
    targaheader[1] = 1;		/* color map type 1 */
    targaheader[5] = (char) (num_colors & 0xFF);
    targaheader[6] = (char) (num_colors >> 8);
    targaheader[7] = 24;	/* 24 bits per cmap entry */
  }

  targaheader[12] = (char) (cinfo->output_width & 0xFF);
  targaheader[13] = (char) (cinfo->output_width >> 8);
  targaheader[14] = (char) (cinfo->output_height & 0xFF);
  targaheader[15] = (char) (cinfo->output_height >> 8);
  targaheader[17] = 0x20;	/* Top-down, non-interlaced */

  if (cinfo->out_color_space == JCS_GRAYSCALE) {
    targaheader[2] = 3;		/* image type = uncompressed gray-scale */
    targaheader[16] = 8;	/* bits per pixel */
  } else {			/* must be RGB */
    if (num_colors > 0) {
      targaheader[2] = 1;	/* image type = colormapped RGB */
      targaheader[16] = 8;
    } else {
      targaheader[2] = 2;	/* image type = uncompressed RGB */
      targaheader[16] = 24;
    }
  }

  if (JFWRITE(dinfo->output_file, targaheader, 18) != (size_t) 18)
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * Write some pixel data.
 * In this module rows_supplied will always be 1.
 */

METHODDEF(void)
put_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		JDIMENSION rows_supplied)
/* used for unquantized full-color output */
{
  tga_dest_ptr dest = (tga_dest_ptr) dinfo;
  register JSAMPROW inptr;
  register char * outptr;
  register JDIMENSION col;

  inptr = dest->pub.buffer[0];
  outptr = dest->iobuffer;
  for (col = cinfo->output_width; col > 0; col--) {
    outptr[0] = (char) GETJSAMPLE(inptr[2]); /* RGB to BGR order */
    outptr[1] = (char) GETJSAMPLE(inptr[1]);
    outptr[2] = (char) GETJSAMPLE(inptr[0]);
    inptr += 3, outptr += 3;
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}

METHODDEF(void)
put_gray_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
	       JDIMENSION rows_supplied)
/* used for grayscale OR quantized color output */
{
  tga_dest_ptr dest = (tga_dest_ptr) dinfo;
  register JSAMPROW inptr;
  register char * outptr;
  register JDIMENSION col;

  inptr = dest->pub.buffer[0];
  outptr = dest->iobuffer;
  for (col = cinfo->output_width; col > 0; col--) {
    *outptr++ = (char) GETJSAMPLE(*inptr++);
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


/*
 * Write some demapped pixel data when color quantization is in effect.
 * For Targa, this is only applied to grayscale data.
 */

METHODDEF(void)
put_demapped_gray (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
		   JDIMENSION rows_supplied)
{
  tga_dest_ptr dest = (tga_dest_ptr) dinfo;
  register JSAMPROW inptr;
  register char * outptr;
  register JSAMPROW color_map0 = cinfo->colormap[0];
  register JDIMENSION col;

  inptr = dest->pub.buffer[0];
  outptr = dest->iobuffer;
  for (col = cinfo->output_width; col > 0; col--) {
    *outptr++ = (char) GETJSAMPLE(color_map0[GETJSAMPLE(*inptr++)]);
  }
  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);
}


/*
 * Startup: write the file header.
 */

METHODDEF(void)
start_output_tga (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  tga_dest_ptr dest = (tga_dest_ptr) dinfo;
  int num_colors, i;
  FILE *outfile;

  if (cinfo->out_color_space == JCS_GRAYSCALE) {
    /* Targa doesn't have a mapped grayscale format, so we will */
    /* demap quantized gray output.  Never emit a colormap. */
    write_header(cinfo, dinfo, 0);
    if (cinfo->quantize_colors)
      dest->pub.put_pixel_rows = put_demapped_gray;
    else
      dest->pub.put_pixel_rows = put_gray_rows;
  } else if (cinfo->out_color_space == JCS_RGB) {
    if (cinfo->quantize_colors) {
      /* We only support 8-bit colormap indexes, so only 256 colors */
      num_colors = cinfo->actual_number_of_colors;
      if (num_colors > 256)
	ERREXIT1(cinfo, JERR_TOO_MANY_COLORS, num_colors);
      write_header(cinfo, dinfo, num_colors);
      /* Write the colormap.  Note Targa uses BGR byte order */
      outfile = dest->pub.output_file;
      for (i = 0; i < num_colors; i++) {
	putc(GETJSAMPLE(cinfo->colormap[2][i]), outfile);
	putc(GETJSAMPLE(cinfo->colormap[1][i]), outfile);
	putc(GETJSAMPLE(cinfo->colormap[0][i]), outfile);
      }
      dest->pub.put_pixel_rows = put_gray_rows;
    } else {
      write_header(cinfo, dinfo, 0);
      dest->pub.put_pixel_rows = put_pixel_rows;
    }
  } else {
    ERREXIT(cinfo, JERR_TGA_COLORSPACE);
  }
}


/*
 * Finish up at the end of the file.
 */

METHODDEF(void)
finish_output_tga (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  /* Make sure we wrote the output file OK */
  fflush(dinfo->output_file);
  if (ferror(dinfo->output_file))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * The module selection routine for Targa format output.
 */

GLOBAL(djpeg_dest_ptr)
jinit_write_targa (j_decompress_ptr cinfo)
{
  tga_dest_ptr dest;

  /* Create module interface object, fill in method pointers */
  dest = (tga_dest_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(tga_dest_struct));
  dest->pub.start_output = start_output_tga;
  dest->pub.finish_output = finish_output_tga;

  /* Calculate output image dimensions so we can allocate space */
  jpeg_calc_output_dimensions(cinfo);

  /* Create I/O buffer.  Note we make this near on a PC. */
  dest->buffer_width = cinfo->output_width * cinfo->output_components;
  dest->iobuffer = (char *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(size_t) (dest->buffer_width * SIZEOF(char)));

  /* Create decompressor output buffer. */
  dest->pub.buffer = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, dest->buffer_width, (JDIMENSION) 1);
  dest->pub.buffer_height = 1;

  return (djpeg_dest_ptr) dest;
}

#endif /* TARGA_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\lib\imagelib.cpp ===
// Dummy file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\tiffcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Tiff Image codec
*
* Abstract:
*
*   Shared methods for the TIFF codec
*
* Revision History:
*
*   7/19/1999 MinLiu
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "tiffcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpTiffCodec::GpTiffCodec(
    void
    )
    :ComRefCount(1),
     InIStreamPtr(NULL),
     OutIStreamPtr(NULL),
     DecodeSinkPtr(NULL),
     ColorPalettePtr(NULL),
     LineSize(0),
     LastBufferAllocatedPtr(NULL),
     LastPropertyBufferPtr(NULL)
{
    SetValid(FALSE);
}// Ctor()

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpTiffCodec::~GpTiffCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if ( InIStreamPtr )
    {
        WARNING(("::~GpTiffCodec -- need to call TerminateDecoder first"));
        InIStreamPtr->Release();
        InIStreamPtr = NULL;
    }

    if ( OutIStreamPtr )
    {
        WARNING(("::~GpTiffCodec -- need to call TerminateEncoder first"));
        OutIStreamPtr->Release();
        OutIStreamPtr = NULL;
    }

    if ( ColorPalettePtr )
    {
        WARNING(("GpTiffCodec::~GpTiffCodec -- color palette not freed"));
        GpFree(ColorPalettePtr);
        ColorPalettePtr = NULL;
    }

    if( LastBufferAllocatedPtr )
    {
        // This points to the buffer in TIFF encoder when the source calls
        // GetPixelDataBuffer(). This piece of memory should be freed when
        // the caller calls ReleasePixelDataBuffer(). But in case the decording
        // failed and the caller can't call ReleasePixelDataBuffer() (bad
        // design), we have to clean up the memory here

        WARNING(("GpTiffCodec::~GpTiffCodec -- sink buffer not freed"));
        GpFree(LastBufferAllocatedPtr);
        LastBufferAllocatedPtr = NULL;
    }

    if ( LastPropertyBufferPtr != NULL )
    {
        // This points to the buffer in TIFF encoder when the source calls
        // GetPropertyBuffer(). This piece of memory should be freed when
        // the caller calls PushPropertyItems(). But in case the decorder
        // forget to call PushPropertyItems(), we have to clean up the memory
        // here
        
        WARNING(("GpTiffCodec::~GpTiffCodec -- property buffer not freed"));
        GpFree(LastPropertyBufferPtr);
        LastPropertyBufferPtr = NULL;
    }

    SetValid(FALSE);    // so we don't use a deleted object

}// Dstor()

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if ( riid == IID_IImageDecoder )
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if ( riid == IID_IImageEncoder )
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if ( riid == IID_IUnknown )
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}// QueryInterface()

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpTiffCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&ComRefCount);
}// AddRef

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpTiffCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&ComRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}// Release()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\tiffcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   tiff image codec
*
* Abstract:
*
*   Header file for the TIFF image encoder/decoder
*
* Revision History:
*
*   7/19/1999 MinLiu
*       Created it.
*
\**************************************************************************/
#ifndef _TIFFCODEC_HPP_
#define _TIFFCODEC_HPP_

#include "tifflib.h"
#include "Cmyk2Rgb.hpp"
#include "propertyutil.hpp"
#include "tiffapi.h"

class GpTiffCodec : public IImageDecoder, IImageEncoder, IImageSink
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagTiffCodec) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid TiffCodec");
        }
    #endif

        return (Tag == ObjectTagTiffCodec);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagTiffCodec : ObjectTagInvalid;
    }

public:

    // Constructor and Destructor
    
    GpTiffCodec(void);
    ~GpTiffCodec(void);

    //-------------------------------------------------------------------------
    // IImageDecoder methods
    //-------------------------------------------------------------------------
    
    // Init and terminate of decoder

    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder)();

    // Main decode methods

    STDMETHOD(BeginDecode)(IN IImageSink* imageSink,
                           IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    // Frame setting methods

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
                                 IN UINT frameIndex);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }

    // Property query methods

    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth,
                            IN OPTIONAL UINT thumbHeight,
                            OUT IImage** thumbImage);
    
    //-------------------------------------------------------------------------
    // IImageEncoder methods
    //-------------------------------------------------------------------------

    // Init and terminate of encoder
    
    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();

    // Encoder parameters setting method

    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // TIFF can handle raw property when saving. But it is only needed
        // before the header is written

        if ( HasWrittenHeader == FALSE )
        {
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    STDMETHOD(PushRawInfo)(IN OUT void* info)
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(GetPropertyBuffer)(IN UINT uiTotalBufferSize,
                                 IN OUT PropertyItem** ppBuffer);
    
    STDMETHOD(PushPropertyItems)(IN UINT numOfItems,
                                 IN UINT uiTotalBufferSize,
                                 IN PropertyItem* item,
                                 IN BOOL fICCProfileChanged);

    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    
    // IImageSink methods (sink for encoder)

    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
                         OUT OPTIONAL RECT* subarea);
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    
    // Main encoder methods

    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
                                  IN PixelFormatID pixelFormat,
                                  IN BOOL lastPass,
                                  OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* bitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
                             IN const BitmapData* bitmapData,
                             IN BOOL lastPass);

    // IUnknown methods for COM object

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

private:

    //-------------------------------------------------------------------------
    // Decoder privates
    //-------------------------------------------------------------------------

    IStream*        InIStreamPtr;       // Pointer to IStream of the input data
    IImageSink*     DecodeSinkPtr;      // Pointer to ImageSink
    ColorPalette*   ColorPalettePtr;    // Color palette for current image
    
    BOOL            HasCalledBeginSink; // Flag to indicate if we have done
                                        // BeginSink or not
    INT             CurrentLine;        // Current line number of decoding

    IFLPARAMS       TiffInParam;        // Pointer to TIFF parameter block for
                                        // the input image
    BOOL            NeedReverseBits;    // If the source is 1 bpp WhiteIsZero,
                                        // then we need to reverse the bits
    UINT            LineSize;           // Scanline size
    ImageFlag       OriginalColorSpace; // Color space info
    Cmyk2Rgb*       CmykToRgbConvertor; // Pointer to CMYK2RGB convertor

    // Color channel stuff
    
    typedef enum
    {
        CHANNEL_1 = 0,
        CHANNEL_2,
        CHANNEL_3,
        CHANNEL_4,
        CHANNEL_LUMINANCE
    } TIFF_COLOR_CHANNLE;

    BOOL    IsChannleView;      // True if the caller set the output format as
                                // channel by channel through SetDecoderParam
    TIFF_COLOR_CHANNLE ChannelIndex;
                                // Index for the channel caller specified
    BOOL    HasSetColorKeyRange;// TRUE if the caller called SetDecoderParam and
                                // set the color key range
    UINT    TransColorKeyLow;   // Transparent color key, lower bounds
    UINT    TransColorKeyHigh;  // Transparent color key, higher bounds

    BOOL    UseEmbeddedICC;     // TRUE if the caller wants to use embeded ICC

    // Property item stuff

    BOOL            HasProcessedPropertyItem;
    InternalPropertyItem   PropertyListHead;
    InternalPropertyItem   PropertyListTail;
    UINT            PropertyListSize;
    UINT            PropertyNumOfItems;
    BOOL            HasPropertyChanged;
    
    // Check if a color palette is 8 bits or 16 bits

    int             CheckColorPalette(int count, UINT16* r,
                                      UINT16* g,
                                      UINT16* b);
    
    // Decode one frame

    STDMETHODIMP    DecodeFrame(IN ImageInfo& imageInfo);
    STDMETHODIMP    DecodeForChannel(IN ImageInfo& imageInfo);
    
    // Return Pixel format info

    PixelFormatID   GetPixelFormatID(void);
    
    // Different color palette creating methods

    HRESULT         CreateColorPalette(VOID);
    HRESULT         CreateGrayscalePalette(VOID);
    void            Restore1Bpp(BYTE* pSrc, BYTE* pDst,
                                int iLength);
    void            Restore4Bpp(BYTE* pSrc, BYTE* pDst,
                                int iLength);

    // Set the color palette in the decoder sink

    HRESULT         SetPaletteForSink(VOID);

    UINT            GetLineBytes(UINT dstWidth);

    STDMETHOD(BuildPropertyItemList)();
    VOID            CleanPropertyList();

    // =====================================================
    // Encoder privates
    // =====================================================

    IFLPARAMS       TiffOutParam;
    IStream*        OutIStreamPtr;
    ImageInfo       EncoderImageInfo;
    BOOL            HasWrittenHeader;   // Set TRUE after we wrote the header
    BOOL            HasSetColorFormat;  // Set TRUE if the caller calls
                                        // SetEncoderParam() to set the color
                                        // depth. Otherwise, we save the image
                                        // as the same color depth as the source
    RECT            EncoderRect;        // Area to be encoded next
    VOID*           LastBufferAllocatedPtr;
    INT             ImgStride;
    UINT            OutputStride;       // Output stride size
    UINT            SinkStride;         // Stride in current sink
    PixelFormatID   RequiredPixelFormat;// The format caller asked for
    IFLCOMPRESSION  RequiredCompression;// The compression method caller asked

    STDMETHODIMP    WriteHeader();      // Write TIFF header

    PropertyItem*   LastPropertyBufferPtr;
                                        // Points to the property buffer we
                                        // allocated for the decoder. This is
                                        // useful to prevent memory leaking in
                                        // case the decoder forgets to call our
                                        // PushPropertyItems()
protected:
    LONG            ComRefCount;       // COM object reference count    
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\tiffdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   TIFF decoder
*
* Abstract:
*
*   Implementation of the TIFF filter decoder
*
* Revision History:
*
*   7/19/1999 MinLiu
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "tiffcodec.hpp"
#include "cmyk2rgb.hpp"
#include "image.h"
#include "tiffapi.h"
#include "..\..\render\srgb.hpp"

//!!! Todo:
// 1)Support JPEG compressed TIFF

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     [IN] stream -- The stream containing the tiff image data
*     [IN] flags  -- Misc. flags
*
* Return Value:
*
*   S_OK---If everything is OK
*   E_FAIL-If we get called more than once
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::InitDecoder(
    IN IStream*         stream,
    IN DecoderInitFlag  flags
    )
{
    // Make sure we haven't been initialized already
    
    if ( InIStreamPtr ) 
    {
        WARNING(("GpTiffCodec::InitDecoder--Already called InitDecoder"));
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    InIStreamPtr = stream;

    NeedReverseBits = FALSE;
    CmykToRgbConvertor = NULL;

    // Default color space is RGB

    OriginalColorSpace = IMGFLAG_COLORSPACE_RGB;
    IsChannleView = FALSE;              // By default we output the full color
    ChannelIndex = CHANNEL_1;
    HasSetColorKeyRange = FALSE;
    UseEmbeddedICC  = FALSE;            // By default, not use embedded ICM

    // Property item stuff

    HasProcessedPropertyItem = FALSE;
    
    PropertyListHead.pPrev = NULL;
    PropertyListHead.pNext = &PropertyListTail;
    PropertyListHead.id = 0;
    PropertyListHead.length = 0;
    PropertyListHead.type = 0;
    PropertyListHead.value = NULL;

    PropertyListTail.pPrev = &PropertyListHead;
    PropertyListTail.pNext = NULL;
    PropertyListTail.id = 0;
    PropertyListTail.length = 0;
    PropertyListTail.type = 0;
    PropertyListTail.value = NULL;
    
    PropertyListSize = 0;
    PropertyNumOfItems = 0;
    HasPropertyChanged = FALSE;
    
    // Open the TIFF image for further checking. If it is a TIFF image, then
    // read its header info

    if ( MSFFOpen(stream, &TiffInParam, IFLM_READ) == IFLERR_NONE )
    {
        SetValid(TRUE);

        return S_OK;
    }
    else
    {
        // Mark the image as invalid.

        SetValid(FALSE);

        InIStreamPtr->Release();
        InIStreamPtr = NULL;
        
        WARNING(("GpTiffCodec::InitDecoder--MSFFOpen failed"));
        return E_FAIL;
    }
}// InitDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::TerminateDecoder()
{
    HRESULT hResult = S_OK;

    // Release the input stream
    
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, no cleanup is needed

        return hResult;
    }

    // Free the memory allocated inside the TIFF lib
    // Note: Here the TIFFClose() won't actually close the file/IStream since
    // file/IStream is not opened by us. The top level codec manager will
    // close it if necessary
    
    if ( MSFFClose(TiffInParam.pTiffHandle) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::TerminateDecoder--MSFFClose() failed"));
        hResult = E_FAIL;
    }

    if( InIStreamPtr )
    {
        InIStreamPtr->Release();
        InIStreamPtr = NULL;
    }

    // Free all the cached property items if we have allocated them

    CleanPropertyList();

    return hResult;
}// TerminateDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Let the caller query if the decoder supports its decoding requirements
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::QueryDecoderParam(
    IN GUID		Guid
    )
{
    if ( Guid == DECODER_OUTPUTCHANNEL )
    {
        return S_OK;
    }

    return E_NOTIMPL;
}// QueryDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*     Setup the decoder parameters. Caller calls this function before calling
*   Decode(). This will set up the output format, like channel output,
*   transparanet key etc.
*
* Arguments:
*
*   Guid-----The GUID for decoder parameter
*	Length---Length of the decoder parameter in bytes
*   Value----Value of the parameter
*
* Return Value:
*
*   Status code
*
* Note:
*   We should ignore any unknown parameters, not return invalid parameter
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::SetDecoderParam(
    IN GUID		Guid,
	IN UINT		Length,
	IN PVOID	Value
    )
{
    if ( Guid == DECODER_TRANSCOLOR )
    {
        if ( Length != 8 )
        {
            WARNING(("GpTiffCodec::SetDecoderParam--Length !=8, set TRANSKEY"));
            return E_INVALIDARG;
        }
        else
        {
            UINT*   puiTemp = (UINT*)Value;
            
            TransColorKeyLow = *puiTemp++;
            TransColorKeyHigh = *puiTemp;

            HasSetColorKeyRange = TRUE;
        }
    }// DECODER_TRANSCOLOR
    else if ( Guid == DECODER_OUTPUTCHANNEL )
    {
        if ( Length != 1 )
        {
            WARNING(("GpTiffCodec::SetDecoderParam--Length != 1, set channel"));
            return E_INVALIDARG;
        }
        else
        {
            // Note: We cannot check if the setting is valid or not here.
            // For example, the caller might set "view channel K" on an RGB
            // image. But at this moment, the Decoder() method might hasn't
            // been called yet. We haven't read the image header yet.

            IsChannleView = TRUE;

            char cChannelName = *(char*)Value;
            
            switch ( (UINT)cChannelName )
            {
            case 'C':
            case 'c':
                ChannelIndex = CHANNEL_1;

                break;

            case 'M':
            case 'm':
                ChannelIndex = CHANNEL_2;
                
                break;

            case 'Y':
            case 'y':
                ChannelIndex = CHANNEL_3;
                
                break;

            case 'K':
            case 'k':
                ChannelIndex = CHANNEL_4;

                break;

            case 'R':
            case 'r':
                ChannelIndex = CHANNEL_1;

                break;

            case 'G':
            case 'g':
                ChannelIndex = CHANNEL_2;

                break;

            case 'B':
            case 'b':
                ChannelIndex = CHANNEL_3;

                break;

            case 'L':
            case 'l':
                ChannelIndex = CHANNEL_LUMINANCE;
                break;
                
            default:
                WARNING(("GpTiffCodec::SetDecoderParam--Unknown channle name"));
                return E_INVALIDARG;
            }// switch()
        }// Length = 1
    }// DECODER_OUTPUTCHANNEL GUID
    else if ( Guid == DECODER_USEICC )
    {
        if ( Length != 1 )
        {
            WARNING(("GpTiffCodec::SetDecoderParam--Length != 1, set USEICM"));
            return E_INVALIDARG;
        }
        
        // Note: use this assignment, the caller can turn on/off the
        // UseEmbeddedICC flag

        UseEmbeddedICC = *(BOOL*)Value;
    }// DECODER_USEICC

    return S_OK;
}// SetDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpTiffCodec::GetPropertyCount--numOfProperty is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetPropertyCount-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetPropertyIdList-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image
    // Here we need to validate if the caller passes us the correct number of
    // IDs which we returned through GetPropertyItemCount(). Also, this is also
    // a validation for memory allocation because the caller allocates memory
    // based on the number of items we returned to it

    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpTiffCodec::GetPropertyList--input wrong"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // Coping list IDs from our internal property item list

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    for ( int i = 0;
         (  (i < (INT)PropertyNumOfItems) && (pTemp != NULL)
         && (pTemp != &PropertyListTail));
         ++i )
    {
        list[i] = pTemp->id;
        pTemp = pTemp->pNext;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpTiffCodec::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetPropertyItemSize-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist

        return IMGERR_PROPERTYNOTFOUND;
    }

    // The size of an property item should be "The size of the item structure
    // plus the size for the value

    *size = pTemp->length + sizeof(PropertyItem);

    return S_OK;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pItemBuffer
    )
{
    if ( pItemBuffer == NULL )
    {
        WARNING(("GpTiffCodec::GetPropertyItem--pBuffer is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
    BYTE*   pOffset = (BYTE*)pItemBuffer + sizeof(PropertyItem);

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist in the list

        return IMGERR_PROPERTYNOTFOUND;
    }
    else if ( (pTemp->length + sizeof(PropertyItem)) != propSize )
    {
        WARNING(("GpTiffCodec::GetPropertyItem---wrong propsize"));
        return E_INVALIDARG;
    }

    // Found the ID in the list and return the item

    pItemBuffer->id = pTemp->id;
    pItemBuffer->length = pTemp->length;
    pItemBuffer->type = pTemp->type;

    if ( pTemp->length != 0 )
    {
        pItemBuffer->value = pOffset;

        GpMemcpy(pOffset, pTemp->value, pTemp->length);
    }
    else
    {
        pItemBuffer->value = NULL;
    }

    return S_OK;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpTiffCodec::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetPropertySize-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/03/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpTiffCodec::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::GetAllPropertyItems-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list and assigtn the result out

    InternalPropertyItem*   pTempSrc = PropertyListHead.pNext;
    PropertyItem*           pTempDst = allItems;
    BYTE*                   pOffSet = (BYTE*)allItems + uiHeaderSize;
        
    for ( int i = 0; i < (INT)PropertyNumOfItems; ++i )
    {
        pTempDst->id = pTempSrc->id;
        pTempDst->length = pTempSrc->length;
        pTempDst->type = pTempSrc->type;

        if ( pTempSrc->length != 0 )
        {
            pTempDst->value = (void*)pOffSet;

            GpMemcpy(pOffSet, pTempSrc->value, pTempSrc->length);
        }
        else
        {
            // For zero length property item, set the value pointer to NULL

            pTempDst->value = NULL;
        }

        // Move onto next memory offset.
        // Note: if the current item length is 0, the next line doesn't move
        // the offset

        pOffSet += pTempSrc->length;
        pTempSrc = pTempSrc->pNext;
        pTempDst++;
    }
    
    return S_OK;
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::RemovePropertyItem-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // Item not found

        return IMGERR_PROPERTYNOTFOUND;
    }

    // Found the item in the list. Remove it

    PropertyNumOfItems--;
    PropertyListSize -= pTemp->length;
        
    RemovePropertyItemFromList(pTemp);
       
    // Remove the item structure

    GpFree(pTemp);

    HasPropertyChanged = TRUE;

    return S_OK;
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Tiff::SetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != item.id) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This item doesn't exist in the list, add it into the list
        
        PropertyNumOfItems++;
        PropertyListSize += item.length;
        
        if ( AddPropertyList(&PropertyListTail,
                             item.id,
                             item.length,
                             item.type,
                             item.value) != S_OK )
        {
            WARNING(("Tiff::SetPropertyItem-AddPropertyList() failed"));
            return E_FAIL;
        }
    }
    else
    {
        // This item already exists in the link list, update the info
        // Update the size first

        PropertyListSize -= pTemp->length;
        PropertyListSize += item.length;
        
        // Free the old item

        GpFree(pTemp->value);

        pTemp->length = item.length;
        pTemp->type = item.type;

        pTemp->value = GpMalloc(item.length);
        if ( pTemp->value == NULL )
        {
            // Since we already freed the old item, we should set its length to
            // 0 before return

            pTemp->length = 0;
            WARNING(("Tiff::SetPropertyItem-Out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pTemp->value, item.value, item.length);
    }

    HasPropertyChanged = TRUE;
    
    return S_OK;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Initiates the decode of the current frame
*
* Arguments:
*
*   imageSink  - The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail BeginDecode

        WARNING(("GpTiffCodec::BeginDecode--Invalid image"));
        return E_FAIL;
    }
    
    if ( DecodeSinkPtr )
    {
        WARNING(("BeginDecode called again before call to EngDecode"));        
        return E_FAIL;
    }

    imageSink->AddRef();
    DecodeSinkPtr = imageSink;

    CurrentLine = 0;
    HasCalledBeginSink = FALSE;

    return S_OK;
}// BeginDecode()

/**************************************************************************\
*
* Function Description:
*
*     Ends the decoding of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::EndDecode--Invalid image"));
        return E_FAIL;
    }
    
    if ( ColorPalettePtr ) 
    {
        // Free the color palette

        GpFree(ColorPalettePtr);
        ColorPalettePtr = NULL;
    }

    if ( CmykToRgbConvertor != NULL )
    {
        delete CmykToRgbConvertor;
        CmykToRgbConvertor = NULL;
    }
    
    if ( !DecodeSinkPtr ) 
    {
        WARNING(("EndDecode called when DecodeSinkPtr is NULL"));
        return E_FAIL;
    }
    
    HRESULT hResult = DecodeSinkPtr->EndSink(statusCode);

    if ( FAILED(hResult) ) 
    {
        WARNING(("GpTiffCodec::EndDecode--EndSink failed"));
        statusCode = hResult; // If EndSink failed return that (more recent)
                              // failure code
    }

    DecodeSinkPtr->Release();
    DecodeSinkPtr = NULL;

    return statusCode;
}// EndDecode()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::GetFrameDimensionsCount--Invalid image"));
        return E_FAIL;
    }
    
    if ( count == NULL )
    {
        WARNING(("GpTiffCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that TIFF is a one dimension image.
    // Note: TIFF only supports multi-page dimension for now

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::GetFrameDimensionsCount--Invalid image"));
        return E_FAIL;
    }
    
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpTiffCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    // We only support FRAMEDIM_PAGE for now

    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpTiffCodec::GetFrameCount--Invalid input args"));
        return E_INVALIDARG;
    }
    
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::GetFrameCount--Invalid image"));
        return E_FAIL;
    }
    
    // Get number of pages in the TIFF image
    
    UINT16  ui16NumOfPage = 0;

    if ( MSFFControl(IFLCMD_GETNUMIMAGES, IFLIT_PRIMARY, 0, &ui16NumOfPage,
                     &TiffInParam) == IFLERR_NONE )
    {
        *count = ui16NumOfPage;

        return S_OK;
    }

    WARNING(("GpTiffCodec::GetFrameCount--MSFFControl failed"));
    return E_FAIL;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::SelectActiveFrame--Invalid image"));
        return E_FAIL;
    }
    
    if ( *dimensionID != FRAMEDIM_PAGE )
    {
        WARNING(("GpTiffCodec::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    // Get number of pages in the TIFF image
    
    UINT16 uiNumOfPage = 0;

    if ( MSFFControl(IFLCMD_GETNUMIMAGES, IFLIT_PRIMARY, 0, &uiNumOfPage,
                     &TiffInParam) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::SelectActiveFrame--MSFFControl failed"));
        return E_FAIL;
    }

    if ( frameIndex > uiNumOfPage )
    {
        // Frame specified out of bounds

        WARNING(("GpTiffCodec::SelectActiveFrame--wrong input frameIndex"));
        return ERROR_INVALID_PARAMETER;
    }

    short sParam = (IFLIT_PRIMARY << 8) | (SEEK_SET & 0xff);

    if ( MSFFControl(IFLCMD_IMAGESEEK, sParam, frameIndex, NULL,
                     &TiffInParam) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::SelectActiveFrame--MSFFControl seek failed"));
        return E_FAIL;
    }

    // Clean up property item list we got from the previous page

    CleanPropertyList();
    
    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::GetThumbnail--Invalid image"));
        return E_FAIL;
    }
    
    return E_NOTIMPL;
}// GetThumbnail()

/**************************************************************************\
*
* Function Description:
*
*     Fills up the ImageInfo structure
*
* Arguments:
*
*     [OUT] pDecoderImageInfo -- information about the decoded tiff image
*
* Todo !!!
*   Since this function get called a lot. Shall we make a local cache?
*
* Return Value:
*
*   S_OK---If everything is OK, else return the error status   
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetImageInfo(
    OUT ImageInfo* pDecoderImageInfo
    )
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::GetImageInfo--Invalid image"));
        return E_FAIL;
    }
    
    DWORD   XDpi[2] = {0};

    // Call GetControl to get Xres and YRes. The reason we can't call MSFFGetTag
    // is that XRes and YRes field are in RATIONAL type. The value "3" for sParm
    // means we need to get 2 (0x11) value back. That's the reason we defined
    // XDpi[2]

    MSFFControl(IFLCMD_RESOLUTION, 3, 0, (void*)&XDpi, &TiffInParam);
    
    //??? Office code doesn't support Tile for now. So we just set it to the
    // width and height. Fix it later

    pDecoderImageInfo->RawDataFormat = IMGFMT_TIFF;
    pDecoderImageInfo->PixelFormat   = GetPixelFormatID();
    pDecoderImageInfo->Width         = TiffInParam.Width;
    pDecoderImageInfo->Height        = TiffInParam.Height;
    pDecoderImageInfo->TileWidth     = TiffInParam.Width;
    pDecoderImageInfo->TileHeight    = TiffInParam.Height;
    pDecoderImageInfo->Xdpi          = XDpi[0];
    pDecoderImageInfo->Ydpi          = XDpi[1];

    pDecoderImageInfo->Flags         = SINKFLAG_TOPDOWN
                                     | SINKFLAG_FULLWIDTH
                                     | OriginalColorSpace
                                     | IMGFLAG_HASREALPIXELSIZE
                                     | IMGFLAG_HASREALDPI;

    // Set the alpha flag if the source is 32 bpp ARGB

    if ( pDecoderImageInfo->PixelFormat == PIXFMT_32BPP_ARGB )
    {
        pDecoderImageInfo->Flags |= SINKFLAG_HASALPHA;
    }

    return S_OK;
}// GetImageInfo()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     DecodeSinkPtr --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::Decode()
{
    if ( !IsValid() )
    {
        // If we haven't been able to open this image, fail

        WARNING(("GpTiffCodec::Decode--Invalid image"));
        return E_FAIL;
    }
    
    ImageInfo   imageInfo;

    // Get current TIFF image info

    HRESULT hResult = GetImageInfo(&imageInfo);

    if ( FAILED(hResult)
       ||(imageInfo.Width < 1)
       ||(imageInfo.Height < 1) )
    {
        WARNING(("GpTiffCodec::Decode--Invalid image attributes"));
        return E_FAIL;
    }

    // Inform the sink that decode is about to start pushing image data to the
    // sink

    if ( !HasCalledBeginSink )
    {
        // Check if the sink needs property stuff
        // Note: for a memory sink, it should return E_FAIL or E_NOTIMPL

        if ( DecodeSinkPtr->NeedRawProperty(NULL) == S_OK )
        {
            if ( HasProcessedPropertyItem == FALSE )
            {
                // If we haven't build the internal property item list, build it

                hResult = BuildPropertyItemList();
                if ( FAILED(hResult) )
                {
                    WARNING(("Tiff::Decode---BuildPropertyItemList() failed"));
                    return hResult;
                }
            }

            UINT    uiTotalBufferSize = PropertyListSize
                                      + PropertyNumOfItems * sizeof(PropertyItem);
            PropertyItem*   pBuffer = NULL;

            hResult = DecodeSinkPtr->GetPropertyBuffer(uiTotalBufferSize, &pBuffer);
            if ( FAILED(hResult) )
            {
                WARNING(("GpTiffCodec::Decode---GetPropertyBuffer() failed"));
                return hResult;
            }

            hResult = GetAllPropertyItems(uiTotalBufferSize,
                                          PropertyNumOfItems, pBuffer);
            if ( hResult != S_OK )
            {
                WARNING(("GpTiffCodec::Decode---GetAllPropertyItems() failed"));
                return hResult;
            }

            hResult = DecodeSinkPtr->PushPropertyItems(PropertyNumOfItems,
                                                       uiTotalBufferSize, pBuffer,
                                                       FALSE // No ICC change
                                                       );

            if ( FAILED(hResult) )
            {
                WARNING(("GpTiffCodec::Decode---PushPropertyItems() failed"));
                return hResult;
            }
        }// If the sink needs raw property
        
        // Pass the image info to the sink. This is a negotiation process.
        // The "imageInfo" structure we pass into this function might be changed
        // For example, the sink, can be either a memory bitmap or an encoder,
        // can ask us this decoder to provide a pixel format it likes. So the
        // "imageInfo" structure after this "BeginSink() call will contain the
        // info the sink likes.

        hResult = DecodeSinkPtr->BeginSink(&imageInfo, NULL);
        
        if ( !SUCCEEDED(hResult) )
        {
            WARNING(("GpTiffCodec::Decode--BeginSink failed"));
            return hResult;
        }

        // We are not allow the client to change the image width and height
        // during the BeginSink() call above. So we have to reset it here
        // Note: Late we should let the caller change the width and height. This
        // will allow the decoder to be able to decoder partial image
        
        if ((TiffInParam.Width <=0) || (TiffInParam.Height <= 0))
        {
            return E_FAIL;
        }

        UINT imageWidth = (UINT)TiffInParam.Width;
        UINT imageHeight = (UINT)TiffInParam.Height;

        imageInfo.Width = imageWidth;
        imageInfo.Height = imageHeight;

        PixelFormatID srcPixelFormatID = GetPixelFormatID();
        
        // Check the required pixel format. If it is not one of our supportted
        // format, switch it to a canonical one
        // For TIFF, we don't support 16 bpp format. Though we can do a
        // conversion before we return it back to caller. I think it will be
        // better to let the sink to do the conversion so that it have a better
        // control of the image quality. As a decoder, we should provide the
        // data as close to its original format as possible

        if ( imageInfo.PixelFormat != srcPixelFormatID )
        {
            // The sink is trying to negotiate a format with us

            switch ( imageInfo.PixelFormat )
            {
            case PIXFMT_1BPP_INDEXED:
            case PIXFMT_4BPP_INDEXED:
            case PIXFMT_8BPP_INDEXED:
            case PIXFMT_24BPP_RGB:
            case PIXFMT_32BPP_ARGB:
            {
                // Check if we can convert the source pixel format to the format
                // sink required. If not. we return 32BPP ARGB

                EpFormatConverter linecvt;
                if ( linecvt.CanDoConvert(srcPixelFormatID,
                                          imageInfo.PixelFormat)==FALSE )
                {
                    imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
                }
            }
                break;

            default:

                // For all the rest format, we convert it to 32BPP_ARGB and let
                // the sink to do the conversion to the format it likes

                imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;

                break;
            }
        }

        if ( MSFFScanlineSize(TiffInParam, &LineSize) != IFLERR_NONE )
        {
            WARNING(("GpTiffCodec::Decode--MSFFScanlineSize failed"));
            return  E_FAIL;
        }
                
        // Need to set the palette in the sink

        hResult = SetPaletteForSink();

        if ( FAILED(hResult) )
        {
            WARNING(("GpTiffCodec::Decode--SetPaletteForSink failed"));
            return hResult;
        }
        
        if ( UseEmbeddedICC == TRUE )
        {
            // Let's verify if this request is valid or not
            // First check if this image has ICC profile or not

            UINT    uiSize = 0;
            hResult = GetPropertyItemSize(TAG_ICC_PROFILE, &uiSize);

            if ( FAILED(hResult) || (uiSize == 0) )
            {
                // This image doesn't have an embedded ICC profile

                UseEmbeddedICC = FALSE;
            }
            else
            {
                // This image does have an embedded ICC profile
                // We need to check if it is a CMYK to RGB conversion or not

                PropertyItem*   pBuffer = (PropertyItem*)GpMalloc(uiSize);

                if ( pBuffer == NULL )
                {
                    WARNING(("GpTiffCodec::Decode--Allocate %d bytes failed",
                             uiSize));
                    return E_OUTOFMEMORY;
                }

                hResult = GetPropertyItem(TAG_ICC_PROFILE, uiSize, pBuffer);
                if ( FAILED(hResult) )
                {
                    UseEmbeddedICC = FALSE;
                }
                else if (uiSize >= 20)
                {
                    // Check if this is a CMYK profile
                    // According to ICC spec, bytes 16-19 should describe the
                    // color space. That's the reason we check the size at least
                    // 20 bytes above

                    BYTE*   pTemp = (BYTE*)pBuffer->value + 16;

                    if ( (pTemp[0] != 'C')
                       ||(pTemp[1] != 'M')
                       ||(pTemp[2] != 'Y')
                       ||(pTemp[3] != 'K') )
                    {
                        // If this is not a CMYK profile, then we turn this
                        // flag off and return RGB data in DecodeFrame() if the
                        // original data is CMYK

                        UseEmbeddedICC = FALSE;
                    }
                }

                GpFree(pBuffer);
            }
        }

        // If it is a CMYK image, initialize a convertor pointer.
        // Note: this constructor takes some time to build a conversion table.
        // For performance reason we call the constructor here instead of inside
        // DecodeFrame() which is called many times.

        if ( OriginalColorSpace == IMGFLAG_COLORSPACE_CMYK )
        {
            // Convert CMYK to RGB

            CmykToRgbConvertor = new Cmyk2Rgb();

            if ( CmykToRgbConvertor == NULL )
            {
                WARNING(("GpTiffCodec::Decode--Fail to create Cmyk convertor"));
                return E_OUTOFMEMORY;
            }
        }

        HasCalledBeginSink = TRUE;
    }

    if ( IsChannleView == TRUE )
    {
        return DecodeForChannel(imageInfo);
    }

    // Decode the current frame based on the "imageInfo" after negotiation
    
    hResult = DecodeFrame(imageInfo);

    return hResult;
}// Decode()

//
//====================Private methods below=================================
//

/**************************************************************************\
*
* Function Description:
*
*     Set the current palette in the sink
*
* Arguments:
*
* Return Value:
*
*   S_OK---If everything is OK. Otherwise, return failure code
*
\**************************************************************************/

HRESULT
GpTiffCodec::SetPaletteForSink()
{
    UINT16  ui16Photometric = 0;
    HRESULT hResult;

    // Get the photometric value first. Then we can decide what kind of color
    // palette we need to set

    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_PhotometricInterpretation,
                    (void*)&ui16Photometric, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::SetPaletteForSink--MSFFGetTag failed"));
        return E_FAIL;
    }
    
    switch ( ui16Photometric )
    {
    case 3:
        // Palette image

        hResult = CreateColorPalette();

        break;

    case 0:
    case 1:
        // Gray scale image, we need to generate a palette for it

        hResult = CreateGrayscalePalette();

        break;

    case 2:
        
        // If it is 2, then it is a color RGB image.

        return S_OK;

    default:

        // Invalid photometric number

        return ERROR_INVALID_PARAMETER;
    }

    if ( FAILED(hResult) )
    {
        WARNING(("GpTiff::SetPaletteForSink--CreateGrayscalePalette failed"));
        return hResult;
    }
    
    // Up to this point, ColorPalettePtr should point to a valid color palette.
    // Set the palette in the sink

    hResult = DecodeSinkPtr->SetPalette(ColorPalettePtr);

    return hResult;
}// SetPaletteForSink()

/**************************************************************************\
*
* Function Description:
*
*     Check if a palette is 16 bits or 8 bits
*
* Arguments:
*
*     [IN] count    -- Number of elements in this palette
*     [IN] r        -- Red component
*     [IN] g        -- Green component
*     [IN] b        -- Blue component
*
* Return Value:
*
*   8---If it is a 8 bits palette
*   16--If it is a 16 bits palette
*
\**************************************************************************/

int
GpTiffCodec::CheckColorPalette(
    int     iCount,
    UINT16* r,
    UINT16* g,
    UINT16* b
    )
{
    while ( iCount-- > 0 )
    {
        if ( (*r++ >= 256)
           ||(*g++ >= 256)
           ||(*b++ >= 256) )
        {
            return (16);
        }
    }

    return (8);
}// CheckColorPalette()

#define TwoBytesToOneByte(x)      (((x) * 255L) / 65535)

/**************************************************************************\
*
* Function Description:
*
*     Create a color palette.
*
* Note:
*     That colorPalette is freed at the end of the decode operation.
*
* Return Value:
*
*   E_OUTOFMEMORY---Out of memory
*   E_FAIL----------Fail
*   S_OK------------If it is OK
*
\**************************************************************************/

HRESULT
GpTiffCodec::CreateColorPalette()
{
    UINT16  ui16BitsPerSample = 0;

    // Get image BitsPerSample (in SHORT) info first

    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_BitsPerSample,
                    (void*)&ui16BitsPerSample, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::CreateColorPalette--MSFFGetTag failed"));
        return E_FAIL;
    }

    // Free the old color palette if there is one

    if ( NULL != ColorPalettePtr )
    {
        GpFree(ColorPalettePtr);
    }

    // Number of palette in this image

    UINT uPaletterSize = 1 << ui16BitsPerSample;

    // Length of each color channle (R, G, B) in bytes. 
    // Note: all the TIFF color palette are in SHORT type which is 2 bytes

    UINT uChannleLength = uPaletterSize << 1;

    // Create a ColorPalette which holds this color palette

    ColorPalettePtr = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                            + uPaletterSize * sizeof(ARGB));

    // Palette buffers for each RGB channel

    UINT16* pusRed = (UINT16*)GpMalloc(uChannleLength);
    UINT16* pusGreen = (UINT16*)GpMalloc(uChannleLength);
    UINT16* pusBlue = (UINT16*)GpMalloc(uChannleLength);

    // Buffer for the whole palette

    UINT16* pPaletteBuf = (UINT16*)GpMalloc(uChannleLength * 3);

    HRESULT hr = S_OK;

    if (ColorPalettePtr && pusRed && pusGreen && pusBlue && pPaletteBuf)
    {
        BYTE    Red, Green, Blue;

        // Get the color palette from input image

        if (MSFFGetTag(TiffInParam.pTiffHandle, T_ColorMap, (void*)pPaletteBuf,
                       uChannleLength * 3) == IFLERR_NONE)
        {
            // Seperate the palette into R, G, B channel
            // Note: In a TIFF color map, all the Red values come first,
            // followed by Green values, then the Blue values.
            //
            // Here we use a temp variable iBlueOffset to save a multiply OP

            UINT uBlueOffset = uPaletterSize << 1;

            for (UINT i = 0; i < uPaletterSize; ++i)
            {
                pusRed[i] = pPaletteBuf[i];
                pusGreen[i] = pPaletteBuf[uPaletterSize + i];
                pusBlue[i] = pPaletteBuf[uBlueOffset + i];
            }

            // Is the palette 16 or 8 bits ?

            int iColorBits = CheckColorPalette(uPaletterSize, pusRed,
                                               pusGreen, pusBlue);

            // Set the palette

            for (UINT i = 0; i < uPaletterSize; ++i)
            {
                if ( 16 == iColorBits )
                {
                    // Note: TIFF internally stores color pallet in 16 bits to
                    // keep high color fidelity. But for now GDI+ only supports
                    // 32 BPP color space that is, 8 bits for each channel. So
                    // here we have to do a map from [0,65535] to [0,255]

                    Red = (BYTE)TwoBytesToOneByte(pusRed[i]);
                    Green = (BYTE)TwoBytesToOneByte(pusGreen[i]);
                    Blue = (BYTE)TwoBytesToOneByte(pusBlue[i]);
                }
                else
                {
                    Red = (BYTE)pusRed[i];
                    Green = (BYTE)pusGreen[i];
                    Blue = (BYTE)pusBlue[i];
                }

                ColorPalettePtr->Entries[i] = MAKEARGB(255, Red, Green, Blue);
            }

            // Set the palette attributes

            ColorPalettePtr->Flags = 0;
            ColorPalettePtr->Count = uPaletterSize;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (pusRed)
    {
        GpFree(pusRed);
    }

    if (pusGreen)
    {
        GpFree(pusGreen);
    }

    if (pusBlue)
    {
        GpFree(pusBlue);
    }

    if (pPaletteBuf)
    {
        GpFree(pPaletteBuf);
    }
    
    return hr;
}// CreateColorPalette()

/**************************************************************************\
*
* Function Description:
*
*     Create a gray level palette. Some of the TIFF images don't set the
*   palette when it is a gray level image. So we have to generate here
*
* Note:
*     That colorPalette is freed at the end of the decode operation.
*
* Todo !!!, maybe we can try to check if the image come with a gray scale
*   palette or not. If yes, use it
*
* Return Value:
*
*   E_OUTOFMEMORY---Out of memory
*   E_FAIL----------Fail
*   S_OK------------If it is OK
*
\**************************************************************************/

HRESULT
GpTiffCodec::CreateGrayscalePalette()
{
    // Free the old color palette if there is one

    if ( NULL != ColorPalettePtr )
    {
        GpFree(ColorPalettePtr);
    }

    UINT16  ui16BitsPerSample = 0;
    UINT16  ui16Photometric = 0;

    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_BitsPerSample,
                    (void*)&ui16BitsPerSample, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("Tiff:CreateGrayscalePalette--MSFFGetTag for Bits failed"));
        return E_FAIL;
    }
    
    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_PhotometricInterpretation,
                    (void*)&ui16Photometric, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("Tiff:CreateGrayscalePalette--MSFFGetTag for photo failed"));
        return E_FAIL;
    }

    int iPaletterSize = 1 << ui16BitsPerSample;

    ColorPalettePtr = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                            + iPaletterSize * sizeof(ARGB));
    if ( !ColorPalettePtr )
    {
        WARNING(("Tiff:CreateGrayscalePalette--Out of memory"));
        return E_OUTOFMEMORY;
    }

    // For performance reason, we should handle the special 1 bpp and 8 bpp
    // case seperately here

    if ( 256 == iPaletterSize )
    {
        for (int j = 0; j < 256; ++j )
        {
            ColorPalettePtr->Entries[j] = MAKEARGB(255, (BYTE)j, (BYTE)j, (BYTE)j);
        }
    }
    else if ( 2 == iPaletterSize )
    {
        // Unfortunately, Office code has a bug in Packbits compress TIFF and
        // NONE compress decoding which inversed the index value. So for now,
        // we temporarily fix it here. Should fix it in the lower level

        UINT16  ui16Compression = 0;

        if ( MSFFGetTag(TiffInParam.pTiffHandle, T_Compression,
                        (void*)&ui16Compression, sizeof(UINT16))!= IFLERR_NONE )
        {
            WARNING(("CreateGrayscalePalette--MSFFGetTag for compr failed"));
            return E_FAIL;
        }
        
        ColorPalettePtr->Entries[0] = MAKEARGB(255, 0, 0, 0);
        ColorPalettePtr->Entries[1] = MAKEARGB(255, 255, 255, 255);
        
        // If the Photometric is not PI_BLACKISZERO (that is,PI_WHITEISZERO)
        // and the compression is not PackBits, neither NONE-COMPRESS, then
        // it is PI_WHITEISZERO with other compression scheme and we need to
        // reverse the index bits
        
        // If the Photometric is PI_BLACKISZERO or the compression schema is 
        // PackBits, or NONE-COMPRESS, or LZW, then we don't need to reverse
        // the index bits. Otherwise, we need to.
        
        if ( ! ( (ui16Photometric == PI_BLACKISZERO)
               ||(ui16Compression == T_COMP_PACK)
               ||(ui16Compression == T_COMP_LZW)
               ||(ui16Compression == T_COMP_NONE) ) )
        {
            NeedReverseBits = TRUE;
        }
    }
    else
    {
        for ( int i = 0; i < iPaletterSize; ++i )
        {
            int iTemp = ((long)i * 255) / (iPaletterSize - 1);

            ColorPalettePtr->Entries[i] = MAKEARGB(255, (BYTE)iTemp, (BYTE)iTemp, (BYTE)iTemp);
        }
    }

    // Set the grayscale palette

    ColorPalettePtr->Flags = 0;
    ColorPalettePtr->Count = iPaletterSize;

    return S_OK;
}// CreateGrayscalePalette()

/**************************************************************************\
*
* Function Description:
*
*     Computes the pixel format ID of the bitmap
*
* Return Value:
*
*     Pixel format ID
*
\**************************************************************************/

PixelFormatID 
GpTiffCodec::GetPixelFormatID(
    void
    )
{
    PixelFormatID pixelFormatID = PixelFormatUndefined;
    UINT16  photometric = 0;
    UINT16  usBitsPerSample = 0;
    UINT16  usSamplesPerPixel = 0;

    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_PhotometricInterpretation,
                    (void*)&photometric, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("Tiff:GetPixelFormatID--MSFFGetTag for photo failed"));
        return PIXFMT_UNDEFINED;
    }

    if ( (MSFFGetTag(TiffInParam.pTiffHandle, T_BitsPerSample,
                    (void*)&usBitsPerSample, sizeof(UINT16)) != IFLERR_NONE) ||
         (usBitsPerSample == 0) )
    {
        WARNING(("Tiff:GetPixelFormatID--MSFFGetTag for bits failed"));
        return PIXFMT_UNDEFINED;
    }

    if ( MSFFGetTag(TiffInParam.pTiffHandle, T_SamplesPerPixel,
                    (void*)&usSamplesPerPixel, sizeof(UINT16)) != IFLERR_NONE )
    {
        WARNING(("Tiff:GetPixelFormatID--MSFFGetTag for sample failed"));
        return PIXFMT_UNDEFINED;
    }

    switch ( photometric )
    {
    case 2:

        // Full RGB color image

        OriginalColorSpace = IMGFLAG_COLORSPACE_RGB;
        
        if ( usBitsPerSample == 8 )
        {
            // Check how many samples/channels per pixel. If it is greater than
            // 3, then it is a real 32 BPP or higher

            if ( usSamplesPerPixel <= 3 )
            {
                pixelFormatID = PIXFMT_24BPP_RGB;
            }
            else
            {
                pixelFormatID = PIXFMT_32BPP_ARGB;
            }
        }
        else if ( usBitsPerSample == 16 )
        {
            pixelFormatID = PIXFMT_48BPP_RGB;
        }
        else
        {
            pixelFormatID = PIXFMT_UNDEFINED;
        }

        break;

    case 3:
        // Color indexed image

        if ( usBitsPerSample == 8 )
        {
            pixelFormatID = PIXFMT_8BPP_INDEXED;
        }
        else if ( usBitsPerSample == 4 )
        {
            pixelFormatID = PIXFMT_4BPP_INDEXED;
        }
        else if ( usBitsPerSample == 1 )
        {
            pixelFormatID = PIXFMT_1BPP_INDEXED;
        }

        break;

    case 0:
    case 1:
        // Gray scale of bi-level image

        OriginalColorSpace = IMGFLAG_COLORSPACE_GRAY;
        
        if ( usBitsPerSample == 8 )
        {
            // Use 8bpp indexed to represent 256 gray scale image
            // We should set the palette for the sink first

            pixelFormatID = PIXFMT_8BPP_INDEXED;
        }
        else if ( usBitsPerSample == 4 )
        {
            pixelFormatID = PIXFMT_4BPP_INDEXED;
        }
        else if ( usBitsPerSample == 1 )
        {
            pixelFormatID = PIXFMT_1BPP_INDEXED;
        }
        else
        {
            pixelFormatID = PIXFMT_UNDEFINED;
        }

        break;

    case 5:
        // CMYK image

        pixelFormatID = PIXFMT_32BPP_ARGB;
        OriginalColorSpace = IMGFLAG_COLORSPACE_CMYK;

        break;

    default:
        // Need to handle some bad test images

        pixelFormatID = PIXFMT_UNDEFINED;

        break;
    }

    return pixelFormatID;
}// GetPixelFormatID()

/**************************************************************************\
*
* Function Description:
*
*     Computes the total bytes needed for decoding the given width of pixels
*   based on source image pixel format
*
* Return Value:
*
*     Total bytes needed.
*
\**************************************************************************/

UINT
GpTiffCodec::GetLineBytes(
    UINT dstWidth
    )
{
    UINT uiLineWidth;
    PixelFormatID srcPixelFormatID = GetPixelFormatID();

    switch ( srcPixelFormatID )
    {
    case PIXFMT_1BPP_INDEXED:      
        uiLineWidth = (dstWidth + 7) & 0xfffffff8;

        break;

    case PIXFMT_4BPP_INDEXED:                                    
    case PIXFMT_8BPP_INDEXED:
        uiLineWidth = (dstWidth + 3) & 0xfffffffc;
        
        break;
    
    case PIXFMT_16BPP_RGB555:
        uiLineWidth = (dstWidth * sizeof(UINT16) + 3) & 0xfffffffc;
        
        break;
    
    case PIXFMT_24BPP_RGB:
        uiLineWidth = (dstWidth * sizeof(RGBTRIPLE) + 3) & 0xfffffffc;
        
        break;
    
    case PIXFMT_32BPP_RGB:
        uiLineWidth = dstWidth * sizeof(RGBQUAD);
        
        break;
    
    case PIXFMT_32BPP_ARGB:
    case PIXFMT_48BPP_RGB:
        uiLineWidth = LineSize;

        break;

    default:   // shouldn't get here...
        uiLineWidth = 0;
    }

    return uiLineWidth;
}// GetLineBytes()

void
GpTiffCodec::Restore4Bpp(
    BYTE*   pSrc,
    BYTE*   pDst,
    int     iLength
    )
{
    BYTE*  pSrcPtr = pSrc;
    BYTE*  pDstPtr = pDst;
    BYTE   ucTemp;

    for ( int i = 0; i < iLength; ++i )
    {
        ucTemp = *pSrcPtr++ & 0x0f;
        ucTemp = (ucTemp << 4) | (*pSrcPtr++ & 0x0f);
        *pDstPtr++ = ucTemp;
    }
}// Restore4Bpp()

void
GpTiffCodec::Restore1Bpp(
    BYTE*   pSrc,
    BYTE*   pDst,
    int     iLength
    )
{
    BYTE*   pSrcPtr = pSrc;
    BYTE*   pDstPtr = pDst;
    BYTE    ucTemp;

    if ( NeedReverseBits == FALSE )
    {
        for ( int i = 0; i < iLength; ++i )
        {
            ucTemp = *pSrcPtr++ & 0x01;
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);

            *pDstPtr++ = ucTemp;
        }
    }
    else
    {
        for ( int i = 0; i < iLength; ++i )
        {
            ucTemp = *pSrcPtr++ & 0x01;
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);
            ucTemp = (ucTemp << 1) | (*pSrcPtr++ & 0x01);

            *pDstPtr++ = ~ucTemp;
        }
    }
}// Restore1Bpp()

/**************************************************************************\
*
* Function Description:
*
*   This routine is a little service routine for converting a 16 bits channel
*   value (R, G, B) to a sRGB64 channel value.
*   Each channel value in sRGB64 is gamma linear (gamma = 1.0). But
*   TIFF's 16 bits R,G,B value is stored as gamma of 2.2, so in this routine, we
*   just use LinearizeLUT[] to linearize it.
*
*   Note: Theoritically we don't need to do this kind of conversion at all. We
*   can easily map our 16 bits value to a 8 bits value.
*   Unfortunately, TIFF decoder has to tell the world that it is a 48BPP_RGB
*   image (when the GetPixelFormat() is called). But GDI+'s 48BPP_RGB and
*   64BPP_ARGB means gamma 1.0 linear data format. So when the format
*   conversion routine ConvertBitmapData() is called, say destination is 32ARGB,
*   it does 48RGB to 64ARGB and then gamma correct it to 32ARGB (gamma = 2.2).
*   So TIFF decoder has to make the data linearized before it can claim itself
*   48RGB.
*
*   Why does TIFF decoder have to claim itself as 48RGB?
*   The cheapest and fastest way to decode is to claim itself as 24RGB and
*   map the 16 bits channel data to 8 bits channel data. But the problems of
*   doing this are:
*   a) Caller doesn't know the real original color depth of the image
*   b) Encoder won't be able to save the image as 48 bpp.
*
*   Hopefully, in V2, we can all sort this out and make the decoder faster.
*
*   TIFF 6.0a specification, page 73:
*
*   It should be noted that although CCDs are linear intensity detectors, TIFF
*   writers may choose to manipulate the image to store gamma-compensated data.
*   Gamma-compensated data is more efficient at encoding an image than is linear
*   intensity data because it requires fewer BitsPerPixel to eliminate banding
*   in the darker tones. It also has the advantage of being closer to the tone
*   response of the display or printer and is, therefore, less likely to produce
*   poor results from applications that are not rigorous about their treatment
*   of images. Be aware that the PhotometricInterpretation value of 0 or 1
*   (grayscale) implies linear data because no gamma is specified. The
*   PhotometricInterpretation value of 2 (RGB data) specifies the NTSC gamma of
*   2.2 as a default. If data is written as something other than the default,
*   then a GrayResponseCurve field or a TransferFunction field must be present
*   to define the deviation. For grayscale data, be sure that the densities in
*   the GrayResponseCurve are consistent with the PhotometricInterpretation
*   field and the HalftoneHints field.
*
* Arguments:
*
*     UINT16 x -- channel value to be converted
*
* Return Value:
*
*   Linearized channel value
*
\**************************************************************************/

static inline UINT16 
ConvertChannelTosRGB64(
    UINT16 x
    )
{
    using namespace sRGB;
    
    // Linear map a 16 bits value [0, 0xffff] to an 8 bits value [0, 0xff].
    // After this map, "temp" should be within [0, 0xff]
    // Note: if we really want to be fast, we can just take the high byte as the
    // input value. This is what Sam's library is doing. Photoshop 6.0 probably
    // is doing the same thing.

    UINT16 temp = (UINT16)( ( (double)x * 0xff) / 0xffff + 0.5);

    // Linearize the data to sRGB64 data format

    return (UINT16)LinearizeLUT[(BYTE)(temp)];
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     dstImageInfo -- imageInfo of what the sink wants
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::DecodeFrame(
    IN ImageInfo& dstImageInfo
    )
{
    HRESULT hResult = S_OK;
    RECT    currentRect;

    // Get the source format first. We can use it to check if we need to change
    // format or not
    
    PixelFormatID srcPixelFormatID = GetPixelFormatID();
    
    if ( srcPixelFormatID == PIXFMT_UNDEFINED ) 
    {
        WARNING(("GpTiffCodec:DecodeFrame--undefined pixel format"));
        return E_FAIL;
    }    
    
    // Buffer to hold original image bits
    // Note: underline TIFF code needs the buffer size at least the
    // width of the image. For example, for a 4 bpp index image, we should
    // allocate half the width. But the underline code will write outside
    // this buffer. So for now, we just make it happy. Will be fixed later.

    UINT    uiBytesNeeded = GetLineBytes(dstImageInfo.Width);
    
    VOID*   pOriginalBits = GpMalloc(uiBytesNeeded);    // Bits read from image
    VOID*   pTemp48 = GpMalloc(uiBytesNeeded);
    VOID*   pTemp32BppBuffer = GpMalloc(dstImageInfo.Width << 2);
                                                        // Buffer for storing
                                                        // 32 bpp conversion
                                                        // result
    VOID*   pResultBuf = GpMalloc(LineSize);
    VOID*   pBits = NULL;
    VOID*   pSrcBits = NULL;
    UINT    uiSrcStride = uiBytesNeeded;

    if ( !pOriginalBits || !pResultBuf || !pTemp32BppBuffer || !pTemp48 ) 
    {
        WARNING(("GpTiffCodec::DecodeFrame--out of memory"));
        hResult = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // Set it to zero. This is necessary for 1 bpp or 4 bpp source image since
    // the size we allocated is a multiple of 8 (1bpp) or 2 (4 bpp). It is
    // possible that we don't have enough bits to fill all the source bytes,
    // like non-multiple of 8 source width for 1 bpp case. If we don't set it
    // to zero, we might introduce extra noise when calling Restore1Bpp()

    GpMemset(pOriginalBits, 0, uiBytesNeeded * sizeof(BYTE));

    currentRect.left = 0;
    currentRect.right = dstImageInfo.Width;

    // Note: Theoritically, uiSrcStride == uiDestStride. But some codec might
    // not allocate DWORD aligned memory chunk, like gifencoder. So the problem
    // will occur in GpMemCpy() below when we fill the dest buffer. Though we
    // can fix it in the encoder side. But it is not realistic if the encoder is
    // written by 3rd party ISVs.
    //
    // One example is when you open an 8bpp indexed TIFF and save it as GIF. If
    // the width is 0x14d (333 in decimal) (flower.tif), the GIF encoder only
    // allocates 14d bytes for each scan line. So we have to calculate the
    // destStride and use it when do memcpy()

    UINT    uiDestStride = dstImageInfo.Width
                         * GetPixelFormatSize(dstImageInfo.PixelFormat);
    uiDestStride = (uiDestStride + 7) >> 3; // Total bytes needed

    BitmapData dstBitmapData;
    dstBitmapData.Scan0 = NULL;

    while ( CurrentLine < (INT)dstImageInfo.Height ) 
    {
        // Don't go outside of height boundary

        currentRect.top = CurrentLine;
        currentRect.bottom = CurrentLine + 1;
        
        // Read 1 line of TIFF data into buffer pointed by "pOriginalBits"

        if ( MSFFGetLine(1, (LPBYTE)pOriginalBits, uiBytesNeeded,
                         TiffInParam.pTiffHandle) != IFLERR_NONE )
        {
            hResult = MSFFGetLastError(TiffInParam.pTiffHandle);
            if ( hResult == S_OK )
            {
                // There are bunch of reasons MSFFGetLine() will fail. But
                // MSFFGetLastError() only reports stream related errors. So if
                // it is an other error which caused MSFFGetLine() fail, we just
                // set the return code as E_FAIL

                hResult = E_FAIL;
            }
            WARNING(("GpTiffCodec::DecodeFrame--MSFFGetLine failed"));            
            goto CleanUp;
        }
        
        // Get a data buffer from sink so that we can write our result to it
        // Note: here we pass in "dstImageInfo.PixelFormat" because we want the
        // sink to allocate a buffer which can contain the image data it wants

        hResult = DecodeSinkPtr->GetPixelDataBuffer(&currentRect, 
                                                    dstImageInfo.PixelFormat,
                                                    TRUE,
                                                    &dstBitmapData);
        if ( !SUCCEEDED(hResult) )
        {
            WARNING(("GpTiffCodec::DecodeFrame--GetPixelDataBuffer failed"));
            goto CleanUp;            
        }

        pSrcBits = pOriginalBits;

        // TIFF stores 24 or 32 bpp image in BGR and ABGR format while our
        // IImage needs RGB and ARGB format. So if the source is either 24
        // or 32 bpp, we have to do a conversion first.
        //
        // For 1 bpp and 4 bpp indexed mode it is a pain here that we have to do
        // the conversion before we give the data back
        // For example, in 4BPP_INDEX case, if the origianl width is 10
        // pixel and its value are A9 12 4F DE C3. But the
        // decoder will ask you to give it a 10 BYTES buffer(instead of
        // 5) and give you back the data as: AA 99 11 22 44 FF DD EE CC
        // 33
        // But we can't fool the uplevel since we have only 16 color.

        switch ( srcPixelFormatID )
        {
        case PIXFMT_32BPP_ARGB:
        {
            if ( OriginalColorSpace == IMGFLAG_COLORSPACE_CMYK )
            {
                if ( UseEmbeddedICC == FALSE )
                {
                    // Convert CMYK to RGB

                    CmykToRgbConvertor->Convert((BYTE*)pOriginalBits,
                                                (BYTE*)pTemp32BppBuffer,
                                                dstImageInfo.Width,
                                                1,
                                                dstImageInfo.Width * 4);
                }
                else
                {
                    // We have to return CMYK and then the caller will get
                    // the embedded ICC profile and call OS' ICC function to
                    // do the conversion

                    BYTE*   pTempDst = (BYTE*)pTemp32BppBuffer;
                    BYTE*   pTempSrc = (BYTE*)pOriginalBits;

                    // Before that we have to convert the data from KYMC to CMYK

                    for ( int i = 0; i < (int)(dstImageInfo.Width); i++ )
                    {
                        pTempDst[0] = pTempSrc[3];
                        pTempDst[1] = pTempSrc[2];
                        pTempDst[2] = pTempSrc[1];
                        pTempDst[3] = pTempSrc[0];

                        pTempDst += 4;
                        pTempSrc += 4;
                    }
                }
            }
            else
            {
                // For 32BPP_ARGB color, we need to do a conversion: ABGR->ARGB
            
                BYTE*   pTempDst = (BYTE*)pTemp32BppBuffer;
                BYTE*   pTempSrc = (BYTE*)pOriginalBits;

                for ( int i = 0; i < (int)(dstImageInfo.Width); i++ )
                {
                    pTempDst[0] = pTempSrc[2];
                    pTempDst[1] = pTempSrc[1];
                    pTempDst[2] = pTempSrc[0];
                    pTempDst[3] = pTempSrc[3];

                    pTempDst += 4;
                    pTempSrc += 4;
                }
            }// Real 32 bpp case
            
            // Up to here, all the source data should be pointed by
            // pTemp32BppBuffer. The stride size is (dstImageInfo.Width << 2)

            pBits = pTemp32BppBuffer;
            uiSrcStride = (dstImageInfo.Width << 2);
        }
            break;

        case PIXFMT_24BPP_RGB:
        {
            BYTE*   pTempSrc = (BYTE*)pOriginalBits;
            BYTE    cTemp;

            // Convert from BGR to RGB

            for ( int i = 0; i < (int)(dstImageInfo.Width); ++i )
            {
                cTemp = (BYTE)pTempSrc[0];
                pTempSrc[0] = pTempSrc[2];
                pTempSrc[2] = cTemp;

                pTempSrc += 3;
            }
            
            pBits = pOriginalBits;
            uiSrcStride = (dstImageInfo.Width * 3);
        }
            break;
        
        case PIXFMT_48BPP_RGB:
        {
            UNALIGNED UINT16 *pbTemp = (UINT16*)pOriginalBits;

            UNALIGNED UINT16* Scan0Temp = (UINT16*)pTemp48;

            // Convert from BGR to RGB

            for ( int i = 0; i < (int)(dstImageInfo.Width); ++i )
            {
                *(Scan0Temp + 2) = ConvertChannelTosRGB64(*pbTemp++); // R
                *(Scan0Temp + 1) = ConvertChannelTosRGB64(*pbTemp++); // G
                *(Scan0Temp + 0) = ConvertChannelTosRGB64(*pbTemp++); // B
        
                Scan0Temp += 3;
            }
            
            pBits = pTemp48;
            uiSrcStride = (dstImageInfo.Width * 6);
        }
            break;

        case PIXFMT_1BPP_INDEXED:
            Restore1Bpp((BYTE*)pSrcBits, (BYTE*)pResultBuf, LineSize);
            pBits = pResultBuf;
            uiSrcStride = LineSize;

            break;

        case PIXFMT_4BPP_INDEXED:
            Restore4Bpp((BYTE*)pSrcBits, (BYTE*)pResultBuf, LineSize);
            pBits = pResultBuf;
            uiSrcStride = LineSize;

            break;

        default:
            pBits = pSrcBits;

            break;
        }// switch (srcPixelFormatID)

        // Up to here, all the source data should be pointed by "pBits"
        // If source is 24 or 32, we have done the BGR to RGB conversion
        // If src and dst have different format, we need to do a format
        // conversion.

        if ( srcPixelFormatID != dstImageInfo.PixelFormat )
        {
            // Make a BitmapData structure to do a format conversion

            BitmapData srcBitmapData;

            srcBitmapData.Scan0 = pBits;
            srcBitmapData.Width = dstBitmapData.Width;
            srcBitmapData.Height = 1;
            srcBitmapData.PixelFormat = srcPixelFormatID;
            srcBitmapData.Reserved = 0;
            srcBitmapData.Stride = uiSrcStride;

            // Do the data conversion.

            hResult = ConvertBitmapData(&dstBitmapData,
                                        ColorPalettePtr,
                                        &srcBitmapData,
                                        ColorPalettePtr);
            if ( !SUCCEEDED(hResult) )
            {
                // This should never happen since we made sure we can do the
                // conversion in Decode() after we do the dst pixel format
                // adjustment

                ASSERT(FALSE);
                WARNING(("GpTiff::DecodeFrame--ConvertBitmapData failed"));
                goto CleanUp;
            }
        }// If src and dst format don't match
        else
        {
            GpMemcpy((void*)dstBitmapData.Scan0, pBits, uiDestStride);
        }// Src and Dst format match
        
        hResult = DecodeSinkPtr->ReleasePixelDataBuffer(&dstBitmapData);

        if ( !SUCCEEDED(hResult) )
        {
            WARNING(("GpTiff::DecodeFrame--ReleasePixelDataBuffer failed"));
            goto CleanUp;
        }

        CurrentLine += 1;
    }// while (CurrentLine < imageInfo.Height)
    
    hResult = S_OK;

CleanUp:
    // Reset current frame so that we can decode the same frame again if needed
    // Note: we need to call Reset() even if one of the function calls above
    // failed. For example, if call to ReleasePixelDataBuffer() failed which
    // means save or decode to memory failed, we still need to RESET ourself,
    // that is, reset the deocder so that caller can still call this decoder to
    // provide bits

    if ( MSFFReset(TiffInParam.pTiffHandle) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::DecodeFrame--MSFFReset failed"));
        hResult = E_FAIL;
    }

    if ( pOriginalBits )
    {
        GpFree(pOriginalBits);
        pOriginalBits = NULL;
    }
    
    if ( pTemp32BppBuffer )
    {
        GpFree(pTemp32BppBuffer);
        pTemp32BppBuffer = NULL;
    }

    if ( pTemp48 )
    {
        GpFree(pTemp48);
        pTemp48 = NULL;
    }
    
    if ( pResultBuf )
    {
        GpFree(pResultBuf);
        pResultBuf = NULL;
    }
    
    return hResult;
}// DecodeFrame()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame and return channel by channel
*
* Arguments:
*
*     dstImageInfo -- imageInfo of what the sink wants
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::DecodeForChannel(
    IN ImageInfo& dstImageInfo
    )
{
    // Sanity check, this function should be called only the image is in CMYK
    // color space

    ASSERT(OriginalColorSpace == IMGFLAG_COLORSPACE_CMYK)

    HRESULT hResult = S_OK;
    RECT    currentRect;

    // Buffer to hold original image bits and temp conversion result
    // Note: as we know this function should only be called when the source is
    // a CMYK image, that is, 4 bytes per pixel.

    UINT    uiBytesNeeded = (dstImageInfo.Width << 2);
    
    VOID*   pOriginalBits = GpMalloc(uiBytesNeeded);    // Bits read from image
    if ( !pOriginalBits ) 
    {
        WARNING(("GpTiffCodec::DecodeForChannel--out of memory"));
        return E_OUTOFMEMORY;
    }
    
    VOID*   pTemp32BppBuffer = GpMalloc(uiBytesNeeded); // Buffer for storing
                                                        // 32 bpp conversion
                                                        // result

    if ( !pTemp32BppBuffer ) 
    {
        GpFree(pOriginalBits);
        WARNING(("GpTiffCodec::DecodeForChannel--out of memory"));
        return E_OUTOFMEMORY;
    }
    
    currentRect.left = 0;
    currentRect.right = dstImageInfo.Width;

    while ( CurrentLine < (INT)dstImageInfo.Height ) 
    {
        // Don't go outside of height boundary

        currentRect.top = CurrentLine;
        currentRect.bottom = CurrentLine + 1;
        
        // Get a data buffer from sink so that we can write our result to it
        // Note: here we pass in "dstImageInfo.PixelFormat" because we want the
        // sink to allocate a buffer which can contain the image data it wants

        BitmapData dstBitmapData;
        hResult = DecodeSinkPtr->GetPixelDataBuffer(&currentRect, 
                                                    dstImageInfo.PixelFormat,
                                                    TRUE,
                                                    &dstBitmapData);
        if ( !SUCCEEDED(hResult) )
        {
            WARNING(("GpTiffCodec::DecodeFrame--GetPixelDataBuffer failed"));
            goto CleanUp;            
        }
    
        // Read 1 line of TIFF data into buffer pointed by "pOriginalBits"

        if ( MSFFGetLine(1, (LPBYTE)pOriginalBits, LineSize,
                         TiffInParam.pTiffHandle) != IFLERR_NONE )
        {
            hResult = MSFFGetLastError(TiffInParam.pTiffHandle);
            if ( hResult == S_OK )
            {
                // There are bunch of reasons MSFFGetLine() will fail. But
                // MSFFGetLastError() only reports stream related errors. So if
                // it is an other error which caused MSFFGetLine() fail, we just
                // set the return code as E_FAIL

                hResult = E_FAIL;
            }
            WARNING(("GpTiffCodec::DecodeFrame--MSFFGetLine failed"));
            goto CleanUp;
        }

        // Convert CMYK to channel output format.

        PBYTE pSource = (PBYTE)pOriginalBits;
        PBYTE pTarget = (PBYTE)pTemp32BppBuffer;
        
        for ( UINT i = 0; i < dstImageInfo.Width; ++i )
        {
            BYTE sourceColor = pSource[ChannelIndex];

            // Note: According to our spec, we should return negative CMYK to
            // the caller because they are sending data directly to the plate

            pTarget[0] = 255 - sourceColor;
            pTarget[1] = 255 - sourceColor;
            pTarget[2] = 255 - sourceColor;
            pTarget[3] = 0xff;
            pSource += 4;
            pTarget += 4;
        }
        
        // If src and dst have different format, we need to do a format
        // conversion. As we know this function should only be called when the
        // source is an CMYK image, that is in PIXFMT_32BPP_ARGB format.

        if ( dstImageInfo.PixelFormat != PIXFMT_32BPP_ARGB )
        {
            // Make a BitmapData structure to do a format conversion

            BitmapData srcBitmapData;

            srcBitmapData.Scan0 = pTemp32BppBuffer;
            srcBitmapData.Width = dstBitmapData.Width;
            srcBitmapData.Height = 1;
            srcBitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
            srcBitmapData.Reserved = 0;
            srcBitmapData.Stride = LineSize;

            // Do the data conversion.

            hResult = ConvertBitmapData(&dstBitmapData, NULL,
                                        &srcBitmapData, NULL);
            if ( !SUCCEEDED(hResult) )
            {
                WARNING(("GpTiff::DecodeForChannel--ConvertBitmapData failed"));
                goto CleanUp;
            }
        }// If src and dst format don't match
        else
        {
            GpMemcpy((void*)dstBitmapData.Scan0, pTemp32BppBuffer, LineSize);
        }// Src and Dst format match
        
        hResult = DecodeSinkPtr->ReleasePixelDataBuffer(&dstBitmapData);

        if ( !SUCCEEDED(hResult) )
        {
            WARNING(("GpTiff::DecodeFrame--ReleasePixelDataBuffer failed"));
            goto CleanUp;
        }

        CurrentLine += 1;
    }// while (CurrentLine < imageInfo.Height)
    
    hResult = S_OK;

    // Reset current frame so that we can decode the same frame again if needed

    if ( MSFFReset(TiffInParam.pTiffHandle) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::DecodeFrame--MSFFReset failed"));
        hResult = E_FAIL;
    }

CleanUp:
    if ( pOriginalBits )
    {
        GpFree(pOriginalBits);
        pOriginalBits = NULL;
    }
    
    if ( pTemp32BppBuffer )
    {
        GpFree(pTemp32BppBuffer);
        pTemp32BppBuffer = NULL;
    }

    return hResult;
}// DecodeForChannel()

/**************************************************************************\
*
* Function Description:
*
*   Build up an InternalPropertyItem list based on TIFF tags
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   05/02/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpTiffCodec::BuildPropertyItemList()
{
    if ( HasProcessedPropertyItem == TRUE )
    {
        return S_OK;
    }

    HasProcessedPropertyItem = TRUE;

    // Loop through all the TAGs in current frame and build the list

    if ( MSFFBuildPropertyList(TiffInParam.pTiffHandle,
                               &PropertyListTail,
                               &PropertyListSize,
                               &PropertyNumOfItems) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::BuildApp1PropertyList--Failed building list"));
        return E_FAIL;
    }

    return S_OK;
}// BuildPropertyItemList()

/**************************************************************************\
*
* Function Description:
*
*   Clean up cached InternalPropertyItem list
*
* Return Value:
*
*   None
*
* Revision History:
*
*   08/04/2000 minliu
*       Created it.
*
\**************************************************************************/

VOID
GpTiffCodec::CleanPropertyList()
{
    if ( HasProcessedPropertyItem == TRUE )
    {
        InternalPropertyItem*   pTempCurrent = PropertyListHead.pNext;
        InternalPropertyItem*   pTempNext = NULL;
        
        for ( int i = 0; 
              ((i < (INT)PropertyNumOfItems) && (pTempCurrent != NULL)); ++i )
        {
            pTempNext = pTempCurrent->pNext;

            GpFree(pTempCurrent->value);
            GpFree(pTempCurrent);

            pTempCurrent = pTempNext;
        }
        
        HasProcessedPropertyItem = FALSE;
        PropertyListHead.pPrev = NULL;
        PropertyListHead.pNext = &PropertyListTail;
        PropertyListTail.pPrev = &PropertyListHead;
        PropertyListTail.pNext = NULL;
        PropertyListSize = 0;
        PropertyNumOfItems = 0;
        HasPropertyChanged = FALSE;
    }
}// CleanPropertyList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngcodec.cpp
*
* Abstract:
*
*   Shared methods for the PNG codec
*
* Revision History:
*
*   7/20/99 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "pngcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpPngCodec::GpPngCodec(
    void
    )
{
    comRefCount   = 1;
}

GpPngDecoder::GpPngDecoder(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;

    pbBuffer = NULL;
    cbBuffer = 0;
    DecoderColorPalettePtr = NULL;
}

GpPngEncoder::GpPngEncoder(
    void
    )
{
    comRefCount   = 1;
    pIoutStream   = NULL;

    EncoderColorPalettePtr = NULL;
    LastPropertyBufferPtr = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpPngCodec::~GpPngCodec(
    void
    )
{
}

GpPngDecoder::~GpPngDecoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpPngCodec::~GpPngCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }
}

GpPngEncoder::~GpPngEncoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIoutStream)
    {
        WARNING(("GpPngCodec::~GpPngCodec -- need to call TerminateEncoder first"));
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    if ( LastPropertyBufferPtr != NULL )
    {
        // This points to the buffer in PNG encoder when the source calls
        // GetPropertyBuffer(). This piece of memory should be freed when
        // the caller calls PushPropertyItems(). But in case the decoder
        // forgets to call PushPropertyItems(), we have to clean up the memory
        // here

        WARNING(("GpPngCodec::~GpPngCodec -- property buffer not freed"));
        GpFree(LastPropertyBufferPtr);
        LastPropertyBufferPtr = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpPngCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

STDMETHODIMP
GpPngDecoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

STDMETHODIMP
GpPngEncoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageEncoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpPngCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

STDMETHODIMP_(ULONG)
GpPngDecoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

STDMETHODIMP_(ULONG)
GpPngEncoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpPngCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}

STDMETHODIMP_(ULONG)
GpPngDecoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}

STDMETHODIMP_(ULONG)
GpPngEncoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\off_tiff\tiffencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   TIFF encoder
*
* Abstract:
*
*   Implementation of the tiff filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*  (IImageSink).
*
* Revision History:
*
*   7/19/1999 MinLiu
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "tiffcodec.hpp"
#include "image.h"

// =======================================================================
// IImageEncoder methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
STDMETHODIMP
GpTiffCodec::InitEncoder(
    IN IStream* stream
    )
{
    // Make sure we haven't been initialized already

    if ( OutIStreamPtr )
    {
        WARNING(("GpTiffCodec::InitEncoder -- Already been initialized"));
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    OutIStreamPtr = stream;

    // office code need to set these attributes before doing
    // initialization
    // Note: all these attributes will be overwritten late when we
    // write the header info based on the EncoderImageInfo and SetEncoderParam()
    // By default, we save a LZW compressed, 24 bpp image
    // Note: If the caller doesn't call SetEncoderParam() to set these
    // parameters, we will save image in the same color depth as the source
    // image and use default compression method

    RequiredCompression = IFLCOMP_LZW;
    RequiredPixelFormat = PIXFMT_24BPP_RGB;
    HasSetColorFormat = FALSE;
    HasWrittenHeader = FALSE;

    TiffOutParam.Compression = RequiredCompression;
    TiffOutParam.ImageClass = IFLCL_RGB;
    TiffOutParam.BitsPerSample = 8;
    TiffOutParam.pTiffHandle = NULL;

    if ( MSFFOpen(stream, &TiffOutParam, IFLM_WRITE) == IFLERR_NONE )
    {
        return S_OK;
    }
    else
    {
        WARNING(("GpTiffCodec::InitEncoder -- MSFFOpen failed"));
        return E_FAIL;
    }
}// InitEncoder()
        
/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::TerminateEncoder()
{
    // Close the TIFF file and release all the resources

    MSFFClose(TiffOutParam.pTiffHandle);
    TiffOutParam.pTiffHandle = NULL;

    // Release the input stream

    if( OutIStreamPtr )
    {
        OutIStreamPtr->Release();
        OutIStreamPtr = NULL;
    }

    if ( NULL != ColorPalettePtr )
    {
        // Free the color palette we allocated

        GpFree(ColorPalettePtr);
        ColorPalettePtr = NULL;
    }

    // Free the memory allocated inside the TIFF lib
    // Note: Here the TIFFClose() won't actually close the file/IStream since
    // file/IStream is not opened by us. The top level codec manager will
    // close it if necessary

    return S_OK;
}// TerminateEncoder()

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}// GetEncodeSink()

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::SetFrameDimension(
    IN const GUID* dimensionID
    )
{    
    // We only support multi-page TIFF for now

    if ( (NULL == dimensionID) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpTiffCodec::SetFrameDimension -- wrong dimentionID"));
        return E_FAIL;
    }

    // We have a new page to encoder. Reset all the parameters for a new page
    // See comments in InitEncoder()

    TiffOutParam.Compression = IFLCOMP_LZW;
    TiffOutParam.ImageClass = IFLCL_RGB;
    TiffOutParam.BitsPerSample = 8;

    // Reset alpha info to none-alpha

    if ( MSFFSetAlphaFlags(TiffOutParam.pTiffHandle, IFLM_WRITE) != IFLERR_NONE)
    {
        WARNING(("GpTiffCodec::WriteHeader -- MSFFSetAlphaFlags failed"));
        return E_FAIL;
    }
    
    short sParam = (IFLIT_PRIMARY << 8) | (SEEK_SET & 0xff);

    if ( MSFFControl(IFLCMD_IMAGESEEK, sParam, NULL, NULL,
                     &TiffOutParam) != IFLERR_NONE )
    {
        WARNING(("TiffCodec::SetFrameDimension-MSFFControl image seek failed"));
        return E_FAIL;
    }

    // Reset PACK Mode

    if ( MSFFControl(IFLCMD_SETPACKMODE, IFLPM_NORMALIZED, 0, NULL,
                     &TiffOutParam)
        != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::SetFrameDimension -- set packed mode failed"));
        return E_FAIL;
    }

    // Reset HasWrittenHeader flag since we are going to write a new header info

    HasWrittenHeader = FALSE;

    return S_OK;
}// SetFrameDimension()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size
*
* Arguments:
*
*   size---------- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpTiffCodec::GetEncoderParameterListSize---Invalid input"));
        return E_INVALIDARG;
    }

    // Note: For TIFF encoder, we currently support following 3 GUIDs
    // ENCODER_COMPRESSION---Which has 5 return value of ValueTypeLong and it
    // takes 5 UINT.
    // ENCODER_COLORDEPTH---Which has 5 return values of ValueTypeLong. So
    // we need 5 UINT for it.
    // ENCODER_SAVE_FLAG---which has 1 return values of ValueTypeLong. So we
    // need 1 UINT for it
    //
    // This comes the formula below:

    UINT uiEncoderParamLength = sizeof(EncoderParameters)
                              + 3 * sizeof(EncoderParameter)
                              + 11 * sizeof(UINT);

    *size = uiEncoderParamLength;

    return S_OK;
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list
*
* Arguments:
*
*   size------------ The size of the encoder parameter list
*   Params---------- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpTiffCodec::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    // Note: For TIFF encoder, we currently support following 3 GUIDs
    // ENCODER_COMPRESSION---Which has 5 return value of ValueTypeLong and it
    // takes 5 UINT.
    // ENCODER_COLORDEPTH---Which has 5 return values of ValueTypeLong. So
    // we need 5 UINT for it.
    // ENCODER_SAVE_FLAG---which has 1 return values of ValueTypeLong. So we
    // need 1 UINT for it
    //
    // This comes the formula below:

    UINT uiEncoderParamLength = sizeof(EncoderParameters)
                              + 3 * sizeof(EncoderParameter)
                              + 11 * sizeof(UINT);


    if ( (size != uiEncoderParamLength) || (Params == NULL) )
    {
        WARNING(("GpTiffCodec::GetEncoderParameterList---Invalid input"));
        return E_INVALIDARG;
    }

    Params->Count = 3;
    Params->Parameter[0].Guid = ENCODER_COMPRESSION;
    Params->Parameter[0].NumberOfValues = 5;
    Params->Parameter[0].Type = EncoderParameterValueTypeLong;

    Params->Parameter[1].Guid = ENCODER_COLORDEPTH;
    Params->Parameter[1].NumberOfValues = 5;
    Params->Parameter[1].Type = EncoderParameterValueTypeLong;
    
    Params->Parameter[2].Guid = ENCODER_SAVE_FLAG;
    Params->Parameter[2].NumberOfValues = 1;
    Params->Parameter[2].Type = EncoderParameterValueTypeLong;

    UINT*   puiTemp = (UINT*)((BYTE*)&Params->Parameter[0]
                              + 3 * sizeof(EncoderParameter));
    
    puiTemp[0] = EncoderValueCompressionLZW;
    puiTemp[1] = EncoderValueCompressionCCITT3;
    puiTemp[2] = EncoderValueCompressionRle;
    puiTemp[3] = EncoderValueCompressionCCITT4;
    puiTemp[4] = EncoderValueCompressionNone;
    puiTemp[5] = 1;
    puiTemp[6] = 4;
    puiTemp[7] = 8;
    puiTemp[8] = 24;
    puiTemp[9] = 32;
    puiTemp[10] = EncoderValueMultiFrame;

    Params->Parameter[0].Value = (VOID*)puiTemp;
    Params->Parameter[1].Value = (VOID*)(puiTemp + 5);
    Params->Parameter[2].Value = (VOID*)(puiTemp + 10);

    return S_OK;
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   This method is used for setting encoder parameters. It must be called
*   before GetEncodeSink().
*
* Arguments:
*
*   Param - Specifies the encoder parameter to be set
*
* Return Value:
*
*   Status code
*
* Note: It will better if we can validate the setting combinations here. For
*   example, 24 bpp and CCITT3 is not valid combination. Unfortunately we cannot
*   return error here since the caller might set the color depth after setting
*   the compression method. Anyway, WriteHeader() will return FAIL for this kind
*   of illegal combination.
\**************************************************************************/

HRESULT
GpTiffCodec::SetEncoderParameters(
    IN const EncoderParameters* pEncoderParams
    )
{
    if ( (NULL == pEncoderParams) || (pEncoderParams->Count == 0) )
    {
        WARNING(("GpTiffCodec::SetEncoderParam--invalid input args"));
        return E_INVALIDARG;
    }

    UINT ulTemp;

    for ( UINT i = 0; (i < pEncoderParams->Count); ++i )
    {
        // Figure out which parameter the caller wants to set

        if ( pEncoderParams->Parameter[i].Guid == ENCODER_COMPRESSION )
        {
            if ( (pEncoderParams->Parameter[i].Type != EncoderParameterValueTypeLong)
               ||(pEncoderParams->Parameter[i].NumberOfValues != 1) )
            {
                WARNING(("Tiff::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }
            
            ulTemp = *((UINT*)pEncoderParams->Parameter[i].Value);

            // Figure out the compression requirement

            switch ( ulTemp )
            {
            case EncoderValueCompressionLZW:
                RequiredCompression = IFLCOMP_LZW;
                break;

            case EncoderValueCompressionCCITT3:
                RequiredCompression = IFLCOMP_CCITTG3;
                break;
                                               
            case EncoderValueCompressionRle:
                RequiredCompression = IFLCOMP_RLE;
                break;

            case EncoderValueCompressionCCITT4:
                RequiredCompression = IFLCOMP_CCITTG4;
                break;

            case EncoderValueCompressionNone:
                RequiredCompression = IFLCOMP_NONE;
                break;

            default:
                WARNING(("Tiff:SetEncoderParameter-invalid compression input"));
                return E_INVALIDARG;
            }
        }// ENCODER_COMPRESSION
        else if ( pEncoderParams->Parameter[i].Guid == ENCODER_COLORDEPTH )
        {
            if ( (pEncoderParams->Parameter[i].Type != EncoderParameterValueTypeLong)
               ||(pEncoderParams->Parameter[i].NumberOfValues != 1) )
            {
                WARNING(("Tiff::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }
            
            ulTemp = *((UINT*)pEncoderParams->Parameter[i].Value);
            
            switch ( ulTemp )
            {
            case 1:
                RequiredPixelFormat = PIXFMT_1BPP_INDEXED;
                break;

            case 4:
                RequiredPixelFormat = PIXFMT_4BPP_INDEXED;
                break;

            case 8:
                RequiredPixelFormat = PIXFMT_8BPP_INDEXED;
                break;

            case 24:
                RequiredPixelFormat = PIXFMT_24BPP_RGB;
                break;

            case 32:
                RequiredPixelFormat = PIXFMT_32BPP_ARGB;
                break;

            default:
                WARNING(("Tiff::SetEncoderParam--invalid color depth input"));
                return E_INVALIDARG;
            }

            HasSetColorFormat = TRUE;
        }// ENCODER_COLORDEPTH
    }// Loop all the settings

    return S_OK;
}// SetEncoderParameters()

// =======================================================================
// IImageSink methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    // Require TOPDOWN and FULLWIDTH
    
    imageInfo->Flags = imageInfo->Flags
                     | SINKFLAG_TOPDOWN
                     | SINKFLAG_FULLWIDTH;

    // Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    
    imageInfo->Flags = imageInfo->Flags
                     & ~SINKFLAG_SCALABLE
                     & ~SINKFLAG_PARTIALLY_SCALABLE
                     & ~SINKFLAG_MULTIPASS
                     & ~SINKFLAG_COMPOSITE;

    // Tell the source that we prefer to the get the format as the caller
    // required format if the caller has set the format through
    // SetEncoderParam().
    // If SetEncoderParam() has not been called, then we don't need to modify
    // the source format if it is a format the encoder can handle. However,
    // if the format is one that the encoder cannot handle, then BeginSink()
    // will return a format that the encoder can handle.
    // Note: When the source calls PushPixelData() or GetPixelDataBuffer(), it
    // can either supply pixel data in the format asked by us (in BeginSink()),
    // or it can supply pixel data in one of the canonical pixel formats.

    if ( HasSetColorFormat == TRUE )
    {
        imageInfo->PixelFormat = RequiredPixelFormat;
    }
    else if ( imageInfo->Flags & SINKFLAG_HASALPHA )
    {
        RequiredPixelFormat = PIXFMT_32BPP_ARGB;
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
    }
    else
    {
        switch ( imageInfo->PixelFormat )
        {
        case PIXFMT_1BPP_INDEXED:        
            RequiredPixelFormat = PIXFMT_1BPP_INDEXED;

            break;

        case PIXFMT_4BPP_INDEXED:        
            RequiredPixelFormat = PIXFMT_4BPP_INDEXED;

            break;

        case PIXFMT_8BPP_INDEXED:
            RequiredPixelFormat = PIXFMT_8BPP_INDEXED;

            break;

        case PIXFMT_16BPP_GRAYSCALE:
        case PIXFMT_16BPP_RGB555:
        case PIXFMT_16BPP_RGB565:
        case PIXFMT_16BPP_ARGB1555:
        case PIXFMT_24BPP_RGB:
        case PIXFMT_48BPP_RGB:

            // TIFF can't save 16 bpp mode. So we have to save it as 24 bpp

            RequiredPixelFormat = PIXFMT_24BPP_RGB;

            break;

        case PIXFMT_32BPP_RGB:
        case PIXFMT_32BPP_ARGB:
        case PIXFMT_32BPP_PARGB:
        case PIXFMT_64BPP_ARGB:
        case PIXFMT_64BPP_PARGB:

            RequiredPixelFormat = PIXFMT_32BPP_ARGB;

            break;

        default:

            // Unknown pixel format

            WARNING(("Tiff::BeginSink()--unknown pixel format"));
            return E_FAIL;
        }// switch ( bitmapData->PixelFormat )

        // Tell the source the pixel format we prefer to receive. It might be
        // the same as the source format

        imageInfo->PixelFormat = RequiredPixelFormat;
    }// Validate the source pixel format to see if we can support it

    EncoderImageInfo = *imageInfo;
    
    if ( subarea ) 
    {
        // Deliver the whole image to the encoder

        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    return S_OK;
}// BeginSink()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the sink state
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::EndSink(
    IN HRESULT statusCode
    )
{
    // Tell the lower level that we have done for current page. But not close
    // the image yet since we might have more pages coming to save

    if ( MSFFFinishOnePage(TiffOutParam.pTiffHandle) == IFLERR_NONE )
    {
        return statusCode;
    }

    WARNING(("Tiff::EndSink()--MSFFFinishOnePage failed"));
    return E_FAIL;
}// EndSink()
    
/**************************************************************************\
*
* Function Description:
*
*     Writes the bitmap file headers
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::WriteHeader()
{
    UINT16      usPhotoMetric;
    UINT16      usBitsPerSample;
    UINT16      usSamplesPerpixel;
    IFLCLASS    imgClass;

    BOOL        bNeedPalette = TRUE;

    if ( HasWrittenHeader == TRUE )
    {
        // Already wrote the header

        return S_OK;
    }

    // Validate the settings
    // Note: RequiredPixelFormat should have been set either in
    // SetEncoderParameters() or BeginSink()
    // RequiredCompression is initialized in InitEncoder() and should be set in
    // SetEncoderParameters() if the caller wants to set it

    if ( (  (RequiredCompression == IFLCOMP_CCITTG3)
          ||(RequiredCompression == IFLCOMP_CCITTG4)
          ||(RequiredCompression == IFLCOMP_RLE) )
       &&(RequiredPixelFormat != PIXFMT_1BPP_INDEXED) )
    {
        // For these compression method, the source has to be in 1 bpp mode

        WARNING(("Tiff::WriteHeader--invalid input"));
        return E_INVALIDARG;
    }
    
    // Setup TAGs based on the RequiredPixelFormat, the format we are going to
    // write out.
    
    switch ( RequiredPixelFormat )
    {
    case PIXFMT_1BPP_INDEXED:
        usPhotoMetric = PI_WHITEISZERO;
        usBitsPerSample = 1;
        usSamplesPerpixel = 1;
        imgClass = IFLCL_BILEVEL;

        bNeedPalette = FALSE;       // For BiLevel TIFF,palette is not required
        
        break;

    case PIXFMT_4BPP_INDEXED:
        usPhotoMetric = PI_PALETTE;
        usBitsPerSample = 4;
        usSamplesPerpixel = 1;
        imgClass = IFLCL_PALETTE;
        
        break;

    case PIXFMT_8BPP_INDEXED:
        usPhotoMetric = PI_PALETTE;
        usBitsPerSample = 8;
        usSamplesPerpixel = 1;
        imgClass = IFLCL_PALETTE;
        
        break;

    case PIXFMT_24BPP_RGB:
        usPhotoMetric = PI_RGB;
        usBitsPerSample = 8;
        usSamplesPerpixel = 3;
        imgClass = IFLCL_RGB;

        bNeedPalette = FALSE;

        break;
    
    case PIXFMT_32BPP_ARGB:
        usPhotoMetric = PI_RGB;
        usBitsPerSample = 8;
        usSamplesPerpixel = 4;
        imgClass = IFLCL_RGBA;

        // Tell the lower level that we have an alpha channel

        if ( MSFFSetAlphaFlags(TiffOutParam.pTiffHandle, IFLM_CHUNKY_ALPHA)
             != IFLERR_NONE )
        {
            WARNING(("GpTiffCodec::WriteHeader -- MSFFSetAlphaFlags failed"));
            return E_FAIL;
        }

        bNeedPalette = FALSE;

        break;
    
    default:
        
        // Unknown format
        
        WARNING(("GpTiffCodec::WriteHeader -- Unknown pixel format"));
        return E_FAIL;
    }

    TiffOutParam.Width = EncoderImageInfo.Width;
    TiffOutParam.Height = EncoderImageInfo.Height;
    TiffOutParam.BitsPerSample = usBitsPerSample;
    TiffOutParam.Compression = RequiredCompression;
    TiffOutParam.ImageClass = imgClass;
    
    // Set image header info

    if ( MSFFSetImageParams(TiffOutParam) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::WriteHeader -- MSFFSetImageParams failed"));
        return E_FAIL;
    }
        
    DWORD   XDpi[2];

    XDpi[0] = (DWORD)(EncoderImageInfo.Xdpi + 0.5);
    XDpi[1] = (DWORD)(EncoderImageInfo.Ydpi + 0.5);

    // Since GDI+ uses inch (DPI) as resolution unit, so we need to set
    // resolution unit first and then set the resolution value

    UINT16    resType = TV_Inch;

    if ( MSFFPutTag(TiffOutParam.pTiffHandle, T_ResolutionUnit,
                    T_SHORT, 1, (BYTE*)(&resType)) != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::WriteHeader -- set resolution unit failed"));
        return E_FAIL;
    }

    // Write out the resolution info
    // The value "3" for sParm means we need to write 2 (0x11) values.

    if ( MSFFControl(IFLCMD_RESOLUTION, 3, 0, (void*)&XDpi, &TiffOutParam)
         != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::WriteHeader -- set resolution failed"));
        return E_FAIL;
    }

    // Set PACK Mode

    if ( MSFFControl(IFLCMD_SETPACKMODE, IFLPM_PACKED, 0, NULL, &TiffOutParam)
        != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::WriteHeader -- set packed mode failed"));
        return E_FAIL;
    }

    // Set palette if necessary

    HRESULT hr = S_OK;

    if ( bNeedPalette )
    {
        if ( NULL == ColorPalettePtr ) 
        {
            WARNING(("WriteHeader--Palette needed but not provided by sink"));
            return E_FAIL;
        }

        // Palette count check
        // Note: This is important because some formats, like gif, can be 8bpp
        // in color depth but has only less than 256 colors in the palette. But
        // for TIFF, the color palette length has to match the color depth. So
        // we have to do some padding here        

        int iNumColors = ColorPalettePtr->Count;

        if ( iNumColors != (1 << usBitsPerSample) )
        {
            ColorPalette*   pSrcPalette = ColorPalettePtr;
            int             iTemp;

            iNumColors = (1 << usBitsPerSample);
    
            ColorPalettePtr = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                              + iNumColors * sizeof(ARGB));

            if ( NULL == ColorPalettePtr )
            {
                WARNING(("GpTiffCodec::WriteHeader -- Out of memory"));
                return E_OUTOFMEMORY;
            }

            ColorPalettePtr->Flags = 0;
            ColorPalettePtr->Count = iNumColors;

            // Copy the old palette first
            // Note: Some bad decoder or source might still send down more
            // entries than it claims. So we need to take the minimum

            int iTempCount = (int)pSrcPalette->Count;
            if ( iTempCount > iNumColors )
            {
                // Evil image. For this color depth, the maxium entries we can
                // have is iNumColors

                iTempCount = iNumColors;
            }

            for ( iTemp = 0; iTemp < iTempCount; ++iTemp )
            {
                ColorPalettePtr->Entries[iTemp] = pSrcPalette->Entries[iTemp];
            }

            // Pad the rest with 0s

            for ( iTemp = (int)pSrcPalette->Count;
                  iTemp < (int)iNumColors; ++iTemp )
            {
                ColorPalettePtr->Entries[iTemp] = (ARGB)0;
            }

            // Free the old copy

            GpFree(pSrcPalette);
        }// If the palette size doesn't match color depth

        // Allocate a palette buffer which contains only RGB component.
        // Note: the one passed in is in ARGB format while TIFF need only RGB
        // format

        BYTE* puiPalette = (BYTE*)GpMalloc(3 * iNumColors * sizeof(BYTE));

        if ( NULL == puiPalette )
        {
            WARNING(("GpTiffCodec::WriteHeader--Out of memory for palette"));
            return E_OUTOFMEMORY;
        }

        ARGB    indexValue;

        // Convert from ARGB to RGB palette

        for ( int i = 0; i < iNumColors; i++ )
        {
            indexValue = ColorPalettePtr->Entries[i];


            puiPalette[3 * i] = (BYTE)((indexValue & 0x00ff0000) >> RED_SHIFT );
            puiPalette[3*i+1] = (BYTE)((indexValue & 0x0000ff00)>>GREEN_SHIFT);
            puiPalette[3*i+2] = (BYTE)((indexValue & 0x000000ff) >>BLUE_SHIFT );
        }

        // Set the palette

        if ( MSFFControl(IFLCMD_PALETTE, 0, 0,
                         puiPalette, &TiffOutParam) != IFLERR_NONE )
        {
            WARNING(("GpTiffCodec::WriteHeader -- set palette failed"));
            hr = E_FAIL;
        }
        
        GpFree(puiPalette);
    }// if ( bNeedPalette )

    HasWrittenHeader = TRUE;
    
    return hr;
}// WriteHeader()

/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette. Here we make a copy of it. It will be used when
*   we need to do conversion between different formats
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpTiffCodec::SetPalette(
    IN const ColorPalette* palette
    )
{
    // Free the old palette first

    if ( NULL != ColorPalettePtr )
    {
        // Free the old color palette

        GpFree(ColorPalettePtr);
    }
    
    ColorPalettePtr = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                              + palette->Count * sizeof(ARGB));

    if ( NULL == ColorPalettePtr )
    {
        WARNING(("GpTiffCodec::SetPalette -- Out of memory"));
        return E_OUTOFMEMORY;
    }

    ColorPalettePtr->Flags = 0;
    ColorPalettePtr->Count = palette->Count;

    for ( int i = 0; i < (int)ColorPalettePtr->Count; ++i )
    {
        ColorPalettePtr->Entries[i] = palette->Entries[i];
    }

    return S_OK;
}// SetPalette()

/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::GetPixelDataBuffer(
    IN const RECT*      rect, 
    IN PixelFormatID    pixelFormat,
    IN BOOL             lastPass,
    OUT BitmapData*     bitmapData
    )
{
    // Validate input parameters

    if ( (rect->left != 0)
      || (rect->right != (LONG)EncoderImageInfo.Width) )
    {
        WARNING(("Tiff::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if ( !lastPass ) 
    {
        WARNING(("Tiff::GetPixelDataBuffer-must receive last pass pixels"));
        return E_INVALIDARG;
    }
    
    // The source pixel format has to be either the format we asked for (set in
    // BeginSink()) or one of the canonical pixel formats

    if ( (IsCanonicalPixelFormat(pixelFormat) == FALSE)
       &&(pixelFormat != RequiredPixelFormat) )
    {
        // Unknown pixel format
        
        WARNING(("Tiff::GetPixelDataBuffer -- Unknown input pixel format"));
        return E_FAIL;
    }
    
    // Figure out the stride length based on source image pixel format and
    // the width.

    SinkStride = EncoderImageInfo.Width;

    switch ( pixelFormat )
    {
    case PIXFMT_1BPP_INDEXED:

        SinkStride = ((SinkStride + 7) >> 3);

        break;

    case PIXFMT_4BPP_INDEXED:

        SinkStride = ((SinkStride + 1) >> 1);
        
        break;

    case PIXFMT_8BPP_INDEXED:

        break;

    case PIXFMT_24BPP_RGB:

        SinkStride *= 3;
        
        break;

    case PIXFMT_32BPP_ARGB:
    case PIXFMT_32BPP_PARGB:

        SinkStride = (SinkStride << 2);
        
        break;

    case PIXFMT_64BPP_ARGB:
    case PIXFMT_64BPP_PARGB:

        SinkStride = (SinkStride << 3);

        break;

    default:
        
        // Invalid pixel format
        
        return E_FAIL;
    }// switch ( pixelFormat )
        
    // Write TIFF header if haven't done so yet
    // Note: HasWrittenHeader will be set to TRUE in WriteHeader() when it
    // is done
    
    HRESULT hResult;
    
    if ( FALSE == HasWrittenHeader )
    {
        hResult = WriteHeader();
        if ( !SUCCEEDED(hResult) ) 
        {
            WARNING(("GpTiffCodec::GetPixelDataBuffer --WriteHeader failed"));
            return hResult;
        }
    }

    // Get the output stride size. We need this info in ReleasePixelDataBuffer()
    // to allocate approprite size of memory buffer

    if ( MSFFScanlineSize(TiffOutParam, &OutputStride) != IFLERR_NONE )
    {
        return E_FAIL;
    }

    // Fill the output bitmap info structure

    bitmapData->Width       = EncoderImageInfo.Width;
    bitmapData->Height      = rect->bottom - rect->top;
    bitmapData->Stride      = SinkStride;
    bitmapData->PixelFormat = pixelFormat;
    bitmapData->Reserved    = 0;
    
    // Restore the source image pixel format info

    EncoderImageInfo.PixelFormat = pixelFormat;

    // Remember the rectangle to be encoded

    EncoderRect = *rect;
    
    // Now allocate the buffer where the data will go. If the other end of the
    // sink is the decoder, then the decoded data will be in this buffer. So
    // here we have to allocate the memory according to the pixel format
    
    if ( !LastBufferAllocatedPtr )
    {
        LastBufferAllocatedPtr = GpMalloc(SinkStride * bitmapData->Height);
        if ( !LastBufferAllocatedPtr )
        {
            WARNING(("GpTiffCodec::GetPixelDataBuffer -- Out of memory"));
            return E_OUTOFMEMORY;
        }

        bitmapData->Scan0 = LastBufferAllocatedPtr;
    }
    else
    {
        WARNING(("TIFF:Need to first free buffer obtained in previous call"));
        return E_FAIL;
    }

    return S_OK;    
}// GetPixelDataBuffer()

/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     pSrcBitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::ReleasePixelDataBuffer(
    IN const BitmapData* pSrcBitmapData
    )
{
    // Buffer to hold one line of final image bits we are going to write out

    HRESULT hResult = S_OK;
    VOID*   pTempLineBuf = GpMalloc(OutputStride);

    if ( !pTempLineBuf )
    {
        WARNING(("GpTiffCodec::ReleasePixelDataBuffer -- Out of memory"));
        return E_OUTOFMEMORY;
    }
    
    // Allocate another line buffer for RGB->BGR conversion result
    
    VOID*   pDestBuf = GpMalloc(OutputStride);

    if ( !pDestBuf )
    {
        GpFree(pTempLineBuf);
        WARNING(("GpTiffCodec::ReleasePixelDataBuffer--Out of memory"));
        return E_OUTOFMEMORY;
    }

    VOID*   pBits = NULL;

    // Write one scanline at a time going from top-down
    // Note: In BeginSink(), we asked to source to provide us with TOP_DOWN
    // format. According to the spec that all sources are required to support
    // data transfer in top-down banding order, even if that's not their
    // preferred order.
    // Note: For TIFF, if we really want to support BOTTOM-UP, we can do a
    // flag check here and then call SaveBottomUp() or SabeTopDown
    // correspondingly. In the SaveBottomUp(), we need to set TAG T_Orientation
    // = 4, which means BOTTOM-UP, LEFT to RIGHT. Also loop starts at bottom
    
    for ( int iCurrentLine = EncoderRect.top;
          iCurrentLine < EncoderRect.bottom;
          ++iCurrentLine ) 
    {
        // Get the offset of the data bits for current line 

        BYTE*   pLineBits = ((BYTE*)pSrcBitmapData->Scan0)
                          + (iCurrentLine - EncoderRect.top)
                            * pSrcBitmapData->Stride;
        
        // If the source data format and the data format we are going to
        // write out are different, we need to do a format conversation

        if ( RequiredPixelFormat != pSrcBitmapData->PixelFormat )
        {
            // If the source doesn't provide us with the format we asked for, we
            // have to do a format conversion here before we write out
            // Here "resultBitmapData" is a BitmapData structure which
            // represents the format we are going to write out.
            // "tempSrcBitmapData" is a BitmapData structure which
            // represents the format we got from the source. Call
            // ConvertBitmapData() to do a format conversion.

            BitmapData resultBitmapData;
            BitmapData tempSrcBitmapData;

            resultBitmapData.Scan0 = pTempLineBuf;
            resultBitmapData.Width = pSrcBitmapData->Width;
            resultBitmapData.Height = 1;
            resultBitmapData.PixelFormat = RequiredPixelFormat;
            resultBitmapData.Reserved = 0;
            resultBitmapData.Stride = OutputStride;

            tempSrcBitmapData.Scan0 = pLineBits;
            tempSrcBitmapData.Width = pSrcBitmapData->Width;
            tempSrcBitmapData.Height = 1;
            tempSrcBitmapData.PixelFormat = pSrcBitmapData->PixelFormat;
            tempSrcBitmapData.Reserved = 0;
            tempSrcBitmapData.Stride = pSrcBitmapData->Stride;
            
            hResult = ConvertBitmapData(&resultBitmapData,
                                        ColorPalettePtr,
                                        &tempSrcBitmapData,
                                        ColorPalettePtr);

            if ( hResult != S_OK )
            {
                WARNING(("ReleasePixelDataBuffer--ConvertBitmapData failed"));
                break;
            }

            pBits = pTempLineBuf;
        }
        else
        {
            pBits = pLineBits;
        }

        // Up to this moment, one line of data we want should be pointed by
        // "pBits"

        if ( RequiredPixelFormat == PIXFMT_24BPP_RGB )
        {
            // For 24BPP_RGB color, we need to do a conversion: RGB->BGR
            // before writing
        
            BYTE*   pTempDst = (BYTE*)pDestBuf;
            BYTE*   pTempSrc = (BYTE*)pBits;

            for ( int i = 0; i < (int)(EncoderImageInfo.Width); i++ )
            {
                pTempDst[0] = pTempSrc[2];
                pTempDst[1] = pTempSrc[1];
                pTempDst[2] = pTempSrc[0];

                pTempDst += 3;
                pTempSrc += 3;
            }

            pBits = pDestBuf;
        }
        else if ( RequiredPixelFormat == PIXFMT_32BPP_ARGB )
        {
            // For 32BPP_ARGB color, we need to do a convertion: ARGB->ABGR
            // before writing
            
            BYTE*   pTempDst = (BYTE*)pDestBuf;
            BYTE*   pTempSrc = (BYTE*)pBits;

            for ( int i = 0; i < (int)(EncoderImageInfo.Width); i++ )
            {
                pTempDst[0] = pTempSrc[2];
                pTempDst[1] = pTempSrc[1];
                pTempDst[2] = pTempSrc[0];
                pTempDst[3] = pTempSrc[3];

                pTempDst += 4;
                pTempSrc += 4;
            }

            pBits = pDestBuf;        
        }

        // Write the result to file

        if ( MSFFPutLine(1, (BYTE*)pBits, pSrcBitmapData->Width,
                         TiffOutParam.pTiffHandle) != IFLERR_NONE )
        {
            hResult = MSFFGetLastError(TiffOutParam.pTiffHandle);
            if ( hResult == S_OK )
            {
                // There are bunch of reasons MSFFPutLine() will fail. But
                // MSFFGetLastError() only reports stream related errors. So if
                // it is an other error which caused MSFFPetLine() fail, we just
                // set the return code as E_FAIL

                hResult = E_FAIL;
            }
            WARNING(("ReleasePixelDataBuffer--MSFFPutLine failed"));

            break;
        }
    } // Write the whole image line by line

    GpFree(pTempLineBuf);
    GpFree(pDestBuf);

    // Free the memory buffer since we're done with it.
    // Note: this chunk of memory is allocated by us in GetPixelDataBuffer()

    if ( pSrcBitmapData->Scan0 == LastBufferAllocatedPtr )
    {
        GpFree(pSrcBitmapData->Scan0);
        LastBufferAllocatedPtr = NULL;
    }

    return hResult;
}// ReleasePixelDataBuffer()

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::PushPixelData(
    IN const RECT*          rect,
    IN const BitmapData*    bitmapData,
    IN BOOL                 lastPass
    )
{
    // Validate input parameters

    if ( (rect->left != 0)
      || (rect->right != (LONG)EncoderImageInfo.Width) )
    {
        WARNING(("Tiff::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if ( !lastPass ) 
    {
        WARNING(("Tiff::PushPixelData -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    EncoderRect = *rect;

    // The source pixel format has to be either the format we asked for (set in
    // BeginSink()) or one of the canonical pixel formats

    if ( (IsCanonicalPixelFormat(bitmapData->PixelFormat) == FALSE)
       &&(bitmapData->PixelFormat != RequiredPixelFormat) )
    {
        // Unknown pixel format
        
        WARNING(("Tiff::PushPixelData -- Unknown input pixel format"));
        return E_FAIL;
    }
    
    // Write TIFF header if haven't done so yet
    // Note: HasWrittenHeader will be set to TRUE in WriteHeader() when it
    // is done
    
    if ( FALSE == HasWrittenHeader )
    {    
        // Write bitmap headers if haven't done so yet
    
        HRESULT hResult = WriteHeader();
        if ( !SUCCEEDED(hResult) ) 
        {
            WARNING(("Tiff::PushPixelData -- WriteHeader failed"));
            return hResult;
        }
    }
    
    // Get the output stride size. We need this info in ReleasePixelDataBuffer()
    // to allocate approprite size of memory buffer

    if ( MSFFScanlineSize(TiffOutParam, &OutputStride) != IFLERR_NONE )
    {
        WARNING(("Tiff::PushPixelData -- MSFFScanlineSize failed"));
        return E_FAIL;
    }
    
    return ReleasePixelDataBuffer(bitmapData);
}// PushPixelData()

/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the .bmp stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpTiffCodec::PushRawData(
    IN const VOID* buffer, 
    IN UINT bufsize
    )
{
    return E_NOTIMPL;
}// PushRawData()

HRESULT
GpTiffCodec::GetPropertyBuffer(
    UINT            uiTotalBufferSize,
    PropertyItem**  ppBuffer
    )
{
    if ( (uiTotalBufferSize == 0) || ( ppBuffer == NULL) )
    {
        WARNING(("GpTiffCodec::GetPropertyBuffer---Invalid inputs"));
        return E_INVALIDARG;
    }

    if ( LastPropertyBufferPtr != NULL )
    {
        WARNING(("Tiff::GetPropertyBuffer---Free the old property buf first"));
        return E_INVALIDARG;
    }

    PropertyItem* pTempBuf = (PropertyItem*)GpMalloc(uiTotalBufferSize);
    if ( pTempBuf == NULL )
    {
        WARNING(("GpTiffCodec::GetPropertyBuffer---Out of memory"));
        return E_OUTOFMEMORY;
    }

    *ppBuffer = pTempBuf;

    // Remember the memory pointer we allocated so that we have better control
    // later

    LastPropertyBufferPtr = pTempBuf;

    return S_OK;
}// GetPropertyBuffer()

HRESULT
GpTiffCodec::PushPropertyItems(
    IN UINT numOfItems,
    IN UINT uiTotalBufferSize,
    IN PropertyItem* item,
    IN BOOL fICCProfileChanged
    )
{
    HRESULT hResult = S_OK;
    if ( HasWrittenHeader == TRUE )
    {
        WARNING(("Can't push property items after the header is written"));
        hResult = E_FAIL;
        goto CleanUp;
    }

    if ( MSFFTiffMakeTagSpace(TiffOutParam.pTiffHandle, numOfItems)
         != IFLERR_NONE )
    {
        WARNING(("GpTiffCodec::PushPropertyItems-MSFFTiffMakeTagSpace failed"));
        hResult = E_FAIL;
        goto CleanUp;
    }

    PropertyItem*   pCurrentItem = item;
    UINT32          ulCount = 0;
    UINT16          ui16Tag;

    for ( UINT i = 0; i < numOfItems; ++i )
    {
        ui16Tag = (UINT16)pCurrentItem->id;

        // First we need to check if we need to push this TAG now. Since some of
        // the properties will be written in BuildDirectory() (wtiff.cpp)
        // depends on current image. So we can skip these tags here
        // Note: we don't need to write T_SubfileType (Old sub file type) since
        // we always write out as T_NewSubfileType, the TIFF 6 recommended sub
        // file type

        switch ( ui16Tag )
        {
        case T_NewSubfileType:
        case T_ImageWidth:
        case T_ImageLength:
        case T_Compression:
        case T_Predictor:
        case T_SamplesPerPixel:
        case T_BitsPerSample:
        case T_PhotometricInterpretation:
        case T_ExtraSamples:
        case T_PlanarConfiguration:
        case T_RowsPerStrip:
        case T_StripByteCounts:
        case T_StripOffsets:
        case T_XResolution:
        case T_YResolution:
        case T_ResolutionUnit:
        case T_FillOrder:
        case T_SubfileType:
            break;

        case TAG_ICC_PROFILE:
        {
            // Since we can't save CMYK TIFF. So if an ICC profile is for CMYK,
            // then it is useless for the TIFF we are going to save here. We
            // should throw it away.
            // According to ICC spec, bytes 16-19 should describe the color
            // space

            if ( pCurrentItem->length < 20 )
            {
                // This is not a valid ICC profile, bail out

                break;
            }

            BYTE UNALIGNED*  pTemp = (BYTE UNALIGNED*)(pCurrentItem->value)+ 16;

            if ( (pTemp[0] == 'C')
               &&(pTemp[1] == 'M')
               &&(pTemp[2] == 'Y')
               &&(pTemp[3] == 'K') )
            {
                // If this is a CMYK profile, then we just bail out here, that
                // is, ignore this property item.
                
                break;
            }
        }

        default:
            if ( ui16Tag < T_NewSubfileType )
            {
                // According to TIFF 6 spec, the smallest and valid TAG is
                // T_NewSubfileType. Currently, only all the GPS tags defined in
                // the exif21 spec is smaller than this.
                // In order to avoid other apps run into problem, we should not
                // save these TAGs.

                break;
            }

            switch ( pCurrentItem->type )
            {
            case TAG_TYPE_BYTE:
            case TAG_TYPE_ASCII:
            case TAG_TYPE_UNDEFINED:
                ulCount = pCurrentItem->length;

                break;

            case TAG_TYPE_SHORT:
                ulCount = (pCurrentItem->length >> 1);

                break;

            case TAG_TYPE_LONG:
            case TAG_TYPE_SLONG:
                ulCount = (pCurrentItem->length >> 2);

                break;

            case TAG_TYPE_RATIONAL:
            case TAG_TYPE_SRATIONAL:
                ulCount = (pCurrentItem->length >> 3);

                break;

            default:
                WARNING(("GpTiffCodec::PushPropertyItems---Wrong tag type"));
                hResult = E_FAIL;
                goto CleanUp;
            }// switch ( pCurrentItem->type )

            if ( MSFFPutTag(TiffOutParam.pTiffHandle, ui16Tag,
                            (UINT16)pCurrentItem->type,
                            (UINT16)ulCount,
                            (BYTE*)(pCurrentItem->value) ) != IFLERR_NONE )
            {
                WARNING(("GpTiffCodec::PushPropertyItems--MSFFPutTag failed"));
                hResult = E_FAIL;
                goto CleanUp;
            }

            break;
        }// switch ( newTiffTag.idTag )
        
        pCurrentItem++;
    }// Loop through all the property items

CleanUp:
    // Free the buffer we allocated for the caller if it is the same as the one
    // we allocated in GetPropertyBuffer()

    if ( (item != NULL) && (item == LastPropertyBufferPtr) )
    {
        GpFree(item);
        LastPropertyBufferPtr = NULL;
    }

    return hResult;
}// PushPropertyItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngdecoder.cpp
*
* Abstract:
*
*   Implementation of the PNG filter decoder
*
* Revision History:
*
*   7/20/99 DChinn
*       Created it.
*   4/01/2000 MinLiu (Min Liu)
*       Took over and implemented property stuff
*
\**************************************************************************/

#include "precomp.hpp"
#include "pngcodec.hpp"
#include "libpng\spngread.h"
#include "..\..\render\srgb.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Error handling for the BITMAPSITE object
*
* Arguments:
*
*     fatal -- is the error fatal?
*     icase -- what kind of error
*     iarg  -- what kind of error
*
* Return Value:
*
*   boolean: should processing stop?
*
\**************************************************************************/
bool
GpPngDecoder::FReport (
    IN bool fatal,
    IN int icase,
    IN int iarg) const
{
    return fatal;
}


/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;

    // Make sure we haven't been initialized already

    if (pIstream) 
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;
    
    ImageBytesPtr = NULL;
    ImageBytesDataPtr = NULL;
    NeedToUnlockBytes = FALSE;

    // need to set read state to false here (instead of in BeginDecode)
    // in case GetImageInfo() is called
    
    bValidSpngReadState = FALSE;
    pGpSpngRead = NULL;
    pbInputBuffer = NULL;
    pbBuffer = NULL;
    
    // Property item stuff

    HasProcessedPropertyItem = FALSE;
    
    PropertyListHead.pPrev = NULL;
    PropertyListHead.pNext = &PropertyListTail;
    PropertyListHead.id = 0;
    PropertyListHead.length = 0;
    PropertyListHead.type = 0;
    PropertyListHead.value = NULL;

    PropertyListTail.pPrev = &PropertyListHead;
    PropertyListTail.pNext = NULL;
    PropertyListTail.id = 0;
    PropertyListTail.length = 0;
    PropertyListTail.type = 0;
    PropertyListTail.value = NULL;
    
    PropertyListSize = 0;
    PropertyNumOfItems = 0;
    HasPropertyChanged = FALSE;

    return S_OK;
}// InitDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder object
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpPngDecoder::TerminateDecoder()
{
    // Release the input stream
    // the destructor calls pGpSpngRead->EndRead();
    
    if ( (NeedToUnlockBytes == TRUE) && (ImageBytesPtr != NULL) )
    {
        // Unlock the whole memory block we locked in GetImageInfo()

        HRESULT hResult = ImageBytesPtr->UnlockBytes(ImageBytesDataPtr,
                                                     cbInputBuffer,
                                                     0);
        if ( FAILED(hResult) )
        {
            WARNING(("GpPngDecoder::TerminateDecoder---UnlockBytes() failed"));
        }
        
        ImageBytesDataPtr = NULL;        
        ImageBytesPtr->Release();
        ImageBytesPtr = NULL;
        cbInputBuffer = 0;
        NeedToUnlockBytes = FALSE;
    }

    delete pGpSpngRead;
    pGpSpngRead = NULL;

    if (pbInputBuffer)
    {
        GpFree (pbInputBuffer);
        pbInputBuffer = NULL;
    }
    if (pbBuffer)
    {
        GpFree (pbBuffer);
        pbBuffer = NULL;
    }

    if (pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    // Free all the cached property items if we have allocated them

    CleanUpPropertyItemList();

    return S_OK;
}// TerminateDecoder()

STDMETHODIMP 
GpPngDecoder::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpPngDecoder::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*   Build up an InternalPropertyItem list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::BuildPropertyItemList()
{
    HRESULT hResult = S_OK;
    UINT    uiTemp;

    if ( HasProcessedPropertyItem == TRUE )
    {
        return hResult;
    }

    // Check if we have read the image header yet. if not, read it. After read
    // the header, we should have all the property info we want
    // Note: bValidSpngReadState will be set to true in GetImageInfo()

    if ( bValidSpngReadState == FALSE )
    {
        ImageInfo imgInfo;

        hResult = GetImageInfo(&imgInfo);

        if ( FAILED(hResult) )
        {
            WARNING(("PngDecoder::BuildPropertyItemList-GetImageInfo failed"));
            return hResult;
        }
    }

    // Now add property item by item
    // pGpSpngRead should be set properly in GetImageInfo()

    ASSERT(pGpSpngRead != NULL);

    // Check if the image has build in ICC profile

    if ( pGpSpngRead->m_ulICCLen != 0 )
    {
        // This image has ICC profile info in it. Add the descriptor first

        if ( pGpSpngRead->m_ulICCNameLen != 0 )
        {
            PropertyNumOfItems++;
            PropertyListSize += pGpSpngRead->m_ulICCNameLen;

            if ( AddPropertyList(&PropertyListTail,
                                 TAG_ICC_PROFILE_DESCRIPTOR,
                                 pGpSpngRead->m_ulICCNameLen,
                                 TAG_TYPE_ASCII,
                                 pGpSpngRead->m_pICCNameBuf) != S_OK )
            {
                WARNING(("Png::BuildPropertyList--Add() ICC name failed"));
                return FALSE;
            }
        }

        // Now add the profile data

        PropertyNumOfItems++;
        PropertyListSize += pGpSpngRead->m_ulICCLen;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_ICC_PROFILE,
                             pGpSpngRead->m_ulICCLen,
                             TAG_TYPE_BYTE,
                             pGpSpngRead->m_pICCBuf) != S_OK )
        {
            WARNING(("Png::BuildPropertyList--AddPropertyList() ICC failed"));
            return FALSE;
        }
    }// ICC profile
    
    // Check if the image has sRGB chunk

    if ( pGpSpngRead->m_bIntent != 255 )
    {
        // Add rendering intent to the property list.
        // Note: the rendering intent takes 1 byte

        PropertyNumOfItems++;
        PropertyListSize += 1;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_SRGB_RENDERING_INTENT,
                             1,
                             TAG_TYPE_BYTE,
                             &pGpSpngRead->m_bIntent) != S_OK )
        {
            WARNING(("Png::BuildPropertyList--AddPropertyList render failed"));
            return FALSE;
        }
    }

    // Check if the image has gamma

    if ( pGpSpngRead->m_uGamma > 0 )
    {
        // This image has gamma info in it. The size is an unsigned int 32
        // Here is the spec: The value of gamma is encoded as a 4-byte unsigned
        // integer, representing gamma times 100,000. For example, a gamma of
        // 1/2.2 would be stored as 45455. When we return to the caller, we'd
        // prefer it to be 2.2. So we return it as TYPE_RATIONAL

        uiTemp = 2 * sizeof(UINT32);
        LONG    llTemp[2];
        llTemp[0] = 100000;
        llTemp[1] = pGpSpngRead->m_uGamma;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_GAMMA,
                             uiTemp,
                             TAG_TYPE_RATIONAL,
                             llTemp) != S_OK )
        {
            WARNING(("Png::BuildPropertyList--AddPropertyList() gamma failed"));
            return FALSE;
        }
    }// gamma

    // Check if the image has chromaticities

    if ( pGpSpngRead->m_fcHRM == TRUE )
    {
        // This image has chromaticities info in it. We will put two tags in the
        // property item list: TAG_WHITE_POINT (2 rationals) and
        // TAG_PRIMAY_CHROMATICS (6 rationals)
        // Note: White points and chromaticities should be > 0

        uiTemp = 4 * sizeof(UINT32);
        
        LONG    llTemp[4];
        llTemp[0] = pGpSpngRead->m_ucHRM[0];
        llTemp[1] = 100000;
        llTemp[2] = pGpSpngRead->m_ucHRM[1];
        llTemp[3] = 100000;

        if ( (llTemp[0] > 0) && (llTemp[2] > 0) )
        {
            PropertyNumOfItems++;
            PropertyListSize += uiTemp;

            if ( AddPropertyList(&PropertyListTail,
                                 TAG_WHITE_POINT,
                                 uiTemp,
                                 TAG_TYPE_RATIONAL,
                                 &llTemp) != S_OK )
            {
                WARNING(("Png::BuildPropList--AddPropertyList() white failed"));
                return FALSE;
            }
        }

        // Add RGB points

        uiTemp = 12 * sizeof(UINT32);
        
        LONG    llTemp1[12];
        llTemp1[0] = pGpSpngRead->m_ucHRM[2];
        llTemp1[1] = 100000;
        llTemp1[2] = pGpSpngRead->m_ucHRM[3];
        llTemp1[3] = 100000;
        
        llTemp1[4] = pGpSpngRead->m_ucHRM[4];
        llTemp1[5] = 100000;
        llTemp1[6] = pGpSpngRead->m_ucHRM[5];
        llTemp1[7] = 100000;
        
        llTemp1[8] = pGpSpngRead->m_ucHRM[6];
        llTemp1[9] = 100000;
        llTemp1[10] = pGpSpngRead->m_ucHRM[7];
        llTemp1[11] = 100000;

        if ( (llTemp1[0] > 0) && (llTemp1[2] > 0)
           &&(llTemp1[4] > 0) && (llTemp1[6] > 0)
           &&(llTemp1[8] > 0) && (llTemp1[10] > 0) )
        {
            PropertyNumOfItems++;
            PropertyListSize += uiTemp;

            if ( AddPropertyList(&PropertyListTail,
                                 TAG_PRIMAY_CHROMATICS,
                                 uiTemp,
                                 TAG_TYPE_RATIONAL,
                                 &llTemp1) != S_OK )
            {
                WARNING(("Png::BuildPropertyList--AddPropList() white failed"));
                return FALSE;
            }
        }
    }// chromaticities
    
    // Check if the image has title

    if ( pGpSpngRead->m_ulTitleLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulTitleLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_IMAGE_TITLE,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pTitleBuf) != S_OK )
        {
            WARNING(("Png::BuildPropertyList-AddPropertyList() title failed"));
            return FALSE;
        }
    }// Title

    // Check if the image has author name

    if ( pGpSpngRead->m_ulAuthorLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulAuthorLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_ARTIST,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pAuthorBuf) != S_OK )
        {
            WARNING(("Png::BuildPropertyList-AddPropertyList() Author failed"));
            return FALSE;
        }
    }// Author
    
    // Check if the image has copy right

    if ( pGpSpngRead->m_ulCopyRightLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulCopyRightLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_COPYRIGHT,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pCopyRightBuf) != S_OK )
        {
            WARNING(("Png::BuildPropList-AddPropertyList() CopyRight failed"));
            return FALSE;
        }
    }// CopyRight
    
    // Check if the image has description

    if ( pGpSpngRead->m_ulDescriptionLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulDescriptionLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_IMAGE_DESCRIPTION,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pDescriptionBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() Description failed"));
            return FALSE;
        }
    }// Description
    
    // Check if the image has creation time

    if ( pGpSpngRead->m_ulCreationTimeLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulCreationTimeLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             EXIF_TAG_D_T_ORIG,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pCreationTimeBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() CreationTime failed"));
            return FALSE;
        }
    }// CreationTime
    
    // Check if the image has software info

    if ( pGpSpngRead->m_ulSoftwareLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulSoftwareLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_SOFTWARE_USED,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pSoftwareBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() Software failed"));
            return FALSE;
        }
    }// Software
    
    // Check if the image has device source info

    if ( pGpSpngRead->m_ulDeviceSourceLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulDeviceSourceLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_EQUIP_MODEL,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pDeviceSourceBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() DeviceSource failed"));
            return FALSE;
        }
    }// DeviceSource

    // Check if the image has comment

    if ( pGpSpngRead->m_ulCommentLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ulCommentLen;

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             EXIF_TAG_USER_COMMENT,
                             uiTemp,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pCommentBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() Comment failed"));
            return FALSE;
        }
    }// Comment
    
    // Check if the image specifies pixel size or aspect ratio

    if ( (pGpSpngRead->m_xpixels != 0) && (pGpSpngRead->m_ypixels != 0) )
    {
        // Pixel specifier takes 1 byte
        
        PropertyNumOfItems++;
        PropertyListSize += 1;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_PIXEL_UNIT,
                             1,
                             TAG_TYPE_BYTE,
                             &pGpSpngRead->m_bpHYs) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() pixel unit failed"));
            return FALSE;
        }
        
        // Pixels per unit in X and Y take 4 bytes each

        uiTemp = sizeof(ULONG);

        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_PIXEL_PER_UNIT_X,
                             uiTemp,
                             TAG_TYPE_LONG,
                             &pGpSpngRead->m_xpixels) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() pixel unit x failed"));
            return FALSE;
        }
        
        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_PIXEL_PER_UNIT_Y,
                             uiTemp,
                             TAG_TYPE_LONG,
                             &pGpSpngRead->m_ypixels) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() pixel unit y failed"));
            return FALSE;
        }    
    }// Pixel UNIT

    // Check if the image has last modification time

    if ( pGpSpngRead->m_ulTimeLen != 0 )
    {
        PropertyNumOfItems++;
        PropertyListSize += pGpSpngRead->m_ulTimeLen;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_DATE_TIME,
                             pGpSpngRead->m_ulTimeLen,
                             TAG_TYPE_ASCII,
                             pGpSpngRead->m_pTimeBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() time failed"));
            return FALSE;
        }
    }// DATE_TIME

    // Check if the image has palette histogram

    if ( pGpSpngRead->m_ihISTLen != 0 )
    {
        uiTemp = pGpSpngRead->m_ihISTLen * sizeof(UINT16);
        PropertyNumOfItems++;
        PropertyListSize += uiTemp;

        if ( AddPropertyList(&PropertyListTail,
                             TAG_PALETTE_HISTOGRAM,
                             uiTemp,
                             TAG_TYPE_SHORT,
                             pGpSpngRead->m_phISTBuf) != S_OK )
        {
            WARNING(("Png::BldPropList-AddPropertyList() hIST failed"));
            return FALSE;
        }
    }// Palette histogram

    HasProcessedPropertyItem = TRUE;

    return hResult;
}// BuildPropertyItemList()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpPngDecoder::GetPropertyCount--numOfProperty is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetPropertyCount-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

STDMETHODIMP 
GpPngDecoder::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetPropertyIdList-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image
    // Here we need to validate if the caller passes us the correct number of
    // IDs which we returned through GetPropertyItemCount(). Also, this is also
    // a validation for memory allocation because the caller allocates memory
    // based on the number of items we returned to it

    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpPngDecoder::GetPropertyList--input wrong"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // Coping list IDs from our internal property item list

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    for ( int i = 0;
         (  (i < (INT)PropertyNumOfItems) && (pTemp != NULL)
         && (pTemp != &PropertyListTail));
         ++i )
    {
        list[i] = pTemp->id;
        pTemp = pTemp->pNext;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpPngDecoder::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetPropertyItemSize-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist

        return IMGERR_PROPERTYNOTFOUND;
    }

    // The size of an property item should be "The size of the item structure
    // plus the size for the value

    *size = pTemp->length + sizeof(PropertyItem);

    return S_OK;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pBuffer
    )
{
    if ( pBuffer == NULL )
    {
        WARNING(("GpPngDecoder::GetPropertyItem--pBuffer is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
    BYTE*   pOffset = (BYTE*)pBuffer + sizeof(PropertyItem);

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( (pTemp->pNext == NULL) || (pTemp->value == NULL) )
    {
        // This ID doesn't exist in the list

        return IMGERR_PROPERTYNOTFOUND;
    }
    else if ( (pTemp->length + sizeof(PropertyItem)) != propSize )
    {
        WARNING(("Png::GetPropertyItem-propsize"));
        return E_INVALIDARG;
    }

    // Found the ID in the list and return the item

    pBuffer->id = pTemp->id;
    pBuffer->length = pTemp->length;
    pBuffer->type = pTemp->type;

    if ( pTemp->length != 0 )
    {
        pBuffer->value = pOffset;
        GpMemcpy(pOffset, pTemp->value, pTemp->length);
    }
    else
    {
        pBuffer->value = NULL;
    }
    
    return S_OK;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpPngDecoder::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetPropertySize-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/04/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpPngDecoder::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Png::GetAllPropertyItems-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list and assigtn the result out

    InternalPropertyItem*   pTempSrc = PropertyListHead.pNext;
    PropertyItem*           pTempDst = allItems;
    BYTE*                   pOffSet = (BYTE*)allItems + uiHeaderSize;
        
    for ( int i = 0; i < (INT)PropertyNumOfItems; ++i )
    {
        pTempDst->id = pTempSrc->id;
        pTempDst->length = pTempSrc->length;
        pTempDst->type = pTempSrc->type;

        if ( pTempSrc->length != 0 )
        {
            pTempDst->value = (void*)pOffSet;

            GpMemcpy(pOffSet, pTempSrc->value, pTempSrc->length);
        }
        else
        {
            // For zero length property item, set the value pointer to NULL

            pTempDst->value = NULL;
        }

        // Move onto next memory offset.
        // Note: if the current item length is 0, the next line doesn't move
        // the offset

        pOffSet += pTempSrc->length;
        pTempSrc = pTempSrc->pNext;
        pTempDst++;
    }
    
    return S_OK;
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/23/2001 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::RemovePropertyItem(
    IN PROPID   propId
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't built the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("PNG::RemovePropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // Item not found

        return IMGERR_PROPERTYNOTFOUND;
    }

    // Found the item in the list. Remove it

    PropertyNumOfItems--;
    PropertyListSize -= pTemp->length;

    RemovePropertyItemFromList(pTemp);

    // Remove the item structure

    delete pTemp;

    HasPropertyChanged = TRUE;

    return S_OK;
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/23/2001 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpPngDecoder::SetPropertyItem(
    IN PropertyItem item
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't built the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("PNG::SetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != item.id) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This item doesn't exist in the list, add it into the list

        PropertyNumOfItems++;
        PropertyListSize += item.length;

        if ( AddPropertyList(&PropertyListTail,
                             item.id,
                             item.length,
                             item.type,
                             item.value) != S_OK )
        {
            WARNING(("GpPngDecoder::SetPropertyItem-AddPropertyList() failed"));
            return E_FAIL;
        }
    }
    else
    {
        // This item already exists in the link list, update the info
        // Update the size first

        PropertyListSize -= pTemp->length;
        PropertyListSize += item.length;

        // Free the old item

        GpFree(pTemp->value);

        pTemp->length = item.length;
        pTemp->type = item.type;

        pTemp->value = GpMalloc(item.length);
        if ( pTemp->value == NULL )
        {
            // Since we already freed the old item, we should set its length to
            // 0 before return

            pTemp->length = 0;
            WARNING(("GpPngDecoder::SetPropertyItem-Out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pTemp->value, item.value, item.length);
    }

    HasPropertyChanged = TRUE;

    return S_OK;
}// SetPropertyItem()

VOID
GpPngDecoder::CleanUpPropertyItemList(
    )
{
    if ( HasProcessedPropertyItem == TRUE )
    {
        InternalPropertyItem*   pTempCurrent = PropertyListHead.pNext;
        InternalPropertyItem*   pTempNext = NULL;

        for ( int i = 0; 
            ((i < (INT)PropertyNumOfItems) && (pTempCurrent != NULL)); ++i )
        {
            pTempNext = pTempCurrent->pNext;

            GpFree(pTempCurrent->value);
            GpFree(pTempCurrent);

            pTempCurrent = pTempNext;
        }

        PropertyNumOfItems = 0;
        HasProcessedPropertyItem = FALSE;
    }
}// CleanUpPropertyItemList()

/**************************************************************************\
*
* Function Description:
*
*   Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink - The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EndDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    // Any other initialization
    currentLine = 0;
    bCalledBeginSink = FALSE;
    
    // It is possible that GetImageInfo() yet. Then pGpSpngRead will be NULL

    if ( bValidSpngReadState == FALSE )
    {
        ImageInfo dummyInfo;
        HRESULT hResult = GetImageInfo(&dummyInfo);
        if ( FAILED(hResult) )
        {
            WARNING(("GpPngDecoder::BeginDecode---GetImageInfo failed"));
            return hResult;
        }

        // Note: bValidSpngReadState will be set to TRUE in GetImageInfo()
    }

    // Prepare SPNGREAD object for reading
    
    cbBuffer = pGpSpngRead->CbRead();
    if (pbBuffer == NULL)
    {
        pbBuffer = GpMalloc(cbBuffer);
        if (!pbBuffer) 
        {
            return E_OUTOFMEMORY;
        }
    }
    if (!(pGpSpngRead->FInitRead (pbBuffer, cbBuffer)))
    {
        return E_FAIL;
    }
    
    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::EndDecode(
    IN HRESULT statusCode
    )
{
    if (DecoderColorPalettePtr) 
    {
        // Free the color palette

        GpFree(DecoderColorPalettePtr);
        DecoderColorPalettePtr = NULL;
    }
    
    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    pGpSpngRead->EndRead();

    HRESULT hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    if (FAILED(hresult)) 
    {
        statusCode = hresult; // If EndSink failed return that (more recent)
                              // failure code
    }

    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets up the ImageInfo structure
*
* Arguments:
*
*     ImageInfo -- information about the decoded image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    HRESULT hResult = S_OK;

    if (!bValidSpngReadState)
    {
        // Query the source stream to see if we can get a memory pointer back

        hResult = pIstream->QueryInterface(IID_IImageBytes,
                                           (VOID**)&ImageBytesPtr);
        
        if ( SUCCEEDED(hResult) )
        {
            hResult = ImageBytesPtr->CountBytes(&cbInputBuffer);
            if ( FAILED(hResult) )
            {
                WARNING(("GpPngDecoder::GetImageInfo---CountBytes() failed"));
                return hResult;
            }

            // Lock the the whole memory bits and pass it down to the
            // decompressor

            hResult = ImageBytesPtr->LockBytes(cbInputBuffer,
                                               0,
                                               &ImageBytesDataPtr);
            if ( FAILED(hResult) )
            {
                WARNING(("GpPngDecoder::GetImageInfo---LockBytes() failed"));
                return hResult;
            }
            
            if (pGpSpngRead == NULL)
            {
                if ( OSInfo::HasMMX )
                {
                    pGpSpngRead = new GpSpngRead(*this,
                                                 ImageBytesDataPtr,
                                                 cbInputBuffer,
                                                 TRUE);
                }
                else
                {
                    pGpSpngRead = new GpSpngRead(*this,
                                                 ImageBytesDataPtr,
                                                 cbInputBuffer,
                                                 FALSE);
                }
            }

            // We need to unlock the ImageBytes when the caller calls
            // TerminateDecoder()

            NeedToUnlockBytes = TRUE;
        }
        else
        {
            // Initialize the SPNGREAD object
            // Unfortunately, we need to read the entire stream for the SPNGREAD
            // constructor to work.  (!!! Is there an easy way to fix this?)

            STATSTG statStg;
            hResult = pIstream->Stat(&statStg, STATFLAG_NONAME);
            if (FAILED(hResult))
            {
                return hResult;
            }
            cbInputBuffer = statStg.cbSize.LowPart;

            // According to the document for IStream::Stat::StatStage(), the
            // caller has to free the pwcsName string

            CoTaskMemFree(statStg.pwcsName);

            if (pbInputBuffer == NULL)
            {
                pbInputBuffer = GpMalloc(cbInputBuffer);
                if (!pbInputBuffer)
                {
                    return E_OUTOFMEMORY;
                }
            }

            // Read the input bytes
            ULONG cbRead = 0;
            LARGE_INTEGER liZero;

            liZero.LowPart = 0;
            liZero.HighPart = 0;
            liZero.QuadPart = 0;

            hResult = pIstream->Seek(liZero, STREAM_SEEK_SET, NULL);
            if (FAILED(hResult))
            {
                return hResult;
            }
            
            hResult = pIstream->Read(pbInputBuffer, cbInputBuffer, &cbRead);
            if (FAILED(hResult))
            {
                return hResult;
            }
            
            if (cbRead != cbInputBuffer)
            {
                return E_FAIL;
            }

            if (pGpSpngRead == NULL)
            {
                if ( OSInfo::HasMMX )
                {
                    pGpSpngRead = new GpSpngRead(*this,
                                                 pbInputBuffer,
                                                 cbInputBuffer,
                                                 TRUE);
                }
                else
                {
                    pGpSpngRead = new GpSpngRead(*this,
                                                 pbInputBuffer,
                                                 cbInputBuffer,
                                                 FALSE);
                }
            }
        }
        
        if (!pGpSpngRead)
        {
            WARNING(("PngCodec::GetImageInfo--could not create SPNGREAD obj"));
            return E_FAIL;
        }
        
        // Read the header of the PNG file
        if (!pGpSpngRead->FHeader())
        {
            return E_FAIL;
        }

        bValidSpngReadState = TRUE;
    }

    // !!! TODO: A quick test to see if there is any transparency information
    // in the image, without decoding the image.

    imageInfo->Flags = SINKFLAG_TOPDOWN |
                       SINKFLAG_FULLWIDTH |
                       IMGFLAG_HASREALPIXELSIZE;
    
    // ASSERT: pSpgnRead->FHeader() has been called, which allows
    // us to call Width() and Height().
    imageInfo->RawDataFormat = IMGFMT_PNG;
    imageInfo->PixelFormat   = GetPixelFormatID();
    imageInfo->Width         = pGpSpngRead->Width();
    imageInfo->Height        = pGpSpngRead->Height();
    imageInfo->TileWidth     = imageInfo->Width;
    imageInfo->TileHeight    = 1;
    if (pGpSpngRead->m_bpHYs == 1)
    {
        // convert m_xpixels and m_ypixels from dots per meter to dpi
        imageInfo->Xdpi = (pGpSpngRead->m_xpixels * 254.0) / 10000.0;
        imageInfo->Ydpi = (pGpSpngRead->m_ypixels * 254.0) / 10000.0;
        imageInfo->Flags |= IMGFLAG_HASREALDPI;
    }
    else
    {
        // Start: [Bug 103296]
        // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
        HDC hdc;
        hdc = ::GetDC(NULL);
        if ((hdc == NULL) || 
            ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
            ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
        {
            WARNING(("GetDC or GetDeviceCaps failed"));
            imageInfo->Xdpi = DEFAULT_RESOLUTION;
            imageInfo->Ydpi = DEFAULT_RESOLUTION;
        }
        ::ReleaseDC(NULL, hdc);
        // End: [Bug 103296]
    }

    switch (pGpSpngRead->ColorType())
    {
    case 0:  // grayscale
        if (pGpSpngRead->m_ctRNS > 0)
        {
            imageInfo->Flags |= SINKFLAG_HASALPHA;
        }
        imageInfo->Flags |= IMGFLAG_COLORSPACE_GRAY;
        break;

    case 2:  // RGB
        if (pGpSpngRead->m_ctRNS > 0)
        {
            imageInfo->Flags |= SINKFLAG_HASALPHA;
        }
        imageInfo->Flags |= IMGFLAG_COLORSPACE_RGB;
        break;

    case 3:  // palette
        // !!! TODO: We still need to determine whether the palette has
        // greyscale or RGB values in it.
        if (pGpSpngRead->m_ctRNS > 0)
        {
            imageInfo->Flags |= SINKFLAG_HASALPHA | IMGFLAG_HASTRANSLUCENT;
        }
        break;

    case 4:  // grayscale + alpha
        imageInfo->Flags |= SINKFLAG_HASALPHA | IMGFLAG_HASTRANSLUCENT;
        imageInfo->Flags |= IMGFLAG_COLORSPACE_GRAY;
        break;

    case 6:  // RGB + alpha
        imageInfo->Flags |= SINKFLAG_HASALPHA | IMGFLAG_HASTRANSLUCENT;
        imageInfo->Flags |= IMGFLAG_COLORSPACE_RGB;
        break;

    default:
        WARNING(("GpPngDecoder::GetImageInfo -- bad pixel format."));
        break;
    }


    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*   None.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::Decode()
{
    HRESULT hresult;
    ImageInfo imageInfo;

    hresult = GetImageInfo(&imageInfo);
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    // Inform the sink that decode is about to begin

    if (!bCalledBeginSink) 
    {
        hresult = PassPropertyToSink();
        if ( FAILED(hresult) ) 
        {
            return hresult;
        }

        hresult = decodeSink->BeginSink(&imageInfo, NULL);
        if (!SUCCEEDED(hresult)) 
        {
            return hresult;
        }

        // Client cannot modify height or width
        imageInfo.Width         = pGpSpngRead->Width();
        imageInfo.Height        = pGpSpngRead->Height();

        // Determine whether we want the decoder to pass the data in the
        // format that the sink has returned from BeginSink or in 32BPP_ARGB
        // (a canonical format).
        PixelFormatID srcPixelFormatID = GetPixelFormatID();
        
        // Check the pixel format. If it is not equal to the format requested in
        // the call to BeginSink(), switch to a canonical format.

        if (  (imageInfo.PixelFormat != srcPixelFormatID)
            ||(srcPixelFormatID == PIXFMT_48BPP_RGB)
            ||(srcPixelFormatID == PIXFMT_64BPP_ARGB) )
        {
            // The sink is trying to negotiate a format with us.
            // The sink's format is different from the closest format
            // we determined: return PIXFMT_32BPP_ARGB (a canonical format).
            // (The other way to do this is to leave imageInfo.PixelFormat
            // the way it was returned if it is a format we can convert to.)
            // Note: we should not return 48 or 64 bpp because the code in the
            // engine doing 48 to 32 bpp assumes gamma = 2.2. If the PNG has
            // gamma info in it, the image won't display correctly. See Office
            // bug#330906

            imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
        }

        bCalledBeginSink = TRUE;
    }

    // ASSERT: At this point, imageInfo.PixelFormat is the format we will send to the sink.

    // set the palette if we need to (i.e., the format is indexed)
    if (imageInfo.PixelFormat & PIXFMTFLAG_INDEXED)
    {
        int cEntries = 0;
        SPNG_U8 *pbPNGPalette = const_cast<SPNG_U8 *> (pGpSpngRead->PbPalette(cEntries));

        DecoderColorPalettePtr = static_cast<ColorPalette *>
            (GpMalloc (sizeof (ColorPalette) + cEntries * sizeof(ARGB)));

        if (DecoderColorPalettePtr == NULL)
        {
            WARNING(("GpPngDecoder::Decode -- Out of memory"));
            return E_OUTOFMEMORY;
        }
        DecoderColorPalettePtr->Flags = 0;
        DecoderColorPalettePtr->Count = cEntries;

        // Set the RGB values of the palette.  Assume alpha 0xff for now.
        for (UINT iPixel = 0; iPixel < (UINT)cEntries; iPixel++)
        {
            DecoderColorPalettePtr->Entries[iPixel] =
                MAKEARGB(0xff,
                         pbPNGPalette [3 * iPixel],
                         pbPNGPalette [3 * iPixel + 1],
                         pbPNGPalette [3 * iPixel + 2]);
        }

        // If there is a transparency chunk, we need to set the alpha values
        // up to the number provided
        if (pGpSpngRead->m_ctRNS > 0)
        {
            // Even if all the alpha values are 0xff, we assume one or more likely
            // will be less than 0xff, so we set the color palette flag
            DecoderColorPalettePtr->Flags = PALFLAG_HASALPHA;

            // Make sure we don't write beyond the limits of the color palette array.
            // If the tRNS chunk contains more entries than the color palette, then
            // we ignore the extra alpha values.
            UINT iNumPixels = pGpSpngRead->m_ctRNS;
            if (cEntries < pGpSpngRead->m_ctRNS)
            {
                iNumPixels = cEntries;
            }

            for (UINT iPixel = 0; iPixel < iNumPixels; iPixel++)
            {
                // ASSERT: the alpha field of the ARGB value is 0xff before
                // we execute this line of code.
                // The result of this line of code is to set the alpha value
                // of the palette entry to the new value.
                
                DecoderColorPalettePtr->Entries[iPixel] =
                    (pGpSpngRead->m_btRNS[iPixel] << ALPHA_SHIFT) |
                    (DecoderColorPalettePtr->Entries[iPixel] & 0x00ffffff);
            }
        }

        // Now the palette is correct.  Set it for the sink.
        hresult = decodeSink->SetPalette(DecoderColorPalettePtr);
        if (FAILED(hresult)) 
        {
            WARNING(("GpPngDecoder::Decode -- could not set palette"));
            return hresult;
        }
    }

    // Decode the current frame
    hresult = DecodeFrame(imageInfo);

    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Computes the pixel format ID of the bitmap.  If the PNG format is close
*     enough to one of the valid pixel formats, then that format is what this
*     function returns.  If it does not match one of the valid pixel formats,
*     then this function returns PIXFMT_32BPP_ARGB.  Also, if the PNG image
*     is not in an indexed format but has alpha information (i.e., has a tRNS
*     chunk), then we send the data in PIXFMT_32BPP_ARGB.  If the
*     PNG format is not valid, then this function returns PIXFMT_UNDEFINED.*     
*
* Return Value:
*
*     Pixel format ID
*
\**************************************************************************/

PixelFormatID 
GpPngDecoder::GetPixelFormatID(
    void
    )
{
    PixelFormatID pixelFormatID;
    SPNG_U8 bitDepth;
    SPNG_U8 colorType;

    // ASSERT: pGpSpgnRead->FHeader() has been called, which allows
    // us to call BDepth() and ColorType().  pGpSpngRead->FInitRead()
    // has been called, which allows us to access m_ctRNS.
    bitDepth = pGpSpngRead->BDepth();
    colorType = pGpSpngRead->ColorType();
    
    switch (colorType)
    {
    case 0: 
        // grayscale
        pixelFormatID = PIXFMT_32BPP_ARGB;
        break;

    case 2:
        // RGB
        switch (bitDepth)
        {
        case 8:
            pixelFormatID = PIXFMT_24BPP_RGB;
            break;

        case 16:
            pixelFormatID = PIXFMT_48BPP_RGB;
            break;

        default:
            pixelFormatID = PIXFMT_UNDEFINED;
        }
        break;

    case 3:
        // indexed
        switch (bitDepth)
        {
        case 1:
            pixelFormatID = PIXFMT_1BPP_INDEXED;
            break;

        case 2:
            // not a valid pixel format
            pixelFormatID = PIXFMT_32BPP_ARGB;
            break;

        case 4:
            pixelFormatID = PIXFMT_4BPP_INDEXED;
            break;

        case 8:
            pixelFormatID = PIXFMT_8BPP_INDEXED;
            break;

        default:
            pixelFormatID = PIXFMT_UNDEFINED;
        }
        break;

    case 4:
        // grayscale + alpha
        switch (bitDepth)
        {
        case 8:
        case 16:
            pixelFormatID = PIXFMT_32BPP_ARGB;
            break;

        default:
            pixelFormatID = PIXFMT_UNDEFINED;
        }
        break;

    case 6:
        // grayscale + alpha
        switch (bitDepth)
        {
        case 8:
            pixelFormatID = PIXFMT_32BPP_ARGB;
            break;

        case 16:
            pixelFormatID = PIXFMT_64BPP_ARGB;
            break;

        default:
            pixelFormatID = PIXFMT_UNDEFINED;
        }
        break;

    default:
        // if we can't recognize the PNG format, return PIXFMT_UNDEFINED
        pixelFormatID = PIXFMT_UNDEFINED;
    }

    // In all valid cases check if there is any transparency information. If so,
    // we will transfer data as PIXFMT_32BPP_ARGB.
    
    if ( pixelFormatID != PIXFMT_UNDEFINED )
    {
        if (pGpSpngRead->m_ctRNS > 0)
        {
            // there is a transparency chunk; there could be transparency info
            pixelFormatID = PIXFMT_32BPP_ARGB;
        }
    }

    return pixelFormatID;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     imageInfo -- decoding parameters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::DecodeFrame(
    IN ImageInfo& dstImageInfo
    )
{
    HRESULT hresult;
    RECT currentRect;
    BitmapData bitmapData;

    PixelFormatID srcPixelFormatID = GetPixelFormatID();
    
    currentRect.left = 0;
    currentRect.right = dstImageInfo.Width;

    if ( srcPixelFormatID == PIXFMT_UNDEFINED ) 
    {
        WARNING(("GpPngDecoder:DecodeFrame -- undefined pixel format"));
        return E_FAIL;
    }    

    while (currentLine < dstImageInfo.Height) 
    {
        currentRect.top = currentLine;
        currentRect.bottom = currentLine + 1;

        hresult = decodeSink->GetPixelDataBuffer(&currentRect, 
                                                 dstImageInfo.PixelFormat, 
                                                 TRUE,
                                                 &bitmapData);
        if ( !SUCCEEDED(hresult) || (bitmapData.Scan0 == NULL) )
        {
            return E_FAIL;
        }

        // Read one line from the input image

        SPNG_U8 *pb = const_cast<SPNG_U8 *> (pGpSpngRead->PbRow());
        if ( pb == NULL )
        {
            return E_FAIL;
        }

        if (dstImageInfo.PixelFormat == PIXFMT_32BPP_ARGB)
        {
            // Convert the line to 32 BPP ARGB format.            
            ConvertPNGLineTo32ARGB (pb, &bitmapData);
        }
        else if (dstImageInfo.PixelFormat & PIXFMTFLAG_INDEXED)
        {
            ASSERT ((dstImageInfo.PixelFormat == PIXFMT_1BPP_INDEXED) ||
                    (dstImageInfo.PixelFormat == PIXFMT_4BPP_INDEXED) ||
                    (dstImageInfo.PixelFormat == PIXFMT_8BPP_INDEXED))

            UINT cbScanline = bitmapData.Width;
            // Compute the number of bytes in the scanline of the PNG image
            // (For PIXFMT_8BPP_INDEXED, the scanline stride equals the width.)
            if (dstImageInfo.PixelFormat == PIXFMT_4BPP_INDEXED)
            {
                cbScanline = (cbScanline + 1) / 2;
            }
            else if (dstImageInfo.PixelFormat == PIXFMT_1BPP_INDEXED)
            {
                cbScanline = (cbScanline + 7) >> 3;
            }

            GpMemcpy (bitmapData.Scan0, pb, cbScanline);
        }
        else if (dstImageInfo.PixelFormat == PIXFMT_24BPP_RGB)
        {
            ConvertPNG24RGBTo24RGB(pb, &bitmapData);
        }
        else if (dstImageInfo.PixelFormat == PIXFMT_48BPP_RGB)
        {
            ConvertPNG48RGBTo48RGB(pb, &bitmapData);
        }
        else if (dstImageInfo.PixelFormat == PIXFMT_64BPP_ARGB)
        {
            ConvertPNG64RGBAlphaTo64ARGB(pb, &bitmapData);
        }
        else
        {
            WARNING(("GpPngDecoder::DecodeFrame -- unexpected pixel data format")); 
            return E_FAIL;
        }

        hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            WARNING(("GpPngDecoder::DecodeFrame -- ReleasePixelDataBuffer failed")); 
            return E_FAIL;
        }

        currentLine++;
    }
        
    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Depending on the Color Type of the PNG data, convert the
*     data in pb to 32bpp ARGB format and place the result in bitmapData.
*
* Arguments:
*
*     pb -- data from the PNG file
*     bitmapData -- output data (32bpp ARGB format)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertPNGLineTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    HRESULT hresult;
    SPNG_U8 const ColorType = pGpSpngRead->ColorType();
    
    switch (ColorType)
    {
    case 0:
        hresult = ConvertGrayscaleTo32ARGB (pb, bitmapData);
        break;

    case 2:
        hresult = ConvertRGBTo32ARGB (pb, bitmapData);
        break;

    case 3:
        hresult = ConvertPaletteIndexTo32ARGB (pb, bitmapData);
        break;

    case 4:
        hresult = ConvertGrayscaleAlphaTo32ARGB (pb, bitmapData);
        break;

    case 6:
        hresult = ConvertRGBAlphaTo32ARGB (pb, bitmapData);
        break;

    default:
        WARNING (("Unknown color type for PNG (%d).", ColorType));
        hresult = E_FAIL;
    }

    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpPngCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that PNG is an one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpPngCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID -- GUID for the dimension requested
*     count -- number of frames in that dimension of the current image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        return E_INVALIDARG;
    }
    
    *count = 1;
    
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if ( (dimensionID == NULL) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpPngDecoder::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    if ( frameIndex > 1 )
    {
        // PNG is a single frame image format

        WARNING(("GpPngDecoder::SelectActiveFrame--Invalid frame index"));
        return E_INVALIDARG;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpPngDecoder::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
* Conversion Routines
\**************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Convert from grayscale data to 32-bit ARGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertGrayscaleTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    SPNG_U8 BitDepth = pGpSpngRead->BDepth();
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    BYTE currentPixel = 0;  // data bit(s) of the current pixel
    BOOL hasAlpha = FALSE;  // whether or not there is potential alpha information
    BYTE alpha255 = 0xff;
    BYTE alpha0value = 0;   // greyscale value of the pixel that will have alpha=0
    WORD alpha0value16 = 0; // as alpha0value, except for 16-bit depth
    BYTE rgbValue = 0;
    UINT i = 0;
    UINT j = 0;

    hasAlpha = (pGpSpngRead->m_ctRNS > 0);
    switch(BitDepth)
    {
    case 1:
        // the least significant bit of the first 2 bytes of the tRNS chunk
        alpha0value = pGpSpngRead->m_btRNS[1] & 0x01;
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x7;
            currentPixel = ((*pbTemp) & (0x1 << (7 - j)));
            rgbValue = (currentPixel) ? 0xff : 0;

            *(Scan0Temp + 3) = (hasAlpha && (currentPixel == alpha0value)) ? 0 : alpha255;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp)= rgbValue;
            Scan0Temp += 4;

            if (j == 7)
            {
                pbTemp++;
            }
        }
        break;

    case 2:
        // the least significant 2 bits of the first 2 bytes of the tRNS chunk
        alpha0value = pGpSpngRead->m_btRNS[1] & 0x03;
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x3;
            currentPixel = ((*pbTemp) & (0x3 << (6 - 2*j))) >> (6 - 2*j);
            rgbValue = (currentPixel |
                (currentPixel << 2) |
                (currentPixel << 4) |
                (currentPixel << 6));

            *(Scan0Temp + 3) = (hasAlpha && (currentPixel == alpha0value)) ? 0 : alpha255;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp)= rgbValue;
            Scan0Temp += 4;

            if (j == 3)
            {
                pbTemp++;
            }
        }
        break;

    case 4:
        // the least significant 4 bits of the first 2 bytes of the tRNS chunk
        alpha0value = pGpSpngRead->m_btRNS[1] & 0x0f;
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x1;
            currentPixel = ((*pbTemp) & (0xf << (4 - 4*j))) >> (4 - 4*j);
            rgbValue = (currentPixel | (currentPixel << 4));

            *(Scan0Temp + 3) = (hasAlpha && (currentPixel == alpha0value)) ? 0 : alpha255;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp)= rgbValue;
            Scan0Temp += 4;

            if (j == 1)
            {
                pbTemp++;
            }
        }
        break;

    case 8:
       // the least significant 8 bits of the first 2 bytes of the tRNS chunk
       alpha0value = pGpSpngRead->m_btRNS[1];
       for (i = 0; i < Width; i++)
       {
            rgbValue = *pbTemp;

            *(Scan0Temp + 3) = (hasAlpha && (rgbValue == alpha0value)) ? 0 : alpha255;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp)= rgbValue;
            Scan0Temp += 4;

            pbTemp++;
        }
        break;

    case 16:
        alpha0value16 = pGpSpngRead->m_btRNS[0];
        for (i = 0; i < Width; i++)
        {
            rgbValue = *pbTemp;

            *(Scan0Temp + 3) = (hasAlpha && (rgbValue == alpha0value16)) ? 0 : alpha255;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp)= rgbValue;
            Scan0Temp += 4;

            pbTemp += 2;  // ignore low-order bits of the grayscale value
        }
        break;

    default:
        WARNING (("Unknown bit depth (d%) for color type 0", BitDepth));
        return E_FAIL;
        break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert from RGB data to 32-bit ARGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertRGBTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    SPNG_U8 BitDepth = pGpSpngRead->BDepth();
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    BYTE alpha255 = 0xff;
    BOOL hasAlpha = FALSE;  // whether or not there is potential alpha information
    
    // Color values for which alpha=0; "16" suffix is for 16-bit depth
    BYTE alpha0red = 0;
    BYTE alpha0green = 0;
    BYTE alpha0blue = 0;
    WORD alpha0red16 = 0;
    WORD alpha0green16 = 0;
    WORD alpha0blue16 = 0;

    UINT i = 0;

    hasAlpha = (pGpSpngRead->m_ctRNS > 0);
    switch(BitDepth)
    {
    case 8:
        // Ignore high-order byte of each 2-byte value
        alpha0red = pGpSpngRead->m_btRNS[1];
        alpha0green = pGpSpngRead->m_btRNS[3];
        alpha0blue = pGpSpngRead->m_btRNS[5];
        for (i = 0; i < Width; i++)
        {
            *(Scan0Temp + 3) = (hasAlpha &&
                                (alpha0red   == *pbTemp) &&
                                (alpha0green == *(pbTemp+1)) &&
                                (alpha0blue  == *(pbTemp+2))) ? 0 : alpha255;
            // Copy next three bytes from pb
            *(Scan0Temp + 2) = *pbTemp;
            pbTemp++;
            *(Scan0Temp + 1) = *pbTemp;
            pbTemp++;
            *(Scan0Temp)= *pbTemp;
            pbTemp++;
            Scan0Temp += 4;
        }
        break;

    case 16:
        alpha0red16 = pGpSpngRead->m_btRNS[0];
        alpha0green16 = pGpSpngRead->m_btRNS[2];
        alpha0blue16 = pGpSpngRead->m_btRNS[4];
        for (i = 0; i < Width; i++)
        {
            *(Scan0Temp + 3) = (hasAlpha &&
                                (alpha0red16   == *pbTemp) &&
                                (alpha0green16 == *(pbTemp+2)) &&
                                (alpha0blue16  == *(pbTemp+4))) ? 0 : alpha255;
            // Copy next three bytes from pb
            *(Scan0Temp + 2) = *pbTemp;
            pbTemp += 2;  // ignore low-order bits of color value
            *(Scan0Temp + 1) = *pbTemp;
            pbTemp += 2;
            *(Scan0Temp)= *pbTemp;
            pbTemp += 2;
            Scan0Temp += 4;
        }
        break;

    default:
        WARNING (("Unknown bit depth (%d) for color type 2", BitDepth));
        return E_FAIL;
        break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert from palette index data to 32-bit ARGB data.
*   See PNG specification for an explanation of the layout of
*   the data that pb points to.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertPaletteIndexTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    SPNG_U8 BitDepth = pGpSpngRead->BDepth();
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    int cEntries = 0;
    UINT ucEntries = 0;
    SPNG_U8 *pbPaletteTemp = const_cast<SPNG_U8 *> (pGpSpngRead->PbPalette(cEntries));
    BYTE alpha255 = 0xff;
    BOOL hasAlpha = FALSE;  // whether or not there is potential alpha information
    BYTE alpha = 0;
    UINT i = 0;
    UINT j = 0;
    UINT currentPixel = 0;

    if (cEntries > 0)
    {
        ucEntries = cEntries;
    }

    hasAlpha = (pGpSpngRead->m_ctRNS > 0);
    switch(BitDepth)
    {
    case 1:
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x7;
            currentPixel = ((*pbTemp) & (0x1 << (7 - j))) >> (7 - j);
            if (currentPixel >= ucEntries)
            {
                // According to the spec, this is an error condition, but
                // IE handles this by giving a black pixel.
                *(Scan0Temp + 3) = alpha255;
                *(Scan0Temp + 2) = 0;
                *(Scan0Temp + 1) = 0;
                *(Scan0Temp) = 0;
                Scan0Temp += 4;
               
                // This is what this case should look like:
                // WARNING (("Not enough palette entries."));
                // return E_FAIL;
            }
            else
            {
                alpha = ((!hasAlpha) || (currentPixel >= (UINT)pGpSpngRead->m_ctRNS)) ?
                    alpha255 : pGpSpngRead->m_btRNS[currentPixel];
                *(Scan0Temp + 3) = alpha;
                *(Scan0Temp + 2) = pbPaletteTemp [3 * currentPixel];
                *(Scan0Temp + 1) = pbPaletteTemp [3 * currentPixel + 1];
                *(Scan0Temp) = pbPaletteTemp [3 * currentPixel + 2];
                Scan0Temp += 4;
            }
            if (j == 7)
            {
                pbTemp++;
            }
        }
        break;

    case 2:
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x3;
            currentPixel = ((*pbTemp) & (0x3 << (6 - 2*j))) >> (6 - 2*j);
            if (currentPixel >= ucEntries)
            {
                // According to the spec, this is an error condition, but
                // IE handles this by giving a black pixel.
                *(Scan0Temp + 3) = alpha255;
                *(Scan0Temp + 2) = 0;
                *(Scan0Temp + 1) = 0;
                *(Scan0Temp) = 0;
                Scan0Temp += 4;
               
                // This is what this case should look like:
                // WARNING (("Not enough palette entries."));
                // return E_FAIL;
            }
            else
            {
                alpha = ((!hasAlpha) || (currentPixel >= (UINT)pGpSpngRead->m_ctRNS)) ?
                    alpha255 : pGpSpngRead->m_btRNS[currentPixel];
                *(Scan0Temp + 3) = alpha;
                *(Scan0Temp + 2) = pbPaletteTemp [3 * currentPixel];
                *(Scan0Temp + 1) = pbPaletteTemp [3 * currentPixel + 1];
                *(Scan0Temp) = pbPaletteTemp [3 * currentPixel + 2];
                Scan0Temp += 4;
            }
            if (j == 3)
            {
                pbTemp++;
            }
        }
        break;

    case 4:
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            j = j & 0x1;
            currentPixel = ((*pbTemp) & (0xf << (4 - 4*j))) >> (4 - 4*j);
            if (currentPixel >= ucEntries)
            {
                // According to the spec, this is an error condition, but
                // IE handles this by giving a black pixel.
                *(Scan0Temp + 3) = alpha255;
                *(Scan0Temp + 2) = 0;
                *(Scan0Temp + 1) = 0;
                *(Scan0Temp) = 0;
                Scan0Temp += 4;
               
                // This is what this case should look like:
                // WARNING (("Not enough palette entries."));
                // return E_FAIL;
            }
            else
            {
                alpha = ((!hasAlpha) || (currentPixel >= (UINT)pGpSpngRead->m_ctRNS)) ?
                   alpha255 : pGpSpngRead->m_btRNS[currentPixel];
                *(Scan0Temp + 3) = alpha;
                *(Scan0Temp + 2) = pbPaletteTemp [3 * currentPixel];
                *(Scan0Temp + 1) = pbPaletteTemp [3 * currentPixel + 1];
                *(Scan0Temp) = pbPaletteTemp [3 * currentPixel + 2];
                Scan0Temp += 4;
            }
            if (j == 1)
            {
                pbTemp++;
            }
        }
        break;

    case 8:
        for (i = 0, j = 0; i < Width; i++, j++)
        {
            currentPixel = *pbTemp;
            if (currentPixel >= ucEntries)
            {
                // According to the spec, this is an error condition, but
                // IE handles this by giving a black pixel.
                *(Scan0Temp + 3) = alpha255;
                *(Scan0Temp + 2) = 0;
                *(Scan0Temp + 1) = 0;
                *(Scan0Temp) = 0;
                Scan0Temp += 4;
               
                // This is what this case should look like:
                // WARNING (("Not enough palette entries."));
                // return E_FAIL;
            }
            else
            {
                alpha = ((!hasAlpha) || (currentPixel >= (UINT)pGpSpngRead->m_ctRNS)) ?
                    alpha255 : pGpSpngRead->m_btRNS[currentPixel];
                *(Scan0Temp + 3) = alpha;
                *(Scan0Temp + 2) = pbPaletteTemp [3 * currentPixel];
                *(Scan0Temp + 1) = pbPaletteTemp [3 * currentPixel + 1];
                *(Scan0Temp) = pbPaletteTemp [3 * currentPixel + 2];
                Scan0Temp += 4;
            }
            pbTemp++;

        }
        break;

    default:
        WARNING (("Unknown bit depth (d%) for color type 3", BitDepth));
        return E_FAIL;
        break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert from grayscale + alpha data to 32-bit ARGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertGrayscaleAlphaTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    SPNG_U8 BitDepth = pGpSpngRead->BDepth();
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    BYTE alpha = 0;
    BYTE rgbValue = 0;
    UINT i = 0;

    switch(BitDepth)
    {
    case 8:
        for (i = 0; i < Width; i++)
        {
            rgbValue = *pbTemp;
            pbTemp++;
            alpha = *pbTemp;
            pbTemp++;
            *(Scan0Temp + 3) = alpha;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp) = rgbValue;
            Scan0Temp += 4;
        }
        break;

    case 16:
        for (i = 0; i < Width; i++)
        {
            rgbValue = *pbTemp;
            pbTemp += 2;    // ignore low-order bits
            alpha = *pbTemp;
            pbTemp += 2;    // ignore low-order bits
            *(Scan0Temp + 3) = alpha;
            *(Scan0Temp + 2) = rgbValue;
            *(Scan0Temp + 1) = rgbValue;
            *(Scan0Temp) = rgbValue;
            Scan0Temp += 4;
        }
        break;

    default:
        WARNING (("Unknown bit depth (d%) for color type 4", BitDepth));
        return E_FAIL;
        break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert from RGB data + alpha to 32-bit ARGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertRGBAlphaTo32ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    SPNG_U8 BitDepth = pGpSpngRead->BDepth();
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    UINT i = 0;

    switch(BitDepth)
    {
    case 8:
        for (i = 0; i < Width; i++)
        {
            *(Scan0Temp + 2) = *pbTemp;
            pbTemp++;
            *(Scan0Temp + 1) = *pbTemp;
            pbTemp++;
            *(Scan0Temp) = *pbTemp;
            pbTemp++;
            *(Scan0Temp + 3) = *pbTemp;     // alpha value
            pbTemp++;
            Scan0Temp += 4;
        }
        break;

    case 16:
        // This code assumes that the format is sRGB - i.e. the gAMA chunk
        // is (1/2.2).

        for (i = 0; i < Width; i++)
        {
            *(Scan0Temp + 2) = *pbTemp; // R
            pbTemp += 2;
            *(Scan0Temp + 1) = *pbTemp; // G
            pbTemp += 2;
            *(Scan0Temp) = *pbTemp;     // B
            pbTemp += 2;
            *(Scan0Temp + 3) = *pbTemp; // A
            pbTemp += 2;
            Scan0Temp += 4;
        }
        break;

    default:
        WARNING (("Unknown bit depth (d%) for color type 6", BitDepth));
        return E_FAIL;
        break;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert from PNG 24bpp RGB (which is really BGR) data to 24-bit RGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertPNG24RGBTo24RGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    UINT Width = bitmapData->Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *Scan0Temp = static_cast<BYTE *> (bitmapData->Scan0);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(Scan0Temp + 2) = *pbTemp;
        pbTemp++;
        *(Scan0Temp + 1) = *pbTemp;
        pbTemp++;
        *(Scan0Temp) = *pbTemp;
        pbTemp++;
        Scan0Temp += 3;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a color channel (a, r, g or b) from PNG's 16-bit format
*   to sRGB64's format. Assumes the PNG format has linear gamma.
*
* Arguments:
*
*   x - channel to convert
*
* Return Value:
*
*   sRGB64 result
*
\**************************************************************************/
static inline UINT16 
ConvertChannel_PngTosRGB64(
    UINT16 x
    )
{
    INT swapped = ((x & 0xff) << 8) + ((x & 0xff00) >> 8);
    return (swapped * SRGB_ONE + 0x7fff) / 0xffff;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert from PNG 48bpp RGB (which is really BGR) to 48-bit RGB data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Notes:
*
*   This code assumes that the gAMA chunk doesn't exist (gamma is 1.0).
*   The destination format is the 48bpp version of sRGB64.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP
GpPngDecoder::ConvertPNG48RGBTo48RGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    UINT Width = bitmapData->Width;
    UNALIGNED UINT16 *pbTemp = reinterpret_cast<UINT16 *> (pb);

    UNALIGNED INT16 *Scan0Temp = static_cast<INT16 *> (bitmapData->Scan0);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(Scan0Temp + 2) = ConvertChannel_PngTosRGB64(*pbTemp++); // R
        *(Scan0Temp + 1) = ConvertChannel_PngTosRGB64(*pbTemp++); // G
        *(Scan0Temp + 0) = ConvertChannel_PngTosRGB64(*pbTemp++); // B
        
        Scan0Temp += 3;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert from PNG 64bpp RGB data + alpha to sRGB64 data.
*
* Arguments:
*
*   pb - pointer to the data
*   bitmapData - pointer to the converted data
*
* Notes:
*
*   This code assumes that the gAMA chunk doesn't exist (gamma is 1.0).
*   The destination format is sRGB64.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::ConvertPNG64RGBAlphaTo64ARGB(
    IN SPNG_U8 *pb,
    OUT BitmapData *bitmapData
    )
{
    UINT Width = bitmapData->Width;
    UNALIGNED UINT16 *pbTemp = reinterpret_cast<UINT16 *> (pb);

    UNALIGNED INT16 *Scan0Temp = static_cast<INT16 *> (bitmapData->Scan0);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(Scan0Temp + 2) = ConvertChannel_PngTosRGB64(*pbTemp++); // R
        *(Scan0Temp + 1) = ConvertChannel_PngTosRGB64(*pbTemp++); // G
        *(Scan0Temp + 0) = ConvertChannel_PngTosRGB64(*pbTemp++); // B
        *(Scan0Temp + 3) = ConvertChannel_PngTosRGB64(*pbTemp++); // A

        Scan0Temp += 4;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Pass property items from current image to the sink.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngDecoder::PassPropertyToSink(
    )
{
    HRESULT     hResult = S_OK;

    // If current image has property items. Then we need to check if the sink
    // needs property stuff or not. If YES, push it
    // Note: for a memory sink, it should return E_FAIL or E_NOTIMPL

    if ((PropertyNumOfItems > 0) && (decodeSink->NeedRawProperty(NULL) == S_OK))
    {
        if ( HasProcessedPropertyItem == FALSE )
        {
            // If we haven't built the internal property item list, build it

            hResult = BuildPropertyItemList();
            if ( FAILED(hResult) )
            {
                WARNING(("PNG::PassPropertyToSink-BuildPropertyItemList fail"));
                goto Done;
            }
        }

        UINT    uiTotalBufferSize = PropertyListSize
                                  + PropertyNumOfItems * sizeof(PropertyItem);
        PropertyItem*   pBuffer = NULL;

        hResult = decodeSink->GetPropertyBuffer(uiTotalBufferSize, &pBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("Png::PassPropertyToSink---GetPropertyBuffer() failed"));
            goto Done;
        }

        hResult = GetAllPropertyItems(uiTotalBufferSize,
                                      PropertyNumOfItems, pBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("Png::PassPropertyToSink-GetAllPropertyItems failed"));
            goto Done;
        }

        hResult = decodeSink->PushPropertyItems(PropertyNumOfItems,
                                                uiTotalBufferSize, pBuffer,
                                                FALSE   // No ICC change
                                                );

        if ( FAILED(hResult) )
        {
            WARNING(("Png::PassPropertyToSink---PushPropertyItems() failed"));
            goto Done;
        }
    }// If the sink needs raw property

Done:
    return hResult;
}// PassPropertyToSink()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngencoder.cpp
*
* Abstract:
*
*   Implementation of the PNG filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*  (IImageSink).
*
* Revision History:
*
*   7/20/99 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "pngcodec.hpp"
#include "libpng\spngwrite.h"


/**************************************************************************\
*
* Function Description:
*
*     Error handling for the BITMAPSITE object
*
* Arguments:
*
*     fatal -- is the error fatal?
*     icase -- what kind of error
*     iarg  -- what kind of error
*
* Return Value:
*
*   boolean: should processing stop?
*
\**************************************************************************/
bool
GpPngEncoder::FReport (
    IN bool fatal,
    IN int icase,
    IN int iarg) const
{
    return fatal;
}

// =======================================================================
// IImageEncoder methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
STDMETHODIMP
GpPngEncoder::InitEncoder(
    IN IStream* stream
    )
{
    // Make sure we haven't been initialized already

    if (pIoutStream)
    {
        return E_FAIL;
    }

    bHasSetPixelFormat = FALSE;
    RequiredPixelFormat = PIXFMT_32BPP_ARGB;    // we really don't need to initialize
    bRequiredScanMethod = false;    // by default, we do not interlace

    // Keep a reference on the input stream

    stream->AddRef();
    pIoutStream = stream;

    bValidSpngWriteState = FALSE;
    pSpngWrite = NULL;
    
    // Porperty related stuff

    CommentBufPtr = NULL;
    ImageTitleBufPtr = NULL;
    ArtistBufPtr = NULL;
    CopyRightBufPtr = NULL;
    ImageDescriptionBufPtr = NULL;
    DateTimeBufPtr = NULL;
    SoftwareUsedBufPtr = NULL;
    EquipModelBufPtr = NULL;
    ICCNameBufPtr = 0;
    ICCDataLength = 0;
    ICCDataBufPtr = NULL;
    GammaValue = 0;
    HasChrmChunk = FALSE;
    GpMemset(CHRM, 0, k_ChromaticityTableLength * sizeof(SPNG_U32));
    HasSetLastModifyTime = FALSE;

    return S_OK;
}
        
/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::TerminateEncoder()
{
    // Free the color palette
    if (EncoderColorPalettePtr)
    {
        GpFree (EncoderColorPalettePtr);
        EncoderColorPalettePtr = NULL;
    }

    // Release the input stream
    if (pIoutStream)
    {
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    // Property related stuff

    if ( CommentBufPtr != NULL )
    {
        GpFree(CommentBufPtr);
        CommentBufPtr = NULL;
    }

    if ( ImageTitleBufPtr != NULL )
    {
        GpFree(ImageTitleBufPtr);
        ImageTitleBufPtr = NULL;
    }
    
    if ( ArtistBufPtr != NULL )
    {
        GpFree(ArtistBufPtr);
        ArtistBufPtr = NULL;
    }
    
    if ( CopyRightBufPtr != NULL )
    {
        GpFree(CopyRightBufPtr);
        CopyRightBufPtr = NULL;
    }
    
    if ( ImageDescriptionBufPtr != NULL )
    {
        GpFree(ImageDescriptionBufPtr);
        ImageDescriptionBufPtr = NULL;
    }
    
    if ( DateTimeBufPtr != NULL )
    {
        GpFree(DateTimeBufPtr);
        DateTimeBufPtr = NULL;
    }
    
    if ( SoftwareUsedBufPtr != NULL )
    {
        GpFree(SoftwareUsedBufPtr);
        SoftwareUsedBufPtr = NULL;
    }
    
    if ( EquipModelBufPtr != NULL )
    {
        GpFree(EquipModelBufPtr);
        EquipModelBufPtr = NULL;
    }
    
    if ( ICCDataBufPtr != NULL )
    {
        GpFree(ICCDataBufPtr);
        ICCDataBufPtr = NULL;
    }

    if ( ICCNameBufPtr != NULL )
    {
        GpFree(ICCNameBufPtr);
        ICCNameBufPtr = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    if ((dimensionID == NULL) ||  (*dimensionID != FRAMEDIM_PAGE))
    {
        return E_FAIL;
    }
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   This method is used for querying encoder parameters. It must be called
*   before GetEncodeSink().
*
*   Here is the interpretation of the color depth parameter, B, for the purposes
*   of saving the image in a PNG format:
*   for B=1,4,8, we will save the image as color type 3 with bit depth B.
*   for B=24,48, we will save the image as color type 2 with bit depth B/3.
*   for B=32,64, we will save the image as color type 6 with bit depth 8.
*
* Arguments:
*
*   count -  Specifies the number of "EncoderParam" structure to be returned
*   Params - A pointer to a list of "EncoderParam" which we support
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpPngEncoder::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterListSize()

HRESULT
GpPngEncoder::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterList()

HRESULT
GpPngEncoder::SetEncoderParameters(
    IN const EncoderParameters* Param
    )
{
    return E_NOTIMPL;
}// SetEncoderParameters()

// =======================================================================
// IImageSink methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpPngEncoder::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{

    // Initialize variables
    lastBufferAllocated = NULL;
    pbWriteBuffer = NULL;
    cbWriteBuffer = 0;

    //Require TOPDOWN and FULLWIDTH
    imageInfo->Flags = imageInfo->Flags | SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    imageInfo->Flags = imageInfo->Flags & ~SINKFLAG_SCALABLE & ~SINKFLAG_PARTIALLY_SCALABLE & ~SINKFLAG_MULTIPASS & ~SINKFLAG_COMPOSITE;

    //   Tell the source that we prefer to the get the format as the caller
    // required format if the caller has set the format through
    // SetEncoderParam().  We assume that if the caller has called SetEncoderParam(),
    // then RequiredPixelFormat contains a format that the encoder can handle (i.e.,
    // any bad input to SetEncoderParam() was rejected).
    //   If SetEncoderParam() has not been called, then we don't need to modify
    // the source format if it is a format the encoder can handle.  However,
    // if the format is one that the encoder cannot handle, then BeginSink() will
    // return a format that the encoder can handle.
    //   Note: When the source calls PushPixelData() or GetPixelDataBuffer(), it
    // can either supply pixel data in the format asked by us (in BeginSink()),
    // or it can supply pixel data in one of the canonical pixel formats.

    if (bHasSetPixelFormat == TRUE)
    {
        imageInfo->PixelFormat = RequiredPixelFormat;
    }

    switch (imageInfo->PixelFormat)
    {
    case PIXFMT_1BPP_INDEXED:
        
        if (bHasSetPixelFormat == FALSE)
        {
            RequiredPixelFormat = PIXFMT_1BPP_INDEXED;
        }
        
        break;

    case PIXFMT_4BPP_INDEXED:

        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_4BPP_INDEXED;
        }

        break;

    case PIXFMT_8BPP_INDEXED:
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_8BPP_INDEXED;
        }

        break;

    case PIXFMT_16BPP_GRAYSCALE:
    case PIXFMT_16BPP_RGB555:
    case PIXFMT_16BPP_RGB565:
    case PIXFMT_16BPP_ARGB1555:
        
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_32BPP_ARGB;
        }

        break;

    case PIXFMT_24BPP_RGB:
        
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_24BPP_RGB;
        }

        break;

    case PIXFMT_32BPP_RGB:
    case PIXFMT_32BPP_ARGB:
    case PIXFMT_32BPP_PARGB:
        
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_32BPP_ARGB;
        }

        break;

    case PIXFMT_48BPP_RGB:
        
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_48BPP_RGB;
        }

        break;

    case PIXFMT_64BPP_ARGB:
    case PIXFMT_64BPP_PARGB:
        
        if (bHasSetPixelFormat == FALSE)
        {        
            RequiredPixelFormat = PIXFMT_64BPP_ARGB;
        }

        break;

    default:
        
        // Unknown pixel format
        WARNING(("GpPngEncoder::BeginSink -- Bad pixel format: failing negotiation.\n"));
        return E_FAIL;
    }

    // ASSERT: At this point, RequiredPixelFormat contains the format returned
    // to the caller, and it is a format that the encoder can handle.
    ASSERT((RequiredPixelFormat == PIXFMT_1BPP_INDEXED) || \
           (RequiredPixelFormat == PIXFMT_4BPP_INDEXED) || \
           (RequiredPixelFormat == PIXFMT_8BPP_INDEXED) || \
           (RequiredPixelFormat == PIXFMT_24BPP_RGB)    || \
           (RequiredPixelFormat == PIXFMT_32BPP_ARGB)   || \
           (RequiredPixelFormat == PIXFMT_48BPP_RGB)    || \
           (RequiredPixelFormat == PIXFMT_64BPP_ARGB))

    imageInfo->PixelFormat = RequiredPixelFormat;

    // remember the image info that we return
    encoderImageInfo = *imageInfo;
    
    if (subarea) 
    {
        // Deliver the whole image to the encoder

        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    // Initialize GpSpngWrite object
    pSpngWrite = new GpSpngWrite(*this);
    if (!pSpngWrite)
    {
        WARNING(("GpPngEncoder::Begin sink -- could not create GpSpngWrite"));
        return E_FAIL;
    }

    // Set the IoutStream to start writing at the beginning of the stream
    LARGE_INTEGER liZero;

    liZero.LowPart = 0;
    liZero.HighPart = 0;
    liZero.QuadPart = 0;

    HRESULT hresult = pIoutStream->Seek(liZero, STREAM_SEEK_SET, NULL);
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the sink state
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpPngEncoder::EndSink(
    IN HRESULT statusCode
    )
{
    HRESULT hResult = S_OK;
    
    if (pSpngWrite)
    {
        // If anything is in the output buffer, write it out
        if (!pSpngWrite->FEndImage())
        {
            // Write out failed. Maybe disk full or something else happened

            WARNING(("GpPngEncoder::EndSink -- call to SPNGWRITE->FEndImage() failed\n"));
            hResult = E_FAIL;
        }
        if (!pSpngWrite->FEndWrite())
        {
            // Write out failed. Maybe disk full or something else happened
            
            WARNING(("GpPngEncoder::EndSink -- final flushing of output failed\n"));
            hResult = E_FAIL;
        }
        // Clean up the SPNGWRITE object
        if (pbWriteBuffer)
        {
            GpFree (pbWriteBuffer);
        }
        delete pSpngWrite;
        pSpngWrite = NULL;
    }

    if (FAILED(hResult)) 
    {
        return hResult;
    }
    
    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpPngEncoder::SetPalette(
    IN const ColorPalette* palette
    )
{
    // Free the old palette first

    if (EncoderColorPalettePtr != NULL)
    {
        // Free the old color palette

        GpFree(EncoderColorPalettePtr);
    }
    
    EncoderColorPalettePtr = static_cast<ColorPalette *>
        (GpMalloc(sizeof(ColorPalette) + palette->Count * sizeof(ARGB)));

    if (!EncoderColorPalettePtr)
    {
        return E_OUTOFMEMORY;
    }

    EncoderColorPalettePtr->Flags = 0;
    EncoderColorPalettePtr->Count = palette->Count;

    for (int i = 0; i < static_cast<int>(EncoderColorPalettePtr->Count); i++)
    {
        EncoderColorPalettePtr->Entries[i] = palette->Entries[i];
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    HRESULT hresult;
    UINT inputStride;
    
    // Check that the caller passed in the encoder's Required pixel format
    // or one of the canonical formats.
    if ((pixelFormat != encoderImageInfo.PixelFormat) &&
        (!IsCanonicalPixelFormat(pixelFormat)))
    {
        WARNING(("GpPngEncoder::GetPixelDataBuffer -- pixel format is neither required nor canonical.\n"));
        return E_INVALIDARG;
    }

    hresult = WriteHeader(encoderImageInfo.Width, encoderImageInfo.PixelFormat);
    if (!SUCCEEDED(hresult))
    {
        return hresult;
    }
    // We assume that the data is being supplied in multiples of a scanline.
    if ((rect->left != 0) || (rect->right != (LONG) encoderImageInfo.Width)) 
    {
        WARNING(("GpPngEncoder::GetPixelDataBuffer -- must be same width as image\n"));
        return E_INVALIDARG;
    }

    if (!lastPass) 
    {
        WARNING(("GpPngEncoder::GetPixelDataBuffer -- must receive last pass pixels\n"));
        return E_INVALIDARG;
    }

    // Need to compute the bitmapData->Stride here, based on the pixel format.
    inputStride = encoderImageInfo.Width;  // we'll need to multiply by bpp next

    switch (pixelFormat)
    {
    case PIXFMT_1BPP_INDEXED:
        
        inputStride = ((inputStride + 7) >> 3);
        break;

    case PIXFMT_4BPP_INDEXED:

        inputStride = ((inputStride + 1) >> 1);
        break;

    case PIXFMT_8BPP_INDEXED:
        break;

    case PIXFMT_24BPP_RGB:
                
        inputStride *= 3;
        break;

    case PIXFMT_32BPP_ARGB:
    case PIXFMT_32BPP_PARGB:
        
        inputStride <<= 2;
        break;

    case PIXFMT_48BPP_RGB:
        
        inputStride *= 6;
        break;

    case PIXFMT_64BPP_ARGB:
    case PIXFMT_64BPP_PARGB:
        
        inputStride <<= 3;
        break;

    default:
        
        // Unknown pixel format
        WARNING(("GpPngEncoder::GetPixelDataBuffer -- unknown pixel format.\n"));
        return E_FAIL;
    }

    bitmapData->Width       = encoderImageInfo.Width;
    bitmapData->Height      = rect->bottom - rect->top;
    bitmapData->Stride      = inputStride;
    bitmapData->PixelFormat = pixelFormat;
    bitmapData->Reserved    = 0;
    
    // Remember the rectangle to be encoded

    encoderRect = *rect;
    
    // Now allocate the buffer where the data will go
    
    if (!lastBufferAllocated) 
    {
        lastBufferAllocated = GpMalloc(bitmapData->Stride * bitmapData->Height);
        if (!lastBufferAllocated) 
        {
            return E_OUTOFMEMORY;
        }
        bitmapData->Scan0 = lastBufferAllocated;
    }
    else
    {
        WARNING(("GpPngEncoder::GetPixelDataBuffer -- need to first free buffer obtained in previous call\n"));
        return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::ReleasePixelDataBuffer(
    IN const BitmapData* pSrcBitmapData
    )
{
    HRESULT hresult = S_OK;
    BYTE *pbTempLineBuf = NULL;    // holds a scanline after calling ConvertBitmapData
    BYTE *pbPostConvert = NULL;    // pointer the data after (the potential) call to ConvertBitmapData
    BYTE *pbDestBuf = NULL;        // holds a scanline in the final PNG format
    SPNG_U8 *pbPNG = NULL;         // pointer to final PNG format scanline

    // NOTE: Check to see if the caller changed the pixel format between
    // GetPixelDataBuffer and ReleasePixelDataBuffer.  If so, exit.
    // This check should succeed if the caller called PushPixelData.
    if ((pSrcBitmapData->PixelFormat != encoderImageInfo.PixelFormat) &&
        (!IsCanonicalPixelFormat(pSrcBitmapData->PixelFormat)))
    {
        WARNING(("GpPngEncoder::ReleasePixelDataBuffer -- pixel format changed between Get and Release.\n"));
        hresult = E_INVALIDARG;
        goto cleanup;
    }

    // ASSERT: At this point, OutputStride is set to the number of bytes needed
    // in a scanline for the format we plan to write to.

    pbTempLineBuf = static_cast <BYTE *>(GpMalloc(OutputStride));
    if (!pbTempLineBuf)
    {
        hresult = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    // Allocate another line buffer for RGB->BGR conversion result
    pbDestBuf = static_cast<BYTE *>(GpMalloc(OutputStride));
    if (!pbDestBuf)
    {
        hresult = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    // Write one scanline at a time going from top to bottom.

    INT scanLine;
    for (scanLine = encoderRect.top;
         scanLine < encoderRect.bottom;
         scanLine++)
    {

        // Now buffer the output bits

        BYTE *pLineBits = ((BYTE *) pSrcBitmapData->Scan0) + 
            (scanLine - encoderRect.top) * pSrcBitmapData->Stride;

        // If bitmapData->PixelFormat is different from encoderImageInfo.pixelFormat,
        // then we need to convert the incoming data to a format closer to the format
        // we will actually write with.
        ASSERT (encoderImageInfo.PixelFormat == RequiredPixelFormat);
        if (pSrcBitmapData->PixelFormat != encoderImageInfo.PixelFormat)
        {
            // If the source doesn't provide us with the format we asked for, we
            // have to do a format conversion here before we write out
            // Here "resultBitmapData" is a BitmapData structure which
            // represents the format we are going to write out.
            // "tempSrcBitmapData" is a BitmapData structure which
            // represents the format we got from the source. Call
            // ConvertBitmapData() to do a format conversion.

            BitmapData tempSrcBitmapData;
            BitmapData resultBitmapData;
            
            tempSrcBitmapData.Scan0 = pLineBits;
            tempSrcBitmapData.Width = pSrcBitmapData->Width;
            tempSrcBitmapData.Height = 1;
            tempSrcBitmapData.PixelFormat = pSrcBitmapData->PixelFormat;
            tempSrcBitmapData.Reserved = 0;
            tempSrcBitmapData.Stride = pSrcBitmapData->Stride;

            resultBitmapData.Scan0 = pbTempLineBuf;
            resultBitmapData.Width = pSrcBitmapData->Width;
            resultBitmapData.Height = 1;
            resultBitmapData.PixelFormat = RequiredPixelFormat;
            resultBitmapData.Reserved = 0;
            resultBitmapData.Stride = OutputStride;

            hresult = ConvertBitmapData(&resultBitmapData,
                                        EncoderColorPalettePtr,
                                        &tempSrcBitmapData,
                                        EncoderColorPalettePtr);
            if (!SUCCEEDED(hresult))
            {
                WARNING(("GpPngEncoder::ReleasePixelDataBuffer -- could not convert bitmap data.\n"))
                goto cleanup;
            }

            pbPostConvert = pbTempLineBuf;
        }
        else
        {
            pbPostConvert = pLineBits; 
        }

        // ASSERT: pbPostConvert points to the data in the RequiredPixelFormat.
        // pbPostConvert now points to the data that is almost in the final PNG file
        // format.  At a minimum, the data has the same number of bits per pixel
        // as the final PNG file format.  What's left to do is to convert the data
        // from the format to the PNG format.

        if (RequiredPixelFormat == PIXFMT_24BPP_RGB)
        {
            // For 24BPP_RGB color, we need to do a conversion: RGB->BGR
            // before writing
            Convert24RGBToBGR(pbPostConvert, pbDestBuf);
            pbPNG = pbDestBuf;
        }        
        else if (RequiredPixelFormat == PIXFMT_32BPP_ARGB)
        {
            // For 32BPP_ARGB color, we need to do a conversion: ARGB->ABGR
            // before writing
            Convert32ARGBToAlphaBGR(pbPostConvert, pbDestBuf);
            pbPNG = pbDestBuf;
        }        
        else if (RequiredPixelFormat == PIXFMT_48BPP_RGB)
        {
            // For 48BPP_RGB color, we need to do a conversion: RGB->BGR
            // before writing
            Convert48RGBToBGR(pbPostConvert, pbDestBuf);
            pbPNG = pbDestBuf;
        }        
        else if (RequiredPixelFormat == PIXFMT_64BPP_ARGB)
        {
            // For 64BPP_ARGB color, we need to do a conversion: ARGB->ABGR
            // before writing
            Convert64ARGBToAlphaBGR(pbPostConvert, pbDestBuf);
            pbPNG = pbDestBuf;
        }        
        else
        {
            // no conversion needed; pbPostConvert has the right bits
            pbPNG = pbPostConvert;
        }

        // ASSERT: pbPNG points to the current line of the bitmap image in
        // the desired PNG format (consistent with the color type and bit depth
        // computed in WriteHeader() ).  PNGbpp was set in WriteHeader() to the
        // appropriate value.

        if (!pSpngWrite->FWriteLine(NULL, pbPNG, PNGbpp))
        {
            hresult = E_FAIL;
            goto cleanup;  // make sure we deallocate lastBufferAllocated, if necessary
        }
    }

cleanup:
    // Free the memory buffer, since we're done with it
    // Note: this chunk of memory is allocated by us in GetPixelDataBuffer()

    if (pSrcBitmapData->Scan0 == lastBufferAllocated)
    {
        GpFree(pSrcBitmapData->Scan0);
        lastBufferAllocated = NULL;
    }
    if (pbTempLineBuf)
    {
        GpFree(pbTempLineBuf);
    }
    if (pbDestBuf)
    {
        GpFree(pbDestBuf);
    }
    return hresult;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    HRESULT hresult;

    // Check that the caller passed in either the encoder's Required pixel format
    // or one of the canonical formats.
    if ((bitmapData->PixelFormat != encoderImageInfo.PixelFormat) &&
        (!IsCanonicalPixelFormat(bitmapData->PixelFormat)))
    {
        WARNING(("GpPngEncoder::PushPixelData -- pixel format is neither required nor canonical.\n"));
        return E_INVALIDARG;
    }

    hresult = WriteHeader(bitmapData->Width, encoderImageInfo.PixelFormat);
    if (!SUCCEEDED(hresult))
    {
        return hresult;
    }

    // Remember the rectangle to be encoded
    encoderRect = *rect;

    if (!lastPass) 
    {
        WARNING(("GpPngEncoder::PushPixelData -- must receive last pass pixels\n"));
        return E_INVALIDARG;
    }

    return ReleasePixelDataBuffer(bitmapData);
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the .png stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::PushRawData(
    IN const VOID* buffer, 
    IN UINT bufsize
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a line of 24BPP_RGB bits to BGR (color type 2 in PNG) bits
*
* Arguments:
*
*   pb    - pointer to 24BPP_RGB bits
*   pbPNG - pointer to BGR bits (color type 2, bit depth 8 in PNG)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP GpPngEncoder::Convert24RGBToBGR(IN BYTE *pb,
    OUT VOID *pbPNG)
{
    UINT Width = encoderImageInfo.Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *pbPNGTemp = static_cast<BYTE *> (pbPNG);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(pbPNGTemp + 2) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 1) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp) = *pbTemp;
        pbTemp++;

        pbPNGTemp += 3;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert a line of 32BPP_ARGB bits to ABGR (color type 6 in PNG) bits
*
* Arguments:
*
*   pb    - pointer to 32BPP_ARGB bits
*   pbPNG - pointer to RGB+alpha bits (color type 6, bit depth 8 in PNG)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP GpPngEncoder::Convert32ARGBToAlphaBGR(IN BYTE *pb,
    OUT VOID *pbPNG)
{
    UINT Width = encoderImageInfo.Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *pbPNGTemp = static_cast<BYTE *> (pbPNG);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(pbPNGTemp + 2) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 1) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 3) = *pbTemp;
        pbTemp++;

        pbPNGTemp += 4;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert a line of 48BPP_RGB bits to BGR (color type 2 in PNG) bits
*
* Arguments:
*
*   pb    - pointer to 48BPP_RGB bits
*   pbPNG - pointer to BGR bits (color type 2, bit depth 16 in PNG)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP GpPngEncoder::Convert48RGBToBGR(IN BYTE *pb,
    OUT VOID *pbPNG)
{
    UINT Width = encoderImageInfo.Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *pbPNGTemp = static_cast<BYTE *> (pbPNG);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(pbPNGTemp + 5) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 4) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 3) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 2) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 1) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp) = *pbTemp;
        pbTemp++;

        pbPNGTemp += 6;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert a line of 64BPP_ARGB bits to ABGR (color type 6 in PNG) bits
*
* Arguments:
*
*   pb    - pointer to 64BPP_ARGB bits
*   pbPNG - pointer to RGB+alpha bits (color type 6, bit depth 16 in PNG)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
STDMETHODIMP GpPngEncoder::Convert64ARGBToAlphaBGR(IN BYTE *pb,
    OUT VOID *pbPNG)
{
    UINT Width = encoderImageInfo.Width;
    SPNG_U8 *pbTemp = pb;
    BYTE *pbPNGTemp = static_cast<BYTE *> (pbPNG);
    UINT i = 0;

    for (i = 0; i < Width; i++)
    {
        *(pbPNGTemp + 5) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 4) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 3) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 2) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 1) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 7) = *pbTemp;
        pbTemp++;
        *(pbPNGTemp + 6) = *pbTemp;
        pbTemp++;

        pbPNGTemp += 8;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Write bits from the output buffer to the output stream.
*
* Arguments:
*
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
bool GpPngEncoder::FWrite(const void *pv, size_t cb)
{
    ULONG cbWritten = 0;
    pIoutStream->Write(pv, cb, &cbWritten);
    if (cbWritten != cb)
    {
        WARNING(("GpPngEncoder::FWrite -- could not write all bytes requested\n"));
        return false;
    }
    return true;
}


/**************************************************************************\
*
* Function Description:
*
*   Write the IHDR, sRGB, PLTE, cHRM, and gAMA chunks.
*   Also, write the pHYs chunk.
*
* Arguments:
*   width       -- width of the image (number of pixels in a scanline)
*   pixelFormat -- the format the source has (finally) decided to send
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::WriteHeader(
    IN UINT width,
    IN PixelFormatID pixelFormat
    )
{
    HRESULT hResult = S_OK;

    // Initialize the SPNGWRITE object if we haven't already
    if (!bValidSpngWriteState)
    {
        UINT colorType;
        UINT bitDepth;
        
        // Determine the PNG format to save image as.
        // Need to compute the output stride here (based on the pixel format) for
        // the Office PNG code, which needs a buffer for each scanline.
        OutputStride = width;   // we'll need to multiply by bpp next
        switch (pixelFormat)
        {
        case PIXFMT_1BPP_INDEXED:

            // save as 1bpp indexed
            OutputStride = ((OutputStride + 7) >> 3);
            colorType = 3;
            bitDepth = 1;
            PNGbpp = 1;
            break;

        case PIXFMT_4BPP_INDEXED:

            // save as 4bpp indexed
            OutputStride = ((OutputStride + 1) >> 1);
            colorType = 3;
            bitDepth = 4;
            PNGbpp = 4;
            break;

        case PIXFMT_8BPP_INDEXED:
            // save as 8bpp indexed
            // (OutputStride == width)
            colorType = 3;
            bitDepth = 8;
            PNGbpp = 8;
            break;

        case PIXFMT_24BPP_RGB:

            // save as 24-bit RGB
            OutputStride *= 3;
            colorType = 2;
            bitDepth = 8;
            PNGbpp = 24;
            break;

        case PIXFMT_32BPP_ARGB:
        case PIXFMT_32BPP_PARGB:

            // save as 32-bit ARGB
            OutputStride <<= 2;
            colorType = 6;
            bitDepth = 8;
            PNGbpp = 32;
            break;

        case PIXFMT_48BPP_RGB:

            // save as 48-bit RGB
            OutputStride *= 6;
            colorType = 2;
            bitDepth = 16;
            PNGbpp = 48;
            break;

        case PIXFMT_64BPP_ARGB:
        case PIXFMT_64BPP_PARGB:

            // save as 64-bit ARGB
            OutputStride <<= 3;
            colorType = 6;
            bitDepth = 16;
            PNGbpp = 64;
            break;

        default:

            // Unknown pixel format
            WARNING(("GpPngEncoder::WriteHeader -- bad pixel format.\n"));
            hResult = E_FAIL;
            goto DoneWriting;
        }

        // FInitWrite initializes the SPNGWRITE object and outputs (into a buffer)
        // the IHDR chunk
        if (pSpngWrite->FInitWrite(encoderImageInfo.Width,
                                   encoderImageInfo.Height,
                                   static_cast<SPNG_U8>(bitDepth),
                                   static_cast<SPNG_U8>(colorType),
                                   bRequiredScanMethod))
        {
            // Allocate and initialize the buffer for one line of output
            cbWriteBuffer = pSpngWrite->CbWrite(false, false);
            pbWriteBuffer = static_cast<SPNG_U8 *>(GpMalloc (cbWriteBuffer));
            if (!pbWriteBuffer)
            {
                return E_OUTOFMEMORY;
            }
            if (!pSpngWrite->FSetBuffer(pbWriteBuffer, cbWriteBuffer))
            {
               WARNING(("GpPngEncoder::WriteHeader -- could not set buffer in PNGWRITE object\n"));
               hResult = E_FAIL;
               goto DoneWriting;
            }
        }
        else
        {
            WARNING(("GpPngEncoder::WriteHeader -- could not init writing to SPNGWRITE object\n"));
            hResult = E_FAIL;
            goto DoneWriting;
        }

        // If the source has ICC profile, then write iCCP chunk. Otherwise,
        // Output sRGB, cHRM, and gAMA chunks (FWritesRGB writes the
        // cHRM and gAMA chunks).
        // Note: according to PNG spec sRGB and ICC chunks should not both
        // appear

        if ( ICCDataLength != 0 )
        {
            if ( !pSpngWrite->FWriteiCCP(ICCNameBufPtr, ICCDataBufPtr,
                                         ICCDataLength) )
            {
                WARNING(("GpPngEncoder::WriteHeader--Fail to write ICC chunk"));
                hResult = E_FAIL;
                goto DoneWriting;
            }

            // We don't need ICC data any more, free it now

            GpFree(ICCNameBufPtr);
            ICCNameBufPtr = NULL;

            GpFree(ICCDataBufPtr);
            ICCDataBufPtr = NULL;
        }
        else if ( (GammaValue != 0) || (HasChrmChunk == TRUE) )
        {
            // According to PNG spec, if you have either gamma or CHRM chunk,
            // then you have to write them out and NOT write out sRGB chunk
            // This is the reason we do the IF check like this here

            if ( GammaValue != 0 )
            {
                if ( !pSpngWrite->FWritegAMA(GammaValue) )
                {
                    WARNING(("Png::WriteHeader-Fail to write gamma chunk"));
                    hResult = E_FAIL;
                    goto DoneWriting;
                }
            }
            
            if ( HasChrmChunk == TRUE )
            {
                if ( !pSpngWrite->FWritecHRM(CHRM) )
                {
                    WARNING(("Png::WriteHeader-Fail to write CHRM chunk"));
                    hResult = E_FAIL;
                    goto DoneWriting;
                }
            }
        }
        else if (!pSpngWrite->FWritesRGB (ICMIntentPerceptual, true))
        {
            // No ICC, gamma and CHRM, then we have to write sRGB chunk out

            WARNING(("GpPngEncoder::WriteHeader--could not write sRGB chunk"));
            hResult = E_FAIL;
            goto DoneWriting;
        }

        // Write the PLTE chunk if the colorType could have one and we have one.
        if ((colorType == 3) || (colorType == 2) || (colorType == 6))
        {
            if (EncoderColorPalettePtr)
            {
                // now we can write the PLTE chunk
                SPNG_U8 (*tempPalette)[3] = NULL;   // equivalent to SPNG_U8 tempPalette[][3]
                SPNG_U8 *tempAlpha = NULL;  // hold alpha values for each palette index
                BOOL bTempAlpha = FALSE;    // tells whether there is a non-255 alpha value
                                            // in any of the palette entries
                BOOL bAlpha0 = FALSE;       // true if there is an index with alpha == 0
                SPNG_U8 iAlpha0 = 0;        // the first index with alpha == 0

                tempPalette = static_cast<SPNG_U8 (*)[3]>(GpMalloc (EncoderColorPalettePtr->Count * 3));
                if (!tempPalette)
                {
                    WARNING(("GpPngEncoder::WriteHeader -- can't allocate temp palette.\n"));
                    hResult = E_OUTOFMEMORY;
                    goto DoneWriting;
                }
                // copy RGB info from EncoderColorPalettePtr to tempPalette
                tempAlpha = static_cast<SPNG_U8 *>(GpMalloc (EncoderColorPalettePtr->Count));
                if (!tempAlpha)
                {
                    WARNING(("GpPngEncoder::WriteHeader -- can't allocate temp alpha.\n"));
                    GpFree(tempPalette);
                    hResult = E_OUTOFMEMORY;
                    goto DoneWriting;
                }
                for (UINT i = 0; i < EncoderColorPalettePtr->Count; i++)
                {
                    ARGB rgbData = EncoderColorPalettePtr->Entries[i];

                    tempPalette[i][0] = static_cast<SPNG_U8>((rgbData & (0xff << RED_SHIFT)) >> RED_SHIFT);
                    tempPalette[i][1] = static_cast<SPNG_U8>((rgbData & (0xff << GREEN_SHIFT)) >> GREEN_SHIFT);
                    tempPalette[i][2] = static_cast<SPNG_U8>((rgbData & (0xff << BLUE_SHIFT)) >> BLUE_SHIFT);

                    tempAlpha[i] = static_cast<SPNG_U8>((rgbData & (0xff << ALPHA_SHIFT)) >> ALPHA_SHIFT);
                    if (tempAlpha[i] < 0xff)
                    {
                        bTempAlpha = TRUE;
                        if ((!bAlpha0) && (tempAlpha[i] == 0))
                        {
                            bAlpha0 = TRUE;
                            iAlpha0 = static_cast<SPNG_U8>(i);
                        }
                    }
                }

                if (!pSpngWrite->FWritePLTE (tempPalette, EncoderColorPalettePtr->Count))
                {
                    WARNING(("GpPngEncoder::WriteHeader -- could not write PLTE chunk.\n"));
                    GpFree(tempPalette);
                    GpFree(tempAlpha);
                    hResult = E_FAIL;
                    goto DoneWriting;
                }

                // For color types 2 and 3, write out a tRNS chunk if there is a
                // non-255 alpha value.  In the color type 2 case, we choose the
                // first index with alpha == 0 to be the index of interest.
                // ASSUMPTION: We don't need to save a tRNS chunk for color type 0
                // because the encoder never saves the image as a color type 0.
                if ((colorType == 2) && bAlpha0)
                {
                    if (!pSpngWrite->FWritetRNS (tempPalette[iAlpha0][0],
                                                 tempPalette[iAlpha0][1],
                                                 tempPalette[iAlpha0][2]))
                    {
                        WARNING(("GpPngEncoder::WriteHeader -- could not write tRNS chunk.\n"));
                        GpFree(tempPalette);
                        GpFree(tempAlpha);
                        hResult = E_FAIL;
                        goto DoneWriting;
                    }
                }
                else if ((colorType == 3) && bTempAlpha)
                {
                    if (!pSpngWrite->FWritetRNS (tempAlpha, EncoderColorPalettePtr->Count))
                    {
                        WARNING(("GpPngEncoder::WriteHeader -- could not write tRNS chunk.\n"));
                        GpFree(tempPalette);
                        GpFree(tempAlpha);
                        hResult = E_FAIL;
                        goto DoneWriting;
                    }
                }
                
                GpFree(tempPalette);
                GpFree(tempAlpha);
            }
            else
            {
                // colorType 3 MUST have a palette
                if (colorType == 3)
                {
                    WARNING(("GpPngEncoder::WriteHeader -- need color palette, but none set\n"));
                    hResult = E_FAIL;
                    goto DoneWriting;
                }
            }
        }

        // Write the pHYs chunk.  (First, convert imageInfo dpi to dots per meter.)
        if ((encoderImageInfo.Xdpi != DEFAULT_RESOLUTION) ||
            (encoderImageInfo.Ydpi != DEFAULT_RESOLUTION))
        {
            if (!pSpngWrite->FWritepHYs(static_cast<SPNG_U32> (encoderImageInfo.Xdpi / 0.0254),
                                        static_cast<SPNG_U32> (encoderImageInfo.Ydpi / 0.0254),
                                        true))
            {
                WARNING(("GpPngEncoder::WriteHeader -- could not write pHYs chunk\n"));
                hResult = E_FAIL;
                goto DoneWriting;
            }
        }

        if ( HasSetLastModifyTime == TRUE )
        {
            // Write out tIME chunk
            
            if ( !pSpngWrite->FWritetIME((SPNG_U8*)&LastModifyTime) )
            {
                WARNING(("PngEncoder::WriteHeader-could not write tIME chunk"));
                hResult = E_FAIL;
                goto DoneWriting;
            }
        }

        // Write out other chunks if there are any

        // Text chunk

        hResult = WriteOutTextChunk(CommentBufPtr, "Comment");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(ImageTitleBufPtr, "Title");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(ArtistBufPtr, "Author");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(CopyRightBufPtr, "Copyright");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(ImageDescriptionBufPtr, "Description");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(DateTimeBufPtr, "CreationTime");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(SoftwareUsedBufPtr, "Software");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        hResult = WriteOutTextChunk(EquipModelBufPtr, "Source");
        if ( FAILED(hResult) )
        {
            goto DoneWriting;
        }
        
        bValidSpngWriteState = TRUE;
    }// If we haven't write header yet

DoneWriting:
    return hResult;
}// WriteHeader()

/**************************************************************************\
*
* Function Description:
*
*   Providing a memory buffer to the caller (source) for storing image property
*
* Arguments:
*
*   uiTotalBufferSize - [IN]Size of the buffer required.
*   ppBuffer----------- [IN/OUT] Pointer to the newly allocated buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpPngEncoder::GetPropertyBuffer(
    UINT            uiTotalBufferSize,
    PropertyItem**  ppBuffer
    )
{
    HRESULT hResult = S_OK;

    if ( (uiTotalBufferSize == 0) || ( ppBuffer == NULL) )
    {
        WARNING(("GpPngEncoder::GetPropertyBuffer---Invalid inputs"));
        hResult = E_INVALIDARG;
        goto GetOut;
    }

    *ppBuffer = NULL;

    if ( LastPropertyBufferPtr != NULL )
    {
        // After calling GetPropertyBuffer(), the caller (source) should call
        // PushPropertyItems() to push all the property items to us and we will
        // free the temporary property buffer after we have handled all the
        // property stuff.
        // The caller shouldn't call GetPropertyBuffer() repeatedly without
        // calling PushPropertyItems()

        WARNING(("PNG::GetPropertyBuffer---Free the old property buf first"));
        hResult = E_INVALIDARG;
        goto GetOut;
    }

    PropertyItem* pTempBuf = (PropertyItem*)GpMalloc(uiTotalBufferSize);
    if ( pTempBuf == NULL )
    {
        WARNING(("GpPngEncoder::GetPropertyBuffer---Out of memory"));
        hResult = E_OUTOFMEMORY;
        goto GetOut;
    }

    *ppBuffer = pTempBuf;

    // Remember the memory pointer we allocated so that we have better control
    // later

    LastPropertyBufferPtr = pTempBuf;

GetOut:
    return hResult;
}// GetPropertyBuffer()

/**************************************************************************\
*
* Function Description:
*
*   Method for accepting property items from the source. Then temporary store
*   them in a proper buffer. These property items will be written out in
*   WriteHeader()
*
* Arguments:
*
*   [IN] uiNumOfPropertyItems - Number of property items passed in
*   [IN] uiTotalBufferSize----- Size of the buffer passed in
*   [IN] pItemBuffer----------- Input buffer for holding all the property items
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::PushPropertyItems(
        IN UINT             uiNumOfPropertyItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
{
    HRESULT hResult = S_OK;
    BOOL    fHasWhitePoint = FALSE;
    BOOL    fHasRGBPoint = FALSE;

    if ( bValidSpngWriteState == TRUE )
    {
        WARNING(("PNGEncoder--Can't push property items after WriteHeader()"));
        hResult = E_FAIL;
        goto CleanUp;
    }
    
    PropertyItem*   pCurrentItem = item;
    UINT32          ulCount = 0;
    UINT16          ui16Tag;

    // Loop through all the property items. Pick those property items which are
    // supported by PNG spec and save it later

    for ( UINT i = 0; i < uiNumOfPropertyItems; ++i )
    {
        ui16Tag = (UINT16)pCurrentItem->id;

        switch ( ui16Tag )
        {
        case EXIF_TAG_USER_COMMENT:
            hResult = GetTextPropertyItem(&CommentBufPtr, pCurrentItem);
            break;

        case TAG_IMAGE_TITLE:
            hResult = GetTextPropertyItem(&ImageTitleBufPtr, pCurrentItem);
            break;

        case TAG_ARTIST:
            hResult = GetTextPropertyItem(&ArtistBufPtr, pCurrentItem);
            break;

        case TAG_COPYRIGHT:
            hResult = GetTextPropertyItem(&CopyRightBufPtr, pCurrentItem);
            break;

        case TAG_IMAGE_DESCRIPTION:
            hResult = GetTextPropertyItem(&ImageDescriptionBufPtr,pCurrentItem);
            break;

        case TAG_DATE_TIME:
            // Last modification time. Should be in tIME chunk

            if ( (pCurrentItem->length > 0) && (pCurrentItem->value != NULL) )
            {
                hResult = ConvertTimeFormat((char UNALIGNED*)pCurrentItem->value,
                                            &LastModifyTime);
                if ( SUCCEEDED(hResult) )
                {
                    HasSetLastModifyTime = TRUE;
                }
            }

            break;

        case EXIF_TAG_D_T_ORIG:
            // Image original creation time. Should be in Text chunk

            hResult = GetTextPropertyItem(&DateTimeBufPtr, pCurrentItem);
            break;

        case TAG_SOFTWARE_USED:
            hResult = GetTextPropertyItem(&SoftwareUsedBufPtr, pCurrentItem);
            break;

        case TAG_EQUIP_MODEL:
            hResult = GetTextPropertyItem(&EquipModelBufPtr, pCurrentItem);
            break;

        case TAG_ICC_PROFILE:
        {
            // If we already have the ICC data, (something wrong), free it. One
            // image can have only one ICC profile

            if ( ICCDataBufPtr != NULL )
            {
                GpFree(ICCDataBufPtr);
                ICCDataBufPtr = NULL;
            }

            ICCDataLength = pCurrentItem->length;
            if ( ICCDataLength == 0 )
            {
                // If the data length is 0, do nothing

                break;
            }

            // Since PNG can't handle CMYK color space. So if an ICC profile is
            // for CMYK, then it is useless for PNG. We should throw it away
            // According to ICC spec, bytes 16-19 should describe the color
            // space

            BYTE UNALIGNED*  pTemp = (BYTE UNALIGNED*)pCurrentItem->value + 16;

            if ( (pTemp[0] == 'C')
               &&(pTemp[1] == 'M')
               &&(pTemp[2] == 'Y')
               &&(pTemp[3] == 'K') )
            {
                // If this is a CMYK profile, then we just bail out
                // Set the ICC data length to 0 so that we won't save it later

                ICCDataLength = 0;
                break;
            }

            ICCDataBufPtr = (SPNG_U8*)GpMalloc(ICCDataLength);
            if ( ICCDataBufPtr == NULL )
            {
                WARNING(("GpPngEncoder::PushPropertyItems--Out of memory"));
                hResult = E_OUTOFMEMORY;
                goto CleanUp;
            }

            GpMemcpy(ICCDataBufPtr, pCurrentItem->value, ICCDataLength);
        }

            break;

        case TAG_ICC_PROFILE_DESCRIPTOR:
        {
            // If we already got a ICC name, (something wrong), free it. One ICC
            // profile can't have two names

            if ( ICCNameBufPtr != NULL )
            {
                GpFree(ICCNameBufPtr);
                ICCNameBufPtr = NULL;
            }

            UINT uiICCNameLength = pCurrentItem->length;

            if ( uiICCNameLength == 0 )
            {
                // If the ICC doesn't have a name, do nothing

                break;
            }

            ICCNameBufPtr = (char*)GpMalloc(uiICCNameLength);
            if ( ICCNameBufPtr == NULL )
            {
                // Set the ICC name length to 0 so that we won't save it later
                
                uiICCNameLength = 0;

                WARNING(("GpPngEncoder::PushPropertyItems--Out of memory"));
                hResult = E_OUTOFMEMORY;
                goto CleanUp;
            }

            GpMemcpy(ICCNameBufPtr, pCurrentItem->value, uiICCNameLength);
        }
            break;

        case TAG_GAMMA:
        {
            // A property item for gamma should contain a RATIONAL type, that is
            // the length has to be 2 UINT32

            if ( (pCurrentItem->length != 2 * sizeof(UINT32) )
               ||(pCurrentItem->type != TAG_TYPE_RATIONAL) )
            {
                break;
            }

            ULONG UNALIGNED*  pTemp = (ULONG UNALIGNED*)pCurrentItem->value;

            // Since gamma values in a property items are stored as 100000
            // and the gamma value times 100000. For example, a gamma of 1/2.2
            // would be stored as 100000 and 45455.
            // But in the PNG header, we need to only store 45455. So here we
            // get the 2nd ULONG value and write it out later

            pTemp++;
            GammaValue = (SPNG_U32)(*pTemp);

            break;
        }

        case TAG_WHITE_POINT:
        {
            // A property item for white point should contain 2 RATIONAL
            // type, that is the length has to be 4 UINT32

            if ( (pCurrentItem->length != 4 * sizeof(UINT32) )
               ||(pCurrentItem->type != TAG_TYPE_RATIONAL) )
            {
                break;
            }
            
            fHasWhitePoint = TRUE;
            
            // See comments below for reasons why we get the 1st and 3rd values
            // from the property item here

            ULONG UNALIGNED*  pTemp = (ULONG UNALIGNED*)pCurrentItem->value;
            
            CHRM[0] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[1] = (SPNG_U32)(*pTemp);

            break;
        }

        case TAG_PRIMAY_CHROMATICS:
        {
            // A property item for chromaticities should contain 6 RATIONAL
            // type, that is the length has to be 12 UINT32

            if ( (pCurrentItem->length != 12 * sizeof(UINT32) )
             ||(pCurrentItem->type != TAG_TYPE_RATIONAL) )
            {
                break;
            }

            fHasRGBPoint = TRUE;
            
            // Each value of chromaticities is encoded as a 4-byte unsigned
            // integer, represending the X or Y value times 100000. For example,
            // a value of 0.3127 would be stored as the integer 31270.
            // When it stored in the property item, it is stored as a RATIONAL
            // value with numerator as 31270 and denominator as 100000
            // So here we need just to get the numerator and write it out later
            
            ULONG UNALIGNED*  pTemp = (ULONG UNALIGNED*)pCurrentItem->value;
            
            CHRM[2] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[3] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[4] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[5] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[6] = (SPNG_U32)(*pTemp);

            pTemp += 2;
            CHRM[7] = (SPNG_U32)(*pTemp);

            break;
        }

        default:
            break;
        }// switch ( ui16Tag )
        
        // Move onto next property item

        pCurrentItem++;
    }// Loop through all the property items

    // We got all the property items we are going to save if we get here
    // One more thing need to check is if we got both WhitePoints and RGB points
    // In PNG, White Points and RGB points have to co-exist. But in JPEG there
    // are stored separatly under different TAGs. So to be fool proof here, we
    // have to be sure we got both of them before we can say we has Chrom chunk.

    if ( (fHasWhitePoint == TRUE) && (fHasRGBPoint == TRUE) )
    {
        HasChrmChunk = TRUE;
    }

    // Free the buffer we allocated for the caller if it is the same as the one
    // we allocated in GetPropertyBuffer()

CleanUp:

    if ( (item != NULL) && (item == LastPropertyBufferPtr) )
    {
        GpFree(item);
        LastPropertyBufferPtr = NULL;
    }

    return hResult;
}// PushPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Method for getting individual text related PNG property item from the
*   source. Then temporary store them in a proper buffer. These property items
*   will be written out in WriteHeader()
*
* Arguments:
*
*   [IN/OUT] ppcDestPtr - Dest buffer to store the text property item
*   [IN] pItem ---------- Input property item which contains the text property
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private function with PNG encoder. So the caller should be
*   responsible for not letting ppcDestPtr be NULL
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::GetTextPropertyItem(
    char**              ppDest,
    const PropertyItem* pItem
    )
{
    ASSERT( (ppDest != NULL) && (pItem != NULL) );
    char*   pTemp = *ppDest;
    HRESULT hResult = S_OK;

    if ( pTemp != NULL )
    {
        // We don't support multiple text items under same property tag
        // that is, for different text property items, it should be stored in
        // different buffer.

        GpFree(pTemp);
    }

    pTemp = (char*)GpMalloc(pItem->length + 1);
    if ( pTemp == NULL )
    {
        WARNING(("GpPngEncoder::GetTextPropertyItem--Out of memory"));
        hResult = E_OUTOFMEMORY;
        goto Done;
    }

    GpMemcpy(pTemp, pItem->value, pItem->length);

    // Add a NULL terminator at the end
    // Note: theoritically we don't need to do this because the source
    // pItem->length should include the NULL terminator. But some
    // stress app purposely don't set the NULL at the end when it calls
    // SetPropertyItem(). On the other hand, even if we add an extra
    // NULL here, it won't be write to the property in the image because
    // when we call FWriteExt() to write the item to the image, it will
    // do a strlen() first and figure out the real length from there

    pTemp[pItem->length] = '\0';

Done:
    *ppDest = pTemp;

    return hResult;
}// GetTextPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Method for writting individual text related PNG property item to the file
*
* Arguments:
*
*   [IN] pContents -- Pointer to a buffer for text item to be written out
*   [IN] pTitle ----- Pointer to the title of the text item to be written
*
* Return Value:
*
*   Status code
*
* Note:
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::WriteOutTextChunk(
    const char*   pContents,
    const char*   pTitle
    )
{
    HRESULT hResult = S_OK;

    if ( (pContents != NULL) && (pTitle != NULL) )
    {
        if ( !pSpngWrite->FWritetEXt(pTitle, pContents) )
        {
            WARNING(("PngEncoder::WriteOutTextChunk-Fail to write tEXt chunk"));
            hResult = E_FAIL;
        }
    }

    return hResult;
}// WriteOutTextChunk()

/**************************************************************************\
*
* Function Description:
*
*   Method for converting the DATE/TIME from YYYY:MM:DD HH:MM:SS to a format of
*   PNG tIME structure
*
* Arguments:
*
*   [IN] pSrc  ---- Pointer to a buffer of source date/time string
*   [IN] pTime ---- Pointer to the result PNG date/time structure
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private function with PNG encoder. So the caller should be
*   responsible for not letting these two pointers to be NULL
*
\**************************************************************************/

STDMETHODIMP
GpPngEncoder::ConvertTimeFormat(
    const char UNALIGNED*   pSrc,
    LastChangeTime*         pTimeBlock
    )
{
    HRESULT hResult = S_OK;

    ASSERT( (pSrc != NULL) && (pTimeBlock != NULL) );

    // The input source time string has to be 19 bytes long

    if ( strlen(pSrc) != 19 )
    {
        hResult = E_FAIL;
    }

    UINT16 tempYear    = (pSrc[0] - '0') * 1000
                       + (pSrc[1] - '0') * 100
                       + (pSrc[2] - '0') * 10
                       + (pSrc[3] - '0');

    // Note: since the lower level PNG library takes 2 bytes for the YEAR, not
    // a USHORT, so we have to swap it here
    
    pTimeBlock->usYear  = ( ((tempYear & 0xff00) >> 8)
                        |   ((tempYear & 0x00ff) << 8) );
    pTimeBlock->cMonth  = (pSrc[5] - '0') * 10 + (pSrc[6] - '0');
    pTimeBlock->cDay    = (pSrc[8] - '0') * 10 + (pSrc[9] - '0');
    pTimeBlock->cHour   = (pSrc[11] - '0') * 10 + (pSrc[12] - '0');
    pTimeBlock->cMinute = (pSrc[14] - '0') * 10 + (pSrc[15] - '0');
    pTimeBlock->cSecond = (pSrc[17] - '0') * 10 + (pSrc[18] - '0');

    return hResult;
}// ConvertTimeFormat()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngcodec.hpp
*
* Abstract:
*
*   Header file for the PNG encoder/decoder
*
* Revision History:
*
*   7/20/99 DChinn
*       Created it.
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*   4/01/2000 MinLiu (Min Liu)
*       Took over and implemented property stuff
*
\**************************************************************************/

#include "libpng\spngsite.h"
#include "libpng\spngread.h"
#include "libpng\spngwrite.h"
#include "pngnoncrit.hpp"
#include "propertyutil.hpp"

const   k_ChromaticityTableLength = 8;

class GpPngDecoder : public IImageDecoder, public BITMAPSITE
{
private:
    
    IStream *pIstream;
    IImageSink* decodeSink;
    GpSpngRead *pGpSpngRead;
    ColorPalette*   DecoderColorPalettePtr;    // Color palette for current image
    VOID *pbInputBuffer;
    UINT cbInputBuffer;
    VOID *pbBuffer;         // buffer for one line of the image
    UINT cbBuffer;
    IImageBytes* ImageBytesPtr;     // Pointer to IImageBytes through query
    const VOID* ImageBytesDataPtr;  // Pointer to IImageBytes data buffer
    BOOL NeedToUnlockBytes;         // Flag to see if need to unlock ImageBytes

    // if bValidSpngReadState == FALSE, then state needs to be reinitialized
    // when a new BeginDecode call is made.
    BOOL bValidSpngReadState;
    BOOL bCalledBeginSink;
    UINT currentLine;

    PixelFormatID GetPixelFormatID(void);
    STDMETHODIMP DecodeFrame(IN ImageInfo& imageInfo);
    STDMETHODIMP ConvertPNGLineTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertGrayscaleTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertRGBTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertPaletteIndexTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertGrayscaleAlphaTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertRGBAlphaTo32ARGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertPNG24RGBTo24RGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertPNG48RGBTo48RGB(IN SPNG_U8 *pb,
        OUT BitmapData *bitmapData);
    STDMETHODIMP ConvertPNG64RGBAlphaTo64ARGB(IN SPNG_U8 *pb, 
        OUT BitmapData *bitmapData);
    STDMETHODIMP BuildPropertyItemList();
    VOID         CleanUpPropertyItemList();
    STDMETHODIMP PassPropertyToSink();

    // pure virtual functions for BITMAPSITE:
    // FReport: data format error handling
    
    bool FReport(bool fatal, int icase, int iarg) const;

    // Property item stuff

    BOOL            HasProcessedPropertyItem;
    InternalPropertyItem   PropertyListHead;
    InternalPropertyItem   PropertyListTail;
    UINT            PropertyListSize;
    UINT            PropertyNumOfItems;
    BOOL            HasPropertyChanged;

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpPngDecoder::GpPngDecoder(void);
    GpPngDecoder::~GpPngDecoder(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);
    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};


class GpPngEncoder : public IImageEncoder, public IImageSink, public BITMAPSITE
{
private:

    IStream *pIoutStream;
    GpSpngWrite *pSpngWrite;
    ImageInfo encoderImageInfo;  // set in BeginSink; used in {Get,Release}PixelDataBuffer
    RECT encoderRect;           // set in GetPixelDataBuffer; used in ReleasePixelDataBuffer
    VOID *lastBufferAllocated;  // used for scan0 in bitmapData in {Get,Release}PixelDataBuffer
    SPNG_U8 *pbWriteBuffer;        // buffer for one line of the image
    UINT cbWriteBuffer;
    // if bValidSpngWriteState == FALSE, then state needs to be reinitialized
    // when a new BeginSink call is made.
    BOOL bValidSpngWriteState;
    ColorPalette*   EncoderColorPalettePtr;    // Color palette for current image
    BOOL            bHasSetPixelFormat; // Set TRUE if the caller calls
                                        // SetEncoderParam() to set the color
                                        // depth. Otherwise, we save the image
                                        // as the same color depth as the source
    PixelFormatID   RequiredPixelFormat;    // The format encoder tries to write as
    bool bRequiredScanMethod;   // true = Interlaced; false = Noninterlaced
    UINT OutputStride;          // stride when we finally write to bitmapData->scan0
    SPNG_U32 PNGbpp;            // bits per pixel of the final output
    
    PropertyItem*   LastPropertyBufferPtr;
                                        // Points to the property buffer we
                                        // allocated for the decoder. This is
                                        // useful to prevent memory leaking in
                                        // case the decoder forgets to call our
                                        // PushPropertyItems()

    char*       CommentBufPtr;          // Pointer to comment buffer chunk
    char*       ImageTitleBufPtr;       // Pointer to image title buffer chunk
    char*       ArtistBufPtr;           // Pointer to artist buffer chunk
    char*       CopyRightBufPtr;        // Pointer to CopyRight buffer chunk
    char*       ImageDescriptionBufPtr; // Pointer to image describ buffer chunk
    char*       DateTimeBufPtr;         // Pointer to date-time buffer chunk
    char*       SoftwareUsedBufPtr;     // Pointer to software used buffer chunk
    char*       EquipModelBufPtr;       // Pointer to equip model buffer chunk
    char*       ICCNameBufPtr;          // Pointer to ICC name buffer
    ULONG       ICCDataLength;          // Length, in bytes, of profile name
    SPNG_U8*    ICCDataBufPtr;          // Pointer to ICC name buffer
    SPNG_U32    GammaValue;             // Gamma value x 100000 to write out
    SPNG_U32    CHRM[k_ChromaticityTableLength];
                                        // Uninterpreted chromaticities x 100000
    BOOL        HasChrmChunk;           // TRUE if we have CHRM chunk
    LastChangeTime  LastModifyTime;     // Last modify time
    BOOL        HasSetLastModifyTime;   // TRUE if caller set Last modify time

    STDMETHODIMP Convert24RGBToBGR (IN BYTE *pLineBits,
                                    OUT VOID *pbWriteBuffer);
    STDMETHODIMP Convert32ARGBToAlphaBGR (IN BYTE *pLineBits,
                                          OUT VOID *pbWriteBuffer);
    STDMETHODIMP Convert48RGBToBGR (IN BYTE *pLineBits,
                                    OUT VOID *pbWriteBuffer);
    STDMETHODIMP Convert64ARGBToAlphaBGR (IN BYTE *pLineBits,
                                          OUT VOID *pbWriteBuffer);
    STDMETHODIMP WriteHeader (IN UINT width,
                              IN PixelFormatID pixelFormat);

    STDMETHODIMP GetTextPropertyItem(char**         ppDest,
                                     const PropertyItem*  pItem);
                                        // Function to get text items from a
                                        // property item structure
    STDMETHODIMP WriteOutTextChunk(const char*    pContents,
                                   const char*    pTitle);
                                        // Function to write out text items
    STDMETHODIMP ConvertTimeFormat(const char UNALIGNED* pSrc,
                                   LastChangeTime* pTimeBlock);
                                        // Function to convert time string to
                                        // PNG tIME structure

    virtual bool FWrite(const void *pv, size_t cb);     // move bytes from output buffer to IOutStream

    // pure virtual functions for BITMAPSITE:
    // FReport: data format error handling
    
    bool FReport(bool fatal, int icase, int iarg) const;

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpPngEncoder::GpPngEncoder(void);
    GpPngEncoder::~GpPngEncoder(void);

    // IImageEncoder methods
    
    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // PNG can handle raw property when saving. But it is only needed
        // before the header is written

        if ( bValidSpngWriteState == FALSE )
        {
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }
    
    STDMETHOD(PushRawInfo)(IN OUT void* info)
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        );
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        );
    
    // IImageSink methods (sink for encoder)
    
    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
        OUT OPTIONAL RECT* subarea);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
        IN PixelFormatID pixelFormat, IN BOOL lastPass,
        OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* pSrcBitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
        IN const BitmapData* bitmapData, IN BOOL lastPass);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};

class GpPngCodec : public GpPngDecoder, public GpPngEncoder
{
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpPngCodec::GpPngCodec(void);
    GpPngCodec::~GpPngCodec(void);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngnoncrit.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngnoncrit.hpp
*
* Abstract:
*
*   Definition for the GpSpngRead class (derived from SPNGREAD),
*   which is capable of reading non-critical chunks (using FChunk).
*
* Revision History:
*
*   9/24/99 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "pngnoncrit.hpp"

#define SWAP_WORD(_x) ((((_x) & 0xff) << 8)|((((_x)>>8) & 0xff) << 0))

GpSpngRead::GpSpngRead(
    BITMAPSITE  &bms,
    const void* pv,
    int         cb,
    bool        fMMX
    )
    : SPNGREAD(bms, pv, cb, fMMX),
      m_uOther(0),
      m_cbOther(0),
      m_uOA(0),
      m_cbOA(0),
      m_xpixels(0),
      m_ypixels(0),
      m_uGamma(0),
      m_uiCCP(0),
      m_cbiCCP(0),
      m_ctRNS(0),
      m_bIntent(255),
      m_bpHYs(255),
      m_bImportant(0),
      m_fcHRM(false),
      m_ulTitleLen(0),
      m_pTitleBuf(NULL),
      m_ulAuthorLen(0),
      m_pAuthorBuf(NULL),
      m_ulCopyRightLen(0),
      m_pCopyRightBuf(NULL),
      m_ulDescriptionLen(0),
      m_pDescriptionBuf(NULL),
      m_ulCreationTimeLen(0),
      m_pCreationTimeBuf(NULL),
      m_ulSoftwareLen(0),
      m_pSoftwareBuf(NULL),
      m_ulDeviceSourceLen(0),
      m_pDeviceSourceBuf(NULL),
      m_ulCommentLen(0),
      m_pCommentBuf(NULL),
      m_pICCBuf(NULL),
      m_ulICCLen(0),
      m_ulICCNameLen(0),
      m_pICCNameBuf(NULL),
      m_ulTimeLen(0),
      m_pTimeBuf(NULL),
      m_ulSPaletteNameLen(0),
      m_pSPaletteNameBuf(NULL),
      m_ihISTLen(0),
      m_phISTBuf(NULL)
{
    m_bsBit[0] = m_bsBit[1] = m_bsBit[2] = m_bsBit[3] = 0;
}

GpSpngRead::~GpSpngRead()
{
    if ( m_ulTitleLen != 0 )
    {
        GpFree(m_pTitleBuf);
    }
    
    if ( m_ulAuthorLen != 0 )
    {
        GpFree(m_pAuthorBuf);
    }
    
    if ( m_ulCopyRightLen != 0 )
    {
        GpFree(m_pCopyRightBuf);
    }
    
    if ( m_ulDescriptionLen != 0 )
    {
        GpFree(m_pDescriptionBuf);
    }
    
    if ( m_ulCreationTimeLen != 0 )
    {
        GpFree(m_pCreationTimeBuf);
    }
    
    if ( m_ulSoftwareLen != 0 )
    {
        GpFree(m_pSoftwareBuf);
    }
    
    if ( m_ulDeviceSourceLen != 0 )
    {
        GpFree(m_pDeviceSourceBuf);
    }
    
    if ( m_ulCommentLen != 0 )
    {
        GpFree(m_pCommentBuf);
    }

    if ( m_ulICCLen != 0 )
    {
        GpFree(m_pICCBuf);
    }

    if ( m_ulICCNameLen != 0 )
    {
        GpFree(m_pICCNameBuf);
    }

    if ( m_ulTimeLen != 0 )
    {
        GpFree(m_pTimeBuf);
    }

    if ( m_ulSPaletteNameLen != 0 )
    {
        GpFree(m_pSPaletteNameBuf);
    }

    if ( m_ihISTLen != 0 )
    {
        GpFree(m_phISTBuf);
    }
}// Dstor()

/*----------------------------------------------------------------------------
    To obtain information from non-critical chunks the following API must be
    implemented.  It gets the chunk identity and length plus a pointer to
    that many bytes.  If it returns false loading of the chunks will stop
    and a fatal error will be logged, the default implementation just skips
    the chunks.  Note that this is called for *all* chunks including
    IDAT.  m_fBadFormat is set if the API returns false.
------------------------------------------------------------------- JohnBo -*/
bool
GpSpngRead::FChunk(
    SPNG_U32 ulen,
    SPNG_U32 uchunk,
    const SPNG_U8* pb
    )
{
    BOOL    bIsCompressed = FALSE;

    switch ( uchunk )
    {
    case PNGcHRM:
        if (ulen == 8 * 4 )
        {
            if ( m_bIntent == 255 ) // No sRGB
            {
                m_fcHRM = true;
                for ( int i=0; i<8; ++i, pb+=4 )
                {
                    m_ucHRM[i] = SPNGu32(pb);
                }
            }
        }
        else
        {
            WARNING(("SPNG: cHRM chunk bad length %d", ulen));
        }

        break;
    
    case PNGgAMA:
        if ( ulen == 4 )
        {
            if ( m_bIntent == 255 ) // Not sRGB
            {
                m_uGamma = SPNGu32(pb);
            }
        }
        else
        {
            WARNING(("SPNG: gAMA chunk bad length %d", ulen));
        }

        break;

    case PNGiCCP:
    {
        // ICC profile chunk. Here is the spec:
        // The iCCP chunk contains:
        //
        // Profile name:       1-79 bytes (character string)
        // Null separator:     1 byte
        // Compression method: 1 byte
        // Compressed profile: n bytes
        //
        // The format is like the zTXt chunk. The profile name can be any
        // convenient name for referring to the profile. It is case-sensitive
        // and subject to the same restrictions as a tEXt
        //
        // keyword:  it must contain only printable Latin-1 [ISO/IEC-8859-1]
        // characters (33-126 and 161-255) and spaces (32), but no leading,
        // trailing, or consecutive spaces. The only value presently defined for
        // the compression method byte is 0, meaning zlib datastream with
        // deflate compression (see Deflate/Inflate Compression, Chapter 5).
        // Decompression of the remainder of the chunk yields the ICC profile.
                          
        m_ulICCNameLen = 0;
        SPNG_U8* pTemp = (SPNG_U8*)pb;

        // Get the profile name

        while ( (ulen > 0) && (*pTemp != 0) )
        {
            --ulen;
            ++pTemp;
            ++m_ulICCNameLen;
        }

        if ( m_ulICCNameLen > 79 )
        {
            WARNING(("GpSpngRead::FChunk iCC profile name too long"));

            // Reset the length to 0 so that we don't confuse ourselves later

            m_ulICCNameLen = 0;
            
            break;
        }

        // Skip the null terminator of the name

        --ulen;
        ++pTemp;
        
        // We count the last NULL terminator as one part of the name

        m_ulICCNameLen++;

        if ( m_pICCNameBuf != NULL )
        {
            // We don't support multiple ICC profiles.

            GpFree(m_pICCNameBuf);
        }

        m_pICCNameBuf = (SPNG_U8*)GpMalloc(m_ulICCNameLen);

        if ( m_pICCNameBuf == NULL )
        {
            WARNING(("GpSpngRead::FChunk---Out of memory for ICC name"));
            return FALSE;
        }

        GpMemcpy(m_pICCNameBuf, pb, m_ulICCNameLen);

        // Move the pb data pointer

        pb = pTemp;

        // Check the Zlib data, for safety because this is a new chunk
        // We do the full Zlib check here.

        if ( (ulen < 3) || (pb[0] != 0) || ((pb[1] & 0xf) != Z_DEFLATED)
             ||( ( ((pb[1] << 8) + pb[2]) % 31) != 0) )
        {
            WARNING(("GpSpngRead::FChunk bad compressed data"));
        }
        else
        {
            if ( m_ulICCLen == 0 )
            {
                pb++;

                // Compressed profile length

                m_cbiCCP = ulen - 1;

                // Assume the uncompressed data will be 4 times bigger than
                // the compressed data. The reason behind it is that zlib
                // usually won't compress data down to 25% of the original size

                m_ulICCLen = (m_cbiCCP << 2);
                m_pICCBuf = (SPNG_U8*)GpMalloc(m_ulICCLen);

                if ( m_pICCBuf == NULL )
                {
                    WARNING(("GpSpngRead::FChunk---Out of memory"));
                    return FALSE;
                }

                INT iRC = uncompress(m_pICCBuf, &m_ulICCLen, pb, m_cbiCCP);

                while ( iRC == Z_MEM_ERROR )
                {
                    // The dest memory we allocated is too small

                    GpFree(m_pICCBuf);

                    // Increment the size by 2 at time and realloc memory

                    m_ulICCLen = (m_ulICCLen << 1);
                    m_pICCBuf = (SPNG_U8*)GpMalloc(m_ulICCLen);

                    if ( m_pICCBuf == NULL )
                    {
                        WARNING(("GpSpngRead::FChunk---Out of memory"));
                        return FALSE;
                    }

                    iRC = uncompress(m_pICCBuf, &m_ulICCLen, pb, m_cbiCCP);
                }

                if ( iRC != Z_OK )
                {
                    // Since we didn't decompress the ICC profile successfully,
                    // we should reset them to NULL. Otherwise,
                    // BuildPropertyItemList() will put the wrong ICC profile in
                    // the property list

                    GpFree(m_pICCBuf);
                    m_pICCBuf = NULL;
                    m_ulICCLen = 0;

                    WARNING(("GpSpngRead::FChunk---uncompress ICC failed"));
                    // We couldn't get the chunk so ignore it.
                    // We've reset our members so we are not in an invalid
                    // state.
                    break;
                }
            }// First ICCP chunk
            else
            {
                WARNING(("SPNG: ICC[%d, %s]: repeated iCCP chunk", ulen,
                         pb - m_ulICCNameLen));
            }
        }// Valid ulen and pb
    }
        
        break;

    case PNGzTXt:

        ParseTextChunk(ulen, pb, TRUE);
        break;

    case PNGtEXt:

        ParseTextChunk(ulen, pb, FALSE);
        break;

    case PNGtIME:
    {
        // Time of the last image midification

        LastChangeTime  myTime;

        GpMemcpy(&myTime, pb, sizeof(LastChangeTime));
        myTime.usYear = SWAP_WORD(myTime.usYear);

        // Convert the format to a 20 bytes long TAG_DATE_TIME format
        // YYYY:MM:DD HH:MM:SS\0
        // Unfortunately we don't have sprintf() to help us. Have to it in a
        // strange way

        if ( m_pTimeBuf != NULL )
        {
            GpFree(m_pTimeBuf);
        }

        m_ulTimeLen = 20;
        m_pTimeBuf = (SPNG_U8*)GpMalloc(m_ulTimeLen);
        if ( m_pTimeBuf == NULL )
        {
            WARNING(("GpSpngRead::FChunk---Out of memory"));
            return FALSE;
        }

        UINT uiResult = myTime.usYear / 1000;   // might be a bug for year 10000
        UINT uiRemainder = myTime.usYear % 1000;
        UINT uiIndex = 0;

        m_pTimeBuf[uiIndex++] = '0' + uiResult;

        uiResult = uiRemainder / 100;
        uiRemainder = uiRemainder % 100;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;

        uiResult = uiRemainder / 10;
        uiRemainder = uiRemainder % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = ':';

        uiResult = myTime.cMonth / 10;
        uiRemainder = myTime.cMonth % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = ':';
        
        uiResult = myTime.cDay / 10;
        uiRemainder = myTime.cDay % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = ' ';        
        
        uiResult = myTime.cHour / 10;
        uiRemainder = myTime.cHour % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = ':';        
        
        uiResult = myTime.cMinute / 10;
        uiRemainder = myTime.cMinute % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = ':';        
        
        uiResult = myTime.cSecond / 10;
        uiRemainder = myTime.cSecond % 10;
        m_pTimeBuf[uiIndex++] = '0' + uiResult;
        m_pTimeBuf[uiIndex++] = '0' + uiRemainder;
        m_pTimeBuf[uiIndex++] = '\0';        
    }
        break;

    case PNGbKGD:
        // Default background chunk

        break;

    case PNGsPLT:
    case PNGspAL:
    {
        // The standard says this chunk should use sPLT. But some apps use spAL
        //
        // Suggest a reduced palette to be used when doing a down level color
        // reduction
        // This chunk contains a null-terminated text string that names the
        // palette and a one-byte sample depth, followed by a series of palette
        // entries, each a six-byte or ten-byte series containing five unsigned
        // integers:
        //
        //    Palette name:    1-79 bytes (character string)
        //    Null terminator: 1 byte
        //    Sample depth:    1 byte
        //    Red:             1 or 2 bytes
        //    Green:           1 or 2 bytes
        //    Blue:            1 or 2 bytes
        //    Alpha:           1 or 2 bytes
        //    Frequency:       2 bytes
        //    ...etc...

        m_ulSPaletteNameLen = 0;
        SPNG_U8* pTemp = (SPNG_U8*)pb;

        // Get the profile name

        while ( (ulen > 0) && (*pTemp != 0) )
        {
            --ulen;
            ++pTemp;
            ++m_ulSPaletteNameLen;
        }

        if ( m_ulSPaletteNameLen > 79 )
        {
            WARNING(("GpSpngRead::FChunk suggested palette name too long"));

            // Reset the length to 0 so that we don't confuse ourselves later

            m_ulSPaletteNameLen = 0;
            
            break;
        }
        
        // Skip the null terminator of the name

        --ulen;
        ++pTemp;
        
        // We count the last NULL terminator as one part of the name

        m_ulSPaletteNameLen++;

        if ( m_pSPaletteNameBuf != NULL )
        {
            // We don't support multiple ICC profiles.

            GpFree(m_pSPaletteNameBuf);
        }

        m_pSPaletteNameBuf = (SPNG_U8*)GpMalloc(m_ulSPaletteNameLen);

        if ( m_pSPaletteNameBuf == NULL )
        {
            WARNING(("GpSpngRead::FChunk---Out of memory for S palette"));
            return FALSE;
        }

        GpMemcpy(m_pSPaletteNameBuf, pb, m_ulSPaletteNameLen);

        // Move the pb data pointer

        pb = pTemp;
    }// PNGsPLT chunk
        
        break;

    case PNGpHYs:
        if (ulen == 9)
        {
            m_xpixels = SPNGu32(pb);
            m_ypixels = SPNGu32(pb+4);
            m_bpHYs = pb[8];
        }
        else
        {
            WARNING(("SPNG: pHYs chunk bad length %d", ulen));
        }
        break;

    case PNGsRGB:
        // sRGB chunk
        // The sRGB chunk contains: Rendering intent: 1 byte

        if ( ulen == 1 )
        {
            // An application that writes the sRGB chunk should also write a
            // gAMA chunk (and perhaps a cHRM chunk) for compatibility with
            // applications that do not use the sRGB chunk.  In this
            // situation, only the following values may be used:
            //
            // gAMA:
            // Gamma:         45455
            //
            // cHRM:
            // White Point x: 31270
            // White Point y: 32900
            // Red x:         64000
            // Red y:         33000
            // Green x:       30000
            // Green y:       60000
            // Blue x:        15000
            // Blue y:         6000

            m_bIntent = pb[0];
            m_uGamma = sRGBgamma;
            m_ucHRM[0] = 31270;
            m_ucHRM[1] = 32900; // white
            m_ucHRM[2] = 64000;
            m_ucHRM[3] = 33000; // red
            m_ucHRM[4] = 30000;
            m_ucHRM[5] = 60000; // green
            m_ucHRM[6] = 15000;
            m_ucHRM[7] =  6000; // blue
        }
        else
        {
            WARNING(("SPNG: sRGB chunk bad length %d", ulen));
        }
        break;

    case PNGsrGB:
        // Pre-approval form

        if (ulen == 22 && GpMemcmp(pb, "PNG group 1996-09-14", 21) == 0)
        {
            m_bIntent = pb[21];
            m_uGamma = sRGBgamma;
            m_ucHRM[0] = 31270;
            m_ucHRM[1] = 32900; // white
            m_ucHRM[2] = 64000;
            m_ucHRM[3] = 33000; // red
            m_ucHRM[4] = 30000;
            m_ucHRM[5] = 60000; // green
            m_ucHRM[6] = 15000;
            m_ucHRM[7] =  6000; // blue
        }
        
        break;

    case PNGsBIT:
        if ( ulen <= 4 )
        {
            GpMemcpy(m_bsBit, pb, ulen);
        }
        else
        {
            WARNING(("SPNG: sBIT chunk bad length %d", ulen));
        }

        break;

    case PNGtRNS:
        if ( ulen > 256 )
        {
            WARNING(("SPNG: tRNS chunk bad length %d", ulen));
            ulen = 256;
        }

        m_ctRNS = ulen;
        GpMemcpy(m_btRNS, pb, ulen);
        
        break;

    case PNGhIST:
        // A hIST chunk can appear only when a PLTE chunk appears. So we can
        // check if the number of entries is right or not.
        // The hIST chunk contains a series of 2-byte(16 bit) unsigned integers.
        // There must be exactly one entry for each entry in the PLTE chunk

        // Get the number of entries

        PbPalette(m_ihISTLen);

        if ( (ulen == 0) || (ulen != (m_ihISTLen << 1)) )
        {
            return FALSE;
        }

        m_phISTBuf = (SPNG_U16*)GpMalloc(m_ihISTLen * sizeof(UINT16));

        if ( m_phISTBuf == NULL )
        {
            WARNING(("GpSpngRead::FChunk---Out of memory for hIST chunk"));
            return FALSE;
        }

        GpMemcpy(m_phISTBuf, pb, ulen);
        
        // Swap the value

        for ( int i = 0; i < m_ihISTLen; ++i )
        {
            m_phISTBuf[i] = SWAP_WORD(m_phISTBuf[i]);
        }

        break;

    case PNGmsOC: // The important colors count
        // Chunk must have our signature

        if ( (ulen == 8) && (GpMemcmp(pb, "MSO aac", 7) == 0) )
        {
            m_bImportant = pb[7];
        }

        break;

    }

    return true;
}// FChunk()

/**************************************************************************\
*
* Function Description:
*
*   Parse text chunk (compressed or non-compressed) in the PNG header
*
* Return Value:
*
*   Return TRUE if everything is OK, otherwise return FALSE
*
* Revision History:
*
*   04/13/2000 minliu
*       Created it.
*
* Text chunk spec:
*   zTXt chunk contains texture data, just as tEXt does. But the data is
*   compressed
*
*   Keyword:              1-79 bytes (character string)
*   Null separator:       1 byte
*   Compression method:   1 byte
*   Compressed Text:      n bytes
*
*   tEXt Textual data
*
*   Textual information that the encoder wishes to record with the image can be
*   stored in tEXt chunks.  Each tEXt chunk contains a keyword and a text
*   string, in the format:
*
*   Keyword:        1-79 bytes (character string)
*   Null separator: 1 byte
*   Text:           n bytes (character string)
*
*   The keyword and text string are separated by a zero byte (null character).
*   Neither the keyword nor the text string can contain a null character. Note
*   that the text string is not null-terminated (the length of the chunk is
*   sufficient information to locate the ending).  The keyword must be at least
*   one character and less than 80 characters long.  The text string can be of
*   any length from zero bytes up to the maximum permissible chunk size less the
*   length of the keyword and separator.
*
\**************************************************************************/

bool
GpSpngRead::ParseTextChunk(
    SPNG_U32 ulen,
    const SPNG_U8* pb,
    bool bIsCompressed
    )
{
    BYTE        acKeyword[80];  // Maximum length of the keyword is 80
    INT         iLength = 0;
    ULONG       ulNewLength = 0;
    SPNG_U8*    pbSrc = NULL;
    SPNG_U8*    pTempBuf = NULL;
    bool        bRC = TRUE;

    // The keyword must be 1 to 79 bytes.

    while ( (ulen > 0) && (iLength < 79) && (*pb != 0) )
    {
        acKeyword[iLength++] = *pb++;
        --ulen;
    }

    // We will bail out if the keyword is over 79 bytes.

    if ( iLength >= 79)
    {
        WARNING(("GpSpngRead--FChunk(),PNGtExt chunk keyword too long"));
        return FALSE;
    }
    
    // Note: after the while loop terminated above, "ulen >= 0".

    if ( bIsCompressed == TRUE )
    {
        // Skip the seperator and the compression method byte
        // Bail out if we don't have enough source bits

        if (ulen <= 2)
        {
            WARNING(("GpSpngRead--FChunk(),PNGtExt chunk keyword missing"));
            return FALSE;
        }

        pb += 2;
        ulen -= 2;
    }
    else
    {
        // Skip the seperator
        // Bail out if we don't have enough source bits

        if (ulen <= 1)
        {
            WARNING(("GpSpngRead--FChunk(),PNGtExt chunk keyword missing"));
            return FALSE;
        }
        
        pb++;
        ulen--;
    }

    // Store the text chunk according to its keyword

    if ( GpMemcmp(acKeyword, "Title", 5) == 0 )
    {
        bRC = GetTextContents(&m_ulTitleLen, &m_pTitleBuf, ulen, pb,
                              bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "Author", 6) == 0 )
    {
        bRC = GetTextContents(&m_ulAuthorLen, &m_pAuthorBuf, ulen, pb,
                              bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "Copyright", 9) == 0 )
    {
        bRC = GetTextContents(&m_ulCopyRightLen, &m_pCopyRightBuf, ulen, pb,
                              bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "Description", 11) == 0 )
    {
        bRC = GetTextContents(&m_ulDescriptionLen, &m_pDescriptionBuf, ulen, pb,
                              bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "CreationTime", 12) == 0 )
    {
        bRC = GetTextContents(&m_ulCreationTimeLen, &m_pCreationTimeBuf, ulen,
                              pb, bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "Software", 8) == 0 )
    {
        bRC = GetTextContents(&m_ulSoftwareLen, &m_pSoftwareBuf, ulen, pb,
                              bIsCompressed);
    }
    else if ( GpMemcmp(acKeyword, "Source", 6) == 0 )
    {
        bRC = GetTextContents(&m_ulDeviceSourceLen, &m_pDeviceSourceBuf, ulen,
                              pb, bIsCompressed);
    }
    else if ( (GpMemcmp(acKeyword, "Comment", 7) == 0)
              ||(GpMemcmp(acKeyword, "Disclaimer", 10) == 0)
              ||(GpMemcmp(acKeyword, "Warning", 7) == 0) )
    {
        bRC = GetTextContents(&m_ulCommentLen, &m_pCommentBuf, ulen, pb,
                              bIsCompressed);
    }

    return bRC;
}// ParseTextChunk()

bool
GpSpngRead::GetTextContents(
    ULONG*          pulLength,
    SPNG_U8**       ppBuf,
    SPNG_U32        ulen,
    const SPNG_U8*  pb,
    bool            bIsCompressed
    )
{
    ULONG       ulFieldLength = *pulLength;
    SPNG_U8*    pFieldBuf = *ppBuf;

    if ( ulFieldLength == 0 )
    {
        // First time see this field

        if ( bIsCompressed == FALSE )
        {
            ulFieldLength = ulen;    // Text chunk length
            pFieldBuf = (SPNG_U8*)GpMalloc(ulFieldLength + 1);

            if ( pFieldBuf == NULL )
            {
                WARNING(("GpSpngRead::GetTextContents---Out of memory"));
                return FALSE;
            }

            GpMemcpy(pFieldBuf, pb, ulFieldLength);
        }// Non-compressed text chunk (tEXt)
        else
        {
            ULONG uiLen = (ulen << 2);
            pFieldBuf = (SPNG_U8*)GpMalloc(uiLen);

            if ( pFieldBuf == NULL )
            {
                WARNING(("GpSpngRead::GetTextContents---Out of memory"));
                return FALSE;
            }

            INT iRC = uncompress(pFieldBuf, &uiLen, pb, ulen);

            // If the return code is Z_MEM_ERROR, it means we didn't allocate
            // enough memory for the decoding result

            while ( iRC == Z_MEM_ERROR )
            {
                // The dest memory we allocated is too small

                GpFree(pFieldBuf);

                // Increment the size by 2 at a time and realloc memory

                uiLen = (uiLen << 1);
                pFieldBuf = (SPNG_U8*)GpMalloc(uiLen);

                if ( pFieldBuf == NULL )
                {
                    WARNING(("GpSpngRead::GetTextContents---Out of memory"));
                    return FALSE;
                }

                // Decompress it again

                iRC = uncompress(pFieldBuf, &uiLen, pb, ulen);
            }

            if ( iRC != Z_OK )
            {
                WARNING(("GpSpng:GetTextContents-uncompress zTXt/tTXt failed"));
                return FALSE;
            }

            // Get the length of the decoded contents

            ulFieldLength = uiLen;
        }// Compressed chunk (zTXt)
    }// First time see this field chunk
    else
    {
        ULONG       ulNewLength = 0;
        SPNG_U8*    pbSrc = NULL;
        SPNG_U8*    pTempBuf = NULL;
        
        // The same field comes again
        // First, change the last char from a \0 to a " "

        pFieldBuf[ulFieldLength - 1] = ' ';

        if ( bIsCompressed == FALSE )
        {
            ulNewLength = ulen;
            pbSrc = (SPNG_U8*)pb;
        }
        else
        {
            ULONG uiLen = (ulen << 2);
            pTempBuf = (SPNG_U8*)GpMalloc(uiLen);

            if ( pTempBuf == NULL )
            {
                WARNING(("GpSpngRead::GetTextContents---Out of memory"));
                return FALSE;
            }

            INT iRC = uncompress(pTempBuf, &uiLen, pb, ulen);

            while ( iRC == Z_MEM_ERROR )
            {
                // The dest memory we allocated is too small

                GpFree(pTempBuf);

                // Increment the size by 2 at time and realloc mem

                uiLen = (uiLen << 1);
                pTempBuf = (SPNG_U8*)GpMalloc(uiLen);

                if ( pTempBuf == NULL )
                {
                    WARNING(("GpSpngRead::GetTextContents---Out of memory"));
                    return FALSE;
                }

                iRC = uncompress(pTempBuf, &uiLen, pb, ulen);
            }

            if ( iRC != Z_OK )
            {
                WARNING(("GpSpng::GetTextContents-uncompress zTXt failed"));
                return FALSE;
            }

            // Get the decoded contents and its length

            ulNewLength = uiLen;
            pbSrc = pTempBuf;
        }// Compressed field chunk (zTXt)

        // Expand the field buffer to the new size

        VOID*  pExpandBuf = GpRealloc(pFieldBuf,
                                      ulFieldLength + ulNewLength + 1);
        if ( pExpandBuf != NULL )
        {
            // Note: GpRealloc() will copy the old contents into "pExpandBuf"
            // before return to us if it succeed

            pFieldBuf = (SPNG_U8*)pExpandBuf;            
        }
        else
        {
            // Note: if the memory expansion failed, we simply return. So we
            // still have all the old contents. The contents buffer will be
            // freed when the destructor is called.

            WARNING(("GpSpngRead::GetTextContents---Out of memory"));
            return FALSE;
        }

        GpMemcpy(pFieldBuf + ulFieldLength, pbSrc, ulNewLength);
        // The length of the new field

        ulFieldLength += ulNewLength;

        if ( pTempBuf != NULL )
        {
            GpFree(pTempBuf);
            pTempBuf = NULL;
        }
    }// Not first time see this field chunk

    // Add a NULL terminator at the end

    pFieldBuf[ulFieldLength] = '\0';
    ulFieldLength++;

    *pulLength = ulFieldLength;
    *ppBuf = pFieldBuf;

    return TRUE;
}// GetTextContents()

GpSpngWrite::GpSpngWrite(
    BITMAPSITE  &bms
    )
    : SPNGWRITE(bms)
{
    // Dummy constructor
    // The reason we need this wrap layer is because a lot of compile and link
    // issues when we provide a static lib to the Office. See Widnows bug#100541
    // and its long email thread for solving this problem
}// Ctor()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\icc34.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/***************************************************************** 
 Copyright (c) 1994-1996 SunSoft, Inc.

                    Rights Reserved

Permission is hereby granted, free of charge, to any person 
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict- 
ion, including without limitation the rights to use, copy, modify, 
merge, publish distribute, sublicense, and/or sell copies of the 
Software, and to permit persons to whom the Software is furnished 
to do so, subject to the following conditions: 
 
The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software. 
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT 
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
OTHER DEALINGS IN THE SOFTWARE. 
 
Except as contained in this notice, the name of SunSoft, Inc. 
shall not be used in advertising or otherwise to promote the 
sale, use or other dealings in this Software without written 
authorization from SunSoft Inc. 
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.4.
 *
 * All header file entries are pre-fixed with "ic" to help 
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array 
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file. 
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.  Note strlen + 1
 * to remember NULL terminator.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes, string_bytes;
        icUcrBg         *ucrBgWrite;
        char            ucr_string[100], *ucr_char;

        strcpy(ucr_string, "Example ucrBG curves");
        ucr_nbytes = sizeof(icUInt32Number) + 
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) + 
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));
        string_bytes = strlen(ucr_string) + 1;

        ucrBgWrite = (icUcrBg *)malloc(
                                (ucr_nbytes + bg_nbytes + string_bytes));
 
        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;
 
        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;

        ucr_char = (char *)((char *)bgCurve + bg_nbytes);
        memcpy(ucr_char, ucr_string, string_bytes);
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370L     /* 'acsp' */
#define icVersionNumber                 0x02100000L     /* 2.1.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000L     /* Bit pos 0 */
#define icPrtrDefaultScreensTrue        0x00000001L     /* Bit pos 0 */
#define icLinesPerInch                  0x00000002L     /* Bit pos 1 */
#define icLinesPerCm                    0x00000000L     /* Bit pos 1 */

/* 
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000L     /* Bit pos 0 */
#define icTransparency                  0x00000001L     /* Bit pos 0 */
#define icGlossy                        0x00000000L     /* Bit pos 1 */
#define icMatte                         0x00000002L     /* Bit pos 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000L     /* Bit pos 0 */
#define icEmbeddedProfileTrue           0x00000001L     /* Bit pos 0 */
#define icUseAnywhere                   0x00000000L     /* Bit pos 1 */
#define icUseWithEmbeddedDataOnly       0x00000002L     /* Bit pos 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000L 
#define icBinaryData                    0x00000001L

/* 
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1


/*------------------------------------------------------------------------*/
/*
 * Use this area to translate platform definitions of long
 * etc into icXXX form. The rest of the header uses the icXXX
 * typedefs. Signatures are 4 byte quantities.
 */
#ifdef __sgi
#include "sgidefs.h"

typedef __int32_t       icSignature;

/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned short  icUInt16Number;
typedef __uint32_t      icUInt32Number;
typedef __uint32_t      icUInt64Number[2];

/* Signed numbers */
typedef char            icInt8Number;
typedef short           icInt16Number;
typedef __int32_t       icInt32Number;
typedef __int32_t       icInt64Number[2];

/* Fixed numbers */
typedef __int32_t       icS15Fixed16Number;
typedef __uint32_t      icU16Fixed16Number;

#else   /* default definitions */

typedef long            icSignature;

/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned short  icUInt16Number;
typedef unsigned long   icUInt32Number;
typedef unsigned long   icUInt64Number[2];

/* Signed numbers */
typedef char            icInt8Number;
typedef short           icInt16Number;
typedef long            icInt32Number;
typedef long            icInt64Number[2];

/* Fixed numbers */
typedef long            icS15Fixed16Number;
typedef unsigned long   icU16Fixed16Number;
#endif  /* default defs */

/*------------------------------------------------------------------------*/
/* public tags and sizes */
typedef enum {
    icSigAToB0Tag                       = 0x41324230L,  /* 'A2B0' */ 
    icSigAToB1Tag                       = 0x41324231L,  /* 'A2B1' */
    icSigAToB2Tag                       = 0x41324232L,  /* 'A2B2' */ 
    icSigBlueColorantTag                = 0x6258595AL,  /* 'bXYZ' */
    icSigBlueTRCTag                     = 0x62545243L,  /* 'bTRC' */
    icSigBToA0Tag                       = 0x42324130L,  /* 'B2A0' */
    icSigBToA1Tag                       = 0x42324131L,  /* 'B2A1' */
    icSigBToA2Tag                       = 0x42324132L,  /* 'B2A2' */
    icSigCalibrationDateTimeTag         = 0x63616C74L,  /* 'calt' */
    icSigCharTargetTag                  = 0x74617267L,  /* 'targ' */ 
    icSigCopyrightTag                   = 0x63707274L,  /* 'cprt' */
    icSigCrdInfoTag                     = 0x63726469L,  /* 'crdi' */
    icSigDeviceMfgDescTag               = 0x646D6E64L,  /* 'dmnd' */
    icSigDeviceModelDescTag             = 0x646D6464L,  /* 'dmdd' */
    icSigGamutTag                       = 0x67616D74L,  /* 'gamt ' */
    icSigGrayTRCTag                     = 0x6b545243L,  /* 'kTRC' */
    icSigGreenColorantTag               = 0x6758595AL,  /* 'gXYZ' */
    icSigGreenTRCTag                    = 0x67545243L,  /* 'gTRC' */
    icSigLuminanceTag                   = 0x6C756d69L,  /* 'lumi' */
    icSigMeasurementTag                 = 0x6D656173L,  /* 'meas' */
    icSigMediaBlackPointTag             = 0x626B7074L,  /* 'bkpt' */
    icSigMediaWhitePointTag             = 0x77747074L,  /* 'wtpt' */
    icSigNamedColorTag                  = 0x6E636f6CL,  /* 'ncol' 
                                                         * OBSOLETE, use ncl2 */
    icSigNamedColor2Tag                 = 0x6E636C32L,  /* 'ncl2' */
    icSigPreview0Tag                    = 0x70726530L,  /* 'pre0' */
    icSigPreview1Tag                    = 0x70726531L,  /* 'pre1' */
    icSigPreview2Tag                    = 0x70726532L,  /* 'pre2' */
    icSigProfileDescriptionTag          = 0x64657363L,  /* 'desc' */
    icSigProfileSequenceDescTag         = 0x70736571L,  /* 'pseq' */
    icSigPs2CRD0Tag                     = 0x70736430L,  /* 'psd0' */
    icSigPs2CRD1Tag                     = 0x70736431L,  /* 'psd1' */
    icSigPs2CRD2Tag                     = 0x70736432L,  /* 'psd2' */
    icSigPs2CRD3Tag                     = 0x70736433L,  /* 'psd3' */
    icSigPs2CSATag                      = 0x70733273L,  /* 'ps2s' */
    icSigPs2RenderingIntentTag          = 0x70733269L,  /* 'ps2i' */
    icSigRedColorantTag                 = 0x7258595AL,  /* 'rXYZ' */
    icSigRedTRCTag                      = 0x72545243L,  /* 'rTRC' */
    icSigScreeningDescTag               = 0x73637264L,  /* 'scrd' */
    icSigScreeningTag                   = 0x7363726EL,  /* 'scrn' */
    icSigTechnologyTag                  = 0x74656368L,  /* 'tech' */
    icSigUcrBgTag                       = 0x62666420L,  /* 'bfd ' */
    icSigViewingCondDescTag             = 0x76756564L,  /* 'vued' */
    icSigViewingConditionsTag           = 0x76696577L,  /* 'view' */
    icMaxEnumTag                        = 0xFFFFFFFFL 
} icTagSignature;

/* technology signature descriptions */
typedef enum {
    icSigDigitalCamera                  = 0x6463616DL,  /* 'dcam' */
    icSigFilmScanner                    = 0x6673636EL,  /* 'fscn' */
    icSigReflectiveScanner              = 0x7273636EL,  /* 'rscn' */
    icSigInkJetPrinter                  = 0x696A6574L,  /* 'ijet' */ 
    icSigThermalWaxPrinter              = 0x74776178L,  /* 'twax' */
    icSigElectrophotographicPrinter     = 0x6570686FL,  /* 'epho' */
    icSigElectrostaticPrinter           = 0x65737461L,  /* 'esta' */
    icSigDyeSublimationPrinter          = 0x64737562L,  /* 'dsub' */
    icSigPhotographicPaperPrinter       = 0x7270686FL,  /* 'rpho' */
    icSigFilmWriter                     = 0x6670726EL,  /* 'fprn' */
    icSigVideoMonitor                   = 0x7669646DL,  /* 'vidm' */
    icSigVideoCamera                    = 0x76696463L,  /* 'vidc' */
    icSigProjectionTelevision           = 0x706A7476L,  /* 'pjtv' */
    icSigCRTDisplay                     = 0x43525420L,  /* 'CRT ' */
    icSigPMDisplay                      = 0x504D4420L,  /* 'PMD ' */
    icSigAMDisplay                      = 0x414D4420L,  /* 'AMD ' */
    icSigPhotoCD                        = 0x4B504344L,  /* 'KPCD' */
    icSigPhotoImageSetter               = 0x696D6773L,  /* 'imgs' */
    icSigGravure                        = 0x67726176L,  /* 'grav' */
    icSigOffsetLithography              = 0x6F666673L,  /* 'offs' */
    icSigSilkscreen                     = 0x73696C6BL,  /* 'silk' */
    icSigFlexography                    = 0x666C6578L,  /* 'flex' */
    icMaxEnumTechnology                 = 0xFFFFFFFFL   
} icTechnologySignature;

/* type signatures */
typedef enum {
    icSigCurveType                      = 0x63757276L,  /* 'curv' */
    icSigDataType                       = 0x64617461L,  /* 'data' */
    icSigDateTimeType                   = 0x6474696DL,  /* 'dtim' */
    icSigLut16Type                      = 0x6d667432L,  /* 'mft2' */
    icSigLut8Type                       = 0x6d667431L,  /* 'mft1' */
    icSigMeasurementType                = 0x6D656173L,  /* 'meas' */
    icSigNamedColorType                 = 0x6E636f6CL,  /* 'ncol' 
                                                         * OBSOLETE, use ncl2 */
    icSigProfileSequenceDescType        = 0x70736571L,  /* 'pseq' */
    icSigS15Fixed16ArrayType            = 0x73663332L,  /* 'sf32' */
    icSigScreeningType                  = 0x7363726EL,  /* 'scrn' */
    icSigSignatureType                  = 0x73696720L,  /* 'sig ' */
    icSigTextType                       = 0x74657874L,  /* 'text' */
    icSigTextDescriptionType            = 0x64657363L,  /* 'desc' */
    icSigU16Fixed16ArrayType            = 0x75663332L,  /* 'uf32' */
    icSigUcrBgType                      = 0x62666420L,  /* 'bfd ' */
    icSigUInt16ArrayType                = 0x75693136L,  /* 'ui16' */
    icSigUInt32ArrayType                = 0x75693332L,  /* 'ui32' */
    icSigUInt64ArrayType                = 0x75693634L,  /* 'ui64' */
    icSigUInt8ArrayType                 = 0x75693038L,  /* 'ui08' */
    icSigViewingConditionsType          = 0x76696577L,  /* 'view' */
    icSigXYZType                        = 0x58595A20L,  /* 'XYZ ' */
    icSigXYZArrayType                   = 0x58595A20L,  /* 'XYZ ' */
    icSigNamedColor2Type                = 0x6E636C32L,  /* 'ncl2' */
    icSigCrdInfoType                    = 0x63726469L,  /* 'crdi' */
    icMaxEnumType                       = 0xFFFFFFFFL   
} icTagTypeSignature;

/* 
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */ 
typedef enum {
    icSigXYZData                        = 0x58595A20L,  /* 'XYZ ' */
    icSigLabData                        = 0x4C616220L,  /* 'Lab ' */
    icSigLuvData                        = 0x4C757620L,  /* 'Luv ' */
    icSigYCbCrData                      = 0x59436272L,  /* 'YCbr' */
    icSigYxyData                        = 0x59787920L,  /* 'Yxy ' */
    icSigRgbData                        = 0x52474220L,  /* 'RGB ' */
    icSigGrayData                       = 0x47524159L,  /* 'GRAY' */
    icSigHsvData                        = 0x48535620L,  /* 'HSV ' */
    icSigHlsData                        = 0x484C5320L,  /* 'HLS ' */
    icSigCmykData                       = 0x434D594BL,  /* 'CMYK' */
    icSigCmyData                        = 0x434D5920L,  /* 'CMY ' */
    icSig2colorData                     = 0x32434C52L,  /* '2CLR' */
    icSig3colorData                     = 0x33434C52L,  /* '3CLR' */
    icSig4colorData                     = 0x34434C52L,  /* '4CLR' */
    icSig5colorData                     = 0x35434C52L,  /* '5CLR' */
    icSig6colorData                     = 0x36434C52L,  /* '6CLR' */
    icSig7colorData                     = 0x37434C52L,  /* '7CLR' */
    icSig8colorData                     = 0x38434C52L,  /* '8CLR' */
    icSig9colorData                     = 0x39434C52L,  /* '9CLR' */
    icSig10colorData                    = 0x41434C52L,  /* 'ACLR' */
    icSig11colorData                    = 0x42434C52L,  /* 'BCLR' */
    icSig12colorData                    = 0x43434C52L,  /* 'CCLR' */
    icSig13colorData                    = 0x44434C52L,  /* 'DCLR' */
    icSig14colorData                    = 0x45434C52L,  /* 'ECLR' */
    icSig15colorData                    = 0x46434C52L,  /* 'FCLR' */
    icMaxEnumData                       = 0xFFFFFFFFL   
} icColorSpaceSignature;

/* profileClass enumerations */
typedef enum {
    icSigInputClass                     = 0x73636E72L,  /* 'scnr' */
    icSigDisplayClass                   = 0x6D6E7472L,  /* 'mntr' */
    icSigOutputClass                    = 0x70727472L,  /* 'prtr' */
    icSigLinkClass                      = 0x6C696E6BL,  /* 'link' */
    icSigAbstractClass                  = 0x61627374L,  /* 'abst' */
    icSigColorSpaceClass                = 0x73706163L,  /* 'spac' */
    icSigNamedColorClass                = 0x6e6d636cL,  /* 'nmcl' */
    icMaxEnumClass                      = 0xFFFFFFFFL  
} icProfileClassSignature;

/* Platform Signatures */
typedef enum {
    icSigMacintosh                      = 0x4150504CL,  /* 'APPL' */
    icSigMicrosoft                      = 0x4D534654L,  /* 'MSFT' */
    icSigSolaris                        = 0x53554E57L,  /* 'SUNW' */
    icSigSGI                            = 0x53474920L,  /* 'SGI ' */
    icSigTaligent                       = 0x54474E54L,  /* 'TGNT' */
    icMaxEnumPlatform                   = 0xFFFFFFFFL  
} icPlatformSignature;

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef enum {
    icFlare0                            = 0x00000000L,  /* 0% flare */
    icFlare100                          = 0x00000001L,  /* 100% flare */
    icMaxFlare                          = 0xFFFFFFFFL   
} icMeasurementFlare;

/* Measurement Geometry, used in the measurmentType tag */
typedef enum {
    icGeometryUnknown                   = 0x00000000L,  /* Unknown */
    icGeometry045or450                  = 0x00000001L,  /* 0/45, 45/0 */
    icGeometry0dord0                    = 0x00000002L,  /* 0/d or d/0 */
    icMaxGeometry                       = 0xFFFFFFFFL   
} icMeasurementGeometry;

/* Rendering Intents, used in the profile header */
typedef enum {
    icPerceptual                        = 0,
    icRelativeColorimetric              = 1,
    icSaturation                        = 2,
    icAbsoluteColorimetric              = 3,
    icMaxEnumIntent                     = 0xFFFFFFFFL   
} icRenderingIntent;

/* Different Spot Shapes currently defined, used for screeningType */
typedef enum {
    icSpotShapeUnknown                  = 0,
    icSpotShapePrinterDefault           = 1,
    icSpotShapeRound                    = 2,
    icSpotShapeDiamond                  = 3,
    icSpotShapeEllipse                  = 4,
    icSpotShapeLine                     = 5,
    icSpotShapeSquare                   = 6,
    icSpotShapeCross                    = 7,
    icMaxEnumSpot                       = 0xFFFFFFFFL   
} icSpotShape;

/* Standard Observer, used in the measurmentType tag */
typedef enum {
    icStdObsUnknown                     = 0x00000000L,  /* Unknown */
    icStdObs1931TwoDegrees              = 0x00000001L,  /* 2 deg */
    icStdObs1964TenDegrees              = 0x00000002L,  /* 10 deg */
    icMaxStdObs                         = 0xFFFFFFFFL   
} icStandardObserver;

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef enum {
    icIlluminantUnknown                 = 0x00000000L,
    icIlluminantD50                     = 0x00000001L,
    icIlluminantD65                     = 0x00000002L,
    icIlluminantD93                     = 0x00000003L,
    icIlluminantF2                      = 0x00000004L,
    icIlluminantD55                     = 0x00000005L,
    icIlluminantA                       = 0x00000006L,
    icIlluminantEquiPowerE              = 0x00000007L,  
    icIlluminantF8                      = 0x00000008L,  
    icMaxEnumIluminant                  = 0xFFFFFFFFL   
} icIlluminant;


/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers 
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;
    
/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         * Interpretation depends on how
                                         * data is used with a given tag
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */    
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */    
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */ 
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */    
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Num of in-table entries */
    icUInt16Number      outputEnt;      /* Num of out-table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The in-table
 *  icUInt16Number      clutTable[icAny];               * The clut 
 *  icUInt16Number      outputTable[outputChan][icAny]; * The out-table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Num of input channels */
    icUInt8Number       outputChan;     /* Num of output channels */
    icUInt8Number       clutPoints;     /* Num of grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */    
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */    
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */ 
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */    
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The in-table
 *  icUInt8Number       clutTable[icAny];               * The clut 
 *  icUInt8Number       outputTable[outputChan][256];   * The out-table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing */
    icMeasurementGeometry       geometry;       /* Meas. geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */

/*
 * icNamedColor2 takes the place of icNamedColor 
 */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icUInt32Number      nDeviceCoords;  /* Num of device coordinates */
    icInt8Number        prefix[32];     /* Prefix for each color name */
    icInt8Number        suffix[32];     /* Suffix for each color name */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         root1[32];              * Root name for 1st color
 * icUInt16Number       pcsCoords1[icAny];      * PCS coords of 1st color
 * icUInt16Number       deviceCoords1[icAny];   * Dev coords of 1st color
 * icInt8Number         root2[32];              * Root name for 2nd color
 * icUInt16Number       pcsCoords2[icAny];      * PCS coords of 2nd color
 * icUInt16Number       deviceCoords2[icAny];   * Dev coords of 2nd color
 *                      :
 *                      :
 * Repeat for name and PCS and device color coordinates up to (count-1)
 * 
 * NOTES:  
 * PCS and device space can be determined from the header.
 *
 * PCS coordinates are icUInt16 numbers and are described in Annex A of 
 * the ICC spec. Only 16 bit L*a*b* and XYZ are allowed. The number of 
 * coordinates is consistent with the headers PCS.
 *
 * Device coordinates are icUInt16 numbers where 0x0000 represents
 * the minimum value and 0xFFFF represents the maximum value. 
 * If the nDeviceCoords value is 0 this field is not given.
 */
} icNamedColor2;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Dev Manufacturer */
    icSignature                 deviceModel;    /* Dev Model */
    icUInt64Number              attributes;     /* Dev attributes */
    icTechnologySignature       technology;     /* Technology sig */
    icInt8Number                data[icAny];    /* Desc text follows */
/*
 *  Data that follows is of this form, this is an icInt8Number
 *  to avoid problems with a compiler generating  bad code as 
 *  these arrays are variable in length.
 *
 * icTextDescription            deviceMfgDesc;  * Manufacturer text
 * icTextDescription            modelDesc;      * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icUInt8Number       data[icAny];    /* Array of desc structs */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[count]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt16Number        ucDesc[ucCount];* The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[67];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of chars */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icInt8Number        data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form, this is a icInt8Number
 *  to avoid problems with a compiler generating  bad code as 
 *  these arrays are variable in length.
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 * icInt8Number         string;         * UcrBg description
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per sq. meter */
    icXYZNumber         surround;       /* In candelas per sq. meter */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;

/* CrdInfo type */
typedef struct {
    icUInt32Number      count;          /* Char count includes NULL */
    icInt8Number        desc[icAny];    /* Null terminated string */
} icCrdInfo;

/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
/* icNamedColor2Type, replaces icNamedColorType */
typedef struct {
    icTagBase           base;           /* Signature, "ncl2" */
    icNamedColor2       ncolor;         /* Named color data */
} icNamedColor2Type;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;   /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of chars */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;
    
/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ nums */
} icXYZType;

/* CRDInfoType where [0] is the CRD product name count and string and
 * [1] -[5] are the rendering intents 0-4 counts and strings
 */
typedef struct {
    icTagBase           base;           /* Signature, "crdi" */
    icCrdInfo           info;           /* 5 sets of counts & strings */
}icCrdInfoType;
     /*   icCrdInfo       productName;     PS product count/string */
     /*   icCrdInfo       CRDName0;        CRD name for intent 0 */ 
     /*   icCrdInfo       CRDName1;        CRD name for intent 1 */ 
     /*   icCrdInfo       CRDName2;        CRD name for intent 2 */ 
     /*   icCrdInfo       CRDName3;        CRD name for intent 3 */
    
/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile structure
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to 
                                         * start of header, Spec 
                                         * Clause 5 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Num tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Prof size in bytes */
    icSignature                 cmmId;          /* CMM for profile */
    icUInt32Number              version;        /* Format version */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Clr space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab */
    icDateTimeNumber            date;           /* Creation Date */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bits */
    icSignature                 manufacturer;   /* Dev manufacturer */
    icUInt32Number              model;          /* Dev model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icSignature                 creator;        /* Profile creator */
    icInt8Number                reserved[44];   /* Reserved */
} icHeader;

/* 
 * A profile, 
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Num tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table 
 * icInt8Number tagData[icAny];         * The tag data 
 */
} icProfile;           

/*------------------------------------------------------------------------*/
/* Obsolete entries */

/* icNamedColor was replaced with icNamedColor2 */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix 
 * icInt8Number         suffix[icAny];  * Suffix 
 * icInt8Number         root1[icAny];   * Root name 
 * icInt8Number         coords1[icAny]; * Color coordinates 
 * icInt8Number         root2[icAny];   * Root name 
 * icInt8Number         coords2[icAny]; * Color coordinates 
 *                      :
 *                      :
 * Repeat for root name and color coordinates up to (count-1)
 */
} icNamedColor;

/* icNamedColorType was replaced by icNamedColor2Type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

#endif /* ICC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\avgmmxdefilter.cpp ===
/*******************************************************************************

SPNGREAD::avgMMXUnfilter : unfilters one row of a decompressed PNG image using
						   the AVG algorithm of method 0 defiltering.

  Assumptions:	The row to be defiltered was filtered with the AVG algorithm
				Row is 8-byte aligned in memory (performance issue)
				First byte of a row stores the defiltering code
				The indicated length of the row includes the defiltering byte

  Algorithm:	To Be Documented

*******************************************************************************/
#include <stdlib.h>
#include "spngread.h"

void SPNGREAD::avgMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev, SPNG_U32 cbRow, SPNG_U32 cbpp)
{
#if defined(_X86_)
	union uAll
		{
		__int64 use;
		double  align;
		}
	LBCarryMask = {0x0101010101010101}, HBClearMask = {0x7f7f7f7f7f7f7f7f},
		ActiveMask, ShiftBpp, ShiftRem;


    const SPNG_U8 *prev_row = pbPrev;
    SPNG_U8 *row = pbRow;
    int bpp;

    SPNG_U32 FullLength;
    SPNG_U32 MMXLength;
    int diff;

    bpp = (cbpp + 7) >> 3; // Get # bytes per pixel
    FullLength  = cbRow; // # of bytes to filter

    _asm {
     // Init address pointers and offset
     mov edi, row                  // edi ==> Avg(x)
     xor ebx, ebx                  // ebx ==> x
     mov edx, edi
     mov esi, prev_row             // esi ==> Prior(x)
     sub edx, bpp                  // edx ==> Raw(x-bpp)
     
     xor eax, eax
     // Compute the Raw value for the first bpp bytes
     //    Raw(x) = Avg(x) + (Prior(x)/2)
davgrlp:
     mov al, [esi + ebx]           // Load al with Prior(x)
     inc ebx
     shr al, 1                     // divide by 2
     add al, [edi+ebx-1]           // Add Avg(x); -1 to offset inc ebx
     cmp ebx, bpp
     mov [edi+ebx-1], al        // Write back Raw(x);
                                // mov does not affect flags; -1 to offset inc ebx
     jb davgrlp


     // get # of bytes to alignment
     mov diff, edi              // take start of row
     add diff, ebx              // add bpp
     add diff, 0xf              // add 7 + 8 to incr past alignment boundary
     and diff, 0xfffffff8       // mask to alignment boundary
     sub diff, edi              // subtract from start ==> value ebx at alignment
     jz davggo

     // fix alignment
     // Compute the Raw value for the bytes upto the alignment boundary
     //    Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
     xor ecx, ecx
davglp1:
     xor eax, eax
        mov cl, [esi + ebx]        // load cl with Prior(x)
     mov al, [edx + ebx]        // load al with Raw(x-bpp)
     add ax, cx
        inc ebx
     shr ax, 1                  // divide by 2
     add al, [edi+ebx-1]           // Add Avg(x); -1 to offset inc ebx
        cmp ebx, diff              // Check if at alignment boundary
       mov [edi+ebx-1], al        // Write back Raw(x);
                                // mov does not affect flags; -1 to offset inc ebx
        jb davglp1                // Repeat until at alignment boundary

davggo:
        mov eax, FullLength

     mov ecx, eax
     sub eax, ebx                  // subtract alignment fix
     and eax, 0x00000007           // calc bytes over mult of 8

     sub ecx, eax                  // drop over bytes from original length
     mov MMXLength, ecx

} // end _asm block


  // Now do the math for the rest of the row
  switch ( bpp )
  {
  case 3:
    {
     ActiveMask.use  = 0x0000000000ffffff;  
     ShiftBpp.use = 24;          // == 3 * 8
     ShiftRem.use = 40;           // == 64 - 24

     _asm {
        // Re-init address pointers and offset
        movq mm7, ActiveMask 
        mov ebx, diff                 // ebx ==> x = offset to alignment boundary
        movq mm5, LBCarryMask 
        mov edi, row                  // edi ==> Avg(x)
        movq mm4, HBClearMask
           mov esi, prev_row             // esi ==> Prior(x)

        // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes 
                                   // (we correct position in loop below) 
davg3lp:
            movq mm0, [edi + ebx]      // Load mm0 with Avg(x)
        // Add (Prev_row/2) to Average
        movq mm3, mm5
        psrlq mm2, ShiftRem      // Correct position Raw(x-bpp) data
            movq mm1, [esi + ebx]      // Load mm1 with Prior(x)
        movq mm6, mm7

        pand mm3, mm1              // get lsb for each prev_row byte

        psrlq mm1, 1               // divide prev_row bytes by 2
        pand  mm1, mm4             // clear invalid bit 7 of each byte

            paddb mm0, mm1             // add (Prev_row/2) to Avg for each byte

        // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
        movq mm1, mm3              // now use mm1 for getting LBCarrys
        pand mm1, mm2              // get LBCarrys for each byte where both
                                   // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1               // divide raw bytes by 2
        pand  mm2, mm4             // clear invalid bit 7 of each byte

        paddb mm2, mm1             // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6              // Leave only Active Group 1 bytes to add to Avg

            paddb mm0, mm2             // add (Raw/2) + LBCarrys to Avg for each Active byte

        // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
        psllq mm6, ShiftBpp    // shift the mm6 mask to cover bytes 3-5

        movq mm2, mm0              // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly

        movq mm1, mm3              // now use mm1 for getting LBCarrys
        pand mm1, mm2              // get LBCarrys for each byte where both
                                   // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1               // divide raw bytes by 2
        pand  mm2, mm4             // clear invalid bit 7 of each byte

        paddb mm2, mm1             // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6              // Leave only Active Group 2 bytes to add to Avg

            paddb mm0, mm2             // add (Raw/2) + LBCarrys to Avg for each Active byte
       
        // Add 3rd active group (Raw(x-bpp)/2) to Average with LBCarry
        psllq mm6, ShiftBpp    // shift the mm6 mask to cover the last two bytes

        movq mm2, mm0              // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly
                                   // Data only needs to be shifted once here to
                                   // get the correct x-bpp offset.

        movq mm1, mm3              // now use mm1 for getting LBCarrys
        pand mm1, mm2              // get LBCarrys for each byte where both
                                   // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1               // divide raw bytes by 2
        pand  mm2, mm4             // clear invalid bit 7 of each byte

        paddb mm2, mm1             // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6              // Leave only Active Group 2 bytes to add to Avg

            add ebx, 8
            paddb mm0, mm2             // add (Raw/2) + LBCarrys to Avg for each Active byte
       
        // Now ready to write back to memory
            movq [edi + ebx - 8], mm0

        // Move updated Raw(x) to use as Raw(x-bpp) for next loop
            cmp ebx, MMXLength

        movq mm2, mm0              // mov updated Raw(x) to mm2
            jb davg3lp

        } // end _asm block
  }
  break;

  case 6:
  case 4:
  case 7:
  case 5:
    {
     ActiveMask.use  = 0xffffffffffffffff;  // use shift below to clear
                                                // appropriate inactive bytes
     ShiftBpp.use = bpp << 3;
     ShiftRem.use = 64 - ShiftBpp.use;

        _asm {
        movq mm4, HBClearMask
        // Re-init address pointers and offset
        mov ebx, diff                 // ebx ==> x = offset to alignment boundary
        // Load ActiveMask and clear all bytes except for 1st active group
        movq mm7, ActiveMask
        mov edi, row                  // edi ==> Avg(x)
        psrlq mm7, ShiftRem
           mov esi, prev_row             // esi ==> Prior(x)


        movq mm6, mm7
        movq mm5, LBCarryMask 
        psllq mm6, ShiftBpp    // Create mask for 2nd active group

        // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes 
                                   // (we correct position in loop below) 
davg4lp:
            movq mm0, [edi + ebx]
        psrlq mm2, ShiftRem       // shift data to position correctly
            movq mm1, [esi + ebx]

        // Add (Prev_row/2) to Average
        movq mm3, mm5
        pand mm3, mm1              // get lsb for each prev_row byte

        psrlq mm1, 1               // divide prev_row bytes by 2
        pand  mm1, mm4             // clear invalid bit 7 of each byte

            paddb mm0, mm1             // add (Prev_row/2) to Avg for each byte

        // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
        movq mm1, mm3              // now use mm1 for getting LBCarrys
        pand mm1, mm2              // get LBCarrys for each byte where both
                                   // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1               // divide raw bytes by 2
        pand  mm2, mm4             // clear invalid bit 7 of each byte

        paddb mm2, mm1             // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm7              // Leave only Active Group 1 bytes to add to Avg

            paddb mm0, mm2             // add (Raw/2) + LBCarrys to Avg for each Active byte

        // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
        movq mm2, mm0              // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly

            add ebx, 8
        movq mm1, mm3              // now use mm1 for getting LBCarrys
        pand mm1, mm2              // get LBCarrys for each byte where both
                                   // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1               // divide raw bytes by 2
        pand  mm2, mm4             // clear invalid bit 7 of each byte

        paddb mm2, mm1             // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6              // Leave only Active Group 2 bytes to add to Avg

            paddb mm0, mm2             // add (Raw/2) + LBCarrys to Avg for each Active byte

            cmp ebx, MMXLength
        // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
        // Prep Raw(x-bpp) for next loop
        movq mm2, mm0              // mov updated Raws to mm2
            jb davg4lp
        } // end _asm block
  }
  break;

  case 2:
    {
     ActiveMask.use  = 0x000000000000ffff;  
     ShiftBpp.use = 16;           // == 2 * 8
     ShiftRem.use = 48;           // == 64 - 16

        _asm {
        // Load ActiveMask
        movq mm7, ActiveMask 
        // Re-init address pointers and offset
        mov ebx, diff             // ebx ==> x = offset to alignment boundary
        movq mm5, LBCarryMask 
        mov edi, row              // edi ==> Avg(x)
        movq mm4, HBClearMask
           mov esi, prev_row      // esi ==> Prior(x)


        // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes 
                                   // (we correct position in loop below) 
davg2lp:
            movq mm0, [edi + ebx]
        psrlq mm2, ShiftRem    // shift data to position correctly
            movq mm1, [esi + ebx]

        // Add (Prev_row/2) to Average
        movq mm3, mm5
        pand mm3, mm1          // get lsb for each prev_row byte

        psrlq mm1, 1           // divide prev_row bytes by 2
        pand  mm1, mm4         // clear invalid bit 7 of each byte
        movq mm6, mm7

            paddb mm0, mm1     // add (Prev_row/2) to Avg for each byte

        // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
        movq mm1, mm3          // now use mm1 for getting LBCarrys
        pand mm1, mm2          // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1           // divide raw bytes by 2
        pand  mm2, mm4         // clear invalid bit 7 of each byte

        paddb mm2, mm1         // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6          // Leave only Active Group 1 bytes to add to Avg

            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active byte

        // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
        psllq mm6, ShiftBpp    // shift the mm6 mask to cover bytes 2 & 3

        movq mm2, mm0          // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly

        movq mm1, mm3          // now use mm1 for getting LBCarrys
        pand mm1, mm2          // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1           // divide raw bytes by 2
        pand  mm2, mm4         // clear invalid bit 7 of each byte

        paddb mm2, mm1         // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6          // Leave only Active Group 2 bytes to add to Avg

            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active byte
       
        // Add rdd active group (Raw(x-bpp)/2) to Average with LBCarry
        psllq mm6, ShiftBpp    // shift the mm6 mask to cover bytes 4 & 5

        movq mm2, mm0          // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly
                               // Data only needs to be shifted once here to
                               // get the correct x-bpp offset.

        movq mm1, mm3          // now use mm1 for getting LBCarrys
        pand mm1, mm2          // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)

        psrlq mm2, 1           // divide raw bytes by 2
        pand  mm2, mm4         // clear invalid bit 7 of each byte

        paddb mm2, mm1         // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6          // Leave only Active Group 2 bytes to add to Avg

            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active byte
       
        // Add 4th active group (Raw(x-bpp)/2) to Average with LBCarry
        psllq mm6, ShiftBpp    // shift the mm6 mask to cover bytes 6 & 7

        movq mm2, mm0          // mov updated Raws to mm2
        psllq mm2, ShiftBpp    // shift data to position correctly
                               // Data only needs to be shifted once here to
                               // get the correct x-bpp offset.
            add ebx, 8
        movq mm1, mm3          // now use mm1 for getting LBCarrys
        pand mm1, mm2          // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)
        psrlq mm2, 1           // divide raw bytes by 2
        pand  mm2, mm4         // clear invalid bit 7 of each byte

        paddb mm2, mm1         // add LBCarrys to (Raw(x-bpp)/2) for each byte

        pand mm2, mm6          // Leave only Active Group 2 bytes to add to Avg

            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active byte
       
            cmp ebx, MMXLength
        // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
        // Prep Raw(x-bpp) for next loop
        movq mm2, mm0              // mov updated Raws to mm2
            jb davg2lp
        } // end _asm block
  }
  break;

  case 1:                       // bpp == 1
    {
     _asm {
        // Re-init address pointers and offset
        mov ebx, diff           // ebx ==> x = offset to alignment boundary
        mov edi, row            // edi ==> Avg(x)
        cmp ebx, FullLength     // Test if offset at end of array
           jnb davg1end

        // Do Paeth decode for remaining bytes
           mov esi, prev_row   // esi ==> Prior(x)   
        mov edx, edi
        xor ecx, ecx           // zero ecx before using cl & cx in loop below
        sub edx, bpp           // edx ==> Raw(x-bpp)
davg1lp:
        // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
        xor eax, eax
          mov cl, [esi + ebx]  // load cl with Prior(x)
        mov al, [edx + ebx]    // load al with Raw(x-bpp)
        add ax, cx
          inc ebx
        shr ax, 1              // divide by 2
        add al, [edi+ebx-1]    // Add Avg(x); -1 to offset inc ebx
          cmp ebx, FullLength  // Check if at end of array
          mov [edi+ebx-1], al  // Write back Raw(x);
                              // mov does not affect flags; -1 to offset inc ebx
           jb davg1lp

davg1end:
       } // end _asm block
    } 
  return;

  case 8:                          // bpp == 8
    {
        _asm {
        // Re-init address pointers and offset
        mov ebx, diff              // ebx ==> x = offset to alignment boundary
        movq mm5, LBCarryMask 
        mov edi, row               // edi ==> Avg(x)
        movq mm4, HBClearMask
           mov esi, prev_row       // esi ==> Prior(x)


        // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes 
                              // (NO NEED to correct position in loop below) 
davg8lp:
            movq mm0, [edi + ebx]
        movq mm3, mm5
            movq mm1, [esi + ebx]

            add ebx, 8
        pand mm3, mm1         // get lsb for each prev_row byte

        psrlq mm1, 1          // divide prev_row bytes by 2
        pand mm3, mm2         // get LBCarrys for each byte where both
                              // lsb's were == 1

        psrlq mm2, 1          // divide raw bytes by 2
        pand  mm1, mm4        // clear invalid bit 7 of each byte

        paddb mm0, mm3        // add LBCarrys to Avg for each byte

        pand  mm2, mm4        // clear invalid bit 7 of each byte

        paddb mm0, mm1        // add (Prev_row/2) to Avg for each byte

            paddb mm0, mm2    // add (Raw/2) to Avg for each byte


            cmp ebx, MMXLength

            movq [edi + ebx - 8], mm0
        movq mm2, mm0         // reuse as Raw(x-bpp)
            jb davg8lp
        } // end _asm block
    } 
  break;

  default:                    // bpp greater than 8
    {
        _asm {
        movq mm5, LBCarryMask 
        // Re-init address pointers and offset
        mov ebx, diff         // ebx ==> x = offset to alignment boundary
        mov edi, row          // edi ==> Avg(x)
        movq mm4, HBClearMask
        mov edx, edi
           mov esi, prev_row  // esi ==> Prior(x)
        sub edx, bpp          // edx ==> Raw(x-bpp)

davgAlp:
            movq mm0, [edi + ebx]
        movq mm3, mm5
            movq mm1, [esi + ebx]

        pand mm3, mm1         // get lsb for each prev_row byte
            movq mm2, [edx + ebx]

        psrlq mm1, 1          // divide prev_row bytes by 2
        pand mm3, mm2         // get LBCarrys for each byte where both
                              // lsb's were == 1

        psrlq mm2, 1          // divide raw bytes by 2
        pand  mm1, mm4        // clear invalid bit 7 of each byte

        paddb mm0, mm3        // add LBCarrys to Avg for each byte

        pand  mm2, mm4        // clear invalid bit 7 of each byte

        paddb mm0, mm1        // add (Prev_row/2) to Avg for each byte

            add ebx, 8
            paddb mm0, mm2    // add (Raw/2) to Avg for each byte

            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm0
            jb davgAlp
        } // end _asm block
    } 
  break;
  }                           // end switch ( bpp )

  
  _asm {
     // MMX acceleration complete now do clean-up
     // Check if any remaining bytes left to decode
        mov ebx, MMXLength    // ebx ==> x = offset bytes remaining after MMX
        mov edi, row          // edi ==> Avg(x) 
        cmp ebx, FullLength   // Test if offset at end of array
        jnb davgend

     // Do Paeth decode for remaining bytes
        mov esi, prev_row     // esi ==> Prior(x)   
     mov edx, edi
     xor ecx, ecx             // zero ecx before using cl & cx in loop below
     sub edx, bpp             // edx ==> Raw(x-bpp)
davglp2:
     // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
     xor eax, eax
        mov cl, [esi + ebx]   // load cl with Prior(x)
     mov al, [edx + ebx]      // load al with Raw(x-bpp)
     add ax, cx
        inc ebx
     shr ax, 1                // divide by 2
     add al, [edi+ebx-1]      // Add Avg(x); -1 to offset inc ebx
        cmp ebx, FullLength        // Check if at end of array
       mov [edi+ebx-1], al    // Write back Raw(x);
                              // mov does not affect flags; -1 to offset inc ebx
        jb davglp2

davgend:
        emms               // End MMX instructions; prep for possible FP instrs.
    } // end _asm block
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\paethmmxdefilter.cpp ===
/*******************************************************************************

SPNGREAD::paethMMXUnfilter : unfilters one row of a decompressed PNG image using
						   the PAETH algorithm of method 0 defiltering.

  Assumptions:	The row to be defiltered was filtered with the PAETH algorithm
				Row is 8-byte aligned in memory (performance issue)
				First byte of a row stores the defiltering code
				The indicated length of the row includes the defiltering byte

  Algorithm:	To Be Documented

*******************************************************************************/
#include <stdlib.h>
#include "spngread.h"

void SPNGREAD::paethMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev, 
                                SPNG_U32 cbRow, SPNG_U32 cbpp)
{
#if defined(_X86_)
	union uAll
		{
		__int64 use;
		double  align;
		}
	pActiveMask, pActiveMask2, pActiveMaskEnd, pShiftBpp, pShiftRem;

		SPNG_U32 FullLength;
		SPNG_U32 MMXLength;

        const SPNG_U8 *prev_row = pbPrev;
		SPNG_U8 *row = pbRow;
		int bpp;
		int diff;
		int patemp, pbtemp, pctemp;

		bpp = (cbpp + 7) >> 3; // Get # bytes per pixel
		FullLength  = cbRow; // # of bytes to filter

		_asm {
         xor ebx, ebx                  // ebx ==> x offset
			mov edi, row
         xor edx, edx                  // edx ==> x-bpp offset
			mov esi, prev_row
         xor eax, eax
         
         // Compute the Raw value for the first bpp bytes
         // Note: the formula works out to always be Paeth(x) = Raw(x) + Prior(x)
         //        where x < bpp
dpthrlp:
         mov al, [edi + ebx]
         add al, [esi + ebx]
         inc ebx
         cmp ebx, bpp
         mov [edi + ebx - 1], al
         jb dpthrlp

         // get # of bytes to alignment
         mov diff, edi              // take start of row
         add diff, ebx              // add bpp
			xor ecx, ecx
         add diff, 0xf              // add 7 + 8 to incr past alignment boundary
         and diff, 0xfffffff8       // mask to alignment boundary
         sub diff, edi              // subtract from start ==> value ebx at alignment
         jz dpthgo

         // fix alignment
dpthlp1:
         xor eax, eax

         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]        // load Prior(x) into al
         mov cl, [esi + edx]        // load Prior(x-bpp) into cl
         sub eax, ecx                 // subtract Prior(x-bpp)
         mov patemp, eax                 // Save pav for later use

         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]        // load Raw(x-bpp) into al
         sub eax, ecx                 // subtract Prior(x-bpp)
         mov ecx, eax

         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp                 // pcv = pav + pbv

         // pc = abs(pcv)
         test eax, 0x80000000                 
         jz dpthpca
         neg eax                     // reverse sign of neg values
dpthpca:
         mov pctemp, eax             // save pc for later use

         // pb = abs(pbv)
         test ecx, 0x80000000                 
         jz dpthpba
         neg ecx                     // reverse sign of neg values
dpthpba:
         mov pbtemp, ecx             // save pb for later use

         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000                 
         jz dpthpaa
         neg eax                     // reverse sign of neg values
dpthpaa:
         mov patemp, eax             // save pa for later use

         // test if pa <= pb  
         cmp eax, ecx
         jna dpthabb

         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc

         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth

dpthbbc:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]        // load Prior(x) into cl
         jmp dpthpaeth

dpthabb:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc

         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth

dpthabc:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl

dpthpaeth:
			inc ebx
			inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256 
         add [edi + ebx - 1], cl
			cmp ebx, diff
			jb dpthlp1

dpthgo:
			mov ecx, FullLength

         mov eax, ecx
         sub eax, ebx                  // subtract alignment fix
         and eax, 0x00000007           // calc bytes over mult of 8

         sub ecx, eax                  // drop over bytes from original length
         mov MMXLength, ecx
   	} // end _asm block


      // Now do the math for the rest of the row
      switch ( bpp )
      {
      case 3:
		{
         pActiveMask.use = 0x0000000000ffffff;  
         pActiveMaskEnd.use = 0xffff000000000000;  
         pShiftBpp.use = 24;    // == bpp(3) * 8
         pShiftRem.use = 40;          // == 64 - 24


			_asm {
            mov ebx, diff
   			mov edi, row               // 
   			mov esi, prev_row          

            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]    
dpth3lp:
            psrlq mm1, pShiftRem              // shift last 3 bytes to 1st 3 bytes
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm1, mm0         // Unpack High bytes of a
            movq mm3, [esi+ebx-8]        // Prep c=Prior(x-bpp) bytes
            punpcklbw mm2, mm0         // Unpack High bytes of b
            psrlq mm3, pShiftRem              // shift last 3 bytes to 1st 3 bytes

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0         // Unpack High bytes of c

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3

            pxor mm0, mm0

            packuswb mm7, mm1
            movq mm3, [esi + ebx]      // load c=Prior(x-bpp)
            pand mm7, pActiveMask

            movq mm2, mm3              // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0         // Unpack High bytes of c
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, mm7              // Now mm1 will be used as Raw(x-bpp)

            // Now do Paeth for 2nd set of bytes (3-5)
            psrlq mm2, pShiftBpp              // load b=Prior(x) step 2

            punpcklbw mm1, mm0         // Unpack High bytes of a
            pxor mm7, mm7
            punpcklbw mm2, mm0         // Unpack High bytes of b

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            psubw mm5, mm3
            psubw mm4, mm3

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv = pbv + pav
            movq mm6, mm5
            paddw mm6, mm4
            
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm5           // Create mask pbv bytes < 0
            pcmpgtw mm7, mm4           // Create mask pav bytes < 0
            pand mm0, mm5              // Only pbv bytes < 0 in mm0
            pand mm7, mm4              // Only pav bytes < 0 in mm7
            psubw mm5, mm0
            psubw mm4, mm7
            psubw mm5, mm0
            psubw mm4, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2

            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            movq mm2, [esi + ebx]      // load b=Prior(x)
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3

            pxor mm0, mm0

            packuswb mm7, mm1
            movq mm3, mm2              // load c=Prior(x-bpp) step 1
            pand mm7, pActiveMask
            punpckhbw mm2, mm0         // Unpack High bytes of b
            psllq mm7, pShiftBpp              // Shift bytes to 2nd group of 3 bytes

             // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            psllq mm3, pShiftBpp              // load c=Prior(x-bpp) step 2
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, mm7

            punpckhbw mm3, mm0         // Unpack High bytes of c
            psllq mm1, pShiftBpp              // Shift bytes
                                       // Now mm1 will be used as Raw(x-bpp)

            // Now do Paeth for 3rd, and final, set of bytes (6-7)

            pxor mm7, mm7

            punpckhbw mm1, mm0         // Unpack High bytes of a
            psubw mm4, mm3

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            pxor mm0, mm0
            paddw mm6, mm5
            
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            pandn mm0, mm1
            pandn mm7, mm4
            paddw mm0, mm2

            paddw mm7, mm5

            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3

            pxor mm1, mm1

            packuswb mm1, mm7
            // Step ebx to next set of 8 bytes and repeat loop til done
				add ebx, 8

            pand mm1, pActiveMaskEnd

            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
                      
				cmp ebx, MMXLength
            pxor mm0, mm0              // pxor does not affect flags
            movq [edi + ebx - 8], mm1      // write back updated value
                                       // mm1 will be used as Raw(x-bpp) next loop
                                       // mm3 ready to be used as Prior(x-bpp) next loop
				jb dpth3lp

			} // end _asm block
      }
      break;

      case 6:
      case 7:
      case 5:
		{
         pActiveMask.use  = 0x00000000ffffffff;  
         pActiveMask2.use = 0xffffffff00000000;  

         pShiftBpp.use = bpp << 3;    // == bpp * 8

         pShiftRem.use = 64 - pShiftBpp.use;

			_asm {
            mov ebx, diff
   			mov edi, row               // 
   			mov esi, prev_row          

            // PRIME the pump (load the first Raw(x-bpp) data set
				movq mm1, [edi+ebx-8]    
            pxor mm0, mm0
dpth6lp:
            // Must shift to position Raw(x-bpp) data
            psrlq mm1, pShiftRem

            // Do first set of 4 bytes
				movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes

            punpcklbw mm1, mm0         // Unpack Low bytes of a
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm2, mm0         // Unpack Low bytes of b

            // Must shift to position Prior(x-bpp) data
            psrlq mm3, pShiftRem

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0         // Unpack Low bytes of c

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3

            pxor mm0, mm0

            packuswb mm7, mm1
            movq mm3, [esi + ebx - 8]      // load c=Prior(x-bpp)
            pand mm7, pActiveMask

            psrlq mm3, pShiftRem
            movq mm2, [esi + ebx]      // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            movq mm6, mm2
            movq [edi + ebx], mm7      // write back updated value

				movq mm1, [edi+ebx-8]    
            psllq mm6, pShiftBpp
            movq mm5, mm7             
            psrlq mm1, pShiftRem
            por mm3, mm6

            psllq mm5, pShiftBpp


            punpckhbw mm3, mm0         // Unpack High bytes of c
            por mm1, mm5
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack High bytes of b

            punpckhbw mm1, mm0         // Unpack High bytes of a

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3

            pxor mm0, mm0

            // Step ex to next set of 8 bytes and repeat loop til done
				add ebx, 8

            packuswb mm1, mm7

            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
				cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                       // mm1 will be used as Raw(x-bpp) next loop
				jb dpth6lp

			} // end _asm block
      }
      break;

      case 4:
		{
         pActiveMask.use  = 0x00000000ffffffff;  

			_asm {
            mov ebx, diff
   			mov edi, row               // 
   			mov esi, prev_row          

            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
				movq mm1, [edi+ebx-8]    // Only time should need to read a=Raw(x-bpp) bytes
dpth4lp:
            // Do first set of 4 bytes
				movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes

            punpckhbw mm1, mm0         // Unpack Low bytes of a
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm2, mm0         // Unpack High bytes of b

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpckhbw mm3, mm0         // Unpack High bytes of c

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3

            pxor mm0, mm0

            packuswb mm7, mm1
            movq mm3, [esi + ebx]      // load c=Prior(x-bpp)
            pand mm7, pActiveMask

            movq mm2, mm3              // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0         // Unpack High bytes of c
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, mm7              // Now mm1 will be used as Raw(x-bpp)

            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack Low bytes of b

            punpcklbw mm1, mm0         // Unpack Low bytes of a

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3

            pxor mm0, mm0

            // Step ex to next set of 8 bytes and repeat loop til done
				add ebx, 8

            packuswb mm1, mm7

            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
				cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                       // mm1 will be used as Raw(x-bpp) next loop
				jb dpth4lp

			} // end _asm block
      }
      break;

      case 8:                          // bpp == 8
		{
         pActiveMask.use  = 0x00000000ffffffff;  

			_asm {
            mov ebx, diff
   			mov edi, row               // 
   			mov esi, prev_row          

            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
				movq mm1, [edi+ebx-8]    // Only time should need to read a=Raw(x-bpp) bytes
dpth8lp:
            // Do first set of 4 bytes
				movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes

            punpcklbw mm1, mm0         // Unpack Low bytes of a
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm2, mm0         // Unpack Low bytes of b

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0         // Unpack Low bytes of c

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3

            pxor mm0, mm0

            packuswb mm7, mm1
				movq mm3, [esi+ebx-8]    // read c=Prior(x-bpp) bytes
            pand mm7, pActiveMask

            movq mm2, [esi + ebx]      // load b=Prior(x)
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            punpckhbw mm3, mm0         // Unpack High bytes of c
            movq [edi + ebx], mm7      // write back updated value
				movq mm1, [edi+ebx-8]    // read a=Raw(x-bpp) bytes
 
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack High bytes of b

            punpckhbw mm1, mm0         // Unpack High bytes of a

            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2

            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4           // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4              // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5           // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5              // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7

            pxor mm0, mm0
            pcmpgtw mm0, mm6           // Create mask pcv bytes < 0
            pand mm0, mm6              // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0

            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5           // pa > pb?
            movq mm0, mm7

            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2


            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?

            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3

            pxor mm0, mm0

            // Step ex to next set of 8 bytes and repeat loop til done
				add ebx, 8

            packuswb mm1, mm7

            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
				cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                       // mm1 will be used as Raw(x-bpp) next loop
				jb dpth8lp


			} // end _asm block
      }
      break;

      case 1:                          // bpp = 1
      case 2:                          // bpp = 2
      default:                         // bpp > 8
		{
		   _asm {
			   mov ebx, diff
			   cmp ebx, FullLength
			   jnb dpthdend

  			   mov edi, row               // 
  			   mov esi, prev_row          

            // Do Paeth decode for remaining bytes
            mov edx, ebx
            xor ecx, ecx               // zero ecx before using cl & cx in loop below
            sub edx, bpp               // Set edx = ebx - bpp

dpthdlp:
            xor eax, eax

            // pav = p - a = (a + b - c) - a = b - c
            mov al, [esi + ebx]        // load Prior(x) into al
            mov cl, [esi + edx]        // load Prior(x-bpp) into cl
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov patemp, eax                 // Save pav for later use

            xor eax, eax
            // pbv = p - b = (a + b - c) - b = a - c
            mov al, [edi + edx]        // load Raw(x-bpp) into al
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov ecx, eax

            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            add eax, patemp                 // pcv = pav + pbv

            // pc = abs(pcv)
            test eax, 0x80000000                 
            jz dpthdpca
            neg eax                     // reverse sign of neg values
dpthdpca:
            mov pctemp, eax             // save pc for later use

            // pb = abs(pbv)
            test ecx, 0x80000000                 
            jz dpthdpba
            neg ecx                     // reverse sign of neg values
dpthdpba:
            mov pbtemp, ecx             // save pb for later use

            // pa = abs(pav)
            mov eax, patemp
            test eax, 0x80000000                 
            jz dpthdpaa
            neg eax                     // reverse sign of neg values
dpthdpaa:
            mov patemp, eax             // save pa for later use

            // test if pa <= pb  
            cmp eax, ecx
            jna dpthdabb

            // pa > pb; now test if pb <= pc
            cmp ecx, pctemp
            jna dpthdbbc

            // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth

dpthdbbc:
            // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
            mov cl, [esi + ebx]        // load Prior(x) into cl
            jmp dpthdpaeth

dpthdabb:
            // pa <= pb; now test if pa <= pc
            cmp eax, pctemp
            jna dpthdabc

            // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth

dpthdabc:
            // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
            mov cl, [edi + edx]  // load Raw(x-bpp) into cl

dpthdpaeth:
			   inc ebx
			   inc edx
            // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256 
            add [edi + ebx - 1], cl
			   cmp ebx, FullLength

			   jb dpthdlp
dpthdend:
      	} // end _asm block
      }
      return;                       // No need to go further with this one
      }                                // end switch ( bpp )


      _asm {
         // MMX acceleration complete now do clean-up
         // Check if any remaining bytes left to decode
			mov ebx, MMXLength
			cmp ebx, FullLength
			jnb dpthend

  			mov edi, row               // 
  			mov esi, prev_row          

         // Do Paeth decode for remaining bytes
         mov edx, ebx
         xor ecx, ecx               // zero ecx before using cl & cx in loop below
         sub edx, bpp               // Set edx = ebx - bpp

dpthlp2:
         xor eax, eax

         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]        // load Prior(x) into al
         mov cl, [esi + edx]        // load Prior(x-bpp) into cl
         sub eax, ecx                 // subtract Prior(x-bpp)
         mov patemp, eax                 // Save pav for later use

         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]        // load Raw(x-bpp) into al
         sub eax, ecx                 // subtract Prior(x-bpp)
         mov ecx, eax

         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp                 // pcv = pav + pbv

         // pc = abs(pcv)
         test eax, 0x80000000                 
         jz dpthpca2
         neg eax                     // reverse sign of neg values
dpthpca2:
         mov pctemp, eax             // save pc for later use

         // pb = abs(pbv)
         test ecx, 0x80000000                 
         jz dpthpba2
         neg ecx                     // reverse sign of neg values
dpthpba2:
         mov pbtemp, ecx             // save pb for later use

         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000                 
         jz dpthpaa2
         neg eax                     // reverse sign of neg values
dpthpaa2:
         mov patemp, eax             // save pa for later use

         // test if pa <= pb  
         cmp eax, ecx
         jna dpthabb2

         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc2

         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2

dpthbbc2:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]        // load Prior(x) into cl
         jmp dpthpaeth2

dpthabb2:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc2

         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2

dpthabc2:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl

dpthpaeth2:
			inc ebx
			inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256 
         add [edi + ebx - 1], cl
			cmp ebx, FullLength

			jb dpthlp2

dpthend:
			emms          // End MMX instructions; prep for possible FP instrs.
   	} // end _asm block
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngclib.cpp ===
/*****************************************************************************
	spngclib.cpp

	IO error and memory management.  Based on the _mgr things in the IJG code
	but all gathered into one structure for convenience.

	This implementation is based on the standard C libary.
*****************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdarg.h>

#include "spngclib.h"


/*----------------------------------------------------------------------------
	Error handling.  The site provides an "error" API which gets called to log
	errors and is passed a boolean which indicates whether the error is fatal
	or not.  The API is only implemented in debug builds, there is no default.
----------------------------------------------------------------------------*/
#if _DEBUG
void BITMAPCLIBSITE::Error(bool fatal, const char *szFile, int iline,
			const char *szExp, ...) const
	{
	/* Use internal knowledge of the Win assert.h implementation. */
	va_list ap;
	va_start(ap, szExp);
	
	if (fatal)
		{
		char buffer[1024];

		vsprintf(buffer, szExp, ap);
		_assert(buffer, const_cast<char*>(szFile), iline);
		}
	else
		{
		vfprintf(stderr, szExp, ap);
		fputc('\n', stderr);
		}

	va_end(ap);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\pngnoncrit.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pngnoncrit.hpp
*
* Abstract:
*
*   Header file for a class definition that derives from SPNGREAD
*   and is capable of reading non-critical chunks (using FChunk).
*
* Revision History:
*
*   9/24/99 DChinn
*       Created it.
*
\**************************************************************************/

#include "libpng\spngsite.h"
#include "libpng\spngread.h"
#include "libpng\spngwrite.h"

// PNG tIME chunk definition

struct LastChangeTime
{
    UINT16  usYear;
    BYTE    cMonth;
    BYTE    cDay;
    BYTE    cHour;
    BYTE    cMinute;
    BYTE    cSecond;
};

class GpSpngRead : public SPNGREAD
{
public:
    GpSpngRead::GpSpngRead(BITMAPSITE &bms, const void *pv, int cb, bool fMMX);
    ~GpSpngRead();

    /* FChunk sets up the following fields, they are initialized as above
		(this may be used to detect absence of the fields.) */
	ULONG          m_uOther;     // Offset of complete GIF (msOG).
	ULONG          m_cbOther;    // Byte count of complete GIF
	ULONG          m_uOA;        // Offset of Office Art data (msOA).
	ULONG          m_cbOA;       // Byte count of Office Art data.
	SPNG_U32       m_ucHRM[8];   // Uninterpreted chromaticities x 100000
	SPNG_U32       m_xpixels;    // Pixels per metre/unknown
	SPNG_U32       m_ypixels;    // Pixels per metre/unknown
	SPNG_U32       m_uGamma;
	ULONG          m_uiCCP;      // Offset of ICC data
	ULONG          m_cbiCCP;     // Length of compressed ICC data
	int            m_ctRNS;      // Length of tRNS chunk
	SPNG_U8        m_btRNS[256]; // transparency values from tRNS chunk
	SPNG_U8        m_bsBit[4];
	SPNG_U8        m_bIntent;
	SPNG_U8        m_bpHYs;      // Should be 0 or 1 for valid chunks
	SPNG_U8        m_bImportant; // From msOC
	bool           m_fcHRM;      // cHRM chunk seen

    SPNG_U8*       m_pTitleBuf;         // Buffer for storing title
    ULONG          m_ulTitleLen;        // Length of title buffer
    SPNG_U8*       m_pAuthorBuf;        // Buffer for storing author
    ULONG          m_ulAuthorLen;       // Length of author buffer
    SPNG_U8*       m_pCopyRightBuf;     // Buffer for storing copyright
    ULONG          m_ulCopyRightLen;    // Length of copyright buffer
    SPNG_U8*       m_pDescriptionBuf;   // Buffer for storing Description
    ULONG          m_ulDescriptionLen;  // Length of Description buffer
    SPNG_U8*       m_pCreationTimeBuf;  // Buffer for storing Creation Time
    ULONG          m_ulCreationTimeLen; // Length of Creation Time buffer
    SPNG_U8*       m_pSoftwareBuf;      // Buffer for storing Software
    ULONG          m_ulSoftwareLen;     // Length of Software buffer
    SPNG_U8*       m_pDeviceSourceBuf;  // Buffer for storing Device Source
    ULONG          m_ulDeviceSourceLen; // Length of Device Source buffer
    SPNG_U8*       m_pCommentBuf;       // Buffer for storing comments
    ULONG          m_ulCommentLen;      // Length of comments
    SPNG_U8*       m_pICCBuf;           // Buffer for storing ICC profile
    ULONG          m_ulICCLen;          // Length of ICC profile
    SPNG_U8*       m_pICCNameBuf;       // Buffer for storing ICC profile name
    ULONG          m_ulICCNameLen;      // Length of ICC profile name
    SPNG_U8*       m_pTimeBuf;          // Buffer for storing date/time value
    ULONG          m_ulTimeLen;         // Length of date/time value
    SPNG_U8*       m_pSPaletteNameBuf;  // Buffer for suggested palette's name
    ULONG          m_ulSPaletteNameLen; // Length of the suggested palette name
    SPNG_U16*      m_phISTBuf;          // Buffer for histogram palette
    INT            m_ihISTLen;          // Length of the histogram palette

	/* Find out whether any of the sBIT information is significant, also
		fills in the rgb with resolved/corrected values of the bit depths
		(will set all to the actually bit depth if there was no sBIT
		chunk.) */
	bool FsBIT(SPNG_U8 rgb[4]) const;

	/* To extract a CIEXYZTRIPLE from the cHRM chunk use this.  If there
		is no cHRM chunk or sRGB has been seen the sRGB triple is returned
		instead. If the chunk produces out of range values false is returned
		and an sRGB value is generated. */
	bool FGetCIEXYZTRIPLE(CIEXYZTRIPLE *ptripe) const;

protected:
	/* To obtain information from non-critical chunks the following API must be
		implemented.  It gets the chunk identity and length plus a pointer to
		that many bytes.  If it returns false loading of the chunks will stop
		and a fatal error will be logged, the default implementation just skips
		the chunks.  Note that this is called for *all* chunks including
		IDAT.  m_fBadFormat is set if the API returns false. */
	virtual bool FChunk(SPNG_U32 ulen, SPNG_U32 uchunk, const SPNG_U8* pb);

private:
    bool            GetTextContents(ULONG*          pulLength,
                                    SPNG_U8**       ppBuf,
                                    SPNG_U32        ulen,
                                    const SPNG_U8*  pb,
                                    bool            bIsCompressed);
    
    bool            ParseTextChunk(SPNG_U32 ulen,
                                   const SPNG_U8* pb,
                                   bool bIsCompressed);
    
};

class GpSpngWrite : public SPNGWRITE
{
public:
    GpSpngWrite(BITMAPSITE &bms);
    ~GpSpngWrite(){};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngclib.h ===
#pragma once
#define SPNGCLIB_H 1
/*****************************************************************************
	spngclib.h

	IO error and memory management.  Based on the _mgr things in the IJG code
	but all gathered into one structure for convenience.

	Standard C libary implementation
*****************************************************************************/
#include "spngsite.h"

class BITMAPCLIBSITE : protected BITMAPSITE
	{
protected:
#if _DEBUG || DEBUG
	/* Error handling.  The site provides an "error" API which gets called
		to log errors and is passed a boolean which indicates whether the
		error is fatal or not.  The API is only implemented in debug builds,
		there is no default. */
	virtual void Error(bool fatal, const char *szFile, int iline,
		const char *szExp, ...) const;
#endif
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\inc\msowarn.h ===
/*************************************************************************
	msowarn.h
	
	Owner: michmarc
	Copyright (c) 1999 Microsoft Corporation
	
	File that contains all of the pragmas necessary to make
	/W4 /WX work with Office builds
*************************************************************************/

#ifndef _MSO_WARN
#define _MSO_WARN
#pragma once

// Warnings that need fixing to make things /W4 clean

// Always useless
#pragma warning(disable:4049)   // Compiler limit -- no more line number info
#pragma warning(disable:4054)   // Casting function pointer to data pointer
#pragma warning(disable:4055)   // Casting data pointer to function pointer
#pragma warning(disable:4100)   // Unreferenced formal parameter
#pragma warning(disable:4115)   // Named type definition in parenthesis
#pragma warning(disable:4152)   // Microsoft extension -- fn/data pointer conv
#pragma warning(disable:4168)   // Compiler limit -- out of debug types
#pragma warning(disable:4200)   // Microsoft extension -- Zero sized array
#pragma warning(disable:4201)   // Microsoft extension -- Nameless struct/union
#pragma warning(disable:4204)   // Microsoft extension -- Nonconst agg initializer
#pragma warning(disable:4206)   // Microsoft extension -- Source file is empty
#pragma warning(disable:4207)   // Microsoft extension -- Extended initializer form
#pragma warning(disable:4211)   // Microsoft extension -- Extern to static
#pragma warning(disable:4213)   // Microsoft extension -- Cast on LValue
#pragma warning(disable:4214)   // Microsoft extension -- Bitfield not int
#pragma warning(disable:4221)   // Microsoft extension -- Init with addr of local
#pragma warning(disable:4239)   // Microsoft extension -- nonconst reference to nonlvalue
#pragma warning(disable:4238)   // Microsoft extension -- class rvalue as lvalue
#pragma warning(disable:4305)   // Casting causes truncation
#pragma warning(disable:4509)   // Microsoft extension -- SEH and destructors
#pragma warning(disable:4510)   // Default constructor could not be generated
#pragma warning(disable:4511)   // Copy constructor could not be generated
#pragma warning(disable:4512)   // Assignment operator could not be generated
#pragma warning(disable:4513)   // Destructor could not be generated
#pragma warning(disable:4514)   // Unreferenced inline function removed
#pragma warning(disable:4527)   // User defined destructor required
#pragma warning(disable:4610)   // User defined constructor required
#pragma warning(disable:4611)   // Setjmp/C++ destruction interaction unportable
#pragma warning(disable:4710)   // Inline function not inlined
#pragma warning(disable:4798)   // Native code instead of PCode generated

#if DEBUG
#pragma warning(disable:4124)	  // Stack checking and __fastcall mixed
#endif

// Currently useless, but could be made useful
#pragma warning(disable:4018)   // Signed/unsigned comparison mismatch.  Might be useful, except that all
                                // arguments smaller than int are promoted to signed int, so byte==(byte+byte) generates this.
#pragma warning(disable:4127)   // Conditional is constant.  Might be useful, but many asserts are constantly true
                                //    and "while (1) {}" and "for(A;;B)" constructs generate this warning as well.
#pragma warning(disable:4245)   // Signed/unsigned asignment mismatch.  Might be useful, except that all
                                // arguments smaller than int are promoted to signed int, so byte=byte+byte generates this.
#pragma warning(disable:4268)   // const static/global initilzed with compiler generated default constructor
                                //    seems that "extern "C" const ClassName cn;" can generate this, even though this is
                                //    a declaration, not a definition
#pragma warning(disable:4310)   // Cast truncates constant value (problem because LOBYTE(0x113) generates this)
                                // and there is often no way to work around the warning
#pragma warning(disable:4702)   // Unreachable code.  Can't be eliminated because this warning
                                // can be generated against compiler created code at the end of a block

// REVIEW -- should these be re-enabled?
#pragma warning(disable:4211)   // Redefined extern to static 
#pragma warning(disable:4505)   // Unreferenced static function removed (happens in ATL code)

#endif /* _MSO_WARN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngcolorimetry.cpp ===
/*****************************************************************************
	spngcoloimetry.cpp

	Ok, so I have to do this myself, why?  This is stuff which should be in
	Windows but isn't.  What is worse it ain't clear at all whether this stuff
	is right, what is clear is that doing nothing is wrong.
	
	Assumpions:
	
		LOGCOLORSPACE CIEXYZTRIPLE is a regular color space gamut - i.e. the
		red green and blue end points is a relatively intensity (we make Y of
		the white point be 1 - i.e. the sum of the Y of the r g and b end points
		must be 1.0) regular CIE color space described by three maximum
		intensity colors - nominally "red" "green" and "blue".
		
		We know that PNG uses colorimetric values for r, g and b plus a white
		point which indicates the relative intensity required of the values to
		achieve "white".  By some pretty complex arithmetic we can convert from
		this to the CIEXYZTRIPLE.  It is assumed that this is the right thing
		to do, although there is evidence that some implementations on the other
		side of the kernel wall assume colorimetric values in CIEXYZTRIPLE plus
		a fixed white point of D50.
*****************************************************************************/
#include "spngcolorimetry.h"

/*----------------------------------------------------------------------------
	Useful constants (these are exact.)
----------------------------------------------------------------------------*/
#define F1_30 (.000000000931322574615478515625f)
#define F1X30 (1073741824.f)


/*----------------------------------------------------------------------------
	CIERGB from cHRM.  The API returns false if it detects and overflow
	condition.  The input  is a set of 8 PNG format cHRM values -
	i.e. numbers scaled by 100000.
----------------------------------------------------------------------------*/
bool FCIERGBFromcHRM(SPNGCIERGB ciergb, const SPNG_U32 rgu[8])
	{
	/* We have x and y for red, green, blue and white.  We want X, Y and Z.
		z is (1-x-y).  For each end point we need a multiplier (k) such that:

			cred.kred + cgreen.kgreen + cblue.kblue = Cwhite

		For c being x, y, z.  We know that Ywhite is 1.0, so we can do a whole
		mess of linear algebra to sort this out.  I'd include this in here if
		there was any way of embedding a MathCAD sheet into a .cpp file... */
	#define F(name,i) float name(rgu[i]*1E-5f)
	F(xwhite, 0);
	F(ywhite, 1);
	F(xred, 2);
	F(yred, 3);
	F(xgreen, 4);
	F(ygreen, 5);
	F(xblue, 6);
	F(yblue, 7);

	float divisor;
	float kred, kgreen, kblue;

	float t;

	t = xblue*ygreen;  divisor  = t;  kred    = t;
	t = yblue*xgreen;  divisor -= t;  kred   -= t;
	t = xred*yblue;    divisor += t;  kgreen  = t;
	t = yred*xblue;    divisor -= t;  kgreen -= t;
	t = xgreen*yred;   divisor += t;  kblue   = t;
	t = ygreen*xred;   divisor -= t;  kblue  -= t;

	/* The Pluto problem - bitmaps on pluto come with green=blue=grey,
		so at this point we have a situation where our matrix transpose is
		0.  We aren't going to get anything meaningful out of this so give
		up now. */
	if (divisor == 0.0)
		return false;

	divisor *= ywhite;
	divisor  = 1/divisor;

	kred   += (xgreen-xblue)*ywhite;
	kred   -= (ygreen-yblue)*xwhite;
	kred   *= divisor;

	kgreen += (xblue-xred)*ywhite;
	kgreen -= (yblue-yred)*xwhite;
	kgreen *= divisor;

	kblue  += (xred-xgreen)*ywhite;
	kblue  -= (yred-ygreen)*xwhite;
	kblue  *= divisor;

	/* Hence the actual values to set into the ciergb. */
	#define CVT30(col,comp,flt,fac)\
		ciergb[ICIE##col][ICIE##comp] = flt * fac;

	t = 1-xred-yred;
	CVT30(Red,X,xred,kred);
	CVT30(Red,Y,yred,kred);
	CVT30(Red,Z,t,kred);

	t = 1-xgreen-ygreen;
	CVT30(Green,X,xgreen,kgreen);
	CVT30(Green,Y,ygreen,kgreen);
	CVT30(Green,Z,t,kgreen);

	t = 1-xblue-yblue;
	CVT30(Blue,X,xblue,kblue);
	CVT30(Blue,Y,yblue,kblue);
	CVT30(Blue,Z,t,kblue);

	#undef CVT30

	return true;
	}


/*----------------------------------------------------------------------------
	Convert a CIERGB into a CIEXYZTRIPLE.  This may fail because of overflow.
----------------------------------------------------------------------------*/
bool FCIEXYZTRIPLEFromCIERGB(CIEXYZTRIPLE *ptripe, const SPNGCIERGB ciergb)
	{
	/* Scale each item by F1X30 after checking for overflow. */
	#define C(col,comp) (ciergb[ICIE##col][ICIE##comp])
	#define CVT30(col,comp)\
		if (C(col,comp) < -2 || C(col,comp) >= 2) return false;\
		ptripe->ciexyz##col.ciexyz##comp = long(C(col,comp)*F1X30)

	CVT30(Red,X);
	CVT30(Red,Y);
	CVT30(Red,Z);

	CVT30(Green,X);
	CVT30(Green,Y);
	CVT30(Green,Z);

	CVT30(Blue,X);
	CVT30(Blue,Y);
	CVT30(Blue,Z);

	#undef CVT30
	#undef C

	return true;
	}


/*----------------------------------------------------------------------------
	Given 8 32 bit values, scaled by 100000 (i.e. as in the PNG cHRM chunk)
	generate the appropriate CIEXYZTRIPLE.  The API returns false if it
	detects an overflow condition.

	This uses floating point arithmetic.
----------------------------------------------------------------------------*/
bool FCIEXYZTRIPLEFromcHRM(CIEXYZTRIPLE *ptripe, const SPNG_U32 rgu[8])
	{
	SPNGCIERGB ciergb;

	if (!FCIERGBFromcHRM(ciergb, rgu))
		return false;

	return FCIEXYZTRIPLEFromCIERGB(ptripe, ciergb);
	}


/*----------------------------------------------------------------------------
	Given a CIEXYZTRIPLE produce the corresponding floating point CIERGB -
	simply a scaling operation.  The input values are 2.30 numbers, so we
	divided by 1<<30.
----------------------------------------------------------------------------*/
void CIERGBFromCIEXYZTRIPLE(SPNGCIERGB ciergb, const CIEXYZTRIPLE *ptripe)
	{
	#define CVT30(col,comp)\
		ciergb[ICIE##col][ICIE##comp] = ptripe->ciexyz##col.ciexyz##comp * F1_30

	CVT30(Red,X);
	CVT30(Red,Y);
	CVT30(Red,Z);
	CVT30(Green,X);
	CVT30(Green,Y);
	CVT30(Green,Z);
	CVT30(Blue,X);
	CVT30(Blue,Y);
	CVT30(Blue,Z);

	#undef CVT30
	}


/*----------------------------------------------------------------------------
	Given a CIEXYZTRIPLE generate the corresponding PNG cHRM chunk information.
	The API returns false if it detects an overflow condition.

	This does not use floating point arithmetic.

	The intermediate arithmetic adds up to three numbers together, because
	the values are 2.30 overflow is possible.  Avoid this by using 4.28 values,
	this causes insignificant loss of precision.
----------------------------------------------------------------------------*/
inline bool FxyFromCIEXYZ(SPNG_U32 rgu[2], const CIEXYZ *pcie)
	{
	const long t((pcie->ciexyzX>>2) + (pcie->ciexyzY>>2) + (pcie->ciexyzZ>>2));
	rgu[0]/*x*/ = MulDiv(pcie->ciexyzX, 100000>>2, t);
	rgu[1]/*y*/ = MulDiv(pcie->ciexyzY, 100000>>2, t);
	/* Check the MulDiv overflow condition. */
	return rgu[0] != (-1) && rgu[1] != (-1);
	}

bool FcHRMFromCIEXYZTRIPLE(SPNG_U32 rgu[8], const CIEXYZTRIPLE *ptripe)
	{
	/* Going this way is easier.  We take an XYZ and convert it to the
		corresponding x,y.  The white value is scaled by 4 to avoid any
		possibility of overflow.  This makes no difference to the final
		result because we calculate X/(X+Y+Z) and so on. */
	CIEXYZ white;
	white.ciexyzX = (ptripe->ciexyzRed.ciexyzX>>2) +
		(ptripe->ciexyzGreen.ciexyzX>>2) +
		(ptripe->ciexyzBlue.ciexyzX>>2);
	white.ciexyzY = (ptripe->ciexyzRed.ciexyzY>>2) +
		(ptripe->ciexyzGreen.ciexyzY>>2) +
		(ptripe->ciexyzBlue.ciexyzY>>2);
	white.ciexyzZ = (ptripe->ciexyzRed.ciexyzZ>>2) +
		(ptripe->ciexyzGreen.ciexyzZ>>2) +
		(ptripe->ciexyzBlue.ciexyzZ>>2);

	if (!FxyFromCIEXYZ(rgu+0, &white))               return false;
	if (!FxyFromCIEXYZ(rgu+2, &ptripe->ciexyzRed))   return false;
	if (!FxyFromCIEXYZ(rgu+4, &ptripe->ciexyzGreen)) return false;
	if (!FxyFromCIEXYZ(rgu+6, &ptripe->ciexyzBlue))  return false;

	return true;
	}


/*----------------------------------------------------------------------------
	Standard values
----------------------------------------------------------------------------*/
extern const SPNGCIERGB SPNGCIERGBD65 =
	{  //  X       Y       Z
		{ .4124f, .2126f, .0193f }, // red
		{ .3576f, .7152f, .0722f }, // green
		{ .1805f, .0722f, .9505f }  // blue
	};

extern const SPNGCIEXYZ SPNGCIEXYZD50 = { .96429567f, 1.f, .82510460f };
extern const SPNGCIEXYZ SPNGCIEXYZD65 = { .95016712f, 1.f, 1.08842297f };

/* This is the Lam and Rigg cone response matrix - it is a transposed matrix
	(notionally the CIEXYZ values are actually RGB values.)  The matrix here
	is further transposed for efficiency in the operations below - watch out,
	this is tricky! */
typedef struct
	{
	SPNGCIERGB m;
	}
LR;

static const LR LamRiggCRM =
	{{  //   R        G        B
		{  .8951f,  .2664f, -.1614f }, // X
		{ -.7502f, 1.7135f,  .0367f }, // Y
		{  .0389f, -.0685f, 1.0296f }  // Z
	}};

static const LR InverseLamRiggCRM =
	{{  //   X        Y        Z
		{  .9870f, -.1471f,  .1600f }, // red
		{  .4323f,  .5184f,  .0493f }, // green
		{ -.0085f,  .0400f,  .9685f }  // blue
	}};

/*----------------------------------------------------------------------------
	Evaluate M * V, giving a vector (V is a column vector, the result is a
	column vector.)  Notice that, notionally, V is an RGB vector, not an XYZ
	vector, the output is and XYZ vector.
----------------------------------------------------------------------------*/
inline void VFromMV(SPNGCIEXYZ v, const LR &m, const SPNGCIEXYZ vIn)
	{
	v[0] = m.m[0][0] * vIn[0] + m.m[0][1] * vIn[1] + m.m[0][2] * vIn[2];
	v[1] = m.m[1][0] * vIn[0] + m.m[1][1] * vIn[1] + m.m[1][2] * vIn[2];
	v[2] = m.m[2][0] * vIn[0] + m.m[2][1] * vIn[1] + m.m[2][2] * vIn[2];
	}

static void MFromMM(SPNGCIERGB mOut, const LR &m1, const SPNGCIERGB m2)
	{
	VFromMV(mOut[0], m1, m2[0]);
	VFromMV(mOut[1], m1, m2[1]);
	VFromMV(mOut[2], m1, m2[2]);
	}

/* Multiply the diagonal matrix from the given vector by the given
	matrix. */
inline void MFromDiagM(SPNGCIERGB mOut, const SPNGCIEXYZ diag, const SPNGCIERGB m)
	{
	mOut[0][0] = diag[0] * m[0][0];
	mOut[0][1] = diag[1] * m[0][1];
	mOut[0][2] = diag[2] * m[0][2];
	mOut[1][0] = diag[0] * m[1][0];
	mOut[1][1] = diag[1] * m[1][1];
	mOut[1][2] = diag[2] * m[1][2];
	mOut[2][0] = diag[0] * m[2][0];
	mOut[2][1] = diag[1] * m[2][1];
	mOut[2][2] = diag[2] * m[2][2];
	}


/*----------------------------------------------------------------------------
	White point adaption.  Given a destination white point adapt the input
	CIERGB appropriately - the input white point is determined by the sum
	of the XYZ values.
----------------------------------------------------------------------------*/
void CIERGBAdapt(SPNGCIERGB ciergb, const SPNGCIEXYZ ciexyzDest)
	{
	SPNGCIEXYZ ciexyzT = // src white point (XYZ)
		{
		ciergb[ICIERed][ICIEX] + ciergb[ICIEGreen][ICIEX] + ciergb[ICIEBlue][ICIEX],
		ciergb[ICIERed][ICIEY] + ciergb[ICIEGreen][ICIEY] + ciergb[ICIEBlue][ICIEY],
		ciergb[ICIERed][ICIEZ] + ciergb[ICIEGreen][ICIEZ] + ciergb[ICIEBlue][ICIEZ]
		};
	SPNGCIEXYZ ciexyzTT; // src RGB cone respone
	VFromMV(ciexyzTT, LamRiggCRM, ciexyzT);

	VFromMV(ciexyzT, LamRiggCRM, ciexyzDest); // dest RGB cone response

	/* Need dest/source as a vector (the diagonal of this is a numeric scaling of
		an input matrix which will not transpose the dimensions.)  I don't think
		there is any way of avoiding the division here. */
	ciexyzT[0] /= ciexyzTT[0];
	ciexyzT[1] /= ciexyzTT[1];
	ciexyzT[2] /= ciexyzTT[2];

	/* Now we start building the output matrix. */
	SPNGCIERGB ciergbT;
	MFromMM(ciergbT, LamRiggCRM, ciergb);         // XYZ <- XYZ
	SPNGCIERGB ciergbTT;
	MFromDiagM(ciergbTT, ciexyzT, ciergbT);       // XYZ <- XYZ (just scaling)
	MFromMM(ciergb, InverseLamRiggCRM, ciergbTT); // RGB <- XYZ
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngcolorimetry.h ===
#pragma once
#define SPNGCOLORIMETRY_H 1
/*****************************************************************************
	spngcolorimetry.h

	Convert PNG cHRM to CIEXYZTRIPLE and vice versa.
*****************************************************************************/
#include <msowarn.h>
#include <windows.h>

#include "spngconf.h"

/* Given 8 32 bit values, scaled by 100000 (i.e. as in the PNG cHRM chunk)
	generate the appropriate CIEXYZTRIPLE.  The API returns false if it
	detects an overflow condition.

	This uses floating point arithmetic. */
bool FCIEXYZTRIPLEFromcHRM(CIEXYZTRIPLE *ptripe, const SPNG_U32 rgu[8]);

/* Given a CIEXYZTRIPLE generate the corresponding PNG cHRM chunk information.
	The API returns false if it detects an overflow condition.

	This uses floating point arithmetic. */
bool FcHRMFromCIEXYZTRIPLE(SPNG_U32 rgu[8], const CIEXYZTRIPLE *ptripe);

/* More primitive types.  We define a set of floating point structures to
	hold CIE XYZ values and triples of these to defined end points in RGB
	space.  This is done using the following enumerations and definitions.
	RGB is primary (so the first indexed item), XYZ secondary. */
enum
	{
	ICIERed   = 0,
	ICIEGreen = 1,
	ICIEBlue  = 2,
	ICIEX     = 0,
	ICIEY     = 1,
	ICIEZ     = 2
	};

/* Thus an array is float[3 {RGB}][3 {XYZ}] */
typedef float      SPNGCIEXYZ[3];
typedef SPNGCIEXYZ SPNGCIERGB[3];

/* These primitive APIs convert a PNG cHRM to a CIERGB and a CIEXYZTRIPLE to
	the same, all use floating point (!).  The F APIs may fail because of
	overflow. */
bool FCIERGBFromcHRM(SPNGCIERGB ciergb, const SPNG_U32 rgu[8]);
void CIERGBFromCIEXYZTRIPLE(SPNGCIERGB ciergb, const CIEXYZTRIPLE *ptripe);
bool FCIEXYZTRIPLEFromCIERGB(CIEXYZTRIPLE *ptripe, const SPNGCIERGB ciergb);

/* White point adaption.  Given a destination white point adapt the input
	CIERGB appropriately - the input white point is determined by the sum
	of the XYZ values. */
void CIERGBAdapt(SPNGCIERGB ciergb, const SPNGCIEXYZ ciexyzDest);

/* Useful values. */
extern const SPNGCIERGB SPNGCIERGBD65;
extern const SPNGCIEXYZ SPNGCIEXYZD65;
extern const SPNGCIEXYZ SPNGCIEXYZD50;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngdefilter.cpp ===
/*****************************************************************************
	spngdefilter.cpp

	PNG support code - unfiltering a row.

	WARNING: This file contains proprietary Intel/Microsoft code
*****************************************************************************/
#include <stdlib.h>
#pragma intrinsic(abs)

#define SPNG_INTERNAL 1
#include "spngread.h"

/*----------------------------------------------------------------------------
	Unfilter (so to speak) a single input row.  Receives the row pointer,
	the pointer to the previous row and a byte count which includes the
	filter byte.
----------------------------------------------------------------------------*/
void SPNGREAD::Unfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev, SPNG_U32 cbRow,
	SPNG_U32 cbpp)
	{
	/* Nothing to do on empty rows. */
	if (cbRow < 2)
		return;

	switch (*pbRow)
		{
	default:
		SPNGlog1("PNG: filter %d invalid", pbRow[-1]);
	case PNGFNone:
		return;

	case PNGFUp:
		if (pbPrev == NULL)   // First line - pbPrev[x]==0 so no work needed
			return;

		if (m_fMMXAvailable && cbpp > 8 && cbRow >= 128)
			{
			upMMXUnfilter(pbRow+1, pbPrev+1, cbRow-1);
			}
		else
			{//MMX

		while (--cbRow > 0)   // Exclude filter byte
#pragma warning(disable: 4244)
			*++pbRow += *++pbPrev;
#pragma warning(error: 4244)

			}//MMX

		return;

	case PNGFAverage:
		if (m_fMMXAvailable && pbPrev != NULL && cbpp > 8 && cbRow >= 128)
			{
			avgMMXUnfilter(pbRow+1, pbPrev+1, cbRow-1, cbpp);
			}
		else
			{//MMX

		cbpp = (cbpp+7)>>3;   // Now in bytes
		--cbRow;              // For i<cbRow,++i behavior below.
		if (pbPrev == NULL)   // First line
			{
			SPNG_U32 i;
			for (i=cbpp; i<cbRow;)
				{
				++i; // Still <cbRow
#pragma warning(disable: 4244)
				pbRow[i] += pbRow[i-cbpp]>>1;
#pragma warning(error: 4244)
				}
			}
		else
			{
			/* The first cbpp bytes have no previous value in X, but do
				have a value from the prior row. */
			SPNG_U32 i;
			for (i=0; i<cbpp && i<cbRow;)
				{
				++i;
#pragma warning(disable: 4244)
				pbRow[i] += pbPrev[i]>>1;
#pragma warning(error: 4244)
				}

			/* The following will not get executed in the 1 pixel wide
				case. */
			for (i=cbpp; i<cbRow;)
				{
				++i;
#pragma warning(disable: 4244)
				pbRow[i] += (pbRow[i-cbpp]+pbPrev[i])>>1;
#pragma warning(error: 4244)
				}
			}

			}//MMX

		return;

	case PNGFPaeth:
		/* Paeth, A.W., "Image File Compression Made Easy", in Graphics
			Gems II, James Arvo, editor.  Academic Press, San Diego, 1991.
			ISBN 0-12-064480-0.

			This reduces to "Subtract" in the case of the first row (because
			we will always use the byte on this row as the predictor.) */
		if (pbPrev != NULL)
			{
			if (m_fMMXAvailable && cbpp > 8 && cbRow >= 128)
				{
				paethMMXUnfilter(pbRow+1, pbPrev+1, cbRow-1, cbpp);
				}
			else 
				{//MMX

			cbpp = (cbpp+7)>>3;   // Now in bytes
			--cbRow;              // For i<cbRow,++i behavior below.

			/* The first cbpp bytes have no previous value in X, but do
				have a value from the prior row, so the predictor reduces
				to PNGFUp. */
			SPNG_U32 i;
			for (i=0; i<cbpp && i<cbRow;)
				{
				++i;
#pragma warning(disable: 4244)
				pbRow[i] += pbPrev[i];
#pragma warning(error: 4244)
				}

			/* Now we genuinely have three possible pixels to use as the
				predictor.  NOTE: I think there is probably some way of
				speeding this particular loop up. */
			for (i=cbpp; i<cbRow;)
				{
				++i;
				int c(pbPrev[i-cbpp]);    // c
				int b(pbRow[i-cbpp] - c); // a-c
				int a(pbPrev[i] - c);     // b-c
				c = abs(a+b);             // (a+b-c)-c
				a = abs(a);               // (a+b-c)-a
				b = abs(b);               // (a+b-c)-b
				if (a <= b)
					{
					if (a <= c)
#pragma warning(disable: 4244)
						pbRow[i] += pbRow[i-cbpp];
#pragma warning(error: 4244)
					else // a > c, so c is least
#pragma warning(disable: 4244)
						pbRow[i] += pbPrev[i-cbpp];
#pragma warning(error: 4244)
					}
				else    // a > b
					{
					if (b <= c)
#pragma warning(disable: 4244)
						pbRow[i] += pbPrev[i];
#pragma warning(error: 4244)
					else // b > c, c is least
#pragma warning(disable: 4244)
						pbRow[i] += pbPrev[i-cbpp];
#pragma warning(error: 4244)
					}
				}

				}//MMX

			return;
			}

		/* Else fall through to the subtract case. */

	case PNGFSub:
		if (m_fMMXAvailable && cbpp > 8 && cbRow >= 128)
			{
			subMMXUnfilter(pbRow+1, cbRow-1, cbpp);
			}
		else
			{//MMX

		cbpp = (cbpp+7)>>3;   // Now in bytes
		--cbRow;              // Exclude filter byte
		for (SPNG_U32 i=cbpp; i<cbRow;)
			{
			++i;
#pragma warning(disable: 4244)
			pbRow[i] += pbRow[i-cbpp];
#pragma warning(error: 4244)
			}

			}//MMX

		return;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngdeinterlace.cpp ===
/*****************************************************************************
	spngdeinterlace.cpp

	PNG support code - deinterlacing.  Implements:
	
	void SPNGREAD::UninterlacePass(SPNG_U8 *pb, int y, int pass)
	void SPNGREAD::Uninterlace(SPNG_U8 *pb, int y)
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngread.h"
#include "spnginternal.h"

// (from ntdef.h)
#ifndef     UNALIGNED
#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

/*****************************************************************************
	De-interlacing.

	Theory
		On a machine with relatively few registers, like the x86, the overhead
	of handling up to four input pointers in parallel so that we can write
	the output only once (doing intermediate calculations in machine registers
	before writing an output unit - a byte or bigger) is going to cause too
	much register pressure.  (4 input pointers, one output pointer, expansion
	tables - four of them - and working registers - no way will this fit in
	a x86).

		So, this code uses the pass algorithm, expanding one pass at a time
	into the output buffer.  The first pass must zero the buffer, the
	subsequent passes or in the new information (better than masking on
	each.)  We potentially need six separate handlers times 3 sub-byte cases
	(1, 2 and 4bpp) plus 1 byte, 2 bytes, 3 bytes and 4 bytes per pixl - that
	is 42 functions, however a small amount of commonality is possible.

		As an optimization the output array must be rounded up to a multiple
	of 8 bytes - so we can handle a complete input byte at 1bpp in pass 1
	without checking for end-of-line.

		I macro generate each of the appropriate functions, the function is
	static and has the name UI<bpp>P<pass> - the function takes pixel count
	of the total number of pixels in the output line.
*****************************************************************************/
/*----------------------------------------------------------------------------
	Macro to swap a SPNG_U32, we give the constants as big endian but must
	swap to little endian on X86.
----------------------------------------------------------------------------*/
#define B_(u) ((u)&0xffU)
#if MAC
	#define S_(u) (u)
	#define U_(u) (u)
#else
	#define S_(u) (B_((u) >>  8) | (B_(u) <<  8))
	#define U_(u) (S_((u) >> 16) | (S_(u) << 16))
#endif


/*----------------------------------------------------------------------------
	1 BPP definitions.  P macro is determined by the initial position, i
	and the step s.  The initial position can be determined from the pass
	(this is, in fact, the simple initial pixel index starting at 0):

		pass   initial pixel (starting at 0)
			1     0
			2     4
			3     0
			4     2
			5     0
			6     1

	this is (pass & 1) ? 0 : (8 >> (pass>>1)), it is inconvenient to use this
	for the bpp<4 cases because we actually want to build the low n bits of
	the value - the value might have 8, 16 or 32 bits.  The following table
	gives the offset of the *rightmost* bit, we work from that:

		pass   initial pixel offset (this goes r to l - backwards)
			1     7
			2     3
			3     3
			4     1
			5     1
			6     0

	which is 7 >> (pass>>1).

	Likewise the step can be determined from the pass:

		pass   step  t      cnv
			1     8   SPNG_U32 U
			2     8   SPNG_U32 U
			3     4   SPNG_U16 S
			4     4   SPNG_U16 S
			5     2   SPNG_U8  B
			6     2   SPNG_U8  B

	which is 8 >> ((pass-1)>>1) (and this is also in pixels.)
----------------------------------------------------------------------------*/
#define InitialPixel(pass)       (((pass) & 1) ? 0 : (8 >> ((pass)>>1)))
#define InitialPixelOffset(pass) (7>>((pass)>>1))
#define Step(pass)               (8>>(((pass)-1)>>1))

#define PSI(x, s, i)\
	((((x)&8)<<(i+3*s-3))|(((x)&4)<<(i+2*s-2))|(((x)&2)<<(i+s-1))|(((x)&1)<<(i)))

#define P(x, pass) PSI(x, Step(pass), InitialPixelOffset(pass))


/*----------------------------------------------------------------------------
	Macro to construct a nibble->SPNG_U32 lookup table for a particular P, P
	is a macro which takes a nibble and constructs the corresponding BIG
	endian SPNG_U32.
----------------------------------------------------------------------------*/
#define MakeTable(t, c, bpp, pass) \
static const t vrg ## bpp ## P ## pass[16] = {\
	c(P(0,pass)), c(P(1,pass)), c(P(2,pass)), c(P(3,pass)), c(P(4,pass)),\
	c(P(5,pass)), c(P(6,pass)), c(P(7,pass)), c(P(8,pass)), c(P(9,pass)),\
	c(P(10,pass)),c(P(11,pass)),c(P(12,pass)),c(P(13,pass)),c(P(14,pass)),\
	c(P(15,pass)) }

#define MakeFunction(t, c, pass, op)\
static void UI1P ## pass(SPNG_U8 *pbOut, const SPNG_U8 *pbIn, int cpix)\
	{\
	MakeTable(t, c, 1, pass);\
	UNALIGNED t* puOut = reinterpret_cast<t*>(pbOut);\
	while (cpix > InitialPixel(pass))\
		{\
		SPNG_U8 bIn(*pbIn++);\
		*puOut++ op vrg1P ## pass[bIn >> 4];\
		*puOut++ op vrg1P ## pass[bIn & 0xf];\
		cpix -= (Step(pass) << 3);\
		}\
	}


/*----------------------------------------------------------------------------
	Now make all the 1 bpp functions.
----------------------------------------------------------------------------*/
MakeFunction(SPNG_U32, U_, 1,  =)
MakeFunction(SPNG_U32, U_, 2, |=)
MakeFunction(SPNG_U16, S_, 3,  =)
MakeFunction(SPNG_U16, S_, 4, |=)
MakeFunction(SPNG_U8,  B_, 5,  =)
MakeFunction(SPNG_U8,  B_, 6, |=)

#undef MakeFunction
#undef PSI


/*----------------------------------------------------------------------------
	2 BPP definitions.  This is more entertaining.  The input bytes expand to
	the same size but the number of pixels processed each time is now halved.
----------------------------------------------------------------------------*/
#define PSI(x, s, i)\
	(( ((x)&12)<<((i+s-1)<<1) )|( ((x)&3)<<((i)<<1) ))

#define MakeFunction(t, c, pass, op)\
static void UI2P ## pass(SPNG_U8 *pbOut, const SPNG_U8 *pbIn, int cpix)\
	{\
	MakeTable(t, c, 2, pass);\
	UNALIGNED t* puOut = reinterpret_cast<t*>(pbOut);\
	while (cpix > InitialPixel(pass))\
		{\
		SPNG_U8 bIn(*pbIn++);\
		*puOut++ op vrg2P ## pass[bIn >> 4];\
		*puOut++ op vrg2P ## pass[bIn & 0xf];\
		cpix -= (Step(pass) << 2);\
		}\
	}


/*----------------------------------------------------------------------------
	So the 2 bpp functions.
----------------------------------------------------------------------------*/
MakeFunction(SPNG_U32, U_, 1,  =)
MakeFunction(SPNG_U32, U_, 2, |=)
MakeFunction(SPNG_U16, S_, 3,  =)
MakeFunction(SPNG_U16, S_, 4, |=)
MakeFunction(SPNG_U8,  B_, 5,  =)
MakeFunction(SPNG_U8,  B_, 6, |=)

#undef MakeFunction
#undef PSI
#undef MakeTable


/*----------------------------------------------------------------------------
	In the 4bpp case each nibble is a pixel, it makes no sense to use a LUT
	to spread the pixels apart (unless we allocate a 256 entry LUT, which I
	avoid doing to save space) so "MakeTable" is no longer required (or is
	not particularly useful.)  The "Step" and "InitialPixel" values tell
	us which *nibble* to start at and we can write each directly the first
	time - any pass before pass 6.  Pass 6 always writes the second (low
	order) nibble.
----------------------------------------------------------------------------*/
#define MakeFunction(pass)\
static void UI4P ## pass(SPNG_U8 *pbOut, const SPNG_U8 *pbIn, int cpix)\
	{\
	cpix -= InitialPixel(pass);\
	pbOut += InitialPixel(pass) >> 1;\
	while (cpix > 0)\
		{\
		SPNG_U8 bIn(*pbIn++);\
		*pbOut = SPNG_U8(bIn & 0xf0); pbOut += Step(pass) >> 1;\
		*pbOut = SPNG_U8(bIn << 4);   pbOut += Step(pass) >> 1;\
		cpix -= (Step(pass) << 1);\
		}\
	}


/*----------------------------------------------------------------------------
	So write the first 5 functions.
----------------------------------------------------------------------------*/
MakeFunction(1)
MakeFunction(2)
MakeFunction(3)
MakeFunction(4)
MakeFunction(5)

#undef MakeFunction


/*----------------------------------------------------------------------------
	And step 6, which must | in the bytes.
----------------------------------------------------------------------------*/
static void UI4P6(SPNG_U8 *pbOut, const SPNG_U8 *pbIn, int cpix)
	{
	--cpix;
	while (cpix > 0)
		{
		SPNG_U8 bIn(*pbIn++);
		*pbOut++ |= SPNG_U8(bIn >> 4);
		*pbOut++ |= SPNG_U8(bIn & 0xf);
		cpix -= 4;
		}
	}


/*----------------------------------------------------------------------------
	Now we are only to the whole byte cases.  We must deal with 1,2,3 or 4
	bytes and with 1,2,3 or 4 16 bit values (for the 16 bit per sample cases).
	Some of these cases overlap, the results are:

		8   1 SPNG_U8
		16  1 SPNG_U16
		24  3 SPNG_U8
		32  1 SPNG_U32
		48  3 SPNG_U16
		64  1 SPNG_U64 (or 2 SPNG_U32)

	This generates functions of the form UI<bitcount>P<pass>
----------------------------------------------------------------------------*/
#define MakeFunction1(t, cbpp, pass)\
static void UI ## cbpp ## P ## pass(SPNG_U8 *pbOut, const SPNG_U8 *pbIn,\
	int cpix)\
	{\
	UNALIGNED t* puOut = reinterpret_cast<t*>(pbOut);\
	const UNALIGNED t* puIn = reinterpret_cast<const t*>(pbIn);\
	puOut += InitialPixel(pass);\
	cpix -= InitialPixel(pass);\
	while (cpix > 0)\
		{\
		*puOut = *puIn++;\
		puOut += Step(pass);\
		cpix -= Step(pass);\
		}\
	}

#define MakeFunction3(t, cbpp, pass)\
static void UI ## cbpp ## P ## pass(SPNG_U8 *pbOut, const SPNG_U8 *pbIn,\
	int cpix)\
	{\
	UNALIGNED t* puOut = reinterpret_cast<t*>(pbOut);\
	const UNALIGNED t* puIn = reinterpret_cast<const t*>(pbIn);\
	puOut += 3*InitialPixel(pass);\
	cpix -= InitialPixel(pass);\
	while (cpix > 0)\
		{\
		*puOut++ = *puIn++;\
		*puOut++ = *puIn++;\
		*puOut++ = *puIn++;\
		puOut += 3*(Step(pass)-1);\
		cpix -= Step(pass);\
		}\
	}


/*----------------------------------------------------------------------------
	Which gives the following.
----------------------------------------------------------------------------*/
#define MakePass(pass)\
	MakeFunction1(SPNG_U8,   8, pass)\
	MakeFunction1(SPNG_U16, 16, pass)\
	MakeFunction3(SPNG_U8,  24, pass)\
	MakeFunction1(SPNG_U32, 32, pass)\
	MakeFunction3(SPNG_U16, 48, pass)\
	MakeFunction1(SPNG_U64, 64, pass)

MakePass(1)
MakePass(2)
MakePass(3)
MakePass(4)
MakePass(5)
MakePass(6)

#undef MakePass
#undef MakeFunction1
#undef MakeFunction3


/*----------------------------------------------------------------------------
	These are stored in a table, we want to index this by bpp count -
	1, 2, 4, 8, 16, 24, 32, 48, 64
----------------------------------------------------------------------------*/
typedef void (*UIP)(SPNG_U8 *pbOut, const SPNG_U8 *pbIN, int cpix);

#define RefPass(name)\
	{ name ## 1, name ## 2, name ## 3, name ## 4, name ## 5, name ##6 }
#define MakePass(cbpp) RefPass(UI ## cbpp ## P)

static const UIP vrgUIP[9][6] =
	{
	MakePass(1),
	MakePass(2),
	MakePass(4),
	MakePass(8),
	MakePass(16),
	MakePass(24),
	MakePass(32),
	MakePass(48),
	MakePass(64)
	};

#undef MakePass
#undef RefPass


/*----------------------------------------------------------------------------
	The index operation.
----------------------------------------------------------------------------*/
inline int IIndex(int cbpp)
	{
	if (cbpp >= 24) return 4 + (cbpp >> 4);
	if (cbpp >=  4) return 2 + (cbpp >> 3);
	return cbpp >> 1;
	}


/*----------------------------------------------------------------------------
	We want an array indexed by bpp.
----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------
	We have a separate function for each pass.  This finds the buffered pass
	image, locates the correct row, then calls the correct function.
----------------------------------------------------------------------------*/
void SPNGREAD::UninterlacePass(SPNG_U8 *pb, SPNG_U32 y, int pass)
	{
	SPNGassert(pass >= 1 && pass <= 6);

	int w(Width());
	int h(Height());
	int cbpp(CBPP());

	/* We need to find the row in the pass buffer, this looks horribly
		complicated but is actually just a straightforwards sequence of
		arithmetic instructions. */
	 const UNALIGNED SPNG_U8 *pbIn = CbPNGPassOffset(w, h, cbpp, pass) +
			CPNGPassBytes(pass, w, cbpp) * CPNGPassRows(pass, y) +
			(m_cbRow << 1) + m_rgbBuffer + 1/*filter byte*/;

	/* Now we can apply the correct un-interlace for this pass and collection
		of component information. */
	vrgUIP[IIndex(cbpp)][pass-1](pb, pbIn, w);
	}


/*----------------------------------------------------------------------------
	Uninterlace the next row into the given buffer.
----------------------------------------------------------------------------*/
void SPNGREAD::Uninterlace(SPNG_U8 *pb, SPNG_U32 y)
	{
	SPNGassert((((int)pb) & 3) == 0);
	SPNGassert((y & 1) == 0);

	// Row 0: 1 6 4 6 2 6 4 6
	// Row 2: Same as 6
	// Row 4: 3 6 4 6 3 6 4 6
	// Row 6: 5 6 5 6 5 6 5 6

	switch (y & 6)
		{
	case 0:
		UninterlacePass(pb, y, 1);
		UninterlacePass(pb, y, 2);
		UninterlacePass(pb, y, 4);
		break;

	case 4:
		UninterlacePass(pb, y, 3);
		UninterlacePass(pb, y, 4);
		break;

	default: // row 2 or row 6
		UninterlacePass(pb, y, 5);
		break;
		}

	UninterlacePass(pb, y, 6);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngicc.h ===
#pragma once
#define SPNGICC_H 1
/*****************************************************************************
	spngicc.h

	Utilities to handle ICC color profile data.
*****************************************************************************/
#include "spngconf.h"

/* Check an ICC chunk for validity.  This can also check for a chunk which 
	is a valid chunk to include ina PNG file.  The cbData value is updated with
	the actual size of the profile if it is less.  This API must be called to
	validate the data before any of the other APIs. */
bool SPNGFValidICC(const void *pvData, size_t &cbData, bool fPNG);

/* Read the profile description, output a PNG style keyword, if possible,
	NULL terminated.  Illegal keyword characters are replaced by spaces,
	however non-ASCII characters are allowed and interpreted as Latin-1. */
bool SPNGFICCProfileName(const void *pvData, size_t cbData, char rgch[80]);

/* Return the end point chromaticities given a validated ICC profile. */
bool SPNGFcHRMFromICC(const void *pvData, size_t cbData, SPNG_U32 rgu[8]);
bool SPNGFCIEXYZTRIPLEFromICC(const void *pvData, size_t cbData,
	CIEXYZTRIPLE &cie);

/* Return the gAMA value (scaled to 100000) from a validated ICC profile. */
bool SPNGFgAMAFromICC(const void *pvData, size_t cbData, SPNG_U32 &ugAMA);
/* Same but the gamma is scaled to 16.16. */
bool SPNGFgammaFromICC(const void *pvData, size_t cbData, SPNG_U32 &redGamma,
	SPNG_U32 &greenGamma, SPNG_U32 &blueGamma);

/* Return the rendering intent from the profile, this does a mapping operation
	into the Win32 intents from the information in the profile header, the
	guts of the API is also provided as a simple mapping function. */
LCSGAMUTMATCH SPNGIntentFromICC(const void *pvData, size_t cbData);
LCSGAMUTMATCH SPNGIntentFromICC(SPNG_U32 uicc);

/* The inverse - given a windows LCSGAMUTMATCH get the corresponding ICC
	intent. */
SPNGICMRENDERINGINTENT SPNGICCFromIntent(LCSGAMUTMATCH lcs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngconf.h ===
#pragma once
#define SPNGCONF_H 1
/*****************************************************************************
    spngconf.h

    SPNG library configuration.
*****************************************************************************/
#if SPNG_INTERNAL && defined(DEBUG) && !defined(_DEBUG)
    #pragma message("     WARNING: _DEBUG switched on")
    #define _DEBUG 1
#endif
  
#include <stddef.h>
#include <string.h>
#pragma intrinsic(memcpy)
#pragma intrinsic(memset)
#pragma intrinsic(strlen)

#include <zlib.h>
#include "spngsite.h"

/* Basic type definitions, hack as required. */
typedef Bytef            SPNG_U8;   // Must match zlib
typedef signed   char    SPNG_S8;
typedef unsigned short   SPNG_U16;
typedef signed   short   SPNG_S16;
typedef unsigned int     SPNG_U32;
typedef signed   int     SPNG_S32;
typedef unsigned __int64 SPNG_U64;
typedef signed   __int64 SPNG_S64;

class SPNGBASE
    {
protected:
    inline SPNGBASE(BITMAPSITE &bms) :
        m_bms(bms)
        {
        }

    inline virtual ~SPNGBASE(void)
        {
        }

public:
    /* The utilities to read short and long values assuming that they are in
        the PNG (big-endian) format. */
    static inline SPNG_U16 SPNGu16(const void *pv)
        {
        const SPNG_U8* pb = static_cast<const SPNG_U8*>(pv);
        return SPNG_U16((pb[0] << 8) + pb[1]);
        }

    static inline SPNG_S16 SPNGs16(const void *pv)
        {
        const SPNG_U8* pb = static_cast<const SPNG_U8*>(pv);
        return SPNG_S16((pb[0] << 8) + pb[1]);
        }

    static inline SPNG_U32 SPNGu32(const void *pv)
        {
        const SPNG_U8* pb = static_cast<const SPNG_U8*>(pv);
        return (((((pb[0] << 8) + pb[1]) << 8) + pb[2]) << 8) + pb[3];
        }

    static inline SPNG_S32 SPNGs32(const void *pv)
        {
        const SPNG_U8* pb = static_cast<const SPNG_U8*>(pv);
        return (((((pb[0] << 8) + pb[1]) << 8) + pb[2]) << 8) + pb[3];
        }

    /* Profile support - the macros automatically build calls to the
        site profile methods but they will only work in a method of a
        sub-class of SPNGBASE. */
    #if _PROFILE || PROFILE || HYBRID
        enum
            {
            spngprofilePNG,
            spngprofileZlib
            };

        #if SPNG_INTERNAL
            #define ProfPNGStart  (m_bms.ProfileStart(spngprofilePNG));
            #define ProfPNGStop   (m_bms.ProfileStop(spngprofilePNG));
            #define ProfZlibStart (m_bms.ProfileStart(spngprofileZlib));
            #define ProfZlibStop  (m_bms.ProfileStop(spngprofileZlib));
        #endif
    #else
        #if SPNG_INTERNAL
            #define ProfPNGStart
            #define ProfPNGStop
            #define ProfZlibStart
            #define ProfZlibStop
        #endif
    #endif

    /* Error handling - again these macros can only be used in the sub-classes.
        They are only used internally. */
    #if _DEBUG
        #define SPNGassert(f)\
            ( (f) || (m_bms.Error(true, __FILE__, __LINE__, #f),false) )
    #else
        #define SPNGassert(f)        ((void)0)
    #endif

    #if _DEBUG && SPNG_INTERNAL
        #define SPNGassert1(f,s,a)\
            ( (f) || (m_bms.Error(true, __FILE__, __LINE__, #f, s,(a)),false) )
        #define SPNGassert2(f,s,a,b)\
            ( (f) || (m_bms.Error(true, __FILE__, __LINE__, #f, s,(a),(b)),false) )

        #define SPNGlog(s)       m_bms.Error(false, __FILE__, __LINE__, s)
        #define SPNGlog1(s,a)    m_bms.Error(false, __FILE__, __LINE__, s,(a))
        #define SPNGlog2(s,a,b)  m_bms.Error(false, __FILE__, __LINE__, s,(a),(b))
        #define SPNGlog3(s,a,b,c)m_bms.Error(false, __FILE__, __LINE__, s,(a),(b),(c))
        #define SPNGcheck(f)       ((f) || (SPNGlog(#f),false))
        #define SPNGcheck1(f,s,a)  ((f) || (SPNGlog1(s,(a)),false))

    #elif SPNG_INTERNAL
        #define SPNGassert1(f,s,a)   ((void)0)
        #define SPNGassert2(f,s,a,b) ((void)0)
        #define SPNGlog(s)           ((void)0)
        #define SPNGlog1(s,a)        ((void)0)
        #define SPNGlog2(s,a,b)      ((void)0)
        #define SPNGlog3(s,a,b,c)    ((void)0)
        #define SPNGcheck(f)         ((void)0)
        #define SPNGcheck1(f,s,a)    ((void)0)
    #endif

    /* Error reporting.  The "icase" value is one of the following
        enumeration.  The "iarg" value is as described below.  If the
        API returns false then the sub-class will set an internal
        "bad format" flag. */
    enum
        {
        pngformat,   // Unspecified format error, iarg is input chunk
        pngcritical, // Unrecognized critical chunk, iarg is chunk
        pngspal,     // Suggested palette seen, iarg is chunk
        pngzlib,     // Zlib error, iarg is error code (made positive)
        };

    /* Zlib interface - utilities to deal with Zlib stuff. */
    bool         FCheckZlib(int ierr);

    /* Built in Zlib maximum buffer sizes. */
    #define SPNGCBINFLATE ((1<<15)+SPNGCBZLIB)
    #define SPNGCBDEFLATE ((256*1024)+SPNGCBZLIB)

protected:
    /* Utilities for PNG format handling. */
    inline int CComponents(SPNG_U8 c/*ColorType*/) const
        {
        SPNGassert((c & 1) == 0 || c == 3);
        return (1 + (c & 2) + ((c & 4) >> 2)) >> (c & 1);
        }

    BITMAPSITE &m_bms;
    };


/*****************************************************************************
    PNG definitions from the standard.

    Basic chunk types.  Only the types we recognize are defined.
*****************************************************************************/
#define PNGCHUNK(a,b,c,d) ((SPNG_U32)(((a)<<24)+((b)<<16)+((c)<<8)+(d)))
#define FPNGCRITICAL(c) (((c) & PNGCHUNK(0x20,0,0,0)) == 0)
#define FPNGSAFETOCOPY(c) (((c) & PNGCHUNK(0,0,0,0x20)) != 0)

#define PNGIHDR PNGCHUNK('I','H','D','R')
#define PNGPLTE PNGCHUNK('P','L','T','E')
#define PNGIDAT PNGCHUNK('I','D','A','T')
#define PNGIEND PNGCHUNK('I','E','N','D')
#define PNGbKGD PNGCHUNK('b','K','G','D')
#define PNGcHRM PNGCHUNK('c','H','R','M')
#define PNGiCCP PNGCHUNK('i','C','C','P')
#define PNGicCP PNGCHUNK('i','c','C','P')
#define PNGgAMA PNGCHUNK('g','A','M','A')
#define PNGsRGB PNGCHUNK('s','R','G','B')
#define PNGsrGB PNGCHUNK('s','r','G','B')
#define PNGpHYs PNGCHUNK('p','H','Y','s')
#define PNGsBIT PNGCHUNK('s','B','I','T')
#define PNGsCAL PNGCHUNK('s','C','A','L')
#define PNGtEXt PNGCHUNK('t','E','X','t')
#define PNGtIME PNGCHUNK('t','I','M','E')
#define PNGhIST PNGCHUNK('h','I','S','T')
#define PNGtRNS PNGCHUNK('t','R','N','S')
#define PNGzTXt PNGCHUNK('z','T','X','t')        
#define PNGsPLT PNGCHUNK('s','P','L','T')
#define PNGspAL PNGCHUNK('s','p','A','L')

/* The Office special chunks. */
#define PNGmsO(b) PNGCHUNK('m','s','O',b)
#define PNGmsOC PNGmsO('C')                /* Has MSO aac signature. */
#define PNGmsOA PNGmsO('A')
#define PNGmsOZ PNGmsO('Z')
#define PNGmsOD PNGmsO('D')                /* Dummy chunk to pad buffer. */

/* The GIF compatibility chunks. */
#define PNGmsOG PNGmsO('G')                /* Complete GIF. */
#define PNGmsOP PNGmsO('P')                /* Position of PLTE. */
/* The following is not currently implemented. */
//#define PNGmsOU PNGmsO('U')                /* Unrecognized extension. */
#define PNGgIFg PNGCHUNK('g','I','F','g')  /* Graphic control extension. */
/* Plain text forces us to use msOG and store the whole thing. */
#define PNGgIFg PNGCHUNK('g','I','F','g')  /* Graphic control extension info*/
#define PNGgIFx PNGCHUNK('g','I','F','x')  /* Unknown application extension */

/* Compression information chunk. */
#define PNGcmPP PNGCHUNK('c','m','P','P')  /* CoMPression Parameters. */


/*****************************************************************************
    Color types.
*****************************************************************************/
typedef enum
    {
    PNGColorTypeGray      = 0, // Valid color type
    PNGColorMaskPalette   = 1, // Invalid color type
    PNGColorMaskColor     = 2,
    PNGColorTypeRGB       = 2, // Valid color type
    PNGColorTypePalette   = 3, // Valid color type
    PNGColorMaskAlpha     = 4,
    PNGColorTypeGrayAlpha = 4, // Valid color type
    PNGColorTypeRGBAlpha  = 6  // Valid color type
    }
PNGCOLORTYPE;


/*****************************************************************************
    The filter types.
*****************************************************************************/
#define PNGFMASK(filter) (1<<((filter)+3))
typedef enum
    {
    PNGFNone        = 0,
    PNGFSub         = 1,
    PNGFUp          = 2,
    PNGFAverage     = 3,
    PNGFPaeth       = 4,
    PNGFMaskNone    = PNGFMASK(PNGFNone),
    PNGFMaskSub     = PNGFMASK(PNGFSub),
    PNGFMaskUp      = PNGFMASK(PNGFUp),
    PNGFMaskAverage = PNGFMASK(PNGFAverage),
    PNGFMaskPaeth   = PNGFMASK(PNGFPaeth),
    PNGFMaskAll     = (PNGFMaskNone | PNGFMaskSub | PNGFMaskUp |
                                PNGFMaskAverage | PNGFMaskPaeth)
    }
PNGFILTER;


/*****************************************************************************
    sRGB rendering intents (also ICM rendering intent).
*****************************************************************************/
typedef enum
    {
    ICMIntentPerceptual           = 0,
    ICMIntentRelativeColorimetric = 1,
    ICMIntentSaturation           = 2,
    ICMIntentAbsoluteColorimetric = 3,
    ICMIntentUseDatatype          = 4
    }
SPNGICMRENDERINGINTENT;


/*****************************************************************************
    sRGB gAMA value - this is the value adopted by the PNG specification,
    a slightly better fit to the inverse of the sRGB function is given by
    44776, but this is not significantly different and this *is* the expected
    value.
*****************************************************************************/
#define sRGBgamma 45455


/*****************************************************************************
    Compression parameter storage.  This is stored in a special chunk which is
    documented here.  The first byte stores information about how the remainder
    of the parameters were determined.  The remaining bytes store information
    about the actual compression method used.  At present there must be exactly
    three bytes which record:

        METHOD:   one byte SPNGcmPPMETHOD as below
        FILTER:   one byte holding an encoded filter/mask value as PNGFILTER
        STRATEGY: one byte holding the Zlib "strategy" value
        LEVEL:    one byte holding the actual Zlib compression level

    The LEVEL byte is an index into the table compiled with Zlib 1.0.4 (i.e.
    configuration_table in deflate.c).

    If the number of bytes does not match the above the information matches
    some other version of Zlib or is encoded in some other way and should be
    ignored.
*****************************************************************************/
typedef enum
    {
    SPNGcmPPDefault    = 0, // Parameters determined from defaults
    SPNGcmPPCheck      = 1, // Program performed a check on compression level
    SPNGcmPPSearch     = 2, // Program tried some set of strategy/filtering
    SPNGcmPPExhaustive = 3, // Exhaustive search of all options
    SPNGcmPPAdaptive   = 4, // Exhaustive search of options per-line
    }
SPNGcmPPMETHOD;


/*****************************************************************************
    The signature.
*****************************************************************************/
extern const SPNG_U8 vrgbPNGSignature[8];
#define cbPNGSignature (sizeof vrgbPNGSignature)

extern const SPNG_U8 vrgbPNGMSOSignature[11];
#define cbPNGMSOSignature (sizeof vrgbPNGMSOSignature)

extern const SPNG_U8 vrgbPNGcmPPSignature[8];
#define cbPNGcmPPSignature (sizeof vrgbPNGcmPPSignature)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spnginterlace.cpp ===
/*****************************************************************************
	spnginterlace.cpp

	PNG image writing support.

   Basic code to interlace a single line plus row packing support.
*****************************************************************************/
#include <basetsd.h>
#include <stdlib.h>
#pragma intrinsic(_rotr, _rotl)

#define SPNG_INTERNAL 1
#include "spngwrite.h"


/*----------------------------------------------------------------------------
	The interlacing magic table (IMT) - this takes a one byte value (256
	entries) and makes the nibble consisting of only the odd bits, thus:
	
		76543210 --> 75316420

	This can also be used to pack pixels when we get them in an expanded form.
----------------------------------------------------------------------------*/
#define IMTB(x) ( ((x)&0x80)+(((x)&0x20)<<1)+(((x)&0x8)<<2)+(((x)&0x2)<<3)+\
						(((x)&0x40)>>3)+(((x)&0x10)>>2)+(((x)&0x4)>>1)+((x)&0x1) )

#define IMTRow4(x)  IMTB(x), IMTB(x+1), IMTB(x+2), IMTB(x+3)
#define IMTRow16(x) IMTRow4(x), IMTRow4(x+4), IMTRow4(x+8), IMTRow4(x+12)
#define IMTRow64(x) IMTRow16(x), IMTRow16(x+16), IMTRow16(x+32), IMTRow16(x+48)

static const SPNG_U8 vrgbIL1[256] =
	{
	IMTRow64(0),
	IMTRow64(64),
	IMTRow64(128),
	IMTRow64(128+64)
	};

#undef IMTB


/*----------------------------------------------------------------------------
	We also need support for the 2bpp case:
	
		33221100 --> 33112200

	Notice that the two tables reduce both 1bpp and 2bpp to the 4bpp case where
	the nibbles must be deinterlaced.
----------------------------------------------------------------------------*/
#define IMTB(x) ( ((x)&0xc0)+(((x)&0x0c)<<2)+(((x)&0x30)>>2)+((x)&0x3) )

static const SPNG_U8 vrgbIL2[256] =
	{
	IMTRow64(0),
	IMTRow64(64),
	IMTRow64(128),
	IMTRow64(128+64)
	};

#undef IMTB
#undef IMTRow64
#undef IMTRow16
#undef IMTRow4


/*----------------------------------------------------------------------------
	Bit pump macros.  Given a buffer of b bits add 24 bits, the BSHIFT macro
	puts the 24 bits in the correct place, the BREM macro returns the last b
	bits assuming that there are 24 in the input.  The BINDEX macro returns
	the ith byte (starting at 0.)  The ROTF macro rotates the 32 bit value
	*forward* by n bytes - i.e. it is rotated to the left on the display (so
	the original n+1 byte is now byte 1.)  MASK13 selects the first and third
	bytes in the 32 bit quantity, ~MASK13 therefore selects the second and
	fourth - again this is counting from low memory.
----------------------------------------------------------------------------*/
#if MAC
	#define BSHIFT(u, b) ((u) >> (b))
	#define BREM(u, b) ((u) << (24-(b)))
	#define BINDEX(u, i) ((u) >> (24-8*(i)))
	#define ROTF(u, i) _rotl((u), 8*(i))
	#define MASK13 0xFF00FF00UL
	#define UWORD(b1,b2,b3,b4) (((b1)<<24)+((b2)<<16)+((b3)<<8)+(b4))
#else
	#define BSHIFT(u, b) ((u) << (b))
	#define BREM(u, b) ((u) >> (24-(b)))
	#define BINDEX(u, i) ((u) >> (8*(i)))
	#define ROTF(u, i) _rotr((u), 8*(i))
	#define MASK13 0x00FF00FFUL
	#define UWORD(b1,b2,b3,b4) (((b4)<<24)+((b3)<<16)+((b2)<<8)+(b1))
#endif

/*****************************************************************************
	ROW PACKING
*****************************************************************************/
/*----------------------------------------------------------------------------
	Pack a row - called to copy a row which needs packing.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FPackRow(SPNG_U8 *pb, const SPNG_U8 *pbIn, SPNG_U32 cbpp)
	{
	const SPNG_U32 cbppOut(m_cbpp);
	SPNGassert(cbpp <= 8 && cbppOut <= 8 && cbppOut < cbpp ||
		cbpp <= 8 && m_pbTrans != NULL ||
		cbpp == 16 && cbppOut == 24 ||
		cbpp == 24 && cbppOut == 24 && m_fBGR ||
		cbpp == 32 && (cbppOut == 24 || cbppOut == 32 && (m_fBGR || m_fMacA)));

	/* The alternative, step through packing the rows.  Remember that the world
		is big-endian, we want fewer bits out than in except in the 16bpp case
		(where we do require more.) */
	int w(m_w);        // NOTE: signed comparisons below.
	SPNGassert(w > 0); // 0 case is handled in caller.
	if (w <= 0)
		return true;

	if (cbpp <= 8 && cbpp == cbppOut)
		{
		w = (w * cbpp + 7) >> 3;

		const SPNG_U8* pbTrans = m_pbTrans;
		SPNGassert(pbTrans != NULL);
		if (pbTrans != NULL)
			do
				*pb++ = pbTrans[*pbIn++];
			while (--w > 0);
		else // Error recovery
			memcpy(pb, pbIn, w);
		return true;
		}
	
	switch (cbpp)
		{
	case 2:
		if (cbppOut != 1)
			break;
		/* I don't think I have a way of excercising this code. */
		SPNGassert(("SPNG: 2->1bpp untested, please note this test case", false));

		/* We want x6x4x2x0 --> ....6420 we can do that with vrgbIL1.  We must
			select the low bit from each of the pixels.  The loop does 8 pixels
			at a time, but is valid so long as we have at least 5. */
		if (m_pbTrans != NULL)
			{
			const SPNG_U8* pbTrans = m_pbTrans;
			while (w > 4)
				{
#pragma warning(disable: 4244)
				*pb++ = (vrgbIL1[pbTrans[pbIn[0]]] << 4) + (vrgbIL1[pbTrans[pbIn[1]]] & 0x0f);
#pragma warning(error: 4244)
				pbIn += 2;
				w -= 8;
				}

			if (w > 0)
				{
#pragma warning(disable: 4244)
				*pb = vrgbIL1[pbTrans[pbIn[0]]] << 4;
#pragma warning(error: 4244)
				}
			}
		else
			{
			while (w > 4)
				{
#pragma warning(disable: 4244)
				*pb++ = (vrgbIL1[pbIn[0]] << 4) + (vrgbIL1[pbIn[1]] & 0x0f);
#pragma warning(error: 4244)
				pbIn += 2;
				w -= 8;
				}

			if (w > 0)
				{
#pragma warning(disable: 4244)
				*pb = vrgbIL1[pbIn[0]] << 4;
#pragma warning(error: 4244)
				}
			}
		return true;


	case 4:
		/* Must be mapping either to 1bpp or 2bpp. */
		if (cbppOut == 2)
			{
			/* xx54xx10 --> ....5410
				It's not clear whether this will be faster using
				vrgbIL2 or the inplace operations below, at present
				I think in-place calculations are better because we
				only want half of the vrgbIL2 result. */
			#define UP42u(x) ((((x)&0x30)<<2)+(((x)&0x3)<<4))
			#define UP42l(x) ((((x)&0x30)>>2)+(((x)&0x3)))
			if (m_pbTrans != NULL)
				{
				const SPNG_U8* pbTrans = m_pbTrans;
				while (w > 2)
					{
					SPNG_U8 b0(pbTrans[*pbIn++]);
					SPNG_U8 b1(pbTrans[*pbIn++]);
#pragma warning(disable: 4244)
					*pb++ = UP42u(b0) + UP42l(b1);
#pragma warning(error: 4244)
					w -= 4;
					}

				if (w > 0)
					{
					SPNG_U8 b(pbTrans[*pbIn]);
#pragma warning(disable: 4244)
					*pb = UP42u(b);
#pragma warning(error: 4244)
					}
				}
			else
				{
				while (w > 2)
					{
					SPNG_U8 b0(*pbIn++);
					SPNG_U8 b1(*pbIn++);
#pragma warning(disable: 4244)
					*pb++ = UP42u(b0) + UP42l(b1);
#pragma warning(error: 4244)
					w -= 4;
					}

				if (w > 0)
					{
					SPNG_U8 b(*pbIn);
#pragma warning(disable: 4244)
					*pb = UP42u(b);
#pragma warning(error: 4244)
					}
				}
			return true;
			}
		else if (cbppOut == 1)
			{
			/* xxx4xxx0 --> ......40 */
			#define UP2(x) ( ((x) & 1) + (((x)>>3) & 2) )
			if (m_pbTrans != NULL)
				{
				const SPNG_U8* pbTrans = m_pbTrans;
				SPNG_U32 u(1);
				do
					{
					SPNG_U8 b(pbTrans[*pbIn++]);
					u = (u << 2) + UP2(b);
					if (u > 255)
						{
#pragma warning(disable: 4244 4242)
						*pb++ = u;
#pragma warning(error: 4244 4242)
						u = 1;
						}
					w -= 2;
					}
				while (w > 0);
				if (u > 1) // Still some bits to output
					{
					while (u < 256) u <<= 2;
#pragma warning(disable: 4244 4242)
					*pb = u;
#pragma warning(error: 4244 4242)
					}
				}
			else
				{
				SPNG_U32 u(1);
				do
					{
					SPNG_U8 b(*pbIn++);
					u = (u << 2) + UP2(b);
					if (u > 255)
						{
#pragma warning(disable: 4244 4242)
						*pb++ = u;
#pragma warning(error: 4244 4242)
						u = 1;
						}
					w -= 2;
					}
				while (w > 0);
				if (u > 1) // Still some bits to output
					{
					while (u < 256) u <<= 2;
#pragma warning(disable: 4244 4242)
					*pb = u;
#pragma warning(error: 4244 4242)
					}
				}
			return true;
			}
		else
			break;


	case 8:
		/* Can have any of 1, 2 or 4 bits. */
			{
			SPNG_U32 u(1);
			SPNG_U32 umask((1<<cbppOut)-1);
			if (m_pbTrans != NULL)
				{
				const SPNG_U8* pbTrans = m_pbTrans;
				do
					{
					u = (u << cbppOut) + (pbTrans[*pbIn++] & umask);
					if (u > 255)
						{
#pragma warning(disable: 4244 4242)
						*pb++ = u;
#pragma warning(error: 4244 4242)
						u = 1;
						}
					}
				while (--w > 0);
				}
			else do
				{
				u = (u << cbppOut) + (*pbIn++ & umask);
				if (u > 255)
					{
#pragma warning(disable: 4244 4242)
					*pb++ = u;
#pragma warning(error: 4244 4242)
					u = 1;
					}
				}
			while (--w > 0);

			if (u > 1) // Still some bits to output
				{
				while (u < 256) u <<= cbppOut;
#pragma warning(disable: 4244 4242)
				*pb = u;
#pragma warning(error: 4244 4242)
				}
			}
		return true;


	case 16:
		/* This must be the translation case, we go from 16 bits to 24 bits
			at the output.  The lookup tables are arranged in the correct order
			for the machine byte order. */
		if (cbppOut != 24)
			break;

		SPNGassert(m_pu1 != NULL && m_pu2 != NULL);
		if (m_pu1 != NULL && m_pu2 != NULL)
			{
			const SPNG_U32 *pu1 = m_pu1;
			const SPNG_U32 *pu2 = m_pu2;
			/* Buffer should be aligned. */
			SPNGassert((((INT_PTR)pb) & 3) == 0);
			SPNG_U32 *pu = reinterpret_cast<SPNG_U32*>(pb);

			/* We must translate w pixels - w input 16bit values into w 24 bit
				output values. */
			SPNG_U32 bb(0);  /* Temporary bit buffer. */
			SPNG_U32 b(0);   /* Count in buffer. */
			do
				{
				SPNG_U32 bbIn(pu1[*pbIn++]);
				bbIn += pu2[*pbIn++];

				bb += BSHIFT(bbIn, b);
				b += 24;
				/* NOTE: >>32 does not give 0 on x86, so we must make sure
					that b never gets to 32 before the BSHIFT above. */
				if (b >= 32)
					{
					*pu++ = bb;
					b -= 32;
					bb = BREM(bbIn, b);
					}
				}
			while (--w > 0);

			/* There may be some bits left to output. */
			if (b > 0)
				*pu = bb;
			}
		return true;


	case 24:
		/* We only support byte swapping for 24bpp - i.e. m_fBGR. */
		if (cbppOut != 24)
			break;

		SPNGassert(m_fBGR);
		if (m_fBGR)
			{
			/* Note that byte order doesn't matter here - we go from an
				input which is BGRBGRBGR to an output with is RGBRGBRGB. */
			do
				{
				*pb++ = pbIn[2];
				*pb++ = pbIn[1];
				*pb++ = pbIn[0];
				pbIn += 3;
				}
			while (--w > 0);
			}
		return true;

	case 32:
		if (cbppOut == 24) /* Strip trailing alpha byte. */
			{
			/* Sometimes the input might be misaligned (we don't explicitly
				require it to be aligned) so we do this two different ways. */
			if ((((INT_PTR)pbIn) & 3) == 0)
				{
				const SPNG_U32 *puIn = reinterpret_cast<const SPNG_U32*>(pbIn);

				if (m_fBGR) /* And reverse the bytes along the way. */
					do
						{
						SPNG_U32 u(*puIn++);
#pragma warning(disable: 4244)
						*pb++ = BINDEX(u, 2);  // R
						*pb++ = BINDEX(u, 1);  // G
						*pb++ = BINDEX(u, 0);  // B
#pragma warning(error: 4244)
						}
					while (--w > 0);
				else
					{
					SPNGassert(m_fMacA);
					do
						{
						SPNG_U32 u(*puIn++);
#pragma warning(disable: 4244)
						*pb++ = BINDEX(u, 1);  // R
						*pb++ = BINDEX(u, 2);  // G
						*pb++ = BINDEX(u, 3);  // B
#pragma warning(error: 4244)
						}
					while (--w > 0);
					}
				}
			else
				{
				/* Do this byte by byte. */
				if (m_fBGR)
					{
					do
						{ // BGRA
						*pb++ = pbIn[2];  // R
						*pb++ = pbIn[1];  // G
						*pb++ = pbIn[0];  // B
						pbIn += 4;
						}
					while (--w > 0);
					}
				else
					{
					SPNGassert(m_fMacA);
					do
						{ // ARGB
						*pb++ = pbIn[1];  // R
						*pb++ = pbIn[2];  // G
						*pb++ = pbIn[3];  // B
						pbIn += 4;
						}
					while (--w > 0);
					}
				}
			return true;
			}

		/* This can *only* be the m_fBGR case - we have got BGRA data in
			the stream and we must generate RGBA data. */
		if (cbppOut != 32)
			break;

		if (m_fBGR)
			{
			SPNGassert((((INT_PTR)pb) & 3) == 0);
			SPNG_U32 *pu = reinterpret_cast<SPNG_U32*>(pb);

			if ((((INT_PTR)pbIn) & 3) == 0)
				{
				const SPNG_U32 *puIn = reinterpret_cast<const SPNG_U32*>(pbIn);
			
				do
					{
					SPNG_U32 u(*puIn++);
					/* BGRA --> RGBA. */
					*pu++ = (ROTF(u, 2) & MASK13) + (u & ~MASK13);
					}
				while (--w > 0);
				}
			else
				{
				do
					{ // BGRA
					*pu++ = UWORD(
								pbIn[2],  // R
								pbIn[1],  // G
								pbIn[0],  // B
								pbIn[3]); // A
					pbIn += 4;
					}
				while (--w > 0);
				}
			}
		else
			{
			SPNGassert(m_fMacA);

			SPNGassert((((INT_PTR)pb) & 3) == 0);
			SPNG_U32 *pu = reinterpret_cast<SPNG_U32*>(pb);

			if ((((INT_PTR)pbIn) & 3) == 0)
				{
				const SPNG_U32 *puIn = reinterpret_cast<const SPNG_U32*>(pbIn);
			
				do
					/* ARGB --> RGBA. */
					*pu++ = ROTF(*puIn++, 1);
				while (--w > 0);
				}
			else
				{
				do
					{ // ARGB
					*pu++ = UWORD(
								pbIn[1],  // R
								pbIn[2],  // G
								pbIn[3],  // B
								pbIn[0]); // A
					pbIn += 4;
					}
				while (--w > 0);
				}
			}

		return true;
		}

	/* Here on something we cannot do. */
	SPNGlog2("SPNG: packing %d bits to %d bits impossible", cbpp, cbppOut);
	return false;
	}


/*****************************************************************************
	INTERLACING
*****************************************************************************/
/*****************************************************************************
	vrgbIL1 gives: 7654321 --> 75316420, thus we can separate out pass 6 into
	the latter half of the row.  On rows 2 and 6 we have 56565656 --> 55556666,
	which is sufficient.  On row 4:-

		36463646 --> 34346666,  34343434 --> 33334444

	and on row 0:-

		16462646 --> 14246666,  14241424 --> 12124444,
										12121212 --> 11112222

	Thus we may need up to three passes through the loop, although each pass
	need process only half the data of the previous pass.

	In all cases for <8 bit pixels the first step separates the data
	into 8 bit units - by separating each byte into a high nibble for
	the first half of the row and a low nibble.
*****************************************************************************/
/*----------------------------------------------------------------------------
	Given a pair of output buffers and an input which is a multiple of 2 bytes
	in length interlace nibbles - high nibbles go to the first buffer, low
	nibbles to the second.

	This API is also capable of translating the input bytes via an optional
	interlace lookup table which  must be either vrgbIL1 or vrgbIL2, the net
	effect is to interlace either 1 bit or 2 bit pixels according to which LUT
	is passed.

	For 1, 2 or 4bpp interlacing is just a process of separating alternate
	pixels into two blocks, this is repeated 1 2 or 3 times with, at each
	step, half the pixels of the previous step.  Although the output must be
	in a separate buffer pass>1 cases modify the passed in buffer as well.
----------------------------------------------------------------------------*/
inline void Interlace12(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 cb, int pass,
	const SPNG_U8 rgbIL[256])
	{
	while (--pass >= 0)
		{
		/* First half of output. */
		SPNG_U8* pbHigh;
		if (pass == 0)
			pbHigh = pbOut;
		else
			pbHigh = pbIn;

		/* Latter half of output, and double-byte count. */
		cb >>= 1;
		SPNG_U8* pbLow = pbOut+cb;
		int cbT(cb);

		SPNG_U8* pb = pbIn;
		while (--cbT >= 0)
			{
			SPNG_U8 b1(rgbIL[*pb++]);
			SPNG_U8 b2(rgbIL[*pb++]);
#pragma warning(disable: 4244)
			*pbHigh++ = (b1 & 0xf0) + (b2 >> 4);
			*pbLow++  = (b1 << 4) + (b2 & 0xf);
#pragma warning(error: 4244)
			}
		}
	}


/*----------------------------------------------------------------------------
	4bpp is identical except that it needs no LUT.
----------------------------------------------------------------------------*/
inline void Interlace4(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 cb, int pass)
	{
	while (--pass >= 0)
		{
		/* First half of output. */
		SPNG_U8* pbHigh;
		if (pass == 0)
			pbHigh = pbOut;
		else
			pbHigh = pbIn;

		/* Latter half of output, and double-byte count. */
		cb >>= 1;
		SPNG_U8* pbLow = pbOut+cb;
		int cbT(cb);

		SPNG_U8* pb = pbIn;
		while (--cbT >= 0)
			{
			SPNG_U8 b1(*pb++);
			SPNG_U8 b2(*pb++);
#pragma warning(disable: 4244)
			*pbHigh++ = (b1 & 0xf0) + (b2 >> 4);
			*pbLow++  = (b1 << 4) + (b2 & 0xf);
#pragma warning(error: 4244)
			}
		}
	}


/*----------------------------------------------------------------------------
	8bpp can work in one pass - we just need the "index to x" magic function.
	This takes an index into the original data, the number of passes (which
	indicates the interleave function) and the number of "units" in the input
	(which may not be the actual number of pixels - it is just a measure of the
	total number of objects being moved - citems>>1 is the position of the
	first pass, citems>>2 of the second and citems>>3 of the third).
----------------------------------------------------------------------------*/
#if 0
inline SPNG_U32 IPass(SPNG_U32 i, int pass, SPNG_U32 citems)
	{
	/* The long form. */
	if (i&1)
		return ((citems+1)>>1) + (i>>1);
	if (pass < 2)
		return (i>>1);
	if (i&2)
		return ((citems+3)>>2) + (i>>2);
	if (pass < 3)
		return (i>>2);
	if (i&4)
		return ((citems+7)>>3) + (i>>3);
	return (i>>3);
	}

#define IPass1(i,w) IPass(i,1,w)
#define IPass2(i,w) IPass(i,2,w)
#define IPass3(i,w) IPass(i,3,w)
#else
/* Form which attempts to get inlining. */
inline SPNG_U32 IPass1(SPNG_U32 i, SPNG_U32 citems)
	{
	return (((citems+1)>>1) & ~((i&1)-1)) + (i>>1);
	}

inline SPNG_U32 IPass2(SPNG_U32 i, SPNG_U32 citems)
	{
	if (i&1)
		return ((citems+1)>>1) + (i>>1);
	i >>= 1;
	return (((citems+3)>>2) & ~((i&1)-1)) + (i>>1);
	}

inline SPNG_U32 IPass3(SPNG_U32 i, SPNG_U32 citems)
	{
	/* The long form. */
	if (i&1)
		return ((citems+1)>>1) + (i>>1);
	i >>= 1;
	if (i&1)
		return ((citems+3)>>2) + (i>>1);
	i >>= 1;
	return (((citems+7)>>3) & ~((i&1)-1)) + (i>>1);
	}
#endif

void XXXNoInLineInterlace8(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			pbOut[IPass1(i,w)] = pbIn[i];
		return;
	case 2:
		for (i=0; i<w; ++i)
			pbOut[IPass2(i,w)] = pbIn[i];
		return;
	case 3:
		for (i=0; i<w; ++i)
			pbOut[IPass3(i,w)] = pbIn[i];
		return;
		}
	}

void XXXNoInLineInterlace16(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U16* puOut = reinterpret_cast<SPNG_U16*>(pbOut);
	SPNG_U16* puIn  = reinterpret_cast<SPNG_U16*>(pbIn);
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			puOut[IPass1(i,w)] = puIn[i];
		return;
	case 2:
		for (i=0; i<w; ++i)
			puOut[IPass2(i,w)] = puIn[i];
		return;
	case 3:
		for (i=0; i<w; ++i)
			puOut[IPass3(i,w)] = puIn[i];
		return;
		}
	}

void XXXNoInLineInterlace24(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass1(i,w)*3);
			SPNG_U32 iTT(i*3);
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT] = pbIn[iTT];
			}
		return;
	case 2:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass2(i,w)*3);
			SPNG_U32 iTT(i*3);
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT] = pbIn[iTT];
			}
		return;
	case 3:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass3(i,w)*3);
			SPNG_U32 iTT(i*3);
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT++] = pbIn[iTT++];
			pbOut[iT] = pbIn[iTT];
			}
		return;
		}
	}

void XXXNoInLineInterlace32(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U32* puOut = reinterpret_cast<SPNG_U32*>(pbOut);
	SPNG_U32* puIn  = reinterpret_cast<SPNG_U32*>(pbIn);
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			puOut[IPass1(i,w)] = puIn[i];
		return;
	case 2:
		for (i=0; i<w; ++i)
			puOut[IPass2(i,w)] = puIn[i];
		return;
	case 3:
		for (i=0; i<w; ++i)
			puOut[IPass3(i,w)] = puIn[i];
		return;
		}
	}

void XXXNoInLineInterlace48(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U16* puOut = reinterpret_cast<SPNG_U16*>(pbOut);
	SPNG_U16* puIn  = reinterpret_cast<SPNG_U16*>(pbIn);
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass1(i,w)*3);
			SPNG_U32 iTT(i*3);
			puOut[iT++] = puIn[iTT++];
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
	case 2:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass2(i,w)*3);
			SPNG_U32 iTT(i*3);
			puOut[iT++] = puIn[iTT++];
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
	case 3:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass3(i,w)*3);
			SPNG_U32 iTT(i*3);
			puOut[iT++] = puIn[iTT++];
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
		}
	}

void XXXNoInLineInterlace64(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 w, int pass)
	{
	SPNG_U32* puOut = reinterpret_cast<SPNG_U32*>(pbOut);
	SPNG_U32* puIn  = reinterpret_cast<SPNG_U32*>(pbIn);
	SPNG_U32 i;
	switch (pass)
		{
	case 1:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass1(i,w)<<1);
			SPNG_U32 iTT(i<<1);
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
	case 2:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass2(i,w)<<1);
			SPNG_U32 iTT(i<<1);
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
	case 3:
		for (i=0; i<w; ++i)
			{
			SPNG_U32 iT(IPass3(i,w)<<1);
			SPNG_U32 iTT(i<<1);
			puOut[iT++] = puIn[iTT++];
			puOut[iT] = puIn[iTT];
			}
		return;
		}
	}


/*----------------------------------------------------------------------------
	Fundamental interlace API - just interlaces one line.
----------------------------------------------------------------------------*/
void SPNGWRITE::Interlace(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 cb, SPNG_U32 cbpp,
	SPNG_U32 y)
	{
	/* We require the interlace buffer to be on an 8 byte boundary because we
		will access the data as 32 bit quantities for speed. */
	SPNGassert((y&~6) == 0);  // Even lines only
	SPNGassert((cb&7) == 0);  // Buffer is a multiple of 8 bytes
	SPNGassert((((INT_PTR)pbIn)&3) == 0);
	SPNGassert((((INT_PTR)pbOut)&3) == 0);

	if (cb < 8)
		{
		SPNGlog1("SPNG: interlace call not expected %d", cb);
		return;
		}

	/* Work out the number of "steps" - 1, 2 or 3 according to y. */
	int pass((y & 2) ? 1 : (3 - ((y&4)>>2)));
	SPNGassert(pass >= 1 && pass <= 3);
	switch (cbpp)
		{
	case 1:
		Interlace12(pbOut, pbIn, cb, pass, vrgbIL1);
		break;
	case 2:
		Interlace12(pbOut, pbIn, cb, pass, vrgbIL2);
		break;
	case 4:
		Interlace4(pbOut, pbIn, cb, pass);
		break;
	case 8:
		XXXNoInLineInterlace8(pbOut, pbIn, m_w, pass);
		break;
	case 16:
		XXXNoInLineInterlace16(pbOut, pbIn, m_w, pass);
		break;
	case 24:
		XXXNoInLineInterlace24(pbOut, pbIn, m_w, pass);
		break;
	case 32:
		XXXNoInLineInterlace32(pbOut, pbIn, m_w, pass);
		break;
	case 48:
		XXXNoInLineInterlace48(pbOut, pbIn, m_w, pass);
		break;
	case 64:
		XXXNoInLineInterlace64(pbOut, pbIn, m_w, pass);
		break;
	default:
		/* The assert is generated once per image by the y==0 test. */
		SPNGassert1(y != 0, "SPNG: bpp %d invalid", cbpp);
		/* And just ignore it. */
		break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngicc.cpp ===
/*****************************************************************************
        spngicc.cpp

        Basic ICC profile support.
*****************************************************************************/
#include <math.h>

#pragma intrinsic(log, exp)

/* Force these to be inlined. */
#pragma optimize("g", on)
inline double InlineLog(double x) { return log(x); }
inline double InlineExp(double x) { return exp(x); }
#define log(x) InlineLog(x)
#define exp(x) InlineExp(x)
/* Restore default optimization. */
#pragma optimize("", on)

#include "spngcolorimetry.h"

#include "icc34.h"

#include "spngicc.h"

// Use the Engine\Runtime\Real.cpp version of exp()
// I used this unglorious hack because libpng doesn't include our normal
// header files. But maybe that should change one day. (Watch out for
// Office, though!) [agodfrey]

// This unglorious hack needs to know about our calling convention in the
// engine because it differs from the codec library calling convention.
// [asecchia]

namespace GpRuntime
{
    double __stdcall Exp(double x);
};    

/*----------------------------------------------------------------------------
        Accessor utilities.
----------------------------------------------------------------------------*/
inline icUInt8Number ICCU8(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icUInt8Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return *(static_cast<const SPNG_U8*>(pvData)+iOffset);
        }

inline icUInt16Number ICCU16(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icUInt16Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return SPNGBASE::SPNGu16(static_cast<const SPNG_U8*>(pvData)+iOffset);
        }

inline icUInt32Number ICCU32(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icUInt32Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return SPNGBASE::SPNGu32(static_cast<const SPNG_U8*>(pvData)+iOffset);
        }

inline icInt8Number ICC8(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icInt8Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return *(static_cast<const SPNG_S8*>(pvData)+iOffset);
        }

inline icInt16Number ICC16(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icInt16Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return SPNGBASE::SPNGs16(static_cast<const SPNG_U8*>(pvData)+iOffset);
        }

inline icInt32Number ICC32(const void *pvData, size_t cbData, int iOffset,
        bool &fTruncated)
        {
        if (iOffset + sizeof (icInt32Number) > cbData)
                {
                fTruncated = true;
                return 0;
                }
        return SPNGBASE::SPNGs32(static_cast<const SPNG_U8*>(pvData)+iOffset);
        }


/*----------------------------------------------------------------------------
        The macros build in an assumption of certain local variable names.
----------------------------------------------------------------------------*/
#define ICCU8(o)  ((ICCU8 )(pvData, cbData, (o), fTruncated))
#define ICCU16(o) ((ICCU16)(pvData, cbData, (o), fTruncated))
#define ICCU32(o) ((ICCU32)(pvData, cbData, (o), fTruncated))

#define ICC8(o)  ((ICC8 )(pvData, cbData, (o), fTruncated))
#define ICC16(o) ((ICC16)(pvData, cbData, (o), fTruncated))
#define ICC32(o) ((ICC32)(pvData, cbData, (o), fTruncated))


/*----------------------------------------------------------------------------
        Check an ICC chunk for validity.  This can also check for a chunk which 
        is a valid chunk to include ina PNG file.
----------------------------------------------------------------------------*/
bool SPNGFValidICC(const void *pvData, size_t &cbData, bool fPNG)
        {
        bool fTruncated(false);

        icUInt32Number u(ICCU32(0));
        if (u > cbData)
                return false;

        /* Allow the data to be bigger. */
        if (u < (icUInt32Number)cbData)
                cbData = u;

        if (cbData < 128+4)
                return false;

        if (ICC32(36) != icMagicNumber)
                return false;

        /* Check the tag count and size first. */
        u = ICCU32(128);
        if (cbData < 128+4+12*u)
                return false;

        /* Now check that all the tags are in the data. */
        icUInt32Number uT, uTT;
        for (uT=0, uTT=128+4; uT<u; ++uT)
                {
                /* Skip signature. */
                uTT += 4;
                icUInt32Number uoffset(ICCU32(uTT));
                uTT += 4;
                icUInt32Number usize(ICCU32(uTT));
                uTT += 4;
                if (uoffset >= cbData || usize > cbData-uoffset)
                        return false;
                }

        /* Require the major part of the version number to match. */
        u = ICCU32(8);
        if ((u >> 24) != (icVersionNumber >> 24))
                return false;

        /* If PNG then the color space must be RGB or GRAY. */
        icInt32Number i(ICC32(16));
        if (fPNG && i != icSigRgbData && i != icSigGrayData)
                return false;

        /* The PCS must be XYZ or Lab unless this is a device link profile. */
        i = ICC32(20);
        icInt32Number ilink(ICC32(16));
        if (ilink != icSigLinkClass && i != icSigXYZData && i != icSigLabData)
                return false;

        /* I don't want a link profile in a PNG file - I must know the PCS from
                this data alone. */
        if (fPNG && ilink == icSigLinkClass)
                return false;

        return !fTruncated;
        }


/*----------------------------------------------------------------------------
        Return the rendering intent from the profile, this does a mapping operation
        into the Win32 intents from the information in the profile header.
----------------------------------------------------------------------------*/
LCSGAMUTMATCH SPNGIntentFromICC(const void *pvData, size_t cbData)
        {
        bool fTruncated(false);
        SPNG_U32 u(ICC32(64));
        if (fTruncated)
                u = 0;
        return SPNGIntentFromICC(u);
        }

/* The following wasn't in VC5. */
#ifndef LCS_GM_ABS_COLORIMETRIC
        #define LCS_GM_ABS_COLORIMETRIC 0x00000008
#elif LCS_GM_ABS_COLORIMETRIC != 8
        #error Unexpected value for absolute colorimetric rendering
#endif
LCSGAMUTMATCH SPNGIntentFromICC(SPNG_U32 uicc)
        {
        switch (uicc)
                {
        default:// Error!
        case ICMIntentPerceptual:
                return LCS_GM_IMAGES;
        case ICMIntentRelativeColorimetric:
                return LCS_GM_GRAPHICS;
        case ICMIntentSaturation:
                return LCS_GM_BUSINESS;
        case ICMIntentAbsoluteColorimetric:
                return LCS_GM_ABS_COLORIMETRIC;
                }
        }


/*----------------------------------------------------------------------------
        The inverse - given a windows LCSGAMUTMATCH get the corresponding ICC
        intent.
----------------------------------------------------------------------------*/
SPNGICMRENDERINGINTENT SPNGICCFromIntent(LCSGAMUTMATCH lcs)
        {
        switch (lcs)
                {
        default: // Error!
        case LCS_GM_IMAGES:
                return ICMIntentPerceptual;
        case LCS_GM_GRAPHICS:
                return ICMIntentRelativeColorimetric;
        case LCS_GM_BUSINESS:
                return ICMIntentSaturation;
        case LCS_GM_ABS_COLORIMETRIC:
                return ICMIntentAbsoluteColorimetric;
                }
        }


/*----------------------------------------------------------------------------
        Look up a particular tagged element, this will return true only if the
        signature is found and if the data is all accessible (i.e. within cbData.)
----------------------------------------------------------------------------*/
static bool FLookup(const void *pvData, size_t cbData, bool &fTruncated,
        icInt32Number signature, icInt32Number type,
        icUInt32Number &offsetTag, icUInt32Number &cbTag)
        {
        /* Tag count (note that our accessors return 0 if we go beyond the end
                of the profile, so this is all safe.) */
        icUInt32Number u(ICCU32(128));

        /* Find the required tag. */
        icUInt32Number uT, uTT;
        for (uT=0, uTT=128+4; uT<u; ++uT, uTT += 12)
                {
                icInt32Number i(ICC32(uTT));
                if (i == signature)
                        {
                        uTT += 4;
                        icUInt32Number uoffset(ICCU32(uTT));
                        uTT += 4;
                        icUInt32Number usize(ICCU32(uTT));
                        if (uoffset >= cbData || usize > cbData-uoffset)
                                {
                                fTruncated = true;
                                return false;
                                }

                        /* The type must match too. */
                        if (usize < 8 || ICC32(uoffset) != type || ICC32(uoffset+4) != 0)
                                return false;

                        /* Success case. */
                        offsetTag = uoffset+8;
                        cbTag = usize-8;
                        return true;
                        }
                }

        /* Tag not found. */
        return false;
        }


/*----------------------------------------------------------------------------
        Read the profile description, output a PNG style keyword, if possible,
        NULL terminated.
----------------------------------------------------------------------------*/
bool SPNGFICCProfileName(const void *pvData, size_t cbData, char rgch[80])
        {
        bool fTruncated(false);

        icUInt32Number uoffset(0);
        icUInt32Number usize(0);
        if (!FLookup(pvData, cbData, fTruncated, icSigProfileDescriptionTag,
                icSigTextDescriptionType, uoffset, usize) ||
                uoffset == 0 || usize < 4)
                return false;

        icUInt32Number cch(ICCU32(uoffset));
        if (cch < 2 || cch > 80 || cch > usize-4)
                return false;

        if (fTruncated)
                return false;

        const char *pch = static_cast<const char*>(pvData)+uoffset+4;
        char *pchOut = rgch;
        bool fSpace(false);
        while (--cch > 0)
                {
                char ch(*pch++);
                if (ch <= 32  || ch > 126 && ch < 161)
                        {
                        if (!fSpace && pchOut > rgch)
                                {
                                *pchOut++ = ' ';
                                fSpace = true;
                                }
                        }
                else
                        {
                        *pchOut++ = ch;
                        fSpace = false;
                        }
                }
        if (fSpace) // trailing space
                --pchOut;
        *pchOut = 0;
        return pchOut > rgch;
        }


/*----------------------------------------------------------------------------
        Read a single XYZ number into a CIEXYZ - the number is still in 16.16
        notation, *NOT* 2.30 - take care.
----------------------------------------------------------------------------*/
static bool FReadXYZ(const void *pvData, size_t cbData, bool &fTruncated,
        icInt32Number sig, CIEXYZ &cie)
        {
        icUInt32Number offsetTag(0);
        icUInt32Number cbTag(0);
        if (!FLookup(pvData, cbData, fTruncated, sig, icSigXYZType, offsetTag, cbTag)
                || offsetTag == 0 || cbTag != 12)
                return false;

        /* So we have three numbers, X,Y,Z. */
        cie.ciexyzX = ICC32(offsetTag); offsetTag += 4;
        cie.ciexyzY = ICC32(offsetTag); offsetTag += 4;
        cie.ciexyzZ = ICC32(offsetTag);
        return true;
        }


/*----------------------------------------------------------------------------
        Adjust 16.16 to 2.30
----------------------------------------------------------------------------*/
inline void AdjustOneI(FXPT2DOT30 &x, bool &fTruncated)
        {
        if (x >= 0x10000 || x < -0x10000)
                fTruncated = true;
        x <<= 14;
        }

inline void AdjustOne(CIEXYZ &cie, bool &fTruncated)
        {
        AdjustOneI(cie.ciexyzX, fTruncated);
        AdjustOneI(cie.ciexyzY, fTruncated);
        AdjustOneI(cie.ciexyzZ, fTruncated);
        }

static bool SPNGFAdjustCIE(CIEXYZTRIPLE &cie)
        {
        bool fTruncated(false);
        AdjustOne(cie.ciexyzRed, fTruncated);
        AdjustOne(cie.ciexyzGreen, fTruncated);
        AdjustOne(cie.ciexyzBlue, fTruncated);
        return !fTruncated;
        }


/*----------------------------------------------------------------------------
        Return the end point chromaticities given a validated ICC profile.
----------------------------------------------------------------------------*/
static bool SPNGFCIE(const void *pvData, size_t cbData, CIEXYZTRIPLE &cie)
        {
        bool fTruncated(false);

        /* We are looking for the colorant tags, notice that the medium white point
                is irrelevant here - we are actually generating a PNG cHRM chunk, so we
                want a reversible set of numbers (white point is implied by end points.)
                */
        return FReadXYZ(pvData, cbData, fTruncated, icSigRedColorantTag, cie.ciexyzRed) &&
                FReadXYZ(pvData, cbData, fTruncated, icSigGreenColorantTag, cie.ciexyzGreen) &&
                FReadXYZ(pvData, cbData, fTruncated, icSigBlueColorantTag, cie.ciexyzBlue) &&
                !fTruncated;
        }


/*----------------------------------------------------------------------------
        The wrapper to convert 16.16 to FXPT2DOT30
----------------------------------------------------------------------------*/
bool SPNGFCIEXYZTRIPLEFromICC(const void *pvData, size_t cbData,
        CIEXYZTRIPLE &cie)
        {
        return SPNGFCIE(pvData, cbData, cie) && SPNGFAdjustCIE(cie);
        }


/*----------------------------------------------------------------------------
        The same but it produces numbers in PNG format.
----------------------------------------------------------------------------*/
bool SPNGFcHRMFromICC(const void *pvData, size_t cbData, SPNG_U32 rgu[8])
        {
        CIEXYZTRIPLE ciexyz;
        if (SPNGFCIE(pvData, cbData, ciexyz))
                {
                /* Those numbers are actually in 16.16 notation, yet the CIEXYZ structure
                        uses FXPT2DOT30, however the chromaticity calculation is all in terms
                        of relative values, so the scaling does not matter beyond the fact that
                        the white point calculation loses 4 bits - so we are actually no better
                        than 16.12, this doesn't really matter. */
                return FcHRMFromCIEXYZTRIPLE(rgu, &ciexyz);
                }

        /* Not found. */
        return false;
        }

        
// prevent log and exp from linking in msvcrt;
// force the intrinsic version to be linked in
#pragma optimize ("g", on)

/*----------------------------------------------------------------------------
        Generic gama reader - uses gray, green, red or blue TRCs as specified,
        returns a double precision gamma value (but it's not really very
        accurate!)
----------------------------------------------------------------------------*/
static bool SPNGFexpFromICC(const void *pvData, size_t cbData, double &dexp,
        icInt32Number signature)
        {
        bool fTruncated(false);

        /* Try for a gray curve first, if we don't get it then we will have to
                fabricate something out of the color curves, because we want to return
                a single number.  We can't do anything with the A/B stuff (well, maybe
                we could, but it is very difficult!)   At present I just choose colors
                in the order green, red, blue - I guess it would be possible to factor
                out the Y then calculate a curve for Y, but this seems like wasted
                effort. */
        icUInt32Number offsetTag(0);
        icUInt32Number cbTag(0);
        if (!FLookup(pvData, cbData, fTruncated, signature, icSigCurveType,
                        offsetTag, cbTag) || fTruncated || cbTag < 4)
                return false;

        /* We have a curve, handle the special cases. */
        icUInt32Number c(ICC32(offsetTag));
        if (cbTag != 4 + c*2)
                return false;

        /* Notice that two points imply linearity, although there may be some
                offset. */
        if (c == 0 || c == 2)
                {
                dexp = 1;
                return true;
                }

        if (c == 1)
                {
                /* We have a canonical value - linear = device^x. */
                        {
                        icUInt16Number u(ICCU16(offsetTag+4));
                        if (u == 0)
                                return false;
                        dexp = u / 256.;
                        }
                return true;
                }

        /* We have a table, the algorithm is to fit a power law by straight line
                fit to the log/log plot.  If the table has footroom/headroom we ignore
                it - so we get the gamma of the curve and a PNG viewer will compress
                the colors because of the headroom/footroom.  There is no way round this.
                We do also take into account setup, though this would be a weird thing
                to put into an encoding I think. */
        offsetTag += 4;
        icUInt16Number ubase(ICCU16(offsetTag));
        icUInt32Number ilow(1);
        while (ilow < c)
                {
                icUInt16Number u(ICCU16(offsetTag + 2*ilow));
                if (u > ubase)
                        break;
                ubase = u;
                ++ilow;
                }

        --c; // Max
        icUInt16Number utop(ICCU16(offsetTag + 2*c));
        while (c > ilow)
                {
                icUInt16Number u(ICCU16(offsetTag + 2*(c-1)));
                if (u < utop)
                        break;
                utop = u;
                --c;
                }

        /* There may actually be no intermediate values. */
        if (ilow == c || ilow+1 == c)
                {
                dexp = 1;
                return true;
                }

        /* But if there are we can do the appropriate fit, adjust ilow to be the
                lowest value, c is the highest, look at all the intermediate values.
                Normalise both ranges to 0..1. */
        offsetTag += 2*ilow; // Offset of the first entry *after* the base
        --ilow;
        if (c <= ilow)
                return false;
        c -= ilow;       // c is the x axis scale factor.
        if (utop <= ubase)
                return false;
        utop = icUInt16Number(utop-ubase); // utop is now the y axis scale factor

        /* We are only interested in the slope, this is, in fact, the canonical
                gamma value because it relates input (x) to output (y).  We have to
                omit the first point because it is -infinity (log(0)) and the last
                point because it is 0.  We want output = input ^ gamma, so gamma is
                ln(output)/ln(input) (hence the restriction on no 0.)  Calculate a mean
                value from all the points.

                This would give unreasonable weight to very small numbers - values close
                to 0, so use a weighting function.  A weighting function which gives
                exactly 2.2 from the sRGB TRC values is input^0.28766497357305, however
                the result is remarkably stable as this power is varied and input^1
                works quite well too. */
        const double xi(1./c);
        const double yi(1./utop);
        double weight(.28766497357305);
        double sumg(0); // Gamma sum
        double sumw(0); // Weight sum

        icUInt32Number i;
        icUInt32Number n(0);
    
        /* What we do next depends on the profile connection space - we must take
                into account the power 3 in Lab. */
        if (ICC32(16) == icSigLabData) for (i=1; i<c; ++i, offsetTag += 2)
                {
                icUInt16Number uy(ICCU16(offsetTag));
                if (uy > ubase)
                        {
                        #define Lab1 0.1107051920735082475368094763644414923059
                        #define Lab2 0.8620689655172413793103448275862068965517
            
            const double x(log(i*xi));
                        const double w(exp(x * weight));
            
                        /* The y value in Lab must be converted to the linear CIE space which
                                PNG expects.  The Lab values are in the range 0..1. */
                        double y((uy-ubase)*yi);
                        if (y < 0.08)
                                y = log(y*Lab1);
                        else
                                y = 3*log((y+.16)*Lab2);

                        sumg += w * y/x;
                        sumw += w;
                        ++n;
                        }
                }
        else for (i=1; i<c; ++i, offsetTag += 2)
                {
                icUInt16Number uy(ICCU16(offsetTag));
                if (uy > ubase)
                        {
                        const double x(log(i*xi));
                        const double w(exp(x * weight));
                        const double y(log((uy-ubase)*yi));

                        sumg += w * y/x;
                        sumw += w;
                        ++n;
                        }
                }

    
        /* A really weird set of values may leave us with no samples, we must have
                at least three samples at this point. */
        if (n < 3 || sumw <= 0)
                return false;

        /* So now we can calculate the slope. */
        const double gamma(sumg / sumw);
        if (gamma == 0) // Possible
                return false;

        /* We don't even try to estimate whether this is a good fit - if a PNG viewer
                doesn't use the ICC data we assume this is better.   Do limit the overall
                gamma here though. */
        if (gamma < .1 || gamma > 10)
                return false;

        dexp = gamma;
        return !fTruncated;
        }

#pragma optimize ("", on)


/*----------------------------------------------------------------------------
        Return the gAMA value (scaled to 100000) from a validated ICC profile.
----------------------------------------------------------------------------*/
bool SPNGFgAMAFromICC(const void *pvData, size_t cbData, SPNG_U32 &ugAMA)
        {
        double gamma;
        /* Test in order gray, green, red, blue. */
        if (!SPNGFexpFromICC(pvData, cbData, gamma, icSigGrayTRCTag) &&
                !SPNGFexpFromICC(pvData, cbData, gamma, icSigGreenTRCTag) &&
                !SPNGFexpFromICC(pvData, cbData, gamma, icSigRedTRCTag) &&
                !SPNGFexpFromICC(pvData, cbData, gamma, icSigBlueTRCTag))
                return false;
        /* This has already been ranged checked for .1 to 10. */
        ugAMA = static_cast<SPNG_U32>(100000/gamma);
        return true;
        }


/*----------------------------------------------------------------------------
        This is the 16.16 version, we want three values here, we will accept
        any.
----------------------------------------------------------------------------*/
bool SPNGFgammaFromICC(const void *pvData, size_t cbData, SPNG_U32 &redGamma,
        SPNG_U32 &greenGamma, SPNG_U32 &blueGamma)
        {
        /* Try for the colors first. */
        double red;
        bool fRed(SPNGFexpFromICC(pvData, cbData, red, icSigRedTRCTag));
        double green;
        bool fGreen(SPNGFexpFromICC(pvData, cbData, green, icSigGreenTRCTag));
        double blue;
        bool fBlue(SPNGFexpFromICC(pvData, cbData, blue, icSigBlueTRCTag));

        if (fRed || fGreen || fBlue)
                {
                /* Got at least one color. */
                if (!fGreen)
                        green = (fRed ? red : blue);
                if (!fRed)
                        red = green;
                if (!fBlue)
                        blue = green;

                redGamma = static_cast<SPNG_U32>(red*65536);
                greenGamma = static_cast<SPNG_U32>(green*65536);
                blueGamma = static_cast<SPNG_U32>(blue*65536);
                }
        else
                {
                /* Gray may exist. */
                if (SPNGFexpFromICC(pvData, cbData, green, icSigGrayTRCTag))
                        redGamma = greenGamma = blueGamma = static_cast<SPNG_U32>(green*65536);
                else
                        return false;
                }

        return true;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spnginternal.h ===
#pragma once
#define SPNGINTERNAL_H 1
/*****************************************************************************
	spnginternal.h

	Internal definitions used by both reading and writing implementations
	but not otherwise required.
*****************************************************************************/
/*****************************************************************************
	PNG utilities based on the definitions in the standard.
*****************************************************************************/
/*----------------------------------------------------------------------------
	The number of pixels in a particular pass of Adam7 interlacing.
----------------------------------------------------------------------------*/
inline int CPNGPassPixels(int pass, int w)
	{
#if 0
	/* The long form. */
	switch (pass)
		{
	case 1: return (w + 7) >> 3;
	case 2: return (w + 3) >> 3;
	case 3: return (w + 3) >> 2;
	case 4: return (w + 1) >> 2;
	case 5: return (w + 1) >> 1;
	case 6: return (w + 0) >> 1;
	case 7: return (w + 0) >> 0;
		}
#else
	// shift = (8-pass) >> 1;
	// add   = 7 >> (pass >> 1);
	return (w + (7 >> (pass >> 1))) >> ((8-pass) >> 1);
#endif
	}


/*----------------------------------------------------------------------------
	The buffer space required for a single row of cpix, taking into account
	whether or not the filter byte is required.
----------------------------------------------------------------------------*/
inline int CPNGRowBytes(int cpix, int cbpp)
	{
	return (((cpix)*(cbpp) + 7) >> 3) + (cpix > 0);
	}


/*----------------------------------------------------------------------------
	The buffer space required for a single row of a particular pass, assuming
	the row actually needs to be read.  Implemented as a macro in an attempt
	to ensure things stay in line.
----------------------------------------------------------------------------*/
#define CPNGPassBytes(pass, w, cbpp)\
	CPNGRowBytes(CPNGPassPixels((pass), (w)), (cbpp))


/*----------------------------------------------------------------------------
	The number of rows in a particular pass of Adam7 interlace.  This ends
	up being a simple variant of CPNGPassPixels, so it is implemented as a
	macro.
----------------------------------------------------------------------------*/
inline int CPNGPassRows(int pass, int h)
	{
#if 0
	/* Long form. */
	switch (pass)
		{
	case 1: return (h + 7) >> 3;  // Note same as 2
	case 2: return (h + 7) >> 3;
	case 3: return (h + 3) >> 3;
	case 4: return (h + 3) >> 2;
	case 5: return (h + 1) >> 2;
	case 6: return (h + 1) >> 1;
	case 7: return	(h + 0) >> 1;
		}
#else
	// shift = (8-(pass-1)) >> 1;  (Except (8-(pass)) >> 1 for pass 1)
	// add   = 7 >> ((pass-1) >> 1);
	// Hence:
	pass -= (pass > 1);
	return (h + (7 >> (pass >> 1))) >> ((8-pass) >> 1);
#endif
	}


/*----------------------------------------------------------------------------
	The *offset* of a particular pass in the buffer, "7" returns the total
	size of the buffer.
----------------------------------------------------------------------------*/
inline int CbPNGPassOffset(int w, int h, int cbpp, int pass)
	{
	int cb(0);
	switch (pass)
		{
	case 7:
		cb += CPNGPassBytes(6, w, cbpp) * CPNGPassRows(6, h);
	case 6:
		cb += CPNGPassBytes(5, w, cbpp) * CPNGPassRows(5, h);
	case 5:
		cb += CPNGPassBytes(4, w, cbpp) * CPNGPassRows(4, h);
	case 4:
		cb += CPNGPassBytes(3, w, cbpp) * CPNGPassRows(3, h);
	case 3:
		cb += CPNGPassBytes(2, w, cbpp) * CPNGPassRows(2, h);
	case 2:
		cb += CPNGPassBytes(1, w, cbpp) * CPNGPassRows(1, h);
		}
	return cb;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngread.cpp ===
/*****************************************************************************
	spngread.cpp

	PNG support code and interface implementation (reading)
*****************************************************************************/
#include <stdlib.h>

#define SPNG_INTERNAL 1
#include "spngread.h"
#include "spnginternal.h"


/*****************************************************************************
	The basic PNG read class.  This must do three things:

	1) Provide access to the required chunks (and extract information from
		them) - we only need to support the chunks we actually want!
	2) Uncompress the IDAT chunks.
	3) "Unfilter" the resultant rows (which may require some temporary buffer
		space for the previous row.)
*****************************************************************************/
/*----------------------------------------------------------------------------
	Initialize a SPNGREAD.
----------------------------------------------------------------------------*/
SPNGREAD::SPNGREAD(BITMAPSITE &bms, const void *pv, int cb, bool fMMX) :
	SPNGBASE(bms),
	m_pb(static_cast<const SPNG_U8*>(pv)), m_cb(cb),
	m_rgbBuffer(NULL), m_cbBuffer(0), m_cbRow(0), m_y(0), m_uLZ(0),
	m_fInited(false), m_fEOZ(false), m_fReadError(false), m_fCritical(false),
	m_fBadFormat(false), m_fMMXAvailable(fMMX),
	m_prgb(NULL), m_crgb(0),
	m_uPNGIHDR(cb),
	m_uPNGIDAT(0),
	m_uPNGtEXtFirst(0),
	m_uPNGtEXtLast(0)
	{
	ProfPNGStart

	/* Initialize the relevant stream fields. */
	memset(&m_zs, 0, sizeof m_zs);
	m_zs.zalloc = Z_NULL;
	m_zs.zfree = Z_NULL;
	m_zs.opaque = static_cast<SPNGBASE*>(this);
	}


/*----------------------------------------------------------------------------
	Destroy a SPNGREAD.
----------------------------------------------------------------------------*/
SPNGREAD::~SPNGREAD()
	{
	EndRead();
	ProfPNGStop
	}


/*----------------------------------------------------------------------------
	Internal implementation of FChunk does nothing.
----------------------------------------------------------------------------*/
bool SPNGREAD::FChunk(SPNG_U32 ulen, SPNG_U32 uchunk, const SPNG_U8* pb)
	{
	return true;
	}


/*----------------------------------------------------------------------------
	Load the chunk information.  Internal API which finds all the chunks which
	might be of interest.
----------------------------------------------------------------------------*/
void SPNGREAD::LoadChunks(SPNG_U32 u/* Start position. */)
	{
	while (u+8 < m_cb)   /* Enough for a chunk header plus 1 byte. */
		{
		SPNG_U32 ulen(SPNGu32(m_pb+u));     /* Chunk length. */
		SPNG_U32 chunk(SPNGu32(m_pb+u+4));  /* Chunk type. */
		if (u+12+ulen > m_cb)              /* Chunk is truncated. */
			{
			SPNGlog("PNG: truncated chunk");
			/* Allow chunks to be truncated here ONLY if they are IDAT. */
			if (chunk != PNGIDAT)
				break;
			/* Store the available length - avoids embarassing read-beyond
				end errors. */
			if (u+8+ulen > m_cb)
				ulen = m_cb-u-8;
			m_ucrc = 0;
			}
		else
			m_ucrc = SPNGu32(m_pb+u+8+ulen);
		u += 8;                            /* Index of chunk data. */

		/* This is the basic switch to detect the chunk type.  This could
			be done more quickly, maybe, by a suitable hash function. */
		switch (chunk)
			{
		case PNGIHDR:
			if (m_uPNGIHDR >= m_cb && ulen >= 13)
				m_uPNGIHDR = u-8;
			break;

		case PNGPLTE:
			if (m_prgb == 0 && ulen >= 3)
				{
				m_prgb = m_pb+u;
				m_crgb = ulen/3; // Rounds down if chunk length bad.
				SPNGcheck(m_crgb*3 == ulen);
				}
			break;

		case PNGIDAT:
			if (m_uPNGIDAT == 0 && ulen > 0)
				m_uPNGIDAT = u-8;
			break;

		case PNGtEXt:
			/* As an optimization the first and last chunk are recorded. */
			if (m_uPNGtEXtFirst == 0)
				m_uPNGtEXtFirst = u-8;
			m_uPNGtEXtLast = u-8;
			break;

		case PNGIEND:
			return;

		default:
			/* Check for a critical chunk and log the presence of this chunk,
				if we can't handle it we shouldn't import the image but we
				may have already done so in which case nothing can be done. */
			if (FPNGCRITICAL(chunk))
				{
				SPNGlog1("PNG: 0x%x: unknown critical chunk", chunk);
				if (!m_bms.FReport(false/*not fatal?*/, pngcritical, chunk))
					m_fCritical = true;
				}
			break;
			}

		/* Now call the FChunk API. */
		if (!FChunk(ulen, chunk, m_pb+u))
			{
			/* Signal a format error. */
			m_fBadFormat = true;
			return;
			}


		u += ulen+4; // Chunk length and CRC
		}

	/* Format errors are ignored by this API - we are just gathering info,
		the code below works out if there is a problem which prevents display.
		*/
	}


/*----------------------------------------------------------------------------
	Generate the header information.  This also validates the IHDR.  It can
	handle data both with and without a signature.
----------------------------------------------------------------------------*/
bool SPNGREAD::FHeader()
	{
	if (m_pb == NULL)
		{
		m_fReadError = true;
		return false;
		}

	SPNG_U32 u(FSignature() ? 8 : 0);

	LoadChunks(u);

	if (FOK())
		{
		if (Width() >= 65536) /* Internal limit. */
			{
			SPNGlog1("PNG: width %d too great", Width());
			m_fBadFormat = true;
			}
		if (Height() >= 65536)
			{
			SPNGlog1("PNG: height %d too great", Height());
			m_fBadFormat = true;
			}

		SPNGcheck(ColorType() < 7 && (ColorType() == 3 ||
			(ColorType() & 1) == 0));
		SPNGcheck(BDepth() == 8 || (BDepth() == 16 && ColorType() != 3) ||
			ColorType() == 0 || (ColorType() == 3 && BDepth() <= 8));
		SPNGcheck(m_pb[m_uPNGIHDR+18]/*compression method*/ == 0);
		SPNGcheck(m_pb[m_uPNGIHDR+19]/*filter method*/ == 0);
		SPNGcheck(m_pb[m_uPNGIHDR+20]/*interlace method*/ < 2);

		/* We deliberately kill any palette based format with more than
			8bpp - otherwise we might end up with massive palettes elsewhere.
			We ignore unknown filter/compression methods even though this
			means the images will misdisplay - by this point we are committed
			to handling the data so there is nothing we an do about the
			unsupported types. */
		if ((BDepth() & (BDepth()-1)) == 0 &&          /* Depth OK */
			BDepth() <= 16 - ((ColorType() & 1) << 3) && /* 8 for palette image */
			((ColorType() & 1) == 0 || ColorType() == 3 /* Value palette type */
				&& m_prgb != NULL))                      /* Check for a palette */
			return !m_fBadFormat && !m_fCritical;       /* Size OK. */

		/* Something is wrong with the details of the format. */
		m_fBadFormat = true;
		SPNGcheck1((BDepth() & (BDepth()-1)) == 0,
				"PNG: Invalid PNG depth %d", BDepth());
		SPNGcheck1(BDepth() < 16 - ((ColorType() & 1) << 3),
				"PNG: Pixel depth %d too great for palette image", BDepth());
		SPNGcheck1((ColorType() & 1) == 0 || m_prgb != NULL,
				"PNG: No PLTE chunk in palette based image", 0);
		}

	(void)m_bms.FReport(true/*fatal*/, pngformat, PNGIHDR);
	return false;
	}


/*----------------------------------------------------------------------------
	strnlen??
----------------------------------------------------------------------------*/
inline int strnlen(const SPNG_U8* pb, int cmax)
	{
	int cb(0);
	while (cb<cmax && pb[cb] != 0) ++cb;
	return cb;
	}


/*----------------------------------------------------------------------------
	API to read a particular text element.  The output is in single byte format
	and just reflects whatever the input happens to be.  The successive
	entries, if any, are joined with \r\n.  The API returns false only if it
	runs out of space in the buffer.  The wzBuffer will be 0 terminated.  If
	the szKey is NULL *all* text entries are output with the keyword preceding
	the text (except for the GIF comment.)

	The chunk is given explicitly as is the start and end position.
----------------------------------------------------------------------------*/
bool SPNGREAD::FReadTextChunk(const char *szKey, char *szBuffer,
	SPNG_U32 cchBuffer, SPNG_U32 usearch, SPNG_U32 u, SPNG_U32 uend)
	{
	SPNG_U32 cchKey(szKey == NULL ? 0 : strlen(szKey)+1);
	SPNGassert(cchKey != 1); /* Don't want empty strings! */
	SPNG_U32 cchOut(0);
	bool     fOK(true);

	if (cchOut < cchBuffer && u > 0) do
		{
		SPNG_U32 ulen(SPNGu32(m_pb+u));  /* Chunk length. */
		if (u+12+ulen > m_cb)            /* Chunk is truncated. */
			break;
		u += 4;
		SPNG_U32 chunk(SPNGu32(m_pb+u)); /* Chunk type. */
		u += 4;                          /* Index of chunk data. */
	
		if (chunk == PNGIEND)
			break;
		else if (chunk == usearch && ulen > cchKey &&
			(cchKey == 0 || memcmp(m_pb+u, szKey, cchKey) == 0))
			{
			/* In the cchKey==0 case we want to check for some keyword and
				handle it first - at this point we set the cch value to the
				key length.  We must take care because the tEXt buffer may
				not be terminated (an error, but certainly possible!) */
			SPNG_U32 cch(cchKey);
			if (cch == 0)
				{
				cch = strnlen(m_pb+u, __min(ulen,80))+1;
				if (cch >= __min(ulen,80))
					{
					SPNGlog("PNG: tEXt chunk with no keyword.");
					cch = 0; // dump whole string
					}
				else if (cch == 1)
					/*Skip empty keyword*/;
				else if (cch != 8 || memcmp(m_pb+u, "Comment", 7) != 0)
					{
					/* If the keyword will not fit then we skip this entry,
						if the keyword will fit put the text doesn't fit the
						whole entry is skipped.  We know that ulen is keyword
						plus value , so we need ulen+1 (for ": ") plus 2 for
						the \r\n. */
					if (cchOut+ulen+3 > cchBuffer)
						{
						u += ulen+4;
						fOK = false; // Indicate truncation
						continue;
						}

					memcpy(szBuffer+cchOut, m_pb+u, cch-1);
					cchOut += cch-1;
					memcpy(szBuffer+cchOut, ": ", 2);
					cchOut += 2;
					}
				}

			/* Here to dump the rest of the string, starting at [cch] (note
				that cch includes the nul character.)  Check for buffer overflow
				and skip this entry if it occurs (this effectively junks very
				big entries.) */
			if (cchOut+(ulen-cch)+2 <= cchBuffer)
				{
				memcpy(szBuffer+cchOut, m_pb+u+cch, ulen-cch);
				cchOut += ulen-cch;
				memcpy(szBuffer+cchOut, "\r\n", 2);
				cchOut += 2;
				}
			else
				fOK = false;  // Something lost

			/* Continue even on a failure case - other strings may work. */
			}

		u += ulen+4;
		}
	while (u <= uend && cchOut < cchBuffer);

	if (cchOut == 0)
		{
		if (cchBuffer > 0)
			szBuffer[0] = 0;
		return fOK;
		}

	/* The following must be true. */
	SPNGassert(cchOut > 1 && cchOut <= cchBuffer);

	/* The following kills the last \r\n separator. */
	if (cchOut > 1)
		szBuffer[cchOut-2] = 0;
	else
		szBuffer[cchBuffer-1] = 0; // Error condition.

	return fOK;
	}


/*----------------------------------------------------------------------------
	The public interface.
----------------------------------------------------------------------------*/
bool SPNGREAD::FReadText(const char *szKey, char *szBuffer,
	SPNG_U32 cchBuffer, SPNG_U32 uchunk)
	{
	if (uchunk == PNGtEXt)
		return FReadTextChunk(szKey, szBuffer, cchBuffer, uchunk,
			m_uPNGtEXtFirst, m_uPNGtEXtLast);
	else
		return FReadTextChunk(szKey, szBuffer, cchBuffer, uchunk,
			m_uPNGIHDR, m_cb-12/*Room for one chunk*/);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spnginternal.cpp ===
/*****************************************************************************
	spnginternal.cpp

	Shared library implementations.
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngconf.h"

bool SPNGBASE::FCheckZlib(int ierr)
	{
	if (ierr >= 0)
		return true;
	ierr = (-ierr);
	SPNGassert(ierr <= 6);
	if (ierr > 6)
		ierr = 6;
	(void)m_bms.FReport(true/*fatal*/, pngzlib, ierr);
	return false;
	}

/*----------------------------------------------------------------------------
	Signatures
----------------------------------------------------------------------------*/
extern const SPNG_U8 vrgbPNGMSOSignature[11] =
	{ 'M', 'S', 'O', 'F', 'F', 'I', 'C', 'E', '9', '.', '0'};

extern const SPNG_U8 vrgbPNGSignature[8] =
	{ 137, 80, 78, 71, 13, 10, 26, 10 };

extern const SPNG_U8 vrgbPNGcmPPSignature[8] =
	{ 'J', 'C', 'm', 'p', '0', '7', '1', '2' };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngreadrow.cpp ===
/*****************************************************************************
	spngreadrow.cpp

	PNG support code - reading a row.
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngread.h"
#include "spnginternal.h"

// (from ntdef.h)
#ifndef     UNALIGNED
#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

/*----------------------------------------------------------------------------
	We need to find the number of bytes buffer for Adam7.  This is the total
	amount of buffer space required for the first *SIX* passes - no allowance
	is made for space for lines of the last (seventh) pass because they can
	be handled line-by-line.
----------------------------------------------------------------------------*/
#define CbPNGAdam7(w, h, cbpp) CbPNGPassOffset(w, h, cbpp, 7)


/*----------------------------------------------------------------------------
	FInterlaceInit - initialize for interlace.
----------------------------------------------------------------------------*/
bool SPNGREAD::FInterlaceInit(void)
	{
	SPNGassert(FInterlace());

	int cbAll(CbPNGAdam7(Width(), Height(), CBPP()));
	int cb(m_cbRow << 1);

	ReadRow(m_rgbBuffer+cb, cbAll);

	/* At this point we have data, although truncation may have set it all
		to 0 - this is OK, 0 is perfectly nice interlace data.  We must
		unfilter the data. */
	cbAll += cb;
	int cbpp(CBPP());
	int w(Width());
	int h(Height());
	for (int pass=1; pass<7; ++pass)
		{
		if (!m_bms.FGo())
			return false;

		int cbRow(CPNGPassBytes(pass, w, cbpp));
		if (cbRow > 0)
			{
			const SPNG_U8* pbPrev = NULL;
			for (int y=CPNGPassRows(pass, h); --y >= 0;)
				{
				Unfilter(m_rgbBuffer+cb, pbPrev, cbRow, cbpp);
				pbPrev = m_rgbBuffer+cb;
				cb += cbRow;
				}
			}
		}

	/* The data must still be de-interlaced, this is done on demand. */
	return true;
	}


/*----------------------------------------------------------------------------
	Return the size of the buffer.
----------------------------------------------------------------------------*/
size_t SPNGREAD::CbRead(void)
	{
	SPNGassert(FOK());

	/* Allocate the row buffer - include the buffer for the filter
		byte and allow for the requirement for two rows to undo
		Paeth filtering, when interlace is required we actually need
		to buffer half of the image. */
	SPNG_U32 cb(0);
	if (FInterlace())
		cb = CbPNGAdam7(Width(), Height(), CBPP());

	/* We store a record of the bytes required for a single row for
		use later on, we allocate two row buffers, we must allocate
		a multiple of 8 bytes for the row buffer to allow de-interlacing
		to overwrite the end, anyway this is probably a performance
		benefit because it means the second row buffer is aligned. */
	m_cbRow = (CPNGRowBytes(Width(), CBPP()) + 7) & ~7;
	cb += m_cbRow << 1;

	return cb;
	}


/*----------------------------------------------------------------------------
	Initialize the IO buffer.
----------------------------------------------------------------------------*/
inline bool SPNGREAD::FInitBuffer(void *pvBuffer, size_t cbBuffer)
	{
	SPNGassert(cbBuffer >= CbRead());
	m_rgbBuffer = static_cast<UNALIGNED SPNG_U8*>(pvBuffer);
	m_cbBuffer = cbBuffer;
	return true;
	}


/*----------------------------------------------------------------------------
	Terminate the buffer.
----------------------------------------------------------------------------*/
inline void SPNGREAD::EndBuffer(void)
	{
	m_rgbBuffer = NULL;
	m_cbBuffer = 0;
	}


/*****************************************************************************
	Basic reading API - reads the rows from the bitmap, call FInitRead at the
	start then call PbRow for each row.  PbRow returns NULL if the row cannot
	be read, including both error and end-of-image. The SPNGBASE "FGo" callback
	is checked for an abort from time to time during reading (particularly
	important for interlaced bitmaps, where the initial row may take a long
	time to calculate.)
*****************************************************************************/
/*----------------------------------------------------------------------------
	Initialization and finalization (public.)
----------------------------------------------------------------------------*/
bool SPNGREAD::FInitRead(void *pvBuffer, size_t cbBuffer)
	{
	m_y = 0;
	if (FInitBuffer(pvBuffer, cbBuffer))
		{
		if (FInitZlib(m_uPNGIDAT, 0))
			return true;
		EndBuffer();
		}
	return false;
	}


/*----------------------------------------------------------------------------
	End.
----------------------------------------------------------------------------*/
void SPNGREAD::EndRead(void)
	{
	EndZlib();
	EndBuffer();
	}


/*----------------------------------------------------------------------------
	Read a row.
----------------------------------------------------------------------------*/
const SPNG_U8 *SPNGREAD::PbRow()
	{
	SPNGassert(m_fInited && m_rgbBuffer != NULL);
	if (!m_fInited || m_rgbBuffer == NULL)
		return NULL;

	if (m_y >= Height())
		return NULL;

	/* Now check for an abort. */
	if (!m_bms.FGo())
		return NULL;

	/* Handle interlace and non-interlace separately. */
	UNALIGNED SPNG_U8*       pb = m_rgbBuffer;
	const UNALIGNED SPNG_U8 *pbPrev = pb;
	int            cb(m_cbRow);

	if (!FInterlace())
		{
		if (m_y & 1)
			pb += cb;
		else
			pbPrev += cb;

		if (m_y == 0)
			pbPrev = NULL;  // Indicates first row.
		}
	else
		{
		if (m_y == 0 && !FInterlaceInit())
			return NULL;

		if (m_y & 2)
			pb += cb;
		else
			pbPrev += cb;

		/* Pass 7 handles as the non-interlace case, the other passes
			need the output to be synthesised. */
		if (m_y & 1) // Pass 7
			{
			if (m_y == 1)
				pbPrev = NULL;  // Indicates first row.
			}
		else
			{
			/* We must retain pbPrev for the next pass 7 row, but
				we can overwrite pb, we must pass an aligned pointer
				to Uninterlace, so we actually kill the filter byte
				here. */
			Uninterlace(pb, m_y);
			++m_y;

			/* The row is set up, so return here. */
			return pb;
			}
		}

	/* This is the non-interlace case, or pass 7 of the interlace
		case, must use the real row width here. */
	++m_y;
	cb = CPNGRowBytes(Width(), CBPP());
	ReadRow(pb, cb);
	Unfilter(pb, pbPrev, cb, CBPP());
	return pb+1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngread.h ===
#pragma once
#define SPNGREAD_H 1
/*****************************************************************************
	spngread.h

	PNG support code and interface implementation (reading)

	The basic PNG read class.  This must do three things:

	1) Provide access to the required chunks (and extract information from
		them) - we only need to support the chunks we actually want!
	2) Uncompress the IDAT chunks.
	3) "Unfilter" the resultant rows (which may require some temporary buffer
		space for the previous row.)
******************************************************************* JohnBo **/
#include "spngconf.h"  // For assert macro and general type convertions.

// (from ntdef.h)
#ifndef     UNALIGNED
#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

class SPNGREAD : public SPNGBASE
	{
public:
	SPNGREAD(BITMAPSITE &bms, const void *pv, int cb, bool fMMX);
	~SPNGREAD();

	/* Basic reading API - reads the rows from the bitmap, call FInitRead
		at the start then call PbRow for each row.  PbRow returns NULL if
		the row cannot be read, including both error and end-of-image. The
		SPNGBASE "FGo" callback is checked for an abort from time to time
		during reading (particularly important for interlaced bitmaps, where
		the initial row may take a long time to calculate.)   Call the
		CbRead API to find out how many bytes of buffer space will be
		needed - this must be called *before* FInitRead and a buffer of this
		size must be passed to FInitRead(), the buffer passed to FInitRead() must
		not be changed! */
	size_t         CbRead(void);
	bool           FInitRead(void *pvBuffer, size_t cbBuffer);
	void           EndRead(void);
	const SPNG_U8 *PbRow(void);
	inline bool    FReadError(void) const { return m_fReadError; }

	/* Basic PNG enquiry routines. */
	inline bool FSignature(void)
		{
		return m_pb != NULL && m_cb >= 8 &&
			memcmp(vrgbPNGSignature, m_pb, cbPNGSignature) == 0;
		}

	/* Return the header information - fails if the header or any data in
		it is invalid. */
	bool FHeader();

	/* Enquiries which may be made after the above call if (and only if)
		it succeeds. */
	inline SPNG_U32 Width(void) const     { return SPNGu32(Pb(m_uPNGIHDR+8)); }
	inline SPNG_U32 Height(void) const    { return SPNGu32(Pb(m_uPNGIHDR+12)); }
	inline int Y(void) const              { return m_y; }
	inline SPNG_U8 BDepth(void) const     { return *Pb(m_uPNGIHDR+16); }
	inline SPNG_U8 ColorType(void) const  { return *Pb(m_uPNGIHDR+17); }
	inline bool FPalette(void) const      { return (ColorType() & 1) != 0; }
	inline bool FColor(void) const        { return (ColorType() & 2) != 0; }
	inline bool FAlpha(void) const        { return (ColorType() & 4) != 0; }
	inline bool FInterlace(void) const    { return *Pb(m_uPNGIHDR+20) == 1; }
	inline bool FCritical(void) const     { return m_fCritical; }
	inline bool FOK(void) const
		{
		return m_uPNGIHDR<m_cb && !m_fBadFormat && m_uPNGIDAT > 0;
		}

	/* The component count can be calculated from the color type. */
	inline int CComponents(void) const
		{
		return SPNGBASE::CComponents(ColorType());
		}

	/* This gives the overall BPP value for a single pixel. */
	inline int CBPP(void) const
		{
		return SPNGBASE::CComponents(ColorType()) * BDepth();
		}

	/* Colorimetric information, including palette information, returns NULL if
		there was no PLTE chunk (doesn't handle suggested palette.) */
	inline const SPNG_U8 *PbPalette(int &cpal) const
		{
		cpal = m_crgb;
		return m_prgb;
		}

	/* API to read a particular text element.  The successive entries, if any,
		are joined with a \r\n separator.  The API returns false only if it
		runs out of space in the buffer.  The wzBuffer will be 0 terminated.
		The default is to search for tEXt chunks, but this can be overridden
		by providing the extra argument. */
	bool FReadText(const char *szKey, char *szBuffer, SPNG_U32 cwchBuffer,
		SPNG_U32 uchunk=PNGtEXt);

	/* API to read a compressed chunk.  This is defined to make the iCCP and
		zTXT specifications - a keyword (0 terminated) followed by compressed
		data.  The API will handle results which overflow the passed in
		buffer by allocating using the Zlib allocator, a buffer *must* be
		passed in!  The API returns NULL on error, the passed in szBuffer if
		it was big enough, else a pointer to a new buffer which must be
		deallocated with the Zlib deallocator.   If the result is non-NULL
		cchBuffer is updated to the length of the data returned. */
	SPNG_U8 *PbReadLZ(SPNG_U32 uoffset, char szKey[80], SPNG_U8 *pbBuffer,
		SPNG_U32 &cchBuffer);

protected:
	/* To obtain information from non-critical chunks the following API must be
		implemented.  It gets the chunk identity and length plus a pointer to
		that many bytes.  If it returns false loading of the chunks will stop
		and a fatal error will be logged, the default implementation just skips
		the chunks.  Note that this is called for *all* chunks including
		IDAT.  m_fBadFormat is set if the API returns false. */
	virtual bool FChunk(SPNG_U32 ulen, SPNG_U32 uchunk, const SPNG_U8* pb);

	/* This API can call the following to find the chunk offset within the
		data.  This can then be added to the original pointer passed to the
		SPNGREAD initializer to get a particular chunk.  Note that the pointer
		points to the chunk data, not the header. */
	inline SPNG_U32 UOffset(const SPNG_U8* pb)
		{
        /* !!! pointer subtraction to compute size - Note that on IA64 this
           number could theoretically be larger than 32bits. It should be
           verified that this cannot occur here.*/
		return (SPNG_U32)(pb - m_pb);
		}

	/* The API can also call the following to get the CRC of the chunk, if
		the chunk is truncated this will return 0 (every time!) otherwise it
		returns the CRC, but note that the CRC has not been validated, the
		internal storage for this data only remains valid during the FChunk
		call. */
	inline SPNG_U32 UCrc(void) const
		{
		return m_ucrc;
		}

private:
	/*** Low level support and utilities ***/
	/* Load the chunk offset information variables, the API takes the
		position in the stream at which to start. */
	void LoadChunks(SPNG_U32 u);

	/* Initialize the stream (call before each use) and clean it up (call
		on demand, called automatically by destructor and FInitZlib.)  The
		Init call is passed the offset of the chunk to start at and the
		number of bytes header on that chunk (if any). */
	bool FInitZlib(SPNG_U32 uLZ, SPNG_U32 cbheader);
	void EndZlib(void);

	/* Internal text reading API which will accept a chunk to search and
		an offset to start at. */
	bool FReadTextChunk(const char *szKey, char *szBuffer, SPNG_U32 cchBuffer,
		SPNG_U32 uchunk, SPNG_U32 ustart, SPNG_U32 uend);

	/* Initialize the buffers. */
	bool FInitBuffer(void *pvBuffer, size_t cbBuffer);
	void EndBuffer(void);

	/* Read bytes - up to cbMax, uchunk is either the identifier of the
		chunk containing the data we are decoding (typically PNGIDAT) or
		0 meaning that we only have one chunk full of data, the internal
		pointer m_uLZ will advance through the data looking for the next
		chunk (it is initialized by FInitZlib.)  The following chunks are
		assumed *not* to have any header in front of the compressed
		data. */
	int CbReadBytes(SPNG_U8 *pb, SPNG_U32 cbMax, SPNG_U32 uchunk);
	/* Read the given number of bytes, handle error by zero filling. */
	void ReadRow(SPNG_U8 *pb, SPNG_U32 cb);

	/* Undo some filtering. */
	void Unfilter(SPNG_U8 *pbRow, const SPNG_U8 *pbPrev, SPNG_U32 cbRow,
		SPNG_U32 cbpp);

	/* INTEL/MICROSOFT PROPRIETARY START */
  	/* MMX routines (from Intel: NOTE: this is proprietary source) */
	void SPNGREAD::avgMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev,
		SPNG_U32 cbRow, SPNG_U32 cbpp);
	void SPNGREAD::paethMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev,
		SPNG_U32 cbRow, SPNG_U32 cbpp);
	void SPNGREAD::subMMXUnfilter(SPNG_U8* pbRow,
		SPNG_U32 cbRow, SPNG_U32 cbpp);
	void SPNGREAD::upMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev,
		SPNG_U32 cbRow);
	/* INTEL/MICROSOFT PROPRIETARY END */

	/* Set up for interlace by reading the first 6 passes and unfiltering
		them. */
	bool FInterlaceInit(void);
	/* De-interlace a single row. */
	void Uninterlace(SPNG_U8 *pb, SPNG_U32 y);
	/* De-interlace one pass in a row. */
	void UninterlacePass(SPNG_U8 *pb, SPNG_U32 y, int pass);

	/*** Basic data access. ***/
	inline const SPNG_U8 *Pb(SPNG_U32 uoffset) const
		{
		SPNGassert(uoffset < m_cb && m_pb != NULL);
		return m_pb+uoffset;
		}

	/*** Data ***/
	/*** Temporary data ***/
	SPNG_U32       m_ucrc;           /* CRC of current chunk. */

	/*** Palette information ***/
	const SPNG_U8* m_prgb;           /* Pointer to the palette (RGB). */
	SPNG_U32       m_crgb;           /* Number of entries. */

	/*** Text chunk offsets. ***/
	SPNG_U32       m_uPNGtEXtFirst;  /* First text chunk. */
	SPNG_U32       m_uPNGtEXtLast;   /* Last text chunk. */

	/*** Chunk offsets ***/
	SPNG_U32       m_uPNGIHDR;       /* File header - initialized to m_cb! */
	SPNG_U32       m_uPNGIDAT;       /* The first IDAT. */

	/*** Control information ***/
	const SPNG_U8* m_pb;             /* The data. */
	SPNG_U32       m_cb;
	UNALIGNED SPNG_U8* m_rgbBuffer;  /* The input buffer. */
	SPNG_U32       m_cbBuffer;       /* The size of this buffer. */
	SPNG_U32       m_cbRow;          /* Bytes for a complete row (rounded up). */
	SPNG_U32       m_y;              /* Which row we are on. */
	SPNG_U32       m_uLZ;            /* The next LZ compressed segment. */
	z_stream       m_zs;             /* The LZ compressed chunk stream. */
	bool           m_fInited;        /* When initialization has been done. */
	bool           m_fEOZ;           /* Set at end of Zlib stream. */
	bool           m_fReadError;     /* Some other error reading. */
	bool           m_fCritical;      /* Unknown critical chunk seen. */
	bool           m_fBadFormat;     /* Insurmountable format error. */
	bool           m_fMMXAvailable;  /* Intel CPU which supports MMX. */
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngreadzlib.cpp ===
/*****************************************************************************
    spngreadzlib.cpp

    PNG support code - SPNGREAD zlib interface.
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngread.h"


/*----------------------------------------------------------------------------
    Initialize the stream (call before each use).  uLZ tells us where to
    start - we don't check the chunk type here...
----------------------------------------------------------------------------*/
bool SPNGREAD::FInitZlib(SPNG_U32 uLZ, SPNG_U32 cbheader)
    {
    if (m_fInited)
        EndZlib();

    if (!FOK())
        return false;

    SPNGassert(m_rgbBuffer != NULL);
    if (m_rgbBuffer == NULL)
        return false;

    m_fReadError = false;

    /* No output buffer yet (and inflateInit2 would treat this as a
        history buffer anyway.) */
    m_zs.next_out = Z_NULL;
    m_zs.avail_out = 0;

    SPNGassert(SPNGu32(m_pb+m_uLZ+4) == PNGIDAT ||
        SPNGu32(m_pb+m_uLZ+4) == PNGiCCP || SPNGu32(m_pb+m_uLZ+4) == PNGzTXt);

    /* m_uLZ always refers to the current chunk, Zlib does not have
        const pointers but it doesn't overwrite the input. */
    m_uLZ = uLZ;
    m_zs.next_in = const_cast<SPNG_U8*>(m_pb + m_uLZ + 8 + cbheader);
    m_zs.avail_in = SPNGu32(m_pb+m_uLZ); // Includes header

    /* Check for truncation because truncated IDAT chunks are allowed
        below. */
    if (m_uLZ+8+m_zs.avail_in > m_cb)
        {
        /* Higher levels should guarantee this. */
        SPNGassert(m_uLZ+8 <= m_cb);
        m_zs.avail_in = m_cb-m_uLZ-8;
        }

    /* Remove the header bytes, we may run out of data before we can
        do anything. 
        we need 1 byte to start with (a zero sized IDAT
        at the start will hose this, higher levels could skip it, but
        it would be really bogus to generate such a thing.  Office
        itself can, in theory, generate a 1 byte IDAT if the data starts
        on exactly the wrong boundary.) */
    if (m_zs.avail_in < cbheader+1)
        {
        SPNGlog("PNG: insufficient LZ data");
        m_fEOZ = m_fReadError = true;
        m_fInited = false;
        m_zs.next_in = NULL;
        m_zs.avail_in = 0;
        return false;
        }

    m_zs.avail_in -= cbheader;

    /* The first byte in the stream is the "method" byte, it should have
        Z_DEFLATED in the low four bits and the window size which we need
        in the upper. */
    m_fInited = FCheckZlib(inflateInit2(&m_zs, 8+(*m_zs.next_in >> 4)));

    if (m_fInited)
        {
        ProfZlibStart
        }

    m_fEOZ = !m_fInited;
    return m_fInited;
    }


/*----------------------------------------------------------------------------
    Low level API to read some bytes.  This API always resets the available
    out buffers, returns the number of bytes read, 0 on error, it may return
    fewer bytes than are asked for - this allows the caller to ask for
    arbitrarily many bytes if necessary.  uchunk says what to do when we reach
    the end of the chunk of input data - go looking for another chunk or stop
    now (if uchunk is 0).
----------------------------------------------------------------------------*/
int SPNGREAD::CbReadBytes(SPNG_U8* pb, SPNG_U32 cbMax, SPNG_U32 uchunk)
    {
    if (m_fEOZ || m_fReadError)
        {
        SPNGlog("PNG: read beyond end of Zlib stream");
        return 0;
        }

    m_zs.next_out = pb;
    m_zs.avail_out = cbMax;

    for (;;)
        {
        /* Now we can invoke Zlib to read the bytes. */
        int i(inflate(&m_zs, Z_PARTIAL_FLUSH));

        /* Expect Z_BUF_ERROR when more input is needed. */
        if (i != Z_BUF_ERROR && !FCheckZlib(i))
            break;

        /* Zlib may tell us that the stream has ended. */
        if (i == Z_STREAM_END)
            m_fEOZ = true;

        /* Work out how many (if any) bytes we got. */
        i = cbMax-m_zs.avail_out;
        SPNGassert(m_zs.next_out-pb == i);

        /* And return on any non-zero result. */
        if (i > 0)
            {
            /* For safety clean out the input infromation. */
            m_zs.next_out = NULL;
            m_zs.avail_out = 0;
            return i;
            }

        /* At this point expect 0 input. */
        SPNGassert(m_zs.avail_in == 0);
        if (m_zs.avail_in > 0)
            break;

        /* Try to find a new chunk if a continuation is permitted. */
        if (uchunk == 0)
            goto LEnd;

        SPNG_U32 u(m_uLZ);
        SPNG_U32 ulen(SPNGu32(m_pb+u)); /* Chunk length. */
        /* The following assert need not be true - e.g. if a chunk of
            one name is continued in one of a different number - but there
            is no case of this at present. */
        SPNGassert(SPNGu32(m_pb+u+4) == uchunk);

        /* The in pointer should always be at the end of this chunk (hum,
            this is an assumption on my part about exactly how Zlib works,
            it doesn't actually matter if this fails, but I think it is
            impossible.) */
        SPNGassert(m_zs.next_in == m_pb+u+8+ulen ||
            m_zs.next_in == m_pb+m_cb); // The truncated IDAT case

        /* So scan the chunks for the next IDAT.  According to the PNG
            spec they should be consequetive, but we don't care if they
            aren't. */
        for (;;)
            {
            u += ulen+12;    /* Header plus CRC. */
            if (u+8 >= m_cb) /* No space for a chunk. */
                goto LEnd;

            ulen = SPNGu32(m_pb+u);
            SPNG_U32 chunk(SPNGu32(m_pb+u+4)); /* Chunk type. */
            if (chunk == uchunk)
                break;
            if (chunk == PNGIEND)
                goto LEnd;

            /* The following happens if we don't have enough data in the
                PNG, or there is an error in our code - we end up reading
                beyond the last IDAT chunk. */
            SPNGlog2("PNG: expected 0x%x, not 0x%x", uchunk, chunk);
            }

        /* Got a chunk. */
        m_uLZ = u;
        m_zs.next_in = const_cast<SPNG_U8*>(m_pb+u+8);
        SPNG_U64 u64Size = ulen;
        u64Size += u + 8;
        if (u64Size > (SPNG_U64)m_cb) /* Chunk is truncated */
            ulen = m_cb-u-8;
        m_zs.avail_in = ulen;
        }

LEnd:
    /* This is the stream error exit case. */
    m_zs.next_out = NULL;
    m_zs.avail_out = 0;
    /* So this means decompression error or read error (e.g.
        a truncated PNG.) */
    SPNGlog("PNG: zlib data read error");
    m_fReadError = true;
    return 0;
    }


/*----------------------------------------------------------------------------
    A utility to read a given number of bytes, if the read fails sets the
    read error flag and 0 fills.  If called after a read failure just zero
    fills.
----------------------------------------------------------------------------*/
void SPNGREAD::ReadRow(SPNG_U8* pb, SPNG_U32 cb)
    {
    while (cb > 0 && !m_fReadError && !m_fEOZ)
        {
        int cbT(CbReadBytes(pb, cb, PNGIDAT));
        if (cbT <= 0)
            break;
        cb -= cbT;
        pb += cbT;
        }

    if (cb > 0)
        {
        SPNGassert(m_fReadError || m_fEOZ); // Something must have happened.
        m_fReadError = true;                // Signal truncation.
        memset(pb, 0, cb);
        }
    }


/*----------------------------------------------------------------------------
    Clean up the Zlib stream (call on demand, called automatically by
    destructor and FInitZlib.)
----------------------------------------------------------------------------*/
void SPNGREAD::EndZlib()
    {
    if (m_fInited)
        {
        ProfZlibStop
        /* Always expect Zlib to end ok. */
        m_fInited = false;
        int iz;
        iz = inflateEnd(&m_zs);
        SPNGassert(iz == Z_OK);
        }
    }


/*----------------------------------------------------------------------------
    API to read a compressed chunk.  This is defined to make the iCCP and zTXT
    specifications - a keyword (0 terminated) followed by compressed data.  The
    API will handle results which overflow the passed in buffer by allocating
    using the Zlib allocator, a buffer *must* be passed in!  The API returns
    NULL on error, the passed in szBuffer if it was big enough, else a pointer
    to a new buffer which must be deallocated with the Zlib deallocator.   If
    the result is non-NULL cchBuffer is updated to the length of the data
    returned.
----------------------------------------------------------------------------*/
SPNG_U8 *SPNGREAD::PbReadLZ(SPNG_U32 uoffset, char szKey[80],
    SPNG_U8 *szBuffer, SPNG_U32 &cchBuffer)
    {
    SPNG_U32 ulen(SPNGu32(m_pb+uoffset)); /* Chunk length. */

    /* Only zTXt and iCCP have the required format at present, so do the
        following - easy to change for other chunks if required.  This
        check ensures we get called with the correct offset. */
    SPNGassert(SPNGu32(m_pb+uoffset+4) == PNGiCCP ||
                    SPNGu32(m_pb+uoffset+4) == PNGzTXt);

    /* Strip out the keyword - it is limited to 79 bytes. */
        {
        SPNG_U32 u(0);

        bool fKeyOk(false);
        while (!fKeyOk && u < ulen && u < 80 && uoffset+u < m_cb)
            {
            *szKey++ = m_pb[uoffset+u];
            fKeyOk = m_pb[uoffset+u++] == 0;
            }

        /* The compression byte must be 0. */
        if (!fKeyOk || u >= ulen || uoffset+u >= m_cb || m_pb[uoffset+u] != 0)
            {
            szKey[79] = 0;
            SPNGlog3("PNG: %x: key %s: %s LZ data", SPNGu32(m_pb+uoffset+4),
                szKey, fKeyOk && u < ulen && uoffset+u < m_cb &&
                    m_pb[uoffset+u] != 0 ? "invalid (not deflate)" : "no");
            return NULL;
            }

        if (!FInitZlib(uoffset, ++u))
            return NULL;
        }

    SPNGassert(!m_fEOZ);

    SPNG_U32 ubuf(0);
    SPNG_U32 usz(0);
    voidpf   psz = NULL;
    bool     fOK(false);

    SPNGassert(m_zs.zalloc != NULL && m_zs.zfree != NULL);
    if (m_zs.zalloc != NULL && m_zs.zfree != NULL)
        {
        /* Loop, reading bytes until we reach the end. */
        do
            {
            int cb(CbReadBytes(szBuffer+ubuf, cchBuffer-ubuf, 0));
            if (cb <= 0)
                break;
            ubuf += cb;

            if (ubuf >= cchBuffer)
                {
                SPNGassert(ubuf == cchBuffer);

                voidpf pszT = m_zs.zalloc(m_zs.opaque, cchBuffer+usz, 1);
                if (pszT == NULL)
                    break;
                if (psz != NULL)
                    {
                    memcpy(pszT, psz, usz);
                    m_zs.zfree(m_zs.opaque, psz);
                    }
                psz = pszT;
                memcpy(static_cast<SPNG_U8*>(psz)+usz, szBuffer, cchBuffer);
                usz += cchBuffer;
                ubuf = 0;
                }

            fOK = m_fEOZ && !m_fReadError;
            }
        while (!m_fReadError && !m_fEOZ);
        }

    EndZlib();

    if (fOK)
        {
        if (psz != NULL)
            {
            cchBuffer = usz;
            return static_cast<SPNG_U8*>(psz);
            }
        else
            {
            cchBuffer = ubuf;
            return szBuffer;
            }
        }

    if (psz != NULL)
        m_zs.zfree(m_zs.opaque, psz);

    return NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngsite.cpp ===
/*****************************************************************************
	spngsite.cpp

	IO error and memory management.  Based on the _mgr things in the IJG code
	but all gathered into one structure for convenience.
*****************************************************************************/
#include <msowarn.h>
#include "spngsite.h"

/* Depending on the compilation option all of these APIs have, at some
	time, unreferenced formal parameters. */
/*----------------------------------------------------------------------------
	Abort handling dummy implementation.
----------------------------------------------------------------------------*/
bool BITMAPSITE::FGo(void) const
	{
	return true;
	}


/*----------------------------------------------------------------------------
	These are dummy implementations which can be used if a sub-class gains
 	no advantage from the size information.
----------------------------------------------------------------------------*/
bool BITMAPSITE::FWrite(const void *pv, size_t cb)
	{
	#if 0
		Error(true, __FILE__, __LINE__,
			"BITMAPSITE::FWrite (%d bytes): not implemented", cb);
	#endif
	return false;
	}


/*----------------------------------------------------------------------------
	Error handling.  The site provides an "error" API which gets called to log
	errors and is passed a boolean which indicates whether the error is fatal
	or not.  The API is not implemented in debug builds, the default
	implementation does nothing in other builds.
----------------------------------------------------------------------------*/
#if !0
void __cdecl BITMAPSITE::Error(bool fatal, const char *szFile, int iline,
	const char *szExp, ...) const
	{
	}
#endif


/*----------------------------------------------------------------------------
	Profiling dummy implementations.
----------------------------------------------------------------------------*/
void BITMAPSITE::ProfileStart(int iwhat)
	{
	#if 0
		Error(false, __FILE__, __LINE__,
			"SPNG: profile %d start in debug unexpected", iwhat);
	#endif
	}

void BITMAPSITE::ProfileStop(int iwhat)
	{
	#if 0
		Error(false, __FILE__, __LINE__,
			"SPNG: profile %d stop in debug unexpected", iwhat);
	#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngsite.h ===
#pragma once
#define SPNGSITE_H 1
/*****************************************************************************
	spngsite.h

	IO error and memory management.  Based on the _mgr things in the IJG code
	but all gathered into one structure for convenience.
*****************************************************************************/
#include <stddef.h>

class BITMAPSITE
	{
public:
	/* A virtual destructor is required. */
	inline virtual ~BITMAPSITE()
		{
		}

	/* Do we keep processing?  Must be implemented in a sub-class somewhere,
		the API checks for some user abort and if it sees one must return
		false, otherwise it must return true.  The default implementation
		always returns true. */
	virtual bool FGo(void) const;

	/* Data format error handling - implemented everywhere this is used to
		log problems in the data.  It gets integer values which indicate
		the nature of the error and are defined on a per bitmap implementation
		basis.  The API returns a bool which indicates whether processing
		should stop or not, it also receives a bool which indicates whether
		or not the error is fatal. */
	virtual bool FReport(bool fatal, int icase, int iarg) const = 0;

	/* IO (actually only output.)  Write cb bytes to the output stream.
		The default implementation will do nothing (assert in debug.) */
	virtual bool  FWrite(const void *pv, size_t cb);

	/* Error handling.  The site provides an "error" API which gets called
		to log errors and is passed a boolean which indicates whether the
		error is fatal or not.  The API is not implemented in debug builds,
		the default implementation does nothing in other builds. */
	virtual void __cdecl Error(bool fatal, const char *szFile, int iline,
		const char *szExp, ...) const
			#if 0 || 0
				= 0
			#endif
		;

	/* Profile support - a particular bitmap implementation calls these with
		an integral enum value which indicates what is being profiled.  The
		default implementations do nothing. */
	virtual void ProfileStart(int iwhat);
	virtual void ProfileStop(int iwhat);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwrite.cpp ===
/*****************************************************************************
	spngwrite.cpp

	PNG support code and interface implementation (writing)
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"


/*****************************************************************************
	BASIC CLASS SUPPORT
*****************************************************************************/
/*----------------------------------------------------------------------------
	Initializer.
----------------------------------------------------------------------------*/
#define DEFAULT_ZLIB_LEVEL 255 // Means "default"
#define DEFAULT_WINDOW_BITS 15
SPNGWRITE::SPNGWRITE(BITMAPSITE &bms) :
	SPNGBASE(bms), m_order(spngordernone),
	m_cbOut(0), m_ucrc(0), m_ichunk(0), m_w(0), m_h(0), m_y(0), m_cbpp(0),
	m_rgbBuffer(NULL), m_cbBuffer(0), m_pbPrev(NULL), m_cbRow(0), m_cpal(0),
	m_pu1(NULL), m_pu2(NULL), m_pbTrans(NULL),
	m_fStarted(false), m_fInited(false), m_fOK(true), m_fInChunk(false),
	m_colortype(3), m_bDepth(8), m_fInterlace(false), m_fBuffer(false),
	m_fPack(false), m_fBGR(false), m_fMacA(false),
	m_istrategy(255), m_cmPPMETHOD(255),
	m_icompressionLevel(DEFAULT_ZLIB_LEVEL),
	m_iwindowBits(DEFAULT_WINDOW_BITS),
	m_filter(255), m_datatype(SPNGUnknown)
	{
	ProfPNGStart

	/* The zlib data structure is initialized here. */
	CleanZlib(&m_zs);

	/* set up for debug memory check */
	SPNGassert((* reinterpret_cast<SPNG_U32*>(m_bSlop) = 0x87654321) != 0);
	}


/*----------------------------------------------------------------------------
	Destroy any still-pending stuff.
----------------------------------------------------------------------------*/
SPNGWRITE::~SPNGWRITE(void)
	{
	EndZlib();
	ProfPNGStop

	/* perform mem trample check */
	SPNGassert(* reinterpret_cast<SPNG_U32*>(m_bSlop) == 0x87654321);
	}


/*----------------------------------------------------------------------------
	Destroy any still-pending stuff.
----------------------------------------------------------------------------*/
void SPNGWRITE::CleanZlib(z_stream *pzs)
	{
	/* Initialize the relevant stream fields. */
	memset(pzs, 0, sizeof *pzs);
	pzs->zalloc = Z_NULL;
	pzs->zfree = Z_NULL;
	pzs->opaque = static_cast<SPNGBASE*>(this);
	}


/*****************************************************************************
	PNG START AND END
*****************************************************************************/
/*----------------------------------------------------------------------------
	Setup for writing, this API takes all the data which will go into the IHDR
	chunk, it dumps a signature followed by the IHDR.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FInitWrite(SPNG_U32 w, SPNG_U32 h, SPNG_U8 bDepth,
	SPNG_U8 colortype, bool fInterlace)
	{
	SPNGassert(m_order == spngordernone);

	if (m_fInited)
		{
		SPNGlog("SPNG: zlib unexpectedly initialized (1)");
		EndZlib();
		}

	/* Record this stuff for later. */
	m_w = w;
	m_h = h;
	m_y = 0;
	m_colortype = colortype;
	m_bDepth = bDepth;
	m_cbpp = bDepth * CComponents(colortype);
	m_cbRow = (w * m_cbpp + 7) >> 3;
	m_fInterlace = fInterlace;

	SPNGassert(m_cbOut == 0);
	memcpy(m_rgb, vrgbPNGSignature, cbPNGSignature);
	m_cbOut = 8;
	m_fStarted = true;
	if (!FStartChunk(13, PNGIHDR))
		return false;
	if (!FOut32(w))
		return false;
	if (!FOut32(h))
		return false;

	SPNG_U8 b[5];
	SPNGassert(bDepth <= 16 && ((bDepth-1) & bDepth) == 0);
	b[0] = bDepth;
	SPNGassert(colortype < 7 && (colortype == 3 || (colortype & 1) == 0));
	b[1] = colortype;
	SPNGassert(bDepth == 8 || (bDepth == 16 && colortype != 3) ||
			colortype == 0 || (colortype == 3 && bDepth <= 8));
	b[2] = 0;           // compression method
	b[3] = 0;           // filter method
	b[4] = fInterlace;  // 1 for Adam7 interlace
	if (!FOutCb(b, 5))
		return false;

	m_order = spngorderIHDR;
	return FEndChunk();
	}


/*----------------------------------------------------------------------------
	Terminate writing.  This will flush any pending output, if this is not
	called the data may not be written.  This also writes the IEND chunk, all
	previous chunks must have been completed.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FEndWrite(void)
	{
	if (m_fInited)
		{
		SPNGlog("SPNG: zlib unexpectedly initialized (2)");
		EndZlib();
		}

	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIDAT && m_order < spngorderIEND);
	if (!FStartChunk(0, PNGIEND))
		return false;
	if (!FEndChunk())
		return false;
	if (m_cbOut > 0 && !FFlush())
		return false;
	m_fStarted = false;
	m_order = spngorderend;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritechrm.cpp ===
/*****************************************************************************
	spngwritecHRM.cpp

	PNG chunk writing support.

   cHRM chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

bool SPNGWRITE::FWritecHRM(const SPNG_U32 uwrgbXY[8])
	{
	static const SPNG_U32 vuwrgbXY[8] =
		{
		31270,  // White X
		32900,
		64000,  // Red X
		33000,
		30000,  // Green X
		60000,
		15000,  // Blue X
		6000
		};
	if (uwrgbXY == NULL)
		uwrgbXY = vuwrgbXY;

	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordercHRM);

	if (m_order >= spngorderPLTE)
		return true;

	if (!FStartChunk(4*8, PNGcHRM))
		return false;
	for (int i=0; i<8; ++i)
		if (!FOut32(uwrgbXY[i]))
			return false;
	if (!FEndChunk())
		return false;

	m_order = spngordercHRM;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritebkgd.cpp ===
/*****************************************************************************
	spngwritebkgd.cpp

	PNG chunk writing support.

   bKGD chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Three variations are required on this interface.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritebKGD(SPNG_U8 bIndex)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderPLTE && m_order < spngorderbKGD);

	/* Skip out of order chunks. */
	if (m_order < spngorderPLTE || m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 3)
		{
		SPNGlog1("SPNG: bKGD(index): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngorderbKGD;
		return true;
		}

	/* The entry must index the palette to be useful. */
	if (bIndex >= m_cpal)
		{
		SPNGlog2("SPNG: bKGD(index): too large (%d, %d entries)", bIndex, m_cpal);
		m_order = spngorderbKGD;
		return true;
		}
	
	/* Color type is valid, write the chunk. */
	if (!FStartChunk(1, PNGbKGD))
		return false;
	if (!FOutB(bIndex))
		return false;

	m_order = spngorderbKGD;
	return FEndChunk();
	}


bool SPNGWRITE::FWritebKGD(SPNG_U16 grey)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderbKGD);

	/* Skip out of order chunks. */
	if (m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 0)
		{
		SPNGlog1("SPNG: bKGD(grey): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngorderbKGD;
		return true;
		}

	/* There is no point writing the chunk if the value is out of range. */
	if (grey >= (1<<m_bDepth))
		{
		SPNGlog2("SPNG: bKGD(grey): %d out of range (%d bits)", grey, m_bDepth);
		m_order = spngorderbKGD;
		return true;
		}

	/* Color type is valid, write the chunk. */
	if (!FStartChunk(2, PNGbKGD))
		return false;
	if (!FOutB(SPNG_U8(grey >> 8)))
		return false;
	if (!FOutB(SPNG_U8(grey)))
		return false;

	m_order = spngorderbKGD;
	return FEndChunk();
	}


bool SPNGWRITE::FWritebKGD(SPNG_U16 r, SPNG_U16 g, SPNG_U16 b)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderbKGD);

	/* Skip out of order chunks. */
	if (m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 2)
		{
		SPNGlog1("SPNG: bKGD(color): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngorderbKGD;
		return true;
		}
	
	/* There is no point writing the chunk if the value is out of range. */
	if (r >= (1<<m_bDepth) || g >= (1<<m_bDepth) || b >= (1<<m_bDepth))
		{
		SPNGlog1("SPNG: bKGD(r,g,b): out of range (%d bits)", m_bDepth);
		m_order = spngorderbKGD;
		return true;
		}

	/* Color type is valid, write the chunk. */
	if (!FStartChunk(6, PNGbKGD))
		return false;
	if (!FOutB(SPNG_U8(r >> 8)))
		return false;
	if (!FOutB(SPNG_U8(r)))
		return false;
	if (!FOutB(SPNG_U8(g >> 8)))
		return false;
	if (!FOutB(SPNG_U8(g)))
		return false;
	if (!FOutB(SPNG_U8(b >> 8)))
		return false;
	if (!FOutB(SPNG_U8(b)))
		return false;

	m_order = spngorderbKGD;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngutf8.cpp ===
/*****************************************************************************
	spngutf8.cpp

	Dummy UTF8 handling.
*****************************************************************************/
#include "spngconf.h"
#include "spnginternal.h"

/* The UNICODE/UTF8 convertions. */
int UTF8ToUnicode(const char *pszIn, int cchIn, wchar_t *pwzOut, int cwchOut)
	{
	if (pwzOut == NULL || cwchOut < 1)
		return 0;

	int cwch(0);
	while (cchIn > 0 && cwch < cwchOut && *pszIn != 0)
		{
		*pwzOut++ = static_cast<unsigned char>(0xff & *pszIn++);
		--cchIn;
		++cwch;
		}
	if (cwch < cwchOut)
		*pwzOut = 0;
	else
		pwzOut[-1] = 0;
	return cwch;
	}

int UnicodeToUTF8(const wchar_t *pwzIn, int cwchIn, char *pszOut, int cchOut)
	{
	if (pszOut == NULL || cchOut < 1)
		return 0;

	int cch(0);
	while (cwchIn > 0 && cch < cchOut && *pwzIn != 0)
		{
		*pszOut++ = static_cast<char>(*pwzIn++);
		--cwchIn;
		++cch;
		}
	if (cch < cchOut)
		*pszOut = 0;
	else
		pszOut[-1] = 0;
	return cch;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngthousands.cpp ===
/*****************************************************************************
	spngthousands.cpp

	Implementation of SetThousands fixed tables, in a separate file to avoid
	dragging in the data if it is not used.
*****************************************************************************/
#include "spngwrite.h"

/*----------------------------------------------------------------------------
	Macro to build an SPNG_U32, four bytes are given in order left to right -
	so msb to lsb on the Mac lsb to msb on little endian machines.
----------------------------------------------------------------------------*/
#if MAC
	#define U_(b1,b2,b2,b4) ((( (( ((b1)<<8) + (b2) )<<8) + (b3) )<<8) + (b4))
#else
	#define U_(b1,b2,b3,b4) ((( (( ((b4)<<8) + (b3) )<<8) + (b2) )<<8) + (b1))
#endif


/*----------------------------------------------------------------------------
	The 5:5:5 lookup tables.
----------------------------------------------------------------------------*/
#define B8_(b5) ( ( (b5)+((b5)<<5) )>>2 ) // Spread 5 bits into 8
#define B8(b5) B8_( (b5) & 0x1F )

#define IMTRow4(x)  IMTB(x), IMTB(x+1), IMTB(x+2), IMTB(x+3)
#define IMTRow16(x) IMTRow4(x), IMTRow4(x+4), IMTRow4(x+8), IMTRow4(x+12)
#define IMTRow64(x) IMTRow16(x), IMTRow16(x+16), IMTRow16(x+32), IMTRow16(x+48)

/* Need the red and green bits from the most significant byte of the word
	(first byte on the Mac.) */
#define IMTB(x) U_(B8((x)>>2), B8((x)<<3), 0, 0)

static const SPNG_U32 vrguThousandsHigh[256] = // Most significant 8 bits
	{
	IMTRow64(0),
	IMTRow64(64),
	IMTRow64(128),
	IMTRow64(128+64)
	};

#undef IMTB

/* Need the low green bits and blue bits. */
#define IMTB(x) U_(0, B8((x)>>5), B8(x), 0)

static const SPNG_U32 vrguThousandsLow[256] =
	{
	IMTRow64(0),
	IMTRow64(64),
	IMTRow64(128),
	IMTRow64(128+64)
	};

#undef IMTB

#undef IMTRow64
#undef IMTRow16
#undef IMTRow4

#undef B8
#undef B8_


/*----------------------------------------------------------------------------
	Byte swapping/16bpp pixel support - sets up the SPNGWRITE to handle 5:5:5
	16 bit values in either big or little endian format.
----------------------------------------------------------------------------*/
void SPNGWRITE::SetThousands(bool fBigEndian)
	{
	if (fBigEndian)
		SetThousands(vrguThousandsHigh, vrguThousandsLow);
	else
		SetThousands(vrguThousandsLow, vrguThousandsHigh);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwrite.h ===
#pragma once
#define SPNGWRITE_H 1
/*****************************************************************************
	spngwrite.h

	PNG support code and interface implementation (writing)

	The basic PNG write class.  This does not implement generic PNG writing -
	only the things we need to do.  All we have to support are the BMP data
	formats include 32bpp BGRA and some palette based BMP reduction (in
	particular to allow the 2bpp format to be produced where required.)

	We also need to allow GIF data to be dumped into the PNG at the appropriate
	moments.
******************************************************************* JohnBo **/
#include "spngconf.h"  // For assert macro and general type convertions.

/* I do not want to have to include the definition of an IStream here,
	so I do this. */
struct IStream;

class SPNGWRITE : public SPNGBASE
	{
public:
	SPNGWRITE(BITMAPSITE &bms);
	~SPNGWRITE();

	/*** Public APIs - call in the order given! ***/

	/* Setup for writing, this API takes all the data which will go into
		the IHDR chunk, it dumps a signature followed by the IHDR. */
	bool FInitWrite(SPNG_U32 w, SPNG_U32 h, SPNG_U8 bDepth, SPNG_U8 colortype,
		bool fInterlace);

	/*** PRE IMAGE CHUNKS ***/
	/* cHRM, gAMA and sBIT must occur before PLTE.  bKGD, tRNS pHYs must be
		after PLTE and before the first IDAT.  We write chunks in the same
		order as pnglib for maximum compatibility.  We write the msOC chunk in
		the position which will allow it to work even with original Office97. */
	/* Chunk order:
			IHDR
				sBIT
				sRGB (not in pnglib yet)
				gAMA
				cHRM
				msOC (because pre-SR1 Office97 required it here)
			PLTE
				tRNS
				bKGD
				hIST (never output)
				pHYs
				oFFs (never output)
				tIME
				tEXt
				msOD (dummy filler chunk to align IDAT)
			IDAT
				msOA
			IEND

		The calls must be made in this order! */
	typedef enum
		{
		spngordernone,
		spngorderIHDR,
		spngordersBIT,
		spngordersRGB,
		spngordergAMA,
		spngordercHRM,
		spngorderiCCP,
		spngordermsOC,
		spngorderPLTE,
		spngordertRNS,
		spngorderbKGD,
		spngorderhIST,
		spngorderpHYs,
		spngorderoFFs,
		spngordertIME,
		spngordertEXt,
		spngordercmPP,
		spngorderIDAT,
		spngordermsOA,
		spngorderIEND,
		spngorderend
		}
	SPNGORDER;

	/* The following APIs will dump the data. */
	/* Significant bit information is output right at the start - in fact
		this differs from the pnglib order where it may be preceded by gAMA
		but this positioning is more convenient because of the sRGB handling
		below. */
	bool FWritesBIT(SPNG_U8 r, SPNG_U8 g, SPNG_U8 b, SPNG_U8 a);

	/* When the sRGB chunk is written cHRM and gAMA will be automatically
		generated.  The intent value may be ICMIntentUseDatatype to cause the
		data type information to be used to determine the rendering intent.
		The gAMA and cHRM APIs write the sRGB/REC 709 values if passed 0.
		fgcToo can be passed to FWritesRGB to cause the code to also write
		the matching gAMA and cHRM chunks - this is the recommeded practice,
		however the cHRM chunk is large so it is wasteful. */
	bool FWritesRGB(SPNGICMRENDERINGINTENT intent, bool fgcToo=false);
	bool FWritegAMA(SPNG_U32 ugAMATimes100000);
	bool FWritecHRM(const SPNG_U32 uWhiteRedGreenBlueXY[8]);
	bool FWriteiCCP(const char *szName, const void *pvData, size_t cbData);
	bool FWritemsOC(SPNG_U8 bImportant);

	bool FWritePLTE(const SPNG_U8 (*pbPal)[3], int cpal);

	/* Chunks after the PLTE. */
	bool FWritetRNS(SPNG_U8 bIndex);
	bool FWritetRNS(SPNG_U8 *rgbIndex, int cIndex);
	bool FWritetRNS(SPNG_U16 grey);
	bool FWritetRNS(SPNG_U16 r, SPNG_U16 g, SPNG_U16 b);

	/* Background color. */
	bool FWritebKGD(SPNG_U8 bIndex);
	bool FWritebKGD(SPNG_U16 grey);
	bool FWritebKGD(SPNG_U16 r, SPNG_U16 g, SPNG_U16 b);

	/* Physical information - always pixels per metre or "unknown". */
	bool FWritepHYs(SPNG_U32 x, SPNG_U32 y, bool fUnitIsMetre);

	/* Timing information - the caller must format the buffer. */
	bool FWritetIME(const SPNG_U8 rgbTime[7]);

	/* Text chunk handling, caller must convert to narrow strings. */
	bool FWritetEXt(const char *szKey, const char *szValue);

	/* Write the cmPP chunk.  This doesn't actually write the chunk,
		instead it records the method - the chunk will be written before
		the first IDAT. */
	inline void WritecmPP(SPNG_U8 bMethod)
		{
		m_cmPPMETHOD = bMethod;
		}

	/*** IMAGE HANDLING ***/
	/* Control the filtering and strategy.  Call these APIs if you know what
		you are doing.  If you don't but *do* know that the data is computer
		generated or photographic call the API below - this makes supposedly
		intelligent choices.  The "filter" can either be a single filter as
		defined by the PNGFILTER enum or a range composed using a mask from
		the PNGFILTER enum. */
	inline void SetCompressionLevel(int ilevel)
		{
		if (ilevel == Z_DEFAULT_COMPRESSION)
			m_icompressionLevel = 255; // Internal flag
		else
			{
			SPNGassert(ilevel >= 0 && ilevel <= Z_BEST_COMPRESSION);
			m_icompressionLevel = SPNG_U8(ilevel);
			}
		}

	inline void SetStrategy(SPNG_U8 strategy)
		{
		SPNGassert(strategy == Z_DEFAULT_STRATEGY || strategy == Z_FILTERED ||
			strategy == Z_HUFFMAN_ONLY);
		m_istrategy = strategy;
		}

	inline void SetFilter(SPNG_U32 filter)
		{
		SPNGassert(filter <= 4 || filter > 7 && (filter & 7) == 0);
		m_filter = SPNG_U8(filter);
		}

	typedef enum
		{
		SPNGUnknown,        // Data could be anything
		SPNGPhotographic,   // Data is photographic in nature
		SPNGCG,             // Data is computer generated but continuous tone
		SPNGDrawing,        // Data is a drawing - restricted colors
		SPNGMixed,          // Data is mixed SPNGDrawing and SPNGCG
		}
	SPNGDATATYPE;

	inline void SetData(SPNGDATATYPE datatype)
		{
		SPNGassert(datatype <= SPNGMixed);
		m_datatype = SPNG_U8(datatype);
		}

	/* APIs to specify how the input data must be transformed.  Note that this
		is a very small subset of the original libpng transformations - just the
		things which are necessary for the bitmaps we encounter.  If any of
		these options are called internal buffer space will be allocated and
		then the previous row is always retained - so the fBuffer flag to
		CbWrite below becomes irrelevant.  These APIs must be called before
		CbWrite. */
	/* SetPack - data must be packed into pixels.  Normally the input will be
		in bytes or nibbles and the format will be in nibbles or 2bpp units.  If
		the input is 32bpp then the alpha *byte* (of the *input* is stripped to
		get 32bpp.)  Which byte is stripped is determined by SetBGR - if set
		then the fourth byte of every four is skipped (the Win32 layout), if not
		then the first byte is skipped (the Mac layout.) */
	inline void SetPack(void)
		{
		m_fPack = true;
		}

	/* SetTranslation - for input which is 8bpp or less the input pixels can
		be translated directly via a translation table with 256 8 bit entries.
		*/
	inline void SetTranslation(const SPNG_U8* pbTrans)
		{
		m_fPack = true;
		m_pbTrans = pbTrans;
		}

	/* SetThousands - the input is 16bpp with bitfields, the output is 24bpp.
		The two arrays are lookup tables for the first and second byte of each
		pixel, they are added together (pu1[b1]+pu2[b2]) to get 24 bits of
		data in the *lower* 24 bits on a little endian machine and the *upper*
		24 bits on a big endian machine (in the correct order!).  These bits
		are then pumpted into the output, 32 at a time. */
	inline void SetThousands(const SPNG_U32 *pu1, const SPNG_U32 *pu2)
		{
		m_fPack = true;
		m_pu1 = pu1;
		m_pu2 = pu2;
		}

	/* Byte swapping/16bpp pixel support - sets up the SPNGWRITE to handle
		5:5:5 16 bit values in either big or little endian format bu calling
		the appropriate SetThousands call above. */
	void SetThousands(bool fBigEndian);

	/* Set BGR - the input data (24 or 32 bit) is in BGR form.  This may be
		combined with SetPack to have the non-RGB (alpha or pack) byte stripped.
		*/
	inline void SetBGR(void)
		{
		m_fPack = true;
		m_fBGR = true;
		}

	/* SetMacA - the input is 32bpp in the format ARGB (as on the Mac) not
		RGBA. */
	inline void SetMacA(void)
		{
		m_fPack = true;
		m_fMacA = true;
		}

	/* Return the number of bytes required as buffer.  May be called at any
		time after FInitWrite, if fBuffer is true space is requested to buffer
		a previous row, otherwise the caller must provide that row.  The fReduce
		setting (see above) indicates that the caller will provide data which
		must be packed to a lower bit depth, fBuffer is ignored and the previous
		row is always retained.   The fInterlace setting indicates that the
		caller will call FWriteRow so the API must buffer all the rows to be
		able to do the interlace.  fBuffer and fReduce are then irrelevant. */
	size_t CbWrite(bool fBuffer, bool fInterlace);

	/* Set the output buffer.  Must be called before any Zlib activity or any
		bitmap stuff is passed in. */
	bool FSetBuffer(void *pvBuffer, size_t cbBuffer);

	/* Write a single row of a bitmap.  This applies the relevant filtering
		strategy then outputs the row.  Normally the cbpp value must match that
		calculated in FInitWrite, however 8bpp input may be provided for any
		lesser bpp value (i.e. 1, 2 or 4) if fRedce was passed to CbWrite.  The
		API may just buffer the row if interlacing.   The width of the buffers
		must correspond to the m_w supplied to FInitWrite and the cbpp provided
		to this call. */
	bool FWriteLine(const SPNG_U8 *pbPrev, const SPNG_U8 *pbThis,
		SPNG_U32 cbpp/*bits per pixel*/);

	/* After the last line call FEndImage to flush the last IDAT chunk. */
	bool FEndImage(void);

	/* Alternatively call this to handle a complete image.  The rowBytes gives
		the packing of the image.  It may be negative for a bottom up image.
		May be called only once!  This calls FEndImage automatically. */
	bool FWriteImage(const SPNG_U8 *pbImage, int cbRowBytes, SPNG_U32 cbpp);

	/*** POST IMAGE CHUNKS ***/
	/* Write an Office Art chunk.  The API just takes the data and puts the
		right header and CRC in, the chunk type (standard PNG format) is given
		as a single byte code, no ordering checks are done (so this can be used
		anywhere the relevant chunk is valid). */
	bool FWritemsO(SPNG_U8 bType, const SPNG_U8 *pbData, size_t cbData);

	/* Do the same thing but take the data from an IStream, the size of the
		data must be provided. */
	bool FWritemsO(SPNG_U8 bType, struct IStream *pistm, size_t cbData);

	/* Write a GIF application extension block.  The input to this is a
		sequence of GIF blocks following the GIF89a spec and, as a consequence,
		the first byte should normally be the value 11, the cbData field is
		used as a check to ensure that we do not overflow the end in the case
		where the file is truncated. */
	bool FWritegIFx(const SPNG_U8* pbBlocks, size_t cbData);

	/* Write a GIF Graphic Control Extension "extra information" chunk. */
	bool FWritegIFg(SPNG_U8 bDisposal, SPNG_U8 bfUser, SPNG_U16 uDelayTime);

	/* Write a totally arbitrary chunk. */
	bool FWriteChunk(SPNG_U32 uchunk, const SPNG_U8 *pbData, size_t cbData);

	/* The same, however the chunk may be written in pieces.  The chunk
		is terminated with a 0 length write, the ulen must be given to
		every call and must be the complete length!  The CRC need only
		be provided on the last (0 length) call, it overrides the passed
		in CRC.  An assert will be produced if there is a CRC mismatch but
		the old CRC is still output. */
	bool FWriteChunkPart(SPNG_U32 ulen, SPNG_U32 uchunk, const SPNG_U8 *pbData,
		size_t cbData, SPNG_U32 ucrc);

	/* Terminate writing.  This will flush any pending output, if this is
		not called the data may not be written. */
	bool FEndWrite(void);

private:
	/* Called to clean out the z_stream in pzs. */
	void CleanZlib(z_stream *pzs);

	/* Resolve the data/strategy information.  Done before the first IDAT chunk
		(in fact done inside FInitZlib.) */
	void ResolveData();

	/* Start a chunk, including initializing the CRC buffer. */
	bool FStartChunk(SPNG_U32 ulen, SPNG_U32 uchunk);

	/* Return a pointer to the available buffer space - there should always be
		at least one byte free in the buffer. */
	inline SPNG_U8 *PbBuffer(unsigned int &cbBuffer)
		{
		cbBuffer = (sizeof m_rgb) - m_cbOut;
		return m_rgb + m_cbOut;
		}

	/* End the chunk, producing the CRC. */
	bool FEndChunk(void);

	/* Flush the buffer - it need not be full! */
	bool FFlush(void);

	/* Output some bytes, may call FFlush. */
	inline bool FOutB(SPNG_U8 b);
	inline bool FOutCb(const SPNG_U8 *pb, SPNG_U32 cb);

	/* Output a single u32 value, may call FFlush. */
	inline bool FOut32(SPNG_U32 u); // Optimized
	bool FOut32_(SPNG_U32 u);       // Uses FOutCb

	/* Initialize the stream (call before each use) and clean it up (call
		on demand, called automatically by destructor and FInitZlib.) */
	bool FInitZlib(int istrategy, int icompressionLevel, int iwindowBits);
	void EndZlib(void);

	/* Append bytes to a chunk, the chunk type is presumed to be PNGIDAT,
		the relevant chunk is started if necessary and the data is compressed
		into the output until all the input has been consumed - possibly
		generating new chunks on the way (all of the same type - PNGIDAT.)
		*/
	bool FWriteCbIDAT(const SPNG_U8* pb, size_t cb);
	bool FFlushIDAT(void);
	bool FEndIDAT(void);

	/* Output one line, the API takes a filter method which should be used
		and the (raw) bytes of the previous line as well as this line.  Lines
		must be passed in top to bottom.  This API handles the interlace pass
		case as well - just call with the correct width (pass bytes minus 1 -
		the filter byte is not included.)

		Note that a width of 0 will result in no output - I think this is
		correct and it should give the correct interlace result. */
	bool FFilterLine(SPNG_U8 filter, const SPNG_U8 *pbPrev,
		const SPNG_U8 *pbThis, SPNG_U32 w/*in bytes*/,
		SPNG_U32 cb/*step in bytes*/);

	/* Enquiry to find out whether the previous line is required.   Note that
		this code relies on PNGFNone==0, so we can check for a mask which just
		has the None/Sub bits set. */
	inline bool FNeedBuffer(void) const
		{
		return m_h > 1 && m_filter != PNGFSub &&
			(m_filter & ~(PNGFMaskNone | PNGFMaskSub)) != 0;
		}

	/* Internal API to copy a row when it also requires packing into fewer
		bits per pixel or other transformations. */
	bool FPackRow(SPNG_U8 *pb, const SPNG_U8 *pbIn, SPNG_U32 cbpp);

	/* Likewise, an api to interlace a single line - y must be 0,2,4 or 6,
		cb must be a multiple of 8 (bytes.)  The input is copied to the
		output, which must not be the same.  Some implementations also
		modify the input. */
	void Interlace(SPNG_U8* pbOut, SPNG_U8* pbIn, SPNG_U32 cb,
		SPNG_U32 cbpp, SPNG_U32 y);

	/*** Data ***/
	SPNGORDER      m_order;              /* Where we are in the output. */
	SPNG_U32       m_cpal;               /* Actual palette entries.*/
	SPNG_U32       m_cbOut;              /* Output buffer byte count. */
	SPNG_U32       m_ucrc;               /* CRC buffer. */
	SPNG_U32       m_ichunk;             /* Index of chunk start. */

	SPNG_U32       m_w;                  /* Width of input in pixels. */
	SPNG_U32       m_h;                  /* Total number of rows. */
	SPNG_U32       m_y;                  /* Current Y (for interlace) */
	SPNG_U32       m_cbpp;               /* Bits per pixel. */

public:
	/* accessors for the above. */
	inline SPNG_U32 W() const {
		return m_w;
	}

	inline SPNG_U32 H() const {
		return m_h;
	}

	inline SPNG_U32 Y() const {
		return m_y;
	}

	inline SPNG_U32 CBPP() const {
		return m_cbpp;
	}

private:
	/*** Interlace handling, etc. ***/
	SPNG_U8*       m_rgbBuffer;
	size_t         m_cbBuffer;
	SPNG_U8*       m_pbPrev;             /* Points into m_rgbBuffer. */
	SPNG_U32       m_cbRow;
	const SPNG_U32*m_pu1;                /* 16bpp->24bpp lookup array. */
	const SPNG_U32*m_pu2;
	const SPNG_U8* m_pbTrans;            /* 8bpp or less translation. */

	/*** Zlib. ***/
	z_stream       m_zs;                 /* The IDAT chunk stream. */
	SPNG_U8        m_colortype;
	SPNG_U8        m_bDepth;
	SPNG_U8        m_istrategy;
	SPNG_U8        m_icompressionLevel;
	SPNG_U8        m_iwindowBits;
	SPNG_U8        m_filter;
	SPNG_U8        m_datatype;
	SPNG_U8        m_cmPPMETHOD;

	/*** Control information. ***/
	bool           m_fStarted;           /* Started writing. */
	bool           m_fInited;            /* Zlib initialized. */
	bool           m_fOK;                /* Everything is OK. */
	bool           m_fInChunk;           /* Processing a chunk. */
	bool           m_fInterlace;         /* Output is interlaced. */
	bool           m_fBuffer;            /* We must buffer the previous row. */
	bool           m_fPack;              /* Input data must be packed. */
	bool           m_fBGR;               /* Input data must be byte swapped. */
	bool           m_fMacA;              /* Input Alpha must be swapped. */

	/* The buffer size determines the maximum buffer passed to Zlib and
		the maximum chunk size.  Make it big to make memory reallocations
		as few as possible when writing to memory. */
	SPNG_U8        m_rgb[65536];         /* Output buffer. */
	SPNG_U8        m_bSlop[4];           /* This guards against programming
														errors! */
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwriteimage.cpp ===
/*****************************************************************************
	spngwriteimage.cpp

	PNG image writing support.

   Basic code to write a bitmap image (to IDAT chunks).
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spnginternal.h"


/*****************************************************************************
	IMAGE HANDLING
*****************************************************************************/
/*----------------------------------------------------------------------------
	Write a single row of a bitmap.  This applies the relevant filtering
	strategy then outputs the row.  Normally the cbpp value must match that
	calculated in FInitWrite, however 8bpp input may be provided for any
	lesser bpp value (i.e. 1, 2 or 4) if fRedce was passed to CbWrite.  The API
	may just buffer the row if interlacing.   The width of the buffers must
	correspond to the m_w supplied to FInitWrite and the cbpp provided to this
	call.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWriteLine(const SPNG_U8 *pbPrev, const SPNG_U8 *pbThis,
	SPNG_U32 cbpp/*bits per pixel*/)
	{
	SPNGassert(cbpp == m_cbpp || cbpp <= 8 && m_cbpp < cbpp || m_cbpp >= 24);
	SPNGassert(!m_fBuffer || !m_fInterlace);
	SPNGassert(pbPrev != NULL || m_y == 0 || (!m_fInterlace && !FNeedBuffer()) ||
		m_rgbBuffer != NULL && (m_pbPrev != NULL && m_fBuffer || m_fInterlace));
	SPNGassert(!m_fInterlace || m_rgbBuffer != NULL
		/*&& m_cbBuffer >= CbWrite(false, false, true)*/);
	SPNGassert(m_order <= spngorderIDAT);
	SPNGassert(m_y < m_h);

	/* Handle zero width. */
	m_order = spngorderIDAT;
	if (m_w == 0)
		{
		++m_y;
		return true;
		}

	/* Buffer for interlace first. */
	SPNG_U32 cb((m_cbRow+7)&~7);
	if (m_fInterlace)
		{
		SPNGassert(m_pbPrev == NULL);

		if (m_rgbBuffer == NULL)
			return false;
		SPNG_U32 ib(cb * (m_y+1));
		if (ib + cb > m_cbBuffer)
			{
			SPNGlog2("SPNG: interlace buffer overflow (%d bytes, %d allocated)",
				ib+cb, m_cbBuffer);
			return false;
			}
		/* The condition for needing to pack bytes is that the bit count does not
			match or m_fBGR is set. */
		if (cbpp == m_cbpp && !m_fPack)
			memcpy(m_rgbBuffer+ib, pbThis, m_cbRow);
		else if (!FPackRow(m_rgbBuffer+ib, pbThis, cbpp))
			return false;
		if (++m_y < m_h)
			return true;

		/* We have all the rows, do the writing. */
		m_y = 0;
		return FWriteImage(m_rgbBuffer+cb, cb, m_cbpp);
		}

	/* This is the non-interlaced case - just write the row.  We may have to
		pack the row.  We may also need to buffer the "previous" row - this is
		indicated by the m_fBuffer flag set from CbWrite.  If we hit the end of
		the buffer here check the logic in CbWrite - it is what determines the
		buffer allocation. */
	if (m_y == 0 || !FNeedBuffer())
		pbPrev = NULL;
	else if (m_pbPrev != NULL)
		pbPrev = m_pbPrev;
	else if (pbPrev == NULL)
		{
		/* We just assert here - the code will actually handle the filtering
			by doing "none". */
		SPNGassert1(pbPrev != NULL, "SPNG: row %d: no previous row", m_y);
		m_filter = PNGFNone; // Switches it off permanently
		m_fBuffer = false;   // Not required
		}

	/* Handle packing of a row. */
	SPNG_U8 *pbRow = NULL;
	if (cbpp != m_cbpp || m_fPack)
		{
		/* Must pack the row.  If we are also buffering then we must take care
			not to overwrite the previous row. */
		pbRow = m_rgbBuffer;
		if (m_fBuffer && (m_y & 1) != 0)
			pbRow += cb;

		/* Now make sure that we have adequate buffer space. */
		if (m_rgbBuffer == NULL || m_rgbBuffer+m_cbBuffer < pbRow+cb)
			{
			SPNGlog2("SPNG: no buffer (%d bytes allocated, %d row bytes)",
				m_cbBuffer, m_cbRow);
			return false;
			}

		if (!FPackRow(pbRow, pbThis, cbpp))
			return false;

		/* Store the location of this data for later, if required. */
		if (m_fBuffer)
			m_pbPrev = pbRow;
		}

	/* Process one line - the input is in either pbRow or, if this is NULL,
		pbThis. */
	if (!FFilterLine(m_filter, pbPrev, pbRow == NULL ? pbThis : pbRow, m_cbRow,
			(m_cbpp+7) >> 3))
		return false;
	++m_y;

	/* Now, if necessary, buffer the line.  Note that pbRow is set if this has
		already been done. */
	if (m_fBuffer && pbRow == NULL)
		{
		if (m_rgbBuffer == NULL || m_cbBuffer < m_cbRow)
			{
			SPNGlog2("SPNG: no buffer (%d bytes allocated, %d row bytes)",
				m_cbBuffer, m_cbRow);
			/* We can ignore this because we have not set m_pbPrev. */
			m_filter = PNGFNone;
			m_fBuffer = false;
			}
		else
			{
			memcpy(m_rgbBuffer, pbThis, m_cbRow);
			m_pbPrev = m_rgbBuffer;
			}
		}

	return true;
	}


/*----------------------------------------------------------------------------
	Alternatively call this to handle a complete image.  The rowBytes gives the
	packing of the image.  It may be negative for a bottom up image.  May be
	called only once!
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWriteImage(const SPNG_U8 *pbImage, int cbRowBytes,
	SPNG_U32 cbpp)
	{
	SPNGassert(cbpp == m_cbpp || cbpp <= 8 && m_cbpp < cbpp || m_cbpp >= 24);
	SPNGassert(m_y == 0);
	SPNGassert(m_order <= spngorderIDAT);

	m_order = spngorderIDAT;
	if (m_w <= 0)
		{
		/* No IDAT is actually written. */
		m_y = m_h;
		return true;
		}

	/* Ensure that we have enough buffer space for interlacing, if required -
		if not the interlacing gets turned off. */
	bool fInPlace(false);        // Modifying our own buffer
	SPNG_U32 cb((m_cbRow+7)&~7); // Interlace/buffer row byte count
	if (m_fInterlace)
		{
		/* So we are doing the interlace thing, we have enough buffer space but
			note that the buffer may be the same as the input - this requires some
			tweaking if it is the case. */
		if (pbImage >= m_rgbBuffer && pbImage < m_rgbBuffer+m_cbBuffer)
			{
			if (pbImage != m_rgbBuffer+cb || m_cbBuffer < cb * (m_h+1) ||
				static_cast<SPNG_U32>(cbRowBytes) != cb || cbpp != m_cbpp)
				{
				SPNGlog("SPNG: unexpected image pointer");
				m_fInterlace = false;
				m_filter = PNGFNone;
				m_fBuffer = false;
				}
			else
				fInPlace = true;
			}

		/* This is the case where we copy the data in - we only need space for
			the first 6 passes. */
		else if (m_cbBuffer < cb * (((m_h+1) >> 1)+1))
			{
			SPNGlog2("SPNG: insufficient interlace buffer (%d, need %d)",
				m_cbBuffer, cb + CbPNGPassOffset(m_w, m_h, m_cbpp, 6) - ((m_h+1) >> 1));
			m_fInterlace = false;
			m_filter = PNGFNone;
			m_fBuffer = false;
			}
		}

	/* If we are *not* doing the interlace thing then we can handle this
		one row at a line. */
	if (!m_fInterlace)
		{
		/* Cancel buffering if it turns out not to be necessary. */
		if (m_fBuffer)
			m_fBuffer = (cbpp != m_cbpp || m_fPack) && FNeedBuffer();
		const SPNG_U8 *pbPrev = NULL;
		while (m_y < m_h)
			{
			if (!FWriteLine(pbPrev, pbImage, cbpp))
				return false;
			pbPrev = pbImage;
			pbImage += cbRowBytes;
			}
		/* FWriteLine does not call FEndIDAT, so this should be OK. */
		SPNGassert(m_fInited);
		return FEndIDAT();
		}

	/* We can set m_y here because nothing below this point uses it. */
	m_y = m_h;

	/* We have interlace buffer space (m_rgbBuffer[m_cbBuffer]) and a
		step to handle the rows in the correct place.  Deinterlace the
		first 6 passes.  If working in-place then remember to skip the
		pass 7 row each time. */
	SPNG_U8*       pbOut = m_rgbBuffer;
	SPNG_U8*       pbBuffer = pbOut+cb;
	const SPNG_U8* pbIn = pbImage;

	/* If the buffers are the same the step must be the same. */
	SPNGassert(pbBuffer != pbIn ||
		cb == static_cast<SPNG_U32>(cbRowBytes) && fInPlace);
	/* Skip row 7 this time through. */
	cbRowBytes <<= 1;
	SPNG_U32 y;
	for (y=0; y<m_h; y+=2)
		{
		/* If not in place copy the input into the output buffer. */
		if (!fInPlace)
			{
			if (cbpp == m_cbpp && !m_fPack)
				memcpy(pbBuffer, pbIn, m_cbRow);
			else if (!FPackRow(pbBuffer, pbIn, cbpp))
				return false;
			}
		else if (cbpp != m_cbpp)
			{
			SPNGlog2("SPNG: bit count mismatch (%d,%d)", m_cbpp, cbpp);
			return false;
			}

		/* Set any overflow to 0 - aids compression. */
		if (cb > m_cbRow)
			memset(pbBuffer+m_cbRow, 0, cb-m_cbRow);

		/* Now interlace this line (this is, of course, only the X
			component of the interlacing.)  To do this we need to
			do something dependent on the current y.  How we do this
			depends on the pixel size. */
		Interlace(pbOut, pbBuffer, cb, m_cbpp, y&6);

		/* Next time use the buffer space which has just been vacated. */
		pbOut = pbBuffer;

		if (pbBuffer == pbIn) // In place
			pbBuffer += cb;
		pbBuffer += cb;
		pbIn += cbRowBytes;
		}

	/* Now output the first six passes. */
	SPNG_U32 cbpix((m_cbpp+7)>>3);  // Byte step count
	SPNG_U32 cbT(cb);               // Row byte count (multiple of 8)
	if (pbBuffer == pbIn)      // In place, so row 7 is in buffer too
		cb <<= 1;               // Inter-row byte count
	for (int pass=1; pass<7; ++pass)
		{
		SPNG_U32 cpix(CPNGPassPixels(pass, m_w));
		if (cpix > 0) // Else no output
			{
			/* The control variables are the number of bytes to output,
				the initial row, the step between rows and the initial
				pointer into the line. */
			cpix = (cpix * m_cbpp + 7) >> 3; // Bytes
			SPNG_U32 y(pass == 3 ? 2 : (pass == 5 ? 1 : 0));
			pbBuffer = m_rgbBuffer;   // First row goes here
			if (y > 0)
				pbBuffer += cbT + (y-1)*cb;
			y <<= 1;

			/* Step into the buffer to the first pixel in this pass.  For
				depths less than 8 the passes are byte aligned, at 8 and
				above the pixel with can be used.  The odd passes (1, 3 and
				5) are at the start of the line, the even are indented some
				distance (always the same distance.) */
			if ((pass & 1) == 0)
				{
				int ishift((8-pass) >> 1);
				if (m_cbpp < 8)
					pbBuffer += cbT >> ishift;
				else
					{
					SPNGassert((m_cbpp & 7) == 0);
					pbBuffer += (((m_w+(1<<ishift)-1) >> ishift) * m_cbpp) >> 3;
					}
				}

			SPNG_U32 yStep(8);
			if (pass > 3)
				yStep >>= (pass-2) >> 1;
			SPNG_U32 cbStep(cb * (yStep>>1));

			pbIn = NULL; // Previous row pointer
			while (y < m_h)
				{
				if (!FFilterLine(m_filter, pbIn, pbBuffer, cpix, cbpix))
					return false;
				pbIn = pbBuffer;
				pbBuffer += cbStep;
				if (y == 0) // First line follows immediately - no row 7
					pbBuffer -= (cb-cbT);
				y += yStep;
				}
			}
		}

	/* Finally output pass 7. */
	if ((cbpp != m_cbpp || m_fPack && !fInPlace) && (m_rgbBuffer == NULL ||
			m_cbBuffer < (cbT + ((FNeedBuffer() && m_h >= 4) ? cbT : 0))))
		{
		SPNGlog2("SPNG: bit count mismatch (%d,%d) and no buffer", m_cbpp, cbpp);
		return false;
		}

	pbImage += (cbRowBytes >> 1);  // First row 7
	pbIn = NULL; // Previous row
	for (y=1; y<m_h; y+=2)
		{
		const SPNG_U8* pbThis;
		if (!fInPlace)
			{
			SPNG_U8* pbT = m_rgbBuffer;
			if ((m_y & 2) && FNeedBuffer())
				{
				SPNGassert(m_cbBuffer >= (cbT << 1));
				pbT += cbT;
				}
			if (!FPackRow(pbT, pbImage, cbpp))
				return false;
			pbThis = pbT;
			}
		else
			pbThis = pbImage;

		if (!FFilterLine(m_filter, pbIn, pbThis, m_cbRow, cbpix))
			return false;
		pbIn = pbThis;
		pbImage += cbRowBytes;
		}

	/* m_y should not have been changed. */
	SPNGassert(m_y == m_h);
	return FEndIDAT();
	}


/*----------------------------------------------------------------------------
	After the last line call FEndImage to flush the last IDAT chunk.  This API
	may be called multiple times (to allow FWriteImage to work.)  Note that
	this API *just* calls FEndIDAT and, interally, FEndIDAT is called instead
	(see FWriteImage above.)
----------------------------------------------------------------------------*/
bool SPNGWRITE::FEndImage(void)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order == spngorderIDAT);
	SPNGassert(m_y == m_h);

	/* If Zlib has not been initialized there is no work to do. */
	if (!m_fInited)
		{
		SPNGassert(!m_fInChunk);
		return true;
		}

	/* So we are in a Zlib block. */
	SPNGassert(m_fInChunk);
	return FEndIDAT();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritefilter.cpp ===
/*****************************************************************************
	spngwritefilter.cpp

	PNG image writing support.

   Basic code to write a bitmap image - image line filtering.
*****************************************************************************/
#include <stdlib.h>
#pragma intrinsic(abs)

#define SPNG_INTERNAL 1
#include "spngwrite.h"


/*****************************************************************************
	IMAGE HANDLING
*****************************************************************************/
#define CBBUFFER 4096

/*----------------------------------------------------------------------------
	Filter the given bytes.  The API gets a pointer to the previous row if it
	is required and a byte count.  It filters in place.  Each API filters cbRow
	bytes according to some strategy - all cbRow bytes are processed (there is
	no skip of leading bytes) so dummy leading bytes may have to be entered.
	The APIs which refer to previous bytes work backward in the buffer!
----------------------------------------------------------------------------*/
inline void FnPNGFSub(SPNG_U8* pbRow, int cbRow, int cbpp/*bytes*/)
	{
	while (--cbRow >= 0)
#pragma warning(disable: 4244)
		pbRow[cbRow] -= pbRow[cbRow-cbpp];
#pragma warning(error: 4244)
	}

inline void FnPNGFUp(SPNG_U8* pbRow, const SPNG_U8* pbPrev, int cbRow)
	{
	while (--cbRow >= 0)
#pragma warning(disable: 4244)
		pbRow[cbRow] -= pbPrev[cbRow];
#pragma warning(error: 4244)
	}

inline void FnPNGFAverage(SPNG_U8* pbRow, const SPNG_U8* pbPrev,
	int cbRow, int cbpp/*bytes*/)
	{
	while (--cbRow >= 0)
#pragma warning(disable: 4244)
		pbRow[cbRow] -= (pbRow[cbRow-cbpp] + pbPrev[cbRow]) >> 1;
#pragma warning(error: 4244)
	}

/* This is for the case of the first line. */
inline void FnPNGFAverage1(SPNG_U8* pbRow, int cbRow, int cbpp/*bytes*/)
	{
	while (--cbRow >= 0)
#pragma warning(disable: 4244)
		pbRow[cbRow] -= pbRow[cbRow-cbpp] >> 1;
#pragma warning(error: 4244)
	}

/* Paeth on the first line is just Sub and the initial bytes are
	effectively Up. */
inline void FnPNGFPaeth(SPNG_U8* pbRow, const SPNG_U8* pbPrev, int i,
	int cbpp/*bytes*/)
	{
	/* Paeth, A.W., "Image File Compression Made Easy", in Graphics
		Gems II, James Arvo, editor.  Academic Press, San Diego, 1991.
		ISBN 0-12-064480-0.
	
		Note that this implementation of the predictor is the same as
		the read implementation - there may be speedups possible. */
	while (--i >= 0)
		{
		int c(pbPrev[i-cbpp]);    // c
		int b(pbRow[i-cbpp] - c); // a-c
		int a(pbPrev[i] - c);     // b-c
		c = abs(a+b);             // (a+b-c)-c
		a = abs(a);               // (a+b-c)-a
		b = abs(b);               // (a+b-c)-b
		if (a <= b)
			{
			if (a <= c)
#pragma warning(disable: 4244)
				pbRow[i] -= pbRow[i-cbpp];
#pragma warning(error: 4244)
			else // a > c, so c is least
#pragma warning(disable: 4244)
				pbRow[i] -= pbPrev[i-cbpp];
#pragma warning(error: 4244)
			}
		else    // a > b
			{
			if (b <= c)
#pragma warning(disable: 4244)
				pbRow[i] -= pbPrev[i];
#pragma warning(error: 4244)
			else // b > c, c is least
#pragma warning(disable: 4244)
				pbRow[i] -= pbPrev[i-cbpp];
#pragma warning(error: 4244)
			}
		}
	}


/*----------------------------------------------------------------------------
	The heuristic to determine the filter in the case where we have multiple
	filters to chose from.

	This function is EXTERNAL solely to prevent it being inlined by the
	compiler.
----------------------------------------------------------------------------*/
SPNG_U8 SPNGFilterOf(SPNG_U8 filter, const SPNG_U8 *pbPrev,
	const SPNG_U8 *pbThis, SPNG_U32 w/*in bytes*/, SPNG_U32 cb/*step in bytes*/)
	{
	SPNG_U32  uworst(~0UL);
	PNGFILTER best(PNGFNone); // A default.

	if ((filter & PNGFMaskNone) != 0)
		{
		/* Simple sum of bytes. */
		uworst = 0;
		const SPNG_S8 *pc = reinterpret_cast<const SPNG_S8*>(pbThis);
		for (SPNG_U32 i=0; i<w; ++i)
			uworst += abs(pc[i]);

		if (uworst == 0)
			return PNGFNone;
		}

	if (w > cb && ((filter & PNGFMaskSub) != 0 ||
		(filter & PNGFMaskPaeth) != 0 && pbPrev == NULL))
		{
		SPNG_U32 u(0);
		const SPNG_S8 *pc = reinterpret_cast<const SPNG_S8*>(pbThis);
		SPNG_U32 i;
		for (i=0; i<cb && i<w; ++i)
			u += abs(pc[i]);

		for (; i<w && u<uworst; ++i)
			u += abs(int((pbThis[i] - pbThis[i-cb]) << 24) >> 24);

		if (u < uworst)
			{
			uworst = u;
			best = PNGFSub;
			if (uworst == 0)
				return PNGFSub;
			}
		}

	if (pbPrev != NULL)
		{
		if ((filter & PNGFMaskUp) != 0 || w <= cb && (filter & PNGFMaskPaeth) != 0)
			{
			SPNG_U32 u(0);
			SPNG_U32 i;
			for (i=0; i<w && u<uworst; ++i)
				u += abs(int((pbThis[i] - pbPrev[i]) << 24) >> 24);

			if (u < uworst)
				{
				uworst = u;
				best = PNGFUp;
				if (uworst == 0)
					return PNGFUp;
				}
			}

		if ((filter & PNGFMaskAverage) != 0)
			{
			SPNG_U32 u(0);
			SPNG_U32 i;
			for (i=0; i<cb && i<w; ++i)
				u += abs(int((pbThis[i] - (pbPrev[i]>>1)) << 24) >> 24);

			for (; i<w && u<uworst; ++i)
				u += abs(int((pbThis[i] - ((pbPrev[i]+pbThis[i-cb])>>1)) << 24) >> 24);

			if (u < uworst)
				{
				uworst = u;
				best = PNGFAverage;
				if (uworst == 0)
					return PNGFAverage;
				}
			}

		/* This is very expensive to calculate because we must do the predictor
			thing, also, because we are working in place we have no buffer to
			temporarily generate the output.  Consequently this code will only
			try Paeth if the best-so-far is worst that PAETH_LIMIT per byte. */
		#define PAETH_LIMIT 16
		#define PAETH_BIAS 4
		if (w > cb && (filter & PNGFMaskPaeth) != 0 && uworst > PAETH_LIMIT*w)
			{
			/* This is a copy of the code below, we trash the pointers but that
				does not matter because this is the last test. */
			SPNG_U8 rgb[CBBUFFER];

			memcpy(rgb, pbThis, cb);
			FnPNGFUp(rgb, pbPrev, cb);
			pbThis += cb;
			pbPrev += cb;
			w -= cb;

			/* Pre-bias against this filter. */
			SPNG_U32 u(PAETH_BIAS*w);
			SPNG_S8* pc = reinterpret_cast<SPNG_S8*>(rgb);
			SPNG_U32 i;
			for (i=0; i<cb; ++i)
				u += abs(pc[i]);

			/* Now handle the main block. */
			if (w > 0) for (;;)
				{
				SPNG_U32 cbT(w);
				if (cbT > CBBUFFER-cb)
					cbT = CBBUFFER-cb;

				/* Make a copy then filter, for this filter the preceding
					cb bytes are required in the buffer. */
				memcpy(rgb, pbThis-cb, cbT+cb);
				FnPNGFPaeth(rgb+cb, pbPrev, cbT, cb);
				for (i=0; i<cbT && u < uworst; ++i)
					u += abs(pc[i+cb]);

				w -= cbT;
				if (w <= 0 || u >= uworst)
					break;

				pbThis += cbT;
				pbPrev += cbT;
				}

			if (u < uworst)
				best = PNGFPaeth;
			}
		}
	else if (w > cb && (filter & PNGFMaskAverage) != 0)
		{
		SPNG_U32 u(0);
		const SPNG_S8 *pc = reinterpret_cast<const SPNG_S8*>(pbThis);
		SPNG_U32 i;
		for (i=0; i<cb && i<w; ++i)
			u += abs(pc[i]);

		for (; i<w && u<uworst; ++i)
			u += abs(int((pbThis[i] - (pbThis[i-cb]>>1)) << 24) >> 24);

		if (u < uworst)
			best = PNGFAverage;
		}

	return SPNG_U8(best);
	}

	
/*----------------------------------------------------------------------------
	Output one line, the API takes a filter method which should be used and the
	(raw) bytes of the previous line as well as this line.  Lines must be
	passed in top to bottom.

	Note that a width of 0 will result in no output - I think this is correct
	and it should give the correct interlace result.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FFilterLine(SPNG_U8 filter, const SPNG_U8 *pbPrev,
	const SPNG_U8 *pbThis, SPNG_U32 w/*in bytes*/, SPNG_U32 cb/*step in bytes*/)
	{
	if (w <= 0)
		return true;
	SPNGassert(cb > 0);
	SPNGassert(w >= cb);
	SPNGassert(cb <= 8);  // 64 bpp case

	if (filter > PNGFPaeth) // A mask has been supplied, not a simple filter
		filter = SPNGFilterOf(filter, pbPrev, pbThis, w, cb);

	/* This may be inefficient, but it happens to be convenient to dump the
		filter byte first. */	
	if (!FWriteCbIDAT(&filter, 1))
		return false;

	/* This is our temporary buffer when we need to hack values. */
	SPNG_U8 rgb[CBBUFFER];
	switch (filter)
		{
	case PNGFUp:
		/* If there is no previous line there is no filtering to do. */
		if (pbPrev == NULL)
			break;

		for (;;)
			{
			SPNG_U32 cbT(w);
			if (cbT > CBBUFFER) cbT = CBBUFFER;

			/* Make a copy then filter. */
			memcpy(rgb, pbThis, cbT);
			FnPNGFUp(rgb, pbPrev, cbT);
			if (!FWriteCbIDAT(rgb, cbT))
				return false;

			w -= cbT;
			if (w <= 0)
				return true;

			pbPrev += cbT;
			pbThis += cbT;
			}

	default:
		//TODO: adaptive filtering - this code will assert here when adaptive
		// filtering is required
		SPNGlog1("PNG: invalid filter %x (adaptive filtering NYI)", filter);
		/* Treate as none. */
	case PNGFNone:
		break;

	case PNGFAverage:
		if (pbPrev == NULL)   // First line
			{
			/* If there are <=cb bytes then no filtering is possible. */
			if (w <= cb)
				break;

			/* First cb bytes are not changed. */
			for (SPNG_U32 iinc(0);;)
				{
				SPNG_U32 cbT(w);
				if (cbT > CBBUFFER-iinc)
					cbT = CBBUFFER-iinc;

				/* Make a copy then filter, for this filter the preceding
					cb bytes are required in the buffer. */
				memcpy(rgb, pbThis-iinc, cbT+iinc);
				FnPNGFAverage1(rgb+cb, cbT+iinc-cb, cb);
				if (!FWriteCbIDAT(rgb+iinc, cbT))
					return false;

				w -= cbT;
				if (w <= 0)
					return true;

				iinc = cb;
				pbThis += cbT;
				}
			}
		else
			{
			/* In this case the buffer is pre-filled with 0 stuff to
				simplify the code. */
			memset(rgb, 0, cb);
			for (;;)
				{
				SPNG_U32 cbT(w);
				if (cbT > CBBUFFER-cb)
					cbT = CBBUFFER-cb;

				/* Make a copy then filter, for this filter the preceding
					cb bytes are required in the buffer. */
				memcpy(rgb+cb, pbThis, cbT);
				FnPNGFAverage(rgb+cb, pbPrev, cbT, cb);
				if (!FWriteCbIDAT(rgb+cb, cbT))
					return false;

				w -= cbT;
				if (w <= 0)
					return true;

				pbThis += cbT;
				pbPrev += cbT;

				/* Reset the first cb bytes of the buffer. */
				memcpy(rgb, pbThis-cb, cb);
				}
			}

	case PNGFPaeth:
		/* On the first line Paeth reduces to Sub because the predictor
			is equal to the value to the left. */
		if (pbPrev != NULL)
			{
			/* The first cb bytes have no values to the left or above
				left, so the predictor is the value above and we need
				only subtract the previous row. */
			SPNGassert(cb <= w);

			memcpy(rgb, pbThis, cb);
			FnPNGFUp(rgb, pbPrev, cb);
			pbThis += cb;
			pbPrev += cb;
			w -= cb;
			if (!FWriteCbIDAT(rgb, cb))
				return false;

			/* Now handle the main block. */
			if (w > 0) for (;;)
				{
				SPNG_U32 cbT(w);
				if (cbT > CBBUFFER-cb)
					cbT = CBBUFFER-cb;

				/* Make a copy then filter, for this filter the preceding
					cb bytes are required in the buffer. */
				memcpy(rgb, pbThis-cb, cbT+cb);
				FnPNGFPaeth(rgb+cb, pbPrev, cbT, cb);
				if (!FWriteCbIDAT(rgb+cb, cbT))
					return false;

				w -= cbT;
				if (w <= 0)
					return true;

				pbThis += cbT;
				pbPrev += cbT;
				}
			}
		/* Else fall through. */

	case PNGFSub:
		/* If there are <=cb bytes then no filtering is possible. */
		if (w <= cb)
			break;

		for (SPNG_U32 iinc(0);;)
			{
			SPNG_U32 cbT(w);
			if (cbT > CBBUFFER-iinc)
				cbT = CBBUFFER-iinc;

			/* Make a copy then filter, for this filter the preceding
				cb bytes are required in the buffer. */
			memcpy(rgb, pbThis-iinc, cbT+iinc);
			FnPNGFSub(rgb+cb, cbT+iinc-cb, cb);
			if (!FWriteCbIDAT(rgb+iinc, cbT))
				return false;

			w -= cbT;
			if (w <= 0)
				return true;

			iinc = cb;
			pbThis += cbT;
			}
		}

	/* If we get to here we actually need to just dump the w bytes at
		pbThis. */
	return FWriteCbIDAT(pbThis, w);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwriteinternal.h ===
#pragma once
#define SPNGWRITEINTERNAL_H 1
/*****************************************************************************
	spngwriteinternal.h

	Internal definitions used by writing implementations but not otherwise
	required.
*****************************************************************************/
/*****************************************************************************
	Inline code to do output.
*****************************************************************************/
/*----------------------------------------------------------------------------
	Output one byte, may call FFlush.
----------------------------------------------------------------------------*/
inline bool SPNGWRITE::FOutB(SPNG_U8 b)
	{
	SPNGassert(m_cbOut < sizeof m_rgb);
	m_rgb[m_cbOut++] = b;

	if (m_cbOut < sizeof m_rgb)
		return true;

	return FFlush();
	}


/*----------------------------------------------------------------------------
	Output a single u32 value, may call FFlush, this could call FOutCb, but I
	think this will be more efficient and it is used frequently.
----------------------------------------------------------------------------*/
inline bool SPNGWRITE::FOut32(SPNG_U32 u)
	{
	/* The PNG byte order is big endian, optimize the common case. */
	if (m_cbOut+4 >= sizeof m_rgb)
		return FOut32_(u);

	m_rgb[m_cbOut++] = SPNG_U8(u >> 24);
	m_rgb[m_cbOut++] = SPNG_U8(u >> 16);
	m_rgb[m_cbOut++] = SPNG_U8(u >>  8);
	m_rgb[m_cbOut++] = SPNG_U8(u);
	return true;
	}


/*----------------------------------------------------------------------------
	Output some bytes, may call FFlush.
----------------------------------------------------------------------------*/
inline bool SPNGWRITE::FOutCb(const SPNG_U8 *pb, SPNG_U32 cb)
	{
	for (;;)
		{
		if (cb <= 0)
			{
			SPNGassert(cb == 0);
			return true;
			}

		SPNG_U32 cbT(cb);
		if (m_cbOut+cbT >= sizeof m_rgb)
			cbT = (sizeof m_rgb)-m_cbOut;

		/* Empty initial buffer will cause this to be 0. */
		memcpy(m_rgb+m_cbOut, pb, cbT);
		m_cbOut += cbT;

		if (m_cbOut < sizeof m_rgb)
			{
			SPNGassert(cb == cbT);
			return true;
			}

		if (!FFlush())
			return false;

		cb -= cbT;
		pb += cbT;
		}
	}


/*----------------------------------------------------------------------------
	ILog2FloorX - a power of 2 such that 1<<power is no larger than x.
	Returns 0 for both 0 and 1.
----------------------------------------------------------------------------*/
inline int ILog2FloorX(SPNG_U32 x) {
	int i(0);
	if (x & 0xffff0000) x >>= 16, i += 16;
	if (x &		0xff00) x >>=	8, i +=	8;
	if (x &		  0xf0) x >>=	4, i +=	4;
	if (x &			0xc) x >>=	2, i +=	2;
	if (x &			0x2) x >>=	1, i +=	1;
	return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritegama.cpp ===
/*****************************************************************************
	spngwritegAMA.cpp

	PNG chunk writing support.

   gAMA chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

bool SPNGWRITE::FWritegAMA(SPNG_U32 ugAMA)
	{
	if (ugAMA == 0)
		ugAMA = sRGBgamma;

	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordergAMA);

	if (m_order >= spngorderPLTE)
		return true;

	if (!FStartChunk(4, PNGgAMA))
		return false;
	if (!FOut32(ugAMA))
		return false;
	if (!FEndChunk())
		return false;

	m_order = spngordergAMA;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritechunk.cpp ===
/*****************************************************************************
	spngwritechunk.cpp

	PNG support code and interface implementation (writing chunks - base
	support)
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"


/*****************************************************************************
	BASIC CHUNK SUPPORT
*****************************************************************************/
/*----------------------------------------------------------------------------
	Flush the buffer - it need not be full!
----------------------------------------------------------------------------*/
bool SPNGWRITE::FFlush(void)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_cbOut <= sizeof m_rgb);

	/* If we are within a chunk then the CRC must be updated. */
	if (m_fInChunk && m_ichunk < m_cbOut)
		{
		SPNGassert(m_ichunk >= 0);
		m_ucrc = crc32(m_ucrc, m_rgb+m_ichunk, m_cbOut-m_ichunk);
		m_ichunk = m_cbOut;
		}

	if (!m_bms.FWrite(m_rgb, m_cbOut))
		return false;

	m_cbOut = m_ichunk = 0;
	return true;
	}


/*----------------------------------------------------------------------------
	Output a single u32 value, may call FFlush, this could call FOutCb, but I
	think this will be more efficient and it is used frequently.  This is the
	out of line version called when a flush call is possible.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FOut32_(SPNG_U32 u)
	{
	if (!FOutB(SPNG_U8(u >> 24)))
		return false;
	if (!FOutB(SPNG_U8(u >> 16)))
		return false;
	if (!FOutB(SPNG_U8(u >>  8)))
		return false;
	return FOutB(SPNG_U8(u));
	}


/*----------------------------------------------------------------------------
	Start a chunk, including initializing the CRC buffer.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FStartChunk(SPNG_U32 ulen, SPNG_U32 uchunk)
	{
	SPNGassert(m_fStarted && !m_fInChunk);

	/* The length is not in the CRC, so output it before
		setting m_fInChunk. */
	if (!FOut32(ulen))
		return false;
	m_fInChunk = true;
	m_ucrc = 0;
	m_ichunk = m_cbOut;
	return FOut32(uchunk);
	}


/*----------------------------------------------------------------------------
	End the chunk, producing the CRC.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FEndChunk(void)
	{
	SPNGassert(m_fStarted && m_fInChunk);
	m_fInChunk = false;
	if (m_ichunk < m_cbOut)
		{
		SPNGassert(m_ichunk >= 0);
		m_ucrc = crc32(m_ucrc, m_rgb+m_ichunk, m_cbOut-m_ichunk);
		m_ichunk = m_cbOut;
		}
	return FOut32(m_ucrc);
	}


/*----------------------------------------------------------------------------
	Write a totally arbitrary chunk.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWriteChunk(SPNG_U32 uchunk, const SPNG_U8 *pbData,
	size_t cbData)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIEND);

	/* There is no real ordering requirement on this chunk so the code will
		actually accept it anywhere. */
	if (!FStartChunk(cbData, uchunk))
		return false;
	if (cbData > 0 && !FOutCb(pbData, cbData))
		return false;
	return FEndChunk();
	}


/*----------------------------------------------------------------------------
	Public API to write chunks in pieces.  The chunk is terminated with a 0
	length write, the ulen must be given to every call and must be the complete
	length! The CRC need only be provided on the last (0 length) call, it
	overrides the passed in CRC.  An assert will be produced if there is a CRC
	mismatch but the old CRC is still output.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWriteChunkPart(SPNG_U32 ulen, SPNG_U32 uchunk,
	const SPNG_U8 *pbData, size_t cbData, SPNG_U32 ucrc)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIEND);

	/* Unknown ordering requirement... */
	if (!m_fInChunk && !FStartChunk(ulen, uchunk))
		return false;

	if (cbData > 0)
		return FOutCb(pbData, cbData);
	else
		{
		/* This is FEndChunk but outputing the old crc! */
		SPNGassert(m_fStarted && m_fInChunk);
		m_fInChunk = false;
		if (m_ichunk < m_cbOut)
			{
			SPNGassert(m_ichunk >= 0);
			m_ucrc = crc32(m_ucrc, m_rgb+m_ichunk, m_cbOut-m_ichunk);
			m_ichunk = m_cbOut;
			}
		SPNGassert2(m_ucrc == ucrc, "SPNG: chunk copy CRC mismatch (%d,%d)",
			m_ucrc, ucrc);
		/* Retain the old CRC to ensure that the recipient of this PNG
			knows the the data is damaged. */
		return FOut32(ucrc);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritegifx.cpp ===
/*****************************************************************************
	spngwritegifx.cpp

	PNG chunk writing support.

   gIFx chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Write a GIF application extension block.  The input to this is a sequence
	of GIF blocks following the GIF89a spec and, as a consequence, the first
	byte should normally be the value 11.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritegIFx(const SPNG_U8* pbBlocks, size_t cbData)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIEND);

	/* We don't actually care if the block has some other size, but I want to
		know when this happens. */
	SPNGassert(pbBlocks[0] == 11);

	/* There is no real ordering requirement on this chunk so the code will
		actually accept it anywhere, need to find the total length first. */
	int cb(0), cbT(cbData);
	const SPNG_U8* pbT = pbBlocks;
	for (;;)
		{
		if (--cbT < 0)
			break;
		SPNG_U8 b(*pbT++);
		if (b == 0 || b > cbT)
			break;
		pbT += b;
		cbT -= b;
		cb  += b;
		}

	if (!FStartChunk(cb, PNGgIFx))
		return false;
	if (cb > 0)
		{
		cbT = cbData;
		pbT = pbBlocks;
		for (;;)
			{
			if (--cbT < 0)
				break;
			SPNG_U8 b(*pbT++);
			if (b == 0 || b > cbT)
				break;
			if (!FOutCb(pbT, b))
				return false;
			pbT += b;
			cbT -= b;
			#if DEBUG || _DEBUG
				cb  -= b;
			#endif
			}
		SPNGassert(cb == 0);
		}

	return FEndChunk();
	}


/*----------------------------------------------------------------------------
	Write a GIF Graphic Control Extension "extra information" chunk.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritegIFg(SPNG_U8 bDisposal, SPNG_U8 bfUser,
	SPNG_U16 uDelayTime)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIDAT);

	/* Handle the default by doing nothing. */
	if (bDisposal == 0 && bfUser == 0 && uDelayTime == 0)
		return true;

	if (!FStartChunk(4, PNGgIFg))
		return false;
	if (!FOutB(bDisposal))
		return false;
	if (!FOutB(bfUser != 0))
		return false;
	if (!FOutB(SPNG_U8(uDelayTime >> 8)))
		return false;
	if (!FOutB(SPNG_U8(uDelayTime)))
		return false;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwriteicc.cpp ===
/*****************************************************************************
	spngwriteiCC.cpp

	PNG chunk writing support.

   iCCP chunk and related things
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"
#include "spngcolorimetry.h"
#include "spngicc.h"

bool SPNGWRITE::FWriteiCCP(const char *szName, const void *pvData, size_t cbData)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderiCCP);

	/* Do some basic validity checks on the ICC chunk and make sure the cbData
		value is correct. */
	if (!SPNGFValidICC(pvData, cbData, true/*for PNG*/))
		{
		SPNGlog2("SPNG: ICC[%d, %s]: invalid profile", cbData, szName);
		if (m_order < spngorderPLTE)
			m_order = spngorderiCCP;
		return true;
		}

	if (m_order >= spngorderPLTE)
		return true;

	/* Get the profile name string if not supplied. */
	char rgch[80];
	if (szName == NULL && SPNGFICCProfileName(pvData, cbData, rgch))
		szName = rgch;
	if (szName == NULL)
		szName = "";

	int cbName(strlen(szName));
	if (cbName > 79)
		{
		SPNGlog2("SPNG: iCCP name too long (%d): %s", cbName, szName);
		m_order = spngorderiCCP;
		return true;
		}

	/* If they haven't been produced yet try to produce the gAMA chunk and,
		where appropriate, the cHRM chunk. */
	if (m_order < spngordergAMA)
		{
		SPNG_U32 ugAMA(0);
		if (SPNGFgAMAFromICC(pvData, cbData, ugAMA) && ugAMA > 0 &&
			!FWritegAMA(ugAMA))
			return false;
		}

	if (m_order < spngordercHRM && (m_colortype & PNGColorMaskColor) != 0)
		{
		SPNG_U32 rgu[8];
		if (SPNGFcHRMFromICC(pvData, cbData, rgu) &&
			!FWritecHRM(rgu))
			return false;
		}

	/* Find the compressed size of the profile. */
	z_stream zs;
	CleanZlib(&zs);
 
	/* Use a temporary, on stack, buffer - most of the time this will be enough,
		supply the data as the input, we do *not* want Zlib to have to allocate
		it's own history buffer, but it does do so at present. */
	zs.next_out = Z_NULL;
	zs.avail_out = 0;
	zs.next_in = const_cast<SPNG_U8*>(static_cast<const SPNG_U8*>(pvData));
	zs.avail_in = cbData;

	/* Find the window bits size - don't give a bigger number than the number
		required by the data size, unless it is 8.  There is an initial code
		table of 256 entries on the data, so this limits us to 8. */
	int iwindowBits(ILog2FloorX(cbData+256));
	if ((1U<<iwindowBits) < cbData+256)
		++iwindowBits;
	SPNGassert((1U<<iwindowBits) >= cbData+256 && iwindowBits >= 8);

	if (iwindowBits < 8)
		iwindowBits = 8;
	else if (iwindowBits > MAX_WBITS)
		iwindowBits = MAX_WBITS;

	bool fOK(false);
	if (FCheckZlib(deflateInit2(&zs, 9/*maximum*/, Z_DEFLATED, iwindowBits,
		9/*memLevel*/, Z_DEFAULT_STRATEGY)))
		{
		int  cbZ(0), ierr, icount(0);
		SPNG_U8 rgb[4096];

		do {
			++icount;
			zs.next_out = rgb;
			zs.avail_out = sizeof rgb;
			ierr = deflate(&zs, Z_FINISH);
			cbZ += (sizeof rgb) - zs.avail_out;
			}
		while (ierr == Z_OK);

		/* At this point ierr indicates the error state, icount whether
			we need to recompress a second time. */
		if (ierr == Z_STREAM_END)
			{
			fOK = true;

			if (!FStartChunk(cbName+2+cbZ, PNGiCCP))
				fOK = false;
			else if (!FOutCb(reinterpret_cast<const SPNG_U8*>(szName), cbName+1))
				fOK = false;
			else if (!FOutB(0)) // deflate compression
				fOK = false;
			else if (icount == 1)
				{
				if (!FOutCb(rgb, cbZ))
					fOK = false;
				}
			else if (FCheckZlib(ierr = deflateReset(&zs)))
				{
				/* We must repeat the compression. */
				int cbZT(0);
				do {
					--icount;
					zs.next_out = rgb;
					zs.avail_out = sizeof rgb;
					ierr = deflate(&zs, Z_FINISH);
					if (ierr >= 0)
						{
						int cbT((sizeof rgb) - zs.avail_out);
						SPNGassert(cbZT + cbT <= cbZ);
						if (cbZT + cbT > cbZ) // Oops
							fOK = false;
						else if (!FOutCb(rgb, cbT))
							fOK = false;
						else
							cbZT += cbT;
						}
					}
				while (fOK && ierr == Z_OK);

				/* Either an error or we reached the end. */
				SPNGassert(!fOK || ierr < 0 || icount == 0 && cbZT == cbZ);
				if (cbZT != cbZ)
					fOK = false;
				}

			if (ierr != Z_STREAM_END)
				fOK = false;
			}
		}

	/* Regardless of error state remove the deflate data. */
	(void)deflateEnd(&zs);

	/* Exit now on error. */
	if (!fOK)
		return false;

	if (!FEndChunk())
		return false;

	m_order = spngorderiCCP;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritemso.cpp ===
/*****************************************************************************
	spngwritemso.cpp

	PNG chunk writing support.

   MSO chunks (msO?) chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Write an Office Art chunk.  The API just takes the data and puts the right
	header and CRC in.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritemsO(SPNG_U8 bType, const SPNG_U8 *pbData, size_t cbData)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIEND);

	/* There is no real ordering requirement on this chunk so the code will
		actually accept it anywhere. */
	if (!FStartChunk(cbPNGMSOSignature+cbData, PNGmsO(bType)))
		return false;
	if (!FOutCb(vrgbPNGMSOSignature, cbPNGMSOSignature))
		return false;
	if (cbData > 0 && !FOutCb(pbData, cbData))
		return false;

	return FEndChunk();
	}


bool SPNGWRITE::FWritemsOC(SPNG_U8 bImportant)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordercHRM);

	if (m_order >= spngorderPLTE)
		return true;

	if (!FStartChunk(8, PNGmsOC))
		return false;
	SPNG_U8 rgb[8] = "MSO aac";
	rgb[7] = bImportant;
	if (!FOutCb(rgb, 8))
		return false;
	if (!FEndChunk())
		return false;

	m_order = spngordermsOC;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwriteplte.cpp ===
/*****************************************************************************
	spngwriteplte.cpp

	PNG chunk writing support.

   PLTE chunk (palette)
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

bool SPNGWRITE::FWritePLTE(const SPNG_U8 (*pbPal)[3], int cbPal)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderPLTE);

	if (m_colortype != 3 && m_colortype != 2 && m_colortype != 6)
		{
		SPNGlog1("SPNG: %d colortype cannot have PLTE", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngorderPLTE;
		return true;
		}
	
	/* Color type is valid, write the chunk. */
	if (!FStartChunk(cbPal * 3, PNGPLTE))
		return false;
	if (!FOutCb(pbPal[0], cbPal * 3))
		return false;

	m_order = spngorderPLTE;
	m_cpal = cbPal;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritephys.cpp ===
/*****************************************************************************
	spngwritephys.cpp

	PNG chunk writing support.

   pHYs chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Physical information - always pixels per metre or "unknown".
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritepHYs(SPNG_U32 x, SPNG_U32 y, bool fUnitIsMetre)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderpHYs);

	/* Skip out of order chunks. */
	if (m_order >= spngorderIDAT)
		return true;

	if (!FStartChunk(9, PNGpHYs))
		return false;
	if (!FOut32(x))
		return false;
	if (!FOut32(y))
		return false;
	if (!FOutB(fUnitIsMetre))
		return false;

	m_order = spngorderpHYs;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritesbit.cpp ===
/*****************************************************************************
	spngwritesbit.cpp

	PNG chunk writing support.

   sBIT chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Significant bit information is output right at the start - in fact this
	differs from the pnglib order where it may be preceded by gAMA but this
	positioning is more convenient because of the sRGB handling below.  Supply
	grey values in r g and b.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritesBIT(SPNG_U8 r, SPNG_U8 g, SPNG_U8 b, SPNG_U8 a)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordersBIT);

	/* Skip out of order chunks. */
	if (m_order >= spngorderPLTE)
		return true;

	/* Double check color values. */
	SPNG_U8 bDepth;
	if (m_colortype == 3)
		bDepth = 8;
	else
		bDepth = m_bDepth;

	/* Check the "grey/green" value, which is always used. */
	if (g > bDepth || g == 0)
		{
		SPNGlog2("SPNG: sBIT green: %d too big (%d)", g, bDepth);
		g = bDepth;
		}

	SPNG_U8 rgba[4];
	bool    fSignificant(g < bDepth);
	rgba[(m_colortype & 2)>>1] = g;

	/* For color cases check r and b too. */
	int cb(1);
	if (m_colortype & 2)
		{
		cb += 2;
		if (r > bDepth || r == 0)
			{
			SPNGlog2("SPNG: sBIT color: red %d too big (%d)", r, bDepth);
			r = bDepth;
			}
		rgba[0] = r;
		if (r < bDepth)
			fSignificant = true;

		if (b > bDepth || b == 0)
			{
			SPNGlog2("SPNG: sBIT color: blue %d too big (%d)", b, bDepth);
			b = bDepth;
			}
		rgba[2] = b;
		if (b < bDepth)
			fSignificant = true;
		}

	/* For alpha check the alpha value... */
	if (m_colortype & 4)
		{
		++cb;
		SPNGassert(m_colortype == 4 || m_colortype == 6);
		if (a > bDepth || a == 0)
			{
			SPNGlog2("SPNG: sBIT alpha: alpha %d too big (%d)", a, bDepth);
			a = bDepth;
			}
		rgba[(m_colortype & 2) + 1] = a;
		if (a < bDepth)
			fSignificant = true;
		}

	/* If the sBIT chunk is not saying anything don't write it. */
	if (!fSignificant)
		return true;

	if (!FStartChunk(cb, PNGsBIT))
		return false;
	if (!FOutCb(rgba, cb))
		return false;
	if (!FEndChunk())
		return false;

	m_order = spngordersBIT;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritesrgb.cpp ===
/*****************************************************************************
	spngwritesrgb.cpp

	PNG chunk writing support.

   sRGB chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	When the sRGB chunk is written cHRM and gAMA will be automatically
	generated.  The imatch value may be out of range (-1) to cause the
	data type information to be used to determine the rendering intent.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritesRGB(SPNGICMRENDERINGINTENT intent, bool fgcToo)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordersRGB);

	/* Skip the chunk if out of order - it is not necessary to return false here,
		the code tries to ensure that an sRGB is not written after a cHRM or
		gAMA. */
	if (m_order >= spngordersRGB)
		return true;

	/* We actually check for the valid value here - not the enum. */
	if (intent < 0 || intent > 3)
		{
		SPNGassert(intent == ICMIntentUseDatatype);
		switch (m_datatype)
			{
		default:
			SPNGlog1("SPNG: invalid data type %d", m_datatype);
		case SPNGUnknown:        // Data could be anything
			/* Default to "perceptual". */
		case SPNGPhotographic:   // Data is photographic in nature
			intent = ICMIntentPerceptual;
			break;

		case SPNGCG:             // Data is computer generated but continuous tone
			/* At present assume perceptual matching is appropriate here. */
			intent = ICMIntentPerceptual;
			break;

		case SPNGDrawing:        // Data is a drawing - restricted colors
		case SPNGMixed:          // Data is mixed SPNGDrawing and SPNGCG
			intent = ICMIntentSaturation;
			break;
			}
		}

	if (!FStartChunk(1, PNGsRGB))
		return false;
	if (!FOutB(SPNG_U8(intent)))
		return false;
	if (!FEndChunk())
		return false;

	if (fgcToo)
		{
		if (!FWritegAMA(0))
			return false;

		/* Errors here are hard because we don't know why they happened. */
		if (!FWritecHRM(NULL/*Rec 709*/))
			return false;
		}

	m_order = spngordersRGB;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritetext.cpp ===
/*****************************************************************************
	spngwritetext.cpp

	PNG chunk writing support.

   tEXt chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Text chunk handling, uses wide strings.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritetEXt(const char *szKey, const char *szValue)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngorderIEND);

	/* Check the keyword length - cannot exceed 79 characters. */
	int cb(strlen(szKey));
	if (cb > 79)
		{
		SPNGlog2("SPNG: tEXt key too long (%d): %s", cb, szKey);
		return true;
		}
	int cbValue(strlen(szValue));

	if (!FStartChunk(cb+1+cbValue, PNGtEXt))
		return false;
	if (!FOutCb(reinterpret_cast<const SPNG_U8*>(szKey), cb+1))
		return false;
	if (!FOutCb(reinterpret_cast<const SPNG_U8*>(szValue), cbValue))
		return false;

	/* This can occur anywhere, so do not set the order. */
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritetime.cpp ===
/*****************************************************************************
	spngwritetime.cpp

	PNG chunk writing support.

   tIME chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"

/*----------------------------------------------------------------------------
	Timing information - either the current time or a time in seconds, 0
	means "now".
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWritetIME(const SPNG_U8 rgbTime[7])
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordertIME);

	if (!FStartChunk(7, PNGtIME))
		return false;
	if (!FOutCb(rgbTime, 7))
		return false;

	m_order = spngordertIME;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritetrns.cpp ===
/*****************************************************************************
	spngwritetrns.cpp

	PNG chunk writing support.

   tRNS chunk
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"


bool SPNGWRITE::FWritetRNS(SPNG_U8 *rgbIndex, int cIndex)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderPLTE && m_order < spngordertRNS);

	/* Skip out of order chunks. */
	if (m_order < spngorderPLTE || m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 3)
		{
		SPNGlog1("SPNG: tRNS(index): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngordertRNS;
		return true;
		}

	if (cIndex <= 0)
		{
		m_order = spngordertRNS;
		return true;
		}

	/* This used to write out the chunk, but at is bad news because the
		PNG which results is invalid, so we must truncate the chunk. */
	if (static_cast<SPNG_U32>(cIndex) > m_cpal)
		{
		SPNGlog2("SPNG: tRNS(index): too large (%d, %d entries)", cIndex, m_cpal);
		cIndex = m_cpal;
		// Check for an empty chunk
		for (int i=0; i<cIndex; ++i)
			if (rgbIndex[i] != 255)
				break;
		if (i == cIndex)
			{
			m_order = spngordertRNS;
			return true;
			}
		}
	
	/* Color type is valid, write the chunk. */
	if (!FStartChunk(cIndex, PNGtRNS))
		return false;
	if (!FOutCb(rgbIndex, cIndex))
		return false;

	m_order = spngordertRNS;
	return FEndChunk();
	}


bool SPNGWRITE::FWritetRNS(SPNG_U8 bIndex)
	{
	if (bIndex >= m_cpal || bIndex > 255)
		{
		SPNGlog2("SPNG: tRNS(index): index %d too large (%d)", bIndex, m_cpal);
		/* But ignore it. */
		return true;
		}

	SPNG_U8 rgb[256];
	memset(rgb, 255, sizeof rgb);
	rgb[bIndex] = 0;
	return FWritetRNS(rgb, bIndex+1);
	}


bool SPNGWRITE::FWritetRNS(SPNG_U16 grey)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordertRNS);

	/* Skip out of order chunks. */
	if (m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 0)
		{
		SPNGlog1("SPNG: tRNS(grey): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngordertRNS;
		return true;
		}

	/* There is no point writing the chunk if the value is out of range. */
	if (grey >= (1<<m_bDepth))
		{
		SPNGlog2("SPNG: tRNS(grey): %d out of range (%d bits)", grey, m_bDepth);
		m_order = spngordertRNS;
		return true;
		}

	/* Color type is valid, write the chunk. */
	if (!FStartChunk(2, PNGtRNS))
		return false;
	if (!FOutB(SPNG_U8(grey >> 8)))
		return false;
	if (!FOutB(SPNG_U8(grey)))
		return false;

	m_order = spngordertRNS;
	return FEndChunk();
	}


bool SPNGWRITE::FWritetRNS(SPNG_U16 r, SPNG_U16 g, SPNG_U16 b)
	{
	SPNGassert(m_fStarted);
	SPNGassert(m_order >= spngorderIHDR && m_order < spngordertRNS);

	/* Skip out of order chunks. */
	if (m_order >= spngorderIDAT)
		return true;

	if (m_colortype != 2)
		{
		SPNGlog1("SPNG: tRNS(color): invalid colortype %d", m_colortype);
		/* We just ignore the attempt to write a PLTE - if there is some data
			format error it will be detected later. */
		m_order = spngordertRNS;
		return true;
		}
	
	/* There is no point writing the chunk if the value is out of range. */
	if (r >= (1<<m_bDepth) || g >= (1<<m_bDepth) || b >= (1<<m_bDepth))
		{
		SPNGlog1("SPNG: tRNS(r,g,b): out of range (%d bits)", m_bDepth);
		m_order = spngordertRNS;
		return true;
		}

	/* Color type is valid, write the chunk. */
	if (!FStartChunk(6, PNGtRNS))
		return false;
	if (!FOutB(SPNG_U8(r >> 8)))
		return false;
	if (!FOutB(SPNG_U8(r)))
		return false;
	if (!FOutB(SPNG_U8(g >> 8)))
		return false;
	if (!FOutB(SPNG_U8(g)))
		return false;
	if (!FOutB(SPNG_U8(b >> 8)))
		return false;
	if (!FOutB(SPNG_U8(b)))
		return false;

	m_order = spngordertRNS;
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\upmmxdefilter.cpp ===
/*******************************************************************************

SPNGREAD::upMMXUnfilter : unfilters one row of a decompressed PNG image using
						   the UP algorithm of method 0 defiltering.

  Assumptions:	The row to be defiltered was filtered with the UP algorithm
				Row is 8-byte aligned in memory (performance issue)
				First byte of a row stores the defiltering code
				The indicated length of the row includes the defiltering byte

  Algorithm:	To Be Documented

*******************************************************************************/
#include <stdlib.h>
#include "spngread.h"

void SPNGREAD::upMMXUnfilter(SPNG_U8* pbRow, const SPNG_U8* pbPrev, SPNG_U32 cbRow)
{
#if defined(_X86_)
        SPNG_U8 *row = pbRow;
        const SPNG_U8 *prev_row = pbPrev;
        SPNG_U32 len = cbRow;       // # of bytes to filter

		_asm {
		    mov edi, row
         // get # of bytes to alignment
            mov ecx, edi
            xor ebx, ebx
            add ecx, 0x7
            xor eax, eax
            and ecx, 0xfffffff8
            mov esi, prev_row
            sub ecx, edi
            jz dupgo

         // fix alignment
duplp1:
			mov al, [edi+ebx]
			add al, [esi+ebx]

			inc ebx
			cmp ebx, ecx
			mov [edi + ebx-1], al       // mov does not affect flags; 
                                        // -1 to offset inc ebx
			jb duplp1

dupgo:
			 mov ecx, len
             mov edx, ecx
             sub edx, ebx                  // subtract alignment fix
             and edx, 0x0000003f           // calc bytes over mult of 64
             sub ecx, edx                  // drop over bytes from length

         // Unrolled loop - use all MMX registers and interleave to reduce
         // number of branch instructions (loops) and reduce partial stalls
duploop:
			movq mm1, [esi+ebx]
			movq mm0, [edi+ebx]
		    movq mm3, [esi+ebx+8]
			paddb mm0, mm1
		    movq mm2, [edi+ebx+8]
			movq [edi+ebx], mm0

		    paddb mm2, mm3
			movq mm5, [esi+ebx+16]
		    movq [edi+ebx+8], mm2

			movq mm4, [edi+ebx+16]
			movq mm7, [esi+ebx+24]
			paddb mm4, mm5
			movq mm6, [edi+ebx+24]
			movq [edi+ebx+16], mm4

			paddb mm6, mm7
			movq mm1, [esi+ebx+32]
			movq [edi+ebx+24], mm6

			movq mm0, [edi+ebx+32]
			movq mm3, [esi+ebx+40]
			paddb mm0, mm1
			movq mm2, [edi+ebx+40]
			movq [edi+ebx+32], mm0

			paddb mm2, mm3
			movq mm5, [esi+ebx+48]
			movq [edi+ebx+40], mm2

			movq mm4, [edi+ebx+48]
			movq mm7, [esi+ebx+56]
			paddb mm4, mm5
			movq mm6, [edi+ebx+56]
			movq [edi+ebx+48], mm4

            add ebx, 64
			paddb mm6, mm7

			cmp ebx, ecx
			         movq [edi+ebx-8], mm6// (+56)movq does not affect flags; -8 to offset add ebx

			jb duploop

         
			cmp edx, 0                    // Test for bytes over mult of 64
			jz dupend

         add ecx, edx

         and edx, 0x00000007           // calc bytes over mult of 8
         sub ecx, edx                  // drop over bytes from length
		 cmp ebx, ecx
			jnb duplt8

         // Loop using MMX registers mm0 & mm1 to update 8 bytes simultaneously
duplpA:
			movq mm1, [esi+ebx]
			movq mm0, [edi+ebx]
			add ebx, 8
			paddb mm0, mm1

			cmp ebx, ecx
			movq [edi+ebx-8], mm0         // movq does not affect flags; -8 to offset add ebx
			jb duplpA

			cmp edx, 0                    // Test for bytes over mult of 8
			jz dupend

duplt8:
         xor eax, eax
			add ecx, edx                  // move over byte count into counter

         // Loop using x86 registers to update remaining bytes
duplp2:
			mov al, [edi + ebx]
			add al, [esi + ebx]

			inc ebx
			cmp ebx, ecx
			mov [edi + ebx-1], al         // mov does not affect flags; -1 to offset inc ebx
			jb duplp2

dupend:
         // Conversion of filtered row completed 
			emms                          // End MMX instructions; prep for possible FP instrs.
		} // end _asm block
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\submmxdefilter.cpp ===
/*******************************************************************************

SPNGREAD::subMMXUnfilter : unfilters one row of a decompressed PNG image using
						   the SUB algorithm of method 0 defiltering.

  Assumptions:	The row to be defiltered was filtered with the SUB algorithm
				Row is 8-byte aligned in memory (performance issue)
				First byte of a row stores the defiltering code
				The indicated length of the row includes the defiltering byte

  Algorithm:	To Be Documented

*******************************************************************************/
#include <stdlib.h>
#include "spngread.h"

void SPNGREAD::subMMXUnfilter(SPNG_U8* pbRow, SPNG_U32 cbRow, SPNG_U32 cbpp)
{
#if defined(_X86_)
	union uAll
		{
		__int64 use;
		double  align;
		}
	sActiveMask, sShiftBpp, sShiftRem;

        SPNG_U8 *row = pbRow;
	    SPNG_U32 FullLength;
		SPNG_U32 MMXLength;
		int diff;
        int bpp;

        bpp = (cbpp + 7) >> 3; // Get # bytes per pixel
		FullLength  = cbRow - bpp; // # of bytes to filter

		_asm {
			mov edi, row               
			mov esi, edi               // lp = row
            add edi, bpp               // rp = row + bpp

            xor eax, eax

            // get # of bytes to alignment
            mov diff, edi          // take start of row
            add diff, 0xf          // add 7 + 8 to incr past alignment boundary
            xor ebx, ebx
            and diff, 0xfffffff8   // mask to alignment boundary
            sub diff, edi          // subtract from start ==> value ebx at alignment
            jz dsubgo

            // fix alignment
dsublp1:
			   mov al, [esi+ebx]
			   add [edi+ebx], al
		      inc ebx
		      cmp ebx, diff
			   jb dsublp1

dsubgo:
			   mov ecx, FullLength
            mov edx, ecx
            sub edx, ebx                  // subtract alignment fix
            and edx, 0x00000007           // calc bytes over mult of 8
            sub ecx, edx                  // drop over bytes from length
            mov MMXLength, ecx
   	} // end _asm block


      // Now do the math for the rest of the row
      switch ( bpp )
      {
      case 3:
		{
         sActiveMask.use  = 0x0000ffffff000000;  
         sShiftBpp.use = 24;          // == 3 * 8
         sShiftRem.use  = 40;          // == 64 - 24

			_asm {
            mov edi, row               
            movq mm7, sActiveMask       // Load sActiveMask for 2nd active byte group
				mov esi, edi               // lp = row
            add edi, bpp               // rp = row + bpp

            movq mm6, mm7
            mov ebx, diff
            psllq mm6, sShiftBpp      // Move mask in mm6 to cover 3rd active byte group

            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]      
dsub3lp:
            psrlq mm1, sShiftRem       // Shift data for adding 1st bpp bytes
                                       // no need for mask; shift clears inactive bytes
            // Add 1st active group
            movq mm0, [edi+ebx]
				paddb mm0, mm1

            // Add 2nd active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
            pand mm1, mm7              // mask to use only 2nd active group
				paddb mm0, mm1             

            // Add 3rd active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
            pand mm1, mm6              // mask to use only 3rd active group
				add ebx, 8
				paddb mm0, mm1             

				cmp ebx, MMXLength
				movq [edi+ebx-8], mm0        // Write updated Raws back to array
            // Prep for doing 1st add at top of loop
            movq mm1, mm0
				jb dsub3lp

			} // end _asm block
      }
      break;

      case 1:
		{
			/* Placed here just in case this is a duplicate of the
			non-MMX code for the SUB filter in png_read_filter_row above
			*/
//         png_bytep rp;
//         png_bytep lp;
//         png_uint_32 i;

//         bpp = (row_info->pixel_depth + 7) >> 3;
//         for (i = (png_uint_32)bpp, rp = row + bpp, lp = row;
//            i < row_info->rowbytes; i++, rp++, lp++)
//			{
//            *rp = (png_byte)(((int)(*rp) + (int)(*lp)) & 0xff);
//			}
			_asm {
            mov ebx, diff
            mov edi, row               
				cmp ebx, FullLength
				jnb dsub1end
				mov esi, edi               // lp = row
				xor eax, eax
            add edi, bpp               // rp = row + bpp

dsub1lp:
				mov al, [esi+ebx]
				add [edi+ebx], al
		      inc ebx
		      cmp ebx, FullLength
				jb dsub1lp

dsub1end:
			} // end _asm block
		}
      return;

      case 6:
      case 7:
      case 4:
      case 5:
		{
         sShiftBpp.use = bpp << 3;
         sShiftRem.use = 64 - sShiftBpp.use;

			_asm {
            mov edi, row               
            mov ebx, diff
				mov esi, edi               // lp = row
            add edi, bpp               // rp = row + bpp

            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]      
dsub4lp:
            psrlq mm1, sShiftRem       // Shift data for adding 1st bpp bytes
                                       // no need for mask; shift clears inactive bytes
				movq mm0, [edi+ebx]
				paddb mm0, mm1

            // Add 2nd active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
                                       // there is no need for any mask
                                       // since shift clears inactive bits/bytes

				add ebx, 8
				paddb mm0, mm1             

				cmp ebx, MMXLength
				movq [edi+ebx-8], mm0
            movq mm1, mm0              // Prep for doing 1st add at top of loop
				jb dsub4lp

			} // end _asm block
      }
      break;

      case 2:
		{
         sActiveMask.use  = 0x00000000ffff0000;  
         sShiftBpp.use = 16;          // == 2 * 8
         sShiftRem.use = 48;           // == 64 - 16

			_asm {
            movq mm7, sActiveMask       // Load sActiveMask for 2nd active byte group
            mov ebx, diff
            movq mm6, mm7
				mov edi, row               
            psllq mm6, sShiftBpp      // Move mask in mm6 to cover 3rd active byte group
				mov esi, edi               // lp = row
            movq mm5, mm6
            add edi, bpp               // rp = row + bpp

            psllq mm5, sShiftBpp      // Move mask in mm5 to cover 4th active byte group

            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]      
dsub2lp:
            // Add 1st active group
            psrlq mm1, sShiftRem       // Shift data for adding 1st bpp bytes
                                       // no need for mask; shift clears inactive bytes
            movq mm0, [edi+ebx]
				paddb mm0, mm1

            // Add 2nd active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
            pand mm1, mm7              // mask to use only 2nd active group
				paddb mm0, mm1             

            // Add 3rd active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
            pand mm1, mm6              // mask to use only 3rd active group
				paddb mm0, mm1             

            // Add 4th active group 
            movq mm1, mm0              // mov updated Raws to mm1
            psllq mm1, sShiftBpp      // shift data to position correctly
            pand mm1, mm5              // mask to use only 4th active group
				add ebx, 8
				paddb mm0, mm1             

				cmp ebx, MMXLength
				movq [edi+ebx-8], mm0        // Write updated Raws back to array
            movq mm1, mm0              // Prep for doing 1st add at top of loop
				jb dsub2lp

			} // end _asm block
      }
      break;

      case 8:
		{
			_asm {
				mov edi, row               
            mov ebx, diff
				mov esi, edi               // lp = row
            add edi, bpp               // rp = row + bpp

			   mov ecx, MMXLength
            movq mm7, [edi+ebx-8]      // PRIME the pump (load the first Raw(x-bpp) data set
            and ecx, ~0x0000003f           // calc bytes over mult of 64

dsub8lp:
				movq mm0, [edi+ebx]        // Load Sub(x) for 1st 8 bytes
				paddb mm0, mm7
               movq mm1, [edi+ebx+8]      // Load Sub(x) for 2nd 8 bytes
				movq [edi+ebx], mm0        // Write Raw(x) for 1st 8 bytes
                                       // Now mm0 will be used as Raw(x-bpp) for
                                       // the 2nd group of 8 bytes.  This will be
                                       // repeated for each group of 8 bytes with 
                                       // the 8th group being used as the Raw(x-bpp) 
                                       // for the 1st group of the next loop.

				   paddb mm1, mm0
                  movq mm2, [edi+ebx+16]      // Load Sub(x) for 3rd 8 bytes
				   movq [edi+ebx+8], mm1      // Write Raw(x) for 2nd 8 bytes

				      paddb mm2, mm1
                     movq mm3, [edi+ebx+24]      // Load Sub(x) for 4th 8 bytes
				      movq [edi+ebx+16], mm2      // Write Raw(x) for 3rd 8 bytes

				         paddb mm3, mm2
                        movq mm4, [edi+ebx+32]      // Load Sub(x) for 5th 8 bytes
				         movq [edi+ebx+24], mm3      // Write Raw(x) for 4th 8 bytes

				            paddb mm4, mm3
                           movq mm5, [edi+ebx+40]      // Load Sub(x) for 6th 8 bytes
				            movq [edi+ebx+32], mm4      // Write Raw(x) for 5th 8 bytes

				               paddb mm5, mm4
                              movq mm6, [edi+ebx+48]      // Load Sub(x) for 7th 8 bytes
				               movq [edi+ebx+40], mm5      // Write Raw(x) for 6th 8 bytes

				                  paddb mm6, mm5
                                 movq mm7, [edi+ebx+56]      // Load Sub(x) for 8th 8 bytes
				                  movq [edi+ebx+48], mm6      // Write Raw(x) for 7th 8 bytes

				add ebx, 64
				                     paddb mm7, mm6
			   cmp ebx, ecx
            				         movq [edi+ebx-8], mm7      // Write Raw(x) for 8th 8 bytes
				jb dsub8lp

				cmp ebx, MMXLength
				jnb dsub8lt8

dsub8lpA:
            movq mm0, [edi+ebx]
				add ebx, 8
				paddb mm0, mm7

				cmp ebx, MMXLength
				movq [edi+ebx-8], mm0         // use -8 to offset early add to ebx
            movq mm7, mm0                 // Move calculated Raw(x) data to mm1 to
                                          // be the new Raw(x-bpp) for the next loop
				jb dsub8lpA

dsub8lt8:
			} // end _asm block
      }
      break;

      default:                         // bpp greater than 8 bytes
		{
			_asm {
            mov ebx, diff
				mov edi, row               
				mov esi, edi               // lp = row
            add edi, bpp               // rp = row + bpp

dsubAlp:
				movq mm0, [edi+ebx]
				movq mm1, [esi+ebx]
				add ebx, 8
				paddb mm0, mm1

				cmp ebx, MMXLength
				movq [edi+ebx-8], mm0      // mov does not affect flags; -8 to offset add ebx
				jb dsubAlp

			} // end _asm block
      } 
      break;

      }                                // end switch ( bpp )

      
      _asm {
            mov ebx, MMXLength
            mov edi, row               
				cmp ebx, FullLength
				jnb dsubend
				mov esi, edi               // lp = row
				xor eax, eax
            add edi, bpp               // rp = row + bpp

dsublp2:
				mov al, [esi+ebx]
				add [edi+ebx], al
		      inc ebx
		      cmp ebx, FullLength
				jb dsublp2

dsubend:
   			emms                       // End MMX instructions; prep for possible FP instrs.
		} // end _asm block
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\png\libpng\spngwritezlib.cpp ===
/*****************************************************************************
	spngwriteimage.cpp

	PNG image writing support.

   Basic code to write a bitmap image (to IDAT chunks).
*****************************************************************************/
#define SPNG_INTERNAL 1
#include "spngwrite.h"
#include "spngwriteinternal.h"
#include "spnginternal.h"

/*****************************************************************************
	ZLIB INTERFACE
*****************************************************************************/
/*----------------------------------------------------------------------------
	Initialize the stream (call before each use).
----------------------------------------------------------------------------*/
inline bool SPNGWRITE::FInitZlib(int istrategy, int icompressionLevel,
	int iwindowBits)
	{
	SPNGassert(m_fStarted && m_fInChunk);

	if (m_fInited)
		EndZlib();

	/* There must be at least one byte available. */
	SPNGassert(m_cbOut < sizeof m_rgb);
	m_zs.next_out = PbBuffer(m_zs.avail_out);

	/* There is no input data yet, the following causes Zlib to allocate its
		own history buffer. */
	m_zs.next_in = Z_NULL;
	m_zs.avail_in = 0;

	SPNGassert(icompressionLevel <= Z_BEST_COMPRESSION);
	SPNGassert(iwindowBits >= 8 && iwindowBits <= 15);
	SPNGassert(istrategy == Z_FILTERED || istrategy == Z_HUFFMAN_ONLY ||
		istrategy == Z_DEFAULT_STRATEGY);

	m_fInited = FCheckZlib(deflateInit2(&m_zs, icompressionLevel, Z_DEFLATED,
		iwindowBits, 9/*memLevel*/, istrategy));

	if (m_fInited)
		{
		ProfZlibStart
		}
	else
		{
		/* Some memory may have been allocated. */
		(void)deflateEnd(&m_zs);
		CleanZlib(&m_zs);
		}

	return m_fInited;
	}


/*----------------------------------------------------------------------------
	Clean up the Zlib stream (call on demand, called automatically by
	destructor and FInitZlib.)
----------------------------------------------------------------------------*/
void SPNGWRITE::EndZlib()
	{
	if (m_fInited)
		{
		SPNGassert(m_fStarted && m_fInChunk);
		ProfZlibStop
		/* Always expect Zlib to end ok. */
		m_fInited = false;
#ifdef DEBUG
		int iz = 
#endif
		(deflateEnd(&m_zs));
		CleanZlib(&m_zs);
		/* The Z_DATA_ERROR case arises if the deflateEnd API is called when
			the stream has not been flushed - this happens if an error occurs
			elsewhere. */
		SPNGassert(iz == Z_OK || iz == Z_DATA_ERROR);
		}
	}


/*****************************************************************************
	IDAT - image handling.
*****************************************************************************/
/*----------------------------------------------------------------------------
	Work out what Zlib strategy to use based on the information supplied by
	the caller.  This also works out any filtering required if nothing has been
	specifed.

	WARNING: this stuff is all guess work.  Needs to be tested out.
----------------------------------------------------------------------------*/
void SPNGWRITE::ResolveData(void)
	{
	SPNG_U8 bT(255);

	/* PNG FILTERING */
	if (m_colortype & 1)     // Palette image
		{
		bT = PNGFNone;        // Filtering always seems bad
		}

	/* We have the data type and the color information.  We know that
		photographic images do well with Paeth unless they have reduced
		color. */
	else switch (m_datatype)
		{
	default:
		SPNGlog1("SPNG: data type %d invalid", m_datatype);
		/* fall through */
	case SPNGUnknown:        // Data could be anything
		if (m_bDepth >= 8)    // Byte sized pixel components
			bT = PNGFMaskAll;
		else
			bT = PNGFNone;
		break;

	case SPNGPhotographic:   // Data is photographic in nature
		if (m_bDepth >= 8)    // Byte sized pixel components
			bT = PNGFPaeth;
		else
			bT = PNGFNone;
		break;

	case SPNGCG:             // Data is computer generated but continuous tone
		bT = PNGFPaeth;
		break;

	case SPNGDrawing:        // Data is a drawing - restricted colors
		bT = PNGFNone;        // Is this right?
		break;

	case SPNGMixed:          // Data is mixed SPNGDrawing and SPNGCG
		bT = PNGFMaskAll;
		break;
		}

	bool fDefault(true);     // Are these the default settings?
	if (m_filter == 255)     // Not set yet
		m_filter = bT;

	/* Reduce single filter masks to the corresponding filter number. */
	else
		{
		if (m_filter > PNGFPaeth && (m_filter & (m_filter-1)) == 0)
			{
			switch (m_filter)
				{
			default:
				SPNGlog1("SPNG: impossible: filter %x", m_filter);
			case PNGFMaskNone:
				m_filter = PNGFNone;
				break;
			case PNGFMaskSub:
				m_filter = PNGFSub;
				break;
			case PNGFMaskUp:
				m_filter = PNGFUp;
				break;
			case PNGFMaskAverage:
				m_filter = PNGFAverage;
				break;
			case PNGFMaskPaeth:
				m_filter = PNGFPaeth;
				break;
				}
			}

		if (m_filter != bT)
			fDefault = false;
		}

	/* ZLIB STRATEGY */
	if (m_filter != 0)
		bT = Z_FILTERED;
	else
		bT = Z_DEFAULT_STRATEGY;

	if (m_istrategy == 255)     // Otherwise caller specified
		m_istrategy = bT;
	else if (m_istrategy != bT)
		fDefault = false;

	/* ZLIB COMPRESSION LEVEL */
	#define ZLIB_FAST 3
	#define ZLIB_SLOW 7
	#define ZLIB_MAX  8
	switch (m_datatype)
		{
	default:
		SPNGlog1("SPNG: data type %d invalid", m_datatype);
		/* fall through */
	case SPNGUnknown:        // Data could be anything
		if (m_bDepth < 8 &&   // Check for palette or grayscale
			((m_colortype & 1) != 0 || (m_colortype & 2) == 0))
			{
			bT = ZLIB_SLOW;    // Assume good color correlation
			break;
			}
		// Fall through

	case SPNGPhotographic:   // Data is photographic in nature
		bT = ZLIB_FAST;    // Assume dithering (etc)
		break;

	case SPNGCG:             // Data is computer generated but continuous tone
	case SPNGMixed:          // Data is mixed SPNGDrawing and SPNGCG
		bT = ZLIB_SLOW;
		break;

	case SPNGDrawing:        // Data is a drawing - restricted colors
		bT = ZLIB_MAX;
		break;
		}

	if (m_icompressionLevel == 255)
		m_icompressionLevel = bT;
	else if (m_icompressionLevel != bT)
		fDefault = false;

	/* If this is determinably *not* our default strategy don't record it
		as such. */
	if (m_cmPPMETHOD == SPNGcmPPDefault && !fDefault)
		m_cmPPMETHOD = SPNGcmPPCheck;

	/* Reset windowBits given that we know how many bytes there are in the
		image - no point having a large windowBits if the image doesn't have
		that amount of data! */
	int cb;
	if (m_fInterlace)
		cb = CbPNGPassOffset(m_w, m_h, m_cbpp, 7);
	else
		cb = CPNGRowBytes(m_w, m_cbpp) * m_h;

	/* Add 256 for the initial code table. */
	cb += 256;

	/* Find the power of 2 which is greater than this. */
	int i(ILog2FloorX(cb));
	if ((1<<i) < cb) ++i;
	SPNGassert((1<<i) >= cb && i >= 8);
	/* Do not *increase* over the default. */
	if (i < m_iwindowBits)
		{
		if (i < 8) i = 8; // Error handling
		m_iwindowBits = SPNG_U8(i);
		}
	}


/*----------------------------------------------------------------------------
	Return the number of bytes required as buffer.  May be called at any time
	after FInitWrite, if fBuffer is true space is requested to buffer a
	previous row, otherwise the caller must provide that row.  The fReduce API
	indicates that the caller will provide data which must be packed to a lower
	bit depth, fBuffer is ignored and the previous row is always retained.
	The fInterlace setting indicates that the caller will call FWriteRow so the
	API must buffer all the rows to be able to do the interlace.  fBuffer and
	fReduce are then irrelevant.
----------------------------------------------------------------------------*/
size_t SPNGWRITE::CbWrite(bool fBuffer, bool fInterlace)
	{
	SPNGassert(m_order < spngorderIDAT); // Before any output!

	/* Perform some sanity checking on the values. */
	if (m_fMacA || m_fBGR)
		{
		SPNGassert(m_cbpp == 24 || m_cbpp == 32);
		if (m_cbpp != 24 && m_cbpp != 32)
			m_fMacA = m_fBGR = false;
		}
	if (m_pbTrans != NULL)
		{
		SPNGassert(m_cbpp <= 8);
		if (m_cbpp > 8)
			m_pbTrans = NULL;
		}

	/* We are going to change the data format if packing, byte swapping or
		16bpp expansion are set up. */
	if (m_pu1 == NULL && m_pu2 != NULL || m_pu1 != NULL && m_pu2 == NULL)
		{
		SPNGassert(("SPNG: one or other 16bpp expansion array NULL", false));
		m_pu1 = m_pu2 = NULL;
		}
	bool fReduce(m_fPack);

	/* Find out if we are handling filters which require no buffering. */
	ResolveData();
	if (!FNeedBuffer())
		fBuffer = false;
	else if (fReduce)
		fBuffer = true;  // Must retain our own copy

	if (m_h == 0 || m_w == 0)
		return 0;
	SPNGassert(m_fStarted && m_cbRow > 0);
	
	if (!m_fInterlace && fInterlace)
		{
		SPNGlog("SPNG: unexpected interlace handling");
		fInterlace = false;      // Error recover
		fReduce = true;          // Assume we need to do this
		fBuffer = FNeedBuffer();
		}

	/* Find the bytes in a row. */
	size_t cb(0);
	size_t cbRow((m_cbRow+7)&~7);
	if (fInterlace)
		{
		/* All the rows are buffered, the buffering must expand each
			row to a multiple of 8 so that the deinterlace will work. If
			we need to do reduction then this will happen during the
			buffering.  Even if it doesn't if there is a row 7 m_h will
			be at least 2 and we will have space in our buffer for the
			reduction.  In any case an extra row must be allocated for
			the de-interlace operation. */
		cb = cbRow * (m_h+1);
		fReduce = false;  // Do this during interlace buffering
		fBuffer = false;  // Do this in-place
		}
	else if (m_fInterlace)
		{
		/* For efficiency allocate a buffer big enough for the
			first 6 passes - exclude filter bytes - again these rows
			are expanded to a multiple of 8 bytes.  In this case we
			may have to both buffer and reduce on row 7, but in that
			case m_h will be at least 4.  We still need the extra row
			buffer. */
		cb = cbRow * (((m_h+1)>>1)+1);
		fReduce = false;
		fBuffer = false;
		}


	/* If we may need to reduce the pixels then we need a buffer for
		the result. */
	if (fReduce)
		cb += cbRow;

	/* If we must buffer the previous row allocate space for this. */
	if (fBuffer)
		cb += cbRow;
	m_fBuffer = fBuffer;

	return cb;
	}


/*----------------------------------------------------------------------------
	Set the output buffer.  Must be called before any Zlib activity or any
	bitmap stuff is passed in.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FSetBuffer(void *pvBuffer, size_t cbBuffer)
	{
	m_rgbBuffer = static_cast<SPNG_U8*>(pvBuffer);
	m_cbBuffer = cbBuffer;
	return true;
	}


/*----------------------------------------------------------------------------
	Flush an IDAT chunk - called only when Zlib has filled the buffer.
----------------------------------------------------------------------------*/
inline bool SPNGWRITE::FFlushIDAT(void)
	{
	SPNGassert(m_fStarted && m_fInChunk && m_fInited);

	/* Adjust m_cbOut to include this chunk. */
	m_cbOut = (SPNG_U32)(m_zs.next_out - m_rgb);
	SPNGassert(m_cbOut == sizeof m_rgb);
	/* We know that we are at the end of the chunk, however the APIs expect to
		have at least one byte available, so flush here. */
	if (!FFlush())
		return false;
	if (!FEndChunk())
		return false;
	SPNGassert(m_cbOut == 4); // The CRC, always!
	SPNGassert(!m_fInChunk);

	if (!FStartChunk((sizeof m_rgb) - m_cbOut - 8, PNGIDAT))
		return false;
	SPNGassert(m_fInChunk);

	m_zs.next_out = PbBuffer(m_zs.avail_out);
	SPNGassert(m_zs.avail_out == (sizeof m_rgb) - 12);

	return true;
	}


/*----------------------------------------------------------------------------
	Append bytes to a chunk, the chunk type is presumed to be PNGIDAT, the
	relevant chunk is started if necessary and the data is compressed into the
	output until all the input has been consumed - possibly generating new
	chunks on the way (all of the same type - PNGIDAT.)
----------------------------------------------------------------------------*/
bool SPNGWRITE::FWriteCbIDAT(const SPNG_U8* pb, size_t cb)
	{
	SPNGassert(m_fStarted);
	/* The caller sets m_order to IDAT. */
	SPNGassert(m_order == spngorderIDAT);
	if (!m_fInChunk)
		{
		SPNGassert(!m_fInited);

		ResolveData();
		if (!m_fInited && m_cmPPMETHOD != 255)
			{
			/* We check for m_fInited here because we would get a badly formed
				PNG if we output this chunk after the first IDAT, but I don't
				think anything else will go (too) wrong if the m_fInited assert
				otherwise fires. */
			if (!FStartChunk(cbPNGcmPPSignature+4, PNGcmPP))
				return false;
			if (!FOutCb(vrgbPNGcmPPSignature, cbPNGcmPPSignature))
				return false;
			if (!FOutB(m_cmPPMETHOD))
				return false;
			if (!FOutB(m_filter))
				return false;
			if (!FOutB(m_istrategy))
				return false;
			if (!FOutB(m_icompressionLevel))
				return false;
			if (!FEndChunk())
				return false;
			}

		/* The chunk has not yet been started.  Create a chunk which has the
			maximum possible size given the buffer size.  If the buffer is not
			big enough for even a single byte a dummy chunk is written. */
		if (m_cbOut+8 >= sizeof m_rgb)
			{
			if (!FStartChunk(0, PNGmsOD))
				return false;
			if (!FEndChunk())
				return false;
			SPNGassert(m_cbOut < 12); /* Must be in a new buffer. */
			}
		if (!FStartChunk((sizeof m_rgb) - m_cbOut - 8, PNGIDAT))
			return false;
		SPNGassert(m_fInChunk);
		if (!FInitZlib(m_istrategy, m_icompressionLevel, m_iwindowBits))
			return false;
		}

	SPNGassert(m_fInited);

	/* We have a started chunk.  The m_cbOut index is that of the first byte
		of the chunk data for the new chunk, the length field of this chunk
		is set to accomodate the whole avail_out buffer. */
	SPNGassert(m_zs.avail_out > 0);
	m_zs.next_in = const_cast<SPNG_U8*>(pb);
	m_zs.avail_in = cb;
	bool fOK(true);

	while (m_zs.avail_in > 0)
		{
		fOK = false;
		if (!FCheckZlib(deflate(&m_zs, Z_NO_FLUSH)))
			break;

		/* If this has left us with no output then we must reset the block
			pointer information and calculate the CRC.  Note that nothing from
			m_cbOut has been CRCed yet. */
		if (m_zs.avail_out <= 0)
			{
			/* Need some more buffer space. */
			if (!FFlushIDAT())
				break;
			}
		fOK = true;
		}

	/* We have handled that buffer or encountered an error.  We can detect
		errors by examining the m_zs state but it is more convenient to hold
		it in fOK. */
	m_zs.next_in = Z_NULL;
	m_zs.avail_in = 0;
	return fOK;
	}


/*----------------------------------------------------------------------------
	End an IDAT chunk, this also flushes the Zlib data - FWriteCbIDAT must have
	been called at least once.
----------------------------------------------------------------------------*/
bool SPNGWRITE::FEndIDAT(void)
	{
	SPNGassert(m_order == spngorderIDAT);
	if (m_order != spngorderIDAT)
		return false;
	SPNGassert(m_fStarted && m_fInChunk && m_fInited);

	/* Note that, typically, this is where we actually do the output because
		Zlib tends to buffer up large amounts of data, also note that under some
		circumstances it is conceivable that this code will generate a 0 length
		IDAT chunk - but we can strip that out. */
	SPNGassert(m_zs.avail_out > 0);
	SPNGassert(m_zs.avail_in == 0 && m_zs.next_in == Z_NULL);

	for (;;)
		{
		int ierr(deflate(&m_zs, Z_FINISH));

		if (!FCheckZlib(ierr))
			return false;

		if (ierr == Z_STREAM_END)
			break; // All output is complete.

		/* We need a new IDAT chunk. */
		if (!FFlushIDAT())
			return false;

		/* Loop again, we terminate when Zlib says that the stream is ended. */
		}

	/* At the end the IDAT chunk size may be wrong. */
	SPNGassert(m_cbOut >= 8);  // Because there is an IDAT header
	/* I'm not totally sure that Zlib maintains the following invariant when
		m_zs.avail_out is set to 0. */
	SPNGassert(m_rgb + (sizeof m_rgb) == m_zs.next_out + m_zs.avail_out);
	if (m_zs.avail_out > 0)
		{
		/* The chunk must be shortened, it may end up zero size in which case
			it can simply be removed. */
		size_t cb(m_zs.next_out - m_rgb);  // Bytes in buffer
		cb -= m_cbOut;                     // Bytes in chunk (chunk length)
		SPNGassert(cb >= 0);
		if (cb <= 0)
			{
			m_cbOut -= 8;  // Remove IDAT header
			m_ichunk = m_cbOut;
			m_ucrc = 0;
			m_fInChunk = false;
			return true;
			}

		/* We must write the new length. */
		m_rgb[m_cbOut-8] = SPNG_U8(cb >> 24);
		m_rgb[m_cbOut-7] = SPNG_U8(cb >> 16);
		m_rgb[m_cbOut-6] = SPNG_U8(cb >>  8);
		m_rgb[m_cbOut-5] = SPNG_U8(cb);

		/* Ensure that the "end chunk" operation will include these bytes in the
			CRC! */
		m_cbOut += cb;
		}
	else if (!FFlush()) // The buffer is full, make space for the CRC
		return false;

	/* Now we can clean up Zlib itself. */
	EndZlib();

	/* Finally end the chunk. */
	return FEndChunk();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   wmfcodec.hpp
*
* Abstract:
*
*   Header file for the WMF encoder/decoder
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

// The metafile file header

#pragma pack(1)

typedef struct tagOLDRECT
{
    short   left;
    short   top;
    short   right;
    short   bottom;
} OLDRECT;

typedef struct {
        DWORD   key;
        WORD    hmf;
        OLDRECT bbox;
        WORD    inch;
        DWORD   reserved;
        WORD    checksum;
}PLACEABLEWMFHEADER;

#pragma pack()

class GpWMFCodec : public IImageDecoder
{
private:

    // =====================================================
    // Decoder privates
    // =====================================================

    IStream *pIstream;
    IImageSink* decodeSink;
    ImageInfo imageInfo;
    PLACEABLEWMFHEADER pwmfh;
    METAHEADER mh;
    BOOL bReadHeader;
    BOOL bReinitializeWMF;
    
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpWMFCodec::GpWMFCodec(void);
    GpWMFCodec::~GpWMFCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink,
                           IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
                                 IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth,
                            IN OPTIONAL UINT thumbHeight,
                            OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(ReadWMFHeader());
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfdecoder.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   wmfdecoder.cpp
*
* Abstract:
*
*   Implementation of the WMF decoder
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "wmfcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;

    // Make sure we haven't been initialized already

    if (pIstream)
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    pIstream = stream;
    bReadHeader = FALSE;
    bReinitializeWMF = FALSE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::TerminateDecoder()
{
    // Release the input stream

    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Reads the WMF header
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::ReadWMFHeader()
{
    HRESULT hresult;

    if (!pIstream)
    {
        return E_FAIL;
    }

    if (!bReadHeader)
    {
        ULONG cbRead;

        // Read the PLACEABLEWMFHEADER

        hresult = pIstream->Read((void *) &pwmfh, sizeof(pwmfh), &cbRead);
        if (FAILED(hresult))
        {
            return hresult;
        }
        if (cbRead != sizeof(pwmfh))
        {
            return E_FAIL;
        }

        // Read the METAHEADER

        hresult = pIstream->Read((void *) &mh, sizeof(mh), &cbRead);
        if (FAILED(hresult))
        {
            return hresult;
        }
        if (cbRead != sizeof(mh))
        {
            return E_FAIL;
        }

        bReadHeader = TRUE;

        imageInfo.RawDataFormat = IMGFMT_WMF;
        imageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo.Width  = MulDiv( pwmfh.bbox.right - pwmfh.bbox.left,
                                   96, pwmfh.inch );
        imageInfo.Height = MulDiv( pwmfh.bbox.bottom - pwmfh.bbox.top,
                                   96, pwmfh.inch );
        imageInfo.TileWidth  = imageInfo.Width;
        imageInfo.TileHeight = 1; // internal GDI format is bottom-up...

        imageInfo.Xdpi = (double) pwmfh.inch;
        imageInfo.Ydpi = (double) pwmfh.inch;
        imageInfo.Flags = SINKFLAG_TOPDOWN
                        | SINKFLAG_FULLWIDTH
                        | SINKFLAG_SCALABLE
                        | IMGFLAG_COLORSPACE_RGB;
    }

    return S_OK;
}

STDMETHODIMP
GpWMFCodec::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
GpWMFCodec::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
GpWMFCodec::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    return E_NOTIMPL;
}// GetPropertyCount()

STDMETHODIMP
GpWMFCodec::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    return E_NOTIMPL;
} // GetPropertyIdList()

HRESULT
GpWMFCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetPropertyItemSize()

HRESULT
GpWMFCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    return E_NOTIMPL;
}// GetPropertyItem()

HRESULT
GpWMFCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    return E_NOTIMPL;
}// GetPropertySize()

HRESULT
GpWMFCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    return E_NOTIMPL;
}// GetAllPropertyItems()

HRESULT
GpWMFCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return E_NOTIMPL;
}// RemovePropertyItem()

HRESULT
GpWMFCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return E_NOTIMPL;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink --  The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink)
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    HRESULT hresult;

    if (!decodeSink)
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }

    hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    bReinitializeWMF = TRUE;

    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetImageInfo(OUT ImageInfo* imageInfoArg)
{
    HRESULT hresult;

    hresult = ReadWMFHeader();
    if (FAILED(hresult))
    {
        return hresult;
    }

    *imageInfoArg = imageInfo;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::Decode()
{
    HRESULT hresult = S_OK;
    void *buffer;

    // If this is the second time through this stream, reinitialize pointer.

    if (bReinitializeWMF)
    {
        bReadHeader = FALSE;
        if (!pIstream)
        {
            return E_FAIL;
        }

        LARGE_INTEGER zero = {0,0};
        hresult = pIstream->Seek(zero, STREAM_SEEK_SET, NULL);
        if (!SUCCEEDED(hresult))
        {
            return hresult;
        }
    }

    hresult = ReadWMFHeader();
    if (FAILED(hresult))
    {
        return hresult;
    }

    // Allocate a buffer for the metafile.  There are some metafiles where
    // mh.mtSize is wrong, so let's read all the bits in the stream.

    //UINT mhSize = mh.mtSize * sizeof(WORD);

    STATSTG statStg;
    hresult = pIstream->Stat(&statStg, STATFLAG_NONAME);
    if (FAILED(hresult))
    {
        return hresult;
    }
    UINT mhSize = statStg.cbSize.LowPart - sizeof(pwmfh);

    // According to the document for IStream::Stat::StatStage(), the caller
    // has to free the pwcsName string
    CoTaskMemFree(statStg.pwcsName);

    buffer = GpMalloc(mhSize);
    if (!buffer)
    {
        return E_OUTOFMEMORY;
    }

    // Copy the metafile header to the start of the buffer

    *((METAHEADER *) buffer) = mh;

    // Now read the rest of the metafile into the buffer

    void *restOfBuffer = (void *) (((BYTE *) buffer) + sizeof(mh));
    ULONG cbRead;
    hresult = pIstream->Read(restOfBuffer, mhSize - sizeof(mh), &cbRead);
    if (FAILED(hresult))
    {
        return hresult;
    }
    if (cbRead != (mhSize - sizeof(mh)))
    {
        return E_FAIL;
    }

    // Call BeginSink

    hresult = decodeSink->BeginSink(&imageInfo, NULL);
    if (FAILED(hresult))
    {
        return hresult;
    }

    // Create memory DC and dibsection

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth    = imageInfo.Width;
    bmi.bmiHeader.biHeight   = imageInfo.Height;
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;

    PBYTE pBits;
    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    if ( hdcMem == NULL )
    {
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }
    HBITMAP hbitmap = CreateDIBSection(hdcScreen,
                                       &bmi,
                                       DIB_RGB_COLORS,
                                        (void **) &pBits,
                                       NULL,
                                       0);
    if (!hbitmap)
    {
        WARNING(("GpWMFCodec::Decode -- failed to create DIBSection"));

        DeleteDC(hdcMem);
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    // Initialize background to white

    UINT *p = (UINT *) pBits;
    UINT numPixels = imageInfo.Width * imageInfo.Height;
    UINT i;
    for (i = 0; i < numPixels; i++, p++)
    {
        *p = 0x00ffffff;
    }

    HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, hbitmap));

    // Create a handle for the metafile backing the bits from the stream

    HMETAFILE hWMF = SetMetaFileBitsEx(mhSize, (BYTE *) buffer);
    if (!hWMF)
    {
        WARNING(("GpWMFCodec::Decode -- cannot create metafile backing stream bits"));

        DeleteDC(hdcMem);
        DeleteObject(SelectObject(hdcMem, hOldBitmap));
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    // Now xform the DC so that the bounding rectangle is exactly the same as our dib.

    INT nOldMapMode = GetMapMode(hdcMem);
    SIZE sizeOld;
    SetMapMode(hdcMem, MM_ANISOTROPIC);
    SetViewportExtEx(hdcMem, imageInfo.Width, imageInfo.Height, &sizeOld );

    // Play the metafile onto the memory DC

    PlayMetaFile(hdcMem, hWMF);

    // Restore old settings

    SetViewportExtEx(hdcMem, sizeOld.cx, sizeOld.cy, NULL);
    SetMapMode(hdcMem, nOldMapMode);

    // And finally deliver the bits to the sink

    // ASSERT: The bits are in PIXFMT_32BPP_RGB format (no alpha values)

    BitmapData bitmapData;
    RECT rect;

    bitmapData.Width  = imageInfo.Width;
    bitmapData.Height = 1;
    bitmapData.Stride = bitmapData.Width * 4;
    bitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
    bitmapData.Reserved = 0;

    rect.left  = 0;
    rect.right = imageInfo.Width;

    for (i=0; i < imageInfo.Height; i++)
    {
        rect.top    = i;
        rect.bottom = i + 1;
        bitmapData.Scan0 = pBits + (imageInfo.Height - i - 1) * bitmapData.Stride;

        // need to fill in the alpha values to make the bits be PIXFMT_32BPP_ARGB format,
        // which is a canonical format.
        UINT j;
        BYTE *ptr;
        for (j = 0, ptr = static_cast<BYTE *>(bitmapData.Scan0);
             j < imageInfo.Width;
             j++, ptr += 4)
        {
            // fill in the alpha value with 0xff
            *(ptr + 3) = 0xff;
        }

        hresult = decodeSink->PushPixelData(&rect,
                                            &bitmapData,
                                            PIXFMT_32BPP_ARGB);

        if (FAILED(hresult))
        {
            WARNING(("GpWMFCodec::Decode -- failed call to PushPixelData"));
            break;
        }
    }

    // Release objects

    DeleteMetaFile(hWMF);
    DeleteObject(SelectObject(hdcMem, hOldBitmap));
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);
    GpFree(buffer);

    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpWmfCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }

    // Tell the caller that WMF is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpWmfCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*
* Arguments:
*
*     dimensionID --
*     count --
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        return E_INVALIDARG;
    }

    *count = 1;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpWMFCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.cpp
*
* Abstract:
*
*   Shared methods for the WMF codec
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "wmfcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpWMFCodec::GpWMFCodec(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpWMFCodec::~GpWMFCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpWMFCodec::~GpWMFCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpWMFCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpWMFCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\aarasterizer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   AARasterizer.cpp
*
* Abstract:
*
*   Contains all the code for rasterizing the fill of a path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

#include "precomp.hpp"

#include <limits.h>

#if DBG
    #define ASSERTACTIVELIST(list, y) AssertActiveList(list, y)
    #define ASSERTACTIVELISTORDER(list) AssertActiveListOrder(list)
    #define ASSERTINACTIVEARRAY(list, count) AssertInactiveArray(list, count)
    #define ASSERTPATH(path) AssertPath(path)
#else
    #define ASSERTACTIVELIST(list, y)
    #define ASSERTACTIVELISTORDER(list)
    #define ASSERTINACTIVEARRAY(list, count)
    #define ASSERTPATH(path)
#endif

// Define our on-stack storage use.  The 'free' versions are nicely tuned
// to avoid allocations in most common scenarios, while at the same time
// not chewing up toooo much stack space.  
//
// We make the debug versions small so that we hit the 'grow' cases more
// frequently, for better testing:

#if DBG
    #define EDGE_STORE_STACK_NUMBER 10
    #define EDGE_STORE_ALLOCATION_NUMBER 11
    #define INACTIVE_LIST_NUMBER 12
    #define ENUMERATE_BUFFER_NUMBER 15
    #define INTERVAL_BUFFER_NUMBER 8        // Must be at least 4
    #define NOMINAL_FILL_POINT_NUMBER 4     // Must be at least 4
#else    
    #define EDGE_STORE_STACK_NUMBER (1600 / sizeof(EpEdge))
    #define EDGE_STORE_ALLOCATION_NUMBER (4032 / sizeof(EpEdge))
    #define INACTIVE_LIST_NUMBER EDGE_STORE_STACK_NUMBER
    #define ENUMERATE_BUFFER_NUMBER 32
    #define INTERVAL_BUFFER_NUMBER 32
    #define NOMINAL_FILL_POINT_NUMBER 32
#endif

class EpEdgeStore;

// 'EpEdge' is our classic data structure for tracking an edge:

struct EpEdge
{
    EpEdge *Next;               // Next active edge (don't check for NULL,
                                //   look for tail sentinel instead)
    INT X;                      // Current X location
    INT Dx;                     // X increment
    INT Error;                  // Current DDA error
    INT ErrorUp;                // Error increment
    INT ErrorDown;              // Error decrement when the error rolls over
    INT StartY;                 // Y-row start
    INT EndY;                   // Y-row end
    INT WindingDirection;       // -1 or 1
};

// We the inactive-array separate from the edge allocations so that
// we can more easily do in-place sorts on it:

struct EpInactiveEdge
{
    EpEdge *Edge;               // Associated edge
    LONGLONG Yx;                // Sorting key, StartY and X packed into an lword
};

// We allocate room for our edge datastructures in batches:

struct EpEdgeAllocation
{
    EpEdgeAllocation *Next;     // Next allocation batch (may be NULL)
    INT Count;
    EpEdge EdgeArray[EDGE_STORE_STACK_NUMBER];
};

// The following is effectively the paramter list for 'InitializeEdges',
// which takes a run of points and sets up the initial edge list:

struct EpInitializeEdgesContext
{
    INT MaxY;                   // Maximum 'y' found, should be INT_MIN on
                                //   first call to 'InitializeEdges'
    RECT* ClipRect;             // Bounding clip rectangle in 28.4 format
    EpEdgeStore *Store;         // Where to stick the edges
    BOOL IsAntialias;           // The edges are going to be rendered
                                //   using antialiasing super-sampling
};

// Interval coverage descriptor for our antialiased filler:

struct EpInterval
{
    INT X;                      // Interval's left edge (Next->X is the 
                                //   right edge)
    INT Depth;                  // Number of layers that this interval has
                                //   been covered
    EpInterval *Next;           // Next interval (look for sentinel, not NULL)
};

// Allocator structure for the antialiased fill interval data:

struct EpIntervalBuffer
{
    EpIntervalBuffer *Next;
    EpInterval Interval[INTERVAL_BUFFER_NUMBER];
};

/**************************************************************************\
*
* Class Description:
*
*  'EpEdgeStore' is used by 'InitializeEdges' as its repository for
*   all the edge data:
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpEdgeStore
{
private:

    INT TotalCount;                 // Total edge count in store
    INT CurrentRemaining;           // How much room remains in current buffer
    EpEdgeAllocation *CurrentBuffer;// Current buffer
    EpEdge *CurrentEdge;            // Current edge in current buffer
    EpEdgeAllocation *Enumerator;   // For enumerating all the edges
    EpEdgeAllocation EdgeHead;      // Our built-in allocation

public:

    EpEdgeStore()
    {
        TotalCount = 0;
        CurrentBuffer = &EdgeHead;
        CurrentEdge = &EdgeHead.EdgeArray[0];
        CurrentRemaining = EDGE_STORE_STACK_NUMBER;

        EdgeHead.Count = EDGE_STORE_STACK_NUMBER;
        EdgeHead.Next = NULL;
    }

    ~EpEdgeStore()
    {
        // Free our allocation list, skipping the head, which is not
        // dynamically allocated:

        EpEdgeAllocation *allocation = EdgeHead.Next;
        while (allocation != NULL)
        {
            EpEdgeAllocation *next = allocation->Next;
            GpFree(allocation);
            allocation = next;
        }
    }

    INT StartEnumeration()
    {
        Enumerator = &EdgeHead;

        // Update the count and make sure nothing more gets added (in
        // part because this Count would have to be re-computed):

        CurrentBuffer->Count -= CurrentRemaining;
        TotalCount += CurrentBuffer->Count;

        // Prevent this from being called again, because bad things would
        // happen:

        CurrentBuffer = NULL;

        return(TotalCount);
    }

    BOOL Enumerate(EpEdge** startEdge, EpEdge** endEdge)
    {
        EpEdgeAllocation *enumerator = Enumerator;
    
        // Might return startEdge == endEdge:
    
        *startEdge = &enumerator->EdgeArray[0];
        *endEdge = &enumerator->EdgeArray[Enumerator->Count];
    
        return((Enumerator = enumerator->Next) != NULL);
    }

    VOID StartAddBuffer(EpEdge **currentEdge, INT *remaining)
    {
        *currentEdge = CurrentEdge;
        *remaining = CurrentRemaining;
    }

    VOID EndAddBuffer(EpEdge *currentEdge, INT remaining)
    {
        CurrentEdge = currentEdge;
        CurrentRemaining = remaining;
    }

    BOOL NextAddBuffer(EpEdge **currentEdge, INT *remaining);
};

/**************************************************************************\
*
* Function Description:
*
*   The edge initializer is out of room in its current 'store' buffer;
*   get it a new one.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
EpEdgeStore::NextAddBuffer(
    EpEdge **currentEdge,
    INT *remaining
    )
{
    // The caller has completely filled up this chunk:

    ASSERT(*remaining == 0);

    // We have to grow our data structure by adding a new buffer
    // and adding it to the list:

    EpEdgeAllocation *newBuffer = static_cast<EpEdgeAllocation*>
        (GpMalloc(sizeof(EpEdgeAllocation) +
                  sizeof(EpEdge) * (EDGE_STORE_ALLOCATION_NUMBER
                                  - EDGE_STORE_STACK_NUMBER)));
    if (newBuffer == NULL)
        return(FALSE);

    newBuffer->Next = NULL;
    newBuffer->Count = EDGE_STORE_ALLOCATION_NUMBER;

    TotalCount += CurrentBuffer->Count;

    CurrentBuffer->Next = newBuffer;
    CurrentBuffer = newBuffer;

    *currentEdge = CurrentEdge = &newBuffer->EdgeArray[0];
    *remaining = CurrentRemaining = EDGE_STORE_ALLOCATION_NUMBER;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the state of the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
AssertActiveList(
    const EpEdge *list, 
    INT yCurrent
    )
{
    BOOL b = TRUE;
    INT activeCount = 0;

    ASSERT(list->X == INT_MIN);
    b &= (list->X == INT_MIN);

    // Skip the head sentinel:

    list = list->Next;

    while (list->X != INT_MAX)
    {
        ASSERT(list->X != INT_MIN);
        b &= (list->X != INT_MIN);

        ASSERT(list->X <= list->Next->X);
        b &= (list->X <= list->Next->X);

        ASSERT((list->StartY <= yCurrent) && (yCurrent < list->EndY));
        b &= ((list->StartY <= yCurrent) && (yCurrent < list->EndY));

        activeCount++;
        list = list->Next;
    }

    ASSERT(list->X == INT_MAX);
    b &= (list->X == INT_MAX);

    // There should always be a multiple of 2 edges in the active list.
    //
    // NOTE: If you hit this assert, do NOT simply comment it out!
    //       It usually means that all the edges didn't get initialized
    //       properly.  For every scan-line, there has to be a left edge
    //       and a right edge (or a mulitple thereof).  So if you give
    //       even a single bad edge to the edge initializer (or you miss 
    //       one), you'll probably hit this assert.

    ASSERT((activeCount & 1) == 0);
    b &= ((activeCount & 1) == 0);

    return(b);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the state of the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
AssertActiveListOrder(
    const EpEdge *list
    )
{
    INT activeCount = 0;

    ASSERT(list->X == INT_MIN);

    // Skip the head sentinel:

    list = list->Next;

    while (list->X != INT_MAX)
    {
        ASSERT(list->X != INT_MIN);
        ASSERT(list->X <= list->Next->X);

        activeCount++;
        list = list->Next;
    }

    ASSERT(list->X == INT_MAX);
}

/**************************************************************************\
*
* Class Description:
*
*   Base class for all our fill routines.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpFiller : public DpOutputSpan
{
public:

    virtual BOOL IsValid() const { return(TRUE); }

};

typedef VOID (FASTCALL EpFiller::*EpFillerFunction)(EpEdge *, INT);

/**************************************************************************\
*
* Class Description:
*
*   Antialised filler state.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpAntialiasedFiller : public EpFiller
{
private:

    INT Y;                              // Current scan
    DpOutputSpan *Output;
    DpOutputSpan *Clipper;
    EpInterval *StartInterval;          // Points to list head entry
    EpInterval *NewInterval;
    EpInterval *EndIntervalMinus2;
    EpIntervalBuffer BuiltinBuffer;
    EpIntervalBuffer *CurrentBuffer;

public:

    EpAntialiasedFiller(DpOutputSpan *output)
    {
        Output = output;
        Clipper = this;

        BuiltinBuffer.Interval[0].X = INT_MIN;
        BuiltinBuffer.Interval[0].Depth = 0;
        BuiltinBuffer.Interval[0].Next = &BuiltinBuffer.Interval[1];

        BuiltinBuffer.Interval[1].X = INT_MAX;
        BuiltinBuffer.Interval[1].Depth = 0xdeadbeef;
        BuiltinBuffer.Interval[1].Next = NULL;

        BuiltinBuffer.Next = NULL;
        CurrentBuffer = &BuiltinBuffer;

        StartInterval = &BuiltinBuffer.Interval[0];
        NewInterval = &BuiltinBuffer.Interval[2];
        EndIntervalMinus2 = &BuiltinBuffer.Interval[INTERVAL_BUFFER_NUMBER - 2];
    }

    ~EpAntialiasedFiller()
    {
        GenerateOutputAndClearCoverage(Y);

        // Free the linked-list of allocations (skipping 'BuiltinBuffer',
        // which is built into the class):

        EpIntervalBuffer *buffer = BuiltinBuffer.Next;
        while (buffer != NULL)
        {
            EpIntervalBuffer *nextBuffer = buffer->Next;
            GpFree(buffer);
            buffer = nextBuffer;
        }
    }

    VOID SetClipper(DpOutputSpan *clipper)
    {
        Clipper = clipper;
    }

    VOID FASTCALL FillEdgesAlternate(const EpEdge *active, INT yCurrent);

    VOID FASTCALL FillEdgesWinding(const EpEdge *active, INT yCurrent);

    BOOL Grow(EpInterval **newInterval, EpInterval**endIntervalMinus2);

    VOID GenerateOutputAndClearCoverage(INT yCurrent);

    virtual GpStatus OutputSpan(INT y, INT left, INT right);
};

/**************************************************************************\
*
* Function Description:
*
*   Grow our interval buffer.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL 
EpAntialiasedFiller::Grow(
    EpInterval **newInterval, 
    EpInterval **endIntervalMinus2
    )
{
    EpIntervalBuffer *newBuffer = CurrentBuffer->Next;
    if (!newBuffer)
    {
        newBuffer = static_cast<EpIntervalBuffer*>
                        (GpMalloc(sizeof(EpIntervalBuffer)));
        if (!newBuffer)
            return(FALSE);

        newBuffer->Next = NULL;
        CurrentBuffer->Next = newBuffer;
    }

    CurrentBuffer = newBuffer;

    NewInterval = &newBuffer->Interval[2];
    EndIntervalMinus2 = &newBuffer->Interval[INTERVAL_BUFFER_NUMBER - 2];

    *newInterval = NewInterval;
    *endIntervalMinus2 = EndIntervalMinus2;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do an alternate-mode
*   antialiased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
EpAntialiasedFiller::FillEdgesAlternate(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    EpInterval *interval = StartInterval;
    EpInterval *newInterval = NewInterval;
    EpInterval *endIntervalMinus2 = EndIntervalMinus2;
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
                endEdge = endEdge->Next->Next;

            ASSERT((left < right) && (right < INT_MAX));

            // Make sure we have enough room to add two intervals if
            // necessary:

            if (newInterval >= endIntervalMinus2)
            {
                if (!Grow(&newInterval, &endIntervalMinus2))
                    break;      // ==============>
            }

            // Skip any intervals less than 'left':

            while ((nextX = interval->Next->X) < left)
                interval = interval->Next;

            // Insert a new interval if necessary:

            if (nextX != left)
            {
                newInterval->X = left;
                newInterval->Depth = interval->Depth + 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }

            // Increase the coverage for any intervals between 'left'
            // and 'right':

            while ((nextX = interval->Next->X) < right)
            {
                interval = interval->Next;
                interval->Depth++;
            }

            // Insert another new interval if necessary:

            if (nextX != right)
            {
                newInterval->X = right;
                newInterval->Depth = interval->Depth - 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    } 

    NewInterval = newInterval;
    Y = yCurrent;

    // If the next scan is done, output what's there:

    if (((yCurrent + 1) & AA_Y_MASK) == 0)
    {
        GenerateOutputAndClearCoverage(yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do a winding-mode
*   antialiased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
EpAntialiasedFiller::FillEdgesWinding(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    EpInterval *interval = StartInterval;
    EpInterval *newInterval = NewInterval;
    EpInterval *endIntervalMinus2 = EndIntervalMinus2;
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;
    INT windingValue;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        windingValue = startEdge->WindingDirection;
        while ((windingValue += endEdge->WindingDirection) != 0)
            endEdge = endEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
            {
                startEdge = endEdge->Next;
                endEdge = startEdge->Next;

                windingValue = startEdge->WindingDirection;
                while ((windingValue += endEdge->WindingDirection) != 0)
                    endEdge = endEdge->Next;
            }

            ASSERT((left < right) && (right < INT_MAX));

            // Make sure we have enough room to add two intervals if
            // necessary:

            if (newInterval >= endIntervalMinus2)
            {
                if (!Grow(&newInterval, &endIntervalMinus2))
                    break;      // ==============>
            }

            // Skip any intervals less than 'left':

            while ((nextX = interval->Next->X) < left)
                interval = interval->Next;

            // Insert a new interval if necessary:

            if (nextX != left)
            {
                newInterval->X = left;
                newInterval->Depth = interval->Depth + 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }

            // Increase the coverage for any intervals between 'left'
            // and 'right':

            while ((nextX = interval->Next->X) < right)
            {
                interval = interval->Next;
                interval->Depth++;
            }

            // Insert another new interval if necessary:

            if (nextX != right)
            {
                newInterval->X = right;
                newInterval->Depth = interval->Depth - 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    } 

    NewInterval = newInterval;
    Y = yCurrent;

    // If the next scan is done, output what's there:

    if (((yCurrent + 1) & AA_Y_MASK) == 0)
    {
        GenerateOutputAndClearCoverage(yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Now that it's been clipped, produce the pixels and modify their
*   alpha values according to the antialiased coverage.
*
* Created:
*
*   03/17/2000 andrewgo
*
\**************************************************************************/

GpStatus
EpAntialiasedFiller::OutputSpan(
    INT y,          // Non-scaled coordinates
    INT left,
    INT right
    ) 
{
    ASSERT(right > left);

    // First ask the 'producer' to actually generate the pixels for us.
    // Then we need to simply whack the pixel buffer with the coverage
    // values we've generated.

    Output->OutputSpan(y, left, right);

    // Retrieve a pointer to the buffer that the 'producer' just wrote
    // the pixels to:

    UCHAR *buffer = reinterpret_cast<UCHAR*> 
                        (Output->GetScanBuffer()->GetCurrentBuffer());

    EpInterval *coverage = StartInterval;

    // Figure out the end of the last pixel, remembering that 'right'
    // is exclusive:

    INT scaledRight = right << AA_X_SHIFT;

    // Skip any intervals that might have been completely clipped out:

    INT pixelLeftEdge = left << AA_X_SHIFT;
    while (coverage->Next->X < pixelLeftEdge)
        coverage = coverage->Next;

    INT pixelRightEdge = pixelLeftEdge + AA_X_WIDTH;

    while (pixelLeftEdge < scaledRight)
    {
        UINT coverageValue;

        // Compute the coverage coming into the first pixel:

        if (coverage->Next->X > pixelRightEdge)
        {
            // The interval extends out the end of the pixel:

            coverageValue = (pixelRightEdge - max(pixelLeftEdge, coverage->X))
                          * coverage->Depth;
        }
        else
        {
            // The interval ends in our pixel:

            coverageValue = (coverage->Next->X - max(pixelLeftEdge, coverage->X))
                          * coverage->Depth;

            coverage = coverage->Next;
    
            // Add in any coverages for intervals contained entirely within the
            // pixel:
    
            while (coverage->Next->X < pixelRightEdge)
            {
                coverageValue += (coverage->Next->X - coverage->X) * coverage->Depth;
                coverage = coverage->Next;
            }
    
            // Add in the coverage for the interval going out of the pixel:
    
            coverageValue += (pixelRightEdge - max(coverage->X, pixelLeftEdge)) 
                           * coverage->Depth;
        }

        // We've goofed if we get a coverage value more than is theoretically
        // possible, or if it's zero (in the latter case, it should have
        // been filtered already by our caller).

        ASSERT(coverageValue <= (1 << (AA_X_SHIFT + AA_Y_SHIFT)));
        ASSERT(coverageValue != 0);

        // Modify the pixel's alpha channel according to the coverage values:

    #if !defined(NO_PREMULTIPLIED_ALPHA)
        *(buffer+0) = MULTIPLY_COVERAGE(*(buffer+0), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        *(buffer+1) = MULTIPLY_COVERAGE(*(buffer+1), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        *(buffer+2) = MULTIPLY_COVERAGE(*(buffer+2), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
    #endif
        *(buffer+3) = MULTIPLY_COVERAGE(*(buffer+3), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        buffer += 4; 

        // Now handle the part of the current interval that completely covers 
        // more than one pixel (if it does):

        UINT consecutivePixels = (min(coverage->Next->X, scaledRight) 
                                  - pixelRightEdge) >> AA_X_SHIFT;

        UINT depth = coverage->Depth;

        // By definition, we shouldn't have an interval with zero coverage
        // (it should have been filtered out by our caller).  We won't fall
        // over, but it would be the wrong thing to do for SrcCopy mode.

        ASSERT((consecutivePixels == 0) || (depth != 0));

        if (depth == AA_Y_HEIGHT)
        {
            // All these pixels are completely covered.  Woo hoo, no work to 
            // do!

            buffer += (4 * consecutivePixels);
        }
        else
        {
            // Go through the run and multiply the alpha values by the run's
            // coverage:

            UINT i = consecutivePixels;
            while (i-- != 0)
            {
            #if !defined(NO_PREMULTIPLIED_ALPHA)
                *(buffer+0) = MULTIPLY_COVERAGE(*(buffer+0), depth, AA_Y_SHIFT);
                *(buffer+1) = MULTIPLY_COVERAGE(*(buffer+1), depth, AA_Y_SHIFT);
                *(buffer+2) = MULTIPLY_COVERAGE(*(buffer+2), depth, AA_Y_SHIFT);
            #endif
                *(buffer+3) = MULTIPLY_COVERAGE(*(buffer+3), depth, AA_Y_SHIFT);
                buffer += 4;
            }
        }

        // Prepare for the next iteration through the loop:

        pixelLeftEdge += ((consecutivePixels + 1) << AA_X_SHIFT);
        pixelRightEdge += ((consecutivePixels + 1) << AA_X_SHIFT);
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Given complete interval data for a scan, find runs of touched pixels
*   and then call the clipper (or directly to the rendering routine if
*   there's no clipping).
*
* Created:
*
*   03/17/2000 andrewgo
*
\**************************************************************************/

VOID
EpAntialiasedFiller::GenerateOutputAndClearCoverage(
    INT yScaled
    )
{
    EpInterval *spanStart = StartInterval->Next;
    EpInterval *spanEnd;

    while (spanStart->X != INT_MAX)
    {
        ASSERT(spanStart->Depth != 0);

        // Here we determine the length of a continuous run of covered
        // pixels.  For the case where the user has set the mode to 
        // SRCCOPY, it's very important that we don't accidentally pass 
        // off as 'covered' a pixel that we later realize wasn't covered.

        spanEnd = spanStart->Next;
        while ((spanEnd->Depth != 0) ||
               ((spanEnd->Next->X & ~AA_X_MASK) == (spanEnd->X & ~AA_X_MASK)))
        {
            spanEnd = spanEnd->Next;
        }

        // Figure out the actual integer pixel values.  

        INT left = spanStart->X >> AA_X_SHIFT;                   // inclusive
        INT right = (spanEnd->X + AA_X_WIDTH - 1) >> AA_X_SHIFT; // exclusive
        INT y = yScaled >> AA_Y_SHIFT;

        // If there's no clip region, this jumps to EpAntialiasedFiller::
        // OutputSpan:

        Clipper->OutputSpan(y, left, right);

        // Advance to after the gap:

        spanStart = spanEnd->Next;
    }

    // Reset our coverage structure.  Point the head back to the tail,
    // and reset where the next new entry will be placed:

    BuiltinBuffer.Interval[0].Next = &BuiltinBuffer.Interval[1];

    CurrentBuffer = &BuiltinBuffer;
    NewInterval = &BuiltinBuffer.Interval[2];
    EndIntervalMinus2 = &BuiltinBuffer.Interval[INTERVAL_BUFFER_NUMBER - 2];
}

/**************************************************************************\
*
* Class Description:
*
*   Aliased filler state.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpAliasedFiller : public EpFiller
{
private:
    DpOutputSpan *Output;

public:

    EpAliasedFiller(DpOutputSpan *output)
    {
        Output = output;
    }

    VOID SetOutputSpan(DpOutputSpan *output)
    {
        Output = output;
    }

    VOID FASTCALL FillEdgesAlternate(const EpEdge *active, INT yCurrent);

    VOID FASTCALL FillEdgesWinding(const EpEdge *active, INT yCurrent);

    virtual GpStatus OutputSpan(INT y, INT left, INT right) { return Ok; }
};

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do an alternate-mode
*   aliased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
EpAliasedFiller::FillEdgesAlternate(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
                endEdge = endEdge->Next->Next;

            ASSERT((left < right) && (right < INT_MAX));

            Output->OutputSpan(yCurrent, left, right);
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do a winding-mode
*   aliased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
EpAliasedFiller::FillEdgesWinding(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;
    INT windingValue;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        windingValue = startEdge->WindingDirection;
        while ((windingValue += endEdge->WindingDirection) != 0)
            endEdge = endEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
            {
                startEdge = endEdge->Next;
                endEdge = startEdge->Next;

                windingValue = startEdge->WindingDirection;
                while ((windingValue += endEdge->WindingDirection) != 0)
                    endEdge = endEdge->Next;
            }

            ASSERT((left < right) && (right < INT_MAX));

            Output->OutputSpan(yCurrent, left, right);
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    }
}

#ifdef BEZIER_FLATTEN_GDI_COMPATIBLE

// GDI flattens using an error of 2/3

// Flatten to an error of 2/3.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00002aa0L)

// Error of 2/3.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

#else

// Use a higher flattening tolerance. Turns out that 2/3 produces very 
// noticable artifacts on antialiased lines.

// Flatten to an error of 1/4.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00001000L)

// Error of 1/4.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

#endif

/**********************************Class***********************************\
* class HfdBasis32
*
*   Class for HFD vector objects.
*
* Public Interface:
*
*   vInit(p1, p2, p3, p4)       - Re-parameterizes the given control points
*                                 to our initial HFD error basis.
*   vLazyHalveStepSize(cShift)  - Does a lazy shift.  Caller has to remember
*                                 it changes 'cShift' by 2.
*   vSteadyState(cShift)        - Re-parameterizes to our working normal
*                                 error basis.
*
*   vTakeStep()                 - Forward steps to next sub-curve
*   vHalveStepSize()            - Adjusts down (subdivides) the sub-curve
*   vDoubleStepSize()           - Adjusts up the sub-curve
*   lError()                    - Returns error if current sub-curve were
*                                 to be approximated using a straight line
*                                 (value is actually multiplied by 6)
*   fxValue()                   - Returns rounded coordinate of first point in
*                                 current sub-curve.  Must be in steady
*                                 state.
*
* History:
*  10-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// The code is actually smaller when these methods are forced inline;
// this is one of the rare cases where 'forceinline' is warranted:

#define INLINE __forceinline

class HfdBasis32
{
private:
    LONG  e0;
    LONG  e1;
    LONG  e2;
    LONG  e3;

public:
    INLINE LONG lParentErrorDividedBy4() 
    { 
        return(max(abs(e3), abs(e2 + e2 - e3))); 
    }

    INLINE LONG lError()                 
    { 
        return(max(abs(e2), abs(e3))); 
    }

    INLINE INT fxValue()                
    { 
        return((e0 + (1L << 12)) >> 13); 
    }

    INLINE VOID vInit(INT p1, INT p2, INT p3, INT p4)
    {
    // Change basis and convert from 28.4 to 18.14 format:
    
        e0 = (p1                     ) << 10;
        e1 = (p4 - p1                ) << 10;
        e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
        e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
    }
    
    INLINE VOID vLazyHalveStepSize(LONG cShift)
    {
        e2 = (e2 + e3) >> 1;
        e1 = (e1 - (e2 >> cShift)) >> 1;
    }
    
    INLINE VOID vSteadyState(LONG cShift)
    {
    // We now convert from 18.14 fixed format to 15.17:
    
        e0 <<= 3;
        e1 <<= 3;
    
        register LONG lShift = cShift - 3;
    
        if (lShift < 0)
        {
            lShift = -lShift;
            e2 <<= lShift;
            e3 <<= lShift;
        }
        else
        {
            e2 >>= lShift;
            e3 >>= lShift;
        }
    }
    
    INLINE VOID vHalveStepSize()
    {
        e2 = (e2 + e3) >> 3;
        e1 = (e1 - e2) >> 1;
        e3 >>= 2;
    }
    
    INLINE VOID vDoubleStepSize()
    {
        e1 += e1 + e2;
        e3 <<= 2;
        e2 = (e2 << 3) - e3;
    }
    
    INLINE VOID vTakeStep()
    {
        e0 += e1;
        register LONG lTemp = e2;
        e1 += lTemp;
        e2 += lTemp - e3;
        e3 = lTemp;
    }
};

/**********************************Class***********************************\
* class Bezier32
*
*   Bezier cracker.
*
* A hybrid cubic Bezier curve flattener based on KirkO's error factor.
* Generates line segments fast without using the stack.  Used to flatten
* a path.
*
* For an understanding of the methods used, see:
*
*     Kirk Olynyk, "..."
*     Goossen and Olynyk, "System and Method of Hybrid Forward
*         Differencing to Render Bezier Splines"
*     Lien, Shantz and Vaughan Pratt, "Adaptive Forward Differencing for
*     Rendering Curves and Surfaces", Computer Graphics, July 1987
*     Chang and Shantz, "Rendering Trimmed NURBS with Adaptive Forward
*         Differencing", Computer Graphics, August 1988
*     Foley and Van Dam, "Fundamentals of Interactive Computer Graphics"
*
* Public Interface:
*
*   vInit(pptfx)                - pptfx points to 4 control points of
*                                 Bezier.  Current point is set to the first
*                                 point after the start-point.
*   Bezier32(pptfx)             - Constructor with initialization.
*   vGetCurrent(pptfx)          - Returns current polyline point.
*   bCurrentIsEndPoint()        - TRUE if current point is end-point.
*   vNext()                     - Moves to next polyline point.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class Bezier32
{
private:
    LONG       cSteps;
    HfdBasis32 x;
    HfdBasis32 y;
    RECT       rcfxBound;

public:
    BOOL bInit(const POINT* aptfx, const RECT*);
    INT cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore);
};

#define FRACTION64 28

class HfdBasis64
{
private:
    LONGLONG e0;
    LONGLONG e1;
    LONGLONG e2;
    LONGLONG e3;

public:
    VOID vInit(INT p1, INT p2, INT p3, INT p4);
    VOID vHalveStepSize();
    VOID vDoubleStepSize();
    VOID vTakeStep();
    VOID vUntransform(LONG* afx);

    VOID vParentError(LONGLONG* peq) const;
    VOID vError(LONGLONG* peq) const;
    INT fxValue() const;
};

class Bezier64
{
private:
    HfdBasis64 xLow;
    HfdBasis64 yLow;
    HfdBasis64 xHigh;
    HfdBasis64 yHigh;

    LONGLONG    eqErrorLow;
    RECT*       prcfxClip;
    RECT        rcfxClip;

    LONG        cStepsHigh;
    LONG        cStepsLow;

public:

    INT cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore);
    VOID vInit(const POINT* aptfx, const RECT* prcfx, const LONGLONG eq);
};

typedef struct _BEZIERCONTROLS {
    POINT ptfx[4];
} BEZIERCONTROLS;

inline VOID vBoundBox(const POINT* aptfx, RECT* prcfx)
{
    INT i;

    INT left = aptfx[0].x;
    INT right = aptfx[0].x;
    INT top = aptfx[0].y;
    INT bottom = aptfx[0].y;

    for (i = 1; i < 4; i++)
    {
        left = min(left, aptfx[i].x);
        top = min(top, aptfx[i].y);
        right = max(right, aptfx[i].x);
        bottom = max(bottom, aptfx[i].y);
    }

    // We make the bounds one pixel loose for the nominal width 
    // stroke case, which increases the bounds by half a pixel 
    // in every dimension:

    prcfx->left = left - 16;
    prcfx->top = top - 16;
    prcfx->right = right + 16;
    prcfx->bottom = bottom + 16;
}

BOOL bIntersect(
    const RECT *a,
    const RECT *b)
{
    return((a->left < b->right) &&
           (a->top < b->bottom) &&
           (a->right > b->left) &&
           (a->bottom > b->top));
}

BOOL Bezier32::bInit(
const POINT* aptfxBez,      // Pointer to 4 control points
const RECT* prcfxClip)      // Bound box of visible region (optional)
{
    POINT aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register INT fxOr;
        register INT fxOffset;

        fxOffset = rcfxBound.left;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.top;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECT*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

INT Bezier32::cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
{
    ASSERT(cptfx > 0);

    INT cptfxOriginal = cptfx;

    do {
    // Return current point:
    
        pptfx->x = x.fxValue() + rcfxBound.left;
        pptfx->y = y.fxValue() + rcfxBound.top;
        pptfx++;
    
    // If cSteps == 0, that was the end point in the curve!
    
        if (cSteps == 0)
        {
            *pbMore = FALSE;

            // '+1' because we haven't decremented 'cptfx' yet:

            return(cptfxOriginal - cptfx + 1);
        }
    
    // Okay, we have to step:
    
        if (max(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
        {
            x.vHalveStepSize();
            y.vHalveStepSize();
            cSteps <<= 1;
        }
    
        ASSERTMSG(max(x.lError(), y.lError()) <= TEST_MAGNITUDE_NORMAL,
                  ("Please tell AndrewGo he was wrong"));
    
        while (!(cSteps & 1) &&
               x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
               y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
        {
            x.vDoubleStepSize();
            y.vDoubleStepSize();
            cSteps >>= 1;
        }
    
        cSteps--;
        x.vTakeStep();
        y.vTakeStep();

    } while (--cptfx != 0);

    *pbMore = TRUE;
    return(cptfxOriginal);
}

///////////////////////////////////////////////////////////////////////////
// Bezier64
//
// All math is done using 64 bit fixed numbers in a 36.28 format.
//
// All drawing is done in a 31 bit space, then a 31 bit window offset
// is applied.  In the initial transform where we change to the HFD
// basis, e2 and e3 require the most bits precision: e2 = 6(p2 - 2p3 + p4).
// This requires an additional 4 bits precision -- hence we require 36 bits
// for the integer part, and the remaining 28 bits is given to the fraction.
//
// In rendering a Bezier, every 'subdivide' requires an extra 3 bits of
// fractional precision.  In order to be reversible, we can allow no
// error to creep in.  Since a INT coordinate is 32 bits, and we
// require an additional 4 bits as mentioned above, that leaves us
// 28 bits fractional precision -- meaning we can do a maximum of
// 9 subdivides.  Now, the maximum absolute error of a Bezier curve in 27
// bit integer space is 2^29 - 1.  But 9 subdivides reduces the error by a
// guaranteed factor of 2^18, meaning we can crack down only to an error
// of 2^11 before we overflow, when in fact we want to crack error to less
// than 1.
//
// So what we do is HFD until we hit an error less than 2^11, reverse our
// basis transform to get the four control points of this smaller curve
// (rounding in the process to 32 bits), then invoke another copy of HFD
// on the reduced Bezier curve.  We again have enough precision, but since
// its starting error is less than 2^11, we can reduce error to 2^-7 before
// overflowing!  We'll start a low HFD after every step of the high HFD.
////////////////////////////////////////////////////////////////////////////

// The following is our 2^11 target error encoded as a 36.28 number
// (don't forget the additional 4 bits of fractional precision!) and
// the 6 times error multiplier:

const LONGLONG geqErrorHigh = (LONGLONG)(6 * (1L << 15) >> (32 - FRACTION64)) << 32;

// The following is the default 2/3 error encoded as a 36.28 number,
// multiplied by 6, and leaving 4 bits for fraction:

const LONGLONG geqErrorLow = (LONGLONG)(4) << 32;

inline INT HfdBasis64::fxValue() const
{
// Convert from 36.28 and round:

    LONGLONG eq = e0;
    eq += (1L << (FRACTION64 - 1));
    eq >>= FRACTION64;
    return((INT) (LONG) eq);
}

#define MAX(a, b) ((a) >= (b) ? (a) : (b))
#define ABS(a) ((a) >= 0 ? (a) : -(a))

inline VOID HfdBasis64::vParentError(LONGLONG* peq) const
{
    *peq = MAX(ABS(e3 << 2), ABS((e2 << 3) - (e3 << 2)));
}

inline VOID HfdBasis64::vError(LONGLONG* peq) const
{
    *peq = MAX(ABS(e2), ABS(e3));
}

VOID HfdBasis64::vInit(INT p1, INT p2, INT p3, INT p4)
{
    LONGLONG eqTmp;
    LONGLONG eqP2 = (LONGLONG) p2;
    LONGLONG eqP3 = (LONGLONG) p3;

// e0 = p1
// e1 = p4 - p1
// e2 = 6(p2 - 2p3 + p4)
// e3 = 6(p1 - 2p2 + p3)

// Change basis:

    e0 = p1;                                        // e0 = p1
    e1 = p4;
    e2 = eqP2; e2 -= eqP3; e2 -= eqP3; e2 += e1;    // e2 = p2 - 2*p3 + p4
    e3 = e0;   e3 -= eqP2; e3 -= eqP2; e3 += eqP3;  // e3 = p1 - 2*p2 + p3
    e1 -= e0;                                       // e1 = p4 - p1

// Convert to 36.28 format and multiply e2 and e3 by six:

    e0 <<= FRACTION64;
    e1 <<= FRACTION64;
    eqTmp = e2; e2 += eqTmp; e2 += eqTmp; e2 <<= (FRACTION64 + 1);
    eqTmp = e3; e3 += eqTmp; e3 += eqTmp; e3 <<= (FRACTION64 + 1);
}

VOID HfdBasis64::vUntransform(LONG* afx)
{
// Declare some temps to hold our operations, since we can't modify e0..e3.

    LONGLONG eqP0;
    LONGLONG eqP1;
    LONGLONG eqP2;
    LONGLONG eqP3;

// p0 = e0
// p1 = e0 + (6e1 - e2 - 2e3)/18
// p2 = e0 + (12e1 - 2e2 - e3)/18
// p3 = e0 + e1

    eqP0 = e0;

// NOTE PERF: Convert this to a multiply by 6: [andrewgo]

    eqP2 = e1;
    eqP2 += e1;
    eqP2 += e1;
    eqP1 = eqP2;
    eqP1 += eqP2;           // 6e1
    eqP1 -= e2;             // 6e1 - e2
    eqP2 = eqP1;
    eqP2 += eqP1;           // 12e1 - 2e2
    eqP2 -= e3;             // 12e1 - 2e2 - e3
    eqP1 -= e3;
    eqP1 -= e3;             // 6e1 - e2 - 2e3

// NOTE: May just want to approximate these divides! [andrewgo]
// Or can do a 64 bit divide by 32 bit to get 32 bits right here.

    eqP1 /= 18;
    eqP2 /= 18;
    eqP1 += e0;
    eqP2 += e0;

    eqP3 = e0;
    eqP3 += e1;

// Convert from 36.28 format with rounding:

    eqP0 += (1L << (FRACTION64 - 1)); eqP0 >>= FRACTION64; afx[0] = (LONG) eqP0;
    eqP1 += (1L << (FRACTION64 - 1)); eqP1 >>= FRACTION64; afx[2] = (LONG) eqP1;
    eqP2 += (1L << (FRACTION64 - 1)); eqP2 >>= FRACTION64; afx[4] = (LONG) eqP2;
    eqP3 += (1L << (FRACTION64 - 1)); eqP3 >>= FRACTION64; afx[6] = (LONG) eqP3;
}

VOID HfdBasis64::vHalveStepSize()
{
// e2 = (e2 + e3) >> 3
// e1 = (e1 - e2) >> 1
// e3 >>= 2

    e2 += e3; e2 >>= 3;
    e1 -= e2; e1 >>= 1;
    e3 >>= 2;
}

VOID HfdBasis64::vDoubleStepSize()
{
// e1 = 2e1 + e2
// e3 = 4e3;
// e2 = 8e2 - e3

    e1 <<= 1; e1 += e2;
    e3 <<= 2;
    e2 <<= 3; e2 -= e3;
}

VOID HfdBasis64::vTakeStep()
{
    e0 += e1;
    LONGLONG eqTmp = e2;
    e1 += e2;
    e2 += eqTmp; e2 -= e3;
    e3 = eqTmp;
}

VOID Bezier64::vInit(
const POINT*    aptfx,        // Pointer to 4 control points
const RECT*     prcfxVis,     // Pointer to bound box of visible area (may be NULL)
LONGLONG        eqError)      // Fractional maximum error (32.32 format)
{
    LONGLONG eqTmp;

    cStepsHigh = 1;
    cStepsLow  = 0;

    xHigh.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    yHigh.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

// Initialize error:

    eqErrorLow = eqError;

    if (prcfxVis == (RECT*) NULL)
        prcfxClip = (RECT*) NULL;
    else
    {
        rcfxClip = *prcfxVis;
        prcfxClip = &rcfxClip;
    }

    while (((xHigh.vError(&eqTmp), eqTmp) > geqErrorHigh) ||
           ((yHigh.vError(&eqTmp), eqTmp) > geqErrorHigh))
    {
        cStepsHigh <<= 1;
        xHigh.vHalveStepSize();
        yHigh.vHalveStepSize();
    }
}

INT Bezier64::cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
{
    POINT    aptfx[4];
    RECT     rcfxBound;
    LONGLONG eqTmp;
    INT      cptfxOriginal = cptfx;

    ASSERT(cptfx > 0);

    do {
        if (cStepsLow == 0)
        {
        // Optimization that if the bound box of the control points doesn't
        // intersect with the bound box of the visible area, render entire
        // curve as a single line:
    
            xHigh.vUntransform(&aptfx[0].x);
            yHigh.vUntransform(&aptfx[0].y);
    
            xLow.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
            yLow.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);
            cStepsLow = 1;
    
            if (prcfxClip != (RECT*) NULL)
                vBoundBox(aptfx, &rcfxBound);
    
            if (prcfxClip == (RECT*) NULL || bIntersect(&rcfxBound, prcfxClip))
            {
                while (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
                       ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
                {
                    cStepsLow <<= 1;
                    xLow.vHalveStepSize();
                    yLow.vHalveStepSize();
                }
            }
    
        // This 'if' handles the case where the initial error for the Bezier
        // is already less than the target error:
    
            if (--cStepsHigh != 0)
            {
                xHigh.vTakeStep();
                yHigh.vTakeStep();
    
                if (((xHigh.vError(&eqTmp), eqTmp) > geqErrorHigh) ||
                    ((yHigh.vError(&eqTmp), eqTmp) > geqErrorHigh))
                {
                    cStepsHigh <<= 1;
                    xHigh.vHalveStepSize();
                    yHigh.vHalveStepSize();
                }
    
                while (!(cStepsHigh & 1) &&
                       ((xHigh.vParentError(&eqTmp), eqTmp) <= geqErrorHigh) &&
                       ((yHigh.vParentError(&eqTmp), eqTmp) <= geqErrorHigh))
                {
                    xHigh.vDoubleStepSize();
                    yHigh.vDoubleStepSize();
                    cStepsHigh >>= 1;
                }
            }
        }
    
        xLow.vTakeStep();
        yLow.vTakeStep();
    
        pptfx->x = xLow.fxValue();
        pptfx->y = yLow.fxValue();
        pptfx++;
    
        cStepsLow--;
        if (cStepsLow == 0 && cStepsHigh == 0)
        {
            *pbMore = FALSE;

            // '+1' because we haven't decremented 'cptfx' yet:

            return(cptfxOriginal - cptfx + 1);
        }
    
        if (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
            ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
        {
            cStepsLow <<= 1;
            xLow.vHalveStepSize();
            yLow.vHalveStepSize();
        }
    
        while (!(cStepsLow & 1) &&
               ((xLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow) &&
               ((yLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow))
        {
            xLow.vDoubleStepSize();
            yLow.vDoubleStepSize();
            cStepsLow >>= 1;
        }

    } while (--cptfx != 0);

    *pbMore = TRUE;
    return(cptfxOriginal);
}

/**********************************Class***********************************\
* class BEZIER
*
* Bezier cracker.  Flattens any Bezier in our 28.4 device space down
* to a smallest 'error' of 2^-7 = 0.0078.  Will use fast 32 bit cracker
* for small curves and slower 64 bit cracker for big curves.
*
* Public Interface:
*
*   vInit(aptfx, prcfxClip, peqError)
*       - pptfx points to 4 control points of Bezier.  The first point
*         retrieved by bNext() is the the first point in the approximation
*         after the start-point.
*
*       - prcfxClip is an optional pointer to the bound box of the visible
*         region.  This is used to optimize clipping of Bezier curves that
*         won't be seen.  Note that this value should account for the pen's
*         width!
*
*       - optional maximum error in 32.32 format, corresponding to Kirko's
*         error factor.
*
*   bNext(pptfx)
*       - pptfx points to where next point in approximation will be
*         returned.  Returns FALSE if the point is the end-point of the
*         curve.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class BEZIER
{
private:

    union
    {
        Bezier64 bez64;
        Bezier32 bez32;
    } bez;

    BOOL bBez32;

public:

// All coordinates must be in 28.4 format:

    BEZIER(const POINT* aptfx, const RECT* prcfxClip)
    {
        bBez32 = bez.bez32.bInit(aptfx, prcfxClip);
        if (!bBez32)
            bez.bez64.vInit(aptfx, prcfxClip, geqErrorLow);
    }

    INT Flatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
    {
        if (bBez32)
        {
            return(bez.bez32.cFlatten(pptfx, cptfx, pbMore));
        }
        else
        {
            return(bez.bez64.cFlatten(pptfx, cptfx, pbMore));
        }
    }
};                                  

/**************************************************************************\
*
* Function Description:
*
*   Clip the edge vertically.
*
*   We've pulled this routine out-of-line from InitializeEdges mainly
*   because it needs to call inline Asm, and when there is in-line
*   Asm in a routine the compiler generally does a much less efficient
*   job optimizing the whole routine.  InitializeEdges is rather 
*   performance critical, so we avoid polluting the whole routine 
*   by having this functionality out-of-line.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
ClipEdge(
    EpEdge *edgeBuffer,
    INT yClipTopInteger,
    INT dMOriginal
    )
{
    INT xDelta;
    INT error;

    // Cases where bigNumerator will exceed 32-bits in precision
    // will be rare, but could happen, and we can't fall over
    // in those cases.

    INT dN = edgeBuffer->ErrorDown;
    LONGLONG bigNumerator = Int32x32To64(dMOriginal, 
                                         yClipTopInteger - edgeBuffer->StartY)
                          + (edgeBuffer->Error + dN);
    if (bigNumerator >= 0)
    {
        QUOTIENT_REMAINDER_64_32(bigNumerator, dN, xDelta, error);
    }
    else
    {
        bigNumerator = -bigNumerator;
        QUOTIENT_REMAINDER_64_32(bigNumerator, dN, xDelta, error);

        xDelta = -xDelta;
        if (error != 0)
        {
            xDelta--;
            error = dN - error;
        }
    }

    // Update the edge data structure with the results:

    edgeBuffer->StartY  = yClipTopInteger;
    edgeBuffer->X      += xDelta;
    edgeBuffer->Error   = error - dN;      // Renormalize error
}

/**************************************************************************\
*
* Function Description:
*
*   Add edges to the edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
InitializeEdges(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath      // not used
    )
{
    INT xStart;
    INT yStart;
    INT yStartInteger;
    INT yEndInteger;
    INT dMOriginal;
    INT dM;
    INT dN;
    INT dX;
    INT errorUp;
    INT quotient;
    INT remainder;
    INT error;
    LONGLONG bigNumerator;
    INT littleNumerator;
    INT windingDirection;
    EpEdge *edgeBuffer;
    EpEdge *endEdge;
    INT bufferCount;
    INT yClipTopInteger;
    INT yClipTop;
    INT yClipBottom;
    INT xClipLeft;
    INT xClipRight;

    EpInitializeEdgesContext *edgeContext = static_cast<EpInitializeEdgesContext*>(context);
    INT yMax = edgeContext->MaxY;
    EpEdgeStore *store = edgeContext->Store;
    RECT *clipRect = edgeContext->ClipRect;

    INT edgeCount = vertexCount - 1;
    ASSERT(edgeCount >= 1);

    if (clipRect == NULL)
    {
        yClipBottom = 0;
        yClipTopInteger = INT_MIN >> AA_Y_SHIFT;   
    }
    else
    {
        yClipTopInteger = clipRect->top >> 4;
        yClipTop = clipRect->top;
        yClipBottom = clipRect->bottom;
        xClipLeft = clipRect->left;
        xClipRight = clipRect->right;

        ASSERT(yClipBottom > 0);
        ASSERT(yClipTop <= yClipBottom);
    }

    if (edgeContext->IsAntialias)
    {
        // If antialiasing, apply the supersampling scaling here before we
        // calculate the DDAs.  We do this here and not in the Matrix
        // transform we give to FixedPointPathEnumerate mainly so that the
        // Bezier flattener can continue to operate in its optimal 28.4
        // format.  
        //
        // We also apply a half-pixel offset here so that the antialiasing
        // code can assume that the pixel centers are at half-pixel
        // coordinates, not on the integer coordinates.

        POINT *point = pointArray;
        INT i = vertexCount;

        do {
            point->x = (point->x + 8) << AA_X_SHIFT;
            point->y = (point->y + 8) << AA_Y_SHIFT;

        } while (point++, --i != 0);

        yClipTopInteger <<= AA_Y_SHIFT;
        yClipTop <<= AA_Y_SHIFT;
        yClipBottom <<= AA_Y_SHIFT;
        xClipLeft <<= AA_X_SHIFT;
        xClipRight <<= AA_X_SHIFT;
    }

    // Make 'yClipBottom' inclusive by subtracting off one pixel
    // (keeping in mind that we're in 28.4 device space):

    yClipBottom -= 16;

    // Warm up the store where we keep the edge data:

    store->StartAddBuffer(&edgeBuffer, &bufferCount);

    do {
        // Handle trivial rejection:

        if (yClipBottom >= 0)
        {
            // Throw out any edges that are above or below the clipping.
            // This has to be a precise check, because we assume later
            // on that every edge intersects in the vertical dimension 
            // with the clip rectangle.  That asssumption is made in two 
            // places:
            //
            // 1.  When we sort the edges, we assume either zero edges,
            //     or two or more.
            // 2.  When we start the DDAs, we assume either zero edges,
            //     or that there's at least one scan of DDAs to output.
            //
            // Plus, of course, it's less efficient if we let things
            // through.
            //
            // Note that 'yClipBottom' is inclusive:

            BOOL clipHigh = ((pointArray)->y <= yClipTop) &&
                            ((pointArray + 1)->y <= yClipTop);

            BOOL clipLow = ((pointArray)->y > yClipBottom) &&
                             ((pointArray + 1)->y > yClipBottom);

            #if DBG
            {
                INT yRectTop, yRectBottom, y0, y1, yTop, yBottom;

                // Getting the trivial rejection code right is tricky.  
                // So on checked builds let's verify that we're doing it 
                // correctly, using a different approach:

                BOOL clipped = FALSE;
                if (clipRect != NULL)
                {
                    yRectTop = clipRect->top >> 4;
                    yRectBottom = clipRect->bottom >> 4;
                    if (edgeContext->IsAntialias)
                    {
                        yRectTop <<= AA_Y_SHIFT;
                        yRectBottom <<= AA_Y_SHIFT;
                    }
                    y0 = ((pointArray)->y + 15) >> 4;
                    y1 = ((pointArray + 1)->y + 15) >> 4;
                    yTop = min(y0, y1);
                    yBottom = max(y0, y1);

                    clipped = ((yTop >= yRectBottom) || (yBottom <= yRectTop));
                }

                ASSERT(clipped == (clipHigh || clipLow));
            }
            #endif

            if (clipHigh || clipLow)
                continue;               // ======================>

            if (edgeCount > 1)
            {
                // Here we'll collapse two edges down to one if both are
                // to the left or to the right of the clipping rectangle.
    
                if (((pointArray)->x < xClipLeft) &&
                    ((pointArray + 1)->x < xClipLeft) &&
                    ((pointArray + 2)->x < xClipLeft))
                {
                    // Note this is one reason why 'pointArray' can't be 'const':

                    *(pointArray + 1) = *(pointArray);

                    continue;           // ======================>
                }

                if (((pointArray)->x > xClipRight) &&
                    ((pointArray + 1)->x > xClipRight) &&
                    ((pointArray + 2)->x > xClipRight))
                {
                    // Note this is one reason why 'pointArray' can't be 'const':

                    *(pointArray + 1) = *(pointArray);

                    continue;           // ======================>
                }
            }
        
        }

        dM = (pointArray + 1)->x - (pointArray)->x;
        dN = (pointArray + 1)->y - (pointArray)->y;
    
        if (dN >= 0)
        {
            // The vector points downward:

            xStart = (pointArray)->x;
            yStart = (pointArray)->y;

            yStartInteger = (yStart + 15) >> 4;
            yEndInteger   = ((pointArray + 1)->y + 15) >> 4;

            windingDirection = 1;
        }
        else
        {
            // The vector points upward, so we have to essentially
            // 'swap' the end points:

            dN = -dN;
            dM = -dM;
    
            xStart = (pointArray + 1)->x;
            yStart = (pointArray + 1)->y;

            yStartInteger = (yStart + 15) >> 4;
            yEndInteger   = ((pointArray)->y + 15) >> 4;

            windingDirection = -1;
        }

        // The edgeBuffer must span an integer y-value in order to be 
        // added to the edgeBuffer list.  This serves to get rid of 
        // horizontal edges, which cause trouble for our divides.

        if (yEndInteger > yStartInteger)
        {
            yMax = max(yMax, yEndInteger);

            dMOriginal = dM;
            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)            // Can't be '<='
                {
                    dX      = -1;
                    errorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, quotient, remainder);
        
                    dX      = -quotient;
                    errorUp = remainder;
                    if (remainder > 0)
                    {
                        dX      = -quotient - 1;
                        errorUp = dN - remainder;
                    }
                }
            }
            else
            {
                if (dM < dN)
                {
                    dX      = 0;
                    errorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, quotient, remainder);
        
                    dX      = quotient;
                    errorUp = remainder;
                }
            }
        
            error = -1;     // Error is initially zero (add dN - 1 for       
                            //   the ceiling, but subtract off dN so that    
                            //   we can check the sign instead of comparing  
                            //   to dN)                                      
        
            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate
        
                for (INT i = 16 - (yStart & 15); i != 0; i--)
                {
                    xStart += dX;
                    error += errorUp;
                    if (error >= 0)
                    {
                        error -= dN;
                        xStart++;
                    }
                }
            }
        
            if ((xStart & 15) != 0)
            {
                error -= dN * (16 - (xStart & 15));
                xStart += 15;       // We'll want the ceiling in just a bit...
            }

            xStart >>= 4;
            error >>= 4;

            if (bufferCount == 0)
            {
                if (!store->NextAddBuffer(&edgeBuffer, &bufferCount))
                    return(FALSE);
            }

            edgeBuffer->X                = xStart;
            edgeBuffer->Dx               = dX;
            edgeBuffer->Error            = error;
            edgeBuffer->ErrorUp          = errorUp;
            edgeBuffer->ErrorDown        = dN;
            edgeBuffer->WindingDirection = windingDirection;
            edgeBuffer->StartY           = yStartInteger;
            edgeBuffer->EndY             = yEndInteger;       // Exclusive of end

            // Here we handle the case where the edge starts above the
            // clipping rectangle, and we need to jump down in the 'y'
            // direction to the first unclipped scan-line.
            //
            // Consequently, we advance the DDA here:

            if (yClipTopInteger > yStartInteger)
            {
                ASSERT(edgeBuffer->EndY > yClipTopInteger);

                ClipEdge(edgeBuffer, yClipTopInteger, dMOriginal);
            }

            // Advance to handle the next edge:

            edgeBuffer++;
            bufferCount--;
        }
    } while (pointArray++, --edgeCount != 0);

    // We're done with this batch.  Let the store know how many edges
    // we ended up with:

    store->EndAddBuffer(edgeBuffer, bufferCount);

    edgeContext->MaxY = yMax;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the line from point[1] to point[2] turns 'left'
*   from the line from point[0] to point[1].  Uses the sign of the
*   cross product.
*
*   Remember that we're in device space, where positive 'y' is down!
*
* Created:
*
*   04/09/2000 andrewgo
*
\**************************************************************************/

inline
BOOL
TurnLeft(
    const POINT *points
    )
{
    LONGLONG ad = Int32x32To64(points[1].x - points[0].x,
                               points[2].y - points[1].y);
    LONGLONG bc = Int32x32To64(points[1].y - points[0].y,
                               points[2].x - points[1].x);

    return(ad < bc);
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the index of the NominalDrawVertex table to be use as the
*   drawing vertex.  The result is numbered such that a traversal using
*   an increasing pointer will go counter-clockwise around the pen.
*
* Created:
*
*   04/09/2000 andrewgo
*
\**************************************************************************/

POINT NominalDrawVertex[] = 
{
    // Don't forget that in device space, positive 'y' is down:

    {0,  -8},
    {-8, 0},
    {0,  8},
    {8,  0}
};

INT OctantToDrawVertexTranslate[] =
{
    0, 2, 0, 2, 3, 3, 1, 1
};

inline
INT
ComputeDrawVertex(
    const POINT* points
    )
{
    INT dx = points[1].x - points[0].x;
    INT dy = points[1].y - points[0].y;
    INT octant = 0;

    if (dx < 0)
    {
        octant |= 1;
        dx = -dx;
    }
    if (dy < 0)
    {
        octant |= 2;
        dy = -dy;
    }
    if (dy > dx)
    {
        octant |= 4;
    }

    return(OctantToDrawVertexTranslate[octant]);
}

/**************************************************************************\
*
* Function Description:
*
*   Routine for nominal-width lines that generates a fast outline to
*   be filled by the fill code.
*
*   The resulting fill must always be done in winding mode.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
InitializeNominal(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath     
    )
{
    POINT leftBuffer[NOMINAL_FILL_POINT_NUMBER];
    POINT rightBuffer[NOMINAL_FILL_POINT_NUMBER];
    POINT lastPoint;
    INT iDraw;
    INT iNewDraw;
    INT xStart;
    INT yStart;
    INT xEnd;
    INT yEnd;
    INT xPerp;
    INT yPerp;
    BOOL isLeftTurn;
    INT iNext;

    POINT *rightStartPlus3 = rightBuffer + 3;
    POINT *rightEnd = rightBuffer + NOMINAL_FILL_POINT_NUMBER;
    POINT *leftStart = leftBuffer;
    POINT *leftEndMinus3 = leftBuffer + NOMINAL_FILL_POINT_NUMBER - 3;
    POINT *left = leftStart;
    POINT *right = rightEnd;

    INT lineCount = vertexCount - 1;

    iDraw = ComputeDrawVertex(pointArray);

    // Add start cap:

    xStart = (pointArray)->x;
    yStart = (pointArray)->y;
    (left)->x = xStart - NominalDrawVertex[iDraw].x;
    (left)->y = yStart - NominalDrawVertex[iDraw].y;
    (left + 1)->x = xStart + NominalDrawVertex[(iDraw + 1) & 3].x;
    (left + 1)->y = yStart + NominalDrawVertex[(iDraw + 1) & 3].y;
    left += 2;

    while (TRUE)
    {
        if (left >= leftEndMinus3)
        {
            lastPoint = *(left - 1);

            if (!InitializeEdges(context, 
                                 leftBuffer, 
                                 static_cast<INT>(left - leftBuffer),
                                 lastSubpath))
            {
                return(FALSE);
            }

            *(leftStart) = lastPoint;
            left = leftStart + 1;
        }
        if (right < rightStartPlus3)
        {
            lastPoint = *right;

            if (!InitializeEdges(context,
                                 right,
                                 static_cast<INT>(rightEnd - right),
                                 lastSubpath))
            {
                return(FALSE);
            }

            *(rightEnd - 1) = lastPoint;
            right = rightEnd - 1;
        }

        xStart = (pointArray)->x;
        yStart = (pointArray)->y;
        xEnd = (pointArray + 1)->x;
        yEnd = (pointArray + 1)->y;
        xPerp = NominalDrawVertex[iDraw].x;
        yPerp = NominalDrawVertex[iDraw].y;

        (left)->x = xStart + xPerp;
        (left)->y = yStart + yPerp;
        (right - 1)->x = xStart - xPerp;
        (right - 1)->y = yStart - yPerp;
        (left + 1)->x = xEnd + xPerp;
        (left + 1)->y = yEnd + yPerp;
        (right - 2)->x = xEnd - xPerp;
        (right - 2)->y = yEnd - yPerp;

        left += 2;
        right -= 2;

        pointArray++;
        if (--lineCount == 0)
            break;

        // Darn, we have to handle a join:

        iNewDraw = ComputeDrawVertex(pointArray);
        if (iNewDraw != iDraw)
        {
            isLeftTurn = TurnLeft(pointArray - 1);
            if (isLeftTurn)
            {
                iNext = (iDraw + 1) & 3;
                if (iNewDraw != iNext)
                {
                    (right - 1)->x = xEnd - NominalDrawVertex[iNext].x;
                    (right - 1)->y = yEnd - NominalDrawVertex[iNext].y;
                    right--;
                }

                (left)->x = xEnd;
                (left)->y = yEnd;
                left++;
            }
            else // We're turning 'right':
            {
                iNext = (iDraw - 1) & 3;
                if (iNewDraw != iNext)
                {
                    (left)->x = xEnd + NominalDrawVertex[iNext].x;
                    (left)->y = yEnd + NominalDrawVertex[iNext].y;
                    left++;
                }

                (right - 1)->x = xEnd;
                (right - 1)->y = yEnd;
                right--;
            }
        }

        ASSERT(left <= &leftBuffer[NOMINAL_FILL_POINT_NUMBER]);
        ASSERT(right >= &rightBuffer[0]);

        iDraw = iNewDraw;
    }

    // Add end cap:

    if (left >= leftEndMinus3)
    {
        lastPoint = *(left - 1);

        if (!InitializeEdges(context, 
                             leftBuffer, 
                             static_cast<INT>(left - leftBuffer),
                             lastSubpath))
        {
            return(FALSE);
        }

        *(leftStart) = lastPoint;
        left = leftStart + 1;
    }

    xStart = (pointArray)->x;
    yStart = (pointArray)->y;
    (left)->x = xStart + NominalDrawVertex[(iDraw - 1) & 3].x;
    (left)->y = yStart + NominalDrawVertex[(iDraw - 1) & 3].y;
    (left + 1)->x = xStart - NominalDrawVertex[iDraw].x;
    (left + 1)->y = yStart - NominalDrawVertex[iDraw].y;
    left += 2;

    // Flush the left batch.  Since we just added an end cap, we
    // know there's more than one vertex in there:

    if (!InitializeEdges(context, 
                         leftBuffer, 
                         static_cast<INT>(left - leftBuffer),
                         lastSubpath))
    {
        return(FALSE);
    }

    // Don't flush the right buffer if there's only one point in there,
    // because one point doesn't make an edge.  

    INT count = static_cast<INT>(rightEnd - right);
    if (count > 1)
    {
        if (!InitializeEdges(context, right, count, lastSubpath))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Does complete parameter checking on the 'types' array of a path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
ValidatePathTypes(
    const BYTE *typesArray,
    INT count
    )
{
    BYTE type;
    const BYTE *types = typesArray;

    if (count == 0)
        return(TRUE);

    while (TRUE)
    {
        // The first point in every subpath has to be an unadorned
        // 'start' point:
    
        if ((*types & PathPointTypePathTypeMask) != PathPointTypeStart)
        {
            WARNING(("Bad subpath start"));
            return(FALSE);
        }
    
        // Advance to the first point after the 'start' point:
    
        types++;
        if (--count == 0)
        {
            WARNING(("Path ended after start-path"));
            return(FALSE);
        }
    
        if ((*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            WARNING(("Can't have a start followed by a start!"));
            return(FALSE);
        }
    
        // Swallow up runs of lines and Bezier curves:
    
        do {
            switch(*types & PathPointTypePathTypeMask)
            {
            case PathPointTypeLine:
                types++;
                if (--count == 0)
                    return(TRUE);
    
                break;
    
            case PathPointTypeBezier:
                if(count < 3)
                {
                    WARNING(("Path ended before multiple of 3 Bezier points"));
                    return(FALSE);
                }

                if((*types & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Can't have a close on the first Bezier vertex"));
                    return(FALSE);
                }
    
                if((*(types + 1) & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Expected plain Bezier control point for 3rd vertex"));
                    return(FALSE);
                }
    
                if((*(types + 2) & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Expected Bezier control point for 4th vertex"));
                    return(FALSE);
                }
    
                types += 3;
                if ((count -= 3) == 0)
                    return(TRUE);
    
                break;
    
            default:
                WARNING(("Illegal type"));
                return(FALSE);
            }

            // A close-subpath marker or a start-subpath marker marks the
            // end of a subpath:

        } while (!(*(types - 1) & PathPointTypeCloseSubpath) &&
                  ((*types & PathPointTypePathTypeMask) != PathPointTypeStart));
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
AssertPath(
    const DpPath *path
    )
{
    // Make sure that the 'types' array is well-formed, otherwise we
    // may fall over in the FixedPointPathEnumerate function.
    //
    // NOTE: If you hit this assert, DO NOT SIMPLY COMMENT THIS ASSERT OUT!
    //
    //       Instead, fix the ValidatePathTypes code if it's letting through
    //       valid paths, or (more likely) fix the code that's letting bogus
    //       paths through.  The FixedPointPathEnumerate routine has some 
    //       subtle assumptions that require the path to be perfectly valid!
    //
    //       No internal code should be producing invalid paths, and all
    //       paths created by the application must be parameter checked!

    ASSERT(ValidatePathTypes(path->GetPathTypes(), path->GetPointCount()));
}

/**************************************************************************\
*
* Function Description:
*
*   Enumerate the path.
*
*   NOTE: The 'enumerateFunction' function is allowed to modify the
*         contents of our call-back buffer!  (This is mainly done
*         to allow 'InitializeEdges' to be simpler for some clipping trivial
*         rejection cases.)
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL 
FixedPointPathEnumerate(
    const DpPath *path,
    const GpMatrix *matrix,
    const RECT *clipRect,       // In scaled 28.4 format
    PathEnumerateType enumType, // Fill, stroke or for flattening.
    FIXEDPOINTPATHENUMERATEFUNCTION enumerateFunction,
    VOID *enumerateContext
    )
{
    POINT bufferStart[ENUMERATE_BUFFER_NUMBER];
    POINT bezierBuffer[4];
    POINT *buffer;
    INT bufferSize;
    POINT startFigure;
    INT iStart;
    INT iEnd;
    INT runSize;
    INT thisCount;
    BOOL isMore;
    RECT scaledClip;
    INT xLast;
    INT yLast;

    ASSERTPATH(path);

    INT pathCount = path->GetPointCount();
    const PointF *pathPoint = path->GetPathPoints();
    const BYTE *pathType = path->GetPathTypes();

    // Every valid subpath has at least two vertices in it, hence the
    // check of 'pathCount - 1':

    iStart = 0;
    while (iStart < pathCount - 1)
    {
        ASSERT((pathType[iStart] & PathPointTypePathTypeMask)
                    == PathPointTypeStart);
        ASSERT((pathType[iStart + 1] & PathPointTypePathTypeMask)
                    != PathPointTypeStart);

        // Add the start point to the beginning of the batch, and
        // remember it for handling the close figure:

        matrix->Transform(&pathPoint[iStart], &startFigure, 1);

        bufferStart[0].x = startFigure.x;
        bufferStart[0].y = startFigure.y;
        buffer = bufferStart + 1;
        bufferSize = ENUMERATE_BUFFER_NUMBER - 1;

        // We need to enter our loop with 'iStart' pointing one past
        // the start figure:

        iStart++;

        do {
            // Try finding a run of lines:
    
            if ((pathType[iStart] & PathPointTypePathTypeMask) 
                                == PathPointTypeLine)
            {
                iEnd = iStart + 1;
    
                while ((iEnd < pathCount) && 
                       ((pathType[iEnd] & PathPointTypePathTypeMask) 
                                == PathPointTypeLine))
                {
                    iEnd++;
                }

                // Okay, we've found a run of lines.  Break it up into our 
                // buffer size:
    
                runSize = (iEnd - iStart);
                do {
                    thisCount = min(bufferSize, runSize);
                    matrix->Transform(&pathPoint[iStart], buffer, thisCount);
    
                    iStart += thisCount;
                    buffer += thisCount;
                    runSize -= thisCount;
                    bufferSize -= thisCount;
    
                    if (bufferSize > 0)
                        break;
    
                    xLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].x;
                    yLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].y;
                    if (!(enumerateFunction)(
                        enumerateContext, 
                        bufferStart, 
                        ENUMERATE_BUFFER_NUMBER,
                        PathEnumerateContinue
                    ))
                    {
                        return(FALSE);
                    }
    
                    // Continue the last vertex as the first in the new batch:
    
                    bufferStart[0].x = xLast;
                    bufferStart[0].y = yLast;
                    buffer = bufferStart + 1;
                    bufferSize = ENUMERATE_BUFFER_NUMBER - 1;

                } while (runSize != 0);
            }
            else
            {
                ASSERT(iStart + 3 <= pathCount);
                ASSERT((pathType[iStart] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
                ASSERT((pathType[iStart + 1] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
                ASSERT((pathType[iStart + 2] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
    
                matrix->Transform(&pathPoint[iStart - 1], bezierBuffer, 4);
    
                // Prepare for the next iteration:
    
                iStart += 3;

                // Crack that Bezier:
    
                BEZIER bezier(bezierBuffer, clipRect);
                do {
                    thisCount = bezier.Flatten(buffer, bufferSize, &isMore);
    
                    buffer += thisCount;
                    bufferSize -= thisCount;

                    if (bufferSize > 0)
                        break;

                    xLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].x;
                    yLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].y;
                    if (!(enumerateFunction)(
                        enumerateContext, 
                        bufferStart, 
                        ENUMERATE_BUFFER_NUMBER,
                        PathEnumerateContinue
                    ))
                    {
                        return(FALSE);
                    }

                    // Continue the last vertex as the first in the new batch:

                    bufferStart[0].x = xLast;
                    bufferStart[0].y = yLast;
                    buffer = bufferStart + 1;
                    bufferSize = ENUMERATE_BUFFER_NUMBER - 1;
    
                } while (isMore);
            }

        } while ((iStart < pathCount) &&
                 ((pathType[iStart] & PathPointTypePathTypeMask) 
                    != PathPointTypeStart));

        // Okay, the subpath is done.  But we still have to handle the
        // 'close figure' (which is implicit for a fill):
        bool isClosed = (
            (enumType == PathEnumerateTypeFill) || 
            (pathType[iStart - 1] & PathPointTypeCloseSubpath));

        if (isClosed)
        {
            // Add the close-figure point:

            buffer->x = startFigure.x;
            buffer->y = startFigure.y;
            bufferSize--;
        }

        // We have to flush anything we might have in the batch, unless 
        // there's only one vertex in there!  (The latter case may happen
        // for the stroke case with no close figure if we just flushed a 
        // batch.)
        // If we're flattening, we must call the one additional time to 
        // correctly handle closing the subpath, even if there is only
        // one entry in the batch. The flattening callback handles the
        // one point case and closes the subpath properly without adding
        // extraneous points.

        INT verticesInBatch = ENUMERATE_BUFFER_NUMBER - bufferSize;
        if ((verticesInBatch > 1) || (enumType == PathEnumerateTypeFlatten))
        {
            // because we always exit the above loops if the buffer contains
            // some data, and if it contains nothing, we add a final element,
            // verticesInBatch should always be at least one.
            // If we're flattening, we will sometimes enter here with 
            // verticesInBatch==1, but it should never be zero or less.
           
            ASSERT(verticesInBatch >= 1);
            
            if (!(enumerateFunction)(
                enumerateContext, 
                bufferStart, 
                verticesInBatch,
                isClosed ? PathEnumerateCloseSubpath : PathEnumerateEndSubpath
            ))
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   We want to sort in the inactive list; the primary key is 'y', and
*   the secondary key is 'x'.  This routine creates a single LONGLONG
*   key that represents both.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

inline VOID YX(INT x, INT y, LONGLONG *p)
{
    // Bias 'x' by INT_MAX so that it's effectively unsigned:

    reinterpret_cast<LARGE_INTEGER*>(p)->HighPart = y;
    reinterpret_cast<LARGE_INTEGER*>(p)->LowPart = x + INT_MAX;
}

/**************************************************************************\
*
* Function Description:
*
*   Recursive function to quick-sort our inactive edge list.  Note that
*   for performance, the results are not completely sorted; an insertion 
*   sort has to be run after the quicksort in order to do a lighter-weight
*   sort of the subtables.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

#define QUICKSORT_THRESHOLD 8

VOID
QuickSortEdges(
    EpInactiveEdge *f,
    EpInactiveEdge *l
    )
{
    EpEdge *e;
    LONGLONG y;
    LONGLONG first;
    LONGLONG second;
    LONGLONG last;

    // Find the median of the first, middle, and last elements:

    EpInactiveEdge *m = f + ((l - f) >> 1);

    SWAP(y, (f + 1)->Yx, m->Yx);
    SWAP(e, (f + 1)->Edge, m->Edge);

    if ((second = (f + 1)->Yx) > (last = l->Yx))
    {
        (f + 1)->Yx = last;
        l->Yx = second;

        SWAP(e, (f + 1)->Edge, l->Edge);
    }
    if ((first = f->Yx) > (last = l->Yx))
    {
        f->Yx = last;
        l->Yx = first;

        SWAP(e, f->Edge, l->Edge);
    }
    if ((second = (f + 1)->Yx) > (first = f->Yx))
    {
        (f + 1)->Yx = first;
        f->Yx = second;

        SWAP(e, (f + 1)->Edge, f->Edge);
    }

    // f->Yx is now the desired median, and (f + 1)->Yx <= f->Yx <= l->Yx

    ASSERT(((f + 1)->Yx <= f->Yx) && (f->Yx <= l->Yx));

    LONGLONG median = f->Yx;

    EpInactiveEdge *i = f + 2;
    while (i->Yx < median)
        i++;

    EpInactiveEdge *j = l - 1;
    while (j->Yx > median)
        j--;

    while (i < j)
    {
        SWAP(y, i->Yx, j->Yx);
        SWAP(e, i->Edge, j->Edge);

        do {
            i++;
        } while (i->Yx < median);

        do {
            j--;
        } while (j->Yx > median);
    }

    SWAP(y, f->Yx, j->Yx);
    SWAP(e, f->Edge, j->Edge);

    size_t a = j - f;
    size_t b = l - j;

    // Use less stack space by recursing on the shorter subtable.  Also,
    // have the less-overhead insertion-sort handle small subtables.

    if (a <= b)
    {
        if (a > QUICKSORT_THRESHOLD)
        {
            // 'a' is the smallest, so do it first:

            QuickSortEdges(f, j - 1);
            QuickSortEdges(j + 1, l);
        }
        else if (b > QUICKSORT_THRESHOLD)
        {
            QuickSortEdges(j + 1, l);
        }
    }
    else
    {
        if (b > QUICKSORT_THRESHOLD)
        {
            // 'b' is the smallest, so do it first:

            QuickSortEdges(j + 1, l);
            QuickSortEdges(f, j - 1);
        }
        else if (a > QUICKSORT_THRESHOLD)
        {
            QuickSortEdges(f, j- 1);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Do a sort of the inactive table using an insertion-sort.  Expects
*   large tables to have already been sorted via quick-sort.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
InsertionSortEdges(
    EpInactiveEdge *inactive,
    INT count
    )
{
    EpInactiveEdge *p;
    EpEdge *e;
    LONGLONG y;
    LONGLONG yPrevious;

    ASSERT((inactive - 1)->Yx == _I64_MIN);
    ASSERT(count >= 2);

    inactive++;     // Skip first entry (by definition it's already in order!)
    count--;            

    do {
        p = inactive;

        // Copy the current stuff to temporary variables to make a hole:

        e = inactive->Edge;
        y = inactive->Yx;

        // Shift everything one slot to the right (effectively moving
        // the hole one position to the left):

        while (y < (yPrevious = (p - 1)->Yx))
        {
            p->Yx = yPrevious;
            p->Edge = (p - 1)->Edge;
            p--;
        }

        // Drop the temporary stuff into the final hole:

        p->Yx = y;
        p->Edge = e;

        // The quicksort should have ensured that we don't have to move
        // any entry terribly far:

        ASSERT(inactive - p <= QUICKSORT_THRESHOLD);

    } while (inactive++, --count != 0);
}

/**************************************************************************\
*
* Function Description:
*
*   Assert the state of the inactive array.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
AssertInactiveArray(
    EpInactiveEdge *inactive,
    INT count
    )
{
    // Verify the head:

    ASSERT((inactive - 1)->Yx == _I64_MIN);
    ASSERT(inactive->Yx != _I64_MIN);

    do {
        LONGLONG yx;
        YX(inactive->Edge->X, inactive->Edge->StartY, &yx);

        ASSERT(inactive->Yx == yx);
        ASSERT(inactive->Yx >= (inactive - 1)->Yx);

    } while (inactive++, --count != 0);

    // Verify that the tail is setup appropriately:

    ASSERT(inactive->Edge->StartY == INT_MAX);
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize and sort the inactive array.
*
* Returns:
*
*   'y' value of topmost edge.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

INT
InitializeInactiveArray(
    EpEdgeStore *edgeStore,
    EpInactiveEdge *inactiveArray,      // 'inactiveArray' must be at least
    INT count,                          //   'count + 2' elements in size!
    EpEdge *tailEdge                    // Tail sentinel for inactive list
    )                
{
    BOOL isMore;
    EpEdge *activeEdge;
    EpEdge *activeEdgeEnd;
    INT i;
    INT j;
    EpEdge *e;
    INT y;

    // First initialize the inactive array.  Skip the first entry, 
    // which we reserve as a head sentinel for the insertion sort:

    EpInactiveEdge *inactiveEdge = inactiveArray + 1;

    do {
        isMore = edgeStore->Enumerate(&activeEdge, &activeEdgeEnd);

        while (activeEdge != activeEdgeEnd)
        {
            inactiveEdge->Edge = activeEdge;
            YX(activeEdge->X, activeEdge->StartY, &inactiveEdge->Yx);
            inactiveEdge++;
            activeEdge++;
        }
    } while (isMore);

    ASSERT(inactiveEdge - inactiveArray == count + 1);

    // Add the tail, which is used when reading back the array.  This 
    // is why we had to allocate the array as 'count + 1':

    inactiveEdge->Edge = tailEdge;

    // Add the head, which is used for the insertion sort.  This is why 
    // we had to allocate the array as 'count + 2':

    inactiveArray->Yx = _I64_MIN;

    // Only invoke the quicksort routine if it's worth the overhead:

    if (count > QUICKSORT_THRESHOLD)
    {
        // Quick-sort this, skipping the first and last elements,
        // which are sentinels.  
        //
        // We do 'inactiveArray + count' to be inclusive of the last
        // element:
    
        QuickSortEdges(inactiveArray + 1, inactiveArray + count);
    }

    // Do a quick sort to handle the mostly sorted result:

    InsertionSortEdges(inactiveArray + 1, count);

    ASSERTINACTIVEARRAY(inactiveArray + 1, count);

    // Return the 'y' value of the topmost edge:

    return(inactiveArray[1].Edge->StartY);
}

/**************************************************************************\
*
* Function Description:
*
*   Insert edges into the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
InsertNewEdges(
    EpEdge *activeList,   
    INT yCurrent,
    EpInactiveEdge **inactiveEdge,  // In/Out
    INT *yNextInactive              // Out, will be INT_MAX when no more
    )
{
    EpInactiveEdge *inactive = *inactiveEdge;

    ASSERT(inactive->Edge->StartY == yCurrent);

    do {
        EpEdge *newActive = inactive->Edge;

        // The activeList edge list sentinel is INT_MAX, so this always 
        // terminates:

        while (activeList->Next->X < newActive->X)
            activeList = activeList->Next;

        newActive->Next = activeList->Next;
        activeList->Next = newActive;

        inactive++;

    } while (inactive->Edge->StartY == yCurrent);

    *yNextInactive = inactive->Edge->StartY;
    *inactiveEdge = inactive;
}

/**************************************************************************\
*
* Function Description:
*
*   Sort the edges so that they're in ascending 'x' order.
*
*   We use a bubble-sort for this stage, because edges maintain good
*   locality and don't often switch ordering positions.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
SortActiveEdges(
    EpEdge *list
    )
{
    BOOL swapOccurred;
    EpEdge *tmp;

    // We should never be called with an empty active edge list:

    ASSERT(list->Next->X != INT_MAX);

    do {
        swapOccurred = FALSE;

        EpEdge *previous = list;
        EpEdge *current = list->Next;
        EpEdge *next = current->Next;
        INT nextX = next->X;
        
        do {
            if (nextX < current->X)
            {
                swapOccurred = TRUE;

                previous->Next = next;
                current->Next = next->Next;
                next->Next = current;

                SWAP(tmp, next, current);
            }

            previous = current;
            current = next;
            next = next->Next;

        } while ((nextX = next->X) != INT_MAX); 

    } while (swapOccurred);
}

/**************************************************************************\
*
* Function Description:
*
* For each scan-line to be filled:
*
*   1.  Remove any stale edges from the active edge list
*   2.  Insert into the active edge list any edges new to this scan-line
*   3.  Advance the DDAs of every active edge
*   4.  If any active edges are out of order, re-sort the active edge list
*   5.  Now that the active edges are ready for this scan, call the filler
*       to traverse the edges and output the spans appropriately
*   6.  Lather, rinse, and repeat
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
RasterizeEdges(
    EpEdge *activeList,
    EpInactiveEdge *inactiveArray,
    INT yCurrent,
    INT yBottom,
    EpFiller *filler,
    EpFillerFunction fillerFunction
    )
{
    INT yNextInactive;

    InsertNewEdges(activeList, yCurrent, &inactiveArray, &yNextInactive);

    ASSERTACTIVELIST(activeList, yCurrent);

    (filler->*fillerFunction)(activeList, yCurrent);
    
    while (++yCurrent < yBottom)
    {
        EpEdge *previous = activeList;
        EpEdge *current = activeList->Next;
        INT outOfOrderCount = 0;

        while (TRUE)
        {
            if (current->EndY <= yCurrent)
            {
                // If we've hit the sentinel, our work here is done:
    
                if (current->EndY == INT_MIN)
                    break;              // ============>
    
                // This edge is stale, remove it from the list:
    
                current = current->Next;
                previous->Next = current;

                continue;               // ============>
            }
    
            // Advance the DDA:
    
            current->X += current->Dx;
            current->Error += current->ErrorUp;
            if (current->Error >= 0)
            {
                current->Error -= current->ErrorDown;
                current->X++;
            }
    
            // Is this entry out-of-order with respect to the previous one?
    
            outOfOrderCount += (previous->X > current->X);
    
            // Advance:
    
            previous = current;
            current = current->Next;
        }

        // It turns out that having any out-of-order edges at this point
        // is extremely rare in practice, so only call the bubble-sort
        // if it's truly needed.
        //
        // NOTE: If you're looking at this code trying to fix a bug where
        //       the edges are out of order when the filler is called, do 
        //       NOT simply change the code to always do the bubble-sort!  
        //       Instead, figure out what caused our 'outOfOrder' logic 
        //       above to get messed up.

        if (outOfOrderCount)
        {
            SortActiveEdges(activeList);
        }

        ASSERTACTIVELISTORDER(activeList);

        if (yCurrent == yNextInactive)
        {
            InsertNewEdges(activeList, yCurrent, &inactiveArray, &yNextInactive);
        }

        ASSERTACTIVELIST(activeList, yCurrent);

        // Do the appropriate alternate or winding, supersampled or 
        // non-supersampled fill:

        (filler->*fillerFunction)(activeList, yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Fill (or sometimes stroke) that path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

GpStatus
RasterizePath(
    const DpPath    *path,
    GpMatrix        *worldTransform,
    GpFillMode       fillMode,
    BOOL             antiAlias,
    BOOL             nominalWideLine,
    DpOutputSpan    *output,
    DpClipRegion    *clipper,
    const GpRect    *drawBounds
    )
{
    EpInactiveEdge inactiveArrayStack[INACTIVE_LIST_NUMBER];
    EpInactiveEdge *inactiveArray;
    EpInactiveEdge *inactiveArrayAllocation;
    EpEdge headEdge;
    EpEdge tailEdge;
    EpEdge *activeList;
    RECT clipBounds;
    GpRect clipRect;
    EpEdgeStore edgeStore;
    EpInitializeEdgesContext edgeContext;
    INT yClipBottom;

    inactiveArrayAllocation = NULL;
    edgeContext.ClipRect = NULL;

    tailEdge.X = INT_MAX;       // Terminator to active list
    tailEdge.StartY = INT_MAX;  // Terminator to inactive list

    tailEdge.EndY = INT_MIN;
    headEdge.X = INT_MIN;       // Beginning of active list
    edgeContext.MaxY = INT_MIN;

    headEdge.Next = &tailEdge;
    activeList = &headEdge;
    edgeContext.Store = &edgeStore;

    edgeContext.IsAntialias = antiAlias;

    //////////////////////////////////////////////////////////////////////////

    DpRegion::Visibility visibility = clipper->GetRectVisibility(
                    drawBounds->X,
                    drawBounds->Y,
                    drawBounds->X + drawBounds->Width,
                    drawBounds->Y + drawBounds->Height);

    if (visibility != DpRegion::TotallyVisible)
    {
        clipper->GetBounds(&clipRect);

        // !!![andrewgo] Don, why do we have to do an 'Invisible' test
        //               here?  Shouldn't GetRectVisibility have already
        //               taken care of that case?  (GetRectVisibility
        //               was checked by our caller.)

        // Early-out if we're invisible, or if the bounds would overflow
        // our DDA calculations (which would cause us to crash).  We
        // leave 4 bits for the 28.4 fixed point, plus enough bits for
        // the antialiasing supersampling.  We also need a bit for doing
        // a signed difference without overflowing.

        if ((visibility == DpRegion::Invisible) ||
            (clipRect.X < (INT_MIN >> (5 + AA_X_SHIFT))) ||
            (clipRect.Y < (INT_MIN >> (5 + AA_Y_SHIFT))) ||
            (clipRect.X > (INT_MAX >> (5 + AA_X_SHIFT))) ||
            (clipRect.Y > (INT_MAX >> (5 + AA_Y_SHIFT))) ||
            (clipRect.Width  > (INT_MAX >> (5 + AA_X_SHIFT))) ||
            (clipRect.Height > (INT_MAX >> (5 + AA_Y_SHIFT))))
        {
            return(Ok);
        }

        // Scale the clip bounds rectangle by 16 to account for our 
        // scaling to 28.4 coordinates:
    
        clipBounds.left = clipRect.GetLeft() * 16;
        clipBounds.top = clipRect.GetTop() * 16;
        clipBounds.right = clipRect.GetRight() * 16;
        clipBounds.bottom = clipRect.GetBottom() * 16;

        yClipBottom = clipRect.GetBottom();

        edgeContext.ClipRect = &clipBounds;
    }

    //////////////////////////////////////////////////////////////////////////

    // Convert all our points to 28.4 fixed point:

    GpMatrix matrix(*worldTransform);
    matrix.AppendScale(TOREAL(16), TOREAL(16));

    // Enumerate the path and construct the edge table:

    FIXEDPOINTPATHENUMERATEFUNCTION pathEnumerationFunction = InitializeEdges;
    
    PathEnumerateType enumType = PathEnumerateTypeFill;
    
    if (nominalWideLine)
    {
        // The nominal-width wideline code always produces edges that
        // require a winding-mode fill:

        pathEnumerationFunction = InitializeNominal;
        fillMode = FillModeWinding;
        enumType = PathEnumerateTypeStroke;   // nominal width is a stroke.
    }

    if (!FixedPointPathEnumerate(
        path, 
        &matrix, 
        edgeContext.ClipRect,
        enumType, 
        pathEnumerationFunction, 
        &edgeContext
        ))
    {
        return(OutOfMemory);
    }

    INT totalCount = edgeStore.StartEnumeration();
    if (totalCount == 0)
        return(Ok);     // We're outta here (empty path or entirely clipped)

    // At this point, there has to be at least two edges.  If there's only
    // one, it means that we didn't do the trivially rejection properly.

    ASSERT(totalCount >= 2);

    inactiveArray = &inactiveArrayStack[0];
    if (totalCount > (INACTIVE_LIST_NUMBER - 2))
    {
        inactiveArrayAllocation = static_cast<EpInactiveEdge*>
            (GpMalloc(sizeof(EpInactiveEdge) * (totalCount + 2)));
        if (inactiveArrayAllocation == NULL)
            return(OutOfMemory);

        inactiveArray = inactiveArrayAllocation;
    }

    // Initialize and sort the inactive array:

    INT yCurrent = InitializeInactiveArray(&edgeStore, inactiveArray, 
                                           totalCount, &tailEdge);
    INT yBottom = edgeContext.MaxY;

    ASSERT(yBottom > 0);

    // Skip the head sentinel on the inactive array:

    inactiveArray++;

    if (antiAlias)
    {
        EpAntialiasedFiller filler(output);

        EpFillerFunction fillerFunction = (fillMode == FillModeAlternate) 
            ? (EpFillerFunction) (EpAntialiasedFiller::FillEdgesAlternate)
            : (EpFillerFunction) (EpAntialiasedFiller::FillEdgesWinding);

        if (edgeContext.ClipRect)
        {
            filler.SetClipper(clipper);

            // The clipper has to call back to EpFillerFunction::OutputSpan
            // to do the output, and then *we* call output->OutputSpan.

            clipper->InitClipping(&filler, drawBounds->Y);

            // 'yClipBottom' is in 28.4 format, and has to be converted
            // to the 30.2 format we use for antialiasing:

            yBottom = min(yBottom, yClipBottom << AA_Y_SHIFT);

            // 'totalCount' should have been zero if all the edges were
            // clipped out (RasterizeEdges assumes there's at least one edge
            // to be drawn):

            ASSERT(yBottom > yCurrent);
        }

        RasterizeEdges(activeList, inactiveArray, yCurrent, yBottom, &filler,
                       fillerFunction);
    }
    else
    {
        EpAliasedFiller filler(output);

        EpFillerFunction fillerFunction = (fillMode == FillModeAlternate) 
            ? (EpFillerFunction) (EpAliasedFiller::FillEdgesAlternate)
            : (EpFillerFunction) (EpAliasedFiller::FillEdgesWinding);

        if (edgeContext.ClipRect)
        {
            // The clipper calls output->OutputSpan directly.  We just have
            // to remember to call clipper->OutputSpan instead of 
            // output->OutputSpan:

            filler.SetOutputSpan(clipper);

            clipper->InitClipping(output, drawBounds->Y);

            yBottom = min(yBottom, yClipBottom);

            // 'totalCount' should have been zero if all the edges were
            // clipped out (RasterizeEdges assumes there's at least one edge
            // to be drawn):

            ASSERT(yBottom > yCurrent);
        }

        RasterizeEdges(activeList, inactiveArray, yCurrent, yBottom, &filler,
                       fillerFunction);
    }

    // Free any objects and get outta here:

    if (inactiveArrayAllocation != NULL)
        GpFree(inactiveArrayAllocation);

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\aaline.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   One-pixel-wide solid anti-aliased lines
*
* Abstract:
*
*   Draws anti-aliased solid-color lines which are one pixel wide.
*   Supports clipping against complex clipping regions. 
*
* History:
*
*   3/31/1999 AMatos
*       Created it.
*   08/17/1999 AGodfrey
*       Separated aliased from antialiased.
*
\**************************************************************************/

#include "precomp.hpp" 

#pragma optimize("a", on) 

// Antialiased lines are usually drawn using aarasterizer.cpp 
// rather than aaline.cpp.  If aaline.cpp is to be used, define
// AAONEPIXELLINE_SUPPORT

#ifdef AAONEPIXELLINE_SUPPORT

//------------------------------------------------------------------------
// Global array that stores all the different options of drawing functions. 
// If the order of the functions change, the offset constants must also 
// change.  
//------------------------------------------------------------------------

#define FUNC_X_MAJOR     0
#define FUNC_Y_MAJOR     1
#define FUNC_CLIP_OFFSET 2


typedef VOID (OnePixelLineDDAAntiAliased::*DDAFunc)(DpScanBuffer*);

DDAFunc gDrawFunctions[] = { 
    OnePixelLineDDAAntiAliased::DrawXMajor, 
    OnePixelLineDDAAntiAliased::DrawYMajor, 
    OnePixelLineDDAAntiAliased::DrawXMajorClip, 
    OnePixelLineDDAAntiAliased::DrawYMajorClip, 
};

//------------------------------------------------------------------------
// Constants used for manipulating fixed point and doing all the bitwise 
// operations on the aliased and antialiased DDA. I know some of these
// are already defined elsewhere, but I do it again here as it might be nice to 
// keep this independent of the rest of gdiplus. 
//------------------------------------------------------------------------

// Fixed point 

#define RealToFix GpRealToFix4 

#define FBITS     4
#define FMASK     0xf
#define FINVMASK  0xfffffff0
#define FSIZE     16
#define FHALF     8
#define FHALFMASK 7

// Antialiasing constants 

#define MAXALPHA   255
#define MAXERROR   0x08000000
#define TESTABOVE  0xf8000000
#define TESTBELOW  0x07ffffff
#define MAXHALF    0x04000000
#define CONVERTALPHA 19


/**************************************************************************\
*
* Function Description:
*
* Does all the DDA setup that is common to aliased and antialiased
* lines. 
*
* Arguments:
*
*   [IN] point1   - end point
*   [IN] point2   - end point
*   [IN] drawLast - FALSE if the line is to be end-exclusive

* Return Value:
*
* Returns TRUE if the drawing should continue, meaning the line
* has non-zero length. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAntiAliased::SetupCommon( 
    GpPointF *point1, 
    GpPointF *point2, 
    BOOL drawLast
    )
{
    // Turn the points into fixed 28.4 

    INT x1 = RealToFix(point1->X); 
    INT x2 = RealToFix(point2->X); 
    
    REAL rDeltaX = point2->X - point1->X; 
    REAL rDeltaY = point2->Y - point1->Y; 

    if( rDeltaX == 0 && rDeltaY == 0 ) 
    {
        return FALSE; 
    }

    INT xDir = 1; 

    if(rDeltaX < 0)
    {
        rDeltaX = -rDeltaX; 
        xDir = -1; 
    }

    INT y1 = RealToFix(point1->Y); 
    INT y2 = RealToFix(point2->Y); 

    INT yDir = 1; 

    if( rDeltaY < 0)
    {
        rDeltaY = -rDeltaY; 
        yDir = -1;
    }
    
    Flipped = FALSE; 

    if( rDeltaY >= rDeltaX ) 
    {
        // y-major 
                
        InvDelta = 1.0F/rDeltaY; 

        // Invert the endpoints if necessary       

        if(yDir == -1)
        {
            INT tmp = y1; 
            y1 = y2; 
            y2 = tmp; 
            tmp = x1;
            x1 = x2; 
            x2 = tmp; 
            xDir = -xDir; 
            Flipped = TRUE; 
        }

        // Determine the Slope 
        
        Slope = xDir*rDeltaX*InvDelta; 

        // Initialize the Start and End points 

        IsXMajor = FALSE; 
        MajorStart = y1; 
        MajorEnd = y2; 
        MinorStart = x1; 
        MinorEnd = x2; 
        MinorDir = xDir;

        // This will help us for the AntiAliased x-major case.

        SwitchFirstLast = 1;

        // Mark that we'll use the y-major functions. 

        DrawFuncIndex = FUNC_Y_MAJOR; 
    }
    else
    {
        // x-major        

        InvDelta = 1.0F/rDeltaX; 

        // Invert the endpoints if necessary        

        if(xDir == -1)
        {
            INT tmp = x1; 
            x1 = x2; 
            x2 = tmp; 
            tmp = y1;
            y1 = y2; 
            y2 = tmp; 
            yDir = -yDir; 
            Flipped = TRUE; 
        }

        Slope = yDir*rDeltaY*InvDelta; 

        // Initialize the rest

        IsXMajor = TRUE; 
        MajorStart = x1; 
        MajorEnd = x2; 
        MinorStart = y1; 
        MinorEnd = y2; 
        MinorDir = yDir; 

        // This will help us for the AntiAliased x-major case.

        SwitchFirstLast = MinorDir;

        // Mark that we'll use the x-major functions. 

        DrawFuncIndex = FUNC_X_MAJOR;
    }

    // Initialize the Deltas. In fixed point. 

    DMajor = MajorEnd - MajorStart; 
    DMinor = (MinorEnd - MinorStart)*MinorDir; 

    // Mark if we're drawing end-exclusive 

    IsEndExclusive = drawLast; 

    return TRUE; 
}

/**************************************************************************\
*
* Function Description:
*
* Does the part of the DDA setup that is specific for anti-aliased lines. 
*
* Arguments:

* Return Value:
*
* Always returns TRUE. It must return a BOOL because it must have the
* same signature as the aliased case. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAntiAliased::SetupAntiAliased()
{   
    const REAL maxError = MAXERROR;

    // Find the integer major positions for the beginning and 
    // the end of the line. 

    INT major, minor; 
    INT majorEnd, minorEnd; 

    major = (MajorStart + FHALF) >> FBITS; 
    majorEnd = (MajorEnd + FHALF) >> FBITS;    

    // Check for the simple case of a one pixel long line
    
    if(majorEnd == major) 
    {
        AlphaFirst = (MAXALPHA*(MajorEnd - MajorStart)*MinorDir) >> FBITS;    
        MajorStart = major;
        MajorEnd   = majorEnd;
        MinorStart = (MinorStart + FHALF) >> FBITS;
        return TRUE; 
    }

    // Store the fraction of the first pixel covered due to 
    // the start point. 

    FracStart = (major << FBITS) - MajorStart; 

    // Advance the minor coordinate to the integer major

    MinorStart += GpFloor(Slope*FracStart); 

    // Calculate the length across the line in the minor direction 

    INT halfWidth = RealToFix(LineLength*InvDelta) >> 1;       

    // Make sure thar startX and endX don't end up being the
    // same pixel, which our code does not handle. Theoretically
    // this cannot happen when the width of the line is 1, but
    // let's make sure it doesn't happen because of some roundoff
    // Error. 

    if( halfWidth < FHALF ) 
    { 
        halfWidth = FHALF; 
    }
    
    INT endMinor = MinorEnd + MinorDir*halfWidth; 

    // Calculate the Error up from the Slope. It needs to be that 
    // way so that the Error up will work when the 0-1 interval 
    // is mapped to the interval 0 to 0x8000000. See comments below. 

    ErrorUp = GpFloor(Slope*maxError); 
    ErrorDown = MinorDir*MAXERROR; 

    // For a given aa one pixel wide line, there can be up to three pixels 
    // baing painted across the line. We call these the first, middle and
    // last lines. So all variable with such prefixes refer to one
    // of these three. firstX and lastX are the positions of these lines. 
    // In the x-major case, unlike the y-major, we might need to switch 
    // who is the first and who is the second line depending on the 
    // direction, so that the order that each line fills the scan 
    // remains the same. That's why we multiply halfWidth by yDir. 

    halfWidth *= SwitchFirstLast; 

    MinorFirst = MinorStart - halfWidth;
    MinorLast  = MinorStart + halfWidth;

    // Calculate the initial Error. The Error is mapped so that 1 is 
    // taken to MAXERROR. So we find how mush we are into the 
    // pixel in X, which is a number between 0 and 16 (n.4). We then
    // multiply this by MAXERROR and shift it from fized point. Finally we add
    // MAXHALF  so that the 0-1 interval is mapped to 0 to MAXERROR 
    // instead of from -MAXHALF  and MAXHALF .     
           
    const INT convError = MAXERROR >> FBITS; 

    ErrorFirst = (MinorFirst - ((MinorFirst + FHALF) & FINVMASK))*
                convError + MAXHALF;
    ErrorLast  = (MinorLast  - ((MinorLast  + FHALF) & FINVMASK))*
                convError + MAXHALF ;
    
    // Now calculate the alpha's for the first pixel. This is 
    // done from the Error. Since the Error is between 
    // 0 and MAXERROR-1, if we shift it back by 19 (CONVERTALPHA)
    // we have a number between 0 and 255. We the multiply by 
    // yFrac which takes into account that the end of the line 
    // also cuts the coverage down. At the end we convert from
    // 28.4. alphaFirst is the alpha of for the first pixel across the
    // aa line, alpha Mid is for the middle if there is one, and 
    // AlphaLast is for the last pixel. 

    FracStart = FracStart + FHALF; 

    // Convert from 28.4 rounding 

    MinorFirst = (MinorFirst + FHALF) >> FBITS; 
    MinorLast  = (MinorLast  + FHALF) >> FBITS; 

    // Store the fraction for the last pixel 

    FracEnd = MajorEnd - (majorEnd << FBITS) + FHALF;

    // Store the initial values in integer coordinates 

    MajorStart = major; 
    MajorEnd = majorEnd; 
    MinorStart = MinorFirst;
    MinorEnd = (endMinor + FHALF) >> FBITS; 

    // Now do some initializations specific for the x-major and 
    // y-major cases. These can't be done in the drawing routine 
    // because those are reused during clipping. 

    if(!IsXMajor)
    {
        // Calculate the coverage values at the initial pixel. 

        AlphaFirst = ((MAXALPHA - (ErrorFirst >> CONVERTALPHA))*
                        FracStart) >> FBITS; 
        AlphaLast  = ((ErrorLast >> CONVERTALPHA)*FracStart) >> FBITS; 
        AlphaMid   = (MAXALPHA*FracStart) >> FBITS; 
    }
    else
    {
        // Depending if we are going up or down, the alpha is calculated 
        // a different way from the coverage. In each case we want to 
        // estimate the coverage as the area from the current position to 
        // the end of the pixel, but which end varies. This is stored 
        // in the following biases. We don't have to do this for the 
        // y-major line because of the switch between first and last line
        // explained above. 

        AlphaBiasLast  = ((1 - MinorDir) >> 1)*TESTBELOW; 
        AlphaBiasFirst = ((1 + MinorDir) >> 1)*TESTBELOW; 

        AlphaFirst = ((AlphaBiasFirst - MinorDir*ErrorFirst)*FracStart) >> FBITS; 
        AlphaLast  = ((AlphaBiasLast  + MinorDir*ErrorLast)*FracStart) >> FBITS; 
        
        // If there is a middle line on the first X value, take xFrac into 
        // account. Otherwise, the middle line's alpha is always MAXALPHA.                
        
        if(MinorDir*(MinorLast - MinorFirst) < 2)
        {
            AlphaMid = MAXALPHA; 
        }
        else
        {
            AlphaMid = MAXALPHA*FracStart >> FBITS; 
        }
        
        // Both the first and last DDAs start with the same 
        // major positions, given by the first pixel. 
        
        MajorFirst = MajorLast = MajorStart; 
    }

    return TRUE; 
}

    
/**************************************************************************\
*
* Function Description:
*
* Draws a y major anti-aliased line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawYMajor(
    DpScanBuffer *scan
    )
{      
    ARGB *buffer;            

    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        buffer  = scan->NextBuffer( MinorStart, MajorStart, 1);
        *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        return; 
    }

    // Get the number of pixels not counting the last one. 
    // Which requires special endpoint treatment. 

    INT  numPixels = MajorEnd - MajorStart;
    BOOL endDone   = FALSE; 

    // There can be two or three pixels across the line

    INT pixelWidth = MinorLast - MinorFirst + 1; 

    while(numPixels) 
    {
        numPixels--; 

last_pixel: 
        
        // Get the scanline buffer buffer

        buffer = scan->NextBuffer(MinorFirst, MajorStart, pixelWidth);       

        // Write the value of the first DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));

        // If there is a middle line, write its value. 

        if(pixelWidth > 2)
        {
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
        }
        
        // Write the value of the last (2nd or 3rd) DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast)); 

        // Update the errors of both DDAs

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next scan, and 
        // the new line width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             
    }

    // The last scan requires special treatment since its coverage
    // must be multiplied my the stored end coverage. So so this 
    // multiplication and go back to the body of the loop above 
    // to draw the last scan. 

    if(!endDone) 
    {
        AlphaFirst = (AlphaFirst*FracEnd) >> FBITS; 
        AlphaLast  = (AlphaLast*FracEnd)  >> FBITS; 
        AlphaMid   = (AlphaMid*FracEnd)   >> FBITS; 
        
        endDone = TRUE; 
        goto last_pixel; 
    }
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major anti-aliased line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawXMajor(
    DpScanBuffer *scan
    )
{
    ARGB *buffer;     
    INT maxWidth = scan->GetSurface()->Width;

    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        buffer  = scan->NextBuffer( MajorStart, MinorStart, 1);
        *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        return; 
    }

    // For an x-major one-pixel wide line, there can be up to 
    // three different scans being painted for the same x 
    // position. But in our case we can't draw to these all at
    // the same time since some surfaces can only be accessed
    // one scan at a time. So the algorithm used here does all the 
    // drawing to one scan at each time. But on the first scan, only
    // the first line should be drawn, on the second one both the
    // first and middle (if there is a middle) and only then all 
    // the lines. So correct the Error of the last line so that 
    // it'll only be drawn when we are at the second or third scan line. 
    // Also correct the alpha since it'll also be crecremented for
    // each scan line. 
    
    ErrorLast   += MinorDir*(MinorLast - MinorFirst)*ErrorDown; 
    AlphaLast   += (MinorLast - MinorFirst)*ErrorDown; 

    // Get the pointer to the buffer

    buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth);

    INT width = 0; 
    INT alpha;                   
    INT middleMajor; 

    while(MajorLast <= MajorEnd) 
    {
        // Fill the scan with the portion corresponding to the 
        // last line, which shoudl comes first on the scan. This is 
        // why we use the class member SwitchFirstLast, so we can decide 
        // based on the line direction which DDA will be the first and last
        // so that the last one (paradoxically) always comes first on the 
        // scan. Keep doing it untill the last line chages scan. Check for
        // the end to multiply by the last pixel's coverage. 

        while(!(ErrorLast & TESTABOVE))
        {
            if(MajorLast == MajorEnd)
            {
                AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 

                // Increment the error to correct for the 
                // decrementing below, since we didn't leave the
                // loop because the error became above 0. 

                ErrorLast += ErrorDown; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, 
                static_cast<BYTE>(AlphaLast >> CONVERTALPHA));
            ErrorLast += ErrorUp; 
            AlphaLast = AlphaBiasLast + MinorDir*ErrorLast; 
            width++; 
            MajorLast++; 
        }

        // We changed scans on the last DDA, so update the errors

        ErrorLast -= ErrorDown; 
        AlphaLast -= MinorDir*ErrorDown; 
        
        // Fill in the middle part if there is one

        middleMajor = MajorLast; 

        while(middleMajor < MajorFirst)
        {
            if( middleMajor == MajorEnd) 
            {
                AlphaMid = (AlphaMid*FracEnd) >> FBITS; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            AlphaMid = MAXALPHA; 
            width++;
            middleMajor++;
        }
    
        // Fill the scan with the portion corresponding to the 
        // first line, which comes last. Keep doing it untill the 
        // last line chages scan. 

        while(!(ErrorFirst & TESTABOVE))
        {
            if(MajorFirst == MajorEnd) 
            {
                AlphaFirst = (AlphaFirst*FracEnd) >> FBITS;
                
                // Since we can have at most three more scans
                // increment ErrorFirst so that we never go in here again

                ErrorFirst += 4*ErrorDown; 
            }

            *buffer++ = GpColor::PremultiplyWithCoverage(
                Color, 
                static_cast<BYTE>(AlphaFirst >> CONVERTALPHA));
            ErrorFirst += ErrorUp; 
            AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
            width++; 
            MajorFirst++; 
        }

        // Update the errors on the first scan

        ErrorFirst -= ErrorDown; 
        AlphaFirst += MinorDir*ErrorDown; 

        // Write the buffer and update the minor variables

        scan->UpdateWidth(width); 
        MinorStart += MinorDir; 
        if (MajorLast <= MajorEnd)
        {
            buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth); 
        }
        width = 0; 
    }

    scan->UpdateWidth(width);
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/
    
VOID
OnePixelLineDDAAntiAliased::DrawYMajorClip(
    DpScanBuffer *scan
    )
{      
    ARGB *buffer;     
        
    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        // Check if the point is inside the rectangle 

        if((MajorStart >= MajorIn) && 
           (MajorStart <= MajorOut) && 
           ((MinorStart  - MinorIn)*MinorDir >= 0) && 
           ((MinorOut - MinorStart)*MinorDir >= 0))
        {
            buffer  = scan->NextBuffer( MinorStart, MajorStart, 1);
            *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        return; 
    }

    // Align the major start coordinate with the edge of the 
    // cliprectangle 

    INT numScans = MajorIn - MajorStart; 

    while(numScans > 0)
    {

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++;
        numScans--;

        if(ErrorFirst & MAXERROR)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
        }
        if(ErrorLast & MAXERROR)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             
    }
    
    // Save the end values 

    INT saveMajor2  = MajorEnd; 
    INT saveFracEnd = FracEnd; 

    // If the end major coordinate is outside of the rectangle, 
    // mark that the DDA should stop at the edge

    if(MajorEnd > MajorOut)
    {
        MajorEnd = MajorOut; 
        FracEnd  = FSIZE; 
    }

    // Number of pixels to draw, not counting the last

    INT  numPixels =  MajorEnd - MajorStart;
    BOOL endDone   = FALSE; 

    // There can be two or three pixels across the line

    INT  pixelWidth = MinorLast - MinorFirst + 1; 

    // Do the DDA loop. Two loops are implemented here. The 
    // first one is used in the case that the x coordinate of
    // the rectangle is close enough to the constant-y edges 
    // of the clip rectangle. In this case, it's a pain, since
    // we have to check each pixel that we are writing if it's
    // not outside. Thus, as soon as we notice that we are 
    // far from the edges we go to the other loop that doesn't 
    // check all that. All it checks is if it got close enough
    // to the other edge, in which case it comes back to this
    // loop, using the label last_part. firstOutDist, firstInDist, 
    // lastOutDist and lastInDist keeps track of the number of 
    // pixels between the first and last DDAs and the In and 
    // Out y-constant edges of the rectangle. 
    
    INT firstOutDist = (MinorOut - MinorFirst)*MinorDir; 

last_part: 

    INT firstInDist  = (MinorFirst - MinorIn)*MinorDir; 
    INT lastInDist   = (MinorLast - MinorIn)*MinorDir; 
    INT lastOutDist  = (MinorOut - MinorLast)*MinorDir; 

    while(numPixels > 0) 
    {
        numPixels--; 

last_pixel: 
        
        // Check if it's ok to write the first pixel 
                
        if(firstInDist >= 0 && firstOutDist >= 0)
        {
            buffer    = scan->NextBuffer(MinorFirst, MajorStart, 1);       
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        else
        {
            // If the first DDA is out, and we are going in the 
            // positive direction, then the whole line is out and
            // we are done

            if(firstOutDist < 0 && MinorDir == 1)
            {
                goto end; 
            }
        }

        // If the line has 3 pixels across

        if(pixelWidth > 2)
        {
            // Check if it's ok to write the second pixel

            if(firstInDist >= -MinorDir && firstOutDist >= MinorDir)
            {
                buffer    = scan->NextBuffer(MinorFirst+1, MajorStart, 1);
                *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            }
        }
        
        // Now check if it's ok to write the last one 

        if(lastInDist >= 0 && lastOutDist >= 0)
        {
            buffer    = scan->NextBuffer(MinorLast, MajorStart, 1);               
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast));
        }
        else
        {
            // If the first DDA is out, and we are going in the 
            // negative direction, then the whole line is out and
            // we are done

            if(lastOutDist < 0 && MinorDir == -1)
            {
                goto end; 
            }
        }

        // Update the errors

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir;
            firstInDist++; 
            firstOutDist--; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
            lastInDist++; 
            lastOutDist--;
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             

        // Check to see if we can 'upgrade' to the next loop 

        if(firstInDist >= 3 && firstOutDist >= 3)
        {
            break;
        }
    }
    
    while(numPixels > 0) 
    {
        numPixels--; 

        // Get the scanline buffer buffer

        buffer = scan->NextBuffer(MinorFirst, MajorStart, pixelWidth);       

        // Write the value of the first DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));

        // If there is a middle line, write its value. 

        if(pixelWidth > 2)
        {
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
        }
        
        // Write the value of the last (2nd or 3rd) DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast));

        // Update the DDA 

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
            firstOutDist--; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             

        // Now check if it's time to go to the other loop
        // because we are too close to the out edge 

        if(firstOutDist < 3)
        {
            goto last_part;
        }
    }

    // Now if we haven't gotten here yet, do the last pixel 
    // and go once more through the loop. 

    if(!endDone) 
    {
        AlphaFirst = (AlphaFirst*FracEnd) >> FBITS; 
        AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 
        AlphaMid   = (AlphaMid*FracEnd) >> FBITS; 
        
        endDone = TRUE; 
        goto last_pixel; 
    }

end:

    MajorEnd = saveMajor2; 
    FracEnd  = saveFracEnd; 
}



/**************************************************************************\
*
* Function Description:
*
* Draws a x major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawXMajorClip(
    DpScanBuffer *scan
    )
{
    ARGB *buffer;     
    INT maxWidth = scan->GetSurface()->Width;
    
    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        // Check to see if the point is inside the rectangle 

        if((MajorStart >= MajorIn)  && 
           (MajorStart <= MajorOut) && 
           ((MinorStart - MinorIn)*MinorDir >= 0) && 
           ((MinorOut - MinorStart)*MinorDir >= 0))
        {
            buffer  = scan->NextBuffer( MajorStart, MinorStart, 1);
            *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        return; 
    }

    // Save the real end and its fraction

    INT saveMajor2  = MajorEnd; 
    INT saveFracEnd = FracEnd; 
    
    // If the end major coordinate is out, mark that we must stop 
    // before. Also make the fraction be one, since the last 
    // one drawn now should not have a fraction

    if(MajorOut < MajorEnd)
    {
        MajorEnd = MajorOut; 
        FracEnd  = FSIZE; 
    }
    
    // Advance until the last DDA is in the right scan line and
    // is aligned with the In y-constant edge of the rectnagle

    INT numScans = (MinorIn - MinorLast)*MinorDir; 
    
    while((numScans > 0 && MajorLast <= MajorEnd) || MajorLast < MajorIn)
    {
        ErrorLast += ErrorUp;
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
            numScans--; 
        }

        MajorLast++; 

        // Calculate the alpha for the current pixel 
        
        AlphaLast = AlphaBiasLast + MinorDir*ErrorLast;
    }
    
    // Do the same for the first DDA

    numScans = (MinorIn - MinorFirst)*MinorDir; 
    
    while((numScans > 0 && MajorFirst <= MajorEnd) || MajorFirst < MajorIn)
    {        
        ErrorFirst += ErrorUp;
        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
            numScans--; 
        }

        MajorFirst++; 

        AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
    }
        
    // If there is no middle line in the first x-position, 
    // make the middle alpha full, since the start coverage 
    // won't apply

    if((MinorLast - MinorFirst) < 2)
    {
        AlphaMid = MAXALPHA; 
    }

    MinorStart = MinorFirst; 

    // The same way that was done in the non-clipping case, 
    // mock arround with the error so we won't draw the 
    // last DDA until the first DDA is in the same scan line, 
    // or has caught up. We need to adjust the alpha and minor
    // positions for this DDA to, so that when we start 
    // drawing they will have the right value 

    ErrorLast += MinorDir*(MinorLast - MinorFirst)*ErrorDown; 
    AlphaLast += (MinorLast - MinorFirst)*ErrorDown; 
    MinorLast -= (MinorLast - MinorFirst); 

    // Get the pointer to the buffer 
    
    buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth);
    
    INT width = 0; 
    INT alpha;                   
    INT middleMajor;

    while(MajorLast <= MajorEnd) 
    {
        // Fill the scan with the portion corresponding to the 
        // last line, which should come first. Keep doing it 
        // until the last line changes scan. 

        while(!(ErrorLast & TESTABOVE))
        {
            // Check if we passed or are at the last pixel
            if(MajorLast >= MajorEnd)
            {
                if(MajorLast == MajorEnd) 
                {
                    // If we are at, just update the alpha

                    AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 
                }
                else
                {
                    // If we passed, we don't want to draw anymore. 
                    // Just adjust the error, alpha and minor so they
                    // will be right when they are corrected after this
                    // loop for the next scan

                    ErrorLast += ErrorDown; 
                    AlphaLast -= MinorDir*ErrorDown;             
                    MinorLast -= MinorDir; 
                    break; 
                }
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, 
                static_cast<BYTE>(AlphaLast >> CONVERTALPHA));
            ErrorLast += ErrorUp; 
            AlphaLast = AlphaBiasLast + MinorDir*ErrorLast; 
            width++; 
            MajorLast++; 
        }
        
        // Correct the values for the next scan

        ErrorLast -= ErrorDown; 
        AlphaLast -= MinorDir*ErrorDown;        
        MinorLast += MinorDir;         

        // Fill in the middle part. 

        middleMajor = MajorLast; 

        while(middleMajor < MajorFirst)
        {
            if( middleMajor == MajorEnd) 
            {
                AlphaMid = (AlphaMid*FracEnd) >> FBITS; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            AlphaMid = MAXALPHA; 
            width++;
            middleMajor++;
        }
    
        // Fill the scan with the portion corresponding to the 
        // first line, which should come first. Keep doing it 
        // until the last line changes scan. 

        while(!(ErrorFirst & TESTABOVE))
        {
            // Check for the end pixel, just like we 
            // did for the last DDA

            if(MajorFirst >= MajorEnd)
            {
                if(MajorFirst == MajorEnd) 
                {
                    AlphaFirst = (AlphaFirst*FracEnd) >> FBITS;
                }
                else
                {
                    ErrorFirst += ErrorDown; 
                    AlphaFirst -= MinorDir*ErrorDown;             
                    MinorFirst -= MinorDir; 
                    break; 
                }
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(
                Color,
                static_cast<BYTE>(AlphaFirst >> CONVERTALPHA));
            ErrorFirst += ErrorUp; 
            AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
            width++; 
            MajorFirst++; 
        }
        
        // Correct the values for the next scan 

        ErrorFirst -= ErrorDown; 
        AlphaFirst += MinorDir*ErrorDown;             
        MinorFirst += MinorDir; 
    
        scan->UpdateWidth(width); 
    
        // Check to see if we have come to the end of the rectangle
        // through the minor coordinate crossing the Out edge
        // in the x-constant direction  

        if(MinorStart == MinorOut)
        {
            MinorStart += MinorDir; 
            break; 
        }

        // Update the minor coordinate and get the next buffer
        // if we aren't done yet.

        MinorStart += MinorDir; 
        if (MajorLast <= MajorEnd)
        {
            buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth); 
        }
        width = 0; 
    }

    scan->UpdateWidth(width);

    // Restore the old values 

    MajorEnd = saveMajor2; 
    FracEnd  = saveFracEnd;
}

//--------------------------------------------------------------------
// Auxiliary functions 
//--------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Clips the line against a rectangle. It assumes that the line endpoints 
* are stored in the class in floating point format. This sets an 
* order in which this function can be called. It must be after the 
* SetupCommon function and before the specific setups for antialiasing 
* and aliasing. This is a pain, but it's better than requirering on of
* these to have to know about clipping. The clipping here is done by 
* using the Slope and InvSlope members of the class to advance the 
* endpoints to the rectangle edges. Thus the function also assumes that
* Slope and InvSlope have been calculated.
*
* Arguments:
*
*   [IN] clipRect - The rectangle to clip against

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL 
OnePixelLineDDAAntiAliased::ClipRectangle(
    const GpRect* clipRect
    )
{

    INT clipBottom, clipTop, clipLeft, clipRight; 

    // Set the major and minor edges ef the clipping
    // region, converting to fixed point 28.4. Note that
    // we don't convert to the pixel center, but to a 
    // that goes all the way up to the pixel edges. This 
    // makes a difference for antialiasing. We don't go all
    // the way to the edge since some rounding rules could 
    // endup lihgting the next pixel outside of the clipping
    // area. That's why we add/subtract 7 instead of 8. 
    // The right and bottom are exclusive. 
    
    INT majorMin = (clipRect->GetLeft() << FBITS) - FHALFMASK;
    INT majorMax = ((clipRect->GetRight() - 1) << FBITS) + FHALFMASK; 
    INT minorMax = ((clipRect->GetBottom() - 1) << FBITS) + FHALFMASK; 
    INT minorMin = (clipRect->GetTop() << FBITS) - FHALFMASK; 

    if(!IsXMajor)
    {
        INT tmp; 
        tmp      = majorMin; 
        majorMin = minorMin; 
        minorMin = tmp; 
        tmp      = majorMax; 
        majorMax = minorMax; 
        minorMax = tmp; 
    }

    // First clip in the major coordinate 

    BOOL minOut, maxOut; 

    minOut = MajorStart < majorMin; 
    maxOut = MajorEnd > majorMax; 

    if( minOut || maxOut )
    {
        if(MajorStart > majorMax || MajorEnd < majorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            MinorStart += GpFloor((majorMin - MajorStart)*Slope); 
            MajorStart = majorMin;
        }

        if(maxOut)
        {
            MinorEnd += GpFloor((majorMax - MajorEnd)*Slope); 
            MajorEnd = majorMax; 

            // If we clipped the last point, we don't need to be IsEndExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    // Now clip the minor coordinate 

    INT *pMajor1, *pMinor1, *pMajor2, *pMinor2; 

    if(MinorDir == 1)
    {
        pMajor1 = &MajorStart; 
        pMajor2 = &MajorEnd; 
        pMinor1 = &MinorStart; 
        pMinor2 = &MinorEnd; 
    }
    else
    {
        pMajor1 = &MajorEnd; 
        pMajor2 = &MajorStart; 
        pMinor1 = &MinorEnd; 
        pMinor2 = &MinorStart; 
    }

    minOut = *pMinor1 < minorMin; 
    maxOut = *pMinor2 > minorMax; 

    if(minOut || maxOut)
    {
        if(*pMinor1 > minorMax || *pMinor2 < minorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            *pMajor1 += GpFloor((minorMin - *pMinor1)*InvSlope); 
            *pMinor1 = minorMin;
        }

        if(maxOut)
        {
            *pMajor2 += GpFloor((minorMax - *pMinor2)*InvSlope); 
            *pMinor2 = minorMax;

            // If we clipped the last point, we don't need to be endExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    return(TRUE); 
}

/**************************************************************************\
*
* Function Description:
*
* Draws a one-pixe-wide line with a solid color. Calls on the 
* OnePixelLineDDAAntiAliased class to do the actual drawing. 
*
* Arguments:
*
*   [IN] scan         - The DpScanBuffer to access the drawing surface 
*   [IN] clipRect     - A single rectangle that includes all the clipping 
*                       region. If there is no clipping, should be set to NULL.                          
*   [IN] clipRegionIn - A complex clipping region. If the clipping region is 
*                       simple, this should be NULL, and clipRect will be used. 
*   [IN] point1       - line end point 
*   [IN] point2       - line end point 
*   [IN] inColor      - the solid color
*   [IN] drawLast     - FALSE if the line is to be end-exclusive.
*   [IN] antiAliased  - TRUE if the line should be antialiased. 
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DrawSolidLineOnePixelAntiAliased( 
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    )
{
    // Take out the const for now because the Enumeration method
    // is not const. 

    DpClipRegion *clipRegion = const_cast<DpClipRegion*>(clipRegionIn); 

    // Setup the common part of the DDA

    OnePixelLineDDAAntiAliased dda; 

    if(!dda.SetupCommon(point1, point2, drawLast))
    {
        return Ok;
    }

    // Calculate the length of the line. Since we only use
    // it to determine the width, it shouldn't matter that
    // we convert the deltas from 28.4 before the multiplication. 

    INT d1 = dda.DMajor >> FBITS; 
    INT d2 = dda.DMinor >> FBITS;

    dda.LineLength = (REAL)sqrt((double)(d1*d1 + d2*d2)); 

    // Store the color, not premultiplied 

    dda.Color = inColor;         

    // Now handle the different clipping cases 

    if(!clipRect)
    {
        // This is easy, there is no clipping so just draw.

        if(!dda.SetupAntiAliased())
        {
            return Ok; 
        }

        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

        return Ok;
    }
    else
    {
        // The inverse of the Slope might be needed. 
       
        // Can't use the inverse slope if the slope is zero.
        if(dda.Slope==0.0F) 
        {
          dda.InvSlope=0.0F;
        } 
        else 
        {
          dda.InvSlope =  (1.0F/dda.Slope); 
        }

        // First of all clip against the bounding rectangle 

        if(!dda.ClipRectangle(clipRect))
        {
            return Ok;            
        }

        // Do the specific setup 

        if(!dda.SetupAntiAliased())
        {
            return Ok; 
        }

        // For each clip rectangle we store it's limits in 
        // an array of four elements. We then index this array using 
        // the variables below which depend on the slope and 
        // direction of the line in the following way: majorIn is edge crossed 
        // to go into the rect in the major direction, majorOut is the edge 
        // crossed to go out of the rect in the major direction, and so on.
        // The same for xIn, xOut, yIn, yOut. 

        INT majorIn, majorOut, minorIn, minorOut; 
        INT xIn, xOut, yIn, yOut;
        
        // Direction to enumerate the rectangles which depends on the 
        // line 

        DpClipRegion::Direction enumDirection; 
        
        INT clipBounds[4]; 
               
        // We store all our info in terms of major and minor 
        // direction, but to deal with cliping rectangles we
        // need to know them in terms of x and y, so calculate
        // xDir, yDir, the advance slope. 

        REAL xAdvanceRate; 
        INT  xDir, yDir; 
        INT  yEndLine;        
    
        // If the line crosses a span completely, (xStart, yStart)
        // is the position where it enters the span and (xEnd, yEnd)
        // is the position that it leaves. If it starts inside the 
        // span, then (xStart, yStart) is the start point

        REAL yStart, xStart, xEnd, yEnd; 

        if(dda.IsXMajor)
        {
            // Calculate the in-out indices

            majorIn  = xIn  = 0; 
            majorOut = xOut = 2; 
            if(dda.MinorDir == 1)
            {
                minorIn  = 1;
                minorOut = 3;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn  = 3;
                minorOut = 1;
                enumDirection = DpClipRegion::BottomLeftToTopRight; 
            }
            
            yIn = minorIn;
            yOut = minorOut;

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MinorStart; 
            xStart = (REAL)dda.MajorStart;

            xAdvanceRate = dda.InvSlope; 
            xDir = 1; 
            yDir = dda.MinorDir; 
            yEndLine =  dda.MinorEnd; 
        }
        else
        {
            majorIn = yIn =  1; 
            majorOut = yOut = 3; 
            if(dda.MinorDir == 1)
            {
                minorIn = 0;
                minorOut = 2;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn = 2;
                minorOut = 0;
                enumDirection = DpClipRegion::TopRightToBottomLeft;
            }
            
            xIn = minorIn; 
            xOut = minorOut; 

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MajorStart;
            xStart = (REAL)dda.MinorStart; 

            xAdvanceRate = dda.Slope; 
            xDir = dda.MinorDir; 
            yDir = 1;
            yEndLine = dda.MajorEnd; 
        }

        // Update the drawing function to the correct 
        // slipping version

        dda.DrawFuncIndex += FUNC_CLIP_OFFSET; 
    
        if(!clipRegion)
        {
            // In this case there is only a single rect, so just
            // draw clipped to that 

            // Store the rectangle in an array so we can atribute the 
            // right values to the MajorIn, majorOut, etc... variables. 
            // Remember that bottom and right are exclusive. 

            clipBounds[0] = clipRect->GetLeft(); 
            clipBounds[1] = clipRect->GetTop(); 
            clipBounds[2] = clipRect->GetRight() - 1; 
            clipBounds[3] = clipRect->GetBottom() - 1; 

            dda.MajorIn  = clipBounds[majorIn]; 
            dda.MajorOut = clipBounds[majorOut]; 
            dda.MinorIn  = clipBounds[minorIn]; 
            dda.MinorOut = clipBounds[minorOut]; 

            (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

            return Ok;
        }
        else
        {
            BOOL agregating = FALSE; 
            INT  agregateBounds[4];

            // We have a complex clipping region. So what we'll do 
            // is clip against each individual rectangle in the 
            // cliping region. 

            clipRegion->StartEnumeration(GpFloor(yStart), enumDirection);            

            GpRect rect; 

            // Get the first rectangle. 

            INT numRects = 1;        

            clipRegion->Enumerate(&rect, numRects); 
            
            clipBounds[0] = rect.GetLeft(); 
            clipBounds[1] = rect.GetTop(); 
            clipBounds[2] = rect.GetRight() - 1; 
            clipBounds[3] = rect.GetBottom() - 1; 
            
            // Store the y position into the span 

            INT currSpanYMin = clipBounds[yIn]; 

            // We need some special treatment for the case where the 
            // line is horizontal, since is this case it's not going 
            // to cross different spans. And it it's not in the current
            // span, it's totally clipped out. 

            if(dda.IsXMajor && dda.ErrorUp == 0)
            {
                if(yStart >= clipBounds[1] && yStart <= clipBounds[3])
                {
                    xStart  = (REAL)dda.MajorStart;
                    xEnd    = (REAL)dda.MajorEnd; 
                }
                else
                {
                    return Ok; 
                }
            }
            else
            {
                if(yStart < clipBounds[1] || yStart > clipBounds[3])
                {
                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate; 
                    yStart  = (REAL)clipBounds[yIn];
                }

                xEnd = xStart + (clipBounds[yOut] - yStart)*xAdvanceRate; 
            }
            
            yEnd = (REAL)clipBounds[yOut]; 

            while(1)
            {
                // Get to the first rectangle on the span that crosses the
                // line 
                
                while((xStart - clipBounds[xOut])*xDir > 0)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                    if(clipBounds[yIn] != currSpanYMin)
                    {
                        goto process_next_span; 
                    }
                }

                // Draw on all the rectangles that intersect the 
                // line 

                if((xStart - clipBounds[xIn])*xDir > 0 && 
                   (clipBounds[xOut] - xEnd)*xDir > 0)
                {
                    if(agregating) 
                    {
                        if((clipBounds[xIn] - agregateBounds[xIn])*xDir < 0)
                        {
                            agregateBounds[xIn] = clipBounds[xIn];        
                        }
                        if((clipBounds[xOut] - agregateBounds[xOut])*xDir > 0)
                        {
                            agregateBounds[xOut] = clipBounds[xOut];        
                        }
                        agregateBounds[yOut] = clipBounds[yOut];
                    }
                    else
                    {
                        agregateBounds[0] = clipBounds[0];
                        agregateBounds[1] = clipBounds[1];
                        agregateBounds[2] = clipBounds[2];
                        agregateBounds[3] = clipBounds[3];

                        agregating = TRUE; 
                    }
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        agregating = FALSE; 
                    }
                    while((xEnd - clipBounds[xIn])*xDir > 0)
                    {
                        dda.MajorIn  = clipBounds[majorIn]; 
                        dda.MajorOut = clipBounds[majorOut]; 
                        dda.MinorIn  = clipBounds[minorIn]; 
                        dda.MinorOut = clipBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                            
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        numRects = 1; 
                        
                        clipRegion->Enumerate(&rect, numRects); 
                        
                        clipBounds[0] = rect.GetLeft(); 
                        clipBounds[1] = rect.GetTop(); 
                        clipBounds[2] = rect.GetRight() - 1; 
                        clipBounds[3] = rect.GetBottom() - 1; 
    
                        if(numRects != 1) 
                        {
                            goto draw_agregated;
                        }
                        if(clipBounds[yIn] != currSpanYMin)
                        {
                            goto process_next_span; 
                        }
                    }
                }
                // Get to the next span

                while(clipBounds[yIn] == currSpanYMin)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                }

process_next_span:

                if((clipBounds[yIn] - yEndLine)*yDir > 0)
                {
                    // We are done. 
                    goto draw_agregated; 
                }

                if((clipBounds[yIn] - yEnd)*yDir == 1)
                {
                    xStart  = xEnd;
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
                        
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        agregating = FALSE; 
                    }

                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate;
                }

                yStart  = (REAL)clipBounds[yIn];                 
                xEnd    = xStart + (clipBounds[yOut] - yStart)*xAdvanceRate; 
                yEnd    = (REAL)clipBounds[yOut];
                currSpanYMin = GpFloor(yStart); 
            }

draw_agregated: 

            if(agregating)
            {
                dda.MajorIn  = agregateBounds[majorIn]; 
                dda.MajorOut = agregateBounds[majorOut]; 
                dda.MinorIn  = agregateBounds[minorIn]; 
                dda.MinorOut = agregateBounds[minorOut]; 
                
                (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan);                 
            }

        }
    }

    return Ok; 
}

#endif // AAONEPIXELLINE_SUPPORT

#pragma optimize("a", off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\bicubic.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bicubic.cpp
*
* Abstract:
*
*   Bicubic Resampling code
*
* Created:
*
*   11/03/1999 ASecchia
\**************************************************************************/

#include "precomp.hpp"

DpOutputBicubicImageSpan::DpOutputBicubicImageSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    Scan     = scan;
    BWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap   = bitmap;

    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL) dBitmap->Width;
        SrcRect.Height = (REAL) dBitmap->Height;
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

namespace DpOutputBicubicImageSpanNS {
const INT KernShift = 6;
const INT Oversample = 1 << KernShift;
const FIX16 kern[2*Oversample+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};


#ifdef _X86_

const short kern14[2*Oversample+1] =
{
    16384, 16374, 16345, 16297, 16230, 16146, 16044, 15926,
    15792, 15642, 15478, 15299, 15106, 14900, 14681, 14451,
    14208, 13955, 13691, 13417, 13134, 12842, 12542, 12235,
    11920, 11599, 11272, 10939, 10602, 10261,  9915,  9567,
     9216,  8863,  8509,  8154,  7798,  7443,  7088,  6735,
     6384,  6035,  5690,  5348,  5010,  4677,  4349,  4028,
     3712,  3404,  3103,  2810,  2526,  2251,  1986,  1732,
     1488,  1256,  1036,   828,   634,   454,   287,   136,
        0,  -124,  -240,  -349,  -450,  -544,  -631,  -711,
     -784,  -851,  -911,  -966, -1014, -1057, -1094, -1126,
    -1152, -1174, -1190, -1202, -1210, -1214, -1213, -1208,
    -1200, -1188, -1173, -1155, -1134, -1110, -1084, -1055,
    -1024,  -991,  -956,  -920,  -882,  -843,  -803,  -762,
     -720,  -678,  -635,  -593,  -550,  -508,  -466,  -425,
     -384,  -345,  -306,  -269,  -234,  -201,  -169,  -139,
     -112,   -87,   -65,   -46,   -30,   -17,    -8,    -2,
        0
};

#pragma warning(disable : 4799)

ARGB FASTCALL Do1DBicubicMMX(ARGB filter[4], short w[4])
{
    ARGB result;
    
    static ULONGLONG HalfFix3 = 0x0004000400040004;

    // really should do this function without any preamble.
    _asm
    {
        mov        eax, filter     ;
        mov        ebx, w          ;
        pxor       mm0, mm0        ; zero

        movq       mm1, [ebx]      ; w

        movd       mm4, [eax]      ; filter[0]
        movd       mm5, [eax+4]    ; filter[1]
        movd       mm6, [eax+8]    ; filter[2]
        movd       mm7, [eax+0xc]  ; filter[3]

        punpcklbw  mm4, mm0        ; 0a0r0g0b (interleave zeros)
        punpcklbw  mm5, mm0        ;
        punpcklbw  mm6, mm0        ;
        punpcklbw  mm7, mm0        ;

        psllw      mm4, 5          ; 2 to compensate for the kernel resolution +
        psllw      mm5, 5          ; 3 to support some fractional bits for the add.
        psllw      mm6, 5          ;
        psllw      mm7, 5          ;

        movq       mm2, mm1        ;
        punpcklwd  mm2, mm2        ; w1 w1 w0 w0
        movq       mm3, mm2        ;
        punpckldq  mm2, mm2        ; w0
        punpckhdq  mm3, mm3        ; w1

        pmulhw     mm4, mm2        ; filter[0]*w0
        pmulhw     mm5, mm3        ; filter[1]*w1

        punpckhwd  mm1, mm1        ; w3 w3 w2 w2
        movq       mm2, mm1        ;
        punpckldq  mm1, mm1        ; w2
        punpckhdq  mm2, mm2        ; w3

        pmulhw     mm6, mm1        ; filter[2]*w2
        pmulhw     mm7, mm2        ; filter[3]*w3

        paddsw     mm4, mm5        ; add
        paddsw     mm6, mm7        ; add
        paddsw     mm4, mm6        ; add

        movq       mm3, HalfFix3   ; 
        paddsw     mm4, mm3        ; add half
        psraw      mm4, 3          ; round the fractional bits away.
        
        packuswb   mm4, mm4        ; saturate between [0, 0xff]

        ; need to saturate the r, g, b components to range 0..a

        movq       mm0, mm4        ;
        punpcklbw  mm0, mm0        ; aarrggbb
        punpckhwd  mm0, mm0        ; aaaarrrr
        psrlq      mm0, 32         ; 0000aaaa
        mov        eax, 0xffffffff ;
        movd       mm1, eax        ;
        psubb      mm1, mm0        ; 255-a
        paddusb    mm4, mm1        ; saturate against 255
        psubusb    mm4, mm1        ; drop it back to the right range

        movd       result, mm4     ;
        //emms; this instruction is done by the caller.
    }
    return result;
}
#endif

inline ARGB Do1DBicubic(ARGB filter[4], const FIX16 x)
{
    // Lookup the convolution kernel.
    FIX16 w0 = kern[Oversample+x];
    FIX16 w1 = kern[x];
    FIX16 w2 = kern[Oversample-x];
    FIX16 w3 = kern[2*Oversample-x];

    // Cast to LONG so that we preserve the sign when we start
    // shifting values around - the bicubic filter will often
    // have negative intermediate color components.
    ULONG *p = (ULONG *)filter;
    LONG a, r, g, b;

    // Casting of p to ULONG and then having the LONG casts in the expressions
    // below is to work around a compiler sign extension bug.
    // In this particular case, the bug was dropping the '& 0xff' from the
    // green component expression causing it to become negative
    // which gets clamped to zero.
    // When the bug is fixed, p should be reverted to LONG and casted to LONG
    // and the LONG casts should be removed from the expressions below.

    // Alpha component
    a = (w0 * (LONG)((p[0] >> 24) & 0xff) +
         w1 * (LONG)((p[1] >> 24) & 0xff) +
         w2 * (LONG)((p[2] >> 24) & 0xff) +
         w3 * (LONG)((p[3] >> 24) & 0xff)) >> FIX16_SHIFT;
    a = (a < 0) ? 0 : (a > 255) ? 255 : a;

    // We have premultiplied alpha values - clamp R, G, B to alpha
    // Red component
    r = (w0 * (LONG)((p[0] >> 16) & 0xff) +
         w1 * (LONG)((p[1] >> 16) & 0xff) +
         w2 * (LONG)((p[2] >> 16) & 0xff) +
         w3 * (LONG)((p[3] >> 16) & 0xff)) >> FIX16_SHIFT;
    r = (r < 0) ? 0 : (r > a) ? a : r;

    // Green component
    g = (w0 * (LONG)((p[0] >> 8) & 0xff) +
         w1 * (LONG)((p[1] >> 8) & 0xff) +
         w2 * (LONG)((p[2] >> 8) & 0xff) +
         w3 * (LONG)((p[3] >> 8) & 0xff)) >> FIX16_SHIFT;
    g = (g < 0) ? 0 : (g > a) ? a : g;

    // Blue component
    b = (w0 * (LONG)(p[0] & 0xff) +
         w1 * (LONG)(p[1] & 0xff) +
         w2 * (LONG)(p[2] & 0xff) +
         w3 * (LONG)(p[3] & 0xff)) >> FIX16_SHIFT;
    b = (b < 0) ? 0 : (b > a) ? a : b;

    return ((a << 24) | (r << 16) | (g << 8) | b);
}
} // end DpOutputBicubicImageSpanNS


GpStatus
DpOutputBicubicImageSpan::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    GpPointF p1, p2;
    p1.X = (REAL) xMin;
    p1.Y = p2.Y = (REAL) y;
    p2.X = (REAL) xMax;

    DeviceToWorld.Transform(&p1);
    DeviceToWorld.Transform(&p2);

    // Convert to Fixed point notation - 16 bits of fractional precision.
    FIX16 dx, dy, x0, y0;
    x0 = GpRound(p1.X*FIX16_ONE);
    y0 = GpRound(p1.Y*FIX16_ONE);

    ASSERT(xMin < xMax);
    dx = GpRound(((p2.X - p1.X)*FIX16_ONE)/(xMax-xMin));
    dy = GpRound(((p2.Y - p1.Y)*FIX16_ONE)/(xMax-xMin));

    return OutputSpanIncremental(y, xMin, xMax, x0, y0, dx, dy);
}

GpStatus
DpOutputBicubicImageSpan::OutputSpanIncremental(
    INT      y,
    INT      xMin,
    INT      xMax,
    FIX16    x0,
    FIX16    y0,
    FIX16    dx,
    FIX16    dy
    )
{
    using namespace DpOutputBicubicImageSpanNS;
    INT width  = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, width);
    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    INT ix;
    INT iy;
    FIX16 fracx;        // hold the fractional increment for ix
    FIX16 fracy;        // hold the fractional increment for iy

    ARGB filter[4][4];  // 4x4 filter array.
    INT xstep, ystep;   // loop variables in x and y
    INT wx[4];
    INT wy[4];          // wrapped coordinates

    // For all pixels in the destination span...
    for(int i=0; i<width; i++)
    {
        // .. compute the position in source space.

        // floor
        ix = x0 >> FIX16_SHIFT;
        iy = y0 >> FIX16_SHIFT;

        // Apply the wrapmode to all possible kernel combinations.
        for(xstep=0;xstep<4;xstep++) {
            wx[xstep] = ix+xstep-1;
            wy[xstep] = iy+xstep-1;
        }


        if(BWrapMode != WrapModeClamp) {
            if( ( (UINT)(ix-1) >= (UINT)( max(((INT)BmpData.Width)-4,0))) ||
                ( (UINT)(iy-1) >= (UINT)( max(((INT)BmpData.Height)-4,0))) )
            {
                for(xstep=0;xstep<4;xstep++) {
                    ApplyWrapMode(BWrapMode, wx[xstep], wy[xstep], BmpData.Width, BmpData.Height);
                }
            }
        }

        // Check to see if we're outside of the valid drawing range specified
        // in the DpBitmap.

        fracx = (x0  & FIX16_MASK) >> (FIX16_SHIFT-KernShift);
        fracy = (y0  & FIX16_MASK) >> (FIX16_SHIFT-KernShift);

        // Build up the filter domain surrounding the current pixel.
        // Technically the loops below should go from -2 to 2 to correctly
        // handle the case of fracx or fracy == 0, but our convolution kernel
        // has zero at that point anyway, so we optimize it away.
        
        for(ystep=0;ystep<4;ystep++) for(xstep=0;xstep<4;xstep++)
        {
            // !!! PERF: check the y step outside
            //       of the x loop and use memset to fill the entire line.
            //       This should reduce the complexity of the inner loop
            //       comparison.

            // Make sure the pixel is within the bounds of the source before
            // accessing it.

            if( ((wx[xstep]) >=0) &&
                ((wy[ystep]) >=0) &&
                ((wx[xstep]) < (INT)(BmpData.Width)) &&
                ((wy[ystep]) < (INT)(BmpData.Height)) )
            {
                filter[xstep][ystep] =
                  *(srcPtr0+stride*(wy[ystep])+(wx[xstep]));
            } else {
                // This means that this source pixel is outside of the valid
                // bits in the source. (edge condition)
                filter[xstep][ystep] = (ARGB) ClampColor;
            }
        }

        #ifdef _X86_
        if(OSInfo::HasMMX)
        {
            // Lookup the convolution kernel.
            short w[4];

            w[0] = kern14[Oversample+fracy];
            w[1] = kern14[fracy];
            w[2] = kern14[Oversample-fracy];
            w[3] = kern14[2*Oversample-fracy];

            // Filter the 4 vertical pixel columns
            // Reuse filter[0] to store the intermediate result
            for(xstep=0;xstep<4;xstep++)
            {
                filter[0][xstep] = Do1DBicubicMMX(filter[xstep], w);
            }

                // Lookup the convolution kernel.

            w[0] = kern14[Oversample+fracx];
            w[1] = kern14[fracx];
            w[2] = kern14[Oversample-fracx];
            w[3] = kern14[2*Oversample-fracx];

            // Filter horizontally.
            *buffer++ = Do1DBicubicMMX(filter[0], w);

            // Update source position
            x0 += dx;
            y0 += dy;
        }
        else
        #endif
        {
            // Filter the 4 vertical pixel columns
            // Reuse filter[0] to store the intermediate result
            for(xstep=0;xstep<4;xstep++)
            {
                filter[0][xstep] = Do1DBicubic(filter[xstep], fracy);
            }

            // Filter horizontally.
            *buffer++ = Do1DBicubic(filter[0], fracx);

            // Update source position
            x0 += dx;
            y0 += dy;
        }
    }

    // Clear the MMX state

    #ifdef _X86_
    if(OSInfo::HasMMX)
    {
        _asm emms;
    }
    #endif

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\alphablender.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Alpha-blender
*
* Abstract:
*
*   A class which alpha-blends a source scanline in either sRGB or
*   sRGB64 format, to a destination of arbitrary format. 
*
*   The operation can be either a SrcOver or a SrcCopy. 
*   A quality hint can be used to make the "SrcOver using sRGB source" case 
*   do a higher-quality blend in the sRGB64 color space.
*
* Created:
*
*   01/03/2000 agodfrey
*       Created it.
*   02/22/2001 agodfrey
*       Expanded it for different scan types (needed for ClearType).
*       Simplified the Initialize() parameters by adding a 
*       DpContext parameter.
*
\**************************************************************************/

#ifndef _ALPHABLENDER_HPP
#define _ALPHABLENDER_HPP

//--------------------------------------------------------------------------
// The different Scan types:
//
// Blend: The typical alpha-blending operation.
//        Context->CompositingMode specifies the blend mode.
//
// Opaque: Opaque can be used in place of Blend, when all the input pixels
//         are opaque. This applies to both SrcCopy and SrcOver blends.
//         (But right now, EpAlphaBlender doesn't distinguish properly
//          between Opaque and SrcCopy. See bug #127412.)
//
// OpaqueSolidFill is a further specialized version of Opaque, in which all
// the input pixels are the same color. Disabled until the back-end supports
// these kinds of scan.
//
// CT and CTSolidFill are the ClearType blends - with an arbitrary brush,
// or a solid (single-color) one, respectively.
//
// Note: We depend on these values starting at 0 and being consecutive -
//       we use them as array indices.
//              
// Max: Counts the number of "real" scan types.
// Unknown: Used where we don't know the type. This allows us to specify
//     the scan type either in Start(), or in NextBuffer(), depending on
//     the situation.
//
//--------------------------------------------------------------------------

enum EpScanType
{
    EpScanTypeBlend,
    EpScanTypeOpaque,
    
    // EpScanTypeOpaqueSolidFill,
    
    EpScanTypeCT,
    EpScanTypeCTSolidFill,
    
    // End of "real" scan types.
    
    EpScanTypeMax,
    EpScanTypeUnknown = EpScanTypeMax
};

#include "ScanOperation.hpp"

// !!! [asecchia] This include needs to be cleaned up when we fix 
// the imaging.h mess.
#include "..\..\privinc\pixelformats.h"

class EpAlphaBlender
{
public:
    EpAlphaBlender() 
    { 
        Initialized = FALSE; 
        ConvertBlendingScan = FALSE;
    }
    
    ~EpAlphaBlender() {}

    // Right now, everyone sets "dither16bpp" to TRUE.
    // I can see it being useful, perhaps renamed to "shouldDither", 
    // to support an API to make us quantize & dither the way GDI does.

    VOID
    Initialize(
        EpScanType scanType,
        PixelFormatID dstFormat,
        PixelFormatID srcFormat,
        const DpContext *context,
        const ColorPalette *dstpal,
        VOID **tempBuffers,
        BOOL dither16bpp,
        BOOL useRMW,
        ARGB solidColor
        );

    VOID Blend(
        VOID *dst, 
        VOID *src, 
        UINT width, 
        INT dither_x, 
        INT dither_y,
        BYTE *ctBuffer
        );

    VOID UpdatePalette(const ColorPalette *dstpal, const EpPaletteMap *paletteMap);
    
    // Returns true if EpAlphaBlender knows how to convert 
    // the specified pixelFormat.    
    
    static BOOL IsSupportedPixelFormat(PixelFormatID pixelFormat)
    {
        return (
           pixelFormat != PixelFormatUndefined &&
           pixelFormat != PixelFormatMulti &&
           pixelFormat != PixelFormat1bppIndexed &&
           pixelFormat != PixelFormat4bppIndexed &&
           pixelFormat != PixelFormat16bppGrayScale &&
           pixelFormat != PixelFormat16bppARGB1555
        );
    }
private:

    // Records whether Initialize() has been called yet
    BOOL Initialized;

    ScanOperation::OtherParams OperationParameters;

    // An internal helper class, used only by Initialize().
    
    class Builder;
    
    // The IA64 compiler seems to need some convincing:
    friend class Builder;
    
    // ConvertBlendingScan:
    //   TRUE:  The pipeline will convert the blending scan to another
    //          format before using it
    //   FALSE: The pipeline will use the original passed-in blending scan
    //          (this is the common case).
    
    BOOL ConvertBlendingScan;
    
    // We represent the pipeline with an array of PipelineItem structures.
    //   Src - the source buffer for the operation. Can also be 
    //         BLENDER_USE_SOURCE or BLENDER_USE_DESTINATION. (q.v.)
    //   Dst - the destination buffer for the operation. For the final
    //         operation of the pipeline, and only then, 
    //         Dst == BLENDER_USE_DESTINATION.
        
    struct PipelineItem
    {
        ScanOperation::ScanOpFunc Op;
        VOID *Src;
        VOID *Dst;
        
        PipelineItem() {} 
        
        PipelineItem(
            ScanOperation::ScanOpFunc op,
            VOID *src,
            VOID *dst
            )
        {
            Op = op;
            Src = src;
            Dst = dst;
        }
    };
    
    enum 
    {
        MAX_ITEMS = 20
    };
    
    // !!! [agodfrey]: MAX_ITEMS was 8. I'm boosting it until we know what the 
    // maximum really should be, so that I can hack in the meantime.

    PipelineItem Pipeline[MAX_ITEMS];   // the scan operation pipeline
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\aarasterizer.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   AARasterizer.hpp
*
* Abstract:
*
*   GpRasterizer class definition (and supporting classes)
*
* Created:
*
*   04/12/99 AMatos
*
\**************************************************************************/

#ifndef _AARASTERIZER_HPP
#define _AARASTERIZER_HPP

// It's possible to have higher 'X' resolution antialiasing than 'Y', with
// only a slight decrease in performance:

#define AA_X_WIDTH  8
#define AA_X_MASK   7
#define AA_X_HALF   4
#define AA_X_SHIFT  3

#define AA_Y_HEIGHT 4
#define AA_Y_MASK   3
#define AA_Y_HALF   2
#define AA_Y_SHIFT  2

// Calculate the new color channel value according to the coverage:
//
//      round((c * multiplier) / 2^(shift))

#define MULTIPLY_COVERAGE(c, multiplier, shift) \
    static_cast<UCHAR>((static_cast<UINT>(c) * (multiplier) \
                        + (1 << ((shift) - 1))) >> (shift))

// SWAP macro:

#define SWAP(temp, a, b) { temp = a; a = b; b = temp; }

enum PathEnumerateTermination {
    PathEnumerateContinue,      // more to come in this subpath
    PathEnumerateEndSubpath,    // end this subpath.
    PathEnumerateCloseSubpath   // end this subpath with a close figure.
};

typedef BOOL (*FIXEDPOINTPATHENUMERATEFUNCTION)(
    VOID *, POINT *, INT, PathEnumerateTermination
);

enum PathEnumerateType {
    PathEnumerateTypeStroke,
    PathEnumerateTypeFill,
    PathEnumerateTypeFlatten
};

BOOL 
FixedPointPathEnumerate(
    const DpPath *path,
    const GpMatrix *matrix,
    const RECT *clipRect,       
    PathEnumerateType enumType,                
    FIXEDPOINTPATHENUMERATEFUNCTION enumerateFunction,
    VOID *enumerateContext
    );

GpStatus
RasterizePath(
    const DpPath    *path,
    GpMatrix        *worldTransform,
    GpFillMode       fillMode,
    BOOL             antiAlias,
    BOOL             nominalWideLine,
    DpOutputSpan    *output,
    DpClipRegion    *clipper,
    const GpRect    *drawBounds
    );

#endif // _AARASTERIZER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\alphablender.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Alpha-blender
*
* Abstract:
*
*   A class which alpha-blends a source scanline in either sRGB or
*   sRGB64 format, to a destination of arbitrary format. 
*
* Revision History:
*
*   01/03/2000 agodfrey
*       Created it.
*   02/22/2001 agodfrey
*       Expanded it for different scan types (needed for ClearType).
*       Simplified the Initialize() parameters by adding a 
*       DpContext parameter.
*
\**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

// !!![agodfrey] Hack:
const ColorPalette*
GetDefaultColorPalette(PixelFormatID pixfmt);

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}
// !!![agodfrey] Endhack

// BLENDER_USE_DESTINATION and BLENDER_USE_SOURCE are used in the Src and 
// Dst fields of PipelineItem:
//    BLENDER_USE_SOURCE: Use the blend's original source  
//      (i.e. the sRGB/sRGB64 scanbuffer)
//    BLENDER_USE_DESTINATION: Use the blend's final destination.
//    BLENDER_INVALID: Used in the debug build for assertions.

#define BLENDER_USE_DESTINATION ((VOID *) 0)
#define BLENDER_USE_SOURCE ((VOID *) 1)
#define BLENDER_INVALID ((VOID *) 2)

using namespace ScanOperation;

/**************************************************************************\
*
* Special-case blend operations which blend directly to a given destination
* format (with the source in 32BPP_PARGB).
*
* Notes:
*
*   The 555/565 cases handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore destination alpha" formats, so we'd need to AlphaDivide after 
*   the blend.
*
\**************************************************************************/

ScanOpFunc ScanOperation::BlendOpsLowQuality[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_Blend_sRGB_555,        // PIXFMT_16BPP_RGB555
    Dither_Blend_sRGB_565,        // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    Blend_sRGB_24,                // PIXFMT_24BPP_RGB
    Blend_sRGB_sRGB,              // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    Blend_sRGB_sRGB,              // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    NULL,                         // PIXFMT_64BPP_PARGB
    Blend_sRGB_24BGR              // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Special-case gamma-corrected blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Notes:
*
*   The 555/565 cases must handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore destination alpha" formats, so we'd need to AlphaDivide after 
*   the blend.
*
\**************************************************************************/

ScanOpFunc ScanOperation::BlendOpsHighQuality[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    BlendLinear_sRGB_555,         // PIXFMT_16BPP_RGB555
    BlendLinear_sRGB_565,         // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    NULL,                         // PIXFMT_24BPP_RGB
    BlendLinear_sRGB_32RGB,       // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    NULL,                         // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    Blend_sRGB64_sRGB64,          // PIXFMT_64BPP_PARGB
    NULL                          // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format - either
* 32BPP_ARGB or 64BPP_ARGB).
*
* This is specific to EpAlphaBlender. EpFormatConverter uses a different
* table; some of the entries are different.
*
* The NULL entries for 32BPP_ARGB and 64_BPP_ARGB are used to indicate that no
* conversion is necessary.
*
* These operations work on all processors.
*
* Notes:
*
*   The 555/565 cases handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
\**************************************************************************/

ScanOpFunc ScanOperation::ABConvertFromCanonicalOps[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    HalftoneToScreen_sRGB_8_16,   // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_sRGB_555,              // PIXFMT_16BPP_RGB555
    Dither_sRGB_565,              // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,           // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,             // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,           // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,           // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,         // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR           // PIXFMT_24BPP_BGR
};

// Builder: Holds the intermediate state and logic used to build the
//   blending pipeline.

class EpAlphaBlender::Builder
{
public:
    Builder(
        PipelineItem *pipelinePtr,
        VOID **tempBuffers,
        GpCompositingMode compositingMode
        )
    {
        TempBuffers = tempBuffers;
        PipelinePtr = pipelinePtr;
        
        // At the start, the source and destination data are in external
        // buffers.
        
        CurrentDstBuffer = BLENDER_USE_DESTINATION;
        CurrentSrcBuffer = BLENDER_USE_SOURCE;
        
#if DBG        
        CompositingMode = compositingMode;
        if (compositingMode == CompositingModeSourceCopy)
        {
            // In SourceCopy mode, we never read from the destination -
            // we only write to it.
            
            CurrentDstBuffer = BLENDER_INVALID;
        }
#endif

        // At the start, all 3 buffers are free. We'll use buffer 0 first.
        // The 'current' source and destination buffers are external buffers,
        // but we set CurrentDstIndex and CurrentSrcIndex in such a way that
        // the 'free buffer' logic works.
        
        FreeBufferIndex = 0;
        CurrentDstIndex = 1;
        CurrentSrcIndex = 2;
    }
    
    BOOL IsEmpty(
        EpAlphaBlender &blender
        )
    {
        return PipelinePtr == blender.Pipeline;
    }

    VOID End(
        EpAlphaBlender &blender
        )
    {
        // Check that we have at least one operation
        ASSERT(!IsEmpty(blender));
        
        // Check that we haven't overstepped the end of the pipeline space
        ASSERT(((PipelinePtr - blender.Pipeline) / sizeof(blender.Pipeline[0])) 
               <= MAX_ITEMS);
        
        // Many of these cases will not have set the destination of the final 
        // item in the pipeline correctly (it's hard for them to know that 
        // they're doing the last item in the pipeline). So we explicitly set 
        // it here.
        
        (PipelinePtr-1)->Dst = BLENDER_USE_DESTINATION;
        
        #if DBG
            // Make further member function calls hit an assertion.
            PipelinePtr = NULL;
        #endif
    }
    
    VOID
    AddConvertSource(
        ScanOperation::ScanOpFunc op
        )
    {
        // Check that we're not calling this when we shouldn't
        
        ASSERT(CurrentSrcBuffer != BLENDER_INVALID);
        
        // Choose the next temporary buffer
        
        INT nextIndex = FreeBufferIndex;
        VOID *nextBuffer = TempBuffers[nextIndex];
        
        // Add the operation
        
        AddOperation(op, CurrentSrcBuffer, nextBuffer);
        CurrentSrcBuffer = nextBuffer;
        
        // Swap the 'free' and 'current' indices.
        
        FreeBufferIndex = CurrentSrcIndex;
        CurrentSrcIndex = nextIndex;
    }
    
    VOID
    AddConvertDestination(
        ScanOperation::ScanOpFunc op
        )
    {
        // Check that we're not calling this when we shouldn't
        
        ASSERT(CompositingMode != CompositingModeSourceCopy);
        ASSERT(CurrentDstBuffer != BLENDER_INVALID);

        // Choose the next temporary buffer
        
        INT nextIndex = FreeBufferIndex;
        VOID *nextBuffer = TempBuffers[nextIndex];
        
        // Add the operation
        
        AddOperation(op, CurrentDstBuffer, nextBuffer);
        CurrentDstBuffer = nextBuffer;
        
        // Swap the 'free' and 'current' indices.
        
        FreeBufferIndex = CurrentDstIndex;
        CurrentDstIndex = nextIndex;
    }
    
    VOID
    AddBlend(
        ScanOperation::ScanOpFunc op,
        EpAlphaBlender &blender
        )
    {
        // Check that we're not calling this when we shouldn't

        ASSERT(CompositingMode != CompositingModeSourceCopy);
        ASSERT(CurrentSrcBuffer != BLENDER_INVALID);
        ASSERT(CurrentDstBuffer != BLENDER_INVALID);
        
        ASSERT(CurrentDstBuffer != BLENDER_USE_SOURCE);
        
        // If we're going to have to convert the source blend pixels, initialize
        // 'BlendingScan' to point to the temporary buffer in which the 
        // converted pixels will end up. Otherwise, Blend() will have to 
        // initialize 'BlendingScan'.
        
        if (CurrentSrcBuffer != BLENDER_USE_SOURCE)
        {
            blender.ConvertBlendingScan = TRUE;
            blender.OperationParameters.BlendingScan = CurrentSrcBuffer;
        }
        else
        {
            blender.ConvertBlendingScan = FALSE;
        }

        // The pipeline doesn't necessarily end with a WriteRMW operation
        // (or with one which contains it). So we must avoid blending from
        // one temporary buffer to another - the blend functions aren't 
        // strictly ternary, and so we would end up leaving garbage values
        // in the target temporary buffer (whenever we blend a completely
        // transparent pixel).
        
        AddOperation(op, CurrentDstBuffer, CurrentDstBuffer);

#if DBG
        // After this, we shouldn't call AddConvertSource or AddBlend again.
        CurrentSrcBuffer = BLENDER_INVALID;
        
        // And if this blend wasn't to a temporary buffer, this should be
        // the final operation in the pipeline. In particular, the caller
        // shouldn't try to add a WriteRMW operation after this.
        
        if (CurrentDstBuffer == BLENDER_USE_DESTINATION)
        {
            CurrentDstBuffer = BLENDER_INVALID;
        }
#endif        
    }

protected:    
    // AddOperation: Adds an operation to the pipeline.
    
    VOID 
    AddOperation(
        ScanOperation::ScanOpFunc op, 
        VOID *src,
        VOID *dst
        )
    {
        ASSERT(PipelinePtr != NULL);
        ASSERT(op != NULL);
        ASSERT(src != BLENDER_INVALID);
        ASSERT(dst != BLENDER_INVALID);
        
        *PipelinePtr++ = PipelineItem(op, src, dst);
    }

    PipelineItem *PipelinePtr; // Points to the space for the next item
    
    VOID **TempBuffers;        // The 3 temporary scan-line buffers
    
    INT FreeBufferIndex;       // The index of the next free scan-line buffer
    
    VOID *CurrentDstBuffer;    // The buffer holding the most recently-converted
    VOID *CurrentSrcBuffer;    // dst/src pixels.
    
    INT CurrentDstIndex;       // The index of the scan-line buffer equal
    INT CurrentSrcIndex;       // to CurrentDstBuffer/CurrentSrcBuffer (kinda)

#if DBG
    GpCompositingMode CompositingMode;
#endif
};

/**************************************************************************\
*
* Function Description:
*
*   Initialize the alpha-blender object
*
* Arguments:
*
*   scanType           - The type of scan to output.
*   dstFormat          - The pixel format of the destination. This shouldn't be
*                        lower than 8bpp.
*   srcFormat          - The pixel format of the source. This should be either
*                        PIXFMT_32BPP_PARGB, or PIXFMT_64BPP_PARGB, except in
*                        SourceCopy mode, in which it can be any legal 
*                        destination format.
*   context            - The graphics context.
*   dstpal             - The destination color palette, if the destination is
*                        palettized. (Can be NULL, but we'll need a palette to 
*                        be supplied [via UpdatePalette()] some time before 
*                        Blend() is called.)
*   tempBuffers        - An array of 3 pointers to temporary buffers, which
*                        should be 64-bit aligned (for perf reasons),
*                        and have enough space to hold a scan of 64bpp pixels.
*   dither16bpp        - If TRUE, and the destination format is 16bpp: We should
*                        dither to the destination.
*   useRMW             - Use the RMW optimization.
*   compositingQuality - Specifies whether to do a high-quality 
*                        (gamma-corrected) blend. A gamma-corrected blend will
*                        be used if this flag says so, or if the source or
*                        destination are linear formats like PIXFMT_64BPP_PARGB.
*
* Notes:
*
*   This code speaks of "canonical" formats - it means the two formats
*   PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB.
*
*   !!! [agodfrey]: "canonical" is a confusing word. We should just say
*       "intermediate" format.
*
*   This function may be called multiple times during the lifetime of an
*   EpAlphaBlender object.
*
*   All error cases are flagged as ASSERTs, so there is no return code.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
EpAlphaBlender::Initialize(
    EpScanType scanType,
    PixelFormatID dstFormat,
    PixelFormatID srcFormat,
    const DpContext *context,
    const ColorPalette *dstpal,
    VOID **tempBuffers,
    BOOL dither16bpp,
    BOOL useRMW,
    ARGB solidColor
    )
{
    // Isolate all the references to 'context'. Later, we may want to solve
    // the 'batching across primitives' problem, and depending on how we do
    // it, we may not want the original context passed down to this function.
    
    const EpPaletteMap *paletteMap = context->PaletteMap;
    GpCompositingMode compositingMode = context->CompositingMode;
    GpCompositingQuality compositingQuality = context->CompositingQuality;
    UINT textContrast = context->TextContrast;

    // ClearType doesn't work with SourceCopy
    BOOL isClearType = (scanType == EpScanTypeCT || scanType == EpScanTypeCTSolidFill);
    if (isClearType)
    {
        ASSERT(compositingMode != CompositingModeSourceCopy);
    }

    ////////////////////////////// PRECONDITIONS ///////////////////////////////
    
    // We don't have Quantize/Halftone operations for pixel formats below 8bpp.
    // Calling code will handle <8bpp, if it wants to, by asking us to
    // draw to 8bpp, and using GDI to read/write to the <8bpp format.
    
    ASSERT(GetPixelFormatSize(dstFormat) >= 8);
    
    // The following destination formats are not supported
    
    ASSERT(IsSupportedPixelFormat(dstFormat));
    
    // This function currently only supports these two compositing modes.
    
    ASSERT(compositingMode == CompositingModeSourceCopy ||
           compositingMode == CompositingModeSourceOver);
    
    ////////////////////////////// INITIALIZATION //////////////////////////////
    
    // Lazy initialization for MMX-specific code.
    
    if (!Initialized)
    {
        // We only need to check CPUSpecificOps initialization the first
        // time this EpAlphaBlender is initialized. On subsequent calls,
        // we know that a call to CPUSpecificOps::Initialize() has already
        // completed.
        
        CPUSpecificOps::Initialize();
        Initialized = TRUE;
    }

    OperationParameters.TempBuffers[0]=tempBuffers[0];
    OperationParameters.TempBuffers[1]=tempBuffers[1];
    OperationParameters.TempBuffers[2]=tempBuffers[2];

    // Set SolidColor - only used for SolidFill scan types
    
    OperationParameters.SolidColor = solidColor;
    OperationParameters.TextContrast = textContrast;
    
    // The pipeline builder
    
    Builder builder(
        Pipeline,
        tempBuffers,
        compositingMode
        );
    
    INT dstfmtIndex = GetPixelFormatIndex(dstFormat);
    INT srcfmtIndex = GetPixelFormatIndex(srcFormat);
    
    BOOL dstExtended = IsExtendedPixelFormat(dstFormat);
    BOOL srcExtended = IsExtendedPixelFormat(srcFormat);
    
    OperationParameters.DoingDither = dither16bpp;
    
    // If the destination format doesn't have an alpha channel, we can make
    // a few optimizations. For example, we can avoid AlphaMultiply/AlphaDivide 
    // in some cases.
                                                        
    BOOL ignoreDstAlpha = !IsAlphaPixelFormat(dstFormat);
    
    // If the destination pixel format is an indexed color format,
    // get the color palette and palette map

    if (IsIndexedPixelFormat(dstFormat))
    {
        OperationParameters.Dstpal = OperationParameters.Srcpal = 
            (dstpal ? dstpal : GetDefaultColorPalette(dstFormat));
            
        OperationParameters.PaletteMap = paletteMap;    
    }
    
    // Process the 'compositingQuality' parameter

    BOOL highQuality = FALSE;
    switch (compositingQuality)
    {
    case CompositingQualityDefault:
    case CompositingQualityHighSpeed:
    case CompositingQualityAssumeLinear:
        break;
    
    case CompositingQualityHighQuality:
    case CompositingQualityGammaCorrected:
        highQuality = TRUE;
        break;
    
    default:
        RIP(("Unrecognized compositing quality: %d", compositingQuality));
        break;
    }
    
    // Work out whether our intermediate format (if we're doing SourceOver)
    // needs to be 32bpp or 64bpp.
    
    BOOL blendExtended = dstExtended || srcExtended || highQuality;
    if (isClearType)
        blendExtended = FALSE;
    
    // Decide on the 'convert from canonical' operation. (We do it now since
    // the logic is the same for all branches.)
    
    ScanOpFunc convertFromCanonical = ABConvertFromCanonicalOps[dstfmtIndex];
    
    switch (dstFormat)
    {
    case PIXFMT_8BPP_INDEXED:
        if (paletteMap && !paletteMap->IsVGAOnly())
        {
            convertFromCanonical = HalftoneToScreen_sRGB_8_216;
        }
        
        // If there is no palette map yet, we'll default to the 16-color 
        // halftone function. Later on, in UpdatePalette(), we'll update this 
        // function pointer if necessary. Ugh.
        break;
        
    case PIXFMT_32BPP_RGB:
        // ignoreDstAlpha should have been set to TRUE earlier.

        ASSERT(ignoreDstAlpha);
        
        // We can write garbage to the high byte, so we treat this
        // exactly as if the destination were ARGB. This avoids calling
        // Quantize_sRGB_32RGB and Convert_32RGB_sRGB.

        convertFromCanonical = NULL;
        dstFormat = PIXFMT_32BPP_ARGB;
        break;
        
    case PIXFMT_16BPP_RGB555:
    case PIXFMT_16BPP_RGB565:
        // The Dither_Blend_sRGB_555_MMX and Dither_Blend_sRGB_565_MMX
        // operations, unlike other blends, are not WriteRMW operations.
        // They sometimes write when a blend pixel is completely transparent.
        // So, we must not use a ReadRMW operation (otherwise we'd write garbage
        // to the destination.)
        
        if (OSInfo::HasMMX && !blendExtended && !isClearType)
        {
            useRMW = FALSE;
        }
        break;
    }
        
    /////////////////////////// SOURCECOPY / OPAQUE ////////////////////////////
    
    if (   (scanType == EpScanTypeOpaque)
        || (compositingMode == CompositingModeSourceCopy))
    {
        // (See bug #122441).
        // 
        // We can now tell the difference between opaque input and general
        // SourceCopy. But I can't fix the bug right now. So, for now
        // we treat SourceCopy like the opaque case.
        //
        // This gives the wrong answer if the Graphics has SourceCopy mode set
        // and the user is drawing semitransparent pixels. Note that they need
        // to be doing this to a non-alpha surface to hit this case, 
        // which is pretty dumb anyway.
        
        if (srcFormat == PIXFMT_32BPP_PARGB
            && ignoreDstAlpha
            && !dstExtended)
        {
            // At this point, the destination shouldn't be 32BPP_PARGB, because
            // we want that to be handled with a simple Copy_32 operation.
            // But that's okay - we shouldn't be here if the destination is
            // 32BPP_PARGB, because ignoreDstAlpha shouldn't be TRUE.
            
            ASSERT(dstFormat != PIXFMT_32BPP_PARGB);
            
            srcFormat = PIXFMT_32BPP_ARGB;
        }
        
        // If the formats are identical, just use a copy operation.
        
        if (srcFormat == dstFormat)
        {
            builder.AddConvertSource(CopyOps[dstfmtIndex]);
            goto PipelineDone;
        }
        
        // We don't check for other special case conversion operations for 
        // SourceCopy, because:
        // 1) I'm lazy
        // 2) We don't have any at the moment
        // 3) If the source isn't in one of the canonical formats, we expect 
        //    that the destination will be the same format. Otherwise, it's
        //    not a perf-important scenario, at least not right now.
        
        
        // Convert to the nearest canonical format, if necessary
        
        if (srcFormat != PIXFMT_32BPP_ARGB &&
            srcFormat != PIXFMT_64BPP_ARGB)
        {
            builder.AddConvertSource(ConvertIntoCanonicalOps[srcfmtIndex]);
        }
        
        // Convert to the other canonical format, if necessary
        
        if (srcExtended != dstExtended)
        {
            builder.AddConvertSource(
                srcExtended ? 
                    GammaConvert_sRGB64_sRGB :
                    GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the destination format, if necessary
                
        if (convertFromCanonical)
        {
            builder.AddConvertSource(convertFromCanonical);
        }
        
        // At least one of these should have added an operation (since
        // the case where the source and destination formats are identical
        // was handled already).
        
        ASSERT(!builder.IsEmpty(*this));
        
        goto PipelineDone;
    }

    ////////////////////////// SOURCEOVER / CLEARTYPE //////////////////////////

    ASSERT(   (scanType == EpScanTypeBlend)
           || isClearType);
    
    // The pseudocode is as follows:
    // * Handle ReadRMW
    // * Check for a special-case blend
    // * Convert source to blend format
    // * Convert destination to blend format
    // * Blend
    // * Convert to destination format
    // * WriteRMW

    // * Handle ReadRMW
    
    // We'll also decide which WriteRMW operation to use at the end.

    ScanOpFunc writeRMWfunc;
    ScanOpFunc readRMWfunc;
        
    writeRMWfunc = NULL;
    readRMWfunc = NULL;
   
    if (useRMW)
    {    
        if (isClearType)
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 16:
                if (scanType == EpScanTypeCT)
                {
                    readRMWfunc = ReadRMW_16_CT_CARGB;
                    writeRMWfunc = WriteRMW_16_CT_CARGB;
                }
                else
                {
                    readRMWfunc = ReadRMW_16_CT_Solid;
                    writeRMWfunc = WriteRMW_16_CT_Solid;
                }
                break;
            case 24:
                if (scanType == EpScanTypeCT)
                {
                    readRMWfunc = ReadRMW_24_CT_CARGB;
                    writeRMWfunc = WriteRMW_24_CT_CARGB;
                }
                else
                {
                    readRMWfunc = ReadRMW_24_CT_Solid;
                    writeRMWfunc = WriteRMW_24_CT_Solid;
                }
                break;
            }
        }
        else
        if (blendExtended)
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 8:
                readRMWfunc = ReadRMW_8_sRGB64;
                writeRMWfunc = WriteRMW_8_sRGB64;
                break;
            case 16:
                // For special-case high quality blends to 16bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_16_sRGB64;
                // writeRMWfunc = WriteRMW_16_sRGB64;
                break;
            case 24:
                readRMWfunc = ReadRMW_24_sRGB64;
                writeRMWfunc = WriteRMW_24_sRGB64;
                break;
            case 32:
                // For special-case high quality blends to 32bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_32_sRGB64;
                // writeRMWfunc = WriteRMW_32_sRGB64;
                break;
            }
        }
        else
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 8:
                readRMWfunc = ReadRMW_8_sRGB;
                writeRMWfunc = WriteRMW_8_sRGB;
                break;
            case 16:
                readRMWfunc = ReadRMW_16_sRGB;
                writeRMWfunc = WriteRMW_16_sRGB;
                break;
            case 24:
                readRMWfunc = ReadRMW_24_sRGB;
                writeRMWfunc = WriteRMW_24_sRGB;
                break;
            case 32:
                // For special-base blends to 32bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_32_sRGB;
                // writeRMWfunc = WriteRMW_32_sRGB;

                break;
            }
        }
        
        // We won't actually add the ReadRMW here. For example, if the source is
        // 32bpp and we want to do an extended blend, we need to convert
        // the source before doing the ReadRMW.
        //
        // However, we needed the logic here so that the special-case blend
        // code doesn't need to duplicate it.
    }
    
    // * Check for a special-case blend
    
    ScanOpFunc specialCaseBlend;
    specialCaseBlend = NULL;
    
    if (scanType == EpScanTypeBlend && !srcExtended)
    {
        if (blendExtended)
        {
            specialCaseBlend = BlendOpsHighQuality[dstfmtIndex];
        }
        else
        {
            specialCaseBlend = BlendOpsLowQuality[dstfmtIndex];
        }
    
        if (specialCaseBlend)
        {
            // If we're supposed to ReadRMW, do it now.
            
            if (readRMWfunc)
            {
                builder.AddConvertDestination(readRMWfunc);
            }
            
            // Dither_Blend_sRGB_555_MMX and Dither_Blend_sRGB_565_MMX
            // don't work with ReadRMW. Earlier code should have handled
            // it, so we'll just assert it here.

            ASSERT(!(   (   (specialCaseBlend == Dither_Blend_sRGB_555_MMX)
                         || (specialCaseBlend == Dither_Blend_sRGB_565_MMX)
                        ) 
                     && (useRMW)));

            builder.AddBlend(specialCaseBlend, *this);
            goto PipelineDone;
        }
    }
    
    // * Convert source to blend format
    
    // We currently only support source data other than 32BPP_PARGB and
    // 64BPP_PARGB for the SourceCopy case.
    
    ASSERT(   (srcFormat == PIXFMT_32BPP_PARGB)
           || (srcFormat == PIXFMT_64BPP_PARGB));
           
    if (blendExtended && !srcExtended)
    {
        // Unfortunately, the source is premultiplied and we need to gamma
        // convert it. We must divide by the alpha first, and remultiply
        // afterwards.
        
        builder.AddConvertSource(AlphaDivide_sRGB);
        builder.AddConvertSource(GammaConvert_sRGB_sRGB64);
        builder.AddConvertSource(AlphaMultiply_sRGB64);
    }    
    
    // * Handle ReadRMW (continued)
    
    if (readRMWfunc)
    {
        builder.AddConvertDestination(readRMWfunc);
    }
            
    // * Convert destination to blend format

    // Skip this if it's already in the blend format
    if (   (blendExtended  && dstFormat != PIXFMT_64BPP_PARGB)
        || (!blendExtended && dstFormat != PIXFMT_32BPP_PARGB))
    {
        
        // Convert to the nearest canonical format, if necessary
        
        if (dstFormat != PIXFMT_32BPP_ARGB &&
            dstFormat != PIXFMT_64BPP_ARGB)
        {
            builder.AddConvertDestination(ConvertIntoCanonicalOps[dstfmtIndex]);
        }
        
        // Convert to sRGB64, if necessary
        
        if (!srcExtended && blendExtended)
        {
            builder.AddConvertDestination(GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the premultiplied version, if necessary
        
        if (!ignoreDstAlpha)
        {
            builder.AddConvertDestination(
                blendExtended ?
                    AlphaMultiply_sRGB64 :
                    AlphaMultiply_sRGB);
        }
    }
    
    // * Blend

    if (scanType == EpScanTypeCT)
    {
        builder.AddBlend(CTBlendCARGB, *this);
    }
    else if (scanType == EpScanTypeCTSolidFill)
    {
        builder.AddBlend(CTBlendSolid, *this);
    }
    else
    {
        builder.AddBlend(
            blendExtended ? 
            BlendOpsHighQuality[GetPixelFormatIndex(PIXFMT_64BPP_PARGB)]:
            BlendOpsLowQuality[GetPixelFormatIndex(PIXFMT_32BPP_PARGB)],
            *this);
    }

    // * Convert to destination format
    
    // Skip this if it's already in the destination format
    if (   (blendExtended  && dstFormat != PIXFMT_64BPP_PARGB)
        || (!blendExtended && dstFormat != PIXFMT_32BPP_PARGB))
    {
        // Convert to the nearest nonpremultiplied, if necessary
        
        if (!ignoreDstAlpha)
        {
            builder.AddConvertDestination(
                blendExtended ?
                    AlphaDivide_sRGB64 :
                    AlphaDivide_sRGB);
        }
        
        // Convert to the other canonical format, if necessary
        
        if (blendExtended != dstExtended)
        {
            builder.AddConvertDestination(
                blendExtended ? 
                    GammaConvert_sRGB64_sRGB :
                    GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the destination format, if necessary
                
        if (convertFromCanonical)
        {
            builder.AddConvertDestination(convertFromCanonical);
        }
    }
    
    // * WriteRMW
        
    if (writeRMWfunc)
    {
        builder.AddConvertDestination(writeRMWfunc);
    }

PipelineDone:    
    
    builder.End(*this);
}

/**************************************************************************\
*
* Function Description:
*
*   Blend source pixels to the given destination.
*
* Arguments:
*
*   dst      - The destination buffer
*   src      - The source pixels to blend
*   width    - The number of pixels in the source/destination buffers
*   dither_x - The x and y offsets of the destination scanline into the 
*   dither_y -   halftone or dither matrix (implicit mod the matrix size).
*   ctBuffer - The ClearType coverage buffer, or NULL for non-ClearType
*                scan types.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/
    
VOID 
EpAlphaBlender::Blend(
    VOID *dst, 
    VOID *src, 
    UINT width,
    INT dither_x,
    INT dither_y,
    BYTE *ctBuffer
    )
{
    if (!width) 
    {
        return;
    }
    
    // If ConvertBlendingScan is TRUE, then Initialize() will already
    // have set BlendingScan to point to one of the temporary buffers.
    
    if (!ConvertBlendingScan)
    {
        OperationParameters.BlendingScan = src;
    }
    
    OperationParameters.CTBuffer = ctBuffer;
    OperationParameters.X = dither_x;
    OperationParameters.Y = dither_y;
            
    PipelineItem *pipelinePtr = &Pipeline[0];
    const VOID *currentSrc;
    VOID *currentDst;
    BOOL finished = FALSE;
    
    do
    {
        currentSrc = pipelinePtr->Src;
        currentDst = pipelinePtr->Dst;
        
        // We should never write to the original source, because we don't
        // control that memory.
        
        ASSERT (currentDst != BLENDER_USE_SOURCE);
        
        // Translate BLENDER_USE_SOURCE and BLENDER_USE_DESTINATION
        
        if (currentSrc == BLENDER_USE_SOURCE)
        {
            currentSrc = src;
        }
        
        if (currentSrc == BLENDER_USE_DESTINATION)
        {
            currentSrc = dst;
        }
        
        if (currentDst == BLENDER_USE_DESTINATION)
        {
            currentDst = dst;
            finished = TRUE;
        }
        
        pipelinePtr->Op(currentDst, currentSrc, width, &OperationParameters);
        pipelinePtr++;
    } while (!finished);
}

/**************************************************************************\
*
* Function Description:
*
*   Update the palette/palette map.
*
* Arguments:
*
*   dstpal          - The destination color palette.
*   paletteMap      - The palette map for the destination.
*
* Notes:
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
EpAlphaBlender::UpdatePalette(
    const ColorPalette *dstpal, 
    const EpPaletteMap *paletteMap
    )
{
    ASSERT(dstpal && paletteMap);
    
    BOOL wasVGAOnly = (!OperationParameters.PaletteMap) || 
                      (OperationParameters.PaletteMap->IsVGAOnly());
    
    OperationParameters.Srcpal = OperationParameters.Dstpal = dstpal;
    OperationParameters.PaletteMap = paletteMap;
    
    // Detect whether we need to change the halftone function.
    
    if (wasVGAOnly != paletteMap->IsVGAOnly())
    {
        ScanOpFunc before, after;
        
        if (wasVGAOnly)
        {
            before = HalftoneToScreen_sRGB_8_16;
            after = HalftoneToScreen_sRGB_8_216;
        }
        else
        {
            before = HalftoneToScreen_sRGB_8_216;
            after = HalftoneToScreen_sRGB_8_16;
        }
        
        // Search the pipeline for the 'before' function, and replace it with
        // the 'after' function.
        
        PipelineItem *pipelinePtr = Pipeline;
        
        while (1)
        {
            if (pipelinePtr->Op == before)
            {
                pipelinePtr->Op = after;
            }

            if (pipelinePtr->Dst == BLENDER_USE_DESTINATION)
            {
                break;
            }
            pipelinePtr++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\bicubic.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bicubic.hpp
*
* Abstract:
*
*   Bicubic Resampling code
*
* Created:
*
*   11/03/1999 ASecchia
\**************************************************************************/

#pragma once

class DpOutputBicubicImageSpan : public DpOutputSpan
{
public:
    DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *  Scan;
    WrapMode BWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;
    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:
    DpOutputBicubicImageSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
    );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
    );

    virtual GpStatus OutputSpanIncremental(
        INT      y,
        INT      xMin,
        INT      xMax,
        FIX16    x0,
        FIX16    y0,
        FIX16    dx,
        FIX16    dy
    );

    virtual BOOL IsValid() const { return (dBitmap!=NULL); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\cpuspecificops.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CPU-specific scan operations
*
* Abstract:
*
*   Handles scan operations which only work on certain CPU's. 
*   Currently only used by EpAlphaBlender. This works by overwriting the
*   function pointer arrays with ones holding CPU-specific information.
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _CPUSPECIFICOPS_HPP
#define _CPUSPECIFICOPS_HPP

namespace CPUSpecificOps
{
    VOID Initialize();       // Sets up the function pointer arrays.
                             // Should only be called once (we ASSERT).
    
    extern BOOL Initialized; // Whether Initialize() has been called yet.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\cpuspecificops.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CPU-specific scan operations
*
* Abstract:
*
*   Handles scan operations which only work on certain CPU's. 
*   Currently only used by EpAlphaBlender. This works by overwriting the
*   function pointer arrays with ones holding CPU-specific information.
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

using namespace ScanOperation;

// This variable records whether Initialize() has been called yet.

BOOL CPUSpecificOps::Initialized = FALSE;

/**************************************************************************\
*
* Special-case low-quality blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Some of these operations may use MMX instructions.
*
* Notes:
*
*   The 555/565 cases support both dithering and non-dithering, via the flag
*   OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore alpha" formats, so we'd need to AlphaDivide after the blend.
*
\**************************************************************************/

static ScanOpFunc BlendOpsLowQuality_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_Blend_sRGB_555_MMX,    // PIXFMT_16BPP_RGB555
    Dither_Blend_sRGB_565_MMX,    // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    Blend_sRGB_24,                // PIXFMT_24BPP_RGB
    Blend_sRGB_sRGB_MMX,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    Blend_sRGB_sRGB_MMX,          // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    NULL,                         // PIXFMT_64BPP_PARGB
    Blend_sRGB_24BGR              // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Special-case gamma-corrected blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Some of these operations may use MMX instructions.
*
* Notes:
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore alpha" formats, so we'd need to AlphaDivide after the blend.
*
\**************************************************************************/

static ScanOpFunc BlendOpsHighQuality_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    BlendLinear_sRGB_555_MMX,     // PIXFMT_16BPP_RGB555
    BlendLinear_sRGB_565_MMX,     // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    NULL,                         // PIXFMT_24BPP_RGB
    BlendLinear_sRGB_32RGB_MMX,   // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    NULL,                         // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    Blend_sRGB64_sRGB64_MMX,      // PIXFMT_64BPP_PARGB
    NULL                          // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format - either
* 32BPP_ARGB or 64BPP_ARGB).
*
* This is specific to EpAlphaBlender. EpFormatConverter uses a different
* table; some of the entries are different.
*
* The NULL entries for 32BPP_ARGB and 64_BPP_ARGB are used to indicate that no
* conversion is necessary.
*
* Some of these operations use MMX instructions.
*
* Notes:
*
*   The 555/565 cases support both dithering and non-dithering, via the flag
*   OtherParams::DoingDither.
*
*   For 8bpp, we use the 16-color halftoning function. Initialize() will
*   need to work out if it can use something better, like the 216-color
*   halftone function. We should really have a 'nearest-color-matching' function
*   here, to support drawing to bitmaps with arbitrary palettes (the "16 VGA
*   colors" assumption is only true for the screen.)
*
\**************************************************************************/

static ScanOpFunc ABConvertFromCanonicalOps_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    HalftoneToScreen_sRGB_8_16,   // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_sRGB_555_MMX,          // PIXFMT_16BPP_RGB555
    Dither_sRGB_565_MMX,          // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,           // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,             // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,           // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,           // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,         // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR           // PIXFMT_24BPP_BGR
};

/**************************************************************************
*
* Function Description:
*
*   Initializes the function pointer arrays with processor-specific
*   data. Should only be called once.
* 
* Return Value:
*
*   NONE
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
CPUSpecificOps::Initialize()
{
    // Thread-protect the access to the global "Initialized" and
    // the function pointer arrays. Beware: Users of these tables (currently
    // only EpAlphaBlender::Initialize()) must be careful when they read those
    // arrays. They must either protect the access under this critical section,
    // or simply ensure that they've called this function first.

    LoadLibraryCriticalSection llcs; // Hey, it's an 'initialization' critsec!
    
    // Make sure no-one calls us before OSInfo::HasMMX is initialized
    
    #if DBG
    
    static BOOL noMMX = FALSE;
    ASSERT(!(noMMX && OSInfo::HasMMX));
    if (!OSInfo::HasMMX)
    {
        noMMX = TRUE;
    }
    
    #endif
    
    if (!Initialized)
    {
        INT i;
        
        if (OSInfo::HasMMX)
        {
            for (i=0; i<PIXFMT_MAX; i++)
            {
                BlendOpsLowQuality[i] = BlendOpsLowQuality_MMX[i];
                BlendOpsHighQuality[i] = BlendOpsHighQuality_MMX[i];
                ABConvertFromCanonicalOps[i] = ABConvertFromCanonicalOps_MMX[i];
            }
        }
        
        Initialized = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\drawcachedbitmap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Software rasterizer code for drawing a CachedBitmap
*
* Created:
*
*   05/18/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

// Class to output a clipped span for a CachedBitmap

class DpOutputCachedBitmapSpan : public DpOutputSpan
{
    EpScanRecord *InputBuffer;
    DpScanBuffer *Scan;
    INT XOff, YOff;           // coordinates of the top left corner.
    INT PixelSize;
    
    public: 

    DpOutputCachedBitmapSpan(
        DpScanBuffer *scan,
        INT x, 
        INT y
    )
    {
        Scan = scan;
        InputBuffer = NULL;
        XOff = x;
        YOff = y;
    }

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        // Can't draw anything if the buffer hasn't been set correctly.

        ASSERT(InputBuffer != NULL);
        ASSERT(YOff + InputBuffer->Y == y);
        ASSERT(xMax-xMin <= InputBuffer->Width);

        // Get an output buffer.

        void *buffer;
        
        buffer = Scan->NextBuffer(
            xMin, y, 
            xMax-xMin, 
            InputBuffer->BlenderNum
        );
        
        // Get a pointer to the start of the scanline.
        
        void *ib = InputBuffer->GetColorBuffer();

        INT pixelSize = PixelSize;

        // InputBuffer->X + XOff is the x starting position on the screen.
        // Make sure we're not trying to draw off to the left of our data.

        ASSERT(xMin >= (InputBuffer->X+XOff));
        ib = (void *) ( (BYTE *)(ib) + 
                        (xMin - (InputBuffer->X+XOff))*pixelSize);
        
        // Copy the input buffer to the output buffer.

        GpMemcpy(buffer, ib, (xMax-xMin)*pixelSize);

        // Cannot fail this routine.

        return Ok;
    }

    // Initialize the class with a new scan record.
    // This is used when we want to start processing a new batch record.

    void SetInputBuffer(
        EpScanRecord *ib,
        INT pixelSize
        ) 
    { 
        InputBuffer = ib; 
        PixelSize = pixelSize;
    }

    // We're always valid.

    virtual int IsValid() const {return TRUE;}
};


/**************************************************************************
*
* Function Description:
*
*   Software Rasterizer code for drawing a DpCachedBitmap
*
* Arguments:
*
*   context - the graphics context.
*   src     - the DpCachedBitmap to draw from
*   dst     - where the output goes
*   x, y    - offset - position to draw the top left corner of the CachedBitmap.
*
* Return Value:
*
*   GpStatus.
*
* Notes:
*   
*   This driver entry point expects the input to be in device coordinates
*   so the caller has to pre compute the world to device transform.
*   This is contrary to how most of our driver entry points work.
*
* Created:
*
*   05/18/2000 asecchia
*      Created it.
*
**************************************************************************/
GpStatus
DpDriver::DrawCachedBitmap(
    DpContext *context,
    DpCachedBitmap *src,
    DpBitmap *dst,
    INT x, INT y               // Device coordinates!
)
{
    ASSERT(context);
    ASSERT(src);
    ASSERT(dst);
    
    // Let's go make sure the Surface pixel format and the CachedBitmap
    // opaque format match.
    // The exception is for 32bppRGB which can draw onto anything.
    // This format is used in the multi-mon case where the individual
    // screen devices can be in multiple formats.
    // When 64bpp formats become first class citizens, we may want to 
    // update this condition.
    
    if((dst->PixelFormat != src->OpaqueFormat) &&
       (src->OpaqueFormat != PixelFormat32bppRGB))
    {
        return WrongState;
    }
    
    // Ignore the world to device transform - this driver entry point is
    // somewhat unique in that it expects device coordinates.

    // Initialize the DpScanBuffer.
    // This hooks us up to the appropriate DpScanXXX class for outputting our
    // data to the destination device.

    DpScanBuffer scanBuffer(
        dst->Scan,
        this,
        context,
        dst,
        FALSE,
        EpScanTypeBlend,
        src->SemiTransparentFormat,
        src->OpaqueFormat
    );
    
    if(!scanBuffer.IsValid())
    {
        return(GenericError);
    }

    // Set up the clipping.

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion *clipRegion = NULL;

    if(context->VisibleClip.GetRectVisibility(
        x, y,
        x+src->Width,
        y+src->Height
        ) != DpRegion::TotallyVisible
       )
    {
        clipRegion = &(context->VisibleClip);
    }
   
    GpRect clippedRect;
    
    if(clipRegion)
    {
        visibility = clipRegion->GetRectVisibility(
            x, y, 
            x+src->Width,
            y+src->Height,
            &clippedRect
        );
    }

    // Decide on our clipping strategy.

    switch (visibility)
    {

        case DpRegion::TotallyVisible:    // no clipping is needed
        {        
            // Copy the scanlines to the destination buffer
        
            // ProcessBatch requests that the DpScan class handle the entire
            // batch as a single block. If it can't it will return FALSE and
            // we fall through into the general purpose code below.
        
            BOOL batchSupported = scanBuffer.ProcessBatch(
                src->RecordStart, 
                src->RecordEnd,
                x, 
                y,
                x+src->Width,
                y+src->Height
            );
            
            if(batchSupported)
            {
                // The scanBuffer supports ProcessBatch; we're done.
                break;
            }
            
            // The scanBuffer doesn't support the ProcessBatch routine.
            // Lets manually enumerate the batch structure into the destination.
            // Fall through into the manual enumeration code:
        }
                
        // !!! PERF [asecchia] We have a perf problem when there is no clipping
        //     except the standard surface bounds. DCI/GDI would be able to clip
        //     this directly, but we aren't sure how to robustly detect this
        //     optimization and ignore the clip rectangle. This does not impact
        //     the fully visible case. Also it's not appropriate to make this
        //     optimization unless we're using DpScanGdiDci as our output device.
    
        case DpRegion::ClippedVisible:   
        case DpRegion::PartiallyVisible:  // some clipping is needed            
        {
            // Create the OutputSpan class for the CachedBitmap.
            // Create this on the stack because it has very little storage
            // and we can avoid a malloc. It gets cleaned up when we go out
            // of scope.

            DpOutputCachedBitmapSpan output(
                &scanBuffer, 
                x, 
                y
            );

            // Initialize the clipper to point to the clip region and
            // create the clpping chain by tacking the output created above
            // on to the end of the list.
          
            DpOutputSpan *clipper;
            if(clipRegion)
            {
                clipper = clipRegion;
                clipRegion->InitClipping(&output, y);
            }
            else
            {
                // no clipping required - possible due to the fallthrough case
                // in the fully visible codepath.
               
                clipper = &output;
            }
            
            // Lets manually enumerate the batch structure into the destination
            // taking into account clipping

            // First set up the running record pointer to the beginning of the
            // batch and a sentinel for the end.

            EpScanRecord *record = src->RecordStart;
            EpScanRecord *batchEnd = src->RecordEnd;

            // For all the batch records, Draw them on the destination.

            while(record < batchEnd) 
            {
                PixelFormatID format;
                if (record->BlenderNum == 0)
                {
                    format = src->SemiTransparentFormat;
                }
                else
                {
                    ASSERT(record->BlenderNum == 1);
                    format = src->OpaqueFormat;
                }
                
                INT pixelSize = GetPixelFormatSize(format) >> 3;
            
                // Set the output span buffer

                output.SetInputBuffer(record, pixelSize);

                // Draw this span

                INT x1 = x+record->X;
                INT x2 = x+record->X+record->Width;
                clipper->OutputSpan(y+record->Y, x1, x2);
                
                // Advance to the next record:

                record = record->NextScanRecord(pixelSize);
            }


        }
        break;
        
        case DpRegion::Invisible:         // nothing on screen - quit
        break;
    }


    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\drawimage.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   drawimage.cpp
*
* Abstract:
*
*   Software Rasterizer DrawImage routine and supporting functionality.
*
* Revision History:
*
*    10/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

// Include the template class definitions for the stretch
// filter modes.

#include "stretch.inc"

namespace DpDriverActiveEdge {

    // We make an array of these for use in the dda computation.

    struct PointFIX4
    {
        FIX4 X;
        FIX4 Y;
    };

    // Vertex iterator.
    // Has two Proxy methods for accessing the dda

    class DdaIterator
    {
        private:
        GpYDda dda;
        PointFIX4 *vertices;
        INT numVertices;
        INT direction;
        INT idx;          // keep this so we don't infinite loop on
                          // degenerate case
        INT idx1, idx2;
        BOOL valid;

        public:

        // GpYDda Proxy-like semantics

        INT GetX()
        {
            return dda.GetX();
        }

        // Initialize the dda and traversal direction

        DdaIterator(PointFIX4 *v, INT n, INT d, INT idx)
        {
            vertices=v;
            numVertices=n;
            ASSERT( (d==-1)||(d==1) );
            direction = d;
            ASSERT( (idx>=0)&&(idx<n) );
            this->idx=idx;
            idx1=idx;
            idx2=idx;
            valid = AdvanceEdge();
        }

        BOOL IsValid() { return valid; }

        // Advance to the next edge and initialize the dda.
        // Return FALSE if we're done.

        BOOL Next(INT y)
        {
            if(dda.DoneWithVector(y))
            {
                return AdvanceEdge();
            }

            // TRUE indicates more to do.

            return TRUE;
        }

        private:

        // Advance the internal state to the next edge.
        // Ignore horizontal edges.
        // Return FALSE if we're done.

        BOOL AdvanceEdge()
        {
            do {
                idx2 = idx1;
                if(direction==1)
                {
                    idx1++;
                    if(idx1>=numVertices) { idx1 = 0; }
                }
                else
                {
                    idx1--;
                    if(idx1<0) { idx1 = numVertices-1; }
                }

            // Loop till we get a non-horizontal edge.
            // Make sure we don't have an infinite loop on all horizontal edges.
            // The Ceiling is used to make almost horizontal lines appear to be
            // horizontal - this allows the algorithm to correctly compute the
            // end terminating case.

            } while(( GpFix4Ceiling(vertices[idx1].Y) ==
                      GpFix4Ceiling(vertices[idx2].Y) ) &&
                    (idx1!=idx));

            if(GpFix4Ceiling(vertices[idx1].Y) >
               GpFix4Ceiling(vertices[idx2].Y) )
            {
                // Initialize the dda

                dda.Init(
                    vertices[idx2].X,
                    vertices[idx2].Y,
                    vertices[idx1].X,
                    vertices[idx1].Y
                );
                return TRUE;
            }

            // terminate if we've wrapped around and started to come back up.
            // I.e return FALSE if we should stop.

            return FALSE;
        }

    };

} // End namespace DpDriverActiveEdge


/**************************************************************************\
*
* Function Description:
*
*   This handles axis aligned drawing. The cases include identity,
*   integer translation, general translation and scaling.
*
* Arguments:
*
*   output - span class to output the scanlines to.
*   dstTL  - top left destination point.
*   dstBR  - bottom right destination point.
*
* History:
*   10/19/1999 asecchia   created it.
*
\**************************************************************************/

VOID StretchBitsMainLoop(
    DpOutputSpan *output,
    GpPoint *dstTL,
    GpPoint *dstBR
    )
{
    // Input coordinates must be correctly ordered. This assumtion is required
    // by the output span routines which must have the spans come in strictly
    // increasing y order.

    ASSERT(dstTL->X < dstBR->X);
    ASSERT(dstTL->Y < dstBR->Y);

    // Main loop - output each scanline.

    const INT left = dstTL->X;
    const INT right = dstBR->X;

    for(INT y=dstTL->Y; y<(dstBR->Y); y++)
    {
        output->OutputSpan(y, left, right);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   CreateBilinearOutputSpan
*   Creates a bilinear or identity outputspan based on our hierarchy
*   of span classes.
*
* Arguments:
*
*   bitmap           - driver surface
*   scan             - scan class
*   xForm            - source rect to destination parallelogram transform
*   imageAttributes  - encapsulates the wrap mode settings.
*
* Return Value:
*
*   DpOutputSpan     - returns the created output span (NULL for failure)
*
* History:
*
*   09/03/2000 asecchia
*   borrowed this from the brush code.
*
\**************************************************************************/

DpOutputSpan*
CreateBilinearOutputSpan(
    IN DpBitmap *bitmap,
    IN DpScanBuffer *scan,
    IN GpMatrix *xForm,      // source rectangle to destination coordinates in
                             // device space.
    IN DpContext *context,
    IN DpImageAttributes *imageAttributes,
    IN bool fLargeImage      // need to handle really large stretches.
                             // usually used for stretch algorithms that punted
                             // due to overflow in internal computation.
    )
{
    // Validate input parameters.

    ASSERT(bitmap);
    ASSERT(scan);
    ASSERT(xForm);
    ASSERT(context);
    ASSERT(imageAttributes);

    DpOutputBilinearSpan *textureSpan;
    GpMatrix brushTransform;
    GpMatrix worldToDevice;

    // Go through our heirarchy of scan drawers:

    if ((!fLargeImage) &&
        xForm->IsIntegerTranslate() &&
        ((imageAttributes->wrapMode == WrapModeTile) ||
         (imageAttributes->wrapMode == WrapModeClamp)))
    {
        textureSpan = new DpOutputBilinearSpan_Identity(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }
    else if ((!fLargeImage) &&
             OSInfo::HasMMX &&
             GpValidFixed16(bitmap->Width) &&
             GpValidFixed16(bitmap->Height))
    {
        textureSpan = new DpOutputBilinearSpan_MMX(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }
    else
    {
        textureSpan = new DpOutputBilinearSpan(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }

    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    return textureSpan;
}

/**************************************************************************\
*
* Function Description:
*
*   CreateOutputSpan
*   Creates an outputspan based on our hierarchy of span classes.
*
* Arguments:
*
*   bitmap           - driver surface
*   scan             - scan class
*   xForm            - source rect to destination parallelogram transform
*   imageAttributes  - encapsulates the wrap mode settings.
*   filterMode       - which InterpolationMode setting to use
*
* Notes:
*
*   The long term plan is to make this and the similar routines in the
*   texture brush code converge. We'd like one routine doing this for
*   all the texture output spans and have both the texture brush and the
*   drawimage reuse the same code and support all the same filter/wrap
*   modes.
*
* Return Value:
*
*   DpOutputSpan     - returns the created output span (NULL for failure)
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

DpOutputSpan *CreateOutputSpan(
    IN DpBitmap *bitmap,
    IN DpScanBuffer *scan,
    IN GpMatrix *xForm,      // source rectangle to destination coordinates in
                             // device space.
    IN DpImageAttributes *imageAttributes,
    IN InterpolationMode filterMode,

    // !!! [asecchia] shouldn't need any of this following stuff - the above
    // bitmap and xForm should be sufficient.
    // The possible exception is the srcRect which may be required if we
    // ever implement the clamp-to-srcRect feature.

    IN DpContext *context,
    IN const GpRectF *srcRect,
    IN const GpRectF *dstRect,
    IN const GpPointF *dstPoints,
    IN const INT numPoints
)
{
    // Validate input parameters.

    ASSERT(bitmap);
    ASSERT(scan);
    ASSERT(xForm);
    ASSERT(imageAttributes);

    // Validate the stuff we had to pass through for the
    // OutputSpan routines that can't handle the xForm.

    ASSERT(context);
    ASSERT(srcRect);
    ASSERT(dstRect);
    ASSERT(dstPoints);
    ASSERT(numPoints == 3);

    bool fPunted = false; 
    
    // Initialize up front so that all the error-out paths are covered.

    DpOutputSpan *output = NULL;

    // Copy to local so that we can modify it without breaking the
    // input parameter consistency.

    InterpolationMode theFilterMode = filterMode;

    // The so-called 'identity' transform which counter-intuitively includes
    // integer only translation.

    if(xForm->IsIntegerTranslate())
    {
        // Use a much simplified output span class for
        // special case CopyBits.
        // The big win is due to the fact that integer
        // translation only cases do not require filtering.

        // Note, we set InterpolationModeBilinear because we
        // will detect the identity in the bilinear span creation.

        theFilterMode = InterpolationModeBilinear;
    }

    switch(theFilterMode)
    {

        // Nearest neighbor filtering. Used mainly for printing scenarios.
        // Aliases badly - only really looks good on high-dpi output devices,
        // however it's the fastest reconstruction filter.

        case InterpolationModeNearestNeighbor:
            output = new DpOutputNearestNeighborSpan(
                bitmap,
                scan,
                context,
                *imageAttributes,
                numPoints,
                dstPoints,
                srcRect
            );
        break;

        // High quality bicubic filter convolution.

        case InterpolationModeHighQuality:
        case InterpolationModeHighQualityBicubic:

        // !!! [asecchia] the high quality bicubic filter code doesn't
        // know how to do rotation yet.

        if(xForm->IsTranslateScale())
        {

            output = new DpOutputSpanStretch<HighQualityBicubic>(
                bitmap,
                scan,
                context,
                *imageAttributes,
                dstRect,
                srcRect
            );

            if(output && !output->IsValid())
            {
                // Failed to create the output span, try fall through to the 
                // regular bilinear output code.
                
                delete output;
                output = NULL;
                fPunted = true;
                goto FallbackCreation;
            }
            
            break;
        }

        // else fall through to the regular bicubic code.

        // Bicubic filter kernel.

        case InterpolationModeBicubic:
            output = new DpOutputBicubicImageSpan(
                bitmap,
                scan,
                context,
                *imageAttributes,
                numPoints,
                dstPoints,
                srcRect
            );
        break;

        // High quality bilinear (tent) convolution filter

        case InterpolationModeHighQualityBilinear:

        // !!! [asecchia] the high quality bilinear filter code doesn't
        // know how to do rotation yet.

        if(xForm->IsTranslateScale())
        {
            output = new DpOutputSpanStretch<HighQualityBilinear>(
                bitmap,
                scan,
                context,
                *imageAttributes,
                dstRect,
                srcRect
            );

            if(output && !output->IsValid())
            {
                // Failed to create the output span, try fall through to the 
                // regular bilinear output code.
                
                delete output;
                output = NULL;
                fPunted = true;
                goto FallbackCreation;
            }
            
            break;
        }

        // else fall through to the regular bilinear code.

        // Bilinear filter kernel - default case.

        case InterpolationModeDefault:
        case InterpolationModeLowQuality:
        case InterpolationModeBilinear:
        default:

            FallbackCreation:
            
            // Create a bilinear span or an identity span.

            output = CreateBilinearOutputSpan(
                bitmap,
                scan,
                xForm,
                context,
                imageAttributes,
                fPunted          // somebody failed and this is the fallback.
            );
    }

    // Check to see that the constructor for the output span class succeeded.

    if(output && !output->IsValid())
    {
       delete output;
       output = NULL;
    }

    // This will be NULL on an error path.

    return output;
}


/**************************************************************************\
*
* Function Description:
*
*   Draws an image.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] srcSurface - the source surface
*   [IN] dstSurface - the image to fill
*   [IN] drawBounds - the surface bounds
*   [IN] mapMode    - the mapping mode of the image
*   [IN] numPoints  - the number of points in dstPoints array (<= 4)
*   [IN] dstPoints  - the array of points for affine or quad transform.
*   [IN] srcRect    - the bounds of the src image.  If this is NULL,
*                     the whole image is used.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* History:
*
*   01/09/1999 ikkof      Created it.
*   10/19/1999 asecchia   rewrite to support rotation.
*
\**************************************************************************/

GpStatus
DpDriver::DrawImage(
    DpContext *          context,
    DpBitmap *           srcSurface,
    DpBitmap *           dstSurface,
    const GpRect *       drawBounds,
    const DpImageAttributes * imgAttributes,
    INT                  numPoints,
    const GpPointF *     dstPoints,
    const GpRectF *      srcRect,
    DriverDrawImageFlags flags
    )
{
    // Get the infrastructure to do active edge table stuff.

    using namespace DpDriverActiveEdge;

    // !!! [asecchia] Why do we have this if we don't use it?

    GpStatus status = Ok;

    // The caller is responsible for padding out the dstPoints structure so
    // that it has at least 3 valid points.

    ASSERT((numPoints==3)||(numPoints==4));

    // We need to do some reordering of points for warping (numPoints==4)
    // to work. For now we require numPoints == 3.

    ASSERT(numPoints==3);

    // Make a local copy so we don't end up modifying our callers' data.

    GpPointF fDst[4];
    GpMemcpy(fDst, dstPoints, sizeof(GpPointF)*numPoints);

    // Need to infer the transform for banding code.

    // !!! PERF: [asecchia] This transform actually gets computed by the Engine
    // before calling the Driver. We should have a way of passing it down
    // so that we don't have to recompute it.

    GpMatrix xForm;
    xForm.InferAffineMatrix(fDst, *srcRect);
    xForm.Append(context->WorldToDevice);
    
    // This is the source rectangle band.

    GpPointF fDst2[4];

    // If we are in HalfPixelMode Offset, we want to be able to read half
    // a pixel to the left of the image, to be able to center the drawing

    fDst2[0].X = srcRect->X;
    fDst2[0].Y = srcRect->Y;
    fDst2[1].X = srcRect->X+srcRect->Width;
    fDst2[1].Y = srcRect->Y;
    fDst2[2].X = srcRect->X;
    fDst2[2].Y = srcRect->Y+srcRect->Height;

    // Transform the points to the destination.

    xForm.Transform(fDst2, 3);

    if(numPoints==3)
    {
        // Force the four point destination format

        fDst[0].X = fDst2[0].X;
        fDst[0].Y = fDst2[0].Y;
        fDst[1].X = fDst2[2].X;
        fDst[1].Y = fDst2[2].Y;
        fDst[2].X = fDst2[1].X+fDst2[2].X-fDst2[0].X;
        fDst[2].Y = fDst2[1].Y+fDst2[2].Y-fDst2[0].Y;
        fDst[3].X = fDst2[1].X;
        fDst[3].Y = fDst2[1].Y;

    } else if (numPoints==4) {

        // !!! [asecchia] This code branch doesn't work yet.
        // The transforms required for correct banding need to be worked out
        // for the warp transform case.
        // This is a V2 feature.

        ASSERT(FALSE);
    }

    // Convert the transformed rectangle to fix point notation.

    PointFIX4 fix4Dst[4];
    fix4Dst[0].X = GpRealToFix4(fDst[0].X);
    fix4Dst[0].Y = GpRealToFix4(fDst[0].Y);
    fix4Dst[1].X = GpRealToFix4(fDst[1].X);
    fix4Dst[1].Y = GpRealToFix4(fDst[1].Y);
    fix4Dst[2].X = GpRealToFix4(fDst[2].X);
    fix4Dst[2].Y = GpRealToFix4(fDst[2].Y);
    fix4Dst[3].X = GpRealToFix4(fDst[3].X);
    fix4Dst[3].Y = GpRealToFix4(fDst[3].Y);

    // !!! [agodfrey] Perf: May want to add the noTransparentPixels parameter.
    // I guess we'd have to check that the coordinates are integer (after
    // translation and scaling), that there's no rotation, and that
    // the image contains no transparent pixels.

    DpScanBuffer scan(
        dstSurface->Scan,
        this,
        context,
        dstSurface
    );

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    // Only valid if xForm->IsTranslateScale()

    GpRectF dstRect(
        fDst[0].X,
        fDst[0].Y,
        fDst[2].X-fDst[0].X,
        fDst[2].Y-fDst[0].Y
    );

    DpOutputSpan* output = CreateOutputSpan(
        srcSurface,
        &scan,
        &xForm,
        const_cast<DpImageAttributes*>(imgAttributes),
        context->FilterType,
        context,
        srcRect,
        &dstRect,
        dstPoints,
        numPoints
    );

    // if output is NULL, we failed to allocate the memory for the
    // output span class.

    if(output == NULL)
    {
        return(OutOfMemory);
    }

    // Set up the clipping.

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion *clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
          drawBounds->X,
          drawBounds->Y,
          drawBounds->GetRight(),
          drawBounds->GetBottom()
        ) != DpRegion::TotallyVisible
       )
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }

    GpRect clippedRect;

    if(clipRegion)
    {
        visibility = clipRegion->GetRectVisibility(
            drawBounds->X,
            drawBounds->Y,
            drawBounds->GetRight(),
            drawBounds->GetBottom(),
            &clippedRect
        );
    }

    // Decide on our clipping strategy.

    DpOutputSpan *outspan;
    switch (visibility)
    {
        case DpRegion::TotallyVisible:    // no clipping is needed
            outspan = output;
        break;

        case DpRegion::ClippedVisible:    //
        case DpRegion::PartiallyVisible:  // some clipping is needed
            outspan = clipRegion;
        break;

        case DpRegion::Invisible:         // nothing on screen - quit
            goto DrawImage_Done;
    }

    if(xForm.IsTranslateScale() ||        // stretch
       xForm.IsIntegerTranslate())        // copybits
    {
        // Do the stretch/translate case

        GpPoint dstTL, dstBR;

        // Round to fixed point to eliminate the very close to integer
        // numbers that can result from transformation.
        // E.g. 300.0000000001 should become 300 after the ceiling operation
        // and not 301 (not the classical definition of ceiling).

        // Top Left corner.

        dstTL.X = GpFix4Ceiling(fix4Dst[0].X);
        dstTL.Y = GpFix4Ceiling(fix4Dst[0].Y);

        // Bottom Right corner

        dstBR.X = GpFix4Ceiling(fix4Dst[2].X);
        dstBR.Y = GpFix4Ceiling(fix4Dst[2].Y);

        // Swap coordinates if necessary.  StretchBitsMainLoop
        // assumes that TL corner is less than BR corner.

        if (dstTL.X > dstBR.X)
        {
            INT xTmp = dstTL.X;
            dstTL.X = dstBR.X;
            dstBR.X = xTmp;
        }
        if (dstTL.Y > dstBR.Y)
        {
            INT yTmp = dstTL.Y;
            dstTL.Y = dstBR.Y;
            dstBR.Y = yTmp;
        }

        // Due to the fixed point calculations used for image stretching, 
        // we are limited to how large an image can be stretched. 
        // If it is out of bounds, return an error.
        if (srcRect->Width > 32767.0f || srcRect->Height > 32767.0f)
        {
            WARNING(("Image width or height > 32767"));
            status = InvalidParameter;
            goto DrawImage_Done;
        }
    
        // This handles both the stretch and the copy case

        // Don't draw anything if there are no scanlines to draw or if
        // there are no pixels in the scanlines.

        if( (dstBR.X != dstTL.X) &&
            (dstBR.Y != dstTL.Y) )
        {
            StretchBitsMainLoop(outspan, &dstTL, &dstBR);
        }
    }
    else
    {
        // Default case - handles generic drawing including
        // rotation, shear, etc.

        INT yMinIdx = 0;    // index of the smallest y coordinate.
        INT y;              // current scanline.

        // Number of points - used for wrap computation.

        const INT points = 4;

        // search for the minimum y coordinate index.

        for(y=1;y<points;y++)
        {
            if(fix4Dst[y].Y < fix4Dst[yMinIdx].Y)
            {
                yMinIdx = y;
            }
        }
        y = GpFix4Ceiling(fix4Dst[yMinIdx].Y);

        // DDA for left and right edges.
        // ASSUMPTION: Convex polygon => two edges only.

        // Work out which edge is left and which is right.

        INT index1, index2;
        REAL det;

        index1 = yMinIdx-1;
        if(index1<0)
        {
            index1=points-1;
        }

        index2 = yMinIdx+1;
        if(index2>=points)
        {
            index2=0;
        }

        // Compute the determinant.
        // The sign of the determinant formed by the first two edges
        // will tell us if the polygon is specified clockwise
        // or anticlockwise.

        if( (fix4Dst[index1].Y==fix4Dst[yMinIdx].Y) &&
            (fix4Dst[index2].Y==fix4Dst[yMinIdx].Y) )
        {
            // Both initial edges are horizontal - compare x coordinates.
            // You get this formula by "cancelling out" the zero y terms
            // in the determinant formula below.
            // This part of the formula only works because we know that
            // yMinIdx is the index of the minimum y coordinate in the
            // polygon.

            det = (REAL)(fix4Dst[index1].X-fix4Dst[index2].X);
        }
        else
        {
            // Full determinant computation

            det = (REAL)
                  (fix4Dst[index2].Y-fix4Dst[yMinIdx].Y)*
                  (fix4Dst[index1].X-fix4Dst[yMinIdx].X)-
                  (REAL)
                  (fix4Dst[index1].Y-fix4Dst[yMinIdx].Y)*
                  (fix4Dst[index2].X-fix4Dst[yMinIdx].X);
        }

        // Even though we've discarded all the empty rectangle cases, it's 
        // still possible for really small non-zero matrix coefficients to
        // be multiplied together giving zero - due to rounding error at 
        // the precision limit of the real number representation.
        // If the det is zero (or really close) the quad has no area and
        // we succeed the call immediately.
        
        if(REALABS(det) < REAL_EPSILON)
        {
            goto DrawImage_Done;
        }

        {
            // Initialize the iterators with the direction dependent on the
            // sign of the determinant.
            // These are scoped because of the exit branches above (goto)
    
            DdaIterator left(fix4Dst, points, (det>0.0f)?1:-1, yMinIdx);
            DdaIterator right(fix4Dst, points, (det>0.0f)?-1:1, yMinIdx);
    
            // If both iterators are valid, start the loop.
    
            INT xLeft, xRight;
    
            if(left.IsValid() && right.IsValid())
            {
                do {
                    // Output the data. We know we only have one span because
                    // we're drawing a convex quad.
    
                    xLeft = left.GetX();
                    xRight = right.GetX();
    
                    // If this ever happens, we've broken a fundumental
                    // assumption of the OutputSpan code. Our x coordinates
                    // must be ordered.
    
                    ASSERT(xLeft <= xRight);
    
                    // Trivially reject any scanlines that don't have any
                    // pixels.
    
                    if(xRight>xLeft)
                    {
                        outspan->OutputSpan(y, xLeft, xRight);
                    }
    
                    // Update the y value to the new scanline
    
                    y++;
    
                    // Incrementaly update DDAs for this new scanline.
                    // End the loop if we're done with the last edge.
    
                } while(left.Next(y-1) && right.Next(y-1));
            }       // end if valid iterators
        }           // end scope
    }               // end else (rotation block)

    // We're done - clean up and return status.

    DrawImage_Done:

    output->End();

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }


    delete output;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\formatconverter.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Format converter
*
* Abstract:
*
*   A class which converts scanlines from one pixel format to another.
*
* Notes:
*
*   The sRGB   format is equivalent to PIXFMT_32BPP_ARGB.
*   The sRGB64 format is equivalent to PIXFMT_64BPP_ARGB.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   11/23/1999 agodfrey
*       Integrated with scan operations, moved it from 
*       imaging\api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

// !!![agodfrey] Hack:
const ColorPalette*
GetDefaultColorPalette(PixelFormatID pixfmt);

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}
// !!![agodfrey] Endhack

using namespace ScanOperation;

/**************************************************************************\
*
* Special-case conversion operations
*
* For performance reasons, we may want to supply special-case operations
* which convert directly from one format to another. Here is where they
* would be plugged in.
*
\**************************************************************************/

struct 
{
    PixelFormatID Srcfmt;
    PixelFormatID Dstfmt;
    ScanOpFunc Op;
}
const SpecialConvertOps[] =
{
    { PIXFMT_24BPP_RGB, PIXFMT_32BPP_PARGB, Convert_24_sRGB },
    
    // Sentinel

    { PIXFMT_UNDEFINED, PIXFMT_UNDEFINED, NULL }
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format.
*
* This is specific to EpFormatConverter - the 16bpp cases don't dither,
* and there's no 8BPP_INDEXED entry (DCurtis removed it, change #806.)
*
\**************************************************************************/

static ScanOpFunc FCConvertFromCanonicalOps[PIXFMT_MAX] =
{
    NULL,                   // PIXFMT_UNDEFINED
    NULL,                   // PIXFMT_1BPP_INDEXED
    NULL,                   // PIXFMT_4BPP_INDEXED
    NULL,                   // PIXFMT_8BPP_INDEXED
    NULL, // !!! TODO       // PIXFMT_16BPP_GRAYSCALE
    Quantize_sRGB_555,      // PIXFMT_16BPP_RGB555
    Quantize_sRGB_565,      // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,     // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,       // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,    // PIXFMT_32BPP_RGB
    Copy_32,                // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,     // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,     // PIXFMT_48BPP_RGB
    Copy_64,                // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,   // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR     // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Function Description:
*
*   Add a scan operation to the pipeline
*
* Arguments:
*
*   [IN/OUT] pipelinePtr - The current position in the Pipeline array,
*                          as it is being built
*   newOperation         - The scan operation to add
*   pixelFormat          - The destination pixel format
*
* Notes:
*
*   This should only be used by Initialize().
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
EpFormatConverter::AddOperation(
    PipelineItem **pipelinePtr,
    const ScanOpFunc newOperation,
    PixelFormatID pixelFormat
    )
{
    if (!newOperation)
    {
        return IMGERR_NOCONVERSION;
    }
    
    (*pipelinePtr)->Op = newOperation;
    (*pipelinePtr)->PixelFormat = pixelFormat;
    (*pipelinePtr)->Dst = NULL;
    
    // If this isn't the first operation in the pipeline,
    // we know that we need to allocate a temporary buffer for the
    // previous operation.
    
    if (*pipelinePtr != Pipeline)
    {
        PipelineItem *prevItem = (*pipelinePtr) - 1;
        
        VOID * buffer;
        buffer = GpMalloc(
            Width * GetPixelFormatSize(prevItem->PixelFormat) >> 3
            );
        if (buffer == NULL)
        {
            WARNING(("Out of memory."));
            return E_OUTOFMEMORY;
        }
        
        prevItem->Dst = buffer;

        // Remember the buffer pointer 
        
        VOID **tempBufPtr = TempBuf;
        
        if (*tempBufPtr) tempBufPtr++;
        ASSERT(!*tempBufPtr);
        
        *tempBufPtr = buffer;
    }
    (*pipelinePtr)++;
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize a scanliner pixel format converter object
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
EpFormatConverter::Initialize(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    )
{
    FreeBuffers();
    
    // !!![agodfrey]
    // We need a better error handling scheme. We should import the
    // CHECK_HR macro from somewhere - I like the one in the test\Simpsons
    // directory.
    // At the moment, we could leak memory if there is a memory failure.
    
    HRESULT hr=S_OK;
    
    Width = srcbmp->Width;
    PixelFormatID srcfmt = srcbmp->PixelFormat;
    PixelFormatID dstfmt = dstbmp->PixelFormat;
    
    INT srcfmtIndex = GetPixelFormatIndex(srcfmt);
    INT dstfmtIndex = GetPixelFormatIndex(dstfmt);

/*    ASSERT(IsValidPixelFormat(srcfmt) &&
           IsValidPixelFormat(dstfmt));
!!![agodfrey] Pixel formats need a revamp. Currently, I'd have to include
    most of imaging/api/*.hpp to get IsValidPixelFormat. Pixel format stuff
    needs to be in a common place. Also, information about the pixel format
    shouldn't be encoded in the pixel format DWORD itself.
*/
    
    // If the source and desination formats are the same, we just need
    // a copy operation.
    //
    // !!![agodfrey] This is horrible. We don't even compare the palettes -
    //               we just compare the pointers.

    if (srcfmt == dstfmt 
        && (!IsIndexedPixelFormat(srcfmt) 
            || (srcpal == dstpal)
           )
       )
    {
        Pipeline[0].Op = CopyOps[srcfmtIndex];
        Pipeline[0].PixelFormat = dstfmt;
        Pipeline[0].Dst = NULL;
        return S_OK;
    }

    // If source pixel format is an indexed color format,
    // make sure we have a source color palette.

    if (IsIndexedPixelFormat(srcfmt))
    {
        if (srcpal)
        {
            ASSERT(GetPixelFormatSize(srcfmt) <= 16);
            
            // If there aren't enough colors in the palette (256 or 16 or 2), 
            // clone the palette and fill the rest with opaque black.
        
            UINT maxPaletteSize = (1 << GetPixelFormatSize(srcfmt));
            if (srcpal->Count < maxPaletteSize)
            {
                ClonedSourcePalette = CloneColorPaletteResize(
                    srcpal,
                    maxPaletteSize,
                    0xff000000);
                srcpal = ClonedSourcePalette;
            }
        }
        OperationParameters.Srcpal = srcpal ? srcpal : GetDefaultColorPalette(srcfmt);
    }    

    // If destination pixel format is an indexed color format,
    // make sure we have a destination color palette.

    if (IsIndexedPixelFormat(dstfmt))
    {
        // !!! [agodfrey] We don't have code to convert to an arbitrary
        //     palette. So we can't convert to a palettized format.
        //     In the original code I transmogrified, there was a '!!! TODO'
        //     next to the 8bpp case.
        
        return IMGERR_NOCONVERSION;
        
        /*
        If we did support it, here's what we'd probably do:
        
        OperationParameters.X = 0;
        OperationParameters.Y = 0;
        
        OperationParameters.Dstpal = dstpal ? dstpal :
                       (srcpal ? srcpal : GetDefaultColorPalette(dstfmt));
        */               
    }

    // Search for a special-case operation for this combination of formats

    UINT index = 0;

    while (SpecialConvertOps[index].Op)
    {
        if (srcfmt == SpecialConvertOps[index].Srcfmt &&
            dstfmt == SpecialConvertOps[index].Dstfmt)
        {
            Pipeline[0].Op = SpecialConvertOps[index].Op;
            Pipeline[0].PixelFormat = dstfmt;
            Pipeline[0].Dst = NULL;
            return S_OK;
        }

        index++;
    }

    // We didn't find a special case; instead we use the general case.
    //
    // We assume that there are only 2 canonical formats -
    // PIXFMT_32BPP_ARGB (i.e. sRGB), and
    // PIXFMT_64BPP_ARGB (i.e. sRGB64). 
    //
    // 1) Convert from the source to the nearest canonical format, if necessary.
    // 2) Convert from that canonical format to the other one, if necessary.
    // 3) Convert to the destination format, if necessary.

    PipelineItem *pipelinePtr = Pipeline;
    
    // Convert from the source to the nearest canonical format, if necessary.
    
    if (!IsCanonicalPixelFormat(srcfmt))
    {
        hr = AddOperation(
            &pipelinePtr,
            ConvertIntoCanonicalOps[srcfmtIndex],
            IsExtendedPixelFormat(srcfmt) ? 
                PIXFMT_64BPP_ARGB : PIXFMT_32BPP_ARGB
            );
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Convert to the other canonical format, if necessary.
    
    if (IsExtendedPixelFormat(srcfmt) != IsExtendedPixelFormat(dstfmt))
    {
        if (IsExtendedPixelFormat(srcfmt))
        {
            hr = AddOperation(
                &pipelinePtr,
                GammaConvert_sRGB64_sRGB,
                PIXFMT_32BPP_ARGB
                );
        }
        else
        {
            hr = AddOperation(
                &pipelinePtr,
                GammaConvert_sRGB_sRGB64,
                PIXFMT_64BPP_ARGB
                );
        }
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Convert to the destination format, if necessary.
    
    if (!IsCanonicalPixelFormat(dstfmt))
    {
        hr = AddOperation(
            &pipelinePtr,
            FCConvertFromCanonicalOps[dstfmtIndex],
            dstfmt
            );
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Assert that the number of operations in our pipeline is between
    // 1 and 3.
    
    ASSERT(pipelinePtr != Pipeline);
    ASSERT(((pipelinePtr - Pipeline) / sizeof(Pipeline[0])) <= 3);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Check if we can do a pixel format converter from srcFmt to dstFmt
*
* Arguments:
*
*   srcFmt - Specifies the source pixel format
*   dstFmt - Specifies the destination pixel format
*
* Return Value:
*
*   Return TRUE if we can do the convertion, otherwise, return FALSE
*
* Note:
*   This function should be put in the hpp file as inline function. But since
*   the hpp file doesn't include scanoperationinternal.hpp (which is needed
*   because we need "FCConvertFromCanonicalOps" and "ConvertIntoCanonicalOps".)
*   So if the caller wants to use this function, he has to include this file 
*   which is not nice.
*
* Revision History:
*
*   04/28/2000 minliu
*       Created it.
*
\**************************************************************************/

BOOL
EpFormatConverter::CanDoConvert(
    const PixelFormatID srcFmt,
    const PixelFormatID dstFmt
    )
{
    if ( srcFmt == dstFmt )
    {
        // If the source and dest are the same format, of course we can convert

        return TRUE;
    }

    INT srcfmtIndex = GetPixelFormatIndex(srcFmt);
    INT dstfmtIndex = GetPixelFormatIndex(dstFmt);

    // If we can convert source to Canonical and then convert to dest, we can
    // do the convertion

    if ( (ConvertIntoCanonicalOps[srcfmtIndex] != NULL)
       &&(FCConvertFromCanonicalOps[dstfmtIndex] != NULL) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}// CanDoConvert()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\halftone.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Halftoning (for GIF codec)
*
* Abstract:
*
*   Halftone 32 bpp to 8 bpp using 216-color halftoning
*
* Revision History:
*
*   02/21/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if defined(_USE_X86_ASSEMBLY)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/**************************************************************************\
*
* Operation Description:
*
*   Halftone from 32bpp ARGB to 8bpp, using the 216-color halftone palette.
*
* Arguments:
*
*   d           - The destination scan
*   s           - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   orgX        - X origin 
*   orgY        - Y origin 
*
* Return Value:
*
*   None
*
* Notes:
*   
*   This version doesn't use a palette map and doesn't care about the
*   20 Windows system colors.
*
* History:
*
*   2/21/2000 DCurtis
*
\**************************************************************************/

VOID
Halftone_sRGB_8_216(
    BYTE* d,
    const BYTE* s,
    UINT count,
    INT orgX,
    INT orgY
    )
{
    orgX %= 91;
    orgY %= 91;
    
    INT     htStartX   = orgX;
    INT     htStartRow = orgY * 91;
    INT     htIndex    = htStartRow + orgX;

    ULONG   r, g, b;
    ULONG   rQuo, gQuo, bQuo;
    ULONG   rRem, gRem, bRem;
    ULONG   divisor = 0x33;
    
    for (;;)
    {
        r = s[2];
        g = s[1];
        b = s[0];

        s += 4;

        QUOTIENT_REMAINDER(r, divisor, rQuo, rRem);
        QUOTIENT_REMAINDER(g, divisor, gQuo, gRem);
        QUOTIENT_REMAINDER(b, divisor, bQuo, bRem);

        // MUST do >, not >= so that a remainder of 0 works correctly
        r = rQuo + (rRem > HT_SuperCell_Red216  [htIndex]);
        g = gQuo + (gRem > HT_SuperCell_Green216[htIndex]);
        b = bQuo + (bRem > HT_SuperCell_Blue216 [htIndex]);

        *d++ = (BYTE)((r*36) + (g*6) + b + 40);

        if (--count == 0)
        {
            break;
        }

        htIndex++;
        if (++orgX >= 91)
        {
            orgX = 0;
            htIndex = htStartRow;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Halftone an image from 32bpp to 8bpp. See the .hpp file for caveats.
*
* Arguments:
*
*   [IN]      src        - pointer to scan0 of source image
*   [IN]      srcStride  - stride of src image (can be negative)
*   [IN]      dst        - pointer to scan0 of destination 8-bpp image
*   [IN]      dstStride  - stride of dst image (can be negative)
*   [IN]      width      - image width
*   [IN]      height     - image height
*   [IN]      orgX       - where the upper-left corner of image starts
*   [IN]      orgY       - for computing the halftone cell origin
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/29/1999 DCurtis
*     Created it.
*   01/20/2000 AGodfrey
*     Moved it from Imaging\Api\Colorpal.cpp/hpp.
*
\**************************************************************************/

VOID
Halftone32bppTo8bpp(
    const BYTE* src,
    INT srcStride,
    BYTE* dst,
    INT dstStride,
    UINT width,
    UINT height,
    INT orgX,
    INT orgY
    )
{
    ASSERT (((srcStride >= 0) && (srcStride >= (INT)(width * 4))) ||
            ((srcStride < 0) && (-srcStride >= (INT)(width * 4))));
    ASSERT (((dstStride >= 0) && (dstStride >= (INT)width)) || 
            ((dstStride < 0) && (-dstStride >= (INT)width)));
    ASSERT((src != NULL) && (dst != NULL));            
    
    if (width == 0)
    {
        return;
    }
    
    for (; height > 0; height--)
    {
        Halftone_sRGB_8_216(dst, src, width, orgX, orgY);
        orgY++;
        src += srcStride;
        dst += dstStride;
    }
}

extern "C" {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\gradientfill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GradientFill.cpp
*
* Abstract:
*
*   gradient fill routines.
*
* Revision History:
*
*   01/21/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define CLAMP_COLOR_CHANNEL(a, b)  \
    if(a < 0)                   \
    {                           \
        a = 0;                  \
    }                           \
    if(a > b)                   \
    {                           \
        a = b;                  \
    }     

// 10bit inverse gamma 2.2 look up table.

static const BYTE TenBitInvGamma2_2 [] = {
    0, 11, 15, 18, 21, 23, 25, 26,
    28, 30, 31, 32, 34, 35, 36, 37,
    39, 40, 41, 42, 43, 44, 45, 45,
    46, 47, 48, 49, 50, 50, 51, 52,
    53, 54, 54, 55, 56, 56, 57, 58,
    58, 59, 60, 60, 61, 62, 62, 63,
    63, 64, 65, 65, 66, 66, 67, 68,
    68, 69, 69, 70, 70, 71, 71, 72,
    72, 73, 73, 74, 74, 75, 75, 76,
    76, 77, 77, 78, 78, 79, 79, 80,
    80, 81, 81, 81, 82, 82, 83, 83,
    84, 84, 84, 85, 85, 86, 86, 87,
    87, 87, 88, 88, 89, 89, 89, 90,
    90, 91, 91, 91, 92, 92, 93, 93,
    93, 94, 94, 94, 95, 95, 96, 96,
    96, 97, 97, 97, 98, 98, 98, 99,
    99, 99, 100, 100, 101, 101, 101, 102,
    102, 102, 103, 103, 103, 104, 104, 104,
    105, 105, 105, 106, 106, 106, 107, 107,
    107, 108, 108, 108, 108, 109, 109, 109,
    110, 110, 110, 111, 111, 111, 112, 112,
    112, 112, 113, 113, 113, 114, 114, 114,
    115, 115, 115, 115, 116, 116, 116, 117,
    117, 117, 117, 118, 118, 118, 119, 119,
    119, 119, 120, 120, 120, 121, 121, 121,
    121, 122, 122, 122, 123, 123, 123, 123,
    124, 124, 124, 124, 125, 125, 125, 125,
    126, 126, 126, 127, 127, 127, 127, 128,
    128, 128, 128, 129, 129, 129, 129, 130,
    130, 130, 130, 131, 131, 131, 131, 132,
    132, 132, 132, 133, 133, 133, 133, 134,
    134, 134, 134, 135, 135, 135, 135, 136,
    136, 136, 136, 137, 137, 137, 137, 138,
    138, 138, 138, 138, 139, 139, 139, 139,
    140, 140, 140, 140, 141, 141, 141, 141,
    142, 142, 142, 142, 142, 143, 143, 143,
    143, 144, 144, 144, 144, 144, 145, 145,
    145, 145, 146, 146, 146, 146, 146, 147,
    147, 147, 147, 148, 148, 148, 148, 148,
    149, 149, 149, 149, 149, 150, 150, 150,
    150, 151, 151, 151, 151, 151, 152, 152,
    152, 152, 152, 153, 153, 153, 153, 154,
    154, 154, 154, 154, 155, 155, 155, 155,
    155, 156, 156, 156, 156, 156, 157, 157,
    157, 157, 157, 158, 158, 158, 158, 158,
    159, 159, 159, 159, 159, 160, 160, 160,
    160, 160, 161, 161, 161, 161, 161, 162,
    162, 162, 162, 162, 163, 163, 163, 163,
    163, 164, 164, 164, 164, 164, 165, 165,
    165, 165, 165, 165, 166, 166, 166, 166,
    166, 167, 167, 167, 167, 167, 168, 168,
    168, 168, 168, 168, 169, 169, 169, 169,
    169, 170, 170, 170, 170, 170, 171, 171,
    171, 171, 171, 171, 172, 172, 172, 172,
    172, 173, 173, 173, 173, 173, 173, 174,
    174, 174, 174, 174, 174, 175, 175, 175,
    175, 175, 176, 176, 176, 176, 176, 176,
    177, 177, 177, 177, 177, 177, 178, 178,
    178, 178, 178, 179, 179, 179, 179, 179,
    179, 180, 180, 180, 180, 180, 180, 181,
    181, 181, 181, 181, 181, 182, 182, 182,
    182, 182, 182, 183, 183, 183, 183, 183,
    183, 184, 184, 184, 184, 184, 185, 185,
    185, 185, 185, 185, 186, 186, 186, 186,
    186, 186, 186, 187, 187, 187, 187, 187,
    187, 188, 188, 188, 188, 188, 188, 189,
    189, 189, 189, 189, 189, 190, 190, 190,
    190, 190, 190, 191, 191, 191, 191, 191,
    191, 192, 192, 192, 192, 192, 192, 192,
    193, 193, 193, 193, 193, 193, 194, 194,
    194, 194, 194, 194, 195, 195, 195, 195,
    195, 195, 195, 196, 196, 196, 196, 196,
    196, 197, 197, 197, 197, 197, 197, 197,
    198, 198, 198, 198, 198, 198, 199, 199,
    199, 199, 199, 199, 199, 200, 200, 200,
    200, 200, 200, 201, 201, 201, 201, 201,
    201, 201, 202, 202, 202, 202, 202, 202,
    202, 203, 203, 203, 203, 203, 203, 204,
    204, 204, 204, 204, 204, 204, 205, 205,
    205, 205, 205, 205, 205, 206, 206, 206,
    206, 206, 206, 206, 207, 207, 207, 207,
    207, 207, 207, 208, 208, 208, 208, 208,
    208, 209, 209, 209, 209, 209, 209, 209,
    210, 210, 210, 210, 210, 210, 210, 211,
    211, 211, 211, 211, 211, 211, 212, 212,
    212, 212, 212, 212, 212, 213, 213, 213,
    213, 213, 213, 213, 213, 214, 214, 214,
    214, 214, 214, 214, 215, 215, 215, 215,
    215, 215, 215, 216, 216, 216, 216, 216,
    216, 216, 217, 217, 217, 217, 217, 217,
    217, 218, 218, 218, 218, 218, 218, 218,
    218, 219, 219, 219, 219, 219, 219, 219,
    220, 220, 220, 220, 220, 220, 220, 221,
    221, 221, 221, 221, 221, 221, 221, 222,
    222, 222, 222, 222, 222, 222, 223, 223,
    223, 223, 223, 223, 223, 223, 224, 224,
    224, 224, 224, 224, 224, 225, 225, 225,
    225, 225, 225, 225, 225, 226, 226, 226,
    226, 226, 226, 226, 226, 227, 227, 227,
    227, 227, 227, 227, 228, 228, 228, 228,
    228, 228, 228, 228, 229, 229, 229, 229,
    229, 229, 229, 229, 230, 230, 230, 230,
    230, 230, 230, 230, 231, 231, 231, 231,
    231, 231, 231, 232, 232, 232, 232, 232,
    232, 232, 232, 233, 233, 233, 233, 233,
    233, 233, 233, 234, 234, 234, 234, 234,
    234, 234, 234, 235, 235, 235, 235, 235,
    235, 235, 235, 236, 236, 236, 236, 236,
    236, 236, 236, 237, 237, 237, 237, 237,
    237, 237, 237, 238, 238, 238, 238, 238,
    238, 238, 238, 238, 239, 239, 239, 239,
    239, 239, 239, 239, 240, 240, 240, 240,
    240, 240, 240, 240, 241, 241, 241, 241,
    241, 241, 241, 241, 242, 242, 242, 242,
    242, 242, 242, 242, 243, 243, 243, 243,
    243, 243, 243, 243, 243, 244, 244, 244,
    244, 244, 244, 244, 244, 245, 245, 245,
    245, 245, 245, 245, 245, 245, 246, 246,
    246, 246, 246, 246, 246, 246, 247, 247,
    247, 247, 247, 247, 247, 247, 248, 248,
    248, 248, 248, 248, 248, 248, 248, 249,
    249, 249, 249, 249, 249, 249, 249, 249,
    250, 250, 250, 250, 250, 250, 250, 250,
    251, 251, 251, 251, 251, 251, 251, 251,
    251, 252, 252, 252, 252, 252, 252, 252,
    252, 252, 253, 253, 253, 253, 253, 253,
    253, 253, 254, 254, 254, 254, 254, 254,
    254, 254, 254, 255, 255, 255, 255, 255
};

// 8bit to float gamma 2.2 LUT.

static const REAL Gamma2_2LUT[] = {
    0.000000000f, 0.001294648f, 0.005948641f, 0.014515050f,
    0.027332777f, 0.044656614f, 0.066693657f, 0.093619749f,
    0.125588466f, 0.162736625f, 0.205187917f, 0.253055448f,
    0.306443578f, 0.365449320f, 0.430163406f, 0.500671134f,
    0.577053056f, 0.659385527f, 0.747741173f, 0.842189273f,
    0.942796093f, 1.049625159f, 1.162737505f, 1.282191881f,
    1.408044937f, 1.540351382f, 1.679164133f, 1.824534436f,
    1.976511986f, 2.135145025f, 2.300480434f, 2.472563819f,
    2.651439585f, 2.837151004f, 3.029740281f, 3.229248608f,
    3.435716220f, 3.649182441f, 3.869685731f, 4.097263727f,
    4.331953283f, 4.573790502f, 4.822810773f, 5.079048802f,
    5.342538638f, 5.613313704f, 5.891406820f, 6.176850227f,
    6.469675611f, 6.769914121f, 7.077596394f, 7.392752570f,
    7.715412307f, 8.045604807f, 8.383358822f, 8.728702674f,
    9.081664270f, 9.442271111f, 9.810550312f, 10.18652861f,
    10.57023236f, 10.96168759f, 11.36091997f, 11.76795482f,
    12.18281716f, 12.60553168f, 13.03612276f, 13.47461451f,
    13.92103071f, 14.37539488f, 14.83773026f, 15.30805982f,
    15.78640628f, 16.27279209f, 16.76723947f, 17.26977037f,
    17.78040653f, 18.29916946f, 18.82608041f, 19.36116046f,
    19.90443044f, 20.45591098f, 21.01562250f, 21.58358523f,
    22.15981921f, 22.74434425f, 23.33718001f, 23.93834596f,
    24.54786138f, 25.16574537f, 25.79201687f, 26.42669465f,
    27.06979729f, 27.72134324f, 28.38135078f, 29.04983802f,
    29.72682293f, 30.41232332f, 31.10635686f, 31.80894107f,
    32.52009334f, 33.23983090f, 33.96817086f, 34.70513018f,
    35.45072570f, 36.20497412f, 36.96789203f, 37.73949586f,
    38.51980195f, 39.30882651f, 40.10658561f, 40.91309523f,
    41.72837123f, 42.55242933f, 43.38528517f, 44.22695426f,
    45.07745202f, 45.93679373f, 46.80499461f, 47.68206973f,
    48.56803410f, 49.46290260f, 50.36669002f, 51.27941105f,
    52.20108030f, 53.13171227f, 54.07132136f, 55.01992190f,
    55.97752811f, 56.94415413f, 57.91981400f, 58.90452170f,
    59.89829110f, 60.90113599f, 61.91307008f, 62.93410700f,
    63.96426029f, 65.00354342f, 66.05196978f, 67.10955268f,
    68.17630535f, 69.25224094f, 70.33737253f, 71.43171314f,
    72.53527570f, 73.64807306f, 74.77011803f, 75.90142331f,
    77.04200157f, 78.19186538f, 79.35102726f, 80.51949965f,
    81.69729494f, 82.88442544f, 84.08090341f, 85.28674102f,
    86.50195041f, 87.72654363f, 88.96053269f, 90.20392952f,
    91.45674601f, 92.71899397f, 93.99068516f, 95.27183128f,
    96.56244399f, 97.86253485f, 99.17211542f, 100.4911972f,
    101.8197915f, 103.1579098f, 104.5055633f, 105.8627634f,
    107.2295212f, 108.6058479f, 109.9917545f, 111.3872522f,
    112.7923519f, 114.2070647f, 115.6314012f, 117.0653726f,
    118.5089894f, 119.9622626f, 121.4252027f, 122.8978204f,
    124.3801265f, 125.8721313f, 127.3738455f, 128.8852796f,
    130.4064438f, 131.9373487f, 133.4780046f, 135.0284217f,
    136.5886104f, 138.1585808f, 139.7383431f, 141.3279074f,
    142.9272838f, 144.5364824f, 146.1555131f, 147.7843860f,
    149.4231109f, 151.0716977f, 152.7301563f, 154.3984965f,
    156.0767280f, 157.7648605f, 159.4629038f, 161.1708675f,
    162.8887612f, 164.6165945f, 166.3543769f, 168.1021179f,
    169.8598270f, 171.6275137f, 173.4051873f, 175.1928571f,
    176.9905325f, 178.7982229f, 180.6159374f, 182.4436852f,
    184.2814757f, 186.1293178f, 187.9872208f, 189.8551937f,
    191.7332455f, 193.6213854f, 195.5196223f, 197.4279651f,
    199.3464228f, 201.2750043f, 203.2137184f, 205.1625740f,
    207.1215799f, 209.0907449f, 211.0700776f, 213.0595868f,
    215.0592813f, 217.0691695f, 219.0892603f, 221.1195621f,
    223.1600835f, 225.2108331f, 227.2718194f, 229.3430508f,
    231.4245359f, 233.5162830f, 235.6183005f, 237.7305968f,
    239.8531803f, 241.9860592f, 244.1292419f, 246.2827366f,
    248.4465516f, 250.6206950f, 252.8051751f, 255.0000000f,
};




/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputSpan *
DpOutputSpan::Create(
    const DpBrush * dpBrush,
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds
)
{
    const GpBrush * brush = GpBrush::GetBrush( (DpBrush *)(dpBrush));

    if(brush)
    {
        return ((GpBrush*) brush)->CreateOutputSpan(scan, context, drawBounds);
    }
    else
        return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Gradient brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputGradientSpan::DpOutputGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    )
{
    Scan = scan;

    CompositingMode = context->CompositingMode;

    Brush = brush;
    BrushType = brush->GetBrushType();
    brush->GetRect(BrushRect);
    WrapMode = brush->GetWrapMode();

    // Incorporate the brush's transform into the graphics context's
    // current transform:

    GpMatrix xForm;
    brush->GetTransform(&xForm);

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);

    // !!![andrewgo] garbage is left in DeviceToWorld if not invertible

    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }

    InitDefaultColorArrays(brush);
}

/**************************************************************************\
*
* Function Description:
*
*   Converts the input value by using the blend factors and
*   blend positions.
*
\**************************************************************************/
    
REAL
slowAdjustValue(
    REAL x, INT count,
    REAL falloff,
    REAL* blendFactors,
    REAL* blendPositions
    )
{
    REAL value = x;
    if(count == 1 && falloff != 1 && falloff > 0)
    {
        if((x >= 0.0f) && (x <= 1.0f))
            value = (REAL) pow(x, falloff);
    }
    else if(count >= 2 && blendFactors && blendPositions)
    {
        // This has to be an 'equality' test, because the 
        // DpOutputLinearGradientSpan fast-path samples only 
        // discretely, and it starts at exactly 0.0 and ends
        // exactly at 1.0.  We don't actually have to incorporate
        // an epsilon in that case because it always gives us
        // exactly 0.0 and 1.0 for the start and end.

        if((x >= 0.0f) && (x <= 1.0f))
        {
            INT index = 1;

            // Look for the interval.

            while( ((x-blendPositions[index]) > REAL_EPSILON) && 
                   (index < count) )
            {
                index++;
            }

            // Interpolate.

            if(index < count)
            {
                REAL d = blendPositions[index] - blendPositions[index - 1];
                if(d > 0)
                {
                    REAL t = (x - blendPositions[index - 1])/d;
                    value = blendFactors[index - 1]
                        + t*(blendFactors[index] - blendFactors[index - 1]);
                }
                else
                    value = (blendFactors[index - 1] + blendFactors[index])/2;
            }
        }
    }

    return value;
}

// We make this routine inline because it's nice and small and very 
// frequently we don't even have to call 'slowAdjustValue'.

inline
REAL
adjustValue(
    REAL x, INT count,
    REAL falloff,
    REAL* blendFactors,
    REAL* blendPositions
    )
{
    REAL value = x;

    if(count != 1 || falloff != 1)
    {
        value = slowAdjustValue(x, count, falloff, blendFactors, blendPositions);
    }
    
    return value;
}


/**************************************************************************\
*
* Function Description:
*
*   GammaLinearizeAndPremultiply
*
*   This function takes non-premultiplied ARGB input and emits a
*   Gamma converted (2.2) output 128bit floating point premultiplied
*   color value
*
* Arguments:
*
*   [IN]  ARGB         - input premultiplied floating point color value
*   [IN]  gammaCorrect - turn on gamma correction logic
*   [OUT] color        - output color value. 128bit float color. premultiplied
*
* 10/31/2000 asecchia
*   Created
*
\**************************************************************************/
VOID GammaLinearizeAndPremultiply( 
    ARGB argb,               // Non-premultiplied input.
    BOOL gammaCorrect,
    GpFColor128 *color       // pre-multiplied output.
)
{
    // Alpha (opacity) shouldn't be gamma corrected.
    
    color->a = (REAL)GpColor::GetAlphaARGB(argb);
    
    // Alpha zero...
    
    if(REALABS((color->a)) < REAL_EPSILON) 
    {
        color->r = 0.0f;
        color->g = 0.0f;
        color->b = 0.0f;
        
        // we're done.
        return;    
    }
    
    if(gammaCorrect)
    {
        
        // use the gamma 2.2 lookup table to convert r, g, b.
        
        color->r = Gamma2_2LUT[GpColor::GetRedARGB(argb)];
        color->g = Gamma2_2LUT[GpColor::GetGreenARGB(argb)];
        color->b = Gamma2_2LUT[GpColor::GetBlueARGB(argb)];
        
    }
    else
    {
        color->r = (REAL)GpColor::GetRedARGB(argb);
        color->g = (REAL)GpColor::GetGreenARGB(argb);
        color->b = (REAL)GpColor::GetBlueARGB(argb);
    }
    
    // Alpha != 255
    
    if(REALABS((color->a)-255.0f) >= REAL_EPSILON) 
    {
        // Do the premultiplication.
        
        color->r *= (color->a)/255.0f;
        color->g *= (color->a)/255.0f;
        color->b *= (color->a)/255.0f;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   GammaUnlinearizePremultiplied128.
*
*   This function takes a 128bit floating point premultiplied color and 
*   performs the inverse gamma correction step.
*
*   First the color value is unpremultiplied - then the r,g,b channels are
*   scaled into the range 0-1023 and rounded so that they match our 10bit
*   gamma lookup table. We pass it through the 1/2.2 gamma LUT and 
*   premultiply the output.
*
* Arguments:
*
*   [IN] color   - input premultiplied floating point color value
*
* Return:
*
*   ARGB         - output premultiplied 32bpp integer color (gamma corrected).
*
* 10/31/2000 asecchia
*   Created
*
\**************************************************************************/

ARGB GammaUnlinearizePremultiplied128(
    const GpFColor128 &color
)
{
    // Do the gamma conversion thing. Ten bits is enough.
    
    INT iA, iR, iG, iB;
    
    // First unpremultiply. Don't do gamma conversion on the alpha channel.
    
    iA = GpRound(color.a);
    
    // make sure we're passed a valid input alpha channel.
    
    ASSERT(iA >= 0);
    ASSERT(iA <= 255);
    
    // full transparency.
    
    if(iA == 0)
    {
        iR = iG = iB = 0;
    }
    else
    {
        // full opacity.
    
        if(iA == 255)
        {
            // Simply scale the color channels to 0-1023
            
            iR = GpRound(color.r*(1023.0f/255.0f));
            iG = GpRound(color.g*(1023.0f/255.0f));
            iB = GpRound(color.b*(1023.0f/255.0f));
        }
        else
        {
            // Alpha Divide. Note that alpha already has a factor of 255 and
            // so do all the color channels. Therefore when we divide the 
            // color channel by color.a, we implicitly cancel out the 255 
            // factor and all that's left is to scale up to 10bit --- hence
            // the scale factor of 1023/a
            
            REAL scale = 1023.0f/color.a;
            iR = GpRound(color.r*scale);
            iG = GpRound(color.g*scale);
            iB = GpRound(color.b*scale);
        }
    }
    
    // must be well formed color value otherwise we will AV accessing our
    // gamma conversion table.
    
    ASSERT(iB >= 0);
    ASSERT(iB <= 1023);
    ASSERT(iG >= 0);
    ASSERT(iG <= 1023);
    ASSERT(iR >= 0);
    ASSERT(iR <= 1023);
    
    // Apply Gamma using our 10bit inverse 2.2 power function table.
    
    GpColorConverter colorConv;
    colorConv.Channel.b = TenBitInvGamma2_2[iB];
    colorConv.Channel.g = TenBitInvGamma2_2[iG];
    colorConv.Channel.r = TenBitInvGamma2_2[iR];
    colorConv.Channel.a = static_cast<BYTE>(iA); // alpha is already linear.
    
    // Premultiply.
    
    return GpColor::ConvertToPremultiplied(colorConv.argb);
}


VOID
interpolatePresetColors(
    GpFColor128 *colorOut,
    REAL x,
    INT count,
    ARGB* presetColors,
    REAL* blendPositions,
    BOOL gammaCorrect
    )
{
    REAL value = x;

    if(count > 1 && presetColors && blendPositions)
    {
        if(x >= 0 && x <= 1)
        {
            INT index = 1;

            // Look for the interval.

            while(blendPositions[index] < x && index < count)
            {
                index++;
            }

            // Interpolate.

            if(index < count)
            {
                GpFColor128 color[2];

                GammaLinearizeAndPremultiply(
                    presetColors[index-1], 
                    gammaCorrect, 
                    &color[0]
                );

                GammaLinearizeAndPremultiply(
                    presetColors[index],
                    gammaCorrect, 
                    &color[1]
                );

                REAL d = blendPositions[index] - blendPositions[index - 1];
                if(d > 0)
                {
                    REAL t = (x - blendPositions[index - 1])/d;
                    colorOut->a = t*(color[1].a - color[0].a) + color[0].a;
                    colorOut->r = t*(color[1].r - color[0].r) + color[0].r;
                    colorOut->g = t*(color[1].g - color[0].g) + color[0].g;
                    colorOut->b = t*(color[1].b - color[0].b) + color[0].b;
                }
                else
                {
                    colorOut->a = (color[0].a + color[1].a)/2.0f;
                    colorOut->r = (color[0].r + color[1].r)/2.0f;
                    colorOut->g = (color[0].g + color[1].g)/2.0f;
                    colorOut->b = (color[0].b + color[1].b)/2.0f;
                }
            }
            else    // index == count
            {
                //!!! This case should not be happening if
                // the blendPositions array is properly set.
                // That means:
                // blendPositions array is monotonically
                // increasing and
                // blendPositions[0] = 0
                // blendPositions[count - 1] = 1.

                GammaLinearizeAndPremultiply(
                    presetColors[count-1], 
                    gammaCorrect,
                    colorOut
                );
            }
        }
        else if(x <= 0)
        {
            GammaLinearizeAndPremultiply(
                presetColors[0], 
                gammaCorrect, 
                colorOut
            );
        }
        else    // x >= 1
        {
            GammaLinearizeAndPremultiply(
                presetColors[count-1], 
                gammaCorrect, 
                colorOut
            );
        }
    }
}

DpTriangleData::DpTriangleData(
    VOID
    )
{
    SetValid(FALSE);
    IsPolygonMode = FALSE;
    GammaCorrect = FALSE;
    Index[0] = 0;
    Index[1] = 1;
    Index[2] = 2;
    GpMemset(&X[0], 0, 3*sizeof(REAL));
    GpMemset(&Y[0], 0, 3*sizeof(REAL));
    GpMemset(Color, 0, 3*sizeof(GpFColor128));
    Xmin = Xmax = 0;
    GpMemset(&M[0], 0, 3*sizeof(REAL));
    GpMemset(&DeltaY[0], 0, 3*sizeof(REAL));

    Falloff0 = 1;
    Falloff1 = 1;
    Falloff2 = 1;
    BlendCount0 = 1;
    BlendCount1 = 1;
    BlendCount2 = 1;
    BlendFactors0 = NULL;
    BlendFactors1 = NULL;
    BlendFactors2 = NULL;
    BlendPositions0 = NULL;
    BlendPositions1 = NULL;
    BlendPositions2 = NULL;

    XSpan[0] = 0.0f;
    XSpan[1] = 0.0f;
}

VOID
DpTriangleData::SetTriangle(
    GpPointF& pt0,
    GpPointF& pt1,
    GpPointF& pt2,
    GpColor& color0,
    GpColor& color1,
    GpColor& color2,
    BOOL isPolygonMode,
    BOOL gammaCorrect
    )
{
    IsPolygonMode = isPolygonMode;
    GammaCorrect = gammaCorrect;

    // !!! [asecchia] Windows db #203480
    // We're filtering the input points here because the rest of the 
    // gradient code is sloppy about handling the comparison between 
    // floating point coordinates. Basically no attempt is made to 
    // handle rounding error and therefore we can get random off-by-one
    // scanline rendering errors based on coordinate differences 
    // on the order of FLT_EPSILON in size.
    // Effectively we're applying a noise filter here by rounding to 
    // 4 bits of fractional precision. This was chosen to match our
    // rasterizer rounding precision because we're in device space
    // already.
    
    X[0] = TOREAL(GpRealToFix4(pt0.X)) / 16.0f;
    Y[0] = TOREAL(GpRealToFix4(pt0.Y)) / 16.0f;
    X[1] = TOREAL(GpRealToFix4(pt1.X)) / 16.0f;
    Y[1] = TOREAL(GpRealToFix4(pt1.Y)) / 16.0f;
    X[2] = TOREAL(GpRealToFix4(pt2.X)) / 16.0f;
    Y[2] = TOREAL(GpRealToFix4(pt2.Y)) / 16.0f;

    GammaLinearizeAndPremultiply(
        color0.GetValue(), 
        GammaCorrect, 
        &Color[0]
    );

    GammaLinearizeAndPremultiply(
        color1.GetValue(), 
        GammaCorrect, 
        &Color[1]
    );

    GammaLinearizeAndPremultiply(
        color2.GetValue(), 
        GammaCorrect, 
        &Color[2]
    );

    Xmin = Xmax = X[0];
    Xmin = min(Xmin, X[1]);
    Xmax = max(Xmax, X[1]);
    Xmin = min(Xmin, X[2]);
    Xmax = max(Xmax, X[2]);

    INT i, j;

    // Sort the points according to the ascending y order. 
    for(i = 0; i < 2; i++)
    {
        for(j = i; j < 3; j++)
        {
            if((Y[j] < Y[i]) ||
                ( (Y[j] == Y[i]) && (X[j] < X[i]) ))
            {
                REAL temp;
                INT tempColor;
                INT tempIndex;

                tempIndex = Index[i];
                Index[i] = Index[j];
                Index[j] = tempIndex;

                temp = X[i];
                X[i] = X[j];
                X[j] = temp;
                temp = Y[i];
                Y[i] = Y[j];
                Y[j] = temp;
            }
        }
    }

    // Calculate the gradients if possible.  

    if(Y[0] != Y[1])
    {
        // P0->P2

        DeltaY[0] = TOREAL(1.0)/(Y[1] - Y[0]);
        M[0] = (X[1] - X[0])*DeltaY[0];
    }
    if(Y[1] != Y[2])
    {
        // P2->P1

        DeltaY[1] = TOREAL(1.0)/(Y[1] - Y[2]);
        M[1] = (X[1] - X[2])*DeltaY[1];
    }
    if(Y[2] != Y[0])
    {
        // P0->P2

        DeltaY[2] = TOREAL(1.0)/(Y[2] - Y[0]);
        M[2] = (X[2] - X[0])*DeltaY[2];
    }

    SetValid(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Get the x span and st array values for this triangle for the scanline 
*   specified by y.
*   NOTE:  This must be called after SetXSpan for a particular value of y.
*
* Return Value:
*
*   TRUE if retrieved successfully
*
* Created: peterost
*
\**************************************************************************/

BOOL
DpTriangleData::GetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x, GpPointF* s)
{
    // If SetXSpan did it's job correctly, we shouldn't need to do all this
    // stuff. In fact we shouldn't even need to pass all these parameters.
    // We simply retrieve the values for the span.
    
    if(!IsValid() || y < Y[0] || y >= Y[2] || xmin > Xmax || 
       xmax < Xmin || XSpan[0] == XSpan[1])
    {
        return FALSE;
    }

    // Retrieve the span coordinates.
    
    x[0] = XSpan[0];
    x[1] = XSpan[1];
    s[0].X = STGradient[0].X;
    s[0].Y = STGradient[0].Y;
    s[1].X = STGradient[1].X;
    s[1].Y = STGradient[1].Y;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the x span and st array values for this triangle for the scanline 
*   specified by y.
*   NOTE:  This must be called before GetXSpan for a particular value of y.
*
* Return Value:
*
*   TRUE if set successfully
*
* Created: peterost (factored out of GetXSpan created by ikkof)
*
\**************************************************************************/

BOOL
DpTriangleData::SetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x)
{
    if(!IsValid() || y < Y[0] || y >= Y[2] || xmin > Xmax || xmax < Xmin)
        return FALSE;

    REAL xSpan[2], dy;
    REAL s1[2], t1[2];

    if(y < Y[1])    // Y[0] <= y < Y[1]
    {
        dy = y - Y[0];

        // P0->P1
        xSpan[0] = X[0] + M[0]*dy;
        s1[0] = DeltaY[0]*dy;
        t1[0] = 0;

        // P0->P2
        xSpan[1] = X[0] + M[2]*dy;
        s1[1] = 0;
        t1[1] = DeltaY[2]*dy;
    }
    else // Y[1] <= y < Y[2]
    {
        // P2->P1
        dy = y - Y[2];
        xSpan[0] = X[2] + M[1]*dy;
        s1[0] = DeltaY[1]*dy;
        t1[0] = 1 - s1[0];

        // P0->P2
        dy = y - Y[0];
        xSpan[1] = X[0] + M[2]*dy;
        s1[1] = 0;
        t1[1] = DeltaY[2]*dy;;
    }

    if(xSpan[0] == xSpan[1])
    {
        XSpan[0] = xSpan[0];
        XSpan[1] = xSpan[1];
        return FALSE;
    }

    // We must convert to the st values of the original
    // triangle.

    INT sIndex = 1, tIndex = 2;

    for(INT i = 0; i < 3; i++)
    {
        if(Index[i] == 1)
            sIndex = i;
        if(Index[i] == 2)
            tIndex = i;
    }

    REAL s[2], t[2];

    switch(sIndex)
    {
    case 0:
        s[0] = 1 - s1[0] - t1[0];
        s[1] = 1 - s1[1] - t1[1];
        break;
    case 1:
        s[0] = s1[0];
        s[1] = s1[1];
        break;
    case 2:
        s[0] = t1[0];
        s[1] = t1[1];
        break;
    }

    switch(tIndex)
    {
    case 0:
        t[0] = 1 - s1[0] - t1[0];
        t[1] = 1 - s1[1] - t1[1];
        break;
    case 1:
        t[0] = s1[0];
        t[1] = s1[1];
        break;
    case 2:
        t[0] = t1[0];
        t[1] = t1[1];
        break;
    }

    INT k0, k1;

    if(xSpan[0] < xSpan[1])
    {
        k0 = 0;
        k1 = 1;
    }
    else
    {
        k0 = 1;
        k1 = 0;
    }

    XSpan[k0] = xSpan[0];
    XSpan[k1] = xSpan[1];
    STGradient[k0].X = s[0];
    STGradient[k1].X = s[1];
    STGradient[k0].Y = t[0];
    STGradient[k1].Y = t[1];

    x[0] = XSpan[0];
    x[1] = XSpan[1];

    return TRUE;
}

GpStatus
DpTriangleData::OutputSpan(
    ARGB* buffer,
    INT compositingMode,
    INT y,
    INT &xMin,
    INT &xMax    // xMax is exclusive
    )
{
    PointF st[2];
    REAL xSpan[2];

    // First grab the span for this y coordinate. 
    // Note that GetXSpan returns the xSpan coordinates and the (s, t) texture
    // coordinates and that both are unclipped. We have to infer the clipping
    // based on the difference between the xSpan coordinates and the 
    // input xMin and xMax coordinates and explicitly apply clipping to the
    // texture space coordinates (s, t).
    //
    // ( Texture mapping and gradient filling are mathematically similar 
    //   problems so we use 'texture space' and 'texture coordinates' 
    //   to refer to the gradient interpolation. In this way, gradient fills
    //   can be thought of as procedurally-defined textures. )
    
    if(!GetXSpan((REAL) y, (REAL) xMin, (REAL) xMax, xSpan, st))
    {
        return Ok;
    }
    
    // SetXSpan ensures a correct ordering of the xSpan coordinates.
    // We rely on this, so we must ASSERT it.
    
    ASSERT(xSpan[0] <= xSpan[1]);

    // Round using our rasterizer rounding rules.
    // This is not strictly true, though, our rasterizer uses GpFix4Ceiling
    // See RasterizerCeiling
    
    INT xLeft  = GpFix4Round(GpRealToFix4(xSpan[0]));
    INT xRight = GpFix4Round(GpRealToFix4(xSpan[1]));
    
    // Clip the x values.
    
    xLeft  = max(xLeft, xMin);
    xRight = min(xRight, xMax);  // remember, xMax is exclusive.
    
    // We're done. No pixels to emit.
    
    if(xLeft >= xRight)
    {
        return Ok;
    }
    
    // Now compute the per pixel interpolation increments for the 
    // texture (s, t) coordinates.
    
    // Here are our actual interpolation coordinates.
    // Start them off at the left-hand edge of the span.

    REAL s = st[0].X;
    REAL t = st[0].Y;
    
    // Left clipping.
    
    // This is the amount to clip off the left edge of the span to reach
    // the left-most pixel.
    
    REAL clipLength = (REAL)xLeft - xSpan[0];
    
    if(REALABS(clipLength) > REAL_EPSILON)
    {
        ASSERT((xSpan[1]-xSpan[0]) != 0.0f);
        
        // Compute the proportion of the span that we're clipping off.
        // This is in the range [0,1]
        
        REAL u = clipLength/(xSpan[1]-xSpan[0]);
        
        // Apply the proportion to texture space and then add to the left
        // texture coordinate.
        
        s += u*(st[1].X-st[0].X);
        t += u*(st[1].Y-st[0].Y);
    }

    // Temporaries to store the right-hand texture endpoint for the span.
    
    REAL s_right = st[1].X;
    REAL t_right = st[1].Y;
    
    // Right clipping.
    
    // This is the amount to clip off the right edge of the span to reach
    // the right-most pixel.
    
    clipLength = xSpan[1] - xRight;
    
    if(REALABS(clipLength) > REAL_EPSILON)
    {
        ASSERT((xSpan[1]-xSpan[0]) != 0.0f);
        
        // Compute the proportion of the span that we're clipping off.
        // This is in the range [0,1]
        
        REAL u = clipLength/(xSpan[1]-xSpan[0]);
        
        // Apply the proportion to texture space and then subtract from the 
        // right texture coordinate.
        
        s_right -= u*(st[1].X-st[0].X);
        t_right -= u*(st[1].Y-st[0].Y);
    }

    // Divide each texture coordinate interval by the number of pixels we're
    // emitting. Note that xRight != xLeft. Also note that SetXSpan ensures a 
    // correct ordering of the xSpan coordinates. This gives us a set of
    // per pixel delta values for the (s, t) coordinates.  
    // The next pixels texture coordinate is computed according 
    // to the following formula:
    // (s', t') <-- (s, t) + (ds, dt)

    ASSERT(xRight > xLeft);

    REAL ds = (s_right - s)/(xRight - xLeft);
    REAL dt = (t_right - t)/(xRight - xLeft);

    GpFColor128 colorOut;

    buffer += (xLeft - xMin);
    
    for(INT x = xLeft; x < xRight; x++, buffer++)
    {
        if(!(UsesPresetColors && BlendPositions0 && BlendCount0 > 1))
        {
            if(BlendCount0 == 1 && Falloff0 == 1
                && BlendCount1 == 1 && Falloff1 == 1
                && BlendCount2 == 1 && Falloff2 == 1)
            {
                colorOut.a = Color[0].a + s*(Color[1].a - Color[0].a) + t*(Color[2].a - Color[0].a);
                colorOut.r = Color[0].r + s*(Color[1].r - Color[0].r) + t*(Color[2].r - Color[0].r);
                colorOut.g = Color[0].g + s*(Color[1].g - Color[0].g) + t*(Color[2].g - Color[0].g);
                colorOut.b = Color[0].b + s*(Color[1].b - Color[0].b) + t*(Color[2].b - Color[0].b);
            }
            else
            {
                REAL u1, s1, t1;

                u1 = ::adjustValue(1 - s - t, BlendCount0, Falloff0,
                            BlendFactors0, BlendPositions0);
                s1 = ::adjustValue(s, BlendCount1, Falloff1,
                            BlendFactors1, BlendPositions1);
                t1 = ::adjustValue(t, BlendCount2, Falloff2,
                            BlendFactors2, BlendPositions2);

                REAL sum;

                if(!IsPolygonMode)
                {
                    sum = u1 + s1 + t1;
                    u1 = u1/sum;
                    s1 = s1/sum;
                    t1 = t1/sum;
                }
                else
                {
                    // If it is the polygon gradient, treat u1 differently.
                    // This gives the similar behavior as RadialGradient.

                    sum = s1 + t1;
                    if(sum != 0)
                    {
                        sum = (1 - u1)/sum;
                        s1 *= sum;
                        t1 *= sum;
                    }
                }

                colorOut.a = Color[0].a + s1*(Color[1].a - Color[0].a) + t1*(Color[2].a - Color[0].a);
                colorOut.r = Color[0].r + s1*(Color[1].r - Color[0].r) + t1*(Color[2].r - Color[0].r);
                colorOut.g = Color[0].g + s1*(Color[1].g - Color[0].g) + t1*(Color[2].g - Color[0].g);
                colorOut.b = Color[0].b + s1*(Color[1].b - Color[0].b) + t1*(Color[2].b - Color[0].b);
            }
        }
        else
        {
            interpolatePresetColors(
                &colorOut,
                1 - s - t,
                BlendCount0,
                PresetColors,
                BlendPositions0,
                GammaCorrect
            );
        }

        s += ds;
        t += dt;

        if((REALABS(colorOut.a) >= REAL_EPSILON) || 
            compositingMode == CompositingModeSourceCopy)
        {
            GpColorConverter colorConv;

            // Make sure the colorOut is properly premultiplied.
            
            CLAMP_COLOR_CHANNEL(colorOut.a, 255.0f)
            CLAMP_COLOR_CHANNEL(colorOut.r, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.g, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.b, colorOut.a);
            
            if(GammaCorrect)
            {
                colorConv.argb = GammaUnlinearizePremultiplied128(colorOut);
            }
            else
            {
                colorConv.Channel.a = static_cast<BYTE>(GpRound(colorOut.a));
                colorConv.Channel.r = static_cast<BYTE>(GpRound(colorOut.r));
                colorConv.Channel.g = static_cast<BYTE>(GpRound(colorOut.g));
                colorConv.Channel.b = static_cast<BYTE>(GpRound(colorOut.b));
            }
            
            // Clamp to the alpha channel for the premultiplied alpha blender.
            
            *buffer = colorConv.argb;
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    if(width <= 0)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL)xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    REAL u1, v1, u2, v2, du, dv;

    u1 = (pt1.X - BrushRect.X)/BrushRect.Width;
    v1 = (pt1.Y - BrushRect.Y)/BrushRect.Height;
    u2 = (pt2.X - BrushRect.X)/BrushRect.Width;
    v2 = (pt2.Y - BrushRect.Y)/BrushRect.Height;
    du = (u2 - u1)/width;
    dv = (v2 - v1)/width;

    INT i;
    REAL u0 = u1, v0 = v1;
    REAL u, v;

    REAL delta = min(BrushRect.Width, BrushRect.Height)/2;
    
    if(REALABS(delta) < REAL_EPSILON)
    {
        delta = 1.0f;
    }
    
    REAL deltaInv = 1.0f/delta;

    for(i = 0; i < width; i++, buffer++)
    {
        u = u0;
        v = v0;
        REAL alpha = 0, red = 0, green = 0, blue = 0;

        // If this is the outside of the rectangle in Clamp mode,
        // don't draw anything.

        if(WrapMode == WrapModeClamp)
        {
            if(u < 0 || u > 1 || v < 0 || v > 1)
            {
                *buffer = 0;

                goto NextUV;
            }
        }
        
        // Remap the v-coordinate in Tile mode.

        if(WrapMode == WrapModeTile || WrapMode == WrapModeTileFlipX)
        {
            // Get the fractional part of v.
            v = GpModF(v, 1);
        }
        else if(WrapMode == WrapModeTileFlipY || WrapMode == WrapModeTileFlipXY)
        {
            INT nV;

            nV = GpFloor(v);
            v = GpModF(v, 1);

            if(nV & 1)
                v = 1 - v;  // flip.
        }

        // Remap the u-coordinate in Tile mode.

        if(WrapMode == WrapModeTile || WrapMode == WrapModeTileFlipY)
        {
            // Get the fractional part of u.
            u = GpModF(u, 1);
        }
        else if(WrapMode == WrapModeTileFlipX || WrapMode == WrapModeTileFlipXY)
        {
            INT nU;

            nU = GpFloor(u);
            u = GpModF(u, 1);

            if(nU & 1)
                u = 1 - u;  // flip.
        }

        if(/*BrushType == BrushRectGrad ||*/ BrushType == BrushTypeLinearGradient)
        {
            const GpRectGradient* rectGrad = static_cast<const GpRectGradient*> (Brush);

            if(!(rectGrad->HasPresetColors() &&
                 rectGrad->DeviceBrush.PresetColors &&
                 rectGrad->DeviceBrush.BlendPositions[0] &&
                 rectGrad->DeviceBrush.BlendCounts[0] > 1))
            {
                u = ::adjustValue(
                    u,
                    rectGrad->DeviceBrush.BlendCounts[0],
                    rectGrad->DeviceBrush.Falloffs[0],
                    rectGrad->DeviceBrush.BlendFactors[0],
                    rectGrad->DeviceBrush.BlendPositions[0]
                    );

                v = ::adjustValue(
                    v,
                    rectGrad->DeviceBrush.BlendCounts[1],
                    rectGrad->DeviceBrush.Falloffs[1],
                    rectGrad->DeviceBrush.BlendFactors[1],
                    rectGrad->DeviceBrush.BlendPositions[1]
                    );

                REAL c[4];

                c[0] = (1 - u)*(1 - v);
                c[1] = u*(1 - v);
                c[2] = (1 - u)*v;
                c[3] = u*v;

                // We must interpolate alpha.
                alpha = c[0]*A[0] + c[1]*A[1]
                    + c[2]*A[2] + c[3]*A[3];
                red = c[0]*R[0] + c[1]*R[1]
                    + c[2]*R[2] + c[3]*R[3];
                green = c[0]*G[0] + c[1]*G[1]
                    + c[2]*G[2] + c[3]*G[3];
                blue = c[0]*B[0] + c[1]*B[1]
                    + c[2]*B[2] + c[3]*B[3];
            }
            else
            {
                GpFColor128 color;
                interpolatePresetColors(
                    &color,
                    u,
                    rectGrad->DeviceBrush.BlendCounts[0],
                    rectGrad->DeviceBrush.PresetColors,
                    rectGrad->DeviceBrush.BlendPositions[0],
                    FALSE
                );
                
                alpha = color.a;
                red = color.r;
                green = color.g;
                blue = color.b;
            }
        }

        if(alpha != 0 || CompositingMode == CompositingModeSourceCopy)
        {
            CLAMP_COLOR_CHANNEL(alpha, 255.0f);
            CLAMP_COLOR_CHANNEL(red, alpha);
            CLAMP_COLOR_CHANNEL(green, alpha);
            CLAMP_COLOR_CHANNEL(blue, alpha);

            *buffer = GpColor::MakeARGB(
                static_cast<BYTE>(GpRound(alpha)),
                static_cast<BYTE>(GpRound(red)),
                static_cast<BYTE>(GpRound(green)), 
                static_cast<BYTE>(GpRound(blue)));
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

NextUV:
        u0 += du;
        v0 += dv;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Constructor for One Dimentional Gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*   [IN] isHorizontal - TRUE if this is the horizontal gradient.
*                       Also TRUE for more complicated one-D gradient like
*                       Radial Gradient.
*   [IN] isVertical - TRUE if this is the vertical gradient.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/21/1999 ikkof
*
\**************************************************************************/

DpOutputOneDGradientSpan::DpOutputOneDGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context,
    BOOL isHorizontal,
    BOOL isVertical
    ) : DpOutputGradientSpan(brush, scan, context)
{
    FPUStateSaver::AssertMode();
    
    Initialize();               
    
    GpStatus status = AllocateOneDData(isHorizontal, isVertical);

    if(status == Ok)
    {
        if(BrushType == BrushTypeLinearGradient)
        {
            SetupRectGradientOneDData();
        }
    }

    if(status == Ok)
        SetValid(TRUE);
}

GpStatus
DpOutputOneDGradientSpan::AllocateOneDData(
    BOOL isHorizontal,
    BOOL isVertical
    )
{
    if(!isHorizontal && !isVertical)
        return InvalidParameter;
    
    IsHorizontal = isHorizontal;
    IsVertical = isVertical;

    GpPointF axis[4];

    axis[0].X = 0;
    axis[0].Y = 0;
    axis[1].X = BrushRect.Width;
    axis[1].Y = 0;
    axis[2].X = BrushRect.Width;
    axis[2].Y = BrushRect.Height;
    axis[3].X = 0;
    axis[3].Y = BrushRect.Height;

    WorldToDevice.VectorTransform(&axis[0], 4);

    // Calculate the sum of the diagonals as the largest possible distance
    // of interest and use this to size the OneD array of colors.  This gets us
    // to within 1 bit of the "true" gradient values for each A,R,G,B channel.
    REAL d1 = REALSQRT(distance_squared(axis[0], axis[2]));
    REAL d2 = REALSQRT(distance_squared(axis[1], axis[3]));

    OneDDataMultiplier = max(1, GpCeiling(d1+d2));
    OneDDataCount = OneDDataMultiplier + 2;

    GpStatus status = Ok;

    OneDData = (ARGB*) GpMalloc(OneDDataCount*sizeof(ARGB));

    if(!OneDData)
        status = OutOfMemory;

    return status;
}

DpOutputOneDGradientSpan::~DpOutputOneDGradientSpan()
{
    if(OneDData)
        GpFree(OneDData);
}

VOID
DpOutputOneDGradientSpan::SetupRectGradientOneDData(
    )
{
    REAL u, u0, du;

    u0 = 0;
    du = 1.0f/OneDDataMultiplier;
    ARGB* buffer = OneDData;

    ASSERT(buffer);
    if(!buffer)
        return;

    for(INT i = 0; i < OneDDataCount; i++, buffer++)
    {       
        u = u0;

        const GpRectGradient* rectGrad = static_cast<const GpRectGradient*> (Brush);

        REAL alpha = 0, red = 0, green = 0, blue = 0;

        if(!(rectGrad->HasPresetColors() &&
            rectGrad->DeviceBrush.PresetColors &&
            rectGrad->DeviceBrush.BlendPositions[0] &&
            rectGrad->DeviceBrush.BlendCounts[0] > 1))
        {
            INT index, i0, i1;
            REAL a0, r0, g0, b0, a1, r1, g1, b1;

            if(IsHorizontal)
            {
                index = 0;
                i0 = 0;
                i1 = 1;
            }
            else
            {
                index = 1;
                i0 = 0;
                i1 = 2;
            }

            a0 = A[i0];
            r0 = R[i0];
            g0 = G[i0];
            b0 = B[i0];

            a1 = A[i1];
            r1 = R[i1];
            g1 = G[i1];
            b1 = B[i1];
            
            u = ::adjustValue(
                u0,
                rectGrad->DeviceBrush.BlendCounts[index],
                rectGrad->DeviceBrush.Falloffs[index],
                rectGrad->DeviceBrush.BlendFactors[index],
                rectGrad->DeviceBrush.BlendPositions[index]
                );

            REAL c[2];

            c[0] = (1 - u);
            c[1] = u;

            // We must interpolate alpha.
            alpha = c[0]*a0 + c[1]*a1;
            red = c[0]*r0 + c[1]*r1;
            green = c[0]*g0 + c[1]*g1;
            blue = c[0]*b0 + c[1]*b1;
        }
        else
        {
            GpFColor128 color;
                
            interpolatePresetColors(
                &color, 
                u0,
                rectGrad->DeviceBrush.BlendCounts[0],
                rectGrad->DeviceBrush.PresetColors,
                rectGrad->DeviceBrush.BlendPositions[0],
                FALSE
            );
            alpha = color.a;
            red = color.r;
            green = color.g;
            blue = color.b;
        }

        if(alpha != 0 || CompositingMode == CompositingModeSourceCopy)
        {
            CLAMP_COLOR_CHANNEL(alpha, 255.0f);
            CLAMP_COLOR_CHANNEL(red, alpha);
            CLAMP_COLOR_CHANNEL(green, alpha);
            CLAMP_COLOR_CHANNEL(blue, alpha);

            *buffer = GpColor::MakeARGB(
                static_cast<BYTE>(GpRound(alpha)),
                static_cast<BYTE>(GpRound(red)),
                static_cast<BYTE>(GpRound(green)), 
                static_cast<BYTE>(GpRound(blue)));
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

        u0 += du;
    }
}


VOID
DpOutputOneDGradientSpan::SetupRadialGradientOneDData()
{
    ASSERT(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputOneDGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    if(width <= 0 || !OneDData)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL)xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    REAL u1, v1, u2, v2;

    u1 = (pt1.X - BrushRect.X)/BrushRect.Width;
    v1 = (pt1.Y - BrushRect.Y)/BrushRect.Height;
    u2 = (pt2.X - BrushRect.X)/BrushRect.Width;
    v2 = (pt2.Y - BrushRect.Y)/BrushRect.Height;

    INT u1Major, u2Major, v1Major, v2Major;
    INT u1Minor, u2Minor, v1Minor, v2Minor;

    u1Major = GpFloor(u1); 
    u2Major = GpFloor(u2);
    u1Minor = GpRound(OneDDataMultiplier*(u1 - u1Major));
    u2Minor = GpRound(OneDDataMultiplier*(u2 - u2Major));

    v1Major = GpFloor(v1);
    v2Major = GpFloor(v2);
    v1Minor = GpRound(OneDDataMultiplier*(v1 - v1Major));
    v2Minor = GpRound(OneDDataMultiplier*(v2 - v2Major));

    INT du, dv;

    du = GpRound((u2 - u1)*OneDDataMultiplier/width);
    dv = GpRound((v2 - v1)*OneDDataMultiplier/width);

    INT i;

    INT uMajor, uMinor, vMajor, vMinor;

    uMajor = u1Major;
    uMinor = u1Minor;
    vMajor = v1Major;
    vMinor = v1Minor;

    if(BrushType == BrushTypeLinearGradient)
    {
        for(i = 0; i < width; i++, buffer++)
        {
            if(IsHorizontal)
            {
                if((WrapMode == WrapModeTileFlipX || WrapMode == WrapModeTileFlipXY)
                    && (uMajor & 0x01) != 0)
                    *buffer = OneDData[OneDDataMultiplier - uMinor];
                else
                    *buffer = OneDData[uMinor];
            }
            else if(IsVertical)
            {
                if((WrapMode == WrapModeTileFlipY || WrapMode == WrapModeTileFlipXY)
                    && (vMajor & 0x01) != 0)
                    *buffer = OneDData[OneDDataMultiplier - vMinor];
                else
                    *buffer = OneDData[vMinor];
            }

            if(WrapMode == WrapModeClamp)
            {
                if(uMajor != 0 || vMajor != 0)
                    *buffer = 0;
            }

            uMinor += du;

            while(uMinor >= OneDDataMultiplier)
            {
                uMajor++;
                uMinor -= OneDDataMultiplier;
            }

            while(uMinor < 0)
            {
                uMajor--;
                uMinor += OneDDataMultiplier;
            }

            vMinor += dv;

            while(vMinor >= OneDDataMultiplier)
            {
                vMajor++;
                vMinor -= OneDDataMultiplier;
            }

            while(vMinor < 0)
            {
                vMajor--;
                vMinor += OneDDataMultiplier;
            }
        }
    } 

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for linear gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

DpOutputLinearGradientSpan::DpOutputLinearGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputGradientSpan(brush, scan, context)
{
    SetValid(FALSE);

    const GpRectGradient* gradient = static_cast<const GpRectGradient*>(brush);

    // Copy some brush attributes to locals for speed:

    GpRectF brushRect;
    gradient->GetRect(brushRect);

    BOOL doPresetColor = (gradient->HasPresetColors());
    BOOL doAdjustValue = (gradient->DeviceBrush.BlendCounts[0] != 1) ||
                         (gradient->DeviceBrush.Falloffs[0] != 1);

    // For now we just assume 32 pixels in the texture.  In the future,
    // we can change this to be inherited from the API.

    UINT numberOfIntervalBits = 5;
    UINT numberOfTexels = 32;
    
    // If we're doing a fancy blend with multiple color points.

    if(doPresetColor || doAdjustValue)
    {
        // Office specifies simple blends with 2-3 blend factors. If it's a 
        // simple blend, 32 texels is enough, but if it's complicated lets
        // use more texels.  Use in the range of the width + height, with a
        // cap of 512.  Using too many texels can result in overflow errors
        // when calculating M11, M21 and Dx, and is wasted memory and 
        // processing power.

        if(gradient->DeviceBrush.BlendCounts[0] > 3)
        {
            REAL widthHeight = brushRect.Width + brushRect.Height;
            if (widthHeight > 512)
            {
                numberOfTexels = 512;
               numberOfIntervalBits = 9;
            }
            else if (widthHeight > 128)
            {
                numberOfTexels = 128;
                numberOfIntervalBits = 7;
            }
        } 
    }
 
    const UINT halfNumberOfTexels = numberOfTexels / 2;

    // The number of texels has to be a power of two:

    ASSERT((numberOfTexels & (numberOfTexels - 1)) == 0);

    // Remember the size:

    IntervalMask = numberOfTexels - 1;
    NumberOfIntervalBits = numberOfIntervalBits;

    // We want to create a transform that takes us from any point in the
    // device-space brush parallelogram to normalized texture coordinates.
    // We're a bit tricky here and do the divide by 2 to handle TileFlipX:

    REAL normalizedSize = (REAL)(numberOfTexels * (1 << ONEDNUMFRACTIONALBITS));

    GpRectF normalizedRect(
        0.0f, 0.0f, 
        normalizedSize / 2, 
        normalizedSize / 2
    );

    GpMatrix normalizeBrushRect;
    if (normalizeBrushRect.InferAffineMatrix(brushRect, normalizedRect) == Ok)
    {
        DeviceToNormalized = WorldToDevice;
        DeviceToNormalized.Prepend(normalizeBrushRect);
        if (DeviceToNormalized.Invert() == Ok)
        {
            // Convert the transform to fixed point units:

            M11 = GpRound(DeviceToNormalized.GetM11());
            M21 = GpRound(DeviceToNormalized.GetM21());
            Dx  = GpRoundSat(DeviceToNormalized.GetDx());

            // For every pixel that we step one to the right in device space,
            // we need to know the corresponding x-increment in texture (err,
            // I mean gradient) space.  Take a (1, 0) device vector, pop-it
            // through the device-to-normalized transform, and you get this
            // as the xIncrement result:

            XIncrement = M11;

            ULONG i;
            GpFColor128 color;
            REAL w;

            // should we perform gamma correction to gamma 2.2 
            
            BOOL doGammaConversion = brush->GetGammaCorrection();
            
            // Store our real converted color channels.
            
            GpFColor128 A, B;
            
            // Convert the end colors to premultiplied form,
            // Convert the end color components to REALs,
            // ... and pre-gamma convert to 2.2 if necessary.
            
            GammaLinearizeAndPremultiply(
                gradient->DeviceBrush.Colors[0].GetValue(),
                doGammaConversion, 
                &A
            );

            GammaLinearizeAndPremultiply(
                gradient->DeviceBrush.Colors[1].GetValue(),
                doGammaConversion, 
                &B
            );

            // Okay, now we simply have to load the texture:

            ULONGLONG *startTexelArgb = &StartTexelArgb[0];
            ULONGLONG *endTexelArgb = &EndTexelArgb[0];

            AGRB64TEXEL *startTexelAgrb = &StartTexelAgrb[0];
            AGRB64TEXEL *endTexelAgrb = &EndTexelAgrb[0];

            REAL wIncrement = 1.0f / halfNumberOfTexels;

            // Note that we're looping through ONEDREALTEXTUREWIDTH + 1
            // elements!

            for (w = 0, i = 0;
                 i <= halfNumberOfTexels;
                 w += wIncrement, i++)
            {
                // We sample the specified interpolators at our fixed
                // frequency:

                if (doPresetColor)
                {
                    interpolatePresetColors(
                        &color, w, 
                        gradient->DeviceBrush.BlendCounts[0],
                        gradient->DeviceBrush.PresetColors,
                        gradient->DeviceBrush.BlendPositions[0],
                        doGammaConversion
                    );
                }
                else
                {
                    REAL multB = w;
                    if (doAdjustValue)
                    {
                        multB = slowAdjustValue(w, 
                            gradient->DeviceBrush.BlendCounts[0],
                            gradient->DeviceBrush.Falloffs[0],
                            gradient->DeviceBrush.BlendFactors[0],
                            gradient->DeviceBrush.BlendPositions[0]);

                        // !!![andrewgo] This can produce out-of-range numbers
                    }

                    REAL multA = 1.0f - multB;

                    color.a = (A.a * multA) + (B.a * multB);
                    color.r = (A.r * multA) + (B.r * multB);
                    color.g = (A.g * multA) + (B.g * multB);
                    color.b = (A.b * multA) + (B.b * multB);
                }

                // Note that we're actually touching ONEDREALTEXTUREWIDTH + 1
                // elements in the array here!

                if(doGammaConversion)
                {
                    GpColorConverter colorConv;
                    colorConv.argb = GammaUnlinearizePremultiplied128(color);
                    
                    startTexelAgrb[i].A00aa00gg = 
                        (colorConv.Channel.a << 16) | colorConv.Channel.g;
                    startTexelAgrb[i].A00rr00bb = 
                        (colorConv.Channel.r << 16) | colorConv.Channel.b;
                }
                else
                {
                    startTexelAgrb[i].A00aa00gg = 
                        (GpRound(color.a) << 16) | GpRound(color.g);
                    startTexelAgrb[i].A00rr00bb = 
                        (GpRound(color.r) << 16) | GpRound(color.b);
                }

                ASSERT((startTexelAgrb[i].A00aa00gg & 0xff00ff00) == 0);
                ASSERT((startTexelAgrb[i].A00rr00bb & 0xff00ff00) == 0);
            }

            // Replicate the interval start colors to the end colors (note
            // again that we actually reference ONEDREALTEXTUREWIDTH + 1
            // elements):

            for (i = 0; i < halfNumberOfTexels; i++)
            {
                endTexelArgb[i] = startTexelArgb[i + 1];
            }

            // Here's why we've only filled up half the texture so far.
            // If FlipX is set, we make the second half an inverted
            // copy of the first; if not, we make it a straight copy:

            if ((gradient->GetWrapMode() != WrapModeTileFlipX) &&
                (gradient->GetWrapMode() != WrapModeTileFlipXY))
            {
                memcpy(&startTexelArgb[halfNumberOfTexels],
                       &startTexelArgb[0],
                       halfNumberOfTexels * sizeof(startTexelArgb[0]));
                memcpy(&endTexelArgb[halfNumberOfTexels],
                       &endTexelArgb[0],
                       halfNumberOfTexels * sizeof(endTexelArgb[0]));
            }
            else
            {
                for (i = 0; i < halfNumberOfTexels; i++)
                {
                    startTexelArgb[halfNumberOfTexels + i] 
                        = endTexelArgb[halfNumberOfTexels - i - 1];

                    endTexelArgb[halfNumberOfTexels + i]
                        = startTexelArgb[halfNumberOfTexels - i - 1];
                }
            }

            // We're done!  We're set!

            SetValid(TRUE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for MMX linear gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

DpOutputLinearGradientSpan_MMX::DpOutputLinearGradientSpan_MMX(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputLinearGradientSpan(brush, scan, context)
{
    ASSERT(OSInfo::HasMMX);

    // Here we do some additional stuff for our MMX routine, beyond
    // what the base constructor did.

#if defined(_X86_)

    UINT32 numberOfTexels = IntervalMask + 1;
    ULONGLONG *startTexelArgb = &StartTexelArgb[0];
    ULONGLONG *endTexelArgb = &EndTexelArgb[0];
    static ULONGLONG OneHalf8dot8 = 0x0080008000800080;

    // The C constructor creates the colors in AGRB order, but we
    // want them in ARGB order, so swap R and G for every pixel:

    USHORT *p = reinterpret_cast<USHORT*>(startTexelArgb);
    for (UINT i = 0; i < numberOfTexels; i++, p += 4)
    {
        USHORT tmp = *(p + 1);
        *(p + 1) = *(p + 2);
        *(p + 2) = tmp;
    }

    p = reinterpret_cast<USHORT*>(endTexelArgb);
    for (UINT i = 0; i < numberOfTexels; i++, p += 4)
    {
        USHORT tmp = *(p + 1);
        *(p + 1) = *(p + 2);
        *(p + 2) = tmp;
    }

    // Make some more adjustments for our MMX routine:
    //
    //     EndTexelArgb[i] -= StartTexelArgb[i]
    //     StartTexelArgb[i] = 256 * StartTexelArgb[i] + OneHalf

    _asm
    {
        mov     ecx, numberOfTexels
        mov     esi, startTexelArgb
        mov     edi, endTexelArgb

    MoreTexels:
        movq    mm0, [esi]
        movq    mm1, [edi]
        psubw   mm1, mm0
        psllw   mm0, 8
        paddw   mm0, OneHalf8dot8
        movq    [esi], mm0
        movq    [edi], mm1
        add     esi, 8
        add     edi, 8
        dec     ecx
        jnz     MoreTexels

        emms
    }

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Uses linear interpolation from a small one dimensional texture
*   that effectively creates a piecewise-linear approximation to
*   the blend curve.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputLinearGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ASSERT((BrushType == BrushTypeLinearGradient) /*|| (BrushType == BrushRectGrad)*/);
    ASSERT(xMax > xMin);

    // Copy some class stuff to local variables for faster access in
    // our inner loop:

    INT32 xIncrement = XIncrement;
    AGRB64TEXEL *startTexels = &StartTexelAgrb[0];
    AGRB64TEXEL *endTexels = &EndTexelAgrb[0];
    UINT32 count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);
    UINT32 intervalMask = IntervalMask;

    // Given our start point in device space, figure out the corresponding 
    // texture pixel.  Note that this is expressed as a fixed-point number 
    // with FRACTIONBITS bits of fractional precision:

    INT32 xTexture = (xMin * M11) + (y * M21) + Dx;

    do {
        // We want to linearly interpolate between two pixels,
        // A and B (where A is the floor pixel, B the ceiling pixel).
        // 'multA' is the fraction of pixel A that we want, and
        // 'multB' is the fraction of pixel B that we want:

        UINT32 multB = ONEDGETFRACTIONAL8BITS(xTexture);   
        UINT32 multA = 256 - multB;

        // We could actually do a big lookup table right off of 'xTexture'
        // for however many bits of precision we wanted to do.  But that
        // would be too much work in the setup.

        UINT32 iTexture = ONEDGETINTEGERBITS(xTexture) & intervalMask;

        AGRB64TEXEL *startTexel = &startTexels[iTexture];
        AGRB64TEXEL *endTexel = &endTexels[iTexture];

        // Note that we can gamma correct the texels so that we don't
        // have to do gamma correction here.  The addition of constants
        // here are to accomplish rounding:

        UINT32 rrrrbbbb = (startTexel->A00rr00bb * multA) 
                        + (endTexel->A00rr00bb * multB)
                        + 0x00800080;

        UINT32 aaaagggg = (startTexel->A00aa00gg * multA)
                        + (endTexel->A00aa00gg * multB)
                        + 0x00800080;

        *buffer = (aaaagggg & 0xff00ff00) + ((rrrrbbbb & 0xff00ff00) >> 8);

        buffer++;
        xTexture += xIncrement;

    } while (--count != 0);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*
* Created:
*
*   03/16/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputLinearGradientSpan_MMX::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ASSERT((BrushType == BrushTypeLinearGradient) /*|| (BrushType == BrushRectGrad)*/);

#if defined(_X86_)

    ASSERT(xMax > xMin);

    // Copy some class stuff to local variables for faster access in
    // our inner loop:

    INT32 xIncrement = XIncrement;
    AGRB64TEXEL *startTexels = &StartTexelAgrb[0];
    AGRB64TEXEL *endTexels = &EndTexelAgrb[0];
    UINT32 count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    // Given our start point in device space, figure out the corresponding 
    // texture pixel.  Note that this is expressed as a fixed-point number 
    // with FRACTIONBITS bits of fractional precision:

    INT32 xTexture = (xMin * M11) + (y * M21) + Dx;

    // Scale up the interval count to the MSB so that we don't have to do
    // a mask in the inner loop, which assumes 16.16 for the fixed point
    // representation.

    UINT32 downshiftAmount = 32 - NumberOfIntervalBits;
    UINT32 upshiftAmount = 16 - NumberOfIntervalBits;
    UINT32 intervalCounter = xTexture << upshiftAmount;
    UINT32 intervalIncrement = xIncrement << upshiftAmount;

    // Prepare for the three stages:
    // stage1: QWORD align the destination
    // stage2: process 2 pixels at a time
    // stage3: process the last pixel if present

    UINT32 stage1_count = 0, stage2_count = 0, stage3_count = 0;
    if (count > 0)
    {
        // If destination is not QWORD aligned, process the first pixel
        // in stage 1.

        if (((UINT_PTR) buffer) & 0x4)
        {
            stage1_count = 1;
            count--;
        }

        stage2_count = count >> 1;
        stage3_count = count - 2 * stage2_count;

        _asm 
        {
            // eax = pointer to interval-start array
            // ebx = pointer to interval-end array
            // ecx = shift count
            // edx = scratch
            // esi = count
            // edi = destination
            // mm0 = interval counter
            // mm1 = interval incrementer
            // mm2 = fractional counter
            // mm3 = fractional incrementer
            // mm4 = temp
            // mm5 = temp

            dec         stage1_count

            mov         eax, startTexels
            mov         ebx, endTexels
            mov         ecx, downshiftAmount             
            mov         esi, stage2_count
            mov         edi, buffer
            movd        mm0, intervalCounter
            movd        mm1, intervalIncrement

            movd        mm2, xTexture           // 0 | 0 | 0 | 0 || x | x | mult | lo
            movd        mm3, xIncrement
            punpcklwd   mm2, mm2                // 0 | x | 0 | x || mult | lo | mult | lo
            punpcklwd   mm3, mm3
            punpckldq   mm2, mm2                // mult | lo | mult | lo || mult | lo | mult | lo
            punpckldq   mm3, mm3

            // This preparation normally happens inside the loop:

            movq        mm4, mm2                // mult | x | mult | x || mult | x | mult | x
            movd        edx, mm0

            jnz         pre_stage2_loop         // the flags for this are set in the "dec stage1_count" above

// stage1_loop:
  
            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            pmullw      mm4, [ebx + edx*8]
            paddd       mm0, mm1                // interval counter += interval increment

            add         edi, 4                  // buffer++

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        

            packuswb    mm4, mm4                // a | r | g | b || a | r | g | b

            movd        [edi - 4], mm4        
            movq        mm4, mm2                // Prepare for next iteration

pre_stage2_loop:

            cmp         esi, 0
            jz          stage3_loop             // Do we need to execute the stage2_loop?

stage2_loop:

            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            paddd       mm0, mm1                // interval counter += interval increment
            pmullw      mm4, [ebx + edx*8]

            add         edi, 8                  // buffer++

            paddw       mm2, mm3                // fractional counter += fractional increment

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            shr         edx, cl

            movq        mm5, mm2                // Prepare for next iteration


            psrlw       mm5, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        
            paddd       mm0, mm1                // interval counter += interval increment
            pmullw      mm5, [ebx + edx*8]
            dec         esi                     // count--

            paddw       mm5, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm5, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        
  
            packuswb    mm4, mm5
            
            movq        [edi - 8], mm4        
            movq        mm4, mm2                // Prepare for next iteration
            jnz         stage2_loop

 stage3_loop:

            dec         stage3_count
            jnz         skip_stage3_loop

            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            pmullw      mm4, [ebx + edx*8]
            paddd       mm0, mm1                // interval counter += interval increment

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        

            packuswb    mm4, mm4                // a | r | g | b || a | r | g | b
  
            movd        [edi], mm4        

skip_stage3_loop:

            emms
        }
    }

#endif

    return(Ok);
}

DpOutputPathGradientSpan::DpOutputPathGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputGradientSpan(brush, scan, context)
{
    SetValid(FALSE);
    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (brush);

    if(pathBrush->DeviceBrush.Path)
        pathBrush->Flatten(&WorldToDevice);

    Count = pathBrush->GetNumberOfPoints();
    PointF pt0, pt1, pt2;
    pathBrush->GetCenterPoint(&pt0);
    WorldToDevice.Transform(&pt0);

    GpColor c0, c1, c2;
    pathBrush->GetCenterColor(&c0);

    Triangles = (DpTriangleData**) GpMalloc(Count*sizeof(DpTriangleData*));

    BOOL isPolygonMode = TRUE;

    if(Triangles)
    {
        GpMemset(Triangles, 0, Count*sizeof(DpTriangleData*));

        INT j;
        for(INT i = 0; i < Count; i++)
        {
            if(i < Count - 1)
                j = i + 1;
            else
                j = 0;

            pathBrush->GetPoint(&pt1, i);
            pathBrush->GetPoint(&pt2, j);

            if(pt1.X != pt2.X || pt1.Y != pt2.Y)
            {
                DpTriangleData* tri = new DpTriangleData();
                pathBrush->GetSurroundColor(&c1, i);
                pathBrush->GetSurroundColor(&c2, j);

                // Transform points if they have not been flattened,
                // since OutputSpan gets span data as Device units and 
                // the BLTransform must be in the same coordinate space.
                
                if (pathBrush->FlattenPoints.GetCount() == 0)
                {
                    WorldToDevice.Transform(&pt1);
                    WorldToDevice.Transform(&pt2);
                }

                tri->SetTriangle(
                    pt0, pt1, pt2, 
                    c0, c1, c2, 
                    isPolygonMode,
                    brush->GetGammaCorrection()
                );

                // Set the blend factors.
                tri->Falloff0 = pathBrush->DeviceBrush.Falloffs[0];
                tri->Falloff1 = 1;
                tri->Falloff2 = 1;
                tri->BlendCount0 = pathBrush->DeviceBrush.BlendCounts[0];
                tri->BlendCount1 = 1;
                tri->BlendCount2 = 1;
                tri->BlendFactors0 = pathBrush->DeviceBrush.BlendFactors[0];
                tri->BlendFactors1 = NULL;
                tri->BlendFactors2 = NULL;
                tri->BlendPositions0 = pathBrush->DeviceBrush.BlendPositions[0];
                tri->BlendPositions1 = NULL;
                tri->BlendPositions2 = NULL;
                tri->PresetColors = pathBrush->DeviceBrush.PresetColors;
                tri->UsesPresetColors = pathBrush->DeviceBrush.UsesPresetColors;

                Triangles[i] = tri;
            }
            else
                Triangles[i] = NULL;
        }
        SetValid(TRUE);
    }
    else
        SetValid(FALSE);
}

DpOutputPathGradientSpan::~DpOutputPathGradientSpan(
    VOID
    )
{
    FreeData();
}

VOID
DpOutputPathGradientSpan::FreeData()
{
    if(Triangles) {
        for(INT i = 0; i < Count; i++)
        {
            DpTriangleData* tri = Triangles[i];
            delete tri;
            Triangles[i] = NULL;
        }

        GpFree(Triangles);
        Triangles = NULL;
    }

    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a polygon gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   03/24/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputPathGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    if(!IsValid())
        return Ok;

    INT     xxMin = xMax, xxMax = xMin;
    INT     iFirst = 0x7FFFFFFF, iLast = 0;

    for(INT i = 0; i < Count; i++)
    {
        DpTriangleData* triangle = Triangles[i];
        REAL   xx[2];
        
        if(triangle &&
           triangle->SetXSpan((REAL) y, (REAL) xMin, (REAL) xMax, xx))
        {
            xxMin = min(xxMin, GpFloor(xx[0]));
            xxMax = max(xxMax, GpRound(xx[1]));
            iFirst = min(iFirst, i);
            iLast = i;
        }
    }

    // Don't attempt to fill outside the specified x bounds
    xxMin = max(xxMin, xMin);
    xxMax = min(xxMax, xMax);

    INT  width = xxMax - xxMin;  // Right exclusive when filling
    
    // No triangles intersect this scan line, so exit
    if (width <= 0)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xxMin, y, width);
    GpMemset(buffer, 0, width*sizeof(ARGB));

    for(INT i = iFirst; i <= iLast; i++)
    {
        DpTriangleData* triangle = Triangles[i];
        if(triangle)
            triangle->OutputSpan(buffer, CompositingMode,
                y, xxMin, xxMax);
    }

    return Ok;
}

DpOutputOneDPathGradientSpan::DpOutputOneDPathGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context,
    BOOL isHorizontal,
    BOOL isVertical
    ) : DpOutputOneDGradientSpan(
            brush,
            scan,
            context,
            isHorizontal,
            isVertical)
{
    if(!IsValid())
        return;

    SetupPathGradientOneDData(brush->GetGammaCorrection());

    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (brush);

    if(pathBrush->DeviceBrush.Path)
        pathBrush->Flatten(&WorldToDevice);

    Count = pathBrush->GetNumberOfPoints();
    PointF pt0, pt1, pt2;
    pathBrush->GetCenterPoint(&pt0);
    WorldToDevice.Transform(&pt0);
    
    // Round center point to nearest 1/16 of a pixel, since
    // this is the rasterizer resolution.  This eliminates
    // precision errors that can affect bilinear transforms.
    pt0.X = FIX4TOREAL(GpRealToFix4(pt0.X));
    pt0.Y = FIX4TOREAL(GpRealToFix4(pt0.Y));
    
    REAL xScale = pathBrush->DeviceBrush.FocusScaleX;
    REAL yScale = pathBrush->DeviceBrush.FocusScaleY;

    REAL inflation;
    pathBrush->GetInflationFactor(&inflation);

    // If we have falloff values, then there are twice the number of
    // transforms.  If we are inflating the gradient outwards, then
    // there are additional transforms also.
    INT  infCount;
    INT  blCount = Count;
    if (xScale != 0 || yScale != 0)
    {
        Count *= 2;
        infCount = Count;
    }
    else
    {
        infCount = blCount;
    }
    
    if (inflation > 1.0f)
    {
        Count += blCount;
    }

    BLTransforms = new GpBilinearTransform[Count];

    GpPointF points[4];
    GpRectF rect(0, 0, 1, 1);

    if(BLTransforms)
    {
        INT j;
        for(INT i = 0; i < blCount; i++)
        {
            if(i < blCount - 1)
                j = i + 1;
            else
                j = 0;

            pathBrush->GetPoint(&pt1, i);
            pathBrush->GetPoint(&pt2, j);

            if(pt1.X != pt2.X || pt1.Y != pt2.Y)
            {
                // Transform points if they have not been flattened,
                // since OutputSpan gets span data as Device units and 
                // the BLTransform must be in the same coordinate space.
                if (pathBrush->FlattenPoints.GetCount() == 0)
                {
                    WorldToDevice.Transform(&pt1);
                    WorldToDevice.Transform(&pt2);
                }

                // Round points to nearest 1/16 of a pixel, since
                // this is the rasterizer resolution.  This eliminates
                // precision errors that can affect bilinear transforms.
                pt1.X = FIX4TOREAL(GpRealToFix4(pt1.X));
                pt1.Y = FIX4TOREAL(GpRealToFix4(pt1.Y));
                pt2.X = FIX4TOREAL(GpRealToFix4(pt2.X));
                pt2.Y = FIX4TOREAL(GpRealToFix4(pt2.Y));
    
                points[1] = pt1;
                points[3] = pt2;

                if (inflation > 1.0f)
                {
                    // Create a quadralateral extension of the gradient away 
                    // from the outer edge, and set the fixed value to 1.0, so
                    // this entire quadralateral will be filled with the edge
                    // color.  This is useful in some printing cases.
                    points[0].X = pt0.X + inflation*(pt1.X - pt0.X);
                    points[0].Y = pt0.Y + inflation*(pt1.Y - pt0.Y);
                    points[2].X = pt0.X + inflation*(pt2.X - pt0.X);
                    points[2].Y = pt0.Y + inflation*(pt2.Y - pt0.Y);

                    GpPointF centerPoints[4];
                    GpRectF centerRect(0, 0, 1, 1);

                    centerPoints[0] = points[0];
                    centerPoints[1] = pt1;
                    centerPoints[2] = points[2];
                    centerPoints[3] = pt2;
                    
                    BLTransforms[infCount+i].SetBilinearTransform(centerRect, &centerPoints[0], 4, 1.0f);
                }

                if(xScale == 0 && yScale == 0)
                {
                    points[0] = pt0;
                    points[2] = pt0;
                }
                else
                {
                    // Set up an outer quadralateral for the gradient, plus an
                    // inner triangle for the single center gradient color.
                    points[0].X = pt0.X + xScale*(pt1.X - pt0.X);
                    points[0].Y = pt0.Y + yScale*(pt1.Y - pt0.Y);
                    points[2].X = pt0.X + xScale*(pt2.X - pt0.X);
                    points[2].Y = pt0.Y + yScale*(pt2.Y - pt0.Y);

                    GpPointF centerPoints[4];
                    GpRectF centerRect(0, 0, 1, 1);

                    centerPoints[0] = pt0;
                    centerPoints[1] = points[0];
                    centerPoints[2] = pt0;
                    centerPoints[3] = points[2];
                    // Set the fixed value to use for the inner triangular 
                    // to 0, so that the inner gradient color will be used to
                    // fill this region.
                    BLTransforms[blCount+i].SetBilinearTransform(centerRect, &centerPoints[0], 4, 0.0f);
                }

                BLTransforms[i].SetBilinearTransform(rect, &points[0], 4);
            }
        }
        SetValid(TRUE);
    }
    else
        SetValid(FALSE);
}

VOID
DpOutputOneDPathGradientSpan::SetupPathGradientOneDData(
    BOOL gammaCorrect
)
{
    REAL u, u0, du;

    u0 = 0;
    du = 1.0f/OneDDataMultiplier;
    ARGB* buffer = OneDData;

    ASSERT(buffer);
    if(!buffer)
        return;

    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (Brush);

    GpColor c0, c1;
    pathBrush->GetCenterColor(&c0);
    pathBrush->GetSurroundColor(&c1, 0);
    
    GpFColor128 color[2];
    
    GammaLinearizeAndPremultiply(
        c0.GetValue(),
        gammaCorrect, 
        &color[0]
    );
    
    GammaLinearizeAndPremultiply(
        c1.GetValue(),
        gammaCorrect, 
        &color[1]
    );

    for(INT i = 0; i < OneDDataCount; i++, buffer++)
    {       
        u = u0;
        REAL w = u;

        GpFColor128 colorOut;

        if(!(pathBrush->HasPresetColors() &&
            pathBrush->DeviceBrush.PresetColors &&
            pathBrush->DeviceBrush.BlendPositions[0] &&
            pathBrush->DeviceBrush.BlendCounts[0] > 1))
        {
            w = ::adjustValue(
                w,
                pathBrush->DeviceBrush.BlendCounts[0],
                pathBrush->DeviceBrush.Falloffs[0],
                pathBrush->DeviceBrush.BlendFactors[0],
                pathBrush->DeviceBrush.BlendPositions[0]
            );

            colorOut.a = color[0].a + w*(color[1].a - color[0].a);
            colorOut.r = color[0].r + w*(color[1].r - color[0].r);
            colorOut.g = color[0].g + w*(color[1].g - color[0].g);
            colorOut.b = color[0].b + w*(color[1].b - color[0].b);
        }
        else
        {
            interpolatePresetColors(
                &colorOut,
                w,
                pathBrush->DeviceBrush.BlendCounts[0],
                pathBrush->DeviceBrush.PresetColors,
                pathBrush->DeviceBrush.BlendPositions[0],
                gammaCorrect
            );
        }
        
        if( (REALABS(colorOut.a) >= REAL_EPSILON) || 
            (CompositingMode == CompositingModeSourceCopy) )
        {
            GpColorConverter colorConv;

            // Make sure the colorOut is properly premultiplied.
            
            CLAMP_COLOR_CHANNEL(colorOut.a, 255.0f)
            CLAMP_COLOR_CHANNEL(colorOut.r, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.g, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.b, colorOut.a);
            
            if(gammaCorrect)
            {
                colorConv.argb = GammaUnlinearizePremultiplied128(colorOut);
            }
            else
            {
                colorConv.Channel.a = static_cast<BYTE>(GpRound(colorOut.a));
                colorConv.Channel.r = static_cast<BYTE>(GpRound(colorOut.r));
                colorConv.Channel.g = static_cast<BYTE>(GpRound(colorOut.g));
                colorConv.Channel.b = static_cast<BYTE>(GpRound(colorOut.b));
            }
            
            // Clamp to the alpha channel for the premultiplied alpha blender.
            
            *buffer = colorConv.argb;
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

        u0 += du;
    }
}

GpStatus
DpOutputOneDPathGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    FPUStateSaver::AssertMode();
    
    if(!IsValid())
    {
        return Ok;
    }

    INT     width  = xMax - xMin;
    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpMemset(buffer, 0, width*sizeof(ARGB));

    REAL* u = (REAL*) GpMalloc(2*width*sizeof(REAL));
    REAL* v = u + width;

    if(u == NULL)
    {
        GpFree(u);

        return OutOfMemory;
    }

    for(INT i = 0; i < Count; i++)
    {
        INT pairCount;
        INT xSpans[4];

        pairCount = BLTransforms[i].GetSourceParameterArrays(
                    u, v, &xSpans[0], y, xMin, xMax);
        if(pairCount > 0)
        {
            REAL* u1 = u;

            for(INT k = 0; k < pairCount; k++)
            {
                ARGB* buffer1 = buffer + xSpans[2*k] - xMin;
                INT width = xSpans[2*k + 1] - xSpans[2*k];                
                for(INT j = 0; j < width; j++)
                {
                    REAL u2 = *u1;
                    if(u2 < 0)
                        u2 = 0;
                    *buffer1++ = OneDData[GpRound(OneDDataMultiplier*u2)];
                    u1++;
                }
                u1 = u + width;
            }
        }
    }

    GpFree(u);

    return Ok;
}

#undef CLAMP_COLOR_CHANNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\httables.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   HtTables.cpp
*
* Abstract:
*
*   Tables for doing halftoning, using Daniel Chou's supercell technique.
*   The tables and comments are DChou's.
*
* Created:
*
*   10/29/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

GDIP_LOGPALETTE256 HTColorPalette = {
    0x300, 256,
  { { 0x00, 0x00, 0x00, 0 },                //      0   1st 8 VGA colors
    { 0x80, 0x00, 0x00, 0 },                //      1
    { 0x00, 0x80, 0x00, 0 },                //      2
    { 0x80, 0x80, 0x00, 0 },                //      3
    { 0x00, 0x00, 0x80, 0 },                //      4
    { 0x80, 0x00, 0x80, 0 },                //      5
    { 0x00, 0x80, 0x80, 0 },                //      6
    { 0xC0, 0xC0, 0xC0, 0 },                //      7

    { 0xC0, 0xDC, 0xC0, 0 },                //      8    4 configurable colors
    { 0xD4, 0xD0, 0xC8, 0 },                //      9    
    { 0xFF, 0xFB, 0xF0, 0 },                //     10
    { 0x3A, 0x6E, 0xA5, 0 },                //     11

    { 0x80, 0x80, 0x80, 0 },                //     12   Last 8 VGA colors
    { 0xFF, 0x00, 0x00, 0 },                //     13
    { 0x00, 0xFF, 0x00, 0 },                //     14
    { 0xFF, 0xFF, 0x00, 0 },                //     15
    { 0x00, 0x00, 0xFF, 0 },                //     16
    { 0xFF, 0x00, 0xFF, 0 },                //     17
    { 0x00, 0xFF, 0xFF, 0 },                //     18
    { 0xFF, 0xFF, 0xFF, 0 },                //     19

    { 0x00, 0x00, 0x00, 0 },                //     20   20 unused entries
    { 0x00, 0x00, 0x00, 0 },                //     21
    { 0x00, 0x00, 0x00, 0 },                //     22
    { 0x00, 0x00, 0x00, 0 },                //     23
    { 0x00, 0x00, 0x00, 0 },                //     24
    { 0x00, 0x00, 0x00, 0 },                //     25
    { 0x00, 0x00, 0x00, 0 },                //     26
    { 0x00, 0x00, 0x00, 0 },                //     27
    { 0x00, 0x00, 0x00, 0 },                //     28
    { 0x00, 0x00, 0x00, 0 },                //     29
    { 0x00, 0x00, 0x00, 0 },                //     30
    { 0x00, 0x00, 0x00, 0 },                //     31
    { 0x00, 0x00, 0x00, 0 },                //     32
    { 0x00, 0x00, 0x00, 0 },                //     33
    { 0x00, 0x00, 0x00, 0 },                //     34
    { 0x00, 0x00, 0x00, 0 },                //     35
    { 0x00, 0x00, 0x00, 0 },                //     36
    { 0x00, 0x00, 0x00, 0 },                //     37
    { 0x00, 0x00, 0x00, 0 },                //     38
    { 0x00, 0x00, 0x00, 0 },                //     39


    { 0x00, 0x00, 0x00, PC_NOCOLLAPSE },    //     40    6^3 palette
    { 0x00, 0x00, 0x33, PC_NOCOLLAPSE },    //     41
    { 0x00, 0x00, 0x66, PC_NOCOLLAPSE },    //     42
    { 0x00, 0x00, 0x99, PC_NOCOLLAPSE },    //     43
    { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE },    //     44
    { 0x00, 0x00, 0xFF, PC_NOCOLLAPSE },    //     45
    { 0x00, 0x33, 0x00, PC_NOCOLLAPSE },    //     46
    { 0x00, 0x33, 0x33, PC_NOCOLLAPSE },    //     47
    { 0x00, 0x33, 0x66, PC_NOCOLLAPSE },    //     48
    { 0x00, 0x33, 0x99, PC_NOCOLLAPSE },    //     49
    { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE },    //     50
    { 0x00, 0x33, 0xFF, PC_NOCOLLAPSE },    //     51
    { 0x00, 0x66, 0x00, PC_NOCOLLAPSE },    //     52
    { 0x00, 0x66, 0x33, PC_NOCOLLAPSE },    //     53
    { 0x00, 0x66, 0x66, PC_NOCOLLAPSE },    //     54
    { 0x00, 0x66, 0x99, PC_NOCOLLAPSE },    //     55
    { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE },    //     56
    { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE },    //     57
    { 0x00, 0x99, 0x00, PC_NOCOLLAPSE },    //     58
    { 0x00, 0x99, 0x33, PC_NOCOLLAPSE },    //     59
    { 0x00, 0x99, 0x66, PC_NOCOLLAPSE },    //     60
    { 0x00, 0x99, 0x99, PC_NOCOLLAPSE },    //     61
    { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE },    //     62
    { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE },    //     63
    { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE },    //     64
    { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE },    //     65
    { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE },    //     66
    { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE },    //     67
    { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE },    //     68
    { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE },    //     69
    { 0x00, 0xFF, 0x00, PC_NOCOLLAPSE },    //     70
    { 0x00, 0xFF, 0x33, PC_NOCOLLAPSE },    //     71
    { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE },    //     72
    { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE },    //     73
    { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE },    //     74
    { 0x00, 0xFF, 0xFF, PC_NOCOLLAPSE },    //     75
    { 0x33, 0x00, 0x00, PC_NOCOLLAPSE },    //     76
    { 0x33, 0x00, 0x33, PC_NOCOLLAPSE },    //     77
    { 0x33, 0x00, 0x66, PC_NOCOLLAPSE },    //     78
    { 0x33, 0x00, 0x99, PC_NOCOLLAPSE },    //     79
    { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE },    //     80
    { 0x33, 0x00, 0xFF, PC_NOCOLLAPSE },    //     81
    { 0x33, 0x33, 0x00, PC_NOCOLLAPSE },    //     82
    { 0x33, 0x33, 0x33, PC_NOCOLLAPSE },    //     83
    { 0x33, 0x33, 0x66, PC_NOCOLLAPSE },    //     84
    { 0x33, 0x33, 0x99, PC_NOCOLLAPSE },    //     85
    { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE },    //     86
    { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE },    //     87
    { 0x33, 0x66, 0x00, PC_NOCOLLAPSE },    //     88
    { 0x33, 0x66, 0x33, PC_NOCOLLAPSE },    //     89
    { 0x33, 0x66, 0x66, PC_NOCOLLAPSE },    //     90
    { 0x33, 0x66, 0x99, PC_NOCOLLAPSE },    //     91
    { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE },    //     92
    { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE },    //     93
    { 0x33, 0x99, 0x00, PC_NOCOLLAPSE },    //     94
    { 0x33, 0x99, 0x33, PC_NOCOLLAPSE },    //     95
    { 0x33, 0x99, 0x66, PC_NOCOLLAPSE },    //     96
    { 0x33, 0x99, 0x99, PC_NOCOLLAPSE },    //     97
    { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE },    //     98
    { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE },    //     99
    { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE },    //    100
    { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE },    //    101
    { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE },    //    102
    { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE },    //    103
    { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    104
    { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    105
    { 0x33, 0xFF, 0x00, PC_NOCOLLAPSE },    //    106
    { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE },    //    107
    { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE },    //    108
    { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE },    //    109
    { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    110
    { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    111
    { 0x66, 0x00, 0x00, PC_NOCOLLAPSE },    //    112
    { 0x66, 0x00, 0x33, PC_NOCOLLAPSE },    //    113
    { 0x66, 0x00, 0x66, PC_NOCOLLAPSE },    //    114
    { 0x66, 0x00, 0x99, PC_NOCOLLAPSE },    //    115
    { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE },    //    116
    { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE },    //    117
    { 0x66, 0x33, 0x00, PC_NOCOLLAPSE },    //    118
    { 0x66, 0x33, 0x33, PC_NOCOLLAPSE },    //    119
    { 0x66, 0x33, 0x66, PC_NOCOLLAPSE },    //    120
    { 0x66, 0x33, 0x99, PC_NOCOLLAPSE },    //    121
    { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE },    //    122
    { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE },    //    123
    { 0x66, 0x66, 0x00, PC_NOCOLLAPSE },    //    124
    { 0x66, 0x66, 0x33, PC_NOCOLLAPSE },    //    125
    { 0x66, 0x66, 0x66, PC_NOCOLLAPSE },    //    126
    { 0x66, 0x66, 0x99, PC_NOCOLLAPSE },    //    127
    { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE },    //    128
    { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE },    //    129
    { 0x66, 0x99, 0x00, PC_NOCOLLAPSE },    //    130
    { 0x66, 0x99, 0x33, PC_NOCOLLAPSE },    //    131
    { 0x66, 0x99, 0x66, PC_NOCOLLAPSE },    //    132
    { 0x66, 0x99, 0x99, PC_NOCOLLAPSE },    //    133
    { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE },    //    134
    { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE },    //    135
    { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE },    //    136
    { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE },    //    137
    { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE },    //    138
    { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE },    //    139
    { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    140
    { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    141
    { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE },    //    142
    { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE },    //    143
    { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE },    //    144
    { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE },    //    145
    { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    146
    { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    147
    { 0x99, 0x00, 0x00, PC_NOCOLLAPSE },    //    148
    { 0x99, 0x00, 0x33, PC_NOCOLLAPSE },    //    149
    { 0x99, 0x00, 0x66, PC_NOCOLLAPSE },    //    150
    { 0x99, 0x00, 0x99, PC_NOCOLLAPSE },    //    151
    { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE },    //    152
    { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE },    //    153
    { 0x99, 0x33, 0x00, PC_NOCOLLAPSE },    //    154
    { 0x99, 0x33, 0x33, PC_NOCOLLAPSE },    //    155
    { 0x99, 0x33, 0x66, PC_NOCOLLAPSE },    //    156
    { 0x99, 0x33, 0x99, PC_NOCOLLAPSE },    //    157
    { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE },    //    158
    { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE },    //    159
    { 0x99, 0x66, 0x00, PC_NOCOLLAPSE },    //    160
    { 0x99, 0x66, 0x33, PC_NOCOLLAPSE },    //    161
    { 0x99, 0x66, 0x66, PC_NOCOLLAPSE },    //    162
    { 0x99, 0x66, 0x99, PC_NOCOLLAPSE },    //    163
    { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE },    //    164
    { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE },    //    165
    { 0x99, 0x99, 0x00, PC_NOCOLLAPSE },    //    166
    { 0x99, 0x99, 0x33, PC_NOCOLLAPSE },    //    167
    { 0x99, 0x99, 0x66, PC_NOCOLLAPSE },    //    168
    { 0x99, 0x99, 0x99, PC_NOCOLLAPSE },    //    169
    { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE },    //    170
    { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE },    //    171
    { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE },    //    172
    { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE },    //    173
    { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE },    //    174
    { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE },    //    175
    { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    176
    { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    177
    { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE },    //    178
    { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE },    //    179
    { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE },    //    180
    { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE },    //    181
    { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    182
    { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    183
    { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE },    //    184
    { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE },    //    185
    { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE },    //    186
    { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE },    //    187
    { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE },    //    188
    { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE },    //    189
    { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE },    //    190
    { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE },    //    191
    { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE },    //    192
    { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE },    //    193
    { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE },    //    194
    { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE },    //    195
    { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE },    //    196
    { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE },    //    197
    { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE },    //    198
    { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE },    //    199
    { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE },    //    200
    { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE },    //    201
    { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE },    //    202
    { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE },    //    203
    { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE },    //    204
    { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE },    //    205
    { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE },    //    206
    { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE },    //    207
    { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE },    //    208
    { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE },    //    209
    { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE },    //    210
    { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE },    //    211
    { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    212
    { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    213
    { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE },    //    214
    { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE },    //    215
    { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE },    //    216
    { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE },    //    217
    { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    218
    { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    219
    { 0xFF, 0x00, 0x00, PC_NOCOLLAPSE },    //    220
    { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE },    //    221
    { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE },    //    222
    { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE },    //    223
    { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE },    //    224
    { 0xFF, 0x00, 0xFF, PC_NOCOLLAPSE },    //    225
    { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE },    //    226
    { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE },    //    227
    { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE },    //    228
    { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE },    //    229
    { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE },    //    230
    { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE },    //    231
    { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE },    //    232
    { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE },    //    233
    { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE },    //    234
    { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE },    //    235
    { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE },    //    236
    { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE },    //    237
    { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE },    //    238
    { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE },    //    239
    { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE },    //    240
    { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE },    //    241
    { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE },    //    242
    { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE },    //    243
    { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE },    //    244
    { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE },    //    245
    { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE },    //    246
    { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE },    //    247
    { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    248
    { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    249
    { 0xFF, 0xFF, 0x00, PC_NOCOLLAPSE },    //    250
    { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE },    //    251
    { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE },    //    252
    { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE },    //    253
    { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    254
    { 0xFF, 0xFF, 0xFF, PC_NOCOLLAPSE }, }  //    255
};

// Unfortunately, the Win9x Halftone palette is missing 4 of the 216 halftoning
// colors, namely:
//          0x00, 0x33, 0xFF
//          0x00, 0xFF, 0x33
//          0x33, 0x00, 0xFF
//          0x33, 0xFF, 0x00

GDIP_LOGPALETTE256 Win9xHalftonePalette = {
  0x300, 256,
  {
    // The first 10 system colors
    { 0x00, 0x00, 0x00, 0x00,          },   //      0  Sys Black, gray 0
    { 0x80, 0x00, 0x00, 0x00,          },   //      1  Sys Dk Red
    { 0x00, 0x80, 0x00, 0x00,          },   //      2  Sys Dk Green
    { 0x80, 0x80, 0x00, 0x00,          },   //      3  Sys Dk Yellow
    { 0x00, 0x00, 0x80, 0x00,          },   //      4  Sys Dk Blue
    { 0x80, 0x00, 0x80, 0x00,          },   //      5  Sys Dk Violet
    { 0x00, 0x80, 0x80, 0x00,          },   //      6  Sys Dk Cyan
    { 0xC0, 0xC0, 0xC0, 0x00,          },   //      7  Sys Lt Gray, gray 192

    // The following two system entries are modified for the desktop.
    { 0xC0, 0xDC, 0xC0, 0x00,          },   //      8  Sys 8 - VARIABLE
    { 0xA6, 0xCA, 0xF0, 0x00,          },   //      9  Sys 9 - VARIABLE

    // Gray scale entries (dark)
    { 0x04, 0x04, 0x04, PC_NOCOLLAPSE, },   //     10  Gray  4
    { 0x08, 0x08, 0x08, PC_NOCOLLAPSE, },   //     11  Gray  8
    { 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE, },   //     12  Gray 12
    { 0x11, 0x11, 0x11, PC_NOCOLLAPSE, },   //     13  Gray 17
    { 0x16, 0x16, 0x16, PC_NOCOLLAPSE, },   //     14  Gray 22
    { 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE, },   //     15  Gray 28
    { 0x22, 0x22, 0x22, PC_NOCOLLAPSE, },   //     16  Gray 34
    { 0x29, 0x29, 0x29, PC_NOCOLLAPSE, },   //     17  Gray 41
    { 0x55, 0x55, 0x55, PC_NOCOLLAPSE, },   //     18  Gray 85
    { 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE, },   //     19  Gray 77
    { 0x42, 0x42, 0x42, PC_NOCOLLAPSE, },   //     20  Gray 66
    { 0x39, 0x39, 0x39, PC_NOCOLLAPSE, },   //     21  Gray 57
    
    // Custom app/OS entries
    { 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE, },   //     22  Salmon
    { 0xFF, 0x50, 0x50, PC_NOCOLLAPSE, },   //     23  Red
    { 0xD6, 0x00, 0x93, PC_NOCOLLAPSE, },   //     24  Purple
    { 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE, },   //     25  Lt Blue
    { 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE, },   //     26  Win95 Tan
    { 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE, },   //     27  Win95 Tan
    { 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE, },   //     28  Win95 Grayish

    // Halftone palette entries
    { 0x33, 0x00, 0x00, PC_NOCOLLAPSE, },   //     29  
    { 0x66, 0x00, 0x00, PC_NOCOLLAPSE, },   //     30
    { 0x99, 0x00, 0x00, PC_NOCOLLAPSE, },   //     31
    { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE, },   //     32
    { 0x00, 0x33, 0x00, PC_NOCOLLAPSE, },   //     33
    { 0x33, 0x33, 0x00, PC_NOCOLLAPSE, },   //     34
    { 0x66, 0x33, 0x00, PC_NOCOLLAPSE, },   //     35
    { 0x99, 0x33, 0x00, PC_NOCOLLAPSE, },   //     36
    { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE, },   //     37
    { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE, },   //     38
    { 0x00, 0x66, 0x00, PC_NOCOLLAPSE, },   //     39
    { 0x33, 0x66, 0x00, PC_NOCOLLAPSE, },   //     40
    { 0x66, 0x66, 0x00, PC_NOCOLLAPSE, },   //     41
    { 0x99, 0x66, 0x00, PC_NOCOLLAPSE, },   //     42
    { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE, },   //     43
    { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE, },   //     44
    { 0x00, 0x99, 0x00, PC_NOCOLLAPSE, },   //     45
    { 0x33, 0x99, 0x00, PC_NOCOLLAPSE, },   //     46
    { 0x66, 0x99, 0x00, PC_NOCOLLAPSE, },   //     47
    { 0x99, 0x99, 0x00, PC_NOCOLLAPSE, },   //     48
    { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE, },   //     49
    { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE, },   //     50
    { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     51
    { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     52
    { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     53
    { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     54
    { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     55
    { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     56
    { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     57
    { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     58
    { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     59
    { 0x00, 0x00, 0x33, PC_NOCOLLAPSE, },   //     60
    { 0x33, 0x00, 0x33, PC_NOCOLLAPSE, },   //     61
    { 0x66, 0x00, 0x33, PC_NOCOLLAPSE, },   //     62
    { 0x99, 0x00, 0x33, PC_NOCOLLAPSE, },   //     63
    { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE, },   //     64
    { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE, },   //     65
    { 0x00, 0x33, 0x33, PC_NOCOLLAPSE, },   //     66
    { 0x33, 0x33, 0x33, PC_NOCOLLAPSE, },   //     67  Gray 51
    { 0x66, 0x33, 0x33, PC_NOCOLLAPSE, },   //     68
    { 0x99, 0x33, 0x33, PC_NOCOLLAPSE, },   //     69
    { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE, },   //     70
    { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE, },   //     71
    { 0x00, 0x66, 0x33, PC_NOCOLLAPSE, },   //     72
    { 0x33, 0x66, 0x33, PC_NOCOLLAPSE, },   //     73
    { 0x66, 0x66, 0x33, PC_NOCOLLAPSE, },   //     74
    { 0x99, 0x66, 0x33, PC_NOCOLLAPSE, },   //     75
    { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE, },   //     76
    { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE, },   //     77
    { 0x00, 0x99, 0x33, PC_NOCOLLAPSE, },   //     78
    { 0x33, 0x99, 0x33, PC_NOCOLLAPSE, },   //     79
    { 0x66, 0x99, 0x33, PC_NOCOLLAPSE, },   //     80
    { 0x99, 0x99, 0x33, PC_NOCOLLAPSE, },   //     81
    { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE, },   //     82
    { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE, },   //     83
    { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     84
    { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     85
    { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     86
    { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     87
    { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     88
    { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     89
    { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     90
    { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     91
    { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     92
    { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     93
    { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     94
    { 0x00, 0x00, 0x66, PC_NOCOLLAPSE, },   //     95
    { 0x33, 0x00, 0x66, PC_NOCOLLAPSE, },   //     96
    { 0x66, 0x00, 0x66, PC_NOCOLLAPSE, },   //     97
    { 0x99, 0x00, 0x66, PC_NOCOLLAPSE, },   //     98
    { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE, },   //     99
    { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE, },   //    100
    { 0x00, 0x33, 0x66, PC_NOCOLLAPSE, },   //    101
    { 0x33, 0x33, 0x66, PC_NOCOLLAPSE, },   //    102
    { 0x66, 0x33, 0x66, PC_NOCOLLAPSE, },   //    103
    { 0x99, 0x33, 0x66, PC_NOCOLLAPSE, },   //    104
    { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE, },   //    105
    { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE, },   //    106
    { 0x00, 0x66, 0x66, PC_NOCOLLAPSE, },   //    107
    { 0x33, 0x66, 0x66, PC_NOCOLLAPSE, },   //    108
    { 0x66, 0x66, 0x66, PC_NOCOLLAPSE, },   //    109  Gray 102
    { 0x99, 0x66, 0x66, PC_NOCOLLAPSE, },   //    110
    { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE, },   //    111
    { 0x00, 0x99, 0x66, PC_NOCOLLAPSE, },   //    112
    { 0x33, 0x99, 0x66, PC_NOCOLLAPSE, },   //    113
    { 0x66, 0x99, 0x66, PC_NOCOLLAPSE, },   //    114
    { 0x99, 0x99, 0x66, PC_NOCOLLAPSE, },   //    115
    { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE, },   //    116
    { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE, },   //    117
    { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    118
    { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    119
    { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    120
    { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    121
    { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    122
    { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    123
    { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    124
    { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    125
    { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    126
    { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    127
    { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    128
    { 0x00, 0x99, 0x99, PC_NOCOLLAPSE, },   //    129
    { 0x99, 0x33, 0x99, PC_NOCOLLAPSE, },   //    130
    { 0x99, 0x00, 0x99, PC_NOCOLLAPSE, },   //    131
    { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE, },   //    132
    { 0x00, 0x00, 0x99, PC_NOCOLLAPSE, },   //    133
    { 0x33, 0x33, 0x99, PC_NOCOLLAPSE, },   //    134
    { 0x66, 0x00, 0x99, PC_NOCOLLAPSE, },   //    135
    { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE, },   //    136
    { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE, },   //    137
    { 0x00, 0x66, 0x99, PC_NOCOLLAPSE, },   //    138
    { 0x33, 0x66, 0x99, PC_NOCOLLAPSE, },   //    139
    { 0x66, 0x33, 0x99, PC_NOCOLLAPSE, },   //    140
    { 0x99, 0x66, 0x99, PC_NOCOLLAPSE, },   //    141
    { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE, },   //    142
    { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE, },   //    143
    { 0x33, 0x99, 0x99, PC_NOCOLLAPSE, },   //    144
    { 0x66, 0x99, 0x99, PC_NOCOLLAPSE, },   //    145
    { 0x99, 0x99, 0x99, PC_NOCOLLAPSE, },   //    146  Gray 153
    { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE, },   //    147
    { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE, },   //    148
    { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    149
    { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    150
    { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    151
    { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    152
    { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    153
    { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    154
    { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    155
    { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    156
    { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    157
    { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    158
    { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    159
    { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    160
    { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    161
    { 0x33, 0x00, 0x99, PC_NOCOLLAPSE, },   //    162
    { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    163
    { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    164
    { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    165
    { 0x00, 0x33, 0x99, PC_NOCOLLAPSE, },   //    166
    { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    167
    { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    168
    { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    169
    { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    170
    { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    171
    { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    172
    { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    173
    { 0x66, 0x66, 0x99, PC_NOCOLLAPSE, },   //    174
    { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    175
    { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    176
    { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE, },   //    177
    { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    178
    { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    179
    { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    180
    { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    181
    { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    182
    { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    183
    { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    184
    { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    185
    { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    186
    { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    187
    { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    188  Gray 204
    { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    189
    { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    190
    { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    191
    { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    192
    { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    193
    { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    194
    { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    195
    { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    196
    { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    197
    { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    198
    { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    199
    { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    200
    { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    201
    { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    202
    { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    203
    { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    204
    { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    205
    { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    206
    { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    207
    { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    208
    { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    209
    { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    210
    { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    211
    { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    212
    { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    213
    { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    214
    { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    215
    { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    216
    { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    217
    { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    218
    { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    219
    { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    220
    { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    221
    { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    222
    { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    223
    { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    224
    { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    225
    { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    226
    { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE, },   //    227
    { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    228
    { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    229
    { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    230
    { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    231
    { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    232
    
    // App custom colors
    { 0xA5, 0x00, 0x21, PC_NOCOLLAPSE, },   //    233  Brick red

    // Gray palette
    { 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE, },   //    234  Gray 95
    { 0x77, 0x77, 0x77, PC_NOCOLLAPSE, },   //    235  Gray 119
    { 0x86, 0x86, 0x86, PC_NOCOLLAPSE, },   //    236  Gray 134
    { 0x96, 0x96, 0x96, PC_NOCOLLAPSE, },   //    237  Gray 150
    { 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE, },   //    238  Gray 203
    { 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE, },   //    239  Gray 178
    { 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE, },   //    240  Gray 215
    { 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE, },   //    241  Gray 221
    { 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE, },   //    242  Gray 227
    { 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE, },   //    243  Gray 234
    { 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE, },   //    244  Gray 241
    { 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE, },   //    245  Gray 248

    // The last 10 system colors

    // The following two system entries are modified for the desktop.
    { 0xFF, 0xFB, 0xF0, 0x00,          },   //    246  Sys 246 - VARIABLE
    { 0xA0, 0xA0, 0xA4, 0x00,          },   //    247  Sys 247 - VARIABLE

    { 0x80, 0x80, 0x80, 0x00,          },   //    248  Sys Lt Gray, gray 128
    { 0xFF, 0x00, 0x00, 0x00,          },   //    249  Sys Red
    { 0x00, 0xFF, 0x00, 0x00,          },   //    250  Sys Green
    { 0xFF, 0xFF, 0x00, 0x00,          },   //    251  Sys Yellow
    { 0x00, 0x00, 0xFF, 0x00,          },   //    252  Sys Blue
    { 0xFF, 0x00, 0xFF, 0x00,          },   //    253  Sys Violet
    { 0x00, 0xFF, 0xFF, 0x00,          },   //    254  Sys Cyan
    { 0xFF, 0xFF, 0xFF, 0x00,          },   //    255  Sys White, gray 255
  }
};

// The RGB values must be linearized before they are halftoned.

// The first gamma table is for 216-color halftoning.
// v = ((x/255)^0.90) * 255
const BYTE GammaTable216[256] = {
    0x00, 0x02, 0x03, 0x05, 0x06, 0x07, 0x09, 0x0A, 
    0x0B, 0x0D, 0x0E, 0x0F, 0x10, 0x12, 0x13, 0x14, 
    0x15, 0x16, 0x17, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 
    0x1E, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 
    0x27, 0x28, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
    0x30, 0x31, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38, 
    0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 
    0x49, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 
    0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 
    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 
    0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 
    0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
    0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7E, 0x7F, 0x80, 
    0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 
    0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
    0xA8, 0xA9, 0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 
    0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 
    0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 
    0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 
    0xC6, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 
    0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD2, 0xD3, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 
    0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 
    0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 
    0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 
    0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 
    0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 
};

// This table is designed so that for a value v,
// GammaTable16[InverseGammaTable16[v]] >= v.
// This is used for doing SrcOver alpha blending
// so that the dest that has already been gamma
// corrected can be inverse gamma corrected before
// we blend it and re-gamma correct it. 
const BYTE InverseGammaTable216[256] = {
    0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
    0x06, 0x06, 0x07, 0x08, 0x09, 0x09, 0x0A, 0x0B, 
    0x0C, 0x0D, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
    0x13, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 
    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 
    0x21, 0x22, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2D, 0x2E, 
    0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,
    0x3F, 0x40, 0x41, 0x41, 0x42, 0x43, 0x44, 0x45, 
    0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 
    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 
    0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 
    0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
    0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x76, 
    0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 
    0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,
    0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 
    0x8F, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 
    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 
    0xB1, 0xB2, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9,
    0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC2, 
    0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 
    0xCB, 0xCC, 0xCD, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDB, 0xDC, 
    0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 
    0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
    0xEE, 0xEF, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
    0xF7, 0xF8, 0xF9, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 
};

// The next gamma table is for 16-color halftoning.
// This is a hand-tuned table.  It started out as a table whose values 
// were calculated by:
//      v = ((x/255)^1.325) * 255
// But then some entries were removed by hand so that more black could 
// be added to the top of the table and more white could be added to the
// bottom of the table.  
const BYTE GammaTable16[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 
    0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 
    0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x17, 0x18, 0x19, 0x1A, 0x1A, 0x1B,
    0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x21,
    0x22, 0x23, 0x24, 0x25, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    0x30, 0x31, 0x32, 0x32, 0x33, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3B, 0x3C, 0x3D,
    0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
    0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D,
    0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65,
    0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
    0x80, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x92, 
    0x93, 0x94, 0x95, 0x96, 0x97, 0x99, 0x9A, 0x9B, 
    0x9C, 0x9D, 0x9E, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 
    0xA5, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAD, 0xAE, 
    0xAF, 0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 
    0xB9, 0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 
    0xC3, 0xC4, 0xC5, 0xC6, 0xC8, 0xC9, 0xCA, 0xCB, 
    0xCD, 0xCE, 0xCF, 0xD0, 0xD2, 0xD3, 0xD4, 0xD5, 
    0xD7, 0xD8, 0xD9, 0xDB, 0xDC, 0xDD, 0xDE, 0xE0, 
    0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 
    0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
};

// This table is designed so that for a value v,
// GammaTable16[InverseGammaTable16[v]] >= v.
// This is used for doing SrcOver alpha blending
// so that the dest that has already been gamma
// corrected can be inverse gamma corrected before
// we blend it and re-gamma correct it. 
const BYTE InverseGammaTable16[256] = {
    0x00, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 
    0x16, 0x18, 0x1A, 0x1C, 0x1D, 0x1E, 0x1F, 0x21, 
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 
    0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x33, 0x34, 
    0x35, 0x36, 0x38, 0x39, 0x3A, 0x3B, 0x3D, 0x3E, 
    0x3F, 0x40, 0x41, 0x42, 0x44, 0x45, 0x46, 0x47, 
    0x48, 0x49, 0x4A, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 
    0x51, 0x52, 0x53, 0x54, 0x56, 0x57, 0x58, 0x59, 
    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 
    0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 
    0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
    0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
    0x82, 0x83, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
    0x98, 0x99, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 
    0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 
    0xA6, 0xA7, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 
    0xAD, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 
    0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xB9, 
    0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 
    0xC1, 0xC2, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
    0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCC, 0xCD, 
    0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9, 0xDA, 
    0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE0, 
    0xE1, 0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
    0xE7, 0xE8, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 
    0xEB, 0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 
    0xEF, 0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 
    0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xFF, 
};

// Standard 8x8 halftoning matrix for 216 colors.
// Contains values between 0x00 and 0x32 (inclusive).

const BYTE HT_216_8x8[8*8] = {
    0x00, 0x19, 0x06, 0x20, 0x02, 0x1B, 0x08, 0x21, 
    0x26, 0x0D, 0x2C, 0x13, 0x28, 0x0E, 0x2E, 0x15,
    0x0A, 0x23, 0x03, 0x1D, 0x0B, 0x25, 0x05, 0x1E, 
    0x30, 0x16, 0x29, 0x10, 0x31, 0x18, 0x2B, 0x11,
    0x02, 0x1C, 0x09, 0x22, 0x01, 0x1A, 0x07, 0x21, 
    0x28, 0x0F, 0x2F, 0x15, 0x27, 0x0D, 0x2D, 0x14,
    0x0C, 0x25, 0x06, 0x1F, 0x0A, 0x24, 0x04, 0x1D, 
    0x32, 0x19, 0x2C, 0x12, 0x30, 0x17, 0x2A, 0x11,
};

// Daniel Chou's halftoning cells

// The first 3 cells are for halftoning to the 216 colors that contain
// all combinations of 0x00, 0x33, 0x66, 0x99, 0xCC, and 0xFF
// These cells contain values between 0x00 and 0x32 (inclusive).

const BYTE HT_SuperCell_Red216[91*91] = {
    0x21, 0x0C, 0x16, 0x31, 0x0E, 0x14, 0x23, 0x16, 0x20, 0x1A,         //  0
    0x01, 0x22, 0x13, 0x06, 0x0C, 0x1F, 0x00, 0x30, 0x0B, 0x05, 
    0x23, 0x19, 0x05, 0x29, 0x23, 0x19, 0x1E, 0x2C, 0x17, 0x2F, 
    0x0B, 0x14, 0x30, 0x0D, 0x2B, 0x1F, 0x0B, 0x05, 0x25, 0x0D, 
    0x01, 0x14, 0x31, 0x1E, 0x02, 0x2E, 0x0A, 0x21, 0x2F, 0x27, 
    0x0A, 0x2D, 0x1E, 0x29, 0x0E, 0x30, 0x06, 0x14, 0x0C, 0x04, 
    0x27, 0x15, 0x0C, 0x29, 0x14, 0x0A, 0x1C, 0x01, 0x22, 0x2C, 
    0x28, 0x1C, 0x0F, 0x2F, 0x16, 0x25, 0x30, 0x02, 0x2C, 0x16, 
    0x04, 0x08, 0x2D, 0x1B, 0x26, 0x13, 0x2A, 0x03, 0x10, 0x1B, 0x13, 
    
    0x1D, 0x2E, 0x10, 0x26, 0x1F, 0x09, 0x2C, 0x10, 0x0B, 0x2D,         //  1
    0x09, 0x31, 0x1D, 0x17, 0x26, 0x19, 0x12, 0x22, 0x1D, 0x15, 
    0x2C, 0x0D, 0x14, 0x2E, 0x00, 0x09, 0x11, 0x21, 0x09, 0x10, 
    0x23, 0x29, 0x08, 0x22, 0x19, 0x13, 0x32, 0x17, 0x2A, 0x1F, 
    0x2D, 0x22, 0x05, 0x17, 0x2A, 0x0D, 0x28, 0x04, 0x12, 0x1A, 
    0x02, 0x23, 0x12, 0x09, 0x16, 0x27, 0x1A, 0x2D, 0x21, 0x19, 
    0x2C, 0x09, 0x30, 0x19, 0x06, 0x2B, 0x11, 0x2F, 0x0B, 0x1A, 
    0x04, 0x15, 0x26, 0x01, 0x21, 0x0D, 0x1C, 0x0A, 0x26, 0x0F, 
    0x2E, 0x27, 0x15, 0x01, 0x2F, 0x0D, 0x1A, 0x21, 0x2F, 0x27, 0x02, 
    
    0x09, 0x24, 0x06, 0x1B, 0x03, 0x28, 0x19, 0x06, 0x27, 0x14,         //  2
    0x24, 0x10, 0x07, 0x2B, 0x03, 0x2F, 0x08, 0x0D, 0x2E, 0x02, 
    0x25, 0x07, 0x22, 0x1C, 0x16, 0x25, 0x30, 0x02, 0x1D, 0x2A, 
    0x18, 0x00, 0x1E, 0x11, 0x05, 0x25, 0x01, 0x1C, 0x08, 0x13, 
    0x07, 0x0E, 0x27, 0x0B, 0x1B, 0x13, 0x23, 0x18, 0x1F, 0x0D, 
    0x31, 0x1C, 0x05, 0x2E, 0x20, 0x0D, 0x08, 0x28, 0x01, 0x0E, 
    0x24, 0x03, 0x21, 0x0E, 0x1F, 0x26, 0x07, 0x17, 0x27, 0x11, 
    0x21, 0x2E, 0x09, 0x1A, 0x11, 0x06, 0x2A, 0x13, 0x20, 0x19, 
    0x0A, 0x1E, 0x0D, 0x23, 0x16, 0x04, 0x2C, 0x07, 0x0B, 0x15, 0x2C, 
    
    0x19, 0x11, 0x2B, 0x14, 0x2F, 0x0C, 0x20, 0x32, 0x1D, 0x03,         //  3
    0x1A, 0x29, 0x20, 0x0B, 0x13, 0x28, 0x23, 0x1A, 0x29, 0x10, 
    0x1B, 0x30, 0x0F, 0x06, 0x2D, 0x0C, 0x1B, 0x14, 0x25, 0x06, 
    0x0E, 0x2D, 0x16, 0x28, 0x2F, 0x0E, 0x2C, 0x10, 0x24, 0x30, 
    0x1D, 0x18, 0x2D, 0x20, 0x06, 0x32, 0x00, 0x2D, 0x09, 0x2B, 
    0x15, 0x0F, 0x2A, 0x18, 0x02, 0x24, 0x13, 0x1E, 0x17, 0x30, 
    0x13, 0x1C, 0x14, 0x2E, 0x00, 0x1B, 0x2C, 0x20, 0x03, 0x32, 
    0x07, 0x0E, 0x2A, 0x1E, 0x31, 0x23, 0x18, 0x05, 0x30, 0x00, 
    0x24, 0x12, 0x31, 0x09, 0x1F, 0x28, 0x18, 0x12, 0x1D, 0x24, 0x0F, 
    
    0x32, 0x20, 0x01, 0x23, 0x0F, 0x18, 0x00, 0x12, 0x0A, 0x2C,         //  4
    0x0D, 0x04, 0x17, 0x30, 0x1C, 0x0E, 0x05, 0x15, 0x07, 0x20, 
    0x0A, 0x17, 0x29, 0x1F, 0x12, 0x28, 0x05, 0x2B, 0x0B, 0x31, 
    0x1B, 0x21, 0x07, 0x0C, 0x1B, 0x20, 0x07, 0x29, 0x15, 0x02, 
    0x2A, 0x10, 0x01, 0x15, 0x26, 0x10, 0x1E, 0x14, 0x27, 0x05, 
    0x21, 0x08, 0x26, 0x0E, 0x1D, 0x31, 0x2A, 0x05, 0x0C, 0x26, 
    0x07, 0x2B, 0x0B, 0x24, 0x17, 0x12, 0x09, 0x0E, 0x14, 0x1D, 
    0x19, 0x24, 0x16, 0x05, 0x0B, 0x14, 0x2B, 0x0C, 0x1D, 0x15, 
    0x2D, 0x06, 0x19, 0x2A, 0x0F, 0x07, 0x23, 0x31, 0x00, 0x2A, 0x05, 
    
    0x0C, 0x16, 0x28, 0x0A, 0x1E, 0x2D, 0x29, 0x23, 0x16, 0x1F,         //  5
    0x26, 0x2D, 0x0F, 0x22, 0x02, 0x20, 0x2C, 0x24, 0x32, 0x13, 
    0x2B, 0x03, 0x0E, 0x24, 0x01, 0x18, 0x21, 0x10, 0x1F, 0x16, 
    0x03, 0x12, 0x2A, 0x24, 0x02, 0x12, 0x18, 0x1E, 0x0C, 0x22, 
    0x0A, 0x25, 0x30, 0x1D, 0x09, 0x2C, 0x07, 0x1B, 0x0F, 0x24, 
    0x17, 0x1E, 0x2F, 0x07, 0x14, 0x04, 0x10, 0x22, 0x2D, 0x1A, 
    0x10, 0x1F, 0x03, 0x29, 0x08, 0x30, 0x23, 0x27, 0x2D, 0x0A, 
    0x29, 0x00, 0x10, 0x2C, 0x26, 0x02, 0x1E, 0x26, 0x08, 0x2A, 
    0x0F, 0x1F, 0x26, 0x01, 0x15, 0x2E, 0x11, 0x0C, 0x20, 0x14, 0x1D, 
    
    0x24, 0x08, 0x1B, 0x30, 0x05, 0x13, 0x07, 0x0D, 0x30, 0x02,         //  6
    0x13, 0x1B, 0x09, 0x29, 0x14, 0x1A, 0x09, 0x11, 0x01, 0x1A, 
    0x26, 0x1D, 0x2E, 0x09, 0x1C, 0x31, 0x08, 0x2D, 0x05, 0x28, 
    0x23, 0x2F, 0x08, 0x17, 0x31, 0x25, 0x2C, 0x03, 0x2F, 0x17, 
    0x1C, 0x13, 0x04, 0x0D, 0x29, 0x16, 0x24, 0x2D, 0x03, 0x31, 
    0x0C, 0x01, 0x19, 0x23, 0x29, 0x18, 0x1F, 0x0A, 0x15, 0x02, 
    0x24, 0x32, 0x16, 0x11, 0x21, 0x1D, 0x02, 0x18, 0x05, 0x21, 
    0x12, 0x30, 0x1B, 0x20, 0x18, 0x0F, 0x2D, 0x11, 0x18, 0x22, 
    0x03, 0x16, 0x0B, 0x2C, 0x1C, 0x21, 0x03, 0x1A, 0x2D, 0x09, 0x29, 
    
    0x02, 0x2C, 0x14, 0x0D, 0x25, 0x20, 0x1A, 0x27, 0x18, 0x0B,         //  7
    0x23, 0x05, 0x31, 0x11, 0x25, 0x0D, 0x2F, 0x21, 0x29, 0x0D, 
    0x06, 0x11, 0x17, 0x2A, 0x13, 0x0C, 0x24, 0x14, 0x1A, 0x0E, 
    0x0A, 0x1A, 0x10, 0x1E, 0x06, 0x0D, 0x09, 0x21, 0x0F, 0x2A, 
    0x07, 0x2E, 0x24, 0x18, 0x1F, 0x02, 0x0B, 0x13, 0x1F, 0x15, 
    0x26, 0x2B, 0x13, 0x0B, 0x2F, 0x09, 0x27, 0x30, 0x1D, 0x2A, 
    0x0E, 0x07, 0x1B, 0x2E, 0x06, 0x15, 0x0C, 0x2F, 0x1E, 0x15, 
    0x09, 0x22, 0x0D, 0x05, 0x2F, 0x08, 0x1B, 0x04, 0x30, 0x0D, 
    0x1C, 0x2F, 0x23, 0x10, 0x06, 0x28, 0x16, 0x25, 0x05, 0x1B, 0x10, 
    
    0x18, 0x21, 0x04, 0x2A, 0x17, 0x03, 0x2C, 0x08, 0x1E, 0x2D,         //  8
    0x28, 0x15, 0x20, 0x00, 0x2C, 0x08, 0x1C, 0x05, 0x15, 0x1F, 
    0x30, 0x24, 0x02, 0x20, 0x05, 0x28, 0x1D, 0x02, 0x2A, 0x20, 
    0x2D, 0x01, 0x28, 0x22, 0x15, 0x29, 0x1A, 0x13, 0x26, 0x04, 
    0x1F, 0x16, 0x0B, 0x2C, 0x10, 0x31, 0x1B, 0x29, 0x06, 0x0A, 
    0x1A, 0x0E, 0x20, 0x03, 0x1D, 0x16, 0x00, 0x0F, 0x06, 0x13, 
    0x1F, 0x28, 0x0B, 0x25, 0x0F, 0x24, 0x2A, 0x12, 0x07, 0x24, 
    0x2E, 0x02, 0x17, 0x2A, 0x13, 0x27, 0x21, 0x13, 0x24, 0x07, 
    0x28, 0x13, 0x02, 0x19, 0x31, 0x09, 0x0E, 0x2F, 0x13, 0x23, 0x2E, 
    
    0x11, 0x31, 0x0F, 0x1D, 0x0A, 0x30, 0x0F, 0x16, 0x01, 0x12,         //  9
    0x09, 0x1C, 0x0C, 0x19, 0x22, 0x17, 0x27, 0x0F, 0x2B, 0x09, 
    0x18, 0x0E, 0x28, 0x0A, 0x2F, 0x15, 0x0F, 0x30, 0x08, 0x11, 
    0x1C, 0x14, 0x30, 0x04, 0x0F, 0x2E, 0x1F, 0x01, 0x30, 0x1A, 
    0x0D, 0x28, 0x06, 0x22, 0x04, 0x17, 0x25, 0x0F, 0x2D, 0x22, 
    0x30, 0x05, 0x27, 0x2D, 0x11, 0x25, 0x2C, 0x1A, 0x23, 0x2F, 
    0x03, 0x16, 0x2C, 0x01, 0x1A, 0x31, 0x04, 0x1C, 0x28, 0x0C, 
    0x2A, 0x1D, 0x25, 0x0B, 0x1F, 0x02, 0x0D, 0x2A, 0x19, 0x10, 
    0x1E, 0x09, 0x2B, 0x1F, 0x13, 0x25, 0x1D, 0x01, 0x2A, 0x0B, 0x06, 
    
    0x26, 0x1A, 0x07, 0x27, 0x22, 0x12, 0x28, 0x23, 0x2A, 0x1F,         // 10
    0x2F, 0x03, 0x29, 0x2F, 0x07, 0x12, 0x02, 0x31, 0x23, 0x01, 
    0x1C, 0x2D, 0x13, 0x1E, 0x19, 0x22, 0x09, 0x23, 0x17, 0x27, 
    0x0C, 0x23, 0x09, 0x19, 0x25, 0x0A, 0x15, 0x23, 0x08, 0x13, 
    0x25, 0x31, 0x13, 0x1E, 0x28, 0x0C, 0x07, 0x20, 0x00, 0x16, 
    0x10, 0x1E, 0x12, 0x19, 0x06, 0x0D, 0x1F, 0x14, 0x08, 0x27, 
    0x1C, 0x0D, 0x22, 0x1E, 0x12, 0x09, 0x20, 0x16, 0x01, 0x0F, 
    0x19, 0x12, 0x04, 0x30, 0x15, 0x2C, 0x1C, 0x0A, 0x2D, 0x00, 
    0x32, 0x17, 0x25, 0x0C, 0x04, 0x2B, 0x10, 0x1A, 0x22, 0x17, 0x1F, 
    
    0x01, 0x0B, 0x2A, 0x15, 0x00, 0x1B, 0x06, 0x0D, 0x19, 0x06,         // 11
    0x11, 0x24, 0x14, 0x0E, 0x1D, 0x2C, 0x20, 0x19, 0x0C, 0x13, 
    0x26, 0x0A, 0x03, 0x29, 0x0C, 0x00, 0x2C, 0x1A, 0x03, 0x2E, 
    0x06, 0x29, 0x10, 0x2C, 0x1D, 0x06, 0x29, 0x0F, 0x2C, 0x1E, 
    0x0A, 0x00, 0x19, 0x0D, 0x2F, 0x1B, 0x2C, 0x14, 0x1C, 0x28, 
    0x08, 0x2B, 0x01, 0x21, 0x27, 0x32, 0x03, 0x2A, 0x0C, 0x18, 
    0x06, 0x30, 0x14, 0x08, 0x2D, 0x26, 0x0D, 0x2C, 0x23, 0x32, 
    0x1F, 0x09, 0x27, 0x19, 0x07, 0x10, 0x23, 0x04, 0x14, 0x26, 
    0x20, 0x05, 0x0F, 0x2F, 0x18, 0x20, 0x08, 0x32, 0x04, 0x0E, 0x2F, 
    
    0x14, 0x2D, 0x20, 0x10, 0x2F, 0x2B, 0x16, 0x1F, 0x32, 0x0B,         // 12
    0x2C, 0x18, 0x20, 0x04, 0x27, 0x0A, 0x15, 0x06, 0x2A, 0x1F, 
    0x30, 0x18, 0x21, 0x15, 0x32, 0x11, 0x27, 0x13, 0x20, 0x0F, 
    0x1C, 0x16, 0x1F, 0x02, 0x13, 0x32, 0x17, 0x1C, 0x05, 0x28, 
    0x17, 0x21, 0x29, 0x08, 0x12, 0x02, 0x26, 0x0E, 0x32, 0x0B, 
    0x24, 0x18, 0x30, 0x0B, 0x16, 0x09, 0x1B, 0x13, 0x21, 0x2B, 
    0x11, 0x25, 0x04, 0x28, 0x17, 0x03, 0x13, 0x1B, 0x06, 0x14, 
    0x03, 0x23, 0x2C, 0x0C, 0x21, 0x2F, 0x17, 0x29, 0x1D, 0x0B, 
    0x12, 0x2C, 0x1B, 0x01, 0x24, 0x0B, 0x16, 0x27, 0x13, 0x2A, 0x1C, 
    
    0x24, 0x0E, 0x04, 0x1D, 0x0C, 0x07, 0x26, 0x02, 0x13, 0x27,         // 13
    0x1C, 0x01, 0x0B, 0x31, 0x1A, 0x10, 0x25, 0x2F, 0x12, 0x04, 
    0x0F, 0x09, 0x2C, 0x05, 0x1B, 0x23, 0x06, 0x0C, 0x31, 0x25, 
    0x04, 0x30, 0x09, 0x2B, 0x25, 0x0E, 0x01, 0x22, 0x0D, 0x30, 
    0x12, 0x07, 0x2E, 0x25, 0x20, 0x18, 0x0A, 0x22, 0x04, 0x12, 
    0x1D, 0x06, 0x13, 0x29, 0x1E, 0x11, 0x24, 0x2D, 0x02, 0x0E, 
    0x1F, 0x19, 0x2E, 0x0E, 0x1D, 0x21, 0x30, 0x0A, 0x29, 0x19, 
    0x2E, 0x10, 0x15, 0x1E, 0x01, 0x26, 0x08, 0x0D, 0x30, 0x19, 
    0x06, 0x21, 0x14, 0x27, 0x11, 0x2E, 0x1D, 0x06, 0x21, 0x0B, 0x06, 
    
    0x16, 0x1A, 0x31, 0x25, 0x18, 0x21, 0x10, 0x2D, 0x23, 0x06,         // 14
    0x0F, 0x29, 0x22, 0x11, 0x2B, 0x01, 0x1E, 0x08, 0x1B, 0x22, 
    0x28, 0x1C, 0x12, 0x26, 0x0B, 0x18, 0x2B, 0x1E, 0x07, 0x19, 
    0x13, 0x26, 0x0F, 0x18, 0x0A, 0x1F, 0x2D, 0x27, 0x15, 0x03, 
    0x24, 0x1A, 0x0E, 0x15, 0x06, 0x30, 0x29, 0x1E, 0x18, 0x2E, 
    0x2A, 0x0E, 0x20, 0x03, 0x2F, 0x06, 0x28, 0x0A, 0x1A, 0x31, 
    0x06, 0x0B, 0x21, 0x00, 0x12, 0x27, 0x05, 0x1E, 0x11, 0x26, 
    0x0A, 0x1D, 0x06, 0x31, 0x11, 0x1B, 0x13, 0x20, 0x02, 0x25, 
    0x2B, 0x0D, 0x30, 0x08, 0x1F, 0x03, 0x2A, 0x0E, 0x19, 0x30, 0x27, 
    
    0x02, 0x29, 0x0B, 0x05, 0x12, 0x30, 0x08, 0x19, 0x0B, 0x20,         // 15
    0x18, 0x2D, 0x14, 0x06, 0x20, 0x17, 0x28, 0x0C, 0x2C, 0x15, 
    0x00, 0x2E, 0x07, 0x1E, 0x2E, 0x01, 0x10, 0x15, 0x29, 0x0E, 
    0x2D, 0x01, 0x1D, 0x23, 0x03, 0x1A, 0x12, 0x07, 0x1E, 0x2B, 
    0x0A, 0x1F, 0x02, 0x2C, 0x1D, 0x10, 0x01, 0x13, 0x09, 0x25, 
    0x02, 0x1A, 0x26, 0x0D, 0x15, 0x1A, 0x0F, 0x20, 0x15, 0x24, 
    0x29, 0x14, 0x2B, 0x18, 0x2F, 0x0B, 0x16, 0x2D, 0x0C, 0x20, 
    0x01, 0x2B, 0x25, 0x0A, 0x29, 0x04, 0x2E, 0x27, 0x12, 0x0A, 
    0x17, 0x04, 0x1D, 0x16, 0x2C, 0x0C, 0x14, 0x23, 0x00, 0x1E, 0x10, 
    
    0x2E, 0x1F, 0x14, 0x26, 0x2B, 0x02, 0x1D, 0x29, 0x14, 0x31,         // 16
    0x05, 0x0D, 0x1C, 0x2F, 0x0A, 0x0F, 0x30, 0x13, 0x05, 0x25, 
    0x0D, 0x17, 0x23, 0x0E, 0x15, 0x27, 0x20, 0x2F, 0x03, 0x1C, 
    0x22, 0x0B, 0x29, 0x11, 0x2E, 0x28, 0x0D, 0x31, 0x19, 0x0F, 
    0x26, 0x32, 0x11, 0x23, 0x0A, 0x27, 0x1A, 0x2B, 0x21, 0x0F, 
    0x16, 0x31, 0x09, 0x2C, 0x22, 0x2A, 0x00, 0x2F, 0x08, 0x0F, 
    0x02, 0x1D, 0x07, 0x25, 0x06, 0x1B, 0x24, 0x03, 0x18, 0x30, 
    0x13, 0x18, 0x0E, 0x20, 0x15, 0x23, 0x18, 0x06, 0x1D, 0x31, 
    0x22, 0x29, 0x10, 0x25, 0x06, 0x1A, 0x27, 0x2F, 0x11, 0x2A, 0x09, 
    
    0x1A, 0x0F, 0x07, 0x1C, 0x17, 0x0E, 0x24, 0x11, 0x00, 0x26,         // 17
    0x1E, 0x24, 0x02, 0x27, 0x1A, 0x24, 0x02, 0x21, 0x1D, 0x31, 
    0x1A, 0x2A, 0x06, 0x30, 0x04, 0x1C, 0x08, 0x0C, 0x18, 0x28, 
    0x06, 0x16, 0x31, 0x05, 0x17, 0x08, 0x20, 0x05, 0x23, 0x00, 
    0x15, 0x08, 0x1A, 0x2A, 0x17, 0x06, 0x31, 0x0C, 0x05, 0x2D, 
    0x1E, 0x04, 0x14, 0x1C, 0x05, 0x12, 0x1E, 0x17, 0x28, 0x20, 
    0x19, 0x30, 0x0E, 0x1E, 0x11, 0x29, 0x0F, 0x2B, 0x08, 0x27, 
    0x06, 0x2C, 0x1C, 0x02, 0x30, 0x08, 0x0D, 0x29, 0x0F, 0x16, 
    0x07, 0x1B, 0x01, 0x2F, 0x11, 0x22, 0x09, 0x1B, 0x06, 0x17, 0x25, 
    
    0x03, 0x2B, 0x21, 0x32, 0x09, 0x20, 0x2F, 0x09, 0x2C, 0x17,         // 18
    0x08, 0x12, 0x2C, 0x15, 0x07, 0x12, 0x2D, 0x18, 0x10, 0x0B, 
    0x04, 0x21, 0x12, 0x18, 0x29, 0x11, 0x2C, 0x25, 0x13, 0x30, 
    0x10, 0x1B, 0x20, 0x0C, 0x25, 0x1C, 0x14, 0x2C, 0x10, 0x27, 
    0x1D, 0x2B, 0x0D, 0x02, 0x1F, 0x0F, 0x23, 0x1D, 0x15, 0x26, 
    0x0B, 0x29, 0x21, 0x0E, 0x2E, 0x0A, 0x26, 0x0C, 0x05, 0x2E, 
    0x12, 0x09, 0x27, 0x16, 0x31, 0x01, 0x21, 0x14, 0x1E, 0x1A, 
    0x0F, 0x22, 0x0A, 0x28, 0x11, 0x1D, 0x22, 0x2D, 0x00, 0x20, 
    0x2E, 0x0E, 0x27, 0x15, 0x20, 0x03, 0x2B, 0x0E, 0x20, 0x31, 0x0C, 
    
    0x24, 0x16, 0x11, 0x01, 0x2A, 0x15, 0x04, 0x1A, 0x1F, 0x0F,         // 19
    0x30, 0x19, 0x0A, 0x1E, 0x32, 0x25, 0x0C, 0x07, 0x25, 0x2C, 
    0x14, 0x28, 0x0C, 0x1E, 0x24, 0x07, 0x1A, 0x00, 0x1F, 0x04, 
    0x24, 0x09, 0x28, 0x13, 0x2D, 0x02, 0x29, 0x0B, 0x19, 0x30, 
    0x06, 0x12, 0x22, 0x30, 0x13, 0x2C, 0x03, 0x11, 0x2F, 0x00, 
    0x18, 0x11, 0x2D, 0x02, 0x25, 0x19, 0x31, 0x14, 0x1F, 0x0D, 
    0x24, 0x2B, 0x04, 0x22, 0x08, 0x19, 0x0D, 0x2F, 0x09, 0x25, 
    0x02, 0x32, 0x13, 0x19, 0x25, 0x04, 0x16, 0x11, 0x26, 0x0A, 
    0x13, 0x2B, 0x09, 0x1D, 0x0C, 0x32, 0x16, 0x24, 0x02, 0x12, 0x1D, 
    
    0x2F, 0x05, 0x28, 0x18, 0x1D, 0x0C, 0x25, 0x2A, 0x0B, 0x23,         // 20
    0x02, 0x2A, 0x21, 0x10, 0x04, 0x16, 0x1F, 0x2A, 0x1B, 0x02, 
    0x1E, 0x08, 0x2F, 0x01, 0x0E, 0x32, 0x14, 0x2D, 0x0E, 0x2A, 
    0x15, 0x2E, 0x01, 0x1E, 0x0A, 0x18, 0x24, 0x06, 0x21, 0x0D, 
    0x18, 0x26, 0x04, 0x1C, 0x08, 0x25, 0x18, 0x29, 0x0A, 0x1C, 
    0x24, 0x09, 0x1D, 0x17, 0x10, 0x07, 0x21, 0x03, 0x2C, 0x18, 
    0x01, 0x1A, 0x13, 0x0C, 0x2D, 0x1D, 0x29, 0x04, 0x13, 0x2D, 
    0x16, 0x1E, 0x04, 0x2B, 0x08, 0x2E, 0x0C, 0x1E, 0x2F, 0x18, 
    0x1D, 0x04, 0x21, 0x17, 0x27, 0x06, 0x11, 0x2A, 0x18, 0x2C, 0x09, 
    
    0x0F, 0x1E, 0x0A, 0x25, 0x06, 0x30, 0x10, 0x18, 0x06, 0x13,         // 21
    0x27, 0x0E, 0x06, 0x2E, 0x1B, 0x29, 0x00, 0x14, 0x0F, 0x2E, 
    0x16, 0x23, 0x18, 0x27, 0x16, 0x1F, 0x0B, 0x24, 0x1A, 0x07, 
    0x1D, 0x0F, 0x19, 0x2A, 0x10, 0x32, 0x11, 0x1B, 0x2D, 0x02, 
    0x1F, 0x2E, 0x0E, 0x17, 0x2B, 0x0C, 0x1E, 0x06, 0x22, 0x0E, 
    0x32, 0x27, 0x04, 0x2F, 0x1F, 0x2B, 0x16, 0x10, 0x27, 0x0B, 
    0x20, 0x32, 0x1E, 0x28, 0x17, 0x06, 0x25, 0x18, 0x21, 0x0D, 
    0x27, 0x0B, 0x23, 0x0F, 0x1F, 0x1A, 0x2A, 0x02, 0x0E, 0x07, 
    0x25, 0x30, 0x11, 0x02, 0x2E, 0x1B, 0x21, 0x0C, 0x07, 0x26, 0x1A, 
    
    0x22, 0x2B, 0x13, 0x2D, 0x12, 0x22, 0x01, 0x2C, 0x1D, 0x2E,         // 22
    0x1F, 0x1A, 0x15, 0x24, 0x09, 0x0E, 0x23, 0x31, 0x05, 0x25, 
    0x0B, 0x10, 0x2C, 0x07, 0x22, 0x03, 0x29, 0x05, 0x13, 0x21, 
    0x31, 0x04, 0x25, 0x07, 0x21, 0x03, 0x28, 0x08, 0x14, 0x28, 
    0x16, 0x07, 0x29, 0x20, 0x01, 0x10, 0x2E, 0x14, 0x2B, 0x17, 
    0x06, 0x12, 0x22, 0x13, 0x0C, 0x01, 0x25, 0x1D, 0x09, 0x2D, 
    0x12, 0x07, 0x0E, 0x02, 0x23, 0x10, 0x0A, 0x31, 0x00, 0x1C, 
    0x07, 0x2A, 0x17, 0x30, 0x13, 0x04, 0x25, 0x14, 0x21, 0x2C, 
    0x15, 0x0B, 0x29, 0x24, 0x0D, 0x14, 0x00, 0x30, 0x1E, 0x13, 0x02, 
    
    0x0C, 0x18, 0x01, 0x1F, 0x08, 0x1B, 0x15, 0x27, 0x0F, 0x03,         // 23
    0x0A, 0x31, 0x01, 0x2A, 0x14, 0x2D, 0x18, 0x0A, 0x1E, 0x1A, 
    0x29, 0x03, 0x1F, 0x0F, 0x2F, 0x12, 0x1C, 0x2F, 0x0F, 0x2B, 
    0x0B, 0x20, 0x14, 0x2E, 0x1A, 0x15, 0x1E, 0x2F, 0x0C, 0x1C, 
    0x10, 0x22, 0x0A, 0x14, 0x31, 0x1A, 0x26, 0x03, 0x0A, 0x1E, 
    0x29, 0x19, 0x0A, 0x26, 0x2C, 0x1B, 0x0E, 0x31, 0x05, 0x1A, 
    0x25, 0x2A, 0x19, 0x2F, 0x14, 0x2C, 0x1C, 0x13, 0x24, 0x11, 
    0x2E, 0x1B, 0x02, 0x0C, 0x27, 0x0A, 0x17, 0x32, 0x11, 0x1B, 
    0x01, 0x1F, 0x18, 0x09, 0x1E, 0x2C, 0x24, 0x18, 0x0E, 0x28, 0x2E, 
    
    0x06, 0x23, 0x31, 0x0D, 0x28, 0x2E, 0x0B, 0x07, 0x21, 0x16,         // 24
    0x25, 0x11, 0x21, 0x0D, 0x1D, 0x04, 0x21, 0x11, 0x2B, 0x07, 
    0x13, 0x31, 0x1B, 0x17, 0x09, 0x23, 0x0C, 0x17, 0x27, 0x03, 
    0x18, 0x10, 0x28, 0x09, 0x0D, 0x26, 0x0F, 0x01, 0x24, 0x2B, 
    0x03, 0x2F, 0x1B, 0x0C, 0x24, 0x05, 0x16, 0x1F, 0x30, 0x10, 
    0x01, 0x2E, 0x1D, 0x04, 0x17, 0x0A, 0x29, 0x13, 0x23, 0x16, 
    0x02, 0x0F, 0x22, 0x0C, 0x1E, 0x03, 0x28, 0x06, 0x2B, 0x1F, 
    0x05, 0x14, 0x25, 0x1F, 0x2D, 0x1C, 0x22, 0x08, 0x05, 0x26, 
    0x0E, 0x2B, 0x06, 0x31, 0x12, 0x04, 0x0B, 0x29, 0x03, 0x1F, 0x15, 
    
    0x2C, 0x0F, 0x1D, 0x05, 0x17, 0x10, 0x23, 0x32, 0x19, 0x2A,         // 25
    0x05, 0x2C, 0x1A, 0x06, 0x28, 0x13, 0x30, 0x02, 0x25, 0x17, 
    0x21, 0x0A, 0x26, 0x01, 0x28, 0x2D, 0x04, 0x1F, 0x09, 0x23, 
    0x1C, 0x30, 0x01, 0x1E, 0x2C, 0x05, 0x2E, 0x19, 0x1F, 0x08, 
    0x19, 0x26, 0x05, 0x2B, 0x1D, 0x10, 0x2D, 0x0C, 0x25, 0x18, 
    0x22, 0x08, 0x28, 0x10, 0x30, 0x22, 0x02, 0x1E, 0x0C, 0x28, 
    0x2F, 0x1D, 0x05, 0x29, 0x08, 0x25, 0x0F, 0x1A, 0x09, 0x0E, 
    0x27, 0x31, 0x0F, 0x07, 0x12, 0x01, 0x0D, 0x2A, 0x1E, 0x2E, 
    0x16, 0x23, 0x10, 0x1A, 0x27, 0x20, 0x1C, 0x15, 0x32, 0x09, 0x1B, 
    
    0x0B, 0x29, 0x16, 0x2C, 0x25, 0x02, 0x1C, 0x04, 0x11, 0x0C,         // 26
    0x1F, 0x15, 0x0F, 0x2E, 0x24, 0x08, 0x1A, 0x1F, 0x0D, 0x2E, 
    0x03, 0x11, 0x2C, 0x0D, 0x1C, 0x13, 0x19, 0x31, 0x12, 0x2C, 
    0x07, 0x0E, 0x24, 0x15, 0x1B, 0x23, 0x14, 0x07, 0x11, 0x31, 
    0x15, 0x0E, 0x20, 0x12, 0x07, 0x28, 0x08, 0x1B, 0x05, 0x12, 
    0x2C, 0x0D, 0x16, 0x1F, 0x08, 0x12, 0x19, 0x2E, 0x06, 0x11, 
    0x09, 0x15, 0x2D, 0x13, 0x19, 0x31, 0x15, 0x22, 0x2E, 0x16, 
    0x1D, 0x02, 0x19, 0x2B, 0x17, 0x2F, 0x25, 0x18, 0x13, 0x0B, 
    0x03, 0x1C, 0x2C, 0x01, 0x0C, 0x2F, 0x10, 0x06, 0x21, 0x10, 0x26, 
    
    0x1F, 0x04, 0x12, 0x09, 0x1E, 0x2D, 0x13, 0x28, 0x22, 0x2F,         // 27
    0x08, 0x27, 0x03, 0x1D, 0x16, 0x0E, 0x2A, 0x11, 0x05, 0x28, 
    0x1B, 0x24, 0x16, 0x20, 0x08, 0x26, 0x0E, 0x21, 0x00, 0x17, 
    0x27, 0x1A, 0x2E, 0x04, 0x11, 0x09, 0x2A, 0x21, 0x27, 0x0B, 
    0x29, 0x01, 0x2C, 0x17, 0x31, 0x1E, 0x14, 0x27, 0x2F, 0x1E, 
    0x03, 0x1B, 0x2F, 0x01, 0x29, 0x24, 0x0B, 0x26, 0x2B, 0x1B, 
    0x20, 0x26, 0x03, 0x24, 0x09, 0x1F, 0x0D, 0x01, 0x27, 0x07, 
    0x22, 0x0C, 0x28, 0x23, 0x0B, 0x20, 0x0F, 0x03, 0x31, 0x23, 
    0x29, 0x09, 0x14, 0x26, 0x19, 0x07, 0x23, 0x2A, 0x18, 0x2D, 0x02, 
    
    0x25, 0x1A, 0x31, 0x22, 0x0F, 0x08, 0x18, 0x0C, 0x06, 0x1C,         // 28
    0x17, 0x2C, 0x23, 0x0A, 0x31, 0x00, 0x22, 0x2D, 0x1D, 0x14, 
    0x0C, 0x2F, 0x06, 0x10, 0x30, 0x03, 0x2B, 0x0B, 0x2A, 0x1E, 
    0x05, 0x11, 0x0A, 0x29, 0x20, 0x31, 0x0E, 0x16, 0x04, 0x1A, 
    0x22, 0x1C, 0x09, 0x23, 0x03, 0x0D, 0x22, 0x00, 0x17, 0x0E, 
    0x29, 0x24, 0x0B, 0x14, 0x1A, 0x31, 0x04, 0x16, 0x13, 0x00, 
    0x32, 0x0D, 0x1A, 0x10, 0x2E, 0x05, 0x2A, 0x1B, 0x12, 0x2F, 
    0x10, 0x2C, 0x13, 0x04, 0x1C, 0x07, 0x2D, 0x1D, 0x07, 0x1A, 
    0x0E, 0x21, 0x30, 0x0F, 0x20, 0x2D, 0x13, 0x01, 0x0A, 0x1D, 0x14, 
    
    0x07, 0x0C, 0x28, 0x00, 0x1B, 0x25, 0x30, 0x1F, 0x2A, 0x13,         // 29
    0x01, 0x0D, 0x19, 0x12, 0x28, 0x1B, 0x09, 0x17, 0x07, 0x26, 
    0x04, 0x1A, 0x22, 0x2A, 0x17, 0x23, 0x15, 0x1B, 0x07, 0x13, 
    0x2F, 0x21, 0x16, 0x1D, 0x06, 0x19, 0x00, 0x1D, 0x2E, 0x13, 
    0x06, 0x30, 0x18, 0x13, 0x27, 0x1A, 0x12, 0x2D, 0x0A, 0x21, 
    0x16, 0x07, 0x2D, 0x21, 0x05, 0x11, 0x1C, 0x20, 0x0D, 0x24, 
    0x18, 0x06, 0x2B, 0x1E, 0x15, 0x23, 0x17, 0x07, 0x20, 0x03, 
    0x18, 0x0A, 0x1E, 0x32, 0x10, 0x25, 0x14, 0x28, 0x11, 0x2C, 
    0x15, 0x04, 0x1C, 0x06, 0x17, 0x0B, 0x28, 0x1E, 0x30, 0x0F, 0x29, 
    
    0x2F, 0x1F, 0x12, 0x17, 0x2B, 0x05, 0x15, 0x03, 0x0F, 0x24,         // 30
    0x31, 0x20, 0x2A, 0x07, 0x1F, 0x10, 0x26, 0x0E, 0x30, 0x20, 
    0x2B, 0x13, 0x0D, 0x01, 0x1C, 0x07, 0x0F, 0x31, 0x20, 0x25, 
    0x0D, 0x29, 0x01, 0x2E, 0x10, 0x27, 0x2C, 0x24, 0x0B, 0x2A, 
    0x0F, 0x26, 0x0A, 0x2C, 0x04, 0x2F, 0x06, 0x25, 0x2A, 0x05, 
    0x32, 0x12, 0x1C, 0x0E, 0x28, 0x23, 0x08, 0x2E, 0x28, 0x07, 
    0x2D, 0x12, 0x27, 0x01, 0x0E, 0x2C, 0x0A, 0x31, 0x26, 0x1C, 
    0x2A, 0x24, 0x05, 0x16, 0x28, 0x00, 0x18, 0x0B, 0x20, 0x02, 
    0x26, 0x2E, 0x0B, 0x2A, 0x24, 0x04, 0x1B, 0x14, 0x24, 0x06, 0x16, 
    
    0x10, 0x05, 0x2D, 0x08, 0x1F, 0x11, 0x27, 0x19, 0x2D, 0x1D,         // 31
    0x09, 0x13, 0x04, 0x2E, 0x16, 0x03, 0x2B, 0x1D, 0x01, 0x11, 
    0x0A, 0x1E, 0x32, 0x25, 0x12, 0x2E, 0x26, 0x02, 0x0B, 0x16, 
    0x04, 0x1A, 0x12, 0x24, 0x09, 0x15, 0x07, 0x18, 0x05, 0x22, 
    0x17, 0x02, 0x1F, 0x0F, 0x21, 0x15, 0x1D, 0x0F, 0x19, 0x11, 
    0x1E, 0x02, 0x2B, 0x17, 0x0A, 0x2D, 0x15, 0x03, 0x1A, 0x10, 
    0x21, 0x1C, 0x0C, 0x20, 0x28, 0x04, 0x1D, 0x12, 0x0D, 0x15, 
    0x06, 0x12, 0x2E, 0x21, 0x0A, 0x2F, 0x23, 0x06, 0x30, 0x0D, 
    0x19, 0x10, 0x1F, 0x13, 0x32, 0x10, 0x2D, 0x03, 0x0D, 0x2B, 0x22, 
    
    0x1B, 0x27, 0x19, 0x24, 0x0C, 0x30, 0x09, 0x21, 0x0C, 0x03,         // 32
    0x18, 0x26, 0x1C, 0x0D, 0x21, 0x31, 0x0B, 0x14, 0x25, 0x19, 
    0x29, 0x03, 0x17, 0x08, 0x29, 0x09, 0x1E, 0x18, 0x2C, 0x27, 
    0x1E, 0x32, 0x0B, 0x2A, 0x1C, 0x21, 0x0E, 0x1E, 0x32, 0x11, 
    0x1D, 0x2F, 0x29, 0x1A, 0x09, 0x2A, 0x08, 0x22, 0x03, 0x2E, 
    0x24, 0x0C, 0x25, 0x05, 0x1F, 0x19, 0x0E, 0x27, 0x0B, 0x30, 
    0x02, 0x17, 0x07, 0x31, 0x1A, 0x14, 0x22, 0x2A, 0x08, 0x27, 
    0x2D, 0x0C, 0x1B, 0x03, 0x0F, 0x19, 0x1E, 0x2A, 0x15, 0x1D, 
    0x24, 0x06, 0x28, 0x01, 0x1C, 0x08, 0x1F, 0x27, 0x18, 0x1D, 0x03, 
    
    0x32, 0x0E, 0x02, 0x2B, 0x15, 0x1C, 0x01, 0x29, 0x14, 0x23,         // 33
    0x2E, 0x0F, 0x29, 0x14, 0x06, 0x1B, 0x23, 0x05, 0x2F, 0x07, 
    0x21, 0x2E, 0x0C, 0x1B, 0x20, 0x15, 0x0E, 0x23, 0x12, 0x06, 
    0x0E, 0x21, 0x06, 0x18, 0x03, 0x30, 0x29, 0x02, 0x0D, 0x25, 
    0x06, 0x0B, 0x12, 0x03, 0x26, 0x10, 0x31, 0x17, 0x27, 0x0A, 
    0x18, 0x14, 0x30, 0x11, 0x2A, 0x00, 0x2F, 0x22, 0x1E, 0x13, 
    0x29, 0x23, 0x2B, 0x12, 0x0C, 0x07, 0x2E, 0x03, 0x1A, 0x1F, 
    0x01, 0x22, 0x15, 0x2B, 0x26, 0x13, 0x07, 0x10, 0x01, 0x2C, 
    0x09, 0x30, 0x15, 0x23, 0x11, 0x2B, 0x16, 0x0F, 0x07, 0x2C, 0x0A, 
    
    0x16, 0x1F, 0x13, 0x22, 0x05, 0x2C, 0x11, 0x18, 0x30, 0x06,         // 34
    0x1E, 0x0A, 0x00, 0x2F, 0x25, 0x0F, 0x17, 0x2B, 0x0D, 0x1D, 
    0x0F, 0x16, 0x24, 0x05, 0x30, 0x01, 0x2B, 0x08, 0x30, 0x19, 
    0x2A, 0x14, 0x2E, 0x26, 0x10, 0x15, 0x24, 0x14, 0x2C, 0x19, 
    0x29, 0x16, 0x22, 0x30, 0x18, 0x20, 0x01, 0x0E, 0x1C, 0x2C, 
    0x06, 0x22, 0x1C, 0x08, 0x21, 0x1B, 0x09, 0x11, 0x04, 0x19, 
    0x09, 0x10, 0x04, 0x1E, 0x2D, 0x25, 0x17, 0x10, 0x2F, 0x0E, 
    0x18, 0x31, 0x07, 0x1E, 0x0A, 0x2E, 0x22, 0x27, 0x18, 0x20, 
    0x0E, 0x1B, 0x05, 0x2D, 0x09, 0x26, 0x02, 0x31, 0x21, 0x13, 0x25, 
    
    0x2B, 0x0B, 0x2F, 0x09, 0x1E, 0x0D, 0x25, 0x1F, 0x0B, 0x11,         // 35
    0x2A, 0x17, 0x22, 0x1A, 0x08, 0x29, 0x02, 0x20, 0x13, 0x26, 
    0x00, 0x2B, 0x12, 0x28, 0x1A, 0x13, 0x25, 0x1C, 0x03, 0x1F, 
    0x0C, 0x00, 0x1C, 0x0D, 0x20, 0x08, 0x1C, 0x06, 0x20, 0x0B, 
    0x00, 0x2D, 0x1C, 0x06, 0x0C, 0x13, 0x2D, 0x23, 0x07, 0x11, 
    0x26, 0x01, 0x0E, 0x2E, 0x13, 0x29, 0x16, 0x25, 0x2C, 0x23, 
    0x31, 0x1B, 0x26, 0x15, 0x02, 0x1F, 0x0A, 0x27, 0x20, 0x08, 
    0x26, 0x13, 0x23, 0x10, 0x1A, 0x05, 0x15, 0x0C, 0x31, 0x06, 
    0x25, 0x2B, 0x10, 0x1E, 0x18, 0x0C, 0x1C, 0x29, 0x0A, 0x1C, 0x00, 
    
    0x20, 0x06, 0x1A, 0x27, 0x17, 0x31, 0x08, 0x03, 0x28, 0x1C,         // 36
    0x03, 0x32, 0x12, 0x0C, 0x2C, 0x1C, 0x10, 0x2E, 0x08, 0x1A, 
    0x31, 0x0A, 0x1E, 0x0E, 0x08, 0x2E, 0x0A, 0x0F, 0x15, 0x2E, 
    0x26, 0x17, 0x2B, 0x05, 0x2F, 0x28, 0x0F, 0x31, 0x12, 0x27, 
    0x1E, 0x12, 0x0E, 0x27, 0x2B, 0x1D, 0x05, 0x29, 0x15, 0x31, 
    0x1B, 0x2B, 0x16, 0x26, 0x03, 0x0C, 0x32, 0x06, 0x0B, 0x17, 
    0x01, 0x0C, 0x2E, 0x08, 0x2A, 0x12, 0x1C, 0x01, 0x15, 0x2C, 
    0x03, 0x0C, 0x2C, 0x00, 0x2F, 0x20, 0x2B, 0x03, 0x1D, 0x12, 
    0x18, 0x0A, 0x22, 0x03, 0x30, 0x21, 0x12, 0x04, 0x18, 0x2F, 0x11, 
    
    0x28, 0x14, 0x2C, 0x0F, 0x04, 0x12, 0x1A, 0x2B, 0x15, 0x23,         // 37
    0x13, 0x26, 0x04, 0x1F, 0x16, 0x05, 0x22, 0x18, 0x2A, 0x05, 
    0x21, 0x19, 0x03, 0x2C, 0x20, 0x18, 0x29, 0x21, 0x2B, 0x05, 
    0x1D, 0x08, 0x22, 0x13, 0x1A, 0x01, 0x17, 0x25, 0x03, 0x19, 
    0x2F, 0x04, 0x21, 0x17, 0x02, 0x24, 0x17, 0x0B, 0x20, 0x03, 
    0x10, 0x0A, 0x1F, 0x07, 0x23, 0x19, 0x21, 0x1C, 0x12, 0x20, 
    0x2B, 0x13, 0x20, 0x18, 0x22, 0x0B, 0x32, 0x29, 0x0F, 0x1A, 
    0x1F, 0x29, 0x1D, 0x18, 0x27, 0x0D, 0x19, 0x11, 0x2D, 0x27, 
    0x00, 0x2E, 0x13, 0x29, 0x0F, 0x06, 0x2C, 0x27, 0x0F, 0x23, 0x05, 
    
    0x0D, 0x1E, 0x02, 0x21, 0x2D, 0x26, 0x20, 0x0E, 0x2E, 0x08,         // 38
    0x0D, 0x1D, 0x2D, 0x10, 0x24, 0x30, 0x0A, 0x0D, 0x1E, 0x13, 
    0x0E, 0x29, 0x14, 0x25, 0x05, 0x12, 0x01, 0x1A, 0x09, 0x14, 
    0x0D, 0x2D, 0x10, 0x26, 0x0A, 0x2C, 0x1F, 0x0D, 0x2B, 0x09, 
    0x15, 0x25, 0x0B, 0x32, 0x11, 0x09, 0x2F, 0x10, 0x1B, 0x29, 
    0x22, 0x18, 0x30, 0x14, 0x2A, 0x10, 0x01, 0x28, 0x2D, 0x0E, 
    0x07, 0x27, 0x04, 0x0E, 0x2C, 0x17, 0x05, 0x23, 0x07, 0x2F, 
    0x0E, 0x16, 0x07, 0x0A, 0x13, 0x04, 0x26, 0x08, 0x22, 0x0D, 
    0x1B, 0x1F, 0x07, 0x17, 0x26, 0x1B, 0x14, 0x1D, 0x08, 0x2D, 0x1A, 
    
    0x31, 0x26, 0x17, 0x08, 0x1B, 0x0B, 0x00, 0x17, 0x06, 0x1F,         // 39
    0x30, 0x16, 0x07, 0x29, 0x02, 0x14, 0x2B, 0x23, 0x01, 0x30, 
    0x24, 0x06, 0x2F, 0x0B, 0x1C, 0x30, 0x27, 0x0E, 0x32, 0x23, 
    0x28, 0x19, 0x02, 0x31, 0x16, 0x21, 0x04, 0x13, 0x1C, 0x22, 
    0x0F, 0x2C, 0x07, 0x1A, 0x29, 0x1E, 0x26, 0x04, 0x2D, 0x0C, 
    0x07, 0x27, 0x02, 0x0D, 0x1B, 0x2F, 0x0A, 0x18, 0x04, 0x23, 
    0x1B, 0x15, 0x30, 0x1D, 0x02, 0x26, 0x10, 0x1E, 0x14, 0x24, 
    0x04, 0x27, 0x2D, 0x22, 0x31, 0x1E, 0x2A, 0x1B, 0x14, 0x06, 
    0x2B, 0x10, 0x30, 0x21, 0x01, 0x0D, 0x32, 0x03, 0x20, 0x12, 0x0A, 
    
    0x04, 0x10, 0x2E, 0x14, 0x2A, 0x11, 0x2F, 0x23, 0x29, 0x1A,         // 40
    0x01, 0x26, 0x0B, 0x19, 0x1F, 0x08, 0x1B, 0x12, 0x29, 0x17, 
    0x09, 0x1F, 0x19, 0x11, 0x23, 0x0C, 0x15, 0x20, 0x04, 0x17, 
    0x06, 0x20, 0x0C, 0x1E, 0x06, 0x11, 0x2F, 0x28, 0x08, 0x31, 
    0x01, 0x1E, 0x13, 0x23, 0x0C, 0x01, 0x18, 0x21, 0x13, 0x1A, 
    0x2E, 0x11, 0x21, 0x2C, 0x08, 0x25, 0x1F, 0x13, 0x31, 0x0B, 
    0x2C, 0x0F, 0x24, 0x09, 0x14, 0x2E, 0x1A, 0x0B, 0x2C, 0x09, 
    0x1C, 0x12, 0x01, 0x19, 0x10, 0x0B, 0x15, 0x02, 0x32, 0x26, 
    0x16, 0x03, 0x1A, 0x0B, 0x2B, 0x1E, 0x25, 0x0B, 0x18, 0x2B, 0x23, 
    
    0x1B, 0x20, 0x0C, 0x24, 0x04, 0x1F, 0x18, 0x0F, 0x0A, 0x14,         // 41
    0x2B, 0x11, 0x21, 0x31, 0x0E, 0x26, 0x2F, 0x06, 0x0C, 0x1D, 
    0x10, 0x28, 0x00, 0x2A, 0x07, 0x2C, 0x02, 0x1C, 0x2B, 0x10, 
    0x2F, 0x12, 0x2C, 0x24, 0x19, 0x26, 0x07, 0x17, 0x24, 0x12, 
    0x19, 0x28, 0x04, 0x2D, 0x15, 0x30, 0x0F, 0x08, 0x28, 0x00, 
    0x1F, 0x16, 0x05, 0x1D, 0x15, 0x04, 0x0D, 0x29, 0x21, 0x19, 
    0x00, 0x1E, 0x0C, 0x2A, 0x20, 0x0D, 0x24, 0x00, 0x28, 0x17, 
    0x31, 0x20, 0x0D, 0x25, 0x2B, 0x07, 0x2E, 0x24, 0x10, 0x1E, 
    0x09, 0x24, 0x29, 0x11, 0x18, 0x08, 0x10, 0x2E, 0x27, 0x01, 0x15, 
    
    0x08, 0x2C, 0x01, 0x1A, 0x30, 0x08, 0x28, 0x02, 0x32, 0x24,         // 42
    0x06, 0x1E, 0x04, 0x28, 0x12, 0x01, 0x19, 0x21, 0x2D, 0x25, 
    0x05, 0x32, 0x13, 0x1E, 0x18, 0x22, 0x12, 0x24, 0x0B, 0x27, 
    0x07, 0x1D, 0x04, 0x13, 0x0B, 0x2B, 0x0E, 0x1F, 0x03, 0x2A, 
    0x0E, 0x21, 0x0A, 0x1B, 0x07, 0x28, 0x23, 0x1C, 0x2F, 0x10, 
    0x0A, 0x26, 0x32, 0x0F, 0x28, 0x2E, 0x19, 0x03, 0x11, 0x09, 
    0x28, 0x13, 0x31, 0x03, 0x19, 0x06, 0x30, 0x15, 0x21, 0x0F, 
    0x03, 0x29, 0x17, 0x05, 0x1D, 0x18, 0x21, 0x0C, 0x06, 0x18, 
    0x2C, 0x0E, 0x1D, 0x05, 0x30, 0x22, 0x1C, 0x06, 0x12, 0x1E, 0x2F, 
    
    0x23, 0x13, 0x27, 0x0E, 0x15, 0x22, 0x13, 0x1B, 0x20, 0x0B,         // 43
    0x19, 0x2E, 0x0C, 0x17, 0x1D, 0x2E, 0x0B, 0x14, 0x03, 0x12, 
    0x19, 0x20, 0x09, 0x2D, 0x04, 0x0D, 0x31, 0x07, 0x1A, 0x14, 
    0x22, 0x17, 0x28, 0x2F, 0x00, 0x1C, 0x14, 0x30, 0x0B, 0x1B, 
    0x05, 0x30, 0x11, 0x2A, 0x1E, 0x0D, 0x03, 0x12, 0x18, 0x23, 
    0x2C, 0x06, 0x18, 0x09, 0x1F, 0x10, 0x23, 0x2B, 0x1D, 0x2F, 
    0x23, 0x05, 0x17, 0x26, 0x11, 0x29, 0x1B, 0x0E, 0x07, 0x27, 
    0x1A, 0x08, 0x2E, 0x11, 0x27, 0x01, 0x12, 0x1B, 0x2F, 0x27, 
    0x13, 0x01, 0x2E, 0x24, 0x14, 0x02, 0x29, 0x16, 0x22, 0x0A, 0x0F, 
    
    0x17, 0x06, 0x1D, 0x2D, 0x0A, 0x2A, 0x07, 0x2C, 0x04, 0x12,         // 44
    0x28, 0x10, 0x23, 0x08, 0x2A, 0x06, 0x24, 0x2A, 0x1D, 0x2F, 
    0x0B, 0x27, 0x18, 0x10, 0x26, 0x1C, 0x14, 0x27, 0x2C, 0x04, 
    0x30, 0x09, 0x0D, 0x1A, 0x21, 0x2C, 0x05, 0x27, 0x16, 0x2C, 
    0x1F, 0x16, 0x23, 0x00, 0x17, 0x21, 0x2C, 0x26, 0x04, 0x0C, 
    0x14, 0x1D, 0x24, 0x2B, 0x02, 0x16, 0x0B, 0x06, 0x15, 0x0E, 
    0x1A, 0x0A, 0x2D, 0x1D, 0x08, 0x21, 0x04, 0x2B, 0x1D, 0x2F, 
    0x13, 0x22, 0x0B, 0x23, 0x31, 0x0E, 0x2B, 0x25, 0x03, 0x0E, 
    0x20, 0x1A, 0x09, 0x10, 0x2B, 0x1A, 0x0D, 0x30, 0x05, 0x2C, 0x28, 
    
    0x21, 0x32, 0x11, 0x04, 0x1F, 0x19, 0x0D, 0x25, 0x16, 0x2F,         // 45
    0x1D, 0x00, 0x2B, 0x13, 0x1F, 0x0F, 0x19, 0x11, 0x08, 0x28, 
    0x0F, 0x06, 0x2E, 0x02, 0x2B, 0x08, 0x21, 0x00, 0x0E, 0x1F, 
    0x12, 0x2A, 0x23, 0x13, 0x07, 0x0C, 0x1F, 0x10, 0x01, 0x24, 
    0x07, 0x0D, 0x2D, 0x10, 0x31, 0x06, 0x15, 0x0A, 0x31, 0x1F, 
    0x29, 0x01, 0x12, 0x0D, 0x2F, 0x1C, 0x25, 0x31, 0x21, 0x02, 
    0x2B, 0x1F, 0x0F, 0x15, 0x2F, 0x0C, 0x13, 0x24, 0x17, 0x0A, 
    0x01, 0x2B, 0x1B, 0x03, 0x17, 0x22, 0x0A, 0x15, 0x1F, 0x08, 
    0x2F, 0x26, 0x16, 0x21, 0x0B, 0x1F, 0x04, 0x24, 0x1A, 0x14, 0x03, 
    
    0x19, 0x0B, 0x29, 0x16, 0x26, 0x02, 0x31, 0x1A, 0x0F, 0x07,         // 46
    0x26, 0x0D, 0x19, 0x31, 0x03, 0x27, 0x30, 0x01, 0x21, 0x15, 
    0x1C, 0x23, 0x14, 0x20, 0x1B, 0x12, 0x2F, 0x16, 0x1A, 0x26, 
    0x06, 0x1C, 0x02, 0x27, 0x32, 0x16, 0x26, 0x1A, 0x2E, 0x12, 
    0x1A, 0x28, 0x09, 0x1C, 0x26, 0x0E, 0x1B, 0x22, 0x10, 0x1A, 
    0x0A, 0x2E, 0x1A, 0x20, 0x27, 0x05, 0x11, 0x08, 0x17, 0x27, 
    0x12, 0x07, 0x29, 0x01, 0x25, 0x1A, 0x2E, 0x02, 0x10, 0x26, 
    0x1F, 0x16, 0x0F, 0x2C, 0x09, 0x1D, 0x05, 0x30, 0x19, 0x24, 
    0x12, 0x04, 0x2C, 0x06, 0x32, 0x13, 0x28, 0x10, 0x08, 0x26, 0x0D, 
    
    0x2E, 0x00, 0x22, 0x08, 0x2E, 0x11, 0x1E, 0x06, 0x22, 0x2C,         // 47
    0x15, 0x21, 0x06, 0x24, 0x0B, 0x15, 0x0D, 0x1D, 0x2C, 0x07, 
    0x30, 0x03, 0x28, 0x0E, 0x07, 0x24, 0x0C, 0x29, 0x07, 0x31, 
    0x0C, 0x2C, 0x17, 0x0E, 0x1F, 0x04, 0x2C, 0x0D, 0x09, 0x1F, 
    0x31, 0x02, 0x21, 0x14, 0x03, 0x2A, 0x2E, 0x01, 0x28, 0x06, 
    0x15, 0x25, 0x04, 0x0A, 0x13, 0x2C, 0x1A, 0x2B, 0x1D, 0x0A, 
    0x2F, 0x18, 0x21, 0x0C, 0x1D, 0x05, 0x14, 0x1F, 0x2C, 0x0C, 
    0x32, 0x06, 0x28, 0x21, 0x13, 0x2E, 0x27, 0x11, 0x02, 0x29, 
    0x0A, 0x1F, 0x0D, 0x1B, 0x24, 0x09, 0x17, 0x2F, 0x1F, 0x2B, 0x1D, 
    
    0x12, 0x28, 0x14, 0x1C, 0x0C, 0x18, 0x2A, 0x27, 0x0E, 0x02,         // 48
    0x1B, 0x0A, 0x2A, 0x10, 0x1C, 0x2B, 0x23, 0x0A, 0x13, 0x26, 
    0x0F, 0x18, 0x0A, 0x31, 0x17, 0x2B, 0x04, 0x1E, 0x15, 0x21, 
    0x13, 0x1F, 0x09, 0x29, 0x19, 0x0B, 0x13, 0x23, 0x2B, 0x06, 
    0x16, 0x11, 0x2B, 0x0B, 0x18, 0x22, 0x0A, 0x17, 0x1E, 0x2F, 
    0x21, 0x0F, 0x31, 0x17, 0x23, 0x00, 0x0B, 0x20, 0x04, 0x14, 
    0x23, 0x04, 0x2D, 0x16, 0x31, 0x27, 0x0A, 0x29, 0x06, 0x19, 
    0x13, 0x1E, 0x0A, 0x1A, 0x00, 0x0D, 0x1B, 0x22, 0x0C, 0x1D, 
    0x2F, 0x15, 0x28, 0x11, 0x03, 0x2D, 0x1D, 0x01, 0x0B, 0x16, 0x06, 
    
    0x25, 0x1A, 0x05, 0x2C, 0x25, 0x01, 0x0A, 0x13, 0x19, 0x31,         // 49
    0x27, 0x13, 0x2F, 0x1F, 0x02, 0x18, 0x06, 0x2E, 0x1A, 0x04, 
    0x1F, 0x2C, 0x1D, 0x23, 0x01, 0x1C, 0x11, 0x2F, 0x0B, 0x01, 
    0x28, 0x10, 0x2F, 0x03, 0x24, 0x30, 0x1D, 0x01, 0x19, 0x27, 
    0x0B, 0x1C, 0x24, 0x2F, 0x1E, 0x06, 0x11, 0x29, 0x0D, 0x14, 
    0x05, 0x1C, 0x2A, 0x07, 0x1E, 0x2E, 0x0F, 0x25, 0x31, 0x10, 
    0x2A, 0x1D, 0x13, 0x06, 0x0F, 0x21, 0x17, 0x10, 0x1D, 0x25, 
    0x02, 0x2D, 0x10, 0x30, 0x23, 0x29, 0x06, 0x16, 0x2C, 0x06, 
    0x19, 0x00, 0x2D, 0x22, 0x18, 0x0E, 0x25, 0x13, 0x22, 0x2D, 0x0C, 
    
    0x03, 0x31, 0x0A, 0x1F, 0x12, 0x30, 0x20, 0x2B, 0x05, 0x1D,         // 50
    0x0C, 0x03, 0x17, 0x09, 0x24, 0x32, 0x15, 0x0F, 0x21, 0x29, 
    0x0B, 0x10, 0x05, 0x13, 0x2D, 0x0D, 0x27, 0x19, 0x24, 0x2D, 
    0x1C, 0x05, 0x22, 0x16, 0x10, 0x06, 0x2B, 0x14, 0x0E, 0x20, 
    0x2D, 0x05, 0x10, 0x07, 0x13, 0x26, 0x32, 0x1A, 0x03, 0x24, 
    0x2C, 0x0B, 0x13, 0x27, 0x0D, 0x15, 0x29, 0x16, 0x09, 0x1A, 
    0x02, 0x0D, 0x24, 0x2B, 0x1C, 0x08, 0x2D, 0x03, 0x30, 0x0D, 
    0x29, 0x22, 0x04, 0x17, 0x08, 0x14, 0x32, 0x0E, 0x27, 0x20, 
    0x10, 0x24, 0x0C, 0x06, 0x1F, 0x2A, 0x09, 0x31, 0x05, 0x19, 0x20, 
    
    0x10, 0x16, 0x29, 0x0E, 0x19, 0x08, 0x1C, 0x0E, 0x22, 0x12,         // 51
    0x23, 0x2E, 0x1C, 0x28, 0x0D, 0x04, 0x1E, 0x25, 0x01, 0x16, 
    0x31, 0x23, 0x19, 0x28, 0x0B, 0x20, 0x05, 0x13, 0x07, 0x0F, 
    0x17, 0x27, 0x0A, 0x1B, 0x29, 0x20, 0x0A, 0x26, 0x31, 0x03, 
    0x1B, 0x29, 0x22, 0x19, 0x2A, 0x01, 0x0E, 0x20, 0x2D, 0x09, 
    0x18, 0x20, 0x01, 0x1A, 0x30, 0x05, 0x1C, 0x02, 0x20, 0x27, 
    0x2E, 0x18, 0x09, 0x27, 0x01, 0x19, 0x28, 0x13, 0x21, 0x17, 
    0x09, 0x14, 0x1F, 0x2A, 0x0E, 0x1C, 0x21, 0x02, 0x1B, 0x09, 
    0x31, 0x15, 0x1B, 0x2F, 0x14, 0x02, 0x1B, 0x15, 0x28, 0x0E, 0x2B, 
    
    0x1D, 0x07, 0x22, 0x03, 0x26, 0x2A, 0x04, 0x17, 0x2F, 0x09,         // 52
    0x2B, 0x06, 0x0F, 0x16, 0x2D, 0x13, 0x2A, 0x0C, 0x2D, 0x08, 
    0x1B, 0x02, 0x2E, 0x08, 0x17, 0x30, 0x1B, 0x29, 0x32, 0x21, 
    0x09, 0x2C, 0x13, 0x31, 0x01, 0x0F, 0x17, 0x1D, 0x09, 0x12, 
    0x16, 0x0C, 0x03, 0x30, 0x0B, 0x1D, 0x17, 0x06, 0x12, 0x28, 
    0x0F, 0x30, 0x25, 0x0C, 0x1F, 0x0A, 0x24, 0x2D, 0x0C, 0x13, 
    0x06, 0x1F, 0x31, 0x11, 0x20, 0x0D, 0x23, 0x07, 0x1B, 0x03, 
    0x2F, 0x1C, 0x0B, 0x24, 0x2E, 0x05, 0x29, 0x11, 0x2E, 0x13, 
    0x03, 0x26, 0x0A, 0x28, 0x0D, 0x2C, 0x23, 0x0A, 0x1E, 0x01, 0x25, 
    
    0x18, 0x2E, 0x13, 0x30, 0x15, 0x0B, 0x2D, 0x23, 0x00, 0x1C,         // 53
    0x14, 0x1F, 0x27, 0x01, 0x22, 0x1C, 0x07, 0x18, 0x1F, 0x13, 
    0x25, 0x11, 0x1F, 0x0F, 0x25, 0x00, 0x0E, 0x1F, 0x03, 0x14, 
    0x1D, 0x02, 0x23, 0x0B, 0x1D, 0x2E, 0x24, 0x05, 0x2C, 0x21, 
    0x2F, 0x27, 0x13, 0x20, 0x15, 0x27, 0x2E, 0x23, 0x1B, 0x02, 
    0x1E, 0x0A, 0x16, 0x2C, 0x12, 0x2A, 0x16, 0x10, 0x1C, 0x2B, 
    0x23, 0x0E, 0x03, 0x17, 0x2C, 0x15, 0x31, 0x0B, 0x2B, 0x25, 
    0x0F, 0x29, 0x01, 0x12, 0x1B, 0x09, 0x16, 0x23, 0x0C, 0x1E, 
    0x2B, 0x20, 0x05, 0x16, 0x1D, 0x04, 0x0F, 0x30, 0x13, 0x2D, 0x09, 
    
    0x26, 0x02, 0x1E, 0x08, 0x1B, 0x21, 0x10, 0x14, 0x28, 0x0D,         // 54
    0x25, 0x0A, 0x1A, 0x31, 0x11, 0x0B, 0x26, 0x30, 0x05, 0x2B, 
    0x0A, 0x28, 0x04, 0x1C, 0x2B, 0x15, 0x27, 0x17, 0x0C, 0x26, 
    0x2E, 0x11, 0x19, 0x28, 0x15, 0x06, 0x2A, 0x14, 0x1B, 0x0B, 
    0x00, 0x1D, 0x0D, 0x2D, 0x08, 0x03, 0x11, 0x0B, 0x31, 0x26, 
    0x14, 0x2B, 0x03, 0x1B, 0x06, 0x21, 0x03, 0x32, 0x09, 0x00, 
    0x15, 0x29, 0x1C, 0x24, 0x09, 0x04, 0x1C, 0x11, 0x1F, 0x15, 
    0x05, 0x21, 0x17, 0x2C, 0x0D, 0x1F, 0x30, 0x00, 0x29, 0x17, 
    0x07, 0x19, 0x11, 0x30, 0x24, 0x18, 0x27, 0x07, 0x19, 0x20, 0x0F, 
    
    0x2B, 0x0D, 0x28, 0x11, 0x25, 0x02, 0x1A, 0x06, 0x32, 0x18,         // 55
    0x04, 0x2E, 0x0F, 0x06, 0x18, 0x2C, 0x02, 0x16, 0x0F, 0x20, 
    0x1A, 0x2E, 0x16, 0x23, 0x05, 0x0B, 0x2F, 0x07, 0x2B, 0x1B, 
    0x0A, 0x22, 0x04, 0x2D, 0x09, 0x22, 0x0E, 0x02, 0x28, 0x11, 
    0x24, 0x18, 0x05, 0x23, 0x1A, 0x2C, 0x1F, 0x16, 0x08, 0x19, 
    0x06, 0x22, 0x10, 0x27, 0x2F, 0x0E, 0x1E, 0x18, 0x27, 0x1F, 
    0x30, 0x07, 0x13, 0x2F, 0x10, 0x2A, 0x26, 0x00, 0x2F, 0x09, 
    0x1B, 0x30, 0x08, 0x25, 0x04, 0x27, 0x10, 0x1C, 0x0A, 0x25, 
    0x0E, 0x2D, 0x22, 0x01, 0x0B, 0x2D, 0x11, 0x22, 0x2A, 0x04, 0x15, 
    
    0x22, 0x06, 0x17, 0x2C, 0x0E, 0x2F, 0x29, 0x20, 0x0E, 0x22,         // 56
    0x2A, 0x15, 0x21, 0x2A, 0x24, 0x1E, 0x10, 0x22, 0x29, 0x00, 
    0x14, 0x07, 0x0E, 0x31, 0x12, 0x21, 0x1A, 0x23, 0x10, 0x01, 
    0x15, 0x31, 0x0F, 0x1F, 0x12, 0x19, 0x32, 0x20, 0x18, 0x2D, 
    0x07, 0x31, 0x29, 0x14, 0x0F, 0x25, 0x05, 0x29, 0x21, 0x2B, 
    0x0E, 0x30, 0x1F, 0x07, 0x16, 0x25, 0x08, 0x2C, 0x11, 0x0D, 
    0x1B, 0x0B, 0x22, 0x02, 0x1A, 0x20, 0x0D, 0x18, 0x22, 0x12, 
    0x27, 0x0C, 0x1D, 0x13, 0x2E, 0x18, 0x05, 0x2C, 0x13, 0x31, 
    0x03, 0x1C, 0x0F, 0x29, 0x14, 0x07, 0x1E, 0x01, 0x0C, 0x2F, 0x1B, 
    
    0x12, 0x32, 0x20, 0x04, 0x1D, 0x0A, 0x12, 0x07, 0x1C, 0x02,         // 57
    0x10, 0x1C, 0x01, 0x0D, 0x13, 0x04, 0x2F, 0x19, 0x0A, 0x30, 
    0x25, 0x1E, 0x27, 0x09, 0x18, 0x2D, 0x04, 0x13, 0x2D, 0x20, 
    0x27, 0x05, 0x1B, 0x29, 0x00, 0x26, 0x07, 0x10, 0x09, 0x21, 
    0x13, 0x0C, 0x1F, 0x01, 0x2E, 0x0A, 0x19, 0x10, 0x00, 0x15, 
    0x1C, 0x02, 0x12, 0x1B, 0x0C, 0x2D, 0x13, 0x02, 0x23, 0x05, 
    0x26, 0x2C, 0x16, 0x28, 0x08, 0x13, 0x2E, 0x06, 0x28, 0x03, 
    0x16, 0x2C, 0x02, 0x21, 0x08, 0x1F, 0x14, 0x23, 0x06, 0x1F, 
    0x16, 0x2B, 0x06, 0x20, 0x1A, 0x27, 0x31, 0x18, 0x13, 0x25, 0x08, 
    
    0x01, 0x19, 0x0B, 0x13, 0x27, 0x18, 0x23, 0x2C, 0x16, 0x2D,         // 58
    0x27, 0x0B, 0x31, 0x26, 0x1B, 0x0B, 0x28, 0x06, 0x1F, 0x12, 
    0x0C, 0x03, 0x1B, 0x2A, 0x01, 0x1E, 0x0C, 0x25, 0x06, 0x18, 
    0x0A, 0x2B, 0x16, 0x0C, 0x2F, 0x1C, 0x16, 0x2C, 0x27, 0x02, 
    0x1C, 0x26, 0x08, 0x1B, 0x22, 0x15, 0x2C, 0x1D, 0x32, 0x26, 
    0x0B, 0x2D, 0x24, 0x2A, 0x03, 0x21, 0x1C, 0x2A, 0x16, 0x2E, 
    0x19, 0x10, 0x06, 0x1D, 0x31, 0x25, 0x0B, 0x1F, 0x10, 0x31, 
    0x22, 0x0F, 0x19, 0x2A, 0x10, 0x32, 0x0C, 0x28, 0x19, 0x0E, 
    0x25, 0x0A, 0x13, 0x2F, 0x02, 0x16, 0x09, 0x2B, 0x1F, 0x0D, 0x29, 
    
    0x1E, 0x2D, 0x23, 0x2A, 0x06, 0x31, 0x00, 0x0D, 0x24, 0x12,         // 59
    0x05, 0x20, 0x16, 0x08, 0x2E, 0x20, 0x15, 0x0E, 0x2D, 0x17, 
    0x28, 0x2D, 0x10, 0x15, 0x24, 0x0F, 0x29, 0x1B, 0x32, 0x11, 
    0x1D, 0x0F, 0x24, 0x04, 0x21, 0x12, 0x05, 0x1F, 0x11, 0x30, 
    0x16, 0x2C, 0x11, 0x30, 0x0D, 0x03, 0x23, 0x07, 0x0F, 0x05, 
    0x1F, 0x17, 0x06, 0x14, 0x31, 0x10, 0x06, 0x0D, 0x1E, 0x0A, 
    0x01, 0x20, 0x2B, 0x0D, 0x15, 0x02, 0x1B, 0x2B, 0x17, 0x0B, 
    0x1D, 0x07, 0x24, 0x0A, 0x26, 0x01, 0x1B, 0x09, 0x2B, 0x02, 
    0x2E, 0x1A, 0x28, 0x0D, 0x25, 0x10, 0x21, 0x12, 0x04, 0x2F, 0x16, 
    
    0x10, 0x0C, 0x03, 0x1C, 0x0F, 0x1F, 0x14, 0x1B, 0x06, 0x30,         // 60
    0x19, 0x25, 0x03, 0x1D, 0x11, 0x03, 0x2B, 0x25, 0x01, 0x1C, 
    0x07, 0x22, 0x05, 0x30, 0x0A, 0x2C, 0x14, 0x03, 0x09, 0x22, 
    0x2D, 0x07, 0x30, 0x19, 0x0E, 0x2B, 0x25, 0x0B, 0x19, 0x06, 
    0x0E, 0x21, 0x02, 0x17, 0x2A, 0x11, 0x28, 0x18, 0x20, 0x2E, 
    0x12, 0x28, 0x1D, 0x09, 0x25, 0x19, 0x28, 0x2F, 0x13, 0x27, 
    0x31, 0x17, 0x24, 0x04, 0x21, 0x2C, 0x11, 0x08, 0x26, 0x04, 
    0x28, 0x14, 0x30, 0x12, 0x1F, 0x17, 0x2D, 0x21, 0x12, 0x1E, 
    0x15, 0x04, 0x21, 0x07, 0x1C, 0x2D, 0x03, 0x26, 0x1A, 0x0A, 0x24, 
    
    0x2C, 0x19, 0x26, 0x12, 0x2D, 0x08, 0x2B, 0x27, 0x1F, 0x0F,         // 61
    0x09, 0x2A, 0x10, 0x2C, 0x26, 0x1A, 0x0A, 0x1D, 0x10, 0x32, 
    0x14, 0x0C, 0x18, 0x20, 0x1C, 0x06, 0x18, 0x20, 0x2A, 0x15, 
    0x01, 0x1F, 0x13, 0x29, 0x09, 0x1B, 0x02, 0x2E, 0x21, 0x2A, 
    0x25, 0x09, 0x1C, 0x25, 0x07, 0x1F, 0x2E, 0x0A, 0x14, 0x29, 
    0x0C, 0x01, 0x2F, 0x0E, 0x1F, 0x01, 0x0C, 0x22, 0x04, 0x1A, 
    0x0E, 0x07, 0x13, 0x2F, 0x19, 0x07, 0x1F, 0x30, 0x13, 0x1A, 
    0x2D, 0x01, 0x1C, 0x08, 0x2B, 0x11, 0x0D, 0x05, 0x30, 0x08, 
    0x26, 0x0F, 0x32, 0x14, 0x2A, 0x0D, 0x17, 0x30, 0x0F, 0x2A, 0x03, 
    
    0x1D, 0x07, 0x31, 0x05, 0x17, 0x24, 0x0B, 0x12, 0x02, 0x2C,         // 62
    0x1C, 0x14, 0x22, 0x0D, 0x06, 0x30, 0x12, 0x22, 0x06, 0x29, 
    0x1E, 0x26, 0x2B, 0x00, 0x0E, 0x24, 0x2F, 0x10, 0x0C, 0x25, 
    0x18, 0x0C, 0x24, 0x05, 0x1F, 0x31, 0x10, 0x16, 0x0C, 0x03, 
    0x17, 0x31, 0x0F, 0x2C, 0x15, 0x0B, 0x1B, 0x02, 0x24, 0x07, 
    0x1A, 0x22, 0x18, 0x2A, 0x13, 0x2C, 0x1D, 0x17, 0x09, 0x24, 
    0x2C, 0x1F, 0x27, 0x0A, 0x10, 0x26, 0x16, 0x00, 0x24, 0x0D, 
    0x20, 0x10, 0x27, 0x18, 0x04, 0x23, 0x2A, 0x19, 0x25, 0x0E, 
    0x2B, 0x1E, 0x09, 0x1A, 0x02, 0x20, 0x06, 0x1D, 0x08, 0x21, 0x13, 
    
    0x0A, 0x22, 0x14, 0x28, 0x1F, 0x02, 0x1A, 0x31, 0x17, 0x21,         // 63
    0x07, 0x32, 0x01, 0x18, 0x1F, 0x15, 0x02, 0x2E, 0x17, 0x0A, 
    0x11, 0x04, 0x15, 0x2F, 0x12, 0x28, 0x02, 0x1E, 0x2C, 0x08, 
    0x31, 0x1C, 0x2A, 0x11, 0x17, 0x25, 0x07, 0x1E, 0x2C, 0x1B, 
    0x11, 0x1F, 0x05, 0x19, 0x03, 0x2F, 0x22, 0x10, 0x30, 0x1D, 
    0x2C, 0x11, 0x0A, 0x04, 0x22, 0x08, 0x10, 0x32, 0x29, 0x13, 
    0x00, 0x18, 0x06, 0x2D, 0x1D, 0x2A, 0x0B, 0x1D, 0x2A, 0x05, 
    0x17, 0x2F, 0x0B, 0x21, 0x31, 0x0A, 0x14, 0x03, 0x1D, 0x16, 
    0x00, 0x13, 0x2C, 0x27, 0x11, 0x2F, 0x25, 0x13, 0x27, 0x18, 0x2E, 
    
    0x29, 0x10, 0x1C, 0x0A, 0x13, 0x2E, 0x0E, 0x23, 0x04, 0x28,         // 64
    0x0F, 0x1B, 0x25, 0x2E, 0x08, 0x2A, 0x24, 0x0D, 0x26, 0x1B, 
    0x2D, 0x23, 0x09, 0x1A, 0x1F, 0x0B, 0x19, 0x13, 0x05, 0x20, 
    0x10, 0x04, 0x0A, 0x2E, 0x01, 0x0D, 0x2A, 0x13, 0x23, 0x08, 
    0x28, 0x2E, 0x0C, 0x22, 0x27, 0x0E, 0x17, 0x2A, 0x0B, 0x15, 
    0x02, 0x23, 0x28, 0x1C, 0x2F, 0x18, 0x25, 0x02, 0x0E, 0x1D, 
    0x2E, 0x0C, 0x22, 0x19, 0x0D, 0x03, 0x32, 0x11, 0x18, 0x2C, 
    0x09, 0x23, 0x03, 0x15, 0x0F, 0x1E, 0x26, 0x2F, 0x08, 0x2C, 
    0x24, 0x1B, 0x04, 0x22, 0x08, 0x16, 0x0C, 0x2B, 0x05, 0x0F, 0x00, 
    
    0x19, 0x30, 0x03, 0x2B, 0x22, 0x07, 0x29, 0x1C, 0x0B, 0x14,         // 65
    0x2D, 0x05, 0x0C, 0x12, 0x21, 0x0F, 0x19, 0x07, 0x2B, 0x01, 
    0x0F, 0x1D, 0x2A, 0x0E, 0x2C, 0x05, 0x31, 0x24, 0x28, 0x17, 
    0x2B, 0x25, 0x16, 0x21, 0x1D, 0x27, 0x19, 0x03, 0x2E, 0x0F, 
    0x00, 0x14, 0x1B, 0x2C, 0x08, 0x1F, 0x01, 0x25, 0x06, 0x20, 
    0x0D, 0x31, 0x06, 0x14, 0x0C, 0x07, 0x2A, 0x1B, 0x22, 0x09, 
    0x25, 0x14, 0x2A, 0x04, 0x24, 0x15, 0x21, 0x06, 0x23, 0x0E, 
    0x1C, 0x12, 0x29, 0x1B, 0x2D, 0x01, 0x18, 0x0C, 0x20, 0x12, 
    0x06, 0x2F, 0x0D, 0x18, 0x2E, 0x1E, 0x04, 0x1B, 0x32, 0x20, 0x25, 
    
    0x07, 0x0D, 0x27, 0x19, 0x0F, 0x1F, 0x16, 0x06, 0x2F, 0x1F,         // 66
    0x18, 0x23, 0x2B, 0x1B, 0x05, 0x31, 0x22, 0x13, 0x1F, 0x15, 
    0x31, 0x05, 0x16, 0x06, 0x25, 0x14, 0x1C, 0x0F, 0x0B, 0x00, 
    0x1B, 0x0D, 0x30, 0x09, 0x12, 0x06, 0x30, 0x0C, 0x22, 0x1A, 
    0x26, 0x1E, 0x06, 0x12, 0x18, 0x32, 0x13, 0x1B, 0x2F, 0x17, 
    0x27, 0x12, 0x21, 0x19, 0x2C, 0x1F, 0x13, 0x05, 0x15, 0x30, 
    0x03, 0x1B, 0x0F, 0x30, 0x12, 0x29, 0x1B, 0x0B, 0x2D, 0x02, 
    0x25, 0x31, 0x06, 0x0D, 0x23, 0x08, 0x2B, 0x10, 0x28, 0x19, 
    0x0B, 0x27, 0x20, 0x10, 0x01, 0x29, 0x23, 0x11, 0x17, 0x0B, 0x13, 
    
    0x1E, 0x23, 0x15, 0x06, 0x32, 0x00, 0x2C, 0x11, 0x26, 0x0D,         // 67
    0x02, 0x13, 0x0A, 0x27, 0x16, 0x0C, 0x03, 0x2E, 0x08, 0x23, 
    0x0B, 0x28, 0x20, 0x30, 0x10, 0x21, 0x03, 0x2A, 0x1E, 0x30, 
    0x12, 0x20, 0x03, 0x1A, 0x2C, 0x23, 0x16, 0x1E, 0x07, 0x15, 
    0x31, 0x0A, 0x2A, 0x24, 0x04, 0x0C, 0x2A, 0x07, 0x0E, 0x2B, 
    0x03, 0x1E, 0x09, 0x28, 0x01, 0x10, 0x2F, 0x27, 0x0B, 0x29, 
    0x11, 0x21, 0x08, 0x1E, 0x0A, 0x01, 0x2F, 0x16, 0x28, 0x14, 
    0x1A, 0x0F, 0x20, 0x17, 0x28, 0x14, 0x1D, 0x24, 0x02, 0x32, 
    0x1F, 0x14, 0x05, 0x2A, 0x1B, 0x15, 0x0D, 0x26, 0x03, 0x2E, 0x28, 
    
    0x01, 0x2F, 0x09, 0x1D, 0x26, 0x0C, 0x1A, 0x21, 0x04, 0x1C,         // 68
    0x28, 0x31, 0x1D, 0x00, 0x2C, 0x1F, 0x29, 0x18, 0x10, 0x2B, 
    0x19, 0x12, 0x01, 0x1B, 0x08, 0x17, 0x2E, 0x09, 0x14, 0x25, 
    0x08, 0x2A, 0x15, 0x26, 0x0E, 0x02, 0x11, 0x27, 0x2B, 0x10, 
    0x04, 0x20, 0x0E, 0x2E, 0x21, 0x1B, 0x26, 0x1E, 0x13, 0x22, 
    0x0C, 0x17, 0x2E, 0x0D, 0x25, 0x19, 0x07, 0x21, 0x1C, 0x17, 
    0x07, 0x2C, 0x28, 0x16, 0x25, 0x19, 0x20, 0x07, 0x0D, 0x22, 
    0x0A, 0x2B, 0x03, 0x2F, 0x0B, 0x05, 0x2E, 0x09, 0x1B, 0x0F, 
    0x04, 0x2C, 0x19, 0x24, 0x0B, 0x31, 0x07, 0x2C, 0x1D, 0x09, 0x16, 
    
    0x1A, 0x0E, 0x2B, 0x12, 0x22, 0x14, 0x29, 0x0A, 0x30, 0x15,         // 69
    0x07, 0x10, 0x22, 0x0E, 0x19, 0x11, 0x0A, 0x26, 0x02, 0x1E, 
    0x09, 0x24, 0x2A, 0x0C, 0x2C, 0x26, 0x0E, 0x1A, 0x20, 0x05, 
    0x2E, 0x0B, 0x1E, 0x05, 0x29, 0x1C, 0x2F, 0x0C, 0x01, 0x1D, 
    0x28, 0x1A, 0x14, 0x01, 0x17, 0x10, 0x05, 0x2E, 0x00, 0x19, 
    0x24, 0x29, 0x05, 0x14, 0x1D, 0x2C, 0x0E, 0x15, 0x01, 0x2E, 
    0x1F, 0x13, 0x02, 0x0D, 0x2B, 0x06, 0x10, 0x2C, 0x1C, 0x30, 
    0x05, 0x27, 0x14, 0x1E, 0x22, 0x19, 0x0F, 0x21, 0x14, 0x2D, 
    0x25, 0x09, 0x11, 0x2F, 0x03, 0x1E, 0x12, 0x19, 0x22, 0x10, 0x2A, 
    
    0x20, 0x27, 0x17, 0x02, 0x0A, 0x2E, 0x03, 0x1D, 0x10, 0x24,         // 70
    0x2D, 0x1B, 0x09, 0x26, 0x30, 0x06, 0x21, 0x1A, 0x32, 0x14, 
    0x2D, 0x06, 0x16, 0x1F, 0x12, 0x07, 0x23, 0x02, 0x2C, 0x0F, 
    0x17, 0x23, 0x11, 0x31, 0x14, 0x0A, 0x20, 0x18, 0x24, 0x2D, 
    0x16, 0x07, 0x30, 0x25, 0x09, 0x2A, 0x14, 0x23, 0x0B, 0x31, 
    0x07, 0x11, 0x1F, 0x30, 0x09, 0x03, 0x23, 0x32, 0x0D, 0x24, 
    0x0A, 0x1A, 0x2F, 0x1C, 0x12, 0x31, 0x24, 0x18, 0x00, 0x12, 
    0x1E, 0x19, 0x09, 0x0F, 0x01, 0x26, 0x30, 0x04, 0x28, 0x0B, 
    0x16, 0x1C, 0x20, 0x0D, 0x16, 0x21, 0x2B, 0x00, 0x0C, 0x31, 0x04, 
    
    0x0B, 0x05, 0x23, 0x31, 0x1E, 0x18, 0x13, 0x28, 0x06, 0x1F,         // 71
    0x02, 0x15, 0x2B, 0x04, 0x23, 0x14, 0x2C, 0x0E, 0x08, 0x21, 
    0x0F, 0x1B, 0x30, 0x04, 0x2A, 0x1A, 0x32, 0x12, 0x27, 0x1D, 
    0x01, 0x29, 0x07, 0x18, 0x24, 0x04, 0x2D, 0x08, 0x13, 0x05, 
    0x0D, 0x23, 0x0B, 0x1C, 0x2D, 0x1F, 0x0D, 0x1C, 0x26, 0x15, 
    0x2B, 0x1A, 0x02, 0x24, 0x17, 0x2A, 0x12, 0x1A, 0x28, 0x04, 
    0x11, 0x26, 0x05, 0x23, 0x09, 0x1F, 0x04, 0x0D, 0x28, 0x23, 
    0x0C, 0x2C, 0x24, 0x32, 0x29, 0x11, 0x17, 0x0D, 0x1C, 0x21, 
    0x06, 0x2E, 0x01, 0x25, 0x2A, 0x06, 0x0E, 0x27, 0x16, 0x24, 0x14, 
    
    0x2F, 0x1D, 0x15, 0x0D, 0x29, 0x08, 0x21, 0x2D, 0x0C, 0x17,         // 72
    0x27, 0x0C, 0x20, 0x18, 0x0D, 0x1D, 0x01, 0x25, 0x19, 0x29, 
    0x02, 0x25, 0x0A, 0x10, 0x22, 0x14, 0x05, 0x20, 0x09, 0x19, 
    0x30, 0x0C, 0x1E, 0x2D, 0x0D, 0x1F, 0x11, 0x27, 0x1C, 0x32, 
    0x1F, 0x2C, 0x12, 0x04, 0x16, 0x02, 0x30, 0x08, 0x11, 0x03, 
    0x21, 0x0E, 0x28, 0x0B, 0x1E, 0x0E, 0x20, 0x06, 0x15, 0x1D, 
    0x30, 0x16, 0x0E, 0x2C, 0x18, 0x13, 0x2A, 0x1E, 0x14, 0x2F, 
    0x07, 0x17, 0x04, 0x13, 0x1A, 0x06, 0x1F, 0x2B, 0x01, 0x31, 
    0x13, 0x27, 0x18, 0x0A, 0x11, 0x1A, 0x2D, 0x1E, 0x08, 0x1B, 0x29, 
    
    0x12, 0x08, 0x2C, 0x04, 0x11, 0x26, 0x05, 0x11, 0x1B, 0x32,         // 73
    0x08, 0x2C, 0x11, 0x31, 0x08, 0x2A, 0x11, 0x2F, 0x06, 0x13, 
    0x2E, 0x16, 0x1E, 0x27, 0x00, 0x2E, 0x0E, 0x17, 0x2D, 0x04, 
    0x12, 0x22, 0x14, 0x03, 0x26, 0x17, 0x02, 0x2B, 0x0A, 0x11, 
    0x00, 0x18, 0x27, 0x22, 0x0F, 0x29, 0x24, 0x18, 0x28, 0x2E, 
    0x1B, 0x07, 0x31, 0x13, 0x2C, 0x00, 0x2F, 0x0B, 0x2B, 0x21, 
    0x0A, 0x29, 0x1F, 0x01, 0x27, 0x07, 0x2F, 0x0A, 0x03, 0x1A, 
    0x10, 0x2B, 0x20, 0x0C, 0x22, 0x2D, 0x0A, 0x26, 0x11, 0x1A, 
    0x0D, 0x07, 0x2B, 0x1E, 0x31, 0x23, 0x03, 0x13, 0x30, 0x02, 0x0D, 
    
    0x19, 0x27, 0x22, 0x1F, 0x1A, 0x30, 0x16, 0x20, 0x02, 0x23,         // 74
    0x14, 0x1D, 0x01, 0x27, 0x1E, 0x15, 0x22, 0x0B, 0x1C, 0x20, 
    0x0D, 0x08, 0x31, 0x19, 0x0B, 0x1D, 0x28, 0x23, 0x0C, 0x25, 
    0x2A, 0x08, 0x1A, 0x2B, 0x0B, 0x30, 0x1D, 0x14, 0x24, 0x1A, 
    0x29, 0x0E, 0x06, 0x31, 0x1A, 0x07, 0x14, 0x04, 0x1F, 0x0C, 
    0x14, 0x23, 0x18, 0x09, 0x1C, 0x26, 0x17, 0x25, 0x0F, 0x02, 
    0x19, 0x06, 0x10, 0x30, 0x0D, 0x1A, 0x21, 0x16, 0x2D, 0x20, 
    0x26, 0x03, 0x1B, 0x29, 0x00, 0x0F, 0x16, 0x20, 0x08, 0x29, 
    0x1F, 0x23, 0x14, 0x04, 0x0F, 0x09, 0x18, 0x28, 0x0F, 0x25, 0x20, 
    
    0x2E, 0x00, 0x0C, 0x15, 0x03, 0x23, 0x0E, 0x2D, 0x0B, 0x2A,         // 75
    0x06, 0x22, 0x19, 0x0D, 0x04, 0x2D, 0x06, 0x18, 0x26, 0x04, 
    0x28, 0x1B, 0x06, 0x11, 0x2B, 0x15, 0x08, 0x02, 0x1E, 0x16, 
    0x0F, 0x31, 0x24, 0x06, 0x12, 0x22, 0x0F, 0x08, 0x2E, 0x04, 
    0x20, 0x2E, 0x15, 0x1F, 0x0A, 0x2C, 0x21, 0x10, 0x32, 0x06, 
    0x27, 0x01, 0x2D, 0x21, 0x04, 0x11, 0x08, 0x1B, 0x30, 0x14, 
    0x24, 0x2D, 0x1B, 0x15, 0x24, 0x05, 0x11, 0x27, 0x0E, 0x08, 
    0x12, 0x31, 0x09, 0x16, 0x23, 0x31, 0x1C, 0x03, 0x2D, 0x16, 
    0x02, 0x10, 0x2C, 0x19, 0x26, 0x2E, 0x1D, 0x04, 0x2C, 0x16, 0x06, 
    
    0x13, 0x1C, 0x30, 0x28, 0x0A, 0x2B, 0x06, 0x1E, 0x18, 0x11,         // 76
    0x26, 0x0F, 0x2F, 0x15, 0x24, 0x1C, 0x10, 0x31, 0x13, 0x2C, 
    0x10, 0x21, 0x2C, 0x24, 0x04, 0x21, 0x31, 0x14, 0x2B, 0x07, 
    0x1B, 0x00, 0x14, 0x1D, 0x28, 0x01, 0x2C, 0x1F, 0x17, 0x12, 
    0x0C, 0x08, 0x24, 0x02, 0x12, 0x26, 0x0B, 0x1C, 0x25, 0x17, 
    0x0E, 0x2A, 0x14, 0x0D, 0x29, 0x31, 0x1F, 0x03, 0x22, 0x09, 
    0x2A, 0x07, 0x20, 0x03, 0x2A, 0x1D, 0x31, 0x01, 0x1D, 0x2B, 
    0x17, 0x1E, 0x0F, 0x2C, 0x11, 0x05, 0x27, 0x13, 0x23, 0x0C, 
    0x32, 0x25, 0x07, 0x1F, 0x00, 0x12, 0x22, 0x0D, 0x1F, 0x09, 0x29, 
    
    0x21, 0x07, 0x0F, 0x14, 0x20, 0x19, 0x13, 0x29, 0x00, 0x30,         // 77
    0x1F, 0x04, 0x28, 0x0B, 0x2C, 0x09, 0x28, 0x01, 0x1E, 0x07, 
    0x18, 0x02, 0x12, 0x1D, 0x0A, 0x1A, 0x0F, 0x25, 0x0D, 0x2E, 
    0x21, 0x28, 0x0D, 0x2D, 0x16, 0x0C, 0x1A, 0x06, 0x28, 0x30, 
    0x1C, 0x2A, 0x19, 0x2C, 0x17, 0x30, 0x00, 0x16, 0x09, 0x2D, 
    0x1B, 0x20, 0x08, 0x1D, 0x18, 0x0A, 0x13, 0x2D, 0x0C, 0x19, 
    0x1E, 0x13, 0x0C, 0x2F, 0x0F, 0x16, 0x0A, 0x22, 0x14, 0x05, 
    0x23, 0x02, 0x26, 0x07, 0x20, 0x1A, 0x0A, 0x2E, 0x06, 0x1D, 
    0x18, 0x13, 0x0C, 0x2E, 0x17, 0x28, 0x06, 0x15, 0x32, 0x1A, 0x0E, 
    
    0x2F, 0x26, 0x1E, 0x2C, 0x02, 0x31, 0x09, 0x24, 0x0D, 0x1B,         // 78
    0x14, 0x0A, 0x17, 0x20, 0x02, 0x13, 0x19, 0x21, 0x0E, 0x2F, 
    0x25, 0x1C, 0x32, 0x0E, 0x27, 0x2D, 0x01, 0x1F, 0x18, 0x04, 
    0x13, 0x09, 0x1F, 0x04, 0x24, 0x32, 0x13, 0x25, 0x0D, 0x01, 
    0x22, 0x13, 0x04, 0x0D, 0x21, 0x0F, 0x1E, 0x2B, 0x22, 0x03, 
    0x12, 0x05, 0x30, 0x24, 0x01, 0x28, 0x1A, 0x26, 0x11, 0x28, 
    0x00, 0x2D, 0x22, 0x19, 0x05, 0x20, 0x2C, 0x0F, 0x28, 0x30, 
    0x0C, 0x2D, 0x1A, 0x14, 0x30, 0x0E, 0x29, 0x19, 0x10, 0x29, 
    0x01, 0x21, 0x2A, 0x1C, 0x09, 0x0F, 0x2B, 0x23, 0x01, 0x25, 0x05, 
    
    0x10, 0x1A, 0x05, 0x0D, 0x23, 0x10, 0x1D, 0x15, 0x2E, 0x06,         // 79
    0x2A, 0x23, 0x32, 0x10, 0x1E, 0x25, 0x30, 0x08, 0x29, 0x14, 
    0x0C, 0x08, 0x29, 0x04, 0x18, 0x08, 0x14, 0x2F, 0x0B, 0x23, 
    0x2B, 0x18, 0x30, 0x11, 0x0A, 0x1D, 0x03, 0x2C, 0x1F, 0x17, 
    0x08, 0x27, 0x32, 0x1E, 0x08, 0x29, 0x06, 0x12, 0x0B, 0x2F, 
    0x1E, 0x26, 0x0B, 0x13, 0x2D, 0x0F, 0x05, 0x21, 0x08, 0x31, 
    0x15, 0x0E, 0x06, 0x27, 0x13, 0x26, 0x02, 0x1A, 0x08, 0x16, 
    0x1C, 0x11, 0x08, 0x2A, 0x05, 0x24, 0x02, 0x20, 0x09, 0x24, 
    0x2E, 0x08, 0x11, 0x03, 0x31, 0x1F, 0x19, 0x0B, 0x13, 0x2B, 0x17, 
    
    0x02, 0x2B, 0x15, 0x28, 0x19, 0x06, 0x2C, 0x03, 0x20, 0x27,         // 80
    0x11, 0x01, 0x1A, 0x06, 0x2D, 0x0C, 0x04, 0x17, 0x1D, 0x02, 
    0x2D, 0x19, 0x22, 0x14, 0x1F, 0x2B, 0x24, 0x06, 0x29, 0x1C, 
    0x0F, 0x05, 0x26, 0x1A, 0x2A, 0x22, 0x15, 0x08, 0x11, 0x2F, 
    0x1A, 0x10, 0x0A, 0x17, 0x25, 0x14, 0x2F, 0x1B, 0x28, 0x15, 
    0x0D, 0x2C, 0x16, 0x1C, 0x07, 0x1F, 0x2F, 0x14, 0x1D, 0x05, 
    0x20, 0x2A, 0x1B, 0x32, 0x0B, 0x1C, 0x2F, 0x12, 0x20, 0x26, 
    0x00, 0x21, 0x26, 0x1C, 0x0F, 0x16, 0x2C, 0x12, 0x30, 0x15, 
    0x0E, 0x1A, 0x27, 0x17, 0x24, 0x13, 0x04, 0x2F, 0x1C, 0x08, 0x1F, 
    
    0x25, 0x0C, 0x20, 0x09, 0x2F, 0x13, 0x27, 0x0E, 0x19, 0x09,         // 81
    0x1E, 0x2D, 0x0B, 0x27, 0x1B, 0x15, 0x2A, 0x24, 0x0E, 0x20, 
    0x27, 0x10, 0x00, 0x30, 0x0A, 0x0E, 0x1D, 0x11, 0x16, 0x03, 
    0x2F, 0x1E, 0x09, 0x13, 0x04, 0x0E, 0x2E, 0x1B, 0x28, 0x04, 
    0x24, 0x2D, 0x22, 0x05, 0x2C, 0x01, 0x0E, 0x20, 0x04, 0x19, 
    0x01, 0x20, 0x09, 0x25, 0x2A, 0x17, 0x02, 0x2A, 0x0B, 0x27, 
    0x17, 0x03, 0x12, 0x08, 0x1F, 0x0F, 0x07, 0x29, 0x05, 0x2C, 
    0x0C, 0x31, 0x13, 0x03, 0x2E, 0x1F, 0x08, 0x1C, 0x03, 0x22, 
    0x05, 0x1F, 0x2C, 0x0A, 0x0E, 0x2D, 0x26, 0x0F, 0x22, 0x0D, 0x31, 
    
    0x12, 0x1B, 0x2E, 0x00, 0x1B, 0x1F, 0x07, 0x23, 0x14, 0x31,         // 82
    0x0E, 0x16, 0x21, 0x13, 0x08, 0x21, 0x10, 0x09, 0x31, 0x16, 
    0x06, 0x1B, 0x25, 0x13, 0x2A, 0x19, 0x02, 0x31, 0x21, 0x0C, 
    0x25, 0x10, 0x2B, 0x23, 0x30, 0x18, 0x00, 0x23, 0x0A, 0x17, 
    0x0C, 0x02, 0x1C, 0x12, 0x1F, 0x19, 0x26, 0x0A, 0x32, 0x24, 
    0x2A, 0x12, 0x30, 0x03, 0x11, 0x0C, 0x24, 0x1A, 0x11, 0x2E, 
    0x0E, 0x25, 0x2D, 0x22, 0x15, 0x2E, 0x23, 0x1B, 0x15, 0x10, 
    0x1E, 0x17, 0x0A, 0x28, 0x18, 0x0E, 0x27, 0x0C, 0x25, 0x19, 
    0x2F, 0x12, 0x00, 0x22, 0x1C, 0x09, 0x16, 0x01, 0x2C, 0x17, 0x07, 
    
    0x2D, 0x05, 0x0F, 0x23, 0x11, 0x0B, 0x29, 0x2D, 0x01, 0x22,         // 83
    0x06, 0x2A, 0x03, 0x30, 0x28, 0x00, 0x2E, 0x1D, 0x03, 0x2A, 
    0x0C, 0x2E, 0x08, 0x1C, 0x04, 0x26, 0x2C, 0x0A, 0x19, 0x2B, 
    0x16, 0x01, 0x1B, 0x15, 0x07, 0x21, 0x2A, 0x11, 0x31, 0x20, 
    0x2A, 0x14, 0x25, 0x0D, 0x31, 0x09, 0x2C, 0x17, 0x11, 0x08, 
    0x1C, 0x06, 0x18, 0x1E, 0x2B, 0x1D, 0x32, 0x07, 0x22, 0x01, 
    0x1E, 0x0A, 0x18, 0x05, 0x2A, 0x02, 0x13, 0x0A, 0x30, 0x24, 
    0x04, 0x2B, 0x1F, 0x06, 0x24, 0x01, 0x32, 0x17, 0x2B, 0x07, 
    0x0E, 0x26, 0x15, 0x32, 0x05, 0x29, 0x20, 0x1B, 0x11, 0x28, 0x1F, 
    
    0x14, 0x25, 0x17, 0x2A, 0x32, 0x16, 0x04, 0x1E, 0x12, 0x1B,         // 84
    0x26, 0x18, 0x0F, 0x1C, 0x0C, 0x1A, 0x15, 0x25, 0x12, 0x19, 
    0x21, 0x11, 0x28, 0x23, 0x0F, 0x16, 0x08, 0x23, 0x10, 0x05, 
    0x1F, 0x32, 0x0B, 0x28, 0x11, 0x1C, 0x09, 0x18, 0x05, 0x0E, 
    0x1A, 0x2F, 0x07, 0x28, 0x03, 0x13, 0x1E, 0x05, 0x22, 0x2D, 
    0x15, 0x28, 0x0E, 0x26, 0x05, 0x12, 0x0A, 0x16, 0x2A, 0x19, 
    0x31, 0x13, 0x29, 0x1E, 0x0D, 0x19, 0x28, 0x1F, 0x01, 0x2A, 
    0x0B, 0x19, 0x0D, 0x2D, 0x1B, 0x14, 0x22, 0x05, 0x13, 0x22, 
    0x1C, 0x09, 0x2A, 0x1E, 0x13, 0x0F, 0x2F, 0x08, 0x25, 0x0C, 0x02, 
    
    0x29, 0x08, 0x1E, 0x03, 0x09, 0x26, 0x1C, 0x0E, 0x2F, 0x09,         // 85
    0x0D, 0x2D, 0x20, 0x07, 0x24, 0x2C, 0x05, 0x0B, 0x28, 0x07, 
    0x30, 0x02, 0x17, 0x0B, 0x32, 0x1F, 0x12, 0x1B, 0x2F, 0x26, 
    0x09, 0x11, 0x24, 0x04, 0x2F, 0x0C, 0x25, 0x2E, 0x1D, 0x24, 
    0x01, 0x11, 0x20, 0x16, 0x1B, 0x2A, 0x0F, 0x27, 0x1A, 0x0C, 
    0x03, 0x21, 0x2F, 0x0A, 0x1A, 0x2E, 0x27, 0x1F, 0x04, 0x0F, 
    0x08, 0x22, 0x04, 0x11, 0x24, 0x2D, 0x07, 0x0F, 0x17, 0x1D, 
    0x12, 0x30, 0x23, 0x12, 0x09, 0x2E, 0x0B, 0x1B, 0x2C, 0x02, 
    0x30, 0x18, 0x10, 0x02, 0x19, 0x26, 0x03, 0x15, 0x1D, 0x31, 0x19, 
    
    0x10, 0x30, 0x0D, 0x22, 0x19, 0x11, 0x2C, 0x06, 0x23, 0x17,         // 86
    0x28, 0x04, 0x15, 0x30, 0x13, 0x0D, 0x1F, 0x2E, 0x1C, 0x0F, 
    0x1F, 0x14, 0x2B, 0x1B, 0x01, 0x27, 0x06, 0x2A, 0x02, 0x15, 
    0x1C, 0x2D, 0x19, 0x1F, 0x15, 0x2B, 0x02, 0x14, 0x07, 0x2C, 
    0x27, 0x09, 0x2D, 0x0C, 0x24, 0x09, 0x2E, 0x02, 0x12, 0x2F, 
    0x1E, 0x10, 0x04, 0x14, 0x22, 0x00, 0x0E, 0x14, 0x2F, 0x26, 
    0x1D, 0x2B, 0x0B, 0x30, 0x15, 0x0A, 0x22, 0x32, 0x27, 0x06, 
    0x21, 0x0A, 0x03, 0x1E, 0x29, 0x04, 0x1F, 0x0F, 0x26, 0x0D, 
    0x21, 0x06, 0x28, 0x23, 0x30, 0x0C, 0x1F, 0x2D, 0x0B, 0x05, 0x22, 
    
    0x02, 0x1C, 0x15, 0x2E, 0x28, 0x01, 0x21, 0x15, 0x2A, 0x02,         // 87
    0x1F, 0x11, 0x25, 0x1B, 0x02, 0x27, 0x18, 0x12, 0x01, 0x29, 
    0x09, 0x25, 0x06, 0x22, 0x13, 0x2D, 0x0F, 0x18, 0x21, 0x0E, 
    0x29, 0x02, 0x0F, 0x09, 0x22, 0x10, 0x1B, 0x21, 0x0D, 0x12, 
    0x17, 0x1E, 0x14, 0x29, 0x00, 0x1E, 0x15, 0x22, 0x29, 0x0B, 
    0x25, 0x18, 0x29, 0x1D, 0x2C, 0x18, 0x23, 0x06, 0x1B, 0x12, 
    0x02, 0x16, 0x1A, 0x26, 0x01, 0x1F, 0x17, 0x03, 0x11, 0x2C, 
    0x15, 0x26, 0x2D, 0x16, 0x0E, 0x25, 0x17, 0x2F, 0x06, 0x16, 
    0x1B, 0x2E, 0x0E, 0x08, 0x1C, 0x06, 0x13, 0x27, 0x11, 0x2A, 0x16, 
    
    0x2D, 0x26, 0x0A, 0x05, 0x13, 0x0C, 0x30, 0x08, 0x1B, 0x12,         // 88
    0x32, 0x08, 0x2C, 0x0B, 0x20, 0x2B, 0x09, 0x32, 0x23, 0x15, 
    0x2D, 0x1A, 0x0F, 0x2E, 0x08, 0x1A, 0x24, 0x09, 0x31, 0x07, 
    0x23, 0x16, 0x28, 0x31, 0x04, 0x26, 0x0A, 0x28, 0x31, 0x20, 
    0x03, 0x2F, 0x05, 0x1B, 0x12, 0x31, 0x0D, 0x19, 0x08, 0x16, 
    0x01, 0x32, 0x07, 0x11, 0x0C, 0x08, 0x2E, 0x29, 0x0D, 0x22, 
    0x2D, 0x0E, 0x20, 0x08, 0x2C, 0x11, 0x29, 0x1B, 0x0A, 0x1F, 
    0x00, 0x0D, 0x19, 0x05, 0x31, 0x20, 0x01, 0x12, 0x23, 0x28, 
    0x01, 0x13, 0x1F, 0x15, 0x2D, 0x18, 0x23, 0x00, 0x1A, 0x1F, 0x09, 
    
    0x18, 0x11, 0x1F, 0x2C, 0x24, 0x18, 0x1E, 0x10, 0x26, 0x0B,         // 89
    0x24, 0x1C, 0x03, 0x18, 0x11, 0x05, 0x1D, 0x0F, 0x06, 0x1F, 
    0x0C, 0x02, 0x27, 0x16, 0x20, 0x03, 0x29, 0x15, 0x1E, 0x12, 
    0x2C, 0x0A, 0x1D, 0x13, 0x1A, 0x2E, 0x15, 0x02, 0x18, 0x09, 
    0x26, 0x0F, 0x22, 0x2C, 0x08, 0x26, 0x04, 0x2D, 0x1F, 0x2B, 
    0x1C, 0x0D, 0x21, 0x2E, 0x26, 0x15, 0x1D, 0x03, 0x18, 0x09, 
    0x28, 0x05, 0x2F, 0x13, 0x1B, 0x0C, 0x05, 0x2E, 0x26, 0x18, 
    0x31, 0x22, 0x2A, 0x12, 0x1C, 0x0C, 0x2B, 0x1A, 0x08, 0x32, 
    0x0B, 0x2B, 0x25, 0x03, 0x29, 0x0E, 0x32, 0x0A, 0x2C, 0x0E, 0x23, 
    
    0x07, 0x29, 0x01, 0x1B, 0x07, 0x2A, 0x02, 0x2E, 0x05, 0x2B,         // 90
    0x16, 0x0E, 0x28, 0x2F, 0x23, 0x2C, 0x14, 0x27, 0x19, 0x2A, 
    0x12, 0x31, 0x1E, 0x0A, 0x11, 0x30, 0x0D, 0x05, 0x26, 0x02, 
    0x1B, 0x21, 0x03, 0x26, 0x06, 0x0F, 0x22, 0x2C, 0x11, 0x1D, 
    0x2B, 0x1A, 0x09, 0x11, 0x23, 0x16, 0x1C, 0x13, 0x06, 0x0F, 
    0x24, 0x14, 0x05, 0x19, 0x01, 0x21, 0x10, 0x25, 0x32, 0x1E, 
    0x11, 0x1B, 0x22, 0x02, 0x24, 0x31, 0x20, 0x15, 0x0F, 0x07, 
    0x12, 0x06, 0x1F, 0x09, 0x28, 0x06, 0x14, 0x21, 0x0E, 0x1D, 
    0x22, 0x19, 0x11, 0x0B, 0x20, 0x06, 0x1E, 0x16, 0x25, 0x05, 0x30, 
};

const BYTE HT_SuperCell_Green216[91*91] = {
    0x12, 0x0A, 0x2A, 0x0E, 0x06, 0x1B, 0x14, 0x24, 0x11, 0x2F,         //  0
    0x03, 0x1A, 0x07, 0x31, 0x05, 0x27, 0x2D, 0x13, 0x0F, 0x00, 
    0x21, 0x11, 0x1E, 0x05, 0x15, 0x23, 0x11, 0x19, 0x0C, 0x1E, 
    0x16, 0x2D, 0x18, 0x27, 0x1B, 0x13, 0x24, 0x2F, 0x0D, 0x17, 
    0x30, 0x15, 0x0F, 0x09, 0x31, 0x01, 0x2B, 0x18, 0x1E, 0x0C, 
    0x12, 0x04, 0x2F, 0x12, 0x1D, 0x07, 0x28, 0x2E, 0x03, 0x0F, 
    0x06, 0x2C, 0x15, 0x02, 0x2E, 0x07, 0x29, 0x24, 0x12, 0x1A, 
    0x07, 0x2E, 0x06, 0x0E, 0x1A, 0x05, 0x1D, 0x18, 0x08, 0x22, 
    0x1A, 0x27, 0x14, 0x31, 0x03, 0x20, 0x0B, 0x2F, 0x14, 0x2A, 0x00, 

    0x28, 0x19, 0x03, 0x1E, 0x27, 0x2B, 0x0D, 0x07, 0x27, 0x0E,         //  1
    0x2B, 0x14, 0x29, 0x21, 0x15, 0x0E, 0x03, 0x1E, 0x29, 0x31, 
    0x06, 0x2C, 0x19, 0x0C, 0x26, 0x2C, 0x09, 0x29, 0x03, 0x2B, 
    0x08, 0x12, 0x07, 0x21, 0x04, 0x2A, 0x0F, 0x1A, 0x02, 0x2B, 
    0x05, 0x21, 0x1C, 0x23, 0x16, 0x1D, 0x0B, 0x06, 0x25, 0x2B, 
    0x1C, 0x18, 0x24, 0x02, 0x2A, 0x0C, 0x18, 0x11, 0x21, 0x25, 
    0x17, 0x1D, 0x0E, 0x24, 0x1A, 0x1F, 0x17, 0x00, 0x0C, 0x28, 
    0x20, 0x0D, 0x1D, 0x26, 0x31, 0x12, 0x2A, 0x26, 0x14, 0x2B, 
    0x0B, 0x00, 0x24, 0x11, 0x19, 0x29, 0x05, 0x25, 0x1D, 0x08, 0x23, 

    0x0E, 0x21, 0x30, 0x12, 0x18, 0x01, 0x1F, 0x2E, 0x1C, 0x17,         //  2
    0x09, 0x1F, 0x0F, 0x0A, 0x2B, 0x1B, 0x2F, 0x17, 0x0B, 0x22, 
    0x15, 0x28, 0x07, 0x30, 0x10, 0x01, 0x16, 0x1D, 0x24, 0x0F, 
    0x26, 0x1F, 0x31, 0x0C, 0x2D, 0x1F, 0x06, 0x22, 0x12, 0x23, 
    0x27, 0x0D, 0x07, 0x2D, 0x05, 0x29, 0x14, 0x30, 0x10, 0x01, 
    0x09, 0x2D, 0x0C, 0x15, 0x30, 0x23, 0x04, 0x1E, 0x0A, 0x2E, 
    0x01, 0x27, 0x08, 0x31, 0x04, 0x0D, 0x2F, 0x21, 0x1C, 0x31, 
    0x03, 0x15, 0x2D, 0x01, 0x09, 0x23, 0x0C, 0x03, 0x20, 0x10, 
    0x30, 0x17, 0x1F, 0x07, 0x2D, 0x0F, 0x1F, 0x16, 0x0D, 0x32, 0x16, 

    0x2B, 0x07, 0x0B, 0x25, 0x0D, 0x31, 0x11, 0x16, 0x03, 0x22,         //  3
    0x30, 0x01, 0x26, 0x18, 0x02, 0x20, 0x0C, 0x25, 0x05, 0x1B, 
    0x09, 0x10, 0x23, 0x17, 0x1E, 0x22, 0x32, 0x0B, 0x13, 0x2F, 
    0x19, 0x01, 0x16, 0x11, 0x1A, 0x0A, 0x16, 0x32, 0x1C, 0x09, 
    0x14, 0x30, 0x18, 0x11, 0x26, 0x0E, 0x21, 0x19, 0x20, 0x17, 
    0x23, 0x28, 0x1E, 0x07, 0x1A, 0x0F, 0x29, 0x32, 0x13, 0x1B, 
    0x10, 0x2B, 0x13, 0x20, 0x16, 0x26, 0x08, 0x13, 0x05, 0x0F, 
    0x24, 0x1A, 0x11, 0x21, 0x16, 0x1C, 0x2F, 0x17, 0x08, 0x1C, 
    0x04, 0x28, 0x0D, 0x25, 0x15, 0x08, 0x2E, 0x02, 0x26, 0x1B, 0x04, 

    0x11, 0x17, 0x2D, 0x1A, 0x06, 0x28, 0x23, 0x08, 0x2C, 0x0D,         //  4
    0x13, 0x1D, 0x2D, 0x11, 0x32, 0x07, 0x14, 0x2B, 0x11, 0x2E, 
    0x26, 0x1D, 0x02, 0x2A, 0x06, 0x0E, 0x1A, 0x05, 0x21, 0x07, 
    0x0D, 0x22, 0x2B, 0x27, 0x03, 0x24, 0x29, 0x03, 0x0F, 0x2B, 
    0x02, 0x20, 0x29, 0x00, 0x1F, 0x08, 0x2D, 0x03, 0x0D, 0x2E, 
    0x11, 0x04, 0x0E, 0x22, 0x20, 0x00, 0x15, 0x08, 0x24, 0x04, 
    0x21, 0x07, 0x1B, 0x0A, 0x2D, 0x0F, 0x2A, 0x23, 0x2C, 0x17, 
    0x2B, 0x08, 0x2A, 0x0D, 0x2C, 0x04, 0x10, 0x29, 0x24, 0x2D, 
    0x12, 0x18, 0x2C, 0x03, 0x1C, 0x28, 0x1A, 0x11, 0x2C, 0x0B, 0x1F, 

    0x30, 0x1E, 0x02, 0x22, 0x14, 0x1C, 0x0B, 0x1A, 0x25, 0x29,         //  5
    0x19, 0x06, 0x0D, 0x1A, 0x23, 0x28, 0x1C, 0x01, 0x20, 0x16, 
    0x04, 0x31, 0x14, 0x0B, 0x2E, 0x13, 0x27, 0x2D, 0x15, 0x26, 
    0x2C, 0x12, 0x06, 0x1C, 0x0E, 0x2E, 0x13, 0x1F, 0x27, 0x17, 
    0x1D, 0x0B, 0x13, 0x1B, 0x32, 0x18, 0x11, 0x25, 0x2A, 0x06, 
    0x1A, 0x31, 0x17, 0x2C, 0x11, 0x2D, 0x26, 0x1D, 0x0D, 0x2C, 
    0x16, 0x30, 0x24, 0x01, 0x18, 0x1E, 0x02, 0x1B, 0x09, 0x0C, 
    0x1E, 0x04, 0x23, 0x1B, 0x07, 0x27, 0x1F, 0x02, 0x19, 0x0C, 
    0x26, 0x09, 0x1D, 0x10, 0x2F, 0x13, 0x09, 0x20, 0x06, 0x18, 0x25, 

    0x10, 0x0A, 0x2A, 0x0E, 0x2C, 0x03, 0x2F, 0x12, 0x01, 0x09,         //  6
    0x20, 0x2C, 0x25, 0x04, 0x14, 0x0B, 0x2E, 0x0E, 0x29, 0x0B, 
    0x1A, 0x0E, 0x21, 0x1B, 0x24, 0x02, 0x1F, 0x0E, 0x01, 0x1C, 
    0x0A, 0x18, 0x30, 0x14, 0x20, 0x0B, 0x19, 0x07, 0x0D, 0x2F, 
    0x06, 0x2D, 0x25, 0x0E, 0x05, 0x27, 0x0A, 0x1D, 0x15, 0x0A, 
    0x24, 0x1F, 0x02, 0x0D, 0x1B, 0x0A, 0x18, 0x03, 0x28, 0x19, 
    0x05, 0x0C, 0x13, 0x2E, 0x26, 0x0B, 0x15, 0x32, 0x13, 0x28, 
    0x2F, 0x16, 0x0B, 0x31, 0x13, 0x18, 0x0A, 0x30, 0x13, 0x1F, 
    0x01, 0x31, 0x22, 0x07, 0x23, 0x01, 0x26, 0x31, 0x14, 0x29, 0x01, 

    0x21, 0x15, 0x1B, 0x06, 0x20, 0x10, 0x27, 0x1F, 0x16, 0x31,         //  7
    0x0F, 0x15, 0x0A, 0x30, 0x21, 0x03, 0x17, 0x1E, 0x06, 0x23, 
    0x2D, 0x26, 0x08, 0x11, 0x2C, 0x17, 0x08, 0x2A, 0x18, 0x31, 
    0x20, 0x04, 0x24, 0x08, 0x28, 0x00, 0x30, 0x24, 0x1D, 0x13, 
    0x22, 0x16, 0x09, 0x2C, 0x21, 0x15, 0x2F, 0x02, 0x20, 0x2D, 
    0x13, 0x08, 0x26, 0x2A, 0x05, 0x31, 0x20, 0x13, 0x2E, 0x0F, 
    0x1F, 0x29, 0x21, 0x0D, 0x04, 0x2B, 0x22, 0x07, 0x25, 0x03, 
    0x1C, 0x11, 0x26, 0x00, 0x21, 0x2C, 0x10, 0x23, 0x06, 0x2B, 
    0x15, 0x1A, 0x0E, 0x17, 0x2A, 0x0E, 0x1A, 0x0B, 0x1F, 0x0F, 0x2C, 

    0x05, 0x2F, 0x24, 0x13, 0x32, 0x17, 0x04, 0x0C, 0x29, 0x1B,         //  8
    0x05, 0x27, 0x1D, 0x18, 0x0F, 0x27, 0x2B, 0x12, 0x30, 0x15, 
    0x01, 0x18, 0x2A, 0x04, 0x21, 0x0F, 0x2F, 0x23, 0x11, 0x06, 
    0x0E, 0x29, 0x1A, 0x12, 0x2C, 0x17, 0x10, 0x2A, 0x03, 0x0A, 
    0x28, 0x01, 0x1E, 0x19, 0x03, 0x0C, 0x29, 0x18, 0x0D, 0x28, 
    0x0F, 0x2E, 0x16, 0x1E, 0x14, 0x25, 0x0E, 0x07, 0x23, 0x02, 
    0x31, 0x09, 0x17, 0x1B, 0x12, 0x1F, 0x10, 0x2E, 0x0E, 0x16, 
    0x21, 0x06, 0x2A, 0x1C, 0x0D, 0x05, 0x28, 0x1A, 0x0E, 0x25, 
    0x08, 0x27, 0x05, 0x2F, 0x1F, 0x15, 0x2D, 0x04, 0x22, 0x08, 0x19, 

    0x1D, 0x0D, 0x01, 0x28, 0x08, 0x1B, 0x24, 0x2E, 0x08, 0x22,         //  9
    0x11, 0x2E, 0x00, 0x2B, 0x08, 0x1B, 0x06, 0x24, 0x0C, 0x1D, 
    0x0A, 0x20, 0x14, 0x31, 0x0A, 0x1D, 0x15, 0x03, 0x1E, 0x27, 
    0x15, 0x2E, 0x02, 0x0D, 0x22, 0x1D, 0x05, 0x20, 0x15, 0x1A, 
    0x31, 0x10, 0x2A, 0x13, 0x30, 0x1C, 0x11, 0x25, 0x07, 0x1C, 
    0x01, 0x19, 0x07, 0x0C, 0x29, 0x01, 0x1C, 0x2B, 0x16, 0x1B, 
    0x12, 0x26, 0x01, 0x23, 0x31, 0x09, 0x1A, 0x00, 0x1D, 0x2C, 
    0x0A, 0x30, 0x0E, 0x18, 0x2F, 0x15, 0x1F, 0x01, 0x2F, 0x20, 
    0x12, 0x2D, 0x1E, 0x11, 0x0A, 0x06, 0x27, 0x1C, 0x13, 0x30, 0x27, 

    0x11, 0x2C, 0x17, 0x1E, 0x10, 0x2B, 0x0D, 0x16, 0x1D, 0x03,         // 10
    0x17, 0x23, 0x0C, 0x15, 0x25, 0x31, 0x0F, 0x18, 0x04, 0x29, 
    0x2F, 0x10, 0x03, 0x1C, 0x26, 0x05, 0x29, 0x0C, 0x2D, 0x1A, 
    0x09, 0x21, 0x1D, 0x32, 0x06, 0x13, 0x2E, 0x0E, 0x2B, 0x25, 
    0x0C, 0x1F, 0x06, 0x26, 0x08, 0x23, 0x01, 0x2B, 0x13, 0x32, 
    0x21, 0x2B, 0x23, 0x30, 0x11, 0x17, 0x2F, 0x0B, 0x28, 0x07, 
    0x2C, 0x1D, 0x0F, 0x2C, 0x06, 0x27, 0x15, 0x24, 0x29, 0x04, 
    0x1A, 0x13, 0x20, 0x04, 0x25, 0x08, 0x2B, 0x0C, 0x17, 0x04, 
    0x1B, 0x0C, 0x01, 0x28, 0x24, 0x1A, 0x10, 0x2E, 0x00, 0x17, 0x0B, 

    0x20, 0x26, 0x0A, 0x2F, 0x06, 0x21, 0x01, 0x27, 0x0F, 0x30,         // 11
    0x2A, 0x06, 0x1B, 0x20, 0x12, 0x02, 0x1F, 0x2D, 0x26, 0x1B, 
    0x0D, 0x23, 0x2C, 0x17, 0x10, 0x2F, 0x19, 0x20, 0x10, 0x04, 
    0x2B, 0x0F, 0x08, 0x15, 0x24, 0x28, 0x09, 0x1B, 0x02, 0x13, 
    0x08, 0x18, 0x2E, 0x0F, 0x17, 0x2D, 0x0C, 0x1F, 0x19, 0x05, 
    0x0C, 0x14, 0x04, 0x1A, 0x09, 0x21, 0x05, 0x1E, 0x13, 0x22, 
    0x0D, 0x05, 0x29, 0x13, 0x1F, 0x0E, 0x2F, 0x08, 0x12, 0x0D, 
    0x23, 0x27, 0x0A, 0x2E, 0x10, 0x1C, 0x13, 0x24, 0x2A, 0x10, 
    0x30, 0x22, 0x15, 0x19, 0x32, 0x03, 0x20, 0x09, 0x23, 0x29, 0x06, 

    0x14, 0x1A, 0x04, 0x24, 0x14, 0x1A, 0x31, 0x0A, 0x21, 0x15,         // 12
    0x0D, 0x26, 0x11, 0x2F, 0x0A, 0x29, 0x16, 0x0A, 0x11, 0x00, 
    0x18, 0x07, 0x28, 0x0B, 0x21, 0x07, 0x12, 0x00, 0x31, 0x24, 
    0x14, 0x26, 0x18, 0x2A, 0x01, 0x10, 0x18, 0x26, 0x30, 0x1E, 
    0x2C, 0x23, 0x01, 0x21, 0x1B, 0x06, 0x15, 0x2F, 0x0F, 0x27, 
    0x1B, 0x29, 0x10, 0x1F, 0x2C, 0x27, 0x12, 0x2A, 0x00, 0x19, 
    0x30, 0x21, 0x1B, 0x0A, 0x17, 0x02, 0x22, 0x1C, 0x2C, 0x17, 
    0x31, 0x02, 0x15, 0x1E, 0x28, 0x02, 0x32, 0x05, 0x1D, 0x09, 
    0x27, 0x06, 0x2B, 0x08, 0x0D, 0x13, 0x2B, 0x18, 0x0D, 0x1C, 0x2D, 

    0x0C, 0x31, 0x0E, 0x2A, 0x1E, 0x09, 0x12, 0x2A, 0x19, 0x05,         // 13
    0x1E, 0x09, 0x2A, 0x03, 0x19, 0x24, 0x05, 0x1D, 0x22, 0x30, 
    0x27, 0x1E, 0x14, 0x02, 0x2D, 0x1C, 0x2A, 0x26, 0x18, 0x0C, 
    0x1F, 0x05, 0x30, 0x0C, 0x1D, 0x2F, 0x22, 0x04, 0x0D, 0x11, 
    0x06, 0x29, 0x13, 0x0C, 0x2B, 0x26, 0x1D, 0x03, 0x23, 0x09, 
    0x2E, 0x00, 0x25, 0x16, 0x02, 0x0E, 0x1B, 0x0A, 0x2E, 0x10, 
    0x08, 0x16, 0x03, 0x2F, 0x23, 0x2B, 0x18, 0x04, 0x0B, 0x1F, 
    0x08, 0x1B, 0x2C, 0x07, 0x0D, 0x18, 0x20, 0x0F, 0x16, 0x22, 
    0x14, 0x1C, 0x10, 0x1F, 0x2D, 0x1D, 0x25, 0x05, 0x31, 0x11, 0x02, 

    0x27, 0x21, 0x17, 0x01, 0x11, 0x2D, 0x22, 0x03, 0x0E, 0x23,         // 14
    0x2D, 0x18, 0x14, 0x22, 0x0E, 0x2E, 0x13, 0x2B, 0x0D, 0x16, 
    0x09, 0x0F, 0x32, 0x1A, 0x25, 0x0D, 0x14, 0x09, 0x1D, 0x04, 
    0x2E, 0x0E, 0x1B, 0x23, 0x06, 0x12, 0x0A, 0x16, 0x2A, 0x21, 
    0x18, 0x0B, 0x1C, 0x2F, 0x04, 0x11, 0x0A, 0x28, 0x12, 0x1D, 
    0x14, 0x0D, 0x31, 0x07, 0x21, 0x30, 0x15, 0x26, 0x21, 0x1D, 
    0x27, 0x2B, 0x13, 0x26, 0x0B, 0x07, 0x12, 0x30, 0x26, 0x13, 
    0x28, 0x0E, 0x22, 0x13, 0x25, 0x2C, 0x09, 0x27, 0x2E, 0x01, 
    0x0D, 0x31, 0x03, 0x25, 0x12, 0x04, 0x0B, 0x15, 0x27, 0x21, 0x19, 

    0x05, 0x0B, 0x1D, 0x2E, 0x25, 0x06, 0x15, 0x1C, 0x30, 0x28,         // 15
    0x0D, 0x01, 0x32, 0x1D, 0x06, 0x1F, 0x08, 0x25, 0x02, 0x1C, 
    0x29, 0x04, 0x20, 0x09, 0x15, 0x05, 0x30, 0x21, 0x10, 0x29, 
    0x13, 0x27, 0x02, 0x14, 0x2C, 0x26, 0x1E, 0x2E, 0x1A, 0x00, 
    0x32, 0x25, 0x05, 0x1F, 0x16, 0x21, 0x31, 0x17, 0x2D, 0x04, 
    0x26, 0x19, 0x1E, 0x12, 0x29, 0x0C, 0x1E, 0x03, 0x08, 0x14, 
    0x0C, 0x05, 0x1E, 0x0F, 0x1A, 0x28, 0x1E, 0x0E, 0x20, 0x01, 
    0x2D, 0x06, 0x1A, 0x30, 0x00, 0x1C, 0x14, 0x06, 0x1A, 0x2B, 
    0x23, 0x19, 0x29, 0x09, 0x17, 0x27, 0x2F, 0x1B, 0x0F, 0x07, 0x2E, 

    0x13, 0x2B, 0x15, 0x08, 0x0F, 0x1E, 0x2C, 0x0B, 0x12, 0x04,         // 16
    0x1A, 0x25, 0x11, 0x0B, 0x2B, 0x17, 0x10, 0x31, 0x20, 0x12, 
    0x2E, 0x24, 0x12, 0x29, 0x2C, 0x1F, 0x19, 0x02, 0x2D, 0x23, 
    0x07, 0x19, 0x20, 0x29, 0x09, 0x16, 0x02, 0x0E, 0x09, 0x27, 
    0x0F, 0x14, 0x2C, 0x0D, 0x2A, 0x08, 0x1C, 0x02, 0x0E, 0x22, 
    0x2C, 0x08, 0x27, 0x0A, 0x19, 0x05, 0x2D, 0x10, 0x29, 0x32, 
    0x19, 0x22, 0x2E, 0x00, 0x31, 0x14, 0x04, 0x2D, 0x0A, 0x1C, 
    0x16, 0x23, 0x11, 0x09, 0x21, 0x0E, 0x30, 0x22, 0x0E, 0x15, 
    0x07, 0x0B, 0x13, 0x20, 0x2C, 0x0D, 0x1F, 0x02, 0x2C, 0x17, 0x1F, 

    0x24, 0x02, 0x28, 0x1F, 0x30, 0x17, 0x00, 0x27, 0x20, 0x16,         // 17
    0x22, 0x07, 0x29, 0x15, 0x24, 0x00, 0x28, 0x1A, 0x0A, 0x05, 
    0x18, 0x0C, 0x1B, 0x01, 0x10, 0x08, 0x28, 0x14, 0x0B, 0x1E, 
    0x15, 0x30, 0x0B, 0x12, 0x1D, 0x31, 0x22, 0x29, 0x13, 0x20, 
    0x1B, 0x07, 0x23, 0x18, 0x01, 0x25, 0x12, 0x2B, 0x1F, 0x07, 
    0x10, 0x16, 0x02, 0x2E, 0x22, 0x13, 0x25, 0x1C, 0x16, 0x04, 
    0x25, 0x0E, 0x08, 0x18, 0x24, 0x09, 0x2A, 0x17, 0x25, 0x11, 
    0x32, 0x04, 0x2B, 0x26, 0x16, 0x04, 0x29, 0x1D, 0x03, 0x25, 
    0x29, 0x1E, 0x2F, 0x01, 0x1A, 0x06, 0x13, 0x23, 0x09, 0x28, 0x0D, 

    0x32, 0x0F, 0x19, 0x0B, 0x04, 0x28, 0x0E, 0x1B, 0x07, 0x30,         // 18
    0x0A, 0x2C, 0x1B, 0x04, 0x2F, 0x1D, 0x0C, 0x14, 0x29, 0x2D, 
    0x22, 0x07, 0x2E, 0x26, 0x18, 0x2F, 0x0C, 0x1C, 0x2A, 0x03, 
    0x0E, 0x22, 0x00, 0x2D, 0x05, 0x10, 0x08, 0x18, 0x30, 0x03, 
    0x2D, 0x0D, 0x28, 0x11, 0x2F, 0x1A, 0x0B, 0x27, 0x14, 0x1A, 
    0x32, 0x1F, 0x2A, 0x1A, 0x0E, 0x31, 0x01, 0x0B, 0x21, 0x10, 
    0x2C, 0x13, 0x1D, 0x2B, 0x11, 0x1C, 0x21, 0x0F, 0x02, 0x28, 
    0x08, 0x1F, 0x18, 0x0C, 0x2F, 0x1B, 0x11, 0x0A, 0x17, 0x32, 
    0x10, 0x05, 0x16, 0x0F, 0x26, 0x31, 0x18, 0x2A, 0x12, 0x1C, 0x07, 

    0x16, 0x1E, 0x2D, 0x26, 0x13, 0x21, 0x2E, 0x14, 0x2A, 0x10,         // 19
    0x1D, 0x14, 0x0C, 0x20, 0x10, 0x07, 0x2E, 0x1F, 0x02, 0x10, 
    0x1D, 0x14, 0x23, 0x05, 0x1E, 0x12, 0x22, 0x05, 0x31, 0x25, 
    0x1B, 0x2B, 0x16, 0x25, 0x19, 0x27, 0x1E, 0x11, 0x24, 0x0B, 
    0x16, 0x21, 0x04, 0x1D, 0x09, 0x21, 0x05, 0x30, 0x0C, 0x25, 
    0x05, 0x0C, 0x12, 0x04, 0x21, 0x08, 0x18, 0x26, 0x2F, 0x06, 
    0x1F, 0x02, 0x26, 0x0B, 0x03, 0x2F, 0x07, 0x1A, 0x2E, 0x1D, 
    0x14, 0x0E, 0x29, 0x03, 0x20, 0x07, 0x23, 0x2D, 0x1F, 0x08, 
    0x22, 0x1C, 0x2C, 0x23, 0x08, 0x1D, 0x03, 0x0C, 0x2F, 0x00, 0x22, 

    0x08, 0x0E, 0x02, 0x16, 0x06, 0x1B, 0x0A, 0x02, 0x24, 0x05,         // 20
    0x26, 0x01, 0x31, 0x28, 0x15, 0x1B, 0x24, 0x0A, 0x17, 0x27, 
    0x06, 0x30, 0x0F, 0x0B, 0x2C, 0x02, 0x21, 0x16, 0x10, 0x08, 
    0x13, 0x06, 0x0D, 0x1F, 0x0A, 0x2F, 0x01, 0x2C, 0x07, 0x1D, 
    0x2B, 0x10, 0x31, 0x16, 0x2B, 0x10, 0x17, 0x1D, 0x02, 0x2B, 
    0x16, 0x28, 0x23, 0x17, 0x2C, 0x1D, 0x2A, 0x11, 0x0A, 0x18, 
    0x28, 0x16, 0x31, 0x22, 0x16, 0x28, 0x13, 0x24, 0x0C, 0x05, 
    0x23, 0x30, 0x1C, 0x11, 0x27, 0x14, 0x2A, 0x01, 0x15, 0x0D, 
    0x29, 0x17, 0x03, 0x0B, 0x19, 0x2D, 0x20, 0x16, 0x25, 0x19, 0x29, 

    0x30, 0x23, 0x2B, 0x1F, 0x31, 0x10, 0x2A, 0x1F, 0x17, 0x2E,         // 21
    0x0F, 0x1F, 0x17, 0x06, 0x25, 0x02, 0x2B, 0x11, 0x31, 0x20, 
    0x0B, 0x1A, 0x2A, 0x1C, 0x15, 0x27, 0x0E, 0x1B, 0x24, 0x2D, 
    0x1F, 0x28, 0x31, 0x11, 0x06, 0x15, 0x21, 0x0E, 0x17, 0x25, 
    0x01, 0x1A, 0x08, 0x26, 0x05, 0x24, 0x2E, 0x0F, 0x21, 0x12, 
    0x1E, 0x00, 0x30, 0x08, 0x0C, 0x14, 0x05, 0x22, 0x1C, 0x2E, 
    0x08, 0x10, 0x06, 0x1A, 0x0E, 0x1E, 0x01, 0x31, 0x12, 0x2B, 
    0x18, 0x00, 0x0B, 0x2D, 0x18, 0x08, 0x0E, 0x1A, 0x25, 0x2F, 
    0x06, 0x0E, 0x2F, 0x27, 0x15, 0x0F, 0x05, 0x2B, 0x07, 0x0D, 0x13, 

    0x03, 0x19, 0x09, 0x12, 0x26, 0x08, 0x23, 0x0C, 0x12, 0x1B,         // 22
    0x2A, 0x08, 0x23, 0x0F, 0x2D, 0x0E, 0x18, 0x07, 0x1C, 0x03, 
    0x28, 0x13, 0x00, 0x22, 0x07, 0x32, 0x09, 0x2B, 0x02, 0x0B, 
    0x15, 0x01, 0x1A, 0x24, 0x2A, 0x1D, 0x0B, 0x28, 0x32, 0x12, 
    0x0B, 0x28, 0x20, 0x13, 0x0C, 0x19, 0x04, 0x29, 0x07, 0x2F, 
    0x09, 0x1A, 0x10, 0x1F, 0x25, 0x32, 0x0F, 0x2C, 0x03, 0x13, 
    0x24, 0x2B, 0x1F, 0x2E, 0x05, 0x2C, 0x0B, 0x17, 0x20, 0x08, 
    0x27, 0x13, 0x20, 0x06, 0x22, 0x30, 0x1F, 0x2C, 0x04, 0x12, 
    0x1D, 0x24, 0x13, 0x1F, 0x04, 0x29, 0x23, 0x11, 0x1D, 0x2C, 0x20, 

    0x28, 0x10, 0x2A, 0x1C, 0x01, 0x18, 0x2C, 0x03, 0x32, 0x06,         // 23
    0x0D, 0x16, 0x29, 0x1B, 0x09, 0x1F, 0x22, 0x27, 0x12, 0x2C, 
    0x0E, 0x1F, 0x2F, 0x0D, 0x19, 0x12, 0x1F, 0x17, 0x27, 0x1C, 
    0x2F, 0x20, 0x0E, 0x04, 0x17, 0x2E, 0x03, 0x1A, 0x05, 0x22, 
    0x2E, 0x15, 0x05, 0x30, 0x1E, 0x27, 0x0D, 0x1F, 0x18, 0x26, 
    0x0D, 0x2B, 0x27, 0x06, 0x1A, 0x02, 0x1E, 0x16, 0x28, 0x0D, 
    0x19, 0x00, 0x0B, 0x14, 0x25, 0x19, 0x23, 0x2A, 0x05, 0x1C, 
    0x0E, 0x2C, 0x1A, 0x2A, 0x0F, 0x02, 0x13, 0x0A, 0x23, 0x18, 
    0x28, 0x00, 0x1B, 0x08, 0x30, 0x1A, 0x09, 0x32, 0x17, 0x05, 0x0C, 

    0x15, 0x20, 0x06, 0x2D, 0x0D, 0x20, 0x13, 0x1C, 0x24, 0x28,         // 24
    0x1E, 0x2D, 0x01, 0x13, 0x31, 0x15, 0x03, 0x2F, 0x0A, 0x18, 
    0x24, 0x06, 0x17, 0x2B, 0x26, 0x03, 0x2D, 0x06, 0x0E, 0x12, 
    0x08, 0x26, 0x14, 0x29, 0x09, 0x11, 0x26, 0x15, 0x1F, 0x09, 
    0x1D, 0x0D, 0x2A, 0x17, 0x02, 0x2B, 0x13, 0x32, 0x01, 0x15, 
    0x22, 0x04, 0x14, 0x2E, 0x12, 0x28, 0x0C, 0x24, 0x06, 0x1E, 
    0x31, 0x23, 0x18, 0x27, 0x07, 0x11, 0x03, 0x15, 0x0F, 0x30, 
    0x24, 0x0A, 0x03, 0x14, 0x1D, 0x27, 0x1B, 0x29, 0x0F, 0x06, 
    0x30, 0x0B, 0x2C, 0x10, 0x21, 0x0D, 0x15, 0x02, 0x24, 0x2E, 0x1C, 

    0x01, 0x30, 0x0B, 0x18, 0x25, 0x30, 0x07, 0x0D, 0x18, 0x04,         // 25
    0x11, 0x09, 0x20, 0x26, 0x05, 0x28, 0x0C, 0x1A, 0x20, 0x01, 
    0x2E, 0x11, 0x09, 0x20, 0x0C, 0x1C, 0x14, 0x23, 0x31, 0x1F, 
    0x2B, 0x05, 0x1B, 0x30, 0x1E, 0x22, 0x0C, 0x30, 0x0F, 0x2B, 
    0x02, 0x19, 0x24, 0x11, 0x0A, 0x22, 0x06, 0x1D, 0x0A, 0x2D, 
    0x10, 0x1E, 0x19, 0x0B, 0x21, 0x07, 0x2B, 0x12, 0x2E, 0x09, 
    0x10, 0x04, 0x2B, 0x0D, 0x32, 0x1D, 0x28, 0x2E, 0x22, 0x01, 
    0x17, 0x1E, 0x2E, 0x26, 0x0B, 0x32, 0x06, 0x16, 0x2D, 0x1E, 
    0x13, 0x19, 0x23, 0x16, 0x02, 0x2C, 0x26, 0x1E, 0x0B, 0x12, 0x29, 

    0x0F, 0x1A, 0x22, 0x13, 0x04, 0x0F, 0x29, 0x22, 0x2F, 0x14,         // 26
    0x23, 0x30, 0x18, 0x0B, 0x1D, 0x11, 0x2C, 0x24, 0x0F, 0x14, 
    0x28, 0x22, 0x1B, 0x02, 0x2D, 0x10, 0x29, 0x0A, 0x00, 0x1B, 
    0x10, 0x24, 0x0D, 0x01, 0x13, 0x07, 0x28, 0x00, 0x23, 0x18, 
    0x26, 0x31, 0x04, 0x1F, 0x2F, 0x1B, 0x10, 0x29, 0x24, 0x1B, 
    0x05, 0x31, 0x25, 0x01, 0x2D, 0x1B, 0x17, 0x02, 0x22, 0x18, 
    0x2A, 0x1C, 0x13, 0x1F, 0x01, 0x15, 0x09, 0x0D, 0x1F, 0x12, 
    0x2A, 0x0F, 0x08, 0x16, 0x05, 0x20, 0x0D, 0x24, 0x02, 0x22, 
    0x08, 0x27, 0x05, 0x2B, 0x1C, 0x11, 0x06, 0x2A, 0x1A, 0x07, 0x21, 

    0x08, 0x27, 0x03, 0x2B, 0x1F, 0x1B, 0x16, 0x01, 0x0A, 0x1B,         // 27
    0x2A, 0x03, 0x10, 0x2B, 0x23, 0x17, 0x08, 0x04, 0x32, 0x1C, 
    0x05, 0x0D, 0x2F, 0x14, 0x23, 0x05, 0x1F, 0x18, 0x27, 0x15, 
    0x09, 0x2C, 0x17, 0x27, 0x2D, 0x18, 0x1C, 0x2C, 0x09, 0x11, 
    0x06, 0x14, 0x0B, 0x28, 0x0D, 0x15, 0x2D, 0x03, 0x12, 0x0C, 
    0x2A, 0x08, 0x11, 0x29, 0x14, 0x0D, 0x2F, 0x1F, 0x0B, 0x26, 
    0x11, 0x07, 0x2F, 0x0A, 0x22, 0x2D, 0x25, 0x1A, 0x07, 0x26, 
    0x04, 0x30, 0x21, 0x1C, 0x2A, 0x11, 0x19, 0x2F, 0x12, 0x1B, 
    0x0E, 0x31, 0x14, 0x0A, 0x24, 0x2F, 0x18, 0x0E, 0x30, 0x16, 0x2B, 

    0x13, 0x32, 0x17, 0x09, 0x2E, 0x0C, 0x25, 0x2D, 0x20, 0x0E,         // 28
    0x07, 0x20, 0x1B, 0x0A, 0x00, 0x2E, 0x1F, 0x13, 0x26, 0x09, 
    0x2C, 0x16, 0x27, 0x07, 0x1A, 0x31, 0x0F, 0x2C, 0x0C, 0x2F, 
    0x22, 0x03, 0x1E, 0x0E, 0x23, 0x05, 0x0D, 0x15, 0x1E, 0x2F, 
    0x21, 0x1C, 0x2C, 0x18, 0x00, 0x25, 0x08, 0x21, 0x17, 0x26, 
    0x1E, 0x16, 0x21, 0x06, 0x1E, 0x03, 0x27, 0x07, 0x16, 0x30, 
    0x03, 0x21, 0x26, 0x18, 0x0F, 0x1C, 0x02, 0x11, 0x31, 0x15, 
    0x1B, 0x0B, 0x12, 0x00, 0x2E, 0x23, 0x03, 0x28, 0x07, 0x2B, 
    0x25, 0x01, 0x1F, 0x19, 0x10, 0x08, 0x1F, 0x00, 0x23, 0x05, 0x1C, 

    0x20, 0x0D, 0x1D, 0x11, 0x26, 0x03, 0x12, 0x08, 0x15, 0x28,         // 29
    0x2F, 0x12, 0x26, 0x31, 0x14, 0x0E, 0x28, 0x19, 0x0D, 0x20, 
    0x19, 0x00, 0x1F, 0x11, 0x25, 0x0A, 0x16, 0x02, 0x25, 0x06, 
    0x1C, 0x13, 0x32, 0x08, 0x15, 0x30, 0x28, 0x22, 0x04, 0x0C, 
    0x28, 0x0F, 0x05, 0x24, 0x1D, 0x2F, 0x0E, 0x1C, 0x31, 0x01, 
    0x10, 0x2E, 0x0B, 0x19, 0x2B, 0x23, 0x13, 0x1C, 0x2A, 0x0C, 
    0x1D, 0x16, 0x08, 0x2A, 0x04, 0x15, 0x27, 0x2A, 0x20, 0x09, 
    0x2C, 0x23, 0x28, 0x18, 0x09, 0x0E, 0x16, 0x1E, 0x0C, 0x14, 
    0x1A, 0x0F, 0x2D, 0x27, 0x03, 0x2A, 0x15, 0x28, 0x10, 0x2E, 0x0B, 

    0x01, 0x2D, 0x22, 0x06, 0x18, 0x30, 0x1D, 0x2B, 0x19, 0x03,         // 30
    0x1D, 0x08, 0x16, 0x04, 0x1E, 0x24, 0x03, 0x30, 0x06, 0x27, 
    0x11, 0x31, 0x0B, 0x2D, 0x03, 0x2A, 0x1D, 0x20, 0x11, 0x17, 
    0x2B, 0x0B, 0x24, 0x1B, 0x02, 0x20, 0x0A, 0x12, 0x2D, 0x1A, 
    0x01, 0x15, 0x32, 0x0A, 0x11, 0x05, 0x26, 0x14, 0x0A, 0x2A, 
    0x19, 0x05, 0x23, 0x2F, 0x0F, 0x09, 0x31, 0x10, 0x01, 0x25, 
    0x12, 0x2E, 0x0F, 0x23, 0x31, 0x1F, 0x0C, 0x06, 0x0F, 0x19, 
    0x02, 0x13, 0x0D, 0x2D, 0x1D, 0x27, 0x31, 0x05, 0x26, 0x30, 
    0x04, 0x21, 0x09, 0x12, 0x21, 0x1B, 0x31, 0x0A, 0x1D, 0x17, 0x29, 

    0x23, 0x19, 0x0A, 0x2B, 0x23, 0x14, 0x05, 0x21, 0x0A, 0x26,         // 31
    0x10, 0x22, 0x2A, 0x0C, 0x2C, 0x1A, 0x0B, 0x11, 0x1D, 0x2B, 
    0x04, 0x22, 0x15, 0x1B, 0x22, 0x13, 0x09, 0x30, 0x29, 0x0D, 
    0x1F, 0x01, 0x29, 0x10, 0x2C, 0x1C, 0x06, 0x18, 0x25, 0x11, 
    0x2B, 0x1F, 0x1B, 0x28, 0x17, 0x1F, 0x2C, 0x03, 0x23, 0x0E, 
    0x1F, 0x27, 0x13, 0x00, 0x16, 0x1B, 0x06, 0x20, 0x2D, 0x1E, 
    0x0A, 0x27, 0x00, 0x1B, 0x06, 0x12, 0x2D, 0x1D, 0x24, 0x2E, 
    0x28, 0x1F, 0x05, 0x24, 0x03, 0x14, 0x0A, 0x22, 0x19, 0x0E, 
    0x1E, 0x2B, 0x17, 0x2F, 0x06, 0x0C, 0x13, 0x03, 0x22, 0x07, 0x13, 

    0x31, 0x04, 0x15, 0x1D, 0x00, 0x0C, 0x29, 0x0F, 0x31, 0x14,         // 32
    0x2C, 0x01, 0x18, 0x23, 0x07, 0x16, 0x2E, 0x21, 0x15, 0x0C, 
    0x1B, 0x08, 0x2B, 0x04, 0x0D, 0x2E, 0x19, 0x03, 0x1B, 0x07, 
    0x2E, 0x15, 0x1A, 0x09, 0x25, 0x11, 0x29, 0x31, 0x03, 0x0B, 
    0x24, 0x07, 0x0E, 0x02, 0x2E, 0x0B, 0x19, 0x11, 0x2E, 0x16, 
    0x07, 0x32, 0x0A, 0x1F, 0x29, 0x24, 0x2B, 0x0C, 0x14, 0x06, 
    0x19, 0x2B, 0x22, 0x16, 0x0B, 0x28, 0x18, 0x03, 0x13, 0x0D, 
    0x07, 0x16, 0x31, 0x19, 0x0F, 0x2C, 0x1D, 0x11, 0x00, 0x29, 
    0x07, 0x11, 0x02, 0x24, 0x1C, 0x2C, 0x26, 0x19, 0x2E, 0x28, 0x0E, 

    0x0B, 0x27, 0x2C, 0x0F, 0x30, 0x26, 0x1E, 0x18, 0x04, 0x21,         // 33
    0x09, 0x1E, 0x0E, 0x31, 0x12, 0x26, 0x01, 0x29, 0x06, 0x30, 
    0x26, 0x12, 0x24, 0x18, 0x1F, 0x06, 0x27, 0x0F, 0x21, 0x14, 
    0x26, 0x0D, 0x22, 0x30, 0x04, 0x17, 0x0D, 0x22, 0x1E, 0x16, 
    0x2F, 0x14, 0x22, 0x2A, 0x12, 0x25, 0x07, 0x28, 0x1C, 0x01, 
    0x25, 0x12, 0x18, 0x2D, 0x0C, 0x12, 0x02, 0x19, 0x28, 0x31, 
    0x11, 0x07, 0x0D, 0x1F, 0x2C, 0x23, 0x09, 0x32, 0x27, 0x1B, 
    0x22, 0x10, 0x29, 0x0A, 0x21, 0x28, 0x06, 0x2D, 0x24, 0x14, 
    0x2E, 0x1A, 0x27, 0x0F, 0x18, 0x0A, 0x1E, 0x0D, 0x05, 0x16, 0x1F, 

    0x1C, 0x13, 0x20, 0x09, 0x17, 0x07, 0x12, 0x2E, 0x0C, 0x1B,         // 34
    0x2F, 0x15, 0x28, 0x04, 0x20, 0x0A, 0x1C, 0x11, 0x1F, 0x17, 
    0x01, 0x2D, 0x0A, 0x32, 0x11, 0x25, 0x15, 0x2C, 0x0A, 0x31, 
    0x03, 0x1D, 0x06, 0x13, 0x1F, 0x2D, 0x01, 0x19, 0x08, 0x26, 
    0x04, 0x1D, 0x09, 0x18, 0x04, 0x1D, 0x31, 0x0D, 0x22, 0x0C, 
    0x2C, 0x1D, 0x03, 0x22, 0x07, 0x1D, 0x2F, 0x0F, 0x22, 0x03, 
    0x24, 0x1C, 0x2F, 0x13, 0x02, 0x10, 0x20, 0x15, 0x0C, 0x00, 
    0x2F, 0x09, 0x1D, 0x14, 0x01, 0x1A, 0x0C, 0x16, 0x1B, 0x09, 
    0x21, 0x0D, 0x32, 0x07, 0x29, 0x02, 0x30, 0x14, 0x2B, 0x25, 0x01, 

    0x0A, 0x25, 0x02, 0x1B, 0x2C, 0x22, 0x02, 0x24, 0x2A, 0x10,         // 35
    0x03, 0x23, 0x0A, 0x19, 0x2B, 0x14, 0x2F, 0x0D, 0x28, 0x09, 
    0x22, 0x0E, 0x1C, 0x02, 0x29, 0x08, 0x1E, 0x01, 0x18, 0x24, 
    0x11, 0x2B, 0x27, 0x19, 0x0A, 0x24, 0x28, 0x11, 0x30, 0x0E, 
    0x2B, 0x11, 0x28, 0x2F, 0x21, 0x0F, 0x15, 0x05, 0x17, 0x28, 
    0x10, 0x09, 0x2F, 0x10, 0x2A, 0x15, 0x26, 0x05, 0x1E, 0x0B, 
    0x17, 0x29, 0x05, 0x26, 0x1B, 0x2D, 0x06, 0x1A, 0x29, 0x24, 
    0x13, 0x2C, 0x05, 0x26, 0x2F, 0x12, 0x22, 0x30, 0x03, 0x2B, 
    0x13, 0x01, 0x1E, 0x15, 0x23, 0x13, 0x20, 0x08, 0x1A, 0x11, 0x2F, 

    0x2A, 0x0F, 0x30, 0x11, 0x28, 0x0A, 0x1C, 0x16, 0x07, 0x20,         // 36
    0x27, 0x12, 0x2E, 0x0F, 0x1D, 0x03, 0x24, 0x05, 0x2C, 0x1A, 
    0x13, 0x27, 0x16, 0x22, 0x0F, 0x1B, 0x2E, 0x0D, 0x29, 0x1C, 
    0x09, 0x17, 0x0B, 0x2E, 0x10, 0x07, 0x1D, 0x05, 0x23, 0x17, 
    0x20, 0x00, 0x1A, 0x0C, 0x07, 0x2B, 0x27, 0x1F, 0x2D, 0x04, 
    0x1F, 0x16, 0x23, 0x19, 0x03, 0x20, 0x0A, 0x19, 0x2F, 0x13, 
    0x2D, 0x10, 0x09, 0x16, 0x0C, 0x27, 0x13, 0x2F, 0x04, 0x0F, 
    0x19, 0x21, 0x16, 0x1E, 0x0A, 0x2A, 0x04, 0x1E, 0x11, 0x25, 
    0x18, 0x22, 0x08, 0x2C, 0x0B, 0x2E, 0x0E, 0x28, 0x22, 0x06, 0x18, 

    0x04, 0x1D, 0x16, 0x07, 0x1F, 0x0F, 0x32, 0x0D, 0x2C, 0x18,         // 37
    0x06, 0x1B, 0x00, 0x22, 0x08, 0x29, 0x18, 0x13, 0x1E, 0x03, 
    0x30, 0x07, 0x2C, 0x06, 0x30, 0x14, 0x04, 0x21, 0x16, 0x05, 
    0x2D, 0x1F, 0x00, 0x21, 0x29, 0x1A, 0x2D, 0x14, 0x2A, 0x0C, 
    0x07, 0x32, 0x26, 0x17, 0x1E, 0x12, 0x01, 0x19, 0x09, 0x13, 
    0x31, 0x27, 0x07, 0x2B, 0x0C, 0x32, 0x12, 0x2A, 0x07, 0x23, 
    0x01, 0x1E, 0x22, 0x31, 0x1E, 0x01, 0x21, 0x0A, 0x1D, 0x2C, 
    0x06, 0x0B, 0x28, 0x02, 0x0F, 0x1B, 0x14, 0x29, 0x0C, 0x05, 
    0x30, 0x0F, 0x26, 0x19, 0x04, 0x1D, 0x18, 0x00, 0x32, 0x0D, 0x1F, 

    0x27, 0x09, 0x2C, 0x24, 0x03, 0x19, 0x25, 0x01, 0x1E, 0x0B,         // 38
    0x31, 0x29, 0x16, 0x2D, 0x1F, 0x0D, 0x32, 0x0A, 0x26, 0x0F, 
    0x21, 0x0D, 0x1E, 0x19, 0x0B, 0x25, 0x2B, 0x11, 0x31, 0x0E, 
    0x26, 0x12, 0x30, 0x0E, 0x16, 0x03, 0x0B, 0x1F, 0x02, 0x1C, 
    0x24, 0x15, 0x10, 0x03, 0x2E, 0x25, 0x0B, 0x30, 0x25, 0x1B, 
    0x0C, 0x00, 0x12, 0x1D, 0x14, 0x24, 0x01, 0x1F, 0x10, 0x28, 
    0x1A, 0x0C, 0x28, 0x04, 0x12, 0x2B, 0x18, 0x10, 0x27, 0x14, 
    0x23, 0x30, 0x13, 0x2B, 0x22, 0x32, 0x08, 0x23, 0x17, 0x2A, 
    0x1B, 0x0A, 0x2E, 0x11, 0x21, 0x0D, 0x25, 0x12, 0x1D, 0x15, 0x2D, 

    0x12, 0x1A, 0x0D, 0x29, 0x14, 0x2D, 0x10, 0x29, 0x13, 0x24,         // 39
    0x11, 0x20, 0x0E, 0x06, 0x13, 0x1A, 0x21, 0x06, 0x2D, 0x1A, 
    0x15, 0x2B, 0x04, 0x27, 0x11, 0x1F, 0x07, 0x1A, 0x02, 0x1E, 
    0x18, 0x04, 0x1B, 0x08, 0x1F, 0x32, 0x27, 0x0F, 0x2F, 0x12, 
    0x29, 0x09, 0x2C, 0x20, 0x0A, 0x15, 0x1C, 0x0F, 0x05, 0x2B, 
    0x22, 0x19, 0x2E, 0x25, 0x05, 0x18, 0x2D, 0x0A, 0x17, 0x05, 
    0x2C, 0x15, 0x08, 0x2D, 0x1A, 0x0C, 0x25, 0x07, 0x31, 0x01, 
    0x1B, 0x08, 0x1E, 0x0C, 0x18, 0x04, 0x11, 0x2E, 0x07, 0x20, 
    0x00, 0x13, 0x1E, 0x02, 0x28, 0x30, 0x05, 0x2A, 0x08, 0x25, 0x03, 

    0x23, 0x31, 0x00, 0x1D, 0x08, 0x22, 0x04, 0x1A, 0x07, 0x2D,         // 40
    0x0A, 0x04, 0x1A, 0x26, 0x2F, 0x02, 0x29, 0x17, 0x0E, 0x00, 
    0x26, 0x0A, 0x13, 0x2F, 0x01, 0x1C, 0x29, 0x0C, 0x23, 0x2D, 
    0x0B, 0x2A, 0x23, 0x2C, 0x13, 0x23, 0x07, 0x17, 0x25, 0x04, 
    0x18, 0x1F, 0x04, 0x19, 0x26, 0x05, 0x2C, 0x21, 0x18, 0x0A, 
    0x11, 0x1F, 0x08, 0x0E, 0x30, 0x0C, 0x1B, 0x27, 0x21, 0x31, 
    0x0E, 0x24, 0x1C, 0x10, 0x22, 0x05, 0x2D, 0x1F, 0x18, 0x0D, 
    0x2B, 0x11, 0x26, 0x06, 0x2D, 0x20, 0x26, 0x1B, 0x0F, 0x15, 
    0x2F, 0x23, 0x2A, 0x18, 0x07, 0x14, 0x21, 0x19, 0x2E, 0x0C, 0x18, 

    0x08, 0x0F, 0x21, 0x17, 0x2F, 0x0C, 0x1E, 0x30, 0x25, 0x17,         // 41
    0x1D, 0x22, 0x2A, 0x0C, 0x24, 0x0A, 0x12, 0x1E, 0x2B, 0x23, 
    0x31, 0x1C, 0x22, 0x18, 0x2B, 0x0E, 0x16, 0x30, 0x13, 0x06, 
    0x20, 0x14, 0x09, 0x10, 0x04, 0x19, 0x0D, 0x2C, 0x1D, 0x0A, 
    0x30, 0x0E, 0x2A, 0x13, 0x31, 0x0F, 0x24, 0x12, 0x01, 0x32, 
    0x27, 0x03, 0x2A, 0x17, 0x1E, 0x28, 0x06, 0x13, 0x08, 0x1A, 
    0x02, 0x13, 0x2F, 0x00, 0x28, 0x15, 0x1B, 0x03, 0x11, 0x26, 
    0x20, 0x03, 0x2F, 0x1B, 0x10, 0x16, 0x0A, 0x03, 0x2C, 0x27, 
    0x0D, 0x06, 0x10, 0x0B, 0x2C, 0x1B, 0x0B, 0x04, 0x10, 0x1F, 0x2B, 

    0x26, 0x15, 0x2C, 0x05, 0x10, 0x2A, 0x16, 0x0A, 0x12, 0x01,         // 42
    0x0E, 0x31, 0x12, 0x03, 0x16, 0x1F, 0x30, 0x0B, 0x05, 0x13, 
    0x07, 0x10, 0x03, 0x0A, 0x24, 0x06, 0x21, 0x03, 0x28, 0x1A, 
    0x0F, 0x31, 0x1C, 0x28, 0x2D, 0x1E, 0x25, 0x00, 0x15, 0x21, 
    0x11, 0x26, 0x07, 0x1D, 0x02, 0x18, 0x09, 0x2D, 0x1D, 0x24, 
    0x14, 0x1B, 0x0F, 0x24, 0x04, 0x11, 0x20, 0x2F, 0x0F, 0x2A, 
    0x1F, 0x26, 0x09, 0x1E, 0x0D, 0x31, 0x0B, 0x27, 0x2D, 0x09, 
    0x19, 0x15, 0x0B, 0x23, 0x02, 0x28, 0x31, 0x1F, 0x16, 0x05, 
    0x20, 0x1A, 0x32, 0x25, 0x1F, 0x11, 0x30, 0x23, 0x29, 0x14, 0x02, 

    0x1F, 0x0A, 0x1A, 0x27, 0x23, 0x1C, 0x02, 0x28, 0x1F, 0x2C,         // 43
    0x26, 0x07, 0x19, 0x2E, 0x1C, 0x06, 0x27, 0x1A, 0x22, 0x18, 
    0x1F, 0x27, 0x2C, 0x15, 0x32, 0x1D, 0x13, 0x25, 0x0A, 0x2C, 
    0x04, 0x24, 0x07, 0x17, 0x02, 0x0B, 0x31, 0x10, 0x29, 0x05, 
    0x2C, 0x1A, 0x22, 0x0B, 0x2A, 0x20, 0x27, 0x06, 0x16, 0x0C, 
    0x05, 0x2D, 0x09, 0x2F, 0x15, 0x2B, 0x00, 0x18, 0x23, 0x05, 
    0x16, 0x0C, 0x2A, 0x17, 0x24, 0x06, 0x13, 0x22, 0x1C, 0x06, 
    0x32, 0x28, 0x12, 0x2C, 0x1D, 0x0C, 0x11, 0x22, 0x0B, 0x1C, 
    0x2B, 0x13, 0x01, 0x16, 0x05, 0x2A, 0x01, 0x16, 0x1C, 0x0C, 0x2E, 

    0x10, 0x31, 0x02, 0x13, 0x07, 0x0D, 0x32, 0x11, 0x1A, 0x06,         // 44
    0x14, 0x21, 0x0C, 0x24, 0x10, 0x2C, 0x0D, 0x01, 0x2D, 0x09, 
    0x2F, 0x0C, 0x23, 0x1A, 0x0C, 0x07, 0x2E, 0x1A, 0x12, 0x1E, 
    0x16, 0x2E, 0x0D, 0x21, 0x26, 0x14, 0x1B, 0x08, 0x18, 0x1F, 
    0x0B, 0x01, 0x16, 0x2D, 0x13, 0x0D, 0x1B, 0x11, 0x2F, 0x20, 
    0x29, 0x11, 0x1D, 0x21, 0x0B, 0x1C, 0x26, 0x0A, 0x2C, 0x11, 
    0x30, 0x1A, 0x05, 0x11, 0x2E, 0x19, 0x2B, 0x03, 0x16, 0x10, 
    0x23, 0x00, 0x1F, 0x08, 0x16, 0x2B, 0x19, 0x01, 0x2F, 0x0F, 
    0x26, 0x0A, 0x2C, 0x22, 0x0F, 0x18, 0x26, 0x09, 0x2D, 0x05, 0x18, 

    0x07, 0x1D, 0x29, 0x20, 0x2D, 0x18, 0x22, 0x04, 0x2E, 0x0B,         // 45
    0x2A, 0x1B, 0x00, 0x29, 0x09, 0x17, 0x21, 0x13, 0x29, 0x0F, 
    0x1D, 0x05, 0x12, 0x02, 0x20, 0x26, 0x0E, 0x00, 0x28, 0x0C, 
    0x23, 0x02, 0x1C, 0x11, 0x2F, 0x06, 0x2A, 0x23, 0x2F, 0x0F, 
    0x28, 0x30, 0x10, 0x1E, 0x07, 0x31, 0x05, 0x29, 0x02, 0x19, 
    0x07, 0x24, 0x01, 0x13, 0x06, 0x32, 0x0E, 0x1A, 0x07, 0x1D, 
    0x01, 0x24, 0x2C, 0x21, 0x02, 0x0E, 0x1F, 0x0A, 0x2F, 0x29, 
    0x0C, 0x18, 0x0E, 0x30, 0x04, 0x21, 0x09, 0x27, 0x14, 0x23, 
    0x03, 0x18, 0x1E, 0x07, 0x2F, 0x1C, 0x0E, 0x20, 0x13, 0x28, 0x23, 

    0x2B, 0x15, 0x0D, 0x08, 0x11, 0x28, 0x0B, 0x15, 0x24, 0x1E,         // 46
    0x0F, 0x2F, 0x15, 0x1E, 0x31, 0x04, 0x1B, 0x26, 0x07, 0x16, 
    0x25, 0x18, 0x28, 0x30, 0x10, 0x2C, 0x18, 0x21, 0x30, 0x06, 
    0x2B, 0x14, 0x28, 0x08, 0x1A, 0x0F, 0x20, 0x0A, 0x02, 0x14, 
    0x1B, 0x21, 0x05, 0x27, 0x18, 0x24, 0x1E, 0x15, 0x23, 0x10, 
    0x31, 0x16, 0x2D, 0x27, 0x19, 0x23, 0x13, 0x2B, 0x22, 0x15, 
    0x28, 0x0A, 0x13, 0x08, 0x1C, 0x29, 0x13, 0x25, 0x1A, 0x05, 
    0x1E, 0x2D, 0x25, 0x1A, 0x28, 0x0E, 0x2E, 0x1E, 0x05, 0x1A, 
    0x30, 0x0D, 0x13, 0x27, 0x0B, 0x2A, 0x06, 0x32, 0x02, 0x1A, 0x0F, 

    0x03, 0x25, 0x19, 0x2E, 0x1B, 0x05, 0x1E, 0x2C, 0x09, 0x17,         // 47
    0x03, 0x24, 0x06, 0x0E, 0x23, 0x12, 0x2D, 0x0E, 0x1F, 0x30, 
    0x00, 0x2C, 0x09, 0x15, 0x1E, 0x05, 0x14, 0x0A, 0x1C, 0x10, 
    0x19, 0x09, 0x1F, 0x2D, 0x24, 0x01, 0x16, 0x1D, 0x2C, 0x25, 
    0x06, 0x0E, 0x15, 0x2E, 0x00, 0x12, 0x0C, 0x2E, 0x09, 0x2A, 
    0x0B, 0x1C, 0x0D, 0x08, 0x2B, 0x02, 0x1E, 0x0C, 0x04, 0x31, 
    0x0E, 0x20, 0x18, 0x30, 0x24, 0x0B, 0x30, 0x02, 0x11, 0x22, 
    0x14, 0x0A, 0x03, 0x11, 0x15, 0x05, 0x18, 0x10, 0x2C, 0x0B, 
    0x1F, 0x2A, 0x24, 0x02, 0x19, 0x12, 0x23, 0x16, 0x1E, 0x0B, 0x30, 

    0x21, 0x0A, 0x2A, 0x01, 0x23, 0x30, 0x13, 0x02, 0x26, 0x31,         // 48
    0x13, 0x2B, 0x1A, 0x28, 0x07, 0x18, 0x02, 0x2A, 0x06, 0x15, 
    0x0E, 0x1D, 0x22, 0x03, 0x2B, 0x0C, 0x24, 0x28, 0x03, 0x20, 
    0x26, 0x32, 0x10, 0x05, 0x14, 0x2A, 0x31, 0x11, 0x0D, 0x18, 
    0x30, 0x29, 0x1F, 0x0A, 0x25, 0x1A, 0x2B, 0x03, 0x18, 0x1E, 
    0x04, 0x26, 0x12, 0x1F, 0x17, 0x0B, 0x2F, 0x27, 0x18, 0x1E, 
    0x06, 0x2C, 0x02, 0x0D, 0x1A, 0x06, 0x16, 0x1D, 0x2C, 0x07, 
    0x31, 0x27, 0x1D, 0x2C, 0x20, 0x2F, 0x25, 0x07, 0x28, 0x12, 
    0x04, 0x14, 0x09, 0x31, 0x1F, 0x05, 0x2D, 0x0A, 0x2A, 0x25, 0x13, 

    0x17, 0x1D, 0x10, 0x16, 0x09, 0x0D, 0x21, 0x19, 0x10, 0x1D,         // 49
    0x08, 0x20, 0x0A, 0x14, 0x2F, 0x26, 0x1E, 0x0C, 0x1A, 0x23, 
    0x2E, 0x0A, 0x17, 0x0F, 0x20, 0x1A, 0x30, 0x0F, 0x2D, 0x14, 
    0x0B, 0x01, 0x17, 0x21, 0x0B, 0x1B, 0x07, 0x26, 0x03, 0x1F, 
    0x0A, 0x04, 0x1A, 0x11, 0x2C, 0x06, 0x22, 0x10, 0x28, 0x13, 
    0x21, 0x2E, 0x00, 0x31, 0x25, 0x12, 0x1B, 0x08, 0x0F, 0x2D, 
    0x14, 0x1B, 0x23, 0x29, 0x11, 0x2E, 0x22, 0x0C, 0x27, 0x0F, 
    0x20, 0x17, 0x07, 0x0E, 0x01, 0x1B, 0x0D, 0x1F, 0x17, 0x21, 
    0x2E, 0x19, 0x1D, 0x0F, 0x28, 0x14, 0x1B, 0x0F, 0x00, 0x1B, 0x08, 

    0x2F, 0x03, 0x2C, 0x24, 0x29, 0x1C, 0x2D, 0x09, 0x2A, 0x03,         // 50
    0x27, 0x0D, 0x2D, 0x01, 0x20, 0x0A, 0x13, 0x32, 0x27, 0x10, 
    0x04, 0x29, 0x24, 0x31, 0x13, 0x01, 0x09, 0x1F, 0x07, 0x1B, 
    0x2C, 0x27, 0x1C, 0x2C, 0x25, 0x10, 0x21, 0x19, 0x2D, 0x28, 
    0x14, 0x24, 0x2F, 0x02, 0x1E, 0x15, 0x0B, 0x1D, 0x32, 0x06, 
    0x0E, 0x17, 0x1E, 0x0D, 0x07, 0x2B, 0x03, 0x20, 0x25, 0x01, 
    0x29, 0x10, 0x07, 0x1D, 0x04, 0x26, 0x12, 0x00, 0x17, 0x1D, 
    0x03, 0x13, 0x2F, 0x23, 0x29, 0x15, 0x06, 0x31, 0x01, 0x0C, 
    0x25, 0x06, 0x29, 0x01, 0x21, 0x09, 0x29, 0x20, 0x30, 0x11, 0x28, 

    0x0E, 0x20, 0x09, 0x19, 0x04, 0x10, 0x00, 0x24, 0x14, 0x2F,         // 51
    0x1A, 0x15, 0x24, 0x1C, 0x0F, 0x2B, 0x04, 0x17, 0x08, 0x20, 
    0x1C, 0x14, 0x09, 0x05, 0x26, 0x2C, 0x17, 0x29, 0x12, 0x23, 
    0x06, 0x0E, 0x12, 0x04, 0x09, 0x2F, 0x02, 0x13, 0x08, 0x10, 
    0x1D, 0x0D, 0x16, 0x28, 0x0E, 0x30, 0x26, 0x01, 0x18, 0x24, 
    0x2C, 0x05, 0x29, 0x15, 0x1C, 0x24, 0x15, 0x31, 0x12, 0x1A, 
    0x0C, 0x25, 0x32, 0x15, 0x2B, 0x0A, 0x1F, 0x31, 0x2A, 0x08, 
    0x2D, 0x26, 0x0B, 0x18, 0x0F, 0x2D, 0x23, 0x12, 0x1B, 0x2B, 
    0x15, 0x0E, 0x2F, 0x17, 0x11, 0x2E, 0x04, 0x18, 0x0A, 0x23, 0x06, 

    0x15, 0x27, 0x12, 0x2F, 0x21, 0x15, 0x32, 0x19, 0x0C, 0x1F,         // 52
    0x0F, 0x07, 0x31, 0x05, 0x17, 0x24, 0x1C, 0x29, 0x0D, 0x2E, 
    0x02, 0x2C, 0x19, 0x1F, 0x0C, 0x21, 0x10, 0x1D, 0x02, 0x2F, 
    0x18, 0x20, 0x30, 0x18, 0x27, 0x15, 0x2B, 0x1E, 0x24, 0x32, 
    0x00, 0x2C, 0x06, 0x21, 0x08, 0x1A, 0x12, 0x2A, 0x10, 0x0A, 
    0x1B, 0x12, 0x21, 0x03, 0x2F, 0x09, 0x0F, 0x1E, 0x08, 0x2C, 
    0x1F, 0x09, 0x19, 0x01, 0x21, 0x14, 0x19, 0x07, 0x10, 0x22, 
    0x0C, 0x1B, 0x02, 0x20, 0x07, 0x1C, 0x0C, 0x2A, 0x08, 0x1E, 
    0x03, 0x21, 0x1B, 0x0B, 0x25, 0x1C, 0x0D, 0x27, 0x14, 0x2D, 0x1A, 

    0x31, 0x01, 0x1E, 0x0C, 0x07, 0x28, 0x1E, 0x06, 0x27, 0x04,         // 53
    0x25, 0x2A, 0x13, 0x21, 0x0C, 0x2E, 0x11, 0x01, 0x23, 0x18, 
    0x11, 0x27, 0x0E, 0x2F, 0x18, 0x04, 0x31, 0x0C, 0x25, 0x15, 
    0x08, 0x29, 0x01, 0x1E, 0x0D, 0x21, 0x0F, 0x06, 0x16, 0x0A, 
    0x20, 0x18, 0x27, 0x14, 0x2E, 0x04, 0x21, 0x07, 0x1F, 0x2E, 
    0x28, 0x08, 0x2C, 0x10, 0x27, 0x18, 0x2C, 0x04, 0x28, 0x15, 
    0x03, 0x2E, 0x12, 0x27, 0x0D, 0x2D, 0x03, 0x27, 0x1C, 0x16, 
    0x25, 0x12, 0x2A, 0x32, 0x14, 0x27, 0x02, 0x18, 0x26, 0x2E, 
    0x11, 0x27, 0x07, 0x2C, 0x05, 0x13, 0x31, 0x1F, 0x08, 0x03, 0x1E, 

    0x09, 0x29, 0x17, 0x2C, 0x1A, 0x11, 0x09, 0x2B, 0x11, 0x2E,         // 54
    0x17, 0x02, 0x1E, 0x0A, 0x2A, 0x05, 0x21, 0x1A, 0x30, 0x09, 
    0x1E, 0x0B, 0x23, 0x01, 0x13, 0x27, 0x1B, 0x06, 0x2B, 0x1E, 
    0x0D, 0x23, 0x19, 0x0A, 0x2D, 0x04, 0x1B, 0x2F, 0x27, 0x0E, 
    0x2B, 0x11, 0x09, 0x1D, 0x10, 0x29, 0x16, 0x30, 0x0D, 0x14, 
    0x01, 0x1E, 0x16, 0x23, 0x0C, 0x02, 0x22, 0x19, 0x0B, 0x24, 
    0x1B, 0x0F, 0x2A, 0x1E, 0x07, 0x1B, 0x23, 0x2F, 0x0C, 0x01, 
    0x30, 0x05, 0x1D, 0x0D, 0x06, 0x2D, 0x1F, 0x0F, 0x04, 0x1A, 
    0x09, 0x32, 0x15, 0x1F, 0x19, 0x2A, 0x01, 0x16, 0x2B, 0x25, 0x0F, 

    0x21, 0x12, 0x06, 0x24, 0x02, 0x2F, 0x24, 0x15, 0x1C, 0x0B,         // 55
    0x22, 0x10, 0x2F, 0x1A, 0x25, 0x16, 0x0E, 0x07, 0x28, 0x16, 
    0x2D, 0x05, 0x2A, 0x1D, 0x2C, 0x08, 0x16, 0x22, 0x12, 0x03, 
    0x32, 0x11, 0x2C, 0x15, 0x26, 0x13, 0x23, 0x02, 0x19, 0x1F, 
    0x04, 0x23, 0x31, 0x01, 0x24, 0x0A, 0x1C, 0x02, 0x23, 0x19, 
    0x26, 0x0B, 0x2E, 0x06, 0x1B, 0x32, 0x11, 0x2A, 0x10, 0x30, 
    0x08, 0x23, 0x02, 0x17, 0x30, 0x10, 0x09, 0x13, 0x1F, 0x2A, 
    0x18, 0x0F, 0x27, 0x17, 0x22, 0x19, 0x12, 0x31, 0x23, 0x14, 
    0x20, 0x0D, 0x00, 0x25, 0x0F, 0x09, 0x23, 0x0E, 0x1C, 0x13, 0x2C, 

    0x02, 0x1C, 0x30, 0x14, 0x1E, 0x0B, 0x18, 0x04, 0x31, 0x06,         // 56
    0x18, 0x26, 0x07, 0x14, 0x00, 0x31, 0x27, 0x1F, 0x10, 0x02, 
    0x22, 0x14, 0x19, 0x10, 0x0C, 0x23, 0x2A, 0x0D, 0x2D, 0x1A, 
    0x26, 0x09, 0x03, 0x21, 0x06, 0x31, 0x0E, 0x29, 0x13, 0x08, 
    0x2E, 0x16, 0x0C, 0x19, 0x2D, 0x13, 0x27, 0x11, 0x2C, 0x05, 
    0x31, 0x12, 0x19, 0x28, 0x13, 0x20, 0x07, 0x1C, 0x00, 0x20, 
    0x13, 0x2C, 0x0D, 0x25, 0x05, 0x20, 0x2B, 0x1A, 0x06, 0x24, 
    0x0A, 0x20, 0x2C, 0x00, 0x0A, 0x28, 0x05, 0x0B, 0x2A, 0x06, 
    0x27, 0x19, 0x2B, 0x08, 0x30, 0x27, 0x18, 0x2E, 0x05, 0x0B, 0x18, 

    0x26, 0x0D, 0x08, 0x2A, 0x0F, 0x21, 0x2C, 0x0F, 0x26, 0x1F,         // 57
    0x2D, 0x0D, 0x2B, 0x22, 0x0C, 0x1C, 0x13, 0x09, 0x2E, 0x1C, 
    0x0D, 0x32, 0x08, 0x20, 0x2E, 0x06, 0x14, 0x00, 0x20, 0x07, 
    0x13, 0x1F, 0x2B, 0x1A, 0x0B, 0x1E, 0x18, 0x09, 0x2C, 0x26, 
    0x0F, 0x1D, 0x2A, 0x07, 0x1F, 0x04, 0x2F, 0x09, 0x1E, 0x10, 
    0x20, 0x08, 0x25, 0x01, 0x2B, 0x0A, 0x2D, 0x25, 0x16, 0x2B, 
    0x04, 0x19, 0x1D, 0x12, 0x28, 0x15, 0x00, 0x26, 0x11, 0x2E, 
    0x1C, 0x06, 0x13, 0x1B, 0x30, 0x14, 0x21, 0x1C, 0x16, 0x0E, 
    0x2E, 0x11, 0x1F, 0x14, 0x1C, 0x12, 0x03, 0x22, 0x2A, 0x1F, 0x30, 

    0x11, 0x2C, 0x22, 0x19, 0x05, 0x27, 0x00, 0x1D, 0x0A, 0x12,         // 58
    0x02, 0x15, 0x1D, 0x04, 0x28, 0x2C, 0x03, 0x24, 0x17, 0x2A, 
    0x05, 0x27, 0x23, 0x02, 0x17, 0x1E, 0x31, 0x1C, 0x29, 0x0F, 
    0x2F, 0x17, 0x0D, 0x25, 0x13, 0x2C, 0x04, 0x20, 0x1A, 0x01, 
    0x21, 0x05, 0x11, 0x24, 0x17, 0x0D, 0x1B, 0x22, 0x16, 0x06, 
    0x2B, 0x1C, 0x0E, 0x16, 0x1E, 0x10, 0x18, 0x06, 0x0D, 0x1F, 
    0x0B, 0x31, 0x06, 0x2C, 0x0B, 0x1B, 0x31, 0x0A, 0x17, 0x02, 
    0x0E, 0x31, 0x25, 0x0C, 0x20, 0x0E, 0x2C, 0x01, 0x2F, 0x1F, 
    0x02, 0x0A, 0x22, 0x03, 0x29, 0x07, 0x1E, 0x10, 0x09, 0x14, 0x04, 

    0x17, 0x1E, 0x01, 0x14, 0x2F, 0x1B, 0x13, 0x30, 0x17, 0x2A,         // 59
    0x23, 0x31, 0x09, 0x17, 0x11, 0x1A, 0x0E, 0x30, 0x07, 0x11, 
    0x1F, 0x17, 0x12, 0x2B, 0x0E, 0x27, 0x11, 0x0B, 0x17, 0x25, 
    0x02, 0x22, 0x08, 0x30, 0x00, 0x27, 0x12, 0x2F, 0x0E, 0x16, 
    0x32, 0x19, 0x2C, 0x0B, 0x2E, 0x27, 0x12, 0x00, 0x2A, 0x24, 
    0x17, 0x04, 0x2F, 0x27, 0x04, 0x30, 0x21, 0x28, 0x2F, 0x12, 
    0x28, 0x22, 0x14, 0x1F, 0x03, 0x23, 0x11, 0x1F, 0x2D, 0x23, 
    0x2A, 0x15, 0x03, 0x29, 0x08, 0x1A, 0x26, 0x0A, 0x13, 0x25, 
    0x1A, 0x28, 0x17, 0x2E, 0x0B, 0x24, 0x32, 0x17, 0x28, 0x1B, 0x25, 

    0x0C, 0x31, 0x0F, 0x25, 0x07, 0x0C, 0x25, 0x08, 0x20, 0x04,         // 60
    0x0E, 0x19, 0x21, 0x2D, 0x24, 0x06, 0x1F, 0x15, 0x22, 0x29, 
    0x0C, 0x03, 0x2F, 0x09, 0x1B, 0x05, 0x24, 0x03, 0x2D, 0x0A, 
    0x1B, 0x2C, 0x10, 0x1E, 0x18, 0x0B, 0x1C, 0x24, 0x07, 0x28, 
    0x0A, 0x26, 0x13, 0x01, 0x20, 0x06, 0x1E, 0x32, 0x0F, 0x0A, 
    0x2D, 0x13, 0x20, 0x0C, 0x1B, 0x09, 0x15, 0x01, 0x1B, 0x07, 
    0x18, 0x02, 0x0F, 0x2D, 0x18, 0x0E, 0x29, 0x04, 0x1A, 0x12, 
    0x0B, 0x1F, 0x19, 0x13, 0x2D, 0x04, 0x16, 0x1E, 0x2B, 0x07, 
    0x0C, 0x31, 0x05, 0x0F, 0x1B, 0x13, 0x2A, 0x0D, 0x02, 0x2E, 0x07, 

    0x20, 0x05, 0x1B, 0x2A, 0x1F, 0x2C, 0x19, 0x11, 0x2D, 0x1C,         // 61
    0x28, 0x07, 0x12, 0x01, 0x0D, 0x2F, 0x28, 0x01, 0x0F, 0x1B, 
    0x2C, 0x24, 0x19, 0x1F, 0x2A, 0x13, 0x30, 0x1E, 0x15, 0x21, 
    0x12, 0x05, 0x29, 0x07, 0x2B, 0x22, 0x10, 0x02, 0x2C, 0x13, 
    0x1D, 0x04, 0x22, 0x1B, 0x15, 0x29, 0x09, 0x14, 0x1A, 0x20, 
    0x02, 0x26, 0x07, 0x16, 0x2C, 0x29, 0x10, 0x20, 0x0D, 0x25, 
    0x2E, 0x1E, 0x29, 0x08, 0x26, 0x30, 0x09, 0x16, 0x26, 0x05, 
    0x21, 0x07, 0x2F, 0x24, 0x0F, 0x23, 0x32, 0x05, 0x10, 0x22, 
    0x15, 0x1D, 0x12, 0x26, 0x20, 0x01, 0x0A, 0x1D, 0x22, 0x11, 0x29, 

    0x13, 0x2D, 0x17, 0x03, 0x14, 0x0E, 0x02, 0x27, 0x06, 0x0D,         // 62
    0x14, 0x30, 0x1E, 0x2A, 0x19, 0x14, 0x0A, 0x1C, 0x31, 0x04, 
    0x09, 0x13, 0x0D, 0x01, 0x23, 0x08, 0x1A, 0x0D, 0x2A, 0x03, 
    0x31, 0x1D, 0x16, 0x24, 0x13, 0x09, 0x30, 0x17, 0x20, 0x08, 
    0x2E, 0x0F, 0x2B, 0x0C, 0x30, 0x0F, 0x23, 0x2B, 0x06, 0x2E, 
    0x10, 0x19, 0x31, 0x11, 0x22, 0x06, 0x19, 0x32, 0x2A, 0x13, 
    0x04, 0x0B, 0x15, 0x1C, 0x01, 0x12, 0x21, 0x2C, 0x0E, 0x32, 
    0x17, 0x2A, 0x0D, 0x01, 0x1F, 0x0B, 0x14, 0x29, 0x1A, 0x2F, 
    0x00, 0x23, 0x2C, 0x09, 0x30, 0x17, 0x25, 0x2D, 0x18, 0x0B, 0x1B, 

    0x27, 0x08, 0x22, 0x0B, 0x28, 0x23, 0x32, 0x1E, 0x16, 0x22,         // 63
    0x26, 0x03, 0x0C, 0x25, 0x05, 0x1F, 0x2C, 0x12, 0x25, 0x17, 
    0x1F, 0x28, 0x31, 0x16, 0x2D, 0x11, 0x22, 0x06, 0x13, 0x23, 
    0x0E, 0x26, 0x0B, 0x01, 0x2E, 0x1C, 0x04, 0x29, 0x0E, 0x1A, 
    0x23, 0x18, 0x06, 0x25, 0x08, 0x19, 0x02, 0x1C, 0x0D, 0x26, 
    0x1D, 0x09, 0x29, 0x00, 0x1D, 0x0B, 0x26, 0x03, 0x08, 0x1B, 
    0x21, 0x28, 0x31, 0x0D, 0x22, 0x1A, 0x07, 0x1D, 0x03, 0x24, 
    0x09, 0x12, 0x27, 0x16, 0x1B, 0x2C, 0x02, 0x20, 0x08, 0x0E, 
    0x2A, 0x0A, 0x16, 0x04, 0x1C, 0x0E, 0x06, 0x13, 0x08, 0x31, 0x00, 

    0x0F, 0x2B, 0x11, 0x30, 0x1C, 0x06, 0x12, 0x0C, 0x2E, 0x09,         // 64
    0x1C, 0x2A, 0x1A, 0x12, 0x32, 0x09, 0x21, 0x06, 0x0C, 0x2E, 
    0x11, 0x07, 0x1C, 0x0A, 0x26, 0x03, 0x1C, 0x2E, 0x27, 0x19, 
    0x08, 0x2E, 0x1A, 0x20, 0x0E, 0x27, 0x14, 0x23, 0x06, 0x31, 
    0x02, 0x11, 0x2E, 0x1D, 0x13, 0x2D, 0x27, 0x15, 0x2C, 0x03, 
    0x14, 0x21, 0x0E, 0x25, 0x15, 0x2F, 0x13, 0x1F, 0x16, 0x2D, 
    0x0E, 0x17, 0x05, 0x25, 0x10, 0x2F, 0x14, 0x28, 0x12, 0x19, 
    0x2D, 0x1C, 0x06, 0x2F, 0x08, 0x25, 0x19, 0x11, 0x26, 0x1C, 
    0x14, 0x1F, 0x28, 0x11, 0x22, 0x2D, 0x27, 0x1B, 0x2A, 0x23, 0x1E, 

    0x05, 0x20, 0x18, 0x03, 0x13, 0x22, 0x19, 0x00, 0x29, 0x11,         // 65
    0x05, 0x13, 0x2D, 0x02, 0x23, 0x0F, 0x16, 0x29, 0x1A, 0x00, 
    0x23, 0x2B, 0x04, 0x20, 0x14, 0x2C, 0x0A, 0x16, 0x01, 0x10, 
    0x20, 0x04, 0x13, 0x2A, 0x06, 0x1A, 0x0A, 0x2C, 0x13, 0x1E, 
    0x2A, 0x26, 0x17, 0x03, 0x24, 0x06, 0x1E, 0x10, 0x08, 0x24, 
    0x30, 0x04, 0x18, 0x2E, 0x04, 0x1A, 0x0E, 0x29, 0x0A, 0x25, 
    0x02, 0x1F, 0x13, 0x2C, 0x06, 0x26, 0x02, 0x2C, 0x0C, 0x1F, 
    0x01, 0x24, 0x0F, 0x21, 0x13, 0x0C, 0x30, 0x0A, 0x2C, 0x06, 
    0x2F, 0x02, 0x19, 0x32, 0x0D, 0x02, 0x1F, 0x11, 0x03, 0x0D, 0x15, 

    0x1A, 0x2E, 0x0B, 0x26, 0x2E, 0x09, 0x2B, 0x25, 0x1F, 0x18,         // 66
    0x31, 0x21, 0x0B, 0x17, 0x28, 0x1B, 0x03, 0x30, 0x25, 0x0E, 
    0x1E, 0x17, 0x10, 0x30, 0x1A, 0x0F, 0x24, 0x1E, 0x31, 0x29, 
    0x1B, 0x2C, 0x0A, 0x23, 0x11, 0x2E, 0x20, 0x01, 0x18, 0x09, 
    0x0F, 0x07, 0x21, 0x0B, 0x32, 0x18, 0x0C, 0x2F, 0x20, 0x19, 
    0x0B, 0x2A, 0x10, 0x20, 0x0A, 0x2C, 0x22, 0x01, 0x31, 0x10, 
    0x1A, 0x2A, 0x0B, 0x1B, 0x20, 0x0B, 0x19, 0x22, 0x08, 0x30, 
    0x10, 0x17, 0x2B, 0x02, 0x1D, 0x29, 0x04, 0x1F, 0x18, 0x12, 
    0x25, 0x0F, 0x21, 0x06, 0x1D, 0x15, 0x0A, 0x29, 0x19, 0x30, 0x25, 

    0x29, 0x01, 0x14, 0x1D, 0x04, 0x0F, 0x1B, 0x13, 0x04, 0x09,         // 67
    0x27, 0x0E, 0x1E, 0x08, 0x2F, 0x0D, 0x22, 0x12, 0x07, 0x16, 
    0x2F, 0x06, 0x25, 0x0B, 0x01, 0x28, 0x06, 0x13, 0x0B, 0x05, 
    0x0F, 0x22, 0x19, 0x32, 0x03, 0x17, 0x0D, 0x25, 0x30, 0x22, 
    0x1A, 0x2E, 0x14, 0x1D, 0x0F, 0x2A, 0x00, 0x26, 0x05, 0x12, 
    0x1D, 0x26, 0x06, 0x1B, 0x25, 0x12, 0x07, 0x1D, 0x14, 0x21, 
    0x08, 0x2F, 0x24, 0x00, 0x16, 0x31, 0x0E, 0x1E, 0x15, 0x28, 
    0x06, 0x26, 0x0B, 0x31, 0x15, 0x0E, 0x24, 0x14, 0x2B, 0x03, 
    0x1D, 0x09, 0x2C, 0x13, 0x2A, 0x24, 0x2E, 0x05, 0x21, 0x0C, 0x07, 

    0x1C, 0x0E, 0x24, 0x2B, 0x17, 0x21, 0x31, 0x0C, 0x2C, 0x22,         // 68
    0x16, 0x01, 0x2B, 0x25, 0x14, 0x05, 0x1D, 0x2B, 0x20, 0x0C, 
    0x27, 0x13, 0x2C, 0x21, 0x1D, 0x2E, 0x19, 0x2A, 0x23, 0x17, 
    0x27, 0x00, 0x13, 0x08, 0x25, 0x1E, 0x2A, 0x13, 0x06, 0x0C, 
    0x28, 0x01, 0x29, 0x05, 0x24, 0x13, 0x1F, 0x15, 0x2A, 0x09, 
    0x2F, 0x17, 0x13, 0x31, 0x08, 0x2A, 0x18, 0x25, 0x0C, 0x2C, 
    0x16, 0x05, 0x0F, 0x28, 0x11, 0x23, 0x07, 0x2D, 0x02, 0x1A, 
    0x20, 0x12, 0x1A, 0x21, 0x06, 0x2D, 0x1B, 0x08, 0x0F, 0x27, 
    0x31, 0x16, 0x25, 0x0A, 0x04, 0x17, 0x0F, 0x1D, 0x13, 0x2C, 0x14, 

    0x20, 0x32, 0x06, 0x10, 0x09, 0x29, 0x02, 0x17, 0x1E, 0x10,         // 69
    0x2E, 0x1B, 0x11, 0x06, 0x20, 0x2E, 0x0F, 0x03, 0x19, 0x2D, 
    0x01, 0x1B, 0x05, 0x16, 0x08, 0x12, 0x0D, 0x02, 0x1C, 0x30, 
    0x0B, 0x2E, 0x1D, 0x29, 0x14, 0x0B, 0x04, 0x1A, 0x2C, 0x1D, 
    0x11, 0x17, 0x0A, 0x2F, 0x19, 0x07, 0x30, 0x0C, 0x1A, 0x23, 
    0x03, 0x0D, 0x24, 0x01, 0x19, 0x0F, 0x30, 0x05, 0x29, 0x02, 
    0x1E, 0x22, 0x1B, 0x2E, 0x05, 0x29, 0x19, 0x12, 0x2A, 0x0E, 
    0x2F, 0x01, 0x2A, 0x09, 0x17, 0x27, 0x01, 0x30, 0x22, 0x0C, 
    0x19, 0x00, 0x10, 0x1C, 0x2F, 0x23, 0x01, 0x28, 0x08, 0x24, 0x04, 

    0x0A, 0x17, 0x1F, 0x2D, 0x1B, 0x12, 0x23, 0x08, 0x27, 0x0A,         // 70
    0x06, 0x25, 0x31, 0x19, 0x0B, 0x29, 0x16, 0x25, 0x09, 0x23, 
    0x0F, 0x20, 0x2A, 0x0D, 0x32, 0x26, 0x20, 0x2C, 0x11, 0x06, 
    0x15, 0x21, 0x06, 0x0D, 0x2D, 0x23, 0x30, 0x0F, 0x21, 0x03, 
    0x31, 0x23, 0x1F, 0x11, 0x27, 0x0E, 0x22, 0x02, 0x2C, 0x16, 
    0x29, 0x1E, 0x2C, 0x0C, 0x23, 0x1F, 0x0B, 0x14, 0x1B, 0x10, 
    0x32, 0x13, 0x0B, 0x18, 0x21, 0x0A, 0x1F, 0x05, 0x24, 0x09, 
    0x16, 0x22, 0x0F, 0x2E, 0x1F, 0x0E, 0x13, 0x1D, 0x16, 0x05, 
    0x20, 0x2C, 0x28, 0x1F, 0x0B, 0x19, 0x11, 0x31, 0x1C, 0x16, 0x2E, 

    0x11, 0x29, 0x01, 0x0D, 0x22, 0x05, 0x2F, 0x1A, 0x2D, 0x15,         // 71
    0x1F, 0x0F, 0x03, 0x22, 0x12, 0x1C, 0x08, 0x32, 0x11, 0x1B, 
    0x30, 0x0A, 0x14, 0x24, 0x19, 0x04, 0x16, 0x09, 0x1F, 0x26, 
    0x2B, 0x10, 0x1A, 0x22, 0x01, 0x19, 0x06, 0x28, 0x15, 0x0D, 
    0x26, 0x0F, 0x02, 0x1B, 0x06, 0x2C, 0x14, 0x1D, 0x0F, 0x07, 
    0x13, 0x0A, 0x1A, 0x14, 0x2E, 0x04, 0x26, 0x2D, 0x20, 0x08, 
    0x27, 0x06, 0x2D, 0x02, 0x12, 0x2C, 0x14, 0x31, 0x18, 0x1F, 
    0x29, 0x04, 0x1B, 0x15, 0x03, 0x24, 0x2B, 0x09, 0x2D, 0x25, 
    0x13, 0x08, 0x0D, 0x15, 0x03, 0x2B, 0x25, 0x09, 0x0E, 0x02, 0x27, 

    0x07, 0x23, 0x13, 0x30, 0x18, 0x2A, 0x0B, 0x10, 0x01, 0x22,         // 72
    0x19, 0x2D, 0x29, 0x09, 0x27, 0x04, 0x2A, 0x1F, 0x02, 0x15, 
    0x26, 0x06, 0x2C, 0x02, 0x1E, 0x0B, 0x28, 0x30, 0x03, 0x19, 
    0x0C, 0x04, 0x2A, 0x14, 0x20, 0x11, 0x1D, 0x09, 0x2B, 0x1A, 
    0x06, 0x16, 0x2E, 0x2A, 0x16, 0x25, 0x09, 0x2E, 0x27, 0x20, 
    0x31, 0x26, 0x02, 0x2A, 0x08, 0x1D, 0x17, 0x02, 0x0D, 0x24, 
    0x16, 0x1C, 0x29, 0x1F, 0x26, 0x0E, 0x01, 0x27, 0x0E, 0x06, 
    0x12, 0x31, 0x24, 0x0B, 0x29, 0x07, 0x18, 0x21, 0x02, 0x10, 
    0x2F, 0x1A, 0x26, 0x32, 0x21, 0x07, 0x16, 0x1E, 0x2A, 0x21, 0x1A, 

    0x15, 0x2C, 0x1C, 0x09, 0x03, 0x15, 0x1D, 0x24, 0x29, 0x12,         // 73
    0x05, 0x0C, 0x15, 0x1A, 0x2F, 0x14, 0x19, 0x0C, 0x25, 0x2B, 
    0x0D, 0x18, 0x1F, 0x10, 0x2F, 0x13, 0x23, 0x0E, 0x15, 0x2D, 
    0x23, 0x1C, 0x2F, 0x09, 0x0E, 0x31, 0x25, 0x18, 0x00, 0x30, 
    0x1E, 0x28, 0x07, 0x21, 0x10, 0x01, 0x1B, 0x0E, 0x06, 0x19, 
    0x04, 0x0F, 0x21, 0x19, 0x12, 0x28, 0x0F, 0x2B, 0x19, 0x2F, 
    0x01, 0x0D, 0x14, 0x09, 0x18, 0x2F, 0x1D, 0x16, 0x21, 0x2D, 
    0x1D, 0x08, 0x10, 0x2C, 0x1E, 0x12, 0x32, 0x0C, 0x1C, 0x2A, 
    0x06, 0x1F, 0x01, 0x12, 0x1B, 0x0E, 0x2F, 0x05, 0x10, 0x30, 0x0C, 

    0x1F, 0x05, 0x10, 0x28, 0x25, 0x21, 0x06, 0x32, 0x0D, 0x1C,         // 74
    0x30, 0x26, 0x20, 0x00, 0x0F, 0x23, 0x06, 0x2D, 0x10, 0x05, 
    0x1E, 0x2F, 0x0A, 0x25, 0x07, 0x2B, 0x00, 0x1B, 0x20, 0x0A, 
    0x12, 0x01, 0x26, 0x19, 0x23, 0x03, 0x0B, 0x2C, 0x10, 0x22, 
    0x0C, 0x13, 0x1A, 0x0B, 0x1F, 0x32, 0x29, 0x17, 0x22, 0x12, 
    0x2B, 0x1D, 0x29, 0x0A, 0x32, 0x05, 0x22, 0x09, 0x1F, 0x11, 
    0x2A, 0x21, 0x30, 0x04, 0x24, 0x0C, 0x06, 0x2B, 0x0B, 0x02, 
    0x14, 0x28, 0x18, 0x00, 0x1A, 0x27, 0x04, 0x15, 0x26, 0x0E, 
    0x17, 0x0B, 0x24, 0x2C, 0x0A, 0x28, 0x23, 0x19, 0x14, 0x03, 0x26, 

    0x17, 0x31, 0x20, 0x0C, 0x2F, 0x12, 0x0B, 0x19, 0x02, 0x20,         // 75
    0x07, 0x11, 0x0A, 0x2C, 0x1E, 0x0A, 0x27, 0x1D, 0x17, 0x22, 
    0x13, 0x01, 0x2A, 0x15, 0x19, 0x20, 0x10, 0x2E, 0x05, 0x28, 
    0x32, 0x17, 0x0F, 0x06, 0x2D, 0x16, 0x28, 0x20, 0x14, 0x07, 
    0x2A, 0x02, 0x30, 0x25, 0x05, 0x14, 0x08, 0x24, 0x02, 0x30, 
    0x09, 0x14, 0x03, 0x10, 0x1F, 0x1A, 0x2D, 0x14, 0x03, 0x25, 
    0x07, 0x19, 0x0F, 0x27, 0x12, 0x1F, 0x29, 0x11, 0x1C, 0x25, 
    0x2F, 0x0D, 0x22, 0x30, 0x09, 0x0F, 0x23, 0x2D, 0x05, 0x20, 
    0x31, 0x28, 0x10, 0x06, 0x1F, 0x15, 0x00, 0x2B, 0x20, 0x2D, 0x09, 

    0x2A, 0x02, 0x14, 0x1A, 0x00, 0x1E, 0x27, 0x2C, 0x14, 0x2A,         // 76
    0x17, 0x2D, 0x1B, 0x26, 0x16, 0x31, 0x11, 0x01, 0x2F, 0x0D, 
    0x28, 0x1B, 0x0F, 0x04, 0x27, 0x08, 0x18, 0x27, 0x13, 0x1A, 
    0x08, 0x1F, 0x2C, 0x21, 0x12, 0x1D, 0x0F, 0x03, 0x1C, 0x2D, 
    0x24, 0x1C, 0x0F, 0x16, 0x2C, 0x1C, 0x10, 0x2E, 0x0D, 0x1E, 
    0x28, 0x18, 0x2E, 0x24, 0x15, 0x00, 0x0D, 0x29, 0x17, 0x31, 
    0x0C, 0x1D, 0x06, 0x2E, 0x1B, 0x01, 0x15, 0x32, 0x09, 0x18, 
    0x04, 0x1E, 0x06, 0x13, 0x2A, 0x1F, 0x17, 0x0A, 0x1C, 0x13, 
    0x03, 0x19, 0x22, 0x18, 0x30, 0x09, 0x1D, 0x0D, 0x06, 0x1A, 0x10, 

    0x0C, 0x23, 0x29, 0x09, 0x2D, 0x17, 0x06, 0x0E, 0x22, 0x0A,         // 77
    0x24, 0x02, 0x14, 0x06, 0x0D, 0x04, 0x1A, 0x2A, 0x08, 0x25, 
    0x07, 0x31, 0x20, 0x2B, 0x1C, 0x31, 0x0D, 0x03, 0x21, 0x0C, 
    0x25, 0x14, 0x02, 0x0C, 0x27, 0x08, 0x2F, 0x25, 0x09, 0x17, 
    0x0D, 0x04, 0x27, 0x09, 0x23, 0x02, 0x20, 0x27, 0x19, 0x04, 
    0x10, 0x20, 0x06, 0x2A, 0x0A, 0x30, 0x24, 0x1C, 0x05, 0x1F, 
    0x13, 0x23, 0x2B, 0x16, 0x09, 0x22, 0x27, 0x05, 0x22, 0x2C, 
    0x10, 0x2A, 0x1A, 0x25, 0x0B, 0x03, 0x2F, 0x0E, 0x2B, 0x27, 
    0x09, 0x2E, 0x0C, 0x02, 0x27, 0x10, 0x25, 0x30, 0x12, 0x28, 0x1E, 

    0x15, 0x06, 0x1D, 0x0F, 0x22, 0x11, 0x2F, 0x1C, 0x04, 0x30,         // 78
    0x10, 0x1E, 0x2E, 0x21, 0x2B, 0x27, 0x20, 0x13, 0x18, 0x1E, 
    0x11, 0x19, 0x05, 0x15, 0x09, 0x12, 0x23, 0x2C, 0x1B, 0x30, 
    0x05, 0x2A, 0x1C, 0x31, 0x16, 0x04, 0x1A, 0x13, 0x29, 0x32, 
    0x14, 0x21, 0x2F, 0x12, 0x2B, 0x18, 0x0C, 0x08, 0x13, 0x2C, 
    0x24, 0x0B, 0x1B, 0x0F, 0x21, 0x19, 0x07, 0x11, 0x2E, 0x0A, 
    0x28, 0x0E, 0x02, 0x20, 0x11, 0x2F, 0x0D, 0x1B, 0x0E, 0x15, 
    0x24, 0x07, 0x0F, 0x2E, 0x15, 0x24, 0x1B, 0x06, 0x21, 0x16, 
    0x10, 0x25, 0x1D, 0x13, 0x2C, 0x1A, 0x03, 0x16, 0x22, 0x02, 0x2D, 

    0x25, 0x30, 0x18, 0x2B, 0x03, 0x28, 0x08, 0x20, 0x15, 0x28,         // 79
    0x18, 0x07, 0x0B, 0x12, 0x1B, 0x0F, 0x08, 0x30, 0x0A, 0x2B, 
    0x00, 0x26, 0x0C, 0x2E, 0x21, 0x05, 0x29, 0x14, 0x08, 0x16, 
    0x0F, 0x22, 0x11, 0x0A, 0x1F, 0x2A, 0x22, 0x0B, 0x01, 0x1E, 
    0x06, 0x1A, 0x08, 0x1E, 0x04, 0x21, 0x31, 0x29, 0x1D, 0x06, 
    0x30, 0x16, 0x29, 0x02, 0x13, 0x2B, 0x0C, 0x20, 0x25, 0x01, 
    0x18, 0x30, 0x26, 0x0B, 0x2A, 0x18, 0x03, 0x2D, 0x20, 0x01, 
    0x31, 0x17, 0x20, 0x01, 0x1E, 0x0C, 0x29, 0x11, 0x31, 0x00, 
    0x1B, 0x2A, 0x07, 0x20, 0x05, 0x22, 0x0B, 0x2C, 0x08, 0x19, 0x0A, 

    0x10, 0x01, 0x13, 0x0A, 0x1F, 0x19, 0x12, 0x26, 0x0C, 0x03,         // 80
    0x22, 0x2A, 0x1F, 0x32, 0x05, 0x17, 0x22, 0x04, 0x24, 0x14, 
    0x1F, 0x2D, 0x12, 0x27, 0x17, 0x1B, 0x0E, 0x01, 0x20, 0x26, 
    0x2D, 0x03, 0x18, 0x29, 0x01, 0x0F, 0x2E, 0x18, 0x27, 0x0F, 
    0x24, 0x2D, 0x10, 0x2A, 0x0B, 0x14, 0x0E, 0x00, 0x16, 0x21, 
    0x11, 0x04, 0x22, 0x2E, 0x1C, 0x25, 0x04, 0x16, 0x2C, 0x13, 
    0x1D, 0x05, 0x15, 0x1B, 0x06, 0x1F, 0x13, 0x25, 0x09, 0x1C, 
    0x0C, 0x2B, 0x08, 0x26, 0x12, 0x2D, 0x04, 0x17, 0x1E, 0x0E, 
    0x2E, 0x0B, 0x18, 0x32, 0x0E, 0x14, 0x29, 0x1D, 0x12, 0x31, 0x20, 

    0x1B, 0x29, 0x24, 0x2F, 0x0E, 0x2B, 0x01, 0x31, 0x1A, 0x2C,         // 81
    0x10, 0x16, 0x00, 0x0E, 0x24, 0x2C, 0x1D, 0x11, 0x2E, 0x0C, 
    0x17, 0x07, 0x1D, 0x03, 0x0A, 0x2C, 0x25, 0x32, 0x19, 0x0B, 
    0x1C, 0x08, 0x2F, 0x23, 0x1C, 0x16, 0x06, 0x1D, 0x12, 0x2B, 
    0x0B, 0x17, 0x02, 0x25, 0x1A, 0x2E, 0x1C, 0x26, 0x2D, 0x0A, 
    0x2A, 0x1D, 0x09, 0x12, 0x07, 0x0F, 0x31, 0x1B, 0x0D, 0x08, 
    0x29, 0x22, 0x0F, 0x2E, 0x27, 0x0C, 0x31, 0x10, 0x29, 0x15, 
    0x23, 0x11, 0x1A, 0x2F, 0x0A, 0x1B, 0x25, 0x0A, 0x28, 0x06, 
    0x24, 0x12, 0x03, 0x24, 0x2B, 0x1B, 0x07, 0x23, 0x0C, 0x28, 0x06, 

    0x2E, 0x0D, 0x08, 0x1B, 0x05, 0x16, 0x22, 0x0D, 0x06, 0x1E,         // 82
    0x09, 0x2E, 0x1A, 0x29, 0x14, 0x03, 0x0C, 0x28, 0x1B, 0x02, 
    0x29, 0x24, 0x0F, 0x30, 0x14, 0x1F, 0x09, 0x12, 0x06, 0x29, 
    0x14, 0x20, 0x12, 0x0C, 0x08, 0x31, 0x25, 0x0A, 0x2F, 0x03, 
    0x1C, 0x27, 0x31, 0x15, 0x08, 0x23, 0x04, 0x13, 0x07, 0x19, 
    0x0E, 0x26, 0x17, 0x2F, 0x28, 0x19, 0x21, 0x03, 0x28, 0x1F, 
    0x32, 0x0A, 0x20, 0x00, 0x17, 0x21, 0x04, 0x1A, 0x07, 0x2E, 
    0x03, 0x29, 0x06, 0x15, 0x22, 0x03, 0x13, 0x2C, 0x1F, 0x15, 
    0x1A, 0x29, 0x1E, 0x0A, 0x13, 0x02, 0x2D, 0x17, 0x00, 0x1E, 0x14, 

    0x03, 0x16, 0x22, 0x12, 0x28, 0x2E, 0x11, 0x20, 0x29, 0x13,         // 83
    0x26, 0x05, 0x21, 0x0A, 0x1E, 0x30, 0x17, 0x07, 0x21, 0x13, 
    0x32, 0x08, 0x19, 0x28, 0x23, 0x04, 0x1C, 0x2B, 0x24, 0x0F, 
    0x30, 0x01, 0x26, 0x2B, 0x1F, 0x10, 0x04, 0x22, 0x15, 0x1F, 
    0x09, 0x10, 0x06, 0x22, 0x11, 0x2B, 0x0C, 0x2F, 0x1E, 0x24, 
    0x32, 0x03, 0x0C, 0x20, 0x00, 0x0B, 0x14, 0x2E, 0x18, 0x11, 
    0x02, 0x1C, 0x13, 0x2A, 0x08, 0x14, 0x2C, 0x26, 0x20, 0x0E, 
    0x1C, 0x0B, 0x20, 0x2B, 0x0E, 0x32, 0x1D, 0x0E, 0x01, 0x30, 
    0x08, 0x0E, 0x2E, 0x19, 0x27, 0x1F, 0x0E, 0x26, 0x2F, 0x0F, 0x23, 

    0x28, 0x1D, 0x31, 0x02, 0x1F, 0x08, 0x1B, 0x05, 0x18, 0x30,         // 84
    0x0E, 0x17, 0x2F, 0x12, 0x06, 0x23, 0x2A, 0x12, 0x2D, 0x05, 
    0x1C, 0x0C, 0x20, 0x01, 0x10, 0x2D, 0x0E, 0x15, 0x03, 0x1D, 
    0x18, 0x0B, 0x1B, 0x06, 0x15, 0x27, 0x2C, 0x19, 0x0D, 0x2A, 
    0x24, 0x19, 0x2C, 0x1F, 0x01, 0x19, 0x28, 0x17, 0x02, 0x0F, 
    0x15, 0x1C, 0x2B, 0x10, 0x1D, 0x2C, 0x25, 0x06, 0x0B, 0x26, 
    0x16, 0x2C, 0x0D, 0x25, 0x30, 0x1F, 0x0A, 0x11, 0x01, 0x17, 
    0x31, 0x25, 0x13, 0x00, 0x1A, 0x25, 0x06, 0x18, 0x26, 0x13, 
    0x2A, 0x21, 0x01, 0x10, 0x08, 0x31, 0x06, 0x13, 0x1B, 0x09, 0x2C, 

    0x06, 0x11, 0x0C, 0x27, 0x17, 0x0E, 0x26, 0x2D, 0x0B, 0x03,         // 85
    0x22, 0x1D, 0x02, 0x2B, 0x19, 0x0C, 0x01, 0x1E, 0x0E, 0x25, 
    0x16, 0x2B, 0x12, 0x2E, 0x17, 0x07, 0x26, 0x31, 0x21, 0x08, 
    0x2C, 0x28, 0x13, 0x2F, 0x1C, 0x01, 0x13, 0x08, 0x1E, 0x00, 
    0x30, 0x05, 0x13, 0x0A, 0x30, 0x0E, 0x1F, 0x0A, 0x25, 0x2C, 
    0x08, 0x22, 0x06, 0x26, 0x17, 0x05, 0x12, 0x1D, 0x22, 0x2D, 
    0x09, 0x21, 0x05, 0x1A, 0x03, 0x0F, 0x19, 0x2F, 0x24, 0x2A, 
    0x06, 0x0F, 0x1D, 0x2E, 0x09, 0x11, 0x29, 0x2D, 0x08, 0x1D, 
    0x04, 0x16, 0x1E, 0x2B, 0x24, 0x16, 0x1D, 0x2B, 0x04, 0x21, 0x15, 

    0x1F, 0x19, 0x2B, 0x06, 0x21, 0x30, 0x00, 0x14, 0x1F, 0x2B,         // 86
    0x12, 0x09, 0x27, 0x20, 0x10, 0x31, 0x25, 0x18, 0x09, 0x2F, 
    0x02, 0x26, 0x06, 0x1C, 0x22, 0x1F, 0x0A, 0x19, 0x0D, 0x14, 
    0x23, 0x0E, 0x03, 0x24, 0x0D, 0x21, 0x32, 0x25, 0x2B, 0x14, 
    0x0F, 0x21, 0x1B, 0x26, 0x16, 0x23, 0x05, 0x31, 0x11, 0x18, 
    0x28, 0x0E, 0x14, 0x2E, 0x0D, 0x27, 0x31, 0x0E, 0x17, 0x05, 
    0x1C, 0x10, 0x2D, 0x14, 0x22, 0x29, 0x06, 0x1C, 0x0A, 0x13, 
    0x1A, 0x2C, 0x04, 0x28, 0x16, 0x22, 0x02, 0x14, 0x21, 0x0E, 
    0x24, 0x31, 0x07, 0x13, 0x0C, 0x03, 0x25, 0x0D, 0x18, 0x32, 0x0E, 

    0x2C, 0x23, 0x09, 0x14, 0x1C, 0x11, 0x25, 0x1C, 0x0F, 0x26,         // 87
    0x19, 0x31, 0x0E, 0x05, 0x1C, 0x15, 0x07, 0x2C, 0x20, 0x14, 
    0x1D, 0x10, 0x31, 0x0B, 0x04, 0x12, 0x2E, 0x00, 0x28, 0x2D, 
    0x04, 0x1F, 0x19, 0x2C, 0x09, 0x1A, 0x11, 0x0B, 0x06, 0x1C, 
    0x28, 0x0A, 0x2E, 0x03, 0x0C, 0x29, 0x13, 0x1C, 0x07, 0x20, 
    0x01, 0x30, 0x1E, 0x04, 0x1A, 0x09, 0x21, 0x02, 0x29, 0x2F, 
    0x15, 0x28, 0x07, 0x1F, 0x0A, 0x2F, 0x25, 0x14, 0x21, 0x02, 
    0x23, 0x0C, 0x17, 0x24, 0x0B, 0x1B, 0x30, 0x0C, 0x1A, 0x2E, 
    0x12, 0x0B, 0x28, 0x1C, 0x2F, 0x19, 0x2E, 0x07, 0x28, 0x1C, 0x01, 

    0x13, 0x0D, 0x30, 0x27, 0x04, 0x2C, 0x07, 0x0C, 0x2E, 0x04,         // 88
    0x08, 0x1E, 0x17, 0x2A, 0x24, 0x0B, 0x29, 0x11, 0x03, 0x24, 
    0x07, 0x18, 0x21, 0x16, 0x2C, 0x26, 0x17, 0x1E, 0x0F, 0x1B, 
    0x12, 0x31, 0x07, 0x15, 0x27, 0x04, 0x29, 0x20, 0x18, 0x2F, 
    0x04, 0x15, 0x22, 0x11, 0x2C, 0x1A, 0x02, 0x24, 0x2C, 0x0D, 
    0x26, 0x19, 0x0B, 0x24, 0x2A, 0x14, 0x1D, 0x12, 0x24, 0x0D, 
    0x00, 0x23, 0x32, 0x0E, 0x17, 0x01, 0x10, 0x2C, 0x0D, 0x28, 
    0x32, 0x1F, 0x09, 0x2F, 0x13, 0x06, 0x1E, 0x29, 0x09, 0x03, 
    0x2A, 0x19, 0x02, 0x23, 0x06, 0x0F, 0x1F, 0x15, 0x10, 0x09, 0x26, 

    0x06, 0x22, 0x02, 0x19, 0x10, 0x20, 0x18, 0x29, 0x16, 0x21,         // 89
    0x13, 0x2D, 0x01, 0x12, 0x2E, 0x02, 0x1E, 0x17, 0x30, 0x0C, 
    0x2D, 0x29, 0x02, 0x0F, 0x1F, 0x0D, 0x08, 0x2A, 0x06, 0x26, 
    0x0B, 0x1C, 0x2A, 0x10, 0x20, 0x17, 0x2D, 0x02, 0x12, 0x24, 
    0x0F, 0x29, 0x19, 0x06, 0x1E, 0x09, 0x2F, 0x15, 0x10, 0x1B, 
    0x06, 0x14, 0x2C, 0x10, 0x01, 0x30, 0x06, 0x2C, 0x08, 0x1F, 
    0x1A, 0x13, 0x05, 0x1B, 0x2B, 0x23, 0x1C, 0x05, 0x1F, 0x17, 
    0x04, 0x10, 0x1C, 0x02, 0x2B, 0x25, 0x10, 0x16, 0x25, 0x1E, 
    0x15, 0x21, 0x10, 0x2A, 0x16, 0x2C, 0x01, 0x2A, 0x21, 0x30, 0x18, 

    0x2D, 0x1D, 0x15, 0x2E, 0x24, 0x0A, 0x32, 0x02, 0x1D, 0x0A,         // 90
    0x23, 0x27, 0x0D, 0x1F, 0x19, 0x10, 0x22, 0x07, 0x26, 0x1C, 
    0x16, 0x0A, 0x25, 0x2F, 0x1B, 0x03, 0x31, 0x21, 0x14, 0x2F, 
    0x02, 0x23, 0x0D, 0x00, 0x30, 0x08, 0x0C, 0x1C, 0x28, 0x08, 
    0x1E, 0x01, 0x2D, 0x26, 0x13, 0x21, 0x0E, 0x27, 0x03, 0x32, 
    0x21, 0x28, 0x09, 0x20, 0x17, 0x25, 0x0E, 0x1B, 0x15, 0x28, 
    0x30, 0x0B, 0x20, 0x27, 0x11, 0x0B, 0x15, 0x30, 0x09, 0x2B, 
    0x14, 0x24, 0x29, 0x15, 0x21, 0x0B, 0x2D, 0x01, 0x31, 0x0F, 
    0x05, 0x2E, 0x08, 0x1D, 0x0C, 0x26, 0x12, 0x1A, 0x05, 0x0E, 0x1F, 
};

const BYTE HT_SuperCell_Blue216[91*91] = {
    0x2D, 0x22, 0x16, 0x10, 0x25, 0x2E, 0x1E, 0x00, 0x28, 0x0F,         //  0
    0x2B, 0x06, 0x31, 0x12, 0x2D, 0x0C, 0x14, 0x1C, 0x27, 0x31, 
    0x08, 0x2B, 0x25, 0x15, 0x1D, 0x11, 0x2F, 0x04, 0x22, 0x06, 
    0x30, 0x01, 0x18, 0x1F, 0x11, 0x25, 0x06, 0x20, 0x10, 0x28, 
    0x16, 0x23, 0x18, 0x31, 0x1F, 0x09, 0x1B, 0x03, 0x1F, 0x10, 
    0x29, 0x1D, 0x02, 0x0E, 0x25, 0x00, 0x17, 0x11, 0x27, 0x2E, 
    0x1D, 0x06, 0x2E, 0x21, 0x14, 0x2A, 0x12, 0x1A, 0x1F, 0x11, 
    0x05, 0x1C, 0x2E, 0x1A, 0x25, 0x09, 0x1D, 0x2A, 0x19, 0x1E, 
    0x2E, 0x20, 0x16, 0x0D, 0x07, 0x28, 0x03, 0x14, 0x2C, 0x01, 0x24, 

    0x19, 0x03, 0x30, 0x0A, 0x19, 0x06, 0x14, 0x31, 0x0A, 0x20,         //  1
    0x15, 0x1A, 0x0B, 0x27, 0x16, 0x24, 0x2F, 0x10, 0x00, 0x1E, 
    0x19, 0x03, 0x2F, 0x0B, 0x21, 0x00, 0x28, 0x0C, 0x2C, 0x12, 
    0x1D, 0x14, 0x27, 0x06, 0x2C, 0x1B, 0x14, 0x2F, 0x02, 0x1C, 
    0x07, 0x0C, 0x26, 0x06, 0x16, 0x2E, 0x12, 0x2B, 0x15, 0x06, 
    0x2F, 0x0B, 0x18, 0x29, 0x13, 0x1F, 0x2F, 0x0A, 0x21, 0x01, 
    0x0D, 0x29, 0x17, 0x05, 0x25, 0x02, 0x32, 0x0A, 0x29, 0x17, 
    0x30, 0x26, 0x07, 0x0F, 0x01, 0x2C, 0x15, 0x0E, 0x01, 0x13, 
    0x08, 0x1A, 0x02, 0x2C, 0x1D, 0x17, 0x21, 0x09, 0x10, 0x1C, 0x0E, 

    0x28, 0x13, 0x1D, 0x28, 0x2D, 0x0C, 0x23, 0x19, 0x13, 0x2D,         //  2
    0x02, 0x2A, 0x22, 0x06, 0x1B, 0x03, 0x09, 0x2B, 0x21, 0x0B, 
    0x13, 0x21, 0x17, 0x05, 0x2C, 0x19, 0x13, 0x23, 0x17, 0x20, 
    0x07, 0x2A, 0x0A, 0x23, 0x15, 0x01, 0x26, 0x0A, 0x2A, 0x21, 
    0x13, 0x2B, 0x1D, 0x12, 0x27, 0x02, 0x21, 0x0D, 0x22, 0x26, 
    0x17, 0x20, 0x2C, 0x08, 0x19, 0x0D, 0x28, 0x04, 0x25, 0x1A, 
    0x15, 0x20, 0x0E, 0x1B, 0x2C, 0x0F, 0x16, 0x22, 0x04, 0x0E, 
    0x22, 0x0B, 0x18, 0x21, 0x28, 0x1B, 0x05, 0x30, 0x21, 0x27, 
    0x0F, 0x31, 0x25, 0x14, 0x0E, 0x2F, 0x0C, 0x24, 0x31, 0x1F, 0x06, 

    0x0A, 0x23, 0x07, 0x11, 0x01, 0x1C, 0x2A, 0x05, 0x26, 0x08,         //  3
    0x1E, 0x0D, 0x12, 0x2E, 0x25, 0x13, 0x1F, 0x18, 0x06, 0x26, 
    0x2E, 0x0D, 0x1E, 0x27, 0x0F, 0x1F, 0x07, 0x32, 0x02, 0x0B, 
    0x24, 0x10, 0x31, 0x1C, 0x0E, 0x2E, 0x1F, 0x11, 0x1B, 0x0D, 
    0x30, 0x00, 0x0E, 0x2D, 0x0B, 0x1D, 0x18, 0x07, 0x2E, 0x00, 
    0x0C, 0x12, 0x03, 0x22, 0x2D, 0x06, 0x1B, 0x13, 0x31, 0x0F, 
    0x2B, 0x03, 0x2F, 0x08, 0x23, 0x19, 0x06, 0x28, 0x2D, 0x1B, 
    0x01, 0x2C, 0x11, 0x32, 0x13, 0x0A, 0x1F, 0x25, 0x06, 0x2C, 
    0x17, 0x0A, 0x1F, 0x06, 0x2A, 0x01, 0x19, 0x29, 0x04, 0x15, 0x2D, 

    0x10, 0x32, 0x18, 0x20, 0x26, 0x15, 0x0E, 0x2D, 0x10, 0x1A,         //  4
    0x30, 0x24, 0x17, 0x01, 0x0E, 0x32, 0x27, 0x10, 0x2F, 0x15, 
    0x02, 0x2A, 0x07, 0x14, 0x30, 0x0A, 0x27, 0x11, 0x2A, 0x1A, 
    0x2E, 0x02, 0x18, 0x06, 0x29, 0x09, 0x18, 0x04, 0x2C, 0x07, 
    0x17, 0x25, 0x19, 0x22, 0x07, 0x31, 0x10, 0x2A, 0x13, 0x1B, 
    0x28, 0x31, 0x1C, 0x0F, 0x25, 0x11, 0x20, 0x2A, 0x0C, 0x06, 
    0x22, 0x11, 0x26, 0x14, 0x0B, 0x30, 0x1D, 0x0D, 0x12, 0x24, 
    0x15, 0x1F, 0x06, 0x25, 0x03, 0x2A, 0x16, 0x10, 0x0B, 0x1F, 
    0x04, 0x28, 0x11, 0x19, 0x26, 0x1F, 0x12, 0x08, 0x1B, 0x0E, 0x25, 

    0x19, 0x29, 0x03, 0x0C, 0x2F, 0x07, 0x1F, 0x02, 0x20, 0x15,         //  5
    0x04, 0x0A, 0x2C, 0x20, 0x19, 0x0A, 0x02, 0x1D, 0x0C, 0x23, 
    0x1B, 0x11, 0x23, 0x19, 0x01, 0x24, 0x17, 0x05, 0x22, 0x0E, 
    0x15, 0x29, 0x20, 0x13, 0x24, 0x10, 0x2F, 0x26, 0x15, 0x1F, 
    0x28, 0x11, 0x04, 0x29, 0x14, 0x1F, 0x26, 0x03, 0x1F, 0x0E, 
    0x23, 0x05, 0x15, 0x09, 0x2F, 0x01, 0x16, 0x07, 0x1F, 0x18, 
    0x2D, 0x1B, 0x06, 0x1E, 0x2A, 0x01, 0x16, 0x21, 0x03, 0x31, 
    0x07, 0x2A, 0x1A, 0x0C, 0x1D, 0x0E, 0x2F, 0x1B, 0x2D, 0x13, 
    0x1A, 0x2C, 0x02, 0x2E, 0x08, 0x0C, 0x24, 0x2D, 0x22, 0x2B, 0x00, 

    0x0D, 0x22, 0x14, 0x1D, 0x10, 0x28, 0x19, 0x32, 0x0C, 0x2B,         //  6
    0x26, 0x10, 0x1D, 0x08, 0x29, 0x23, 0x15, 0x2A, 0x04, 0x2C, 
    0x08, 0x31, 0x0A, 0x2B, 0x1D, 0x0D, 0x2E, 0x1B, 0x28, 0x04, 
    0x1D, 0x08, 0x0C, 0x30, 0x00, 0x1D, 0x07, 0x22, 0x0B, 0x02, 
    0x32, 0x0C, 0x1C, 0x2F, 0x05, 0x0D, 0x19, 0x0A, 0x30, 0x16, 
    0x0A, 0x2D, 0x27, 0x1F, 0x19, 0x2A, 0x23, 0x30, 0x12, 0x28, 
    0x00, 0x0D, 0x32, 0x17, 0x10, 0x23, 0x2D, 0x09, 0x28, 0x18, 
    0x10, 0x0A, 0x26, 0x15, 0x2B, 0x22, 0x09, 0x02, 0x28, 0x07, 
    0x24, 0x0E, 0x20, 0x14, 0x1D, 0x32, 0x15, 0x04, 0x0B, 0x13, 0x1E, 

    0x2B, 0x05, 0x25, 0x2D, 0x04, 0x22, 0x0B, 0x12, 0x24, 0x08,         //  7
    0x18, 0x2E, 0x04, 0x17, 0x11, 0x2D, 0x0D, 0x22, 0x19, 0x13, 
    0x1F, 0x16, 0x25, 0x05, 0x11, 0x29, 0x13, 0x0A, 0x31, 0x11, 
    0x25, 0x2E, 0x19, 0x26, 0x15, 0x2A, 0x1A, 0x0F, 0x2D, 0x1B, 
    0x13, 0x20, 0x08, 0x16, 0x22, 0x2C, 0x12, 0x27, 0x22, 0x01, 
    0x1F, 0x18, 0x10, 0x03, 0x0B, 0x14, 0x0D, 0x03, 0x1B, 0x0A, 
    0x25, 0x15, 0x22, 0x04, 0x27, 0x0A, 0x13, 0x1C, 0x0E, 0x22, 
    0x2D, 0x1E, 0x02, 0x30, 0x05, 0x12, 0x27, 0x15, 0x20, 0x0C, 
    0x31, 0x18, 0x09, 0x2A, 0x10, 0x01, 0x25, 0x19, 0x30, 0x27, 0x09, 

    0x2F, 0x11, 0x1B, 0x0A, 0x18, 0x2E, 0x03, 0x29, 0x1B, 0x00,         //  8
    0x1E, 0x13, 0x23, 0x30, 0x01, 0x1B, 0x06, 0x31, 0x0A, 0x27, 
    0x01, 0x0E, 0x1B, 0x2D, 0x1F, 0x08, 0x20, 0x00, 0x18, 0x22, 
    0x06, 0x14, 0x03, 0x21, 0x09, 0x11, 0x31, 0x04, 0x16, 0x24, 
    0x06, 0x2D, 0x26, 0x10, 0x28, 0x03, 0x1C, 0x07, 0x2C, 0x13, 
    0x29, 0x06, 0x22, 0x2E, 0x29, 0x1E, 0x25, 0x2C, 0x10, 0x2F, 
    0x1D, 0x0F, 0x2B, 0x09, 0x2F, 0x19, 0x1F, 0x05, 0x2F, 0x00, 
    0x15, 0x27, 0x1A, 0x0E, 0x22, 0x19, 0x07, 0x30, 0x1C, 0x12, 
    0x00, 0x1E, 0x27, 0x05, 0x19, 0x2B, 0x1E, 0x10, 0x05, 0x1D, 0x17, 

    0x22, 0x08, 0x29, 0x13, 0x27, 0x0F, 0x1E, 0x15, 0x2F, 0x0F,         //  9
    0x2C, 0x0A, 0x28, 0x0F, 0x1F, 0x27, 0x14, 0x1D, 0x0F, 0x2B, 
    0x22, 0x2F, 0x0B, 0x14, 0x02, 0x2E, 0x26, 0x1C, 0x2B, 0x0C, 
    0x2C, 0x1D, 0x0F, 0x2A, 0x1E, 0x06, 0x22, 0x27, 0x0A, 0x2B, 
    0x11, 0x1E, 0x01, 0x1B, 0x0A, 0x31, 0x15, 0x1F, 0x0C, 0x1B, 
    0x09, 0x31, 0x0D, 0x19, 0x11, 0x05, 0x09, 0x15, 0x20, 0x08, 
    0x29, 0x03, 0x18, 0x20, 0x12, 0x02, 0x24, 0x28, 0x11, 0x1D, 
    0x0B, 0x06, 0x12, 0x29, 0x09, 0x2C, 0x23, 0x10, 0x04, 0x2C, 
    0x23, 0x15, 0x0C, 0x2E, 0x23, 0x0E, 0x07, 0x2E, 0x21, 0x12, 0x02, 

    0x0E, 0x18, 0x31, 0x01, 0x20, 0x07, 0x21, 0x0B, 0x05, 0x27,         // 10
    0x20, 0x05, 0x15, 0x08, 0x19, 0x0C, 0x2E, 0x03, 0x20, 0x08, 
    0x17, 0x05, 0x29, 0x24, 0x19, 0x11, 0x0D, 0x15, 0x07, 0x12, 
    0x26, 0x05, 0x32, 0x16, 0x0D, 0x2D, 0x19, 0x0E, 0x1F, 0x02, 
    0x18, 0x0C, 0x2F, 0x15, 0x20, 0x0D, 0x26, 0x02, 0x2F, 0x11, 
    0x24, 0x15, 0x1D, 0x00, 0x24, 0x32, 0x1A, 0x2A, 0x01, 0x1B, 
    0x13, 0x31, 0x0C, 0x1B, 0x2C, 0x0E, 0x31, 0x0B, 0x18, 0x2A, 
    0x2D, 0x23, 0x32, 0x1D, 0x15, 0x01, 0x0D, 0x2A, 0x17, 0x25, 
    0x06, 0x2F, 0x11, 0x1F, 0x03, 0x14, 0x27, 0x16, 0x0C, 0x2C, 0x28, 

    0x24, 0x05, 0x1E, 0x10, 0x2B, 0x16, 0x31, 0x19, 0x22, 0x11,         // 11
    0x18, 0x1C, 0x32, 0x22, 0x2B, 0x06, 0x22, 0x11, 0x1A, 0x30, 
    0x13, 0x1E, 0x10, 0x07, 0x32, 0x1E, 0x05, 0x30, 0x28, 0x1F, 
    0x09, 0x18, 0x23, 0x01, 0x21, 0x13, 0x03, 0x2B, 0x13, 0x31, 
    0x23, 0x29, 0x08, 0x25, 0x04, 0x19, 0x11, 0x2A, 0x23, 0x05, 
    0x2C, 0x07, 0x27, 0x2D, 0x0B, 0x13, 0x22, 0x0E, 0x26, 0x0B, 
    0x24, 0x1E, 0x07, 0x27, 0x05, 0x17, 0x1E, 0x07, 0x20, 0x03, 
    0x0D, 0x1A, 0x02, 0x0E, 0x24, 0x2F, 0x1C, 0x1F, 0x0A, 0x13, 
    0x1C, 0x09, 0x29, 0x17, 0x0A, 0x30, 0x22, 0x02, 0x1F, 0x0A, 0x1A, 

    0x2D, 0x15, 0x26, 0x0A, 0x1B, 0x04, 0x10, 0x27, 0x09, 0x2B,         // 12
    0x03, 0x0F, 0x26, 0x02, 0x11, 0x16, 0x2A, 0x26, 0x0A, 0x28, 
    0x03, 0x2E, 0x18, 0x22, 0x0C, 0x2A, 0x17, 0x23, 0x01, 0x1A, 
    0x2D, 0x10, 0x29, 0x0B, 0x2F, 0x1D, 0x28, 0x0B, 0x1C, 0x06, 
    0x0F, 0x1D, 0x12, 0x2E, 0x22, 0x2B, 0x06, 0x1B, 0x0E, 0x19, 
    0x1F, 0x13, 0x0C, 0x21, 0x17, 0x04, 0x2C, 0x07, 0x30, 0x17, 
    0x03, 0x14, 0x2E, 0x12, 0x23, 0x2A, 0x0F, 0x2D, 0x13, 0x26, 
    0x16, 0x20, 0x13, 0x28, 0x07, 0x17, 0x11, 0x05, 0x32, 0x27, 
    0x0E, 0x21, 0x04, 0x26, 0x1B, 0x2A, 0x0F, 0x19, 0x32, 0x14, 0x03, 

    0x0D, 0x08, 0x2F, 0x13, 0x23, 0x2D, 0x1E, 0x02, 0x2F, 0x13,         // 13
    0x24, 0x2E, 0x0B, 0x1B, 0x2F, 0x1D, 0x0E, 0x00, 0x17, 0x1E, 
    0x0E, 0x23, 0x05, 0x2C, 0x13, 0x02, 0x1F, 0x0A, 0x0E, 0x14, 
    0x24, 0x05, 0x16, 0x1C, 0x11, 0x06, 0x18, 0x21, 0x2D, 0x16, 
    0x26, 0x03, 0x1A, 0x07, 0x0D, 0x13, 0x32, 0x20, 0x08, 0x29, 
    0x01, 0x30, 0x1A, 0x03, 0x2B, 0x26, 0x1D, 0x19, 0x10, 0x22, 
    0x2C, 0x26, 0x0D, 0x1C, 0x0A, 0x00, 0x1B, 0x24, 0x05, 0x30, 
    0x09, 0x2C, 0x05, 0x2E, 0x22, 0x0C, 0x2C, 0x23, 0x18, 0x01, 
    0x2B, 0x15, 0x30, 0x11, 0x00, 0x14, 0x08, 0x25, 0x06, 0x22, 0x2A, 

    0x1D, 0x20, 0x18, 0x01, 0x29, 0x08, 0x0E, 0x18, 0x20, 0x0B,         // 14
    0x1D, 0x06, 0x21, 0x14, 0x04, 0x0A, 0x2D, 0x20, 0x2B, 0x07, 
    0x14, 0x28, 0x16, 0x09, 0x1C, 0x27, 0x15, 0x2C, 0x26, 0x31, 
    0x0C, 0x1F, 0x2E, 0x03, 0x2B, 0x25, 0x09, 0x10, 0x00, 0x29, 
    0x0A, 0x30, 0x23, 0x16, 0x27, 0x1D, 0x00, 0x12, 0x2E, 0x16, 
    0x0B, 0x25, 0x11, 0x23, 0x0E, 0x09, 0x13, 0x01, 0x28, 0x0C, 
    0x08, 0x1A, 0x05, 0x21, 0x31, 0x15, 0x2B, 0x0C, 0x19, 0x10, 
    0x1C, 0x25, 0x0E, 0x18, 0x1C, 0x02, 0x27, 0x08, 0x10, 0x20, 
    0x08, 0x1A, 0x0D, 0x1E, 0x24, 0x2D, 0x1D, 0x29, 0x0E, 0x18, 0x11, 

    0x31, 0x06, 0x2A, 0x0E, 0x1F, 0x14, 0x30, 0x26, 0x05, 0x16,         // 15
    0x28, 0x11, 0x18, 0x2A, 0x22, 0x26, 0x16, 0x05, 0x11, 0x31, 
    0x20, 0x01, 0x2F, 0x24, 0x0F, 0x30, 0x06, 0x11, 0x1D, 0x03, 
    0x1A, 0x09, 0x26, 0x0F, 0x20, 0x14, 0x32, 0x1B, 0x23, 0x13, 
    0x1F, 0x0E, 0x2A, 0x05, 0x2C, 0x0A, 0x18, 0x25, 0x09, 0x20, 
    0x1C, 0x2B, 0x06, 0x2D, 0x16, 0x31, 0x25, 0x21, 0x2D, 0x1C, 
    0x13, 0x2F, 0x16, 0x28, 0x10, 0x08, 0x26, 0x03, 0x22, 0x28, 
    0x01, 0x15, 0x1F, 0x07, 0x10, 0x31, 0x1E, 0x15, 0x2E, 0x1B, 
    0x21, 0x2D, 0x05, 0x2A, 0x07, 0x0C, 0x16, 0x03, 0x2F, 0x24, 0x02, 

    0x17, 0x12, 0x24, 0x1A, 0x05, 0x24, 0x0A, 0x1A, 0x2B, 0x0E,         // 16
    0x31, 0x01, 0x2C, 0x08, 0x12, 0x31, 0x0C, 0x1C, 0x25, 0x09, 
    0x1A, 0x0D, 0x1D, 0x05, 0x19, 0x0C, 0x22, 0x19, 0x09, 0x21, 
    0x13, 0x2C, 0x1D, 0x08, 0x18, 0x02, 0x28, 0x05, 0x2E, 0x07, 
    0x19, 0x02, 0x14, 0x1C, 0x0F, 0x20, 0x2D, 0x10, 0x2A, 0x02, 
    0x0E, 0x18, 0x0A, 0x1E, 0x04, 0x1A, 0x0B, 0x06, 0x17, 0x03, 
    0x27, 0x1F, 0x01, 0x0B, 0x1E, 0x2E, 0x17, 0x1D, 0x32, 0x0E, 
    0x2D, 0x0A, 0x28, 0x2D, 0x23, 0x13, 0x05, 0x0C, 0x26, 0x03, 
    0x0B, 0x14, 0x23, 0x12, 0x18, 0x31, 0x20, 0x10, 0x1A, 0x0A, 0x27, 

    0x08, 0x2D, 0x0A, 0x30, 0x16, 0x2C, 0x13, 0x00, 0x23, 0x1C,         // 17
    0x0A, 0x20, 0x1B, 0x0E, 0x1E, 0x02, 0x20, 0x13, 0x29, 0x10, 
    0x2C, 0x15, 0x2A, 0x12, 0x2D, 0x26, 0x00, 0x2F, 0x2A, 0x0E, 
    0x25, 0x01, 0x12, 0x30, 0x24, 0x0E, 0x1D, 0x0C, 0x17, 0x2A, 
    0x25, 0x31, 0x20, 0x09, 0x2F, 0x03, 0x1C, 0x06, 0x23, 0x14, 
    0x31, 0x22, 0x28, 0x13, 0x20, 0x2A, 0x12, 0x2F, 0x0E, 0x2B, 
    0x09, 0x0F, 0x25, 0x2D, 0x1A, 0x04, 0x0F, 0x09, 0x13, 0x05, 
    0x18, 0x20, 0x12, 0x02, 0x09, 0x2B, 0x20, 0x19, 0x2A, 0x12, 
    0x1E, 0x31, 0x01, 0x1C, 0x26, 0x02, 0x29, 0x08, 0x2C, 0x13, 0x1F, 

    0x1C, 0x0E, 0x20, 0x02, 0x27, 0x08, 0x1F, 0x2D, 0x10, 0x04,         // 18
    0x27, 0x13, 0x05, 0x2F, 0x17, 0x2A, 0x07, 0x2E, 0x04, 0x1F, 
    0x07, 0x25, 0x03, 0x1F, 0x07, 0x13, 0x1E, 0x16, 0x05, 0x1B, 
    0x2F, 0x18, 0x28, 0x05, 0x1A, 0x2D, 0x26, 0x13, 0x20, 0x0B, 
    0x11, 0x06, 0x19, 0x28, 0x12, 0x26, 0x17, 0x0C, 0x2C, 0x1A, 
    0x0A, 0x11, 0x03, 0x30, 0x0F, 0x00, 0x1D, 0x26, 0x21, 0x14, 
    0x1B, 0x32, 0x17, 0x06, 0x13, 0x27, 0x21, 0x24, 0x2A, 0x1C, 
    0x26, 0x07, 0x31, 0x1C, 0x17, 0x25, 0x10, 0x01, 0x2F, 0x09, 
    0x18, 0x27, 0x0D, 0x2C, 0x0F, 0x0A, 0x16, 0x1C, 0x24, 0x00, 0x2A, 

    0x04, 0x27, 0x19, 0x13, 0x0F, 0x1B, 0x0C, 0x27, 0x15, 0x30,         // 19
    0x18, 0x2B, 0x21, 0x24, 0x0B, 0x11, 0x1B, 0x24, 0x0D, 0x18, 
    0x30, 0x16, 0x0B, 0x2E, 0x18, 0x2B, 0x0D, 0x27, 0x12, 0x20, 
    0x0C, 0x07, 0x1E, 0x0C, 0x14, 0x03, 0x0A, 0x30, 0x02, 0x1B, 
    0x23, 0x2C, 0x0D, 0x01, 0x23, 0x08, 0x31, 0x12, 0x1F, 0x04, 
    0x2D, 0x27, 0x16, 0x23, 0x0A, 0x2D, 0x15, 0x0C, 0x05, 0x29, 
    0x02, 0x1F, 0x0E, 0x21, 0x2B, 0x0A, 0x2D, 0x01, 0x15, 0x0C, 
    0x2C, 0x15, 0x0E, 0x29, 0x0C, 0x2F, 0x07, 0x1F, 0x15, 0x24, 
    0x04, 0x1F, 0x08, 0x18, 0x24, 0x1E, 0x2F, 0x06, 0x15, 0x32, 0x11, 

    0x21, 0x30, 0x06, 0x2B, 0x25, 0x31, 0x05, 0x19, 0x08, 0x20,         // 20
    0x06, 0x0C, 0x12, 0x01, 0x2D, 0x26, 0x09, 0x14, 0x29, 0x00, 
    0x23, 0x0F, 0x1C, 0x26, 0x10, 0x02, 0x23, 0x08, 0x30, 0x02, 
    0x2A, 0x14, 0x2E, 0x22, 0x2B, 0x1F, 0x18, 0x21, 0x15, 0x2E, 
    0x05, 0x16, 0x1E, 0x2F, 0x15, 0x1A, 0x27, 0x01, 0x24, 0x18, 
    0x09, 0x1D, 0x07, 0x2B, 0x18, 0x22, 0x06, 0x31, 0x18, 0x24, 
    0x0D, 0x2B, 0x08, 0x1B, 0x02, 0x17, 0x10, 0x1A, 0x30, 0x06, 
    0x20, 0x02, 0x24, 0x1E, 0x04, 0x14, 0x1B, 0x28, 0x0C, 0x2C, 
    0x10, 0x2B, 0x13, 0x30, 0x04, 0x13, 0x27, 0x0F, 0x20, 0x0B, 0x1A, 

    0x08, 0x16, 0x0C, 0x1D, 0x01, 0x21, 0x13, 0x2E, 0x25, 0x0F,         // 21
    0x1C, 0x28, 0x31, 0x16, 0x1C, 0x04, 0x1F, 0x32, 0x10, 0x1B, 
    0x2B, 0x05, 0x21, 0x09, 0x31, 0x1D, 0x29, 0x17, 0x1E, 0x0F, 
    0x25, 0x1B, 0x0F, 0x08, 0x27, 0x07, 0x0F, 0x2B, 0x09, 0x10, 
    0x25, 0x0A, 0x29, 0x0F, 0x06, 0x1E, 0x0C, 0x2B, 0x10, 0x30, 
    0x13, 0x21, 0x0E, 0x02, 0x26, 0x10, 0x29, 0x1F, 0x09, 0x12, 
    0x2F, 0x15, 0x24, 0x11, 0x31, 0x26, 0x1E, 0x08, 0x25, 0x11, 
    0x18, 0x2F, 0x09, 0x11, 0x2D, 0x25, 0x0A, 0x32, 0x05, 0x19, 
    0x1D, 0x00, 0x21, 0x1C, 0x0E, 0x2D, 0x01, 0x1A, 0x2B, 0x04, 0x26, 

    0x12, 0x1F, 0x2D, 0x10, 0x17, 0x0B, 0x1F, 0x03, 0x2A, 0x14,         // 22
    0x04, 0x24, 0x09, 0x20, 0x0E, 0x2B, 0x17, 0x05, 0x25, 0x0B, 
    0x16, 0x2F, 0x12, 0x19, 0x06, 0x14, 0x0C, 0x05, 0x2C, 0x1A, 
    0x07, 0x31, 0x01, 0x18, 0x11, 0x31, 0x1B, 0x00, 0x20, 0x1D, 
    0x2D, 0x1A, 0x03, 0x22, 0x26, 0x2E, 0x14, 0x07, 0x1D, 0x03, 
    0x25, 0x2B, 0x1A, 0x32, 0x15, 0x09, 0x1A, 0x01, 0x2B, 0x1C, 
    0x0A, 0x00, 0x28, 0x1D, 0x0C, 0x06, 0x2E, 0x0D, 0x22, 0x28, 
    0x0B, 0x1C, 0x2A, 0x18, 0x20, 0x01, 0x17, 0x11, 0x21, 0x13, 
    0x2F, 0x0C, 0x17, 0x09, 0x28, 0x15, 0x21, 0x0D, 0x24, 0x14, 0x2C, 

    0x02, 0x28, 0x06, 0x23, 0x2F, 0x29, 0x11, 0x1A, 0x09, 0x23,         // 23
    0x2F, 0x11, 0x1A, 0x05, 0x28, 0x13, 0x21, 0x0F, 0x2E, 0x1E, 
    0x07, 0x26, 0x01, 0x2A, 0x20, 0x2D, 0x25, 0x11, 0x20, 0x0C, 
    0x14, 0x22, 0x29, 0x1D, 0x23, 0x05, 0x26, 0x16, 0x2A, 0x04, 
    0x14, 0x0C, 0x31, 0x17, 0x12, 0x03, 0x19, 0x23, 0x28, 0x16, 
    0x0C, 0x05, 0x11, 0x1F, 0x06, 0x25, 0x2F, 0x11, 0x15, 0x26, 
    0x20, 0x17, 0x2E, 0x04, 0x15, 0x20, 0x13, 0x18, 0x04, 0x31, 
    0x14, 0x00, 0x23, 0x07, 0x0C, 0x27, 0x2B, 0x1E, 0x03, 0x26, 
    0x07, 0x29, 0x24, 0x32, 0x06, 0x1E, 0x0A, 0x17, 0x2F, 0x0B, 0x1B, 

    0x31, 0x0F, 0x1A, 0x13, 0x04, 0x08, 0x25, 0x2C, 0x0F, 0x1C,         // 24
    0x17, 0x02, 0x2C, 0x25, 0x0C, 0x30, 0x08, 0x1A, 0x02, 0x29, 
    0x11, 0x1A, 0x22, 0x13, 0x0D, 0x03, 0x19, 0x32, 0x00, 0x27, 
    0x2D, 0x04, 0x11, 0x0B, 0x2D, 0x14, 0x0C, 0x2F, 0x12, 0x0A, 
    0x27, 0x20, 0x10, 0x28, 0x0A, 0x20, 0x30, 0x0F, 0x09, 0x2F, 
    0x21, 0x18, 0x2E, 0x0D, 0x2A, 0x1C, 0x0B, 0x21, 0x04, 0x31, 
    0x07, 0x0F, 0x21, 0x19, 0x2C, 0x28, 0x01, 0x2B, 0x1C, 0x09, 
    0x1F, 0x2B, 0x11, 0x31, 0x14, 0x1B, 0x0E, 0x09, 0x2D, 0x18, 
    0x1E, 0x0F, 0x03, 0x13, 0x1A, 0x26, 0x2E, 0x04, 0x1D, 0x07, 0x23, 

    0x16, 0x09, 0x26, 0x2B, 0x1F, 0x1B, 0x15, 0x01, 0x2E, 0x07,         // 25
    0x2A, 0x0F, 0x22, 0x15, 0x1C, 0x03, 0x1F, 0x2A, 0x13, 0x23, 
    0x0C, 0x31, 0x0A, 0x2C, 0x1C, 0x16, 0x23, 0x08, 0x1D, 0x16, 
    0x0A, 0x1B, 0x30, 0x17, 0x02, 0x1E, 0x21, 0x03, 0x24, 0x19, 
    0x2C, 0x06, 0x1C, 0x01, 0x2C, 0x1A, 0x05, 0x2A, 0x14, 0x1C, 
    0x07, 0x28, 0x01, 0x23, 0x14, 0x03, 0x17, 0x2C, 0x0E, 0x1B, 
    0x14, 0x2B, 0x09, 0x11, 0x06, 0x1B, 0x0B, 0x21, 0x11, 0x27, 
    0x0E, 0x18, 0x06, 0x1D, 0x28, 0x04, 0x30, 0x21, 0x14, 0x0C, 
    0x30, 0x16, 0x21, 0x2C, 0x0F, 0x02, 0x15, 0x23, 0x10, 0x29, 0x12, 

    0x2C, 0x1E, 0x00, 0x0D, 0x11, 0x32, 0x0B, 0x21, 0x16, 0x27,         // 26
    0x1F, 0x08, 0x31, 0x04, 0x12, 0x28, 0x16, 0x09, 0x30, 0x04, 
    0x1D, 0x17, 0x06, 0x24, 0x04, 0x2F, 0x0B, 0x14, 0x2B, 0x0F, 
    0x26, 0x20, 0x06, 0x25, 0x2A, 0x10, 0x19, 0x2A, 0x08, 0x1F, 
    0x0E, 0x15, 0x2E, 0x23, 0x13, 0x0C, 0x25, 0x1F, 0x00, 0x2C, 
    0x0E, 0x1E, 0x15, 0x2C, 0x08, 0x30, 0x26, 0x06, 0x20, 0x29, 
    0x05, 0x24, 0x1D, 0x2F, 0x26, 0x0F, 0x32, 0x16, 0x07, 0x2D, 
    0x04, 0x25, 0x2E, 0x0A, 0x22, 0x10, 0x19, 0x07, 0x2A, 0x01, 
    0x27, 0x05, 0x1D, 0x0B, 0x28, 0x1F, 0x2C, 0x09, 0x30, 0x21, 0x04, 

    0x27, 0x19, 0x2F, 0x17, 0x24, 0x05, 0x28, 0x1D, 0x04, 0x0D,         // 27
    0x13, 0x18, 0x26, 0x0A, 0x20, 0x2F, 0x0D, 0x26, 0x1C, 0x10, 
    0x2C, 0x21, 0x12, 0x28, 0x0F, 0x1E, 0x2A, 0x24, 0x07, 0x30, 
    0x02, 0x18, 0x0E, 0x1D, 0x07, 0x32, 0x05, 0x0E, 0x16, 0x30, 
    0x02, 0x29, 0x09, 0x19, 0x06, 0x32, 0x11, 0x18, 0x0B, 0x24, 
    0x13, 0x31, 0x0A, 0x1A, 0x0F, 0x1E, 0x19, 0x13, 0x09, 0x16, 
    0x30, 0x0D, 0x13, 0x03, 0x16, 0x1F, 0x05, 0x27, 0x1A, 0x1F, 
    0x14, 0x1C, 0x10, 0x19, 0x02, 0x2D, 0x26, 0x12, 0x1C, 0x20, 
    0x19, 0x10, 0x2E, 0x06, 0x19, 0x0C, 0x12, 0x1B, 0x01, 0x18, 0x0D, 

    0x06, 0x13, 0x0B, 0x20, 0x08, 0x2C, 0x18, 0x10, 0x30, 0x22,         // 28
    0x2D, 0x00, 0x1D, 0x2B, 0x0F, 0x1A, 0x01, 0x14, 0x07, 0x29, 
    0x0B, 0x00, 0x1B, 0x2E, 0x0A, 0x1A, 0x01, 0x10, 0x19, 0x1E, 
    0x12, 0x2E, 0x28, 0x15, 0x0B, 0x1A, 0x26, 0x2D, 0x23, 0x11, 
    0x1B, 0x24, 0x0E, 0x20, 0x28, 0x1E, 0x03, 0x27, 0x2F, 0x19, 
    0x03, 0x20, 0x05, 0x24, 0x29, 0x00, 0x0C, 0x2F, 0x27, 0x1C, 
    0x01, 0x22, 0x19, 0x2B, 0x0B, 0x25, 0x13, 0x2E, 0x03, 0x0E, 
    0x30, 0x01, 0x2A, 0x25, 0x13, 0x1E, 0x0A, 0x04, 0x30, 0x0D, 
    0x08, 0x28, 0x15, 0x24, 0x31, 0x03, 0x2A, 0x25, 0x0F, 0x2D, 0x23, 

    0x31, 0x25, 0x04, 0x29, 0x1B, 0x0E, 0x03, 0x24, 0x07, 0x1A,         // 29
    0x09, 0x29, 0x11, 0x17, 0x06, 0x29, 0x1F, 0x2D, 0x22, 0x16, 
    0x24, 0x30, 0x14, 0x04, 0x21, 0x13, 0x31, 0x22, 0x04, 0x29, 
    0x0C, 0x21, 0x03, 0x2B, 0x24, 0x13, 0x1F, 0x01, 0x0A, 0x29, 
    0x08, 0x16, 0x30, 0x01, 0x14, 0x0A, 0x2D, 0x16, 0x06, 0x22, 
    0x29, 0x0D, 0x17, 0x2F, 0x12, 0x20, 0x2B, 0x22, 0x07, 0x0F, 
    0x2C, 0x28, 0x05, 0x1F, 0x30, 0x00, 0x1D, 0x10, 0x22, 0x26, 
    0x09, 0x20, 0x0D, 0x06, 0x32, 0x0E, 0x29, 0x18, 0x24, 0x14, 
    0x2C, 0x21, 0x00, 0x0E, 0x22, 0x15, 0x1C, 0x06, 0x1F, 0x14, 0x09, 

    0x0F, 0x1E, 0x17, 0x30, 0x13, 0x1F, 0x2F, 0x14, 0x2B, 0x0E,         // 30
    0x15, 0x24, 0x04, 0x31, 0x24, 0x08, 0x18, 0x0C, 0x03, 0x1C, 
    0x08, 0x0F, 0x27, 0x18, 0x2C, 0x06, 0x27, 0x0D, 0x2E, 0x15, 
    0x07, 0x1C, 0x10, 0x09, 0x2F, 0x06, 0x0D, 0x1A, 0x15, 0x1E, 
    0x2D, 0x05, 0x1C, 0x10, 0x2C, 0x1A, 0x0D, 0x20, 0x10, 0x09, 
    0x14, 0x2C, 0x1D, 0x07, 0x0B, 0x16, 0x05, 0x11, 0x19, 0x1F, 
    0x15, 0x0B, 0x11, 0x1B, 0x0E, 0x18, 0x2A, 0x08, 0x16, 0x2C, 
    0x13, 0x18, 0x2C, 0x1C, 0x16, 0x21, 0x01, 0x2D, 0x0C, 0x1C, 
    0x04, 0x12, 0x2E, 0x1D, 0x07, 0x2B, 0x10, 0x2F, 0x0B, 0x2A, 0x1B, 

    0x01, 0x2C, 0x09, 0x0E, 0x02, 0x26, 0x0B, 0x1C, 0x02, 0x1F,         // 31
    0x2F, 0x1B, 0x0B, 0x1F, 0x12, 0x2E, 0x0F, 0x28, 0x31, 0x11, 
    0x2C, 0x1D, 0x07, 0x1F, 0x0C, 0x1D, 0x16, 0x09, 0x1B, 0x23, 
    0x2C, 0x27, 0x18, 0x20, 0x16, 0x22, 0x27, 0x31, 0x21, 0x03, 
    0x10, 0x24, 0x29, 0x09, 0x22, 0x26, 0x02, 0x2A, 0x1C, 0x30, 
    0x25, 0x01, 0x0F, 0x24, 0x28, 0x1E, 0x2E, 0x25, 0x02, 0x30, 
    0x08, 0x21, 0x2F, 0x25, 0x07, 0x27, 0x0B, 0x31, 0x02, 0x1C, 
    0x05, 0x27, 0x11, 0x03, 0x28, 0x09, 0x14, 0x1F, 0x07, 0x31, 
    0x23, 0x0A, 0x26, 0x18, 0x0B, 0x24, 0x04, 0x27, 0x17, 0x06, 0x21, 

    0x16, 0x1C, 0x28, 0x20, 0x2E, 0x18, 0x06, 0x29, 0x16, 0x25,         // 32
    0x06, 0x10, 0x2D, 0x17, 0x01, 0x1B, 0x21, 0x06, 0x1A, 0x25, 
    0x02, 0x2A, 0x13, 0x32, 0x10, 0x01, 0x26, 0x2B, 0x10, 0x02, 
    0x12, 0x06, 0x2F, 0x00, 0x0C, 0x2A, 0x03, 0x0F, 0x08, 0x2E, 
    0x19, 0x0B, 0x16, 0x31, 0x06, 0x17, 0x2F, 0x13, 0x05, 0x18, 
    0x11, 0x20, 0x19, 0x32, 0x02, 0x19, 0x09, 0x14, 0x2B, 0x0D, 
    0x28, 0x19, 0x01, 0x15, 0x2D, 0x12, 0x21, 0x1A, 0x25, 0x10, 
    0x1F, 0x31, 0x08, 0x22, 0x2D, 0x1A, 0x26, 0x10, 0x29, 0x13, 
    0x1A, 0x2B, 0x03, 0x0F, 0x30, 0x14, 0x1A, 0x0C, 0x1E, 0x12, 0x2E, 

    0x0D, 0x05, 0x14, 0x08, 0x1C, 0x12, 0x24, 0x0E, 0x32, 0x0B,         // 33
    0x13, 0x27, 0x05, 0x21, 0x29, 0x09, 0x13, 0x1F, 0x0B, 0x16, 
    0x0E, 0x1A, 0x05, 0x27, 0x22, 0x2E, 0x19, 0x05, 0x21, 0x31, 
    0x17, 0x21, 0x0F, 0x1D, 0x2D, 0x12, 0x1B, 0x17, 0x28, 0x13, 
    0x20, 0x27, 0x02, 0x1B, 0x12, 0x0D, 0x1F, 0x0B, 0x21, 0x2C, 
    0x09, 0x2B, 0x06, 0x14, 0x0D, 0x29, 0x0F, 0x21, 0x1A, 0x12, 
    0x05, 0x1D, 0x10, 0x24, 0x04, 0x1E, 0x06, 0x15, 0x0D, 0x2A, 
    0x0A, 0x15, 0x1B, 0x0D, 0x13, 0x03, 0x30, 0x06, 0x1D, 0x04, 
    0x0C, 0x16, 0x1E, 0x21, 0x28, 0x01, 0x2C, 0x22, 0x32, 0x03, 0x26, 

    0x2B, 0x22, 0x31, 0x0F, 0x2A, 0x01, 0x2C, 0x1D, 0x04, 0x22,         // 34
    0x1A, 0x2C, 0x1D, 0x15, 0x0E, 0x2D, 0x25, 0x03, 0x2A, 0x23, 
    0x30, 0x21, 0x0D, 0x18, 0x04, 0x12, 0x1E, 0x0D, 0x14, 0x1D, 
    0x0B, 0x29, 0x19, 0x08, 0x23, 0x06, 0x20, 0x2C, 0x0B, 0x1C, 
    0x05, 0x2C, 0x11, 0x21, 0x2D, 0x24, 0x00, 0x29, 0x16, 0x03, 
    0x1D, 0x0D, 0x26, 0x1E, 0x2C, 0x23, 0x04, 0x30, 0x07, 0x29, 
    0x21, 0x32, 0x0A, 0x2A, 0x1A, 0x0F, 0x2E, 0x29, 0x03, 0x2F, 
    0x21, 0x00, 0x28, 0x2E, 0x23, 0x0B, 0x20, 0x16, 0x2E, 0x26, 
    0x22, 0x2D, 0x06, 0x12, 0x09, 0x1C, 0x0F, 0x06, 0x18, 0x0B, 0x1C, 

    0x02, 0x18, 0x07, 0x25, 0x19, 0x20, 0x0A, 0x11, 0x18, 0x2D,         // 35
    0x00, 0x0F, 0x08, 0x30, 0x02, 0x1C, 0x16, 0x32, 0x13, 0x0A, 
    0x01, 0x1D, 0x2E, 0x09, 0x1F, 0x2B, 0x07, 0x2F, 0x28, 0x02, 
    0x2D, 0x04, 0x13, 0x31, 0x28, 0x14, 0x0A, 0x25, 0x01, 0x31, 
    0x0E, 0x18, 0x08, 0x1D, 0x0A, 0x2A, 0x1C, 0x11, 0x31, 0x1F, 
    0x13, 0x30, 0x15, 0x04, 0x0B, 0x13, 0x1C, 0x16, 0x1F, 0x0C, 
    0x15, 0x03, 0x1F, 0x13, 0x2F, 0x09, 0x22, 0x11, 0x1C, 0x17, 
    0x0C, 0x1D, 0x0F, 0x05, 0x19, 0x2B, 0x1C, 0x0E, 0x09, 0x13, 
    0x00, 0x0F, 0x27, 0x2E, 0x19, 0x2A, 0x23, 0x13, 0x2B, 0x24, 0x14, 

    0x10, 0x2A, 0x1D, 0x0C, 0x04, 0x14, 0x30, 0x26, 0x08, 0x28,         // 36
    0x14, 0x21, 0x19, 0x23, 0x11, 0x27, 0x05, 0x0E, 0x1B, 0x2D, 
    0x18, 0x10, 0x29, 0x14, 0x26, 0x0F, 0x17, 0x23, 0x0A, 0x1B, 
    0x0F, 0x24, 0x1E, 0x0D, 0x02, 0x1C, 0x2F, 0x11, 0x1F, 0x15, 
    0x29, 0x22, 0x2E, 0x03, 0x16, 0x0F, 0x06, 0x19, 0x08, 0x0C, 
    0x28, 0x01, 0x21, 0x1B, 0x2F, 0x27, 0x0A, 0x2D, 0x00, 0x2A, 
    0x19, 0x2C, 0x0E, 0x27, 0x02, 0x17, 0x25, 0x04, 0x27, 0x07, 
    0x23, 0x2D, 0x16, 0x24, 0x09, 0x10, 0x02, 0x25, 0x2B, 0x1B, 
    0x30, 0x18, 0x1D, 0x0B, 0x14, 0x04, 0x30, 0x0D, 0x1F, 0x08, 0x2F, 

    0x0A, 0x22, 0x12, 0x29, 0x2E, 0x23, 0x05, 0x15, 0x1E, 0x0D,         // 37
    0x2F, 0x0B, 0x29, 0x07, 0x2C, 0x0A, 0x20, 0x28, 0x06, 0x21, 
    0x08, 0x23, 0x04, 0x1B, 0x06, 0x31, 0x00, 0x21, 0x13, 0x26, 
    0x16, 0x2B, 0x07, 0x21, 0x17, 0x27, 0x05, 0x18, 0x0D, 0x25, 
    0x05, 0x0B, 0x13, 0x23, 0x30, 0x1F, 0x2C, 0x27, 0x23, 0x2E, 
    0x18, 0x0E, 0x25, 0x08, 0x17, 0x02, 0x22, 0x12, 0x25, 0x0F, 
    0x08, 0x24, 0x1B, 0x07, 0x1E, 0x2C, 0x0B, 0x1A, 0x2E, 0x0F, 
    0x2A, 0x12, 0x04, 0x31, 0x1E, 0x28, 0x2F, 0x18, 0x04, 0x1F, 
    0x08, 0x0C, 0x21, 0x02, 0x26, 0x21, 0x0A, 0x17, 0x00, 0x1C, 0x26, 

    0x18, 0x31, 0x02, 0x16, 0x08, 0x0E, 0x1A, 0x29, 0x02, 0x25,         // 38
    0x1C, 0x03, 0x12, 0x1E, 0x14, 0x19, 0x10, 0x2F, 0x15, 0x26, 
    0x2B, 0x16, 0x30, 0x0C, 0x24, 0x1D, 0x11, 0x2B, 0x07, 0x2E, 
    0x04, 0x0B, 0x1C, 0x11, 0x2F, 0x0B, 0x22, 0x2C, 0x02, 0x30, 
    0x1F, 0x1C, 0x2B, 0x0D, 0x18, 0x04, 0x13, 0x0D, 0x02, 0x1D, 
    0x06, 0x2C, 0x13, 0x29, 0x10, 0x1E, 0x2B, 0x05, 0x18, 0x1F, 
    0x2E, 0x04, 0x12, 0x31, 0x14, 0x0D, 0x28, 0x13, 0x09, 0x20, 
    0x02, 0x1C, 0x28, 0x0C, 0x17, 0x13, 0x08, 0x21, 0x0F, 0x15, 
    0x23, 0x2C, 0x12, 0x31, 0x0E, 0x2C, 0x1B, 0x27, 0x2E, 0x13, 0x04, 

    0x1E, 0x0F, 0x25, 0x1B, 0x27, 0x1F, 0x2C, 0x0A, 0x2E, 0x10,         // 39
    0x16, 0x22, 0x2C, 0x05, 0x31, 0x24, 0x00, 0x1E, 0x04, 0x11, 
    0x0D, 0x01, 0x1F, 0x12, 0x2D, 0x0B, 0x18, 0x25, 0x0E, 0x1F, 
    0x19, 0x32, 0x28, 0x03, 0x23, 0x13, 0x08, 0x28, 0x1A, 0x12, 
    0x07, 0x17, 0x01, 0x27, 0x09, 0x25, 0x1B, 0x30, 0x16, 0x10, 
    0x21, 0x1B, 0x03, 0x20, 0x30, 0x07, 0x0D, 0x27, 0x31, 0x0A, 
    0x15, 0x28, 0x20, 0x09, 0x26, 0x20, 0x00, 0x32, 0x1D, 0x16, 
    0x26, 0x0B, 0x19, 0x21, 0x01, 0x26, 0x1B, 0x0C, 0x27, 0x32, 
    0x01, 0x26, 0x07, 0x16, 0x1E, 0x03, 0x15, 0x06, 0x23, 0x0E, 0x2C, 

    0x15, 0x07, 0x0B, 0x2B, 0x11, 0x01, 0x18, 0x12, 0x20, 0x08,         // 40
    0x30, 0x0D, 0x26, 0x17, 0x0E, 0x28, 0x0B, 0x2A, 0x18, 0x31, 
    0x1C, 0x25, 0x2B, 0x19, 0x03, 0x29, 0x06, 0x30, 0x15, 0x01, 
    0x23, 0x0F, 0x17, 0x0C, 0x2C, 0x19, 0x1E, 0x0F, 0x20, 0x0A, 
    0x2A, 0x22, 0x32, 0x13, 0x1F, 0x2D, 0x0A, 0x06, 0x24, 0x2A, 
    0x0A, 0x32, 0x0F, 0x0A, 0x1C, 0x15, 0x23, 0x19, 0x11, 0x02, 
    0x1C, 0x0C, 0x17, 0x2C, 0x05, 0x19, 0x11, 0x23, 0x05, 0x2D, 
    0x10, 0x2B, 0x06, 0x2C, 0x11, 0x2F, 0x04, 0x2B, 0x1E, 0x0A, 
    0x13, 0x1F, 0x1A, 0x29, 0x09, 0x23, 0x10, 0x2A, 0x1B, 0x0A, 0x20, 

    0x28, 0x2F, 0x22, 0x17, 0x08, 0x31, 0x25, 0x04, 0x1C, 0x27,         // 41
    0x01, 0x1B, 0x08, 0x1F, 0x03, 0x1A, 0x13, 0x22, 0x08, 0x20, 
    0x0B, 0x13, 0x07, 0x0F, 0x21, 0x14, 0x23, 0x0D, 0x1B, 0x2A, 
    0x09, 0x25, 0x04, 0x1F, 0x27, 0x00, 0x31, 0x06, 0x17, 0x2E, 
    0x14, 0x0E, 0x07, 0x1A, 0x03, 0x0F, 0x21, 0x2B, 0x19, 0x00, 
    0x14, 0x25, 0x17, 0x2C, 0x25, 0x01, 0x2D, 0x06, 0x21, 0x2A, 
    0x24, 0x30, 0x03, 0x0F, 0x1C, 0x2E, 0x08, 0x29, 0x0C, 0x1A, 
    0x01, 0x22, 0x15, 0x1D, 0x07, 0x22, 0x19, 0x10, 0x06, 0x18, 
    0x2B, 0x0E, 0x05, 0x2E, 0x13, 0x26, 0x31, 0x09, 0x16, 0x30, 0x05, 

    0x19, 0x01, 0x12, 0x2D, 0x1E, 0x0E, 0x15, 0x2E, 0x0B, 0x16,         // 42
    0x2B, 0x13, 0x2E, 0x11, 0x23, 0x30, 0x05, 0x2D, 0x10, 0x02, 
    0x2E, 0x17, 0x28, 0x32, 0x1C, 0x08, 0x2E, 0x03, 0x20, 0x10, 
    0x2D, 0x13, 0x2F, 0x1A, 0x12, 0x0A, 0x15, 0x29, 0x24, 0x08, 
    0x26, 0x1C, 0x2C, 0x23, 0x2F, 0x15, 0x1B, 0x0C, 0x12, 0x20, 
    0x2D, 0x04, 0x1F, 0x06, 0x1A, 0x12, 0x26, 0x0B, 0x2F, 0x0E, 
    0x06, 0x18, 0x1F, 0x29, 0x25, 0x0B, 0x16, 0x1E, 0x13, 0x2F, 
    0x27, 0x0B, 0x30, 0x0F, 0x28, 0x0A, 0x14, 0x2D, 0x28, 0x22, 
    0x03, 0x2F, 0x15, 0x21, 0x00, 0x0D, 0x18, 0x20, 0x02, 0x25, 0x11, 

    0x1E, 0x26, 0x09, 0x1B, 0x03, 0x21, 0x29, 0x06, 0x22, 0x0F,         // 43
    0x1E, 0x0A, 0x25, 0x07, 0x2A, 0x0E, 0x1D, 0x26, 0x17, 0x2A, 
    0x23, 0x05, 0x1F, 0x01, 0x0D, 0x2A, 0x19, 0x13, 0x2C, 0x06, 
    0x17, 0x1E, 0x08, 0x0E, 0x2B, 0x25, 0x1D, 0x04, 0x11, 0x21, 
    0x03, 0x0C, 0x13, 0x05, 0x0B, 0x26, 0x02, 0x31, 0x28, 0x09, 
    0x1B, 0x0E, 0x28, 0x10, 0x31, 0x0A, 0x1E, 0x14, 0x19, 0x1F, 
    0x13, 0x2C, 0x08, 0x11, 0x02, 0x21, 0x30, 0x04, 0x24, 0x07, 
    0x17, 0x1C, 0x04, 0x21, 0x17, 0x31, 0x24, 0x00, 0x0D, 0x1B, 
    0x12, 0x25, 0x0B, 0x1C, 0x2C, 0x1E, 0x06, 0x2B, 0x14, 0x2C, 0x0C, 

    0x32, 0x16, 0x2A, 0x10, 0x28, 0x0A, 0x11, 0x1A, 0x2D, 0x27,         // 44
    0x03, 0x32, 0x15, 0x1D, 0x18, 0x01, 0x15, 0x08, 0x0D, 0x1C, 
    0x13, 0x0E, 0x1A, 0x26, 0x13, 0x24, 0x09, 0x1E, 0x0F, 0x26, 
    0x21, 0x02, 0x29, 0x22, 0x03, 0x17, 0x2F, 0x0D, 0x2C, 0x16, 
    0x31, 0x28, 0x1F, 0x17, 0x29, 0x22, 0x11, 0x1D, 0x06, 0x24, 
    0x14, 0x2F, 0x08, 0x16, 0x22, 0x29, 0x05, 0x2C, 0x07, 0x27, 
    0x01, 0x25, 0x16, 0x30, 0x1B, 0x14, 0x0D, 0x19, 0x2B, 0x0F, 
    0x20, 0x12, 0x2B, 0x0D, 0x02, 0x1B, 0x08, 0x1F, 0x16, 0x30, 
    0x0A, 0x29, 0x18, 0x05, 0x13, 0x27, 0x0F, 0x1C, 0x0B, 0x20, 0x05, 

    0x23, 0x0E, 0x06, 0x22, 0x14, 0x2D, 0x1F, 0x01, 0x13, 0x0A,         // 45
    0x1A, 0x23, 0x0E, 0x04, 0x2F, 0x23, 0x27, 0x31, 0x20, 0x07, 
    0x27, 0x30, 0x09, 0x2C, 0x18, 0x04, 0x30, 0x28, 0x01, 0x31, 
    0x0C, 0x1A, 0x14, 0x30, 0x0C, 0x22, 0x06, 0x1A, 0x1F, 0x07, 
    0x0F, 0x19, 0x00, 0x30, 0x0D, 0x06, 0x2E, 0x16, 0x10, 0x2A, 
    0x03, 0x19, 0x25, 0x2C, 0x01, 0x0E, 0x17, 0x21, 0x0F, 0x32, 
    0x0C, 0x1C, 0x0D, 0x23, 0x06, 0x2C, 0x26, 0x09, 0x1D, 0x02, 
    0x31, 0x07, 0x27, 0x1E, 0x2D, 0x11, 0x2A, 0x10, 0x2B, 0x07, 
    0x1F, 0x02, 0x23, 0x32, 0x08, 0x23, 0x2D, 0x01, 0x27, 0x1A, 0x13, 

    0x03, 0x2C, 0x1A, 0x30, 0x03, 0x17, 0x08, 0x31, 0x1D, 0x2B,         // 46
    0x11, 0x06, 0x2D, 0x20, 0x17, 0x0B, 0x12, 0x04, 0x1A, 0x2D, 
    0x00, 0x21, 0x15, 0x06, 0x22, 0x10, 0x1C, 0x0A, 0x17, 0x1D, 
    0x11, 0x2D, 0x05, 0x1E, 0x11, 0x2B, 0x13, 0x28, 0x02, 0x25, 
    0x2D, 0x09, 0x23, 0x11, 0x1D, 0x18, 0x28, 0x01, 0x1F, 0x2E, 
    0x0D, 0x1E, 0x06, 0x11, 0x1C, 0x1F, 0x30, 0x02, 0x1A, 0x1F, 
    0x15, 0x2E, 0x04, 0x29, 0x11, 0x1E, 0x00, 0x12, 0x2E, 0x15, 
    0x24, 0x0E, 0x19, 0x14, 0x06, 0x24, 0x18, 0x05, 0x26, 0x1A, 
    0x13, 0x2C, 0x0E, 0x1E, 0x16, 0x0C, 0x18, 0x12, 0x30, 0x08, 0x2A, 

    0x1D, 0x21, 0x0A, 0x13, 0x1E, 0x2A, 0x25, 0x0D, 0x21, 0x02,         // 47
    0x25, 0x17, 0x29, 0x10, 0x08, 0x2C, 0x1C, 0x2A, 0x0A, 0x10, 
    0x18, 0x0D, 0x1D, 0x2F, 0x26, 0x0C, 0x2B, 0x13, 0x25, 0x06, 
    0x27, 0x09, 0x24, 0x19, 0x01, 0x25, 0x09, 0x30, 0x10, 0x1C, 
    0x14, 0x21, 0x2A, 0x05, 0x2D, 0x08, 0x21, 0x0C, 0x1A, 0x07, 
    0x23, 0x13, 0x32, 0x24, 0x0A, 0x14, 0x25, 0x12, 0x2A, 0x09, 
    0x03, 0x26, 0x21, 0x16, 0x0B, 0x32, 0x17, 0x29, 0x1F, 0x0B, 
    0x1B, 0x2D, 0x01, 0x21, 0x2F, 0x0B, 0x1E, 0x2E, 0x0E, 0x03, 
    0x24, 0x17, 0x07, 0x2A, 0x03, 0x2F, 0x1F, 0x05, 0x23, 0x16, 0x0B, 

    0x10, 0x18, 0x00, 0x28, 0x0C, 0x05, 0x12, 0x18, 0x09, 0x15,         // 48
    0x30, 0x0B, 0x1D, 0x04, 0x27, 0x1F, 0x02, 0x15, 0x24, 0x1E, 
    0x2B, 0x25, 0x05, 0x13, 0x01, 0x17, 0x20, 0x04, 0x2E, 0x21, 
    0x12, 0x17, 0x2A, 0x0A, 0x2E, 0x1B, 0x16, 0x1E, 0x0A, 0x2B, 
    0x05, 0x0C, 0x1A, 0x25, 0x15, 0x1F, 0x13, 0x2C, 0x25, 0x14, 
    0x29, 0x02, 0x19, 0x2A, 0x04, 0x2D, 0x0C, 0x06, 0x23, 0x2E, 
    0x12, 0x19, 0x09, 0x2C, 0x1A, 0x08, 0x23, 0x0F, 0x03, 0x28, 
    0x08, 0x10, 0x25, 0x09, 0x28, 0x10, 0x01, 0x14, 0x20, 0x2B, 
    0x0B, 0x30, 0x1B, 0x11, 0x25, 0x1A, 0x0A, 0x2C, 0x0E, 0x1F, 0x2E, 

    0x06, 0x25, 0x31, 0x20, 0x1B, 0x2C, 0x22, 0x2F, 0x27, 0x1B,         // 49
    0x05, 0x23, 0x14, 0x2F, 0x19, 0x0D, 0x30, 0x0F, 0x29, 0x03, 
    0x13, 0x0A, 0x2D, 0x1A, 0x28, 0x31, 0x08, 0x19, 0x0E, 0x29, 
    0x02, 0x32, 0x0E, 0x21, 0x11, 0x07, 0x27, 0x03, 0x24, 0x19, 
    0x27, 0x31, 0x10, 0x02, 0x0D, 0x30, 0x06, 0x0F, 0x03, 0x30, 
    0x0B, 0x1D, 0x09, 0x0F, 0x1F, 0x18, 0x28, 0x1C, 0x16, 0x0D, 
    0x1E, 0x29, 0x10, 0x01, 0x27, 0x1E, 0x05, 0x2E, 0x1A, 0x13, 
    0x2B, 0x1E, 0x31, 0x13, 0x17, 0x1D, 0x25, 0x32, 0x06, 0x1C, 
    0x12, 0x26, 0x00, 0x21, 0x08, 0x2B, 0x13, 0x27, 0x18, 0x02, 0x27, 

    0x1B, 0x0D, 0x16, 0x0F, 0x08, 0x15, 0x01, 0x10, 0x07, 0x2B,         // 50
    0x12, 0x2D, 0x00, 0x24, 0x12, 0x05, 0x23, 0x18, 0x08, 0x1B, 
    0x32, 0x17, 0x20, 0x0F, 0x09, 0x23, 0x10, 0x26, 0x1E, 0x09, 
    0x1A, 0x1F, 0x05, 0x15, 0x1E, 0x2C, 0x0D, 0x31, 0x13, 0x0E, 
    0x02, 0x17, 0x20, 0x2C, 0x26, 0x19, 0x1E, 0x2A, 0x17, 0x20, 
    0x10, 0x2E, 0x27, 0x15, 0x30, 0x03, 0x11, 0x30, 0x00, 0x28, 
    0x05, 0x31, 0x21, 0x14, 0x2F, 0x0D, 0x16, 0x28, 0x0C, 0x23, 
    0x06, 0x19, 0x03, 0x20, 0x07, 0x2A, 0x0B, 0x17, 0x10, 0x29, 
    0x09, 0x1E, 0x14, 0x2E, 0x17, 0x0E, 0x01, 0x1C, 0x08, 0x30, 0x14, 

    0x2D, 0x29, 0x04, 0x27, 0x2F, 0x23, 0x29, 0x19, 0x1E, 0x0D,         // 51
    0x20, 0x08, 0x1A, 0x0D, 0x29, 0x1D, 0x2D, 0x0B, 0x2B, 0x22, 
    0x0E, 0x06, 0x2A, 0x02, 0x1C, 0x14, 0x2C, 0x00, 0x2F, 0x13, 
    0x2B, 0x0B, 0x27, 0x2F, 0x02, 0x17, 0x22, 0x05, 0x1D, 0x2D, 
    0x23, 0x0A, 0x1D, 0x07, 0x12, 0x04, 0x0B, 0x24, 0x08, 0x1C, 
    0x01, 0x22, 0x06, 0x23, 0x0A, 0x1B, 0x25, 0x09, 0x22, 0x14, 
    0x1B, 0x08, 0x0C, 0x1D, 0x05, 0x24, 0x11, 0x1C, 0x01, 0x30, 
    0x16, 0x0B, 0x29, 0x0F, 0x2E, 0x1A, 0x04, 0x2B, 0x24, 0x02, 
    0x18, 0x31, 0x06, 0x0F, 0x28, 0x1F, 0x32, 0x24, 0x11, 0x20, 0x0B, 

    0x22, 0x09, 0x1E, 0x19, 0x03, 0x0F, 0x0A, 0x2D, 0x05, 0x26,         // 52
    0x15, 0x2A, 0x1F, 0x30, 0x07, 0x16, 0x01, 0x1E, 0x11, 0x03, 
    0x28, 0x1D, 0x12, 0x23, 0x30, 0x0C, 0x21, 0x17, 0x0F, 0x06, 
    0x22, 0x16, 0x0F, 0x1A, 0x0B, 0x2A, 0x0F, 0x26, 0x16, 0x06, 
    0x29, 0x12, 0x30, 0x16, 0x2A, 0x22, 0x32, 0x13, 0x2D, 0x15, 
    0x2C, 0x19, 0x0F, 0x2C, 0x13, 0x2B, 0x0E, 0x18, 0x2B, 0x0D, 
    0x2D, 0x24, 0x16, 0x29, 0x19, 0x2B, 0x06, 0x2D, 0x26, 0x0E, 
    0x1F, 0x2C, 0x24, 0x15, 0x01, 0x23, 0x13, 0x1F, 0x0D, 0x2D, 
    0x22, 0x0C, 0x2A, 0x1C, 0x04, 0x0B, 0x1A, 0x05, 0x2B, 0x18, 0x03, 

    0x17, 0x10, 0x2E, 0x12, 0x25, 0x1D, 0x17, 0x21, 0x13, 0x31,         // 53
    0x03, 0x0F, 0x17, 0x0B, 0x21, 0x11, 0x25, 0x29, 0x15, 0x30, 
    0x17, 0x07, 0x2E, 0x16, 0x05, 0x29, 0x07, 0x25, 0x1C, 0x27, 
    0x2E, 0x01, 0x1E, 0x29, 0x23, 0x08, 0x1B, 0x2E, 0x0A, 0x1F, 
    0x0E, 0x1A, 0x00, 0x23, 0x0A, 0x1A, 0x0F, 0x02, 0x26, 0x07, 
    0x11, 0x25, 0x04, 0x1D, 0x08, 0x1F, 0x02, 0x27, 0x06, 0x1F, 
    0x03, 0x10, 0x2F, 0x02, 0x12, 0x0B, 0x20, 0x15, 0x09, 0x1C, 
    0x13, 0x02, 0x0D, 0x1C, 0x27, 0x0E, 0x30, 0x09, 0x1C, 0x12, 
    0x05, 0x16, 0x23, 0x12, 0x26, 0x2C, 0x14, 0x0C, 0x25, 0x0F, 0x28, 

    0x1D, 0x01, 0x28, 0x06, 0x32, 0x08, 0x29, 0x04, 0x1E, 0x0A,         // 54
    0x1B, 0x2D, 0x25, 0x02, 0x1C, 0x2F, 0x06, 0x0E, 0x1B, 0x0C, 
    0x25, 0x20, 0x0B, 0x27, 0x0F, 0x1B, 0x12, 0x32, 0x03, 0x0C, 
    0x17, 0x09, 0x31, 0x04, 0x14, 0x30, 0x01, 0x11, 0x19, 0x2B, 
    0x04, 0x2E, 0x27, 0x0F, 0x2C, 0x04, 0x28, 0x1C, 0x0C, 0x1F, 
    0x29, 0x0B, 0x32, 0x14, 0x27, 0x2F, 0x13, 0x1B, 0x31, 0x17, 
    0x28, 0x1A, 0x09, 0x1F, 0x26, 0x31, 0x1B, 0x04, 0x24, 0x2F, 
    0x07, 0x22, 0x32, 0x08, 0x2B, 0x06, 0x16, 0x29, 0x00, 0x2F, 
    0x27, 0x09, 0x2E, 0x01, 0x18, 0x07, 0x1F, 0x2E, 0x1B, 0x06, 0x31, 

    0x14, 0x24, 0x0B, 0x18, 0x1F, 0x15, 0x0C, 0x2E, 0x10, 0x2A,         // 55
    0x21, 0x06, 0x14, 0x29, 0x10, 0x18, 0x2B, 0x23, 0x08, 0x2C, 
    0x00, 0x11, 0x1B, 0x03, 0x1F, 0x2E, 0x0A, 0x21, 0x14, 0x2C, 
    0x1C, 0x21, 0x12, 0x19, 0x0D, 0x1D, 0x20, 0x28, 0x06, 0x24, 
    0x15, 0x20, 0x13, 0x06, 0x20, 0x15, 0x2F, 0x23, 0x17, 0x30, 
    0x03, 0x18, 0x20, 0x00, 0x1A, 0x07, 0x23, 0x0D, 0x08, 0x12, 
    0x0B, 0x21, 0x2B, 0x0E, 0x05, 0x16, 0x0D, 0x2C, 0x10, 0x17, 
    0x2A, 0x1A, 0x15, 0x11, 0x1F, 0x1A, 0x25, 0x0F, 0x20, 0x14, 
    0x23, 0x1B, 0x0E, 0x20, 0x31, 0x10, 0x21, 0x00, 0x15, 0x23, 0x08, 

    0x0C, 0x2E, 0x1B, 0x10, 0x2A, 0x02, 0x1A, 0x23, 0x16, 0x00,         // 56
    0x1A, 0x0D, 0x32, 0x08, 0x20, 0x0B, 0x02, 0x15, 0x1F, 0x26, 
    0x16, 0x31, 0x29, 0x14, 0x2B, 0x17, 0x01, 0x1D, 0x0F, 0x28, 
    0x05, 0x0E, 0x2C, 0x22, 0x27, 0x06, 0x16, 0x0B, 0x32, 0x1B, 
    0x0D, 0x09, 0x1C, 0x31, 0x19, 0x08, 0x10, 0x01, 0x12, 0x08, 
    0x1B, 0x0F, 0x2A, 0x12, 0x26, 0x0C, 0x2C, 0x1E, 0x29, 0x23, 
    0x2D, 0x01, 0x16, 0x1D, 0x29, 0x22, 0x01, 0x28, 0x1E, 0x03, 
    0x0E, 0x24, 0x04, 0x2D, 0x0D, 0x03, 0x2E, 0x07, 0x19, 0x0A, 
    0x10, 0x2C, 0x05, 0x14, 0x0A, 0x1C, 0x2A, 0x0A, 0x2F, 0x11, 0x2A, 

    0x1F, 0x03, 0x28, 0x06, 0x22, 0x2D, 0x0F, 0x26, 0x0B, 0x2F,         // 57
    0x13, 0x26, 0x1D, 0x17, 0x2C, 0x27, 0x1C, 0x31, 0x10, 0x04, 
    0x1A, 0x0C, 0x07, 0x24, 0x05, 0x0E, 0x28, 0x2D, 0x07, 0x22, 
    0x15, 0x26, 0x0B, 0x00, 0x2B, 0x11, 0x2D, 0x21, 0x12, 0x01, 
    0x2E, 0x26, 0x03, 0x24, 0x0B, 0x29, 0x1D, 0x26, 0x2E, 0x22, 
    0x2B, 0x24, 0x0A, 0x2E, 0x05, 0x18, 0x12, 0x02, 0x19, 0x05, 
    0x1C, 0x12, 0x32, 0x09, 0x10, 0x2F, 0x13, 0x19, 0x08, 0x21, 
    0x2E, 0x09, 0x28, 0x22, 0x17, 0x28, 0x12, 0x1F, 0x30, 0x29, 
    0x03, 0x17, 0x27, 0x23, 0x2B, 0x04, 0x13, 0x19, 0x1E, 0x03, 0x1A, 

    0x26, 0x16, 0x0B, 0x30, 0x14, 0x08, 0x1E, 0x06, 0x29, 0x20,         // 58
    0x09, 0x2B, 0x02, 0x11, 0x06, 0x0C, 0x13, 0x06, 0x29, 0x0B, 
    0x2E, 0x21, 0x1D, 0x10, 0x30, 0x23, 0x12, 0x18, 0x0B, 0x2F, 
    0x02, 0x1A, 0x31, 0x14, 0x1D, 0x08, 0x25, 0x04, 0x18, 0x29, 
    0x21, 0x0F, 0x2B, 0x16, 0x11, 0x2D, 0x05, 0x1A, 0x09, 0x0D, 
    0x14, 0x02, 0x19, 0x1E, 0x22, 0x31, 0x27, 0x0E, 0x30, 0x14, 
    0x2A, 0x0C, 0x24, 0x19, 0x06, 0x1E, 0x0B, 0x24, 0x31, 0x12, 
    0x1B, 0x16, 0x10, 0x03, 0x31, 0x09, 0x1D, 0x01, 0x0F, 0x24, 
    0x1D, 0x32, 0x08, 0x1A, 0x0E, 0x30, 0x25, 0x0D, 0x23, 0x2C, 0x0E, 

    0x2F, 0x11, 0x1C, 0x20, 0x0D, 0x19, 0x31, 0x15, 0x11, 0x04,         // 59
    0x1D, 0x0E, 0x22, 0x2F, 0x1B, 0x23, 0x2E, 0x1F, 0x18, 0x25, 
    0x12, 0x02, 0x2D, 0x19, 0x0A, 0x1B, 0x03, 0x26, 0x1E, 0x13, 
    0x29, 0x1F, 0x06, 0x21, 0x0C, 0x19, 0x30, 0x0E, 0x24, 0x07, 
    0x14, 0x1A, 0x09, 0x1E, 0x01, 0x20, 0x0E, 0x27, 0x17, 0x1F, 
    0x28, 0x30, 0x07, 0x10, 0x15, 0x03, 0x1B, 0x20, 0x09, 0x24, 
    0x07, 0x1F, 0x03, 0x29, 0x2D, 0x15, 0x27, 0x05, 0x0E, 0x1F, 
    0x01, 0x2B, 0x1F, 0x1B, 0x0C, 0x24, 0x15, 0x2C, 0x18, 0x06, 
    0x12, 0x0C, 0x1F, 0x01, 0x15, 0x1E, 0x03, 0x29, 0x08, 0x14, 0x06, 

    0x24, 0x02, 0x2C, 0x04, 0x25, 0x2A, 0x01, 0x24, 0x2B, 0x18,         // 60
    0x30, 0x16, 0x25, 0x05, 0x14, 0x29, 0x00, 0x10, 0x08, 0x1D, 
    0x2A, 0x0E, 0x15, 0x04, 0x29, 0x1F, 0x09, 0x31, 0x0D, 0x19, 
    0x09, 0x10, 0x16, 0x2C, 0x27, 0x04, 0x15, 0x1C, 0x2E, 0x0B, 
    0x2C, 0x04, 0x30, 0x28, 0x18, 0x2F, 0x14, 0x06, 0x2E, 0x03, 
    0x12, 0x1A, 0x23, 0x2D, 0x09, 0x2B, 0x0C, 0x13, 0x2D, 0x18, 
    0x10, 0x2E, 0x16, 0x0E, 0x21, 0x00, 0x1B, 0x2A, 0x18, 0x2D, 
    0x0A, 0x27, 0x07, 0x2E, 0x13, 0x2A, 0x06, 0x23, 0x0A, 0x2B, 
    0x27, 0x16, 0x23, 0x2D, 0x28, 0x0B, 0x18, 0x11, 0x32, 0x20, 0x1B, 

    0x0D, 0x28, 0x13, 0x1B, 0x0A, 0x10, 0x1F, 0x0D, 0x07, 0x22,         // 61
    0x0A, 0x01, 0x2A, 0x0B, 0x1F, 0x0E, 0x1A, 0x26, 0x30, 0x16, 
    0x05, 0x1F, 0x27, 0x22, 0x0D, 0x2E, 0x14, 0x22, 0x01, 0x2C, 
    0x23, 0x2F, 0x02, 0x1B, 0x11, 0x20, 0x2A, 0x01, 0x10, 0x17, 
    0x1E, 0x25, 0x15, 0x0C, 0x24, 0x09, 0x1C, 0x2A, 0x23, 0x0B, 
    0x26, 0x06, 0x0C, 0x28, 0x1D, 0x18, 0x24, 0x05, 0x28, 0x01, 
    0x1C, 0x25, 0x08, 0x1D, 0x12, 0x0A, 0x30, 0x11, 0x03, 0x24, 
    0x13, 0x22, 0x0E, 0x1A, 0x00, 0x20, 0x10, 0x2E, 0x1E, 0x1A, 
    0x02, 0x2F, 0x09, 0x10, 0x05, 0x22, 0x2C, 0x1D, 0x01, 0x16, 0x09, 

    0x2F, 0x17, 0x07, 0x31, 0x26, 0x15, 0x2C, 0x1A, 0x2E, 0x14,         // 62
    0x28, 0x1C, 0x10, 0x18, 0x31, 0x09, 0x2C, 0x13, 0x03, 0x0D, 
    0x2E, 0x19, 0x09, 0x2C, 0x11, 0x03, 0x19, 0x28, 0x10, 0x1B, 
    0x07, 0x26, 0x1E, 0x0B, 0x2E, 0x07, 0x0D, 0x26, 0x22, 0x28, 
    0x02, 0x0D, 0x1C, 0x05, 0x11, 0x29, 0x02, 0x0E, 0x13, 0x1B, 
    0x31, 0x17, 0x1F, 0x13, 0x00, 0x0E, 0x32, 0x1E, 0x11, 0x21, 
    0x0B, 0x30, 0x04, 0x28, 0x2C, 0x18, 0x22, 0x08, 0x1F, 0x0C, 
    0x31, 0x04, 0x17, 0x2C, 0x28, 0x0B, 0x18, 0x04, 0x12, 0x0D, 
    0x20, 0x13, 0x1B, 0x29, 0x14, 0x26, 0x07, 0x10, 0x25, 0x2B, 0x22, 

    0x0F, 0x1E, 0x21, 0x11, 0x02, 0x1C, 0x05, 0x0B, 0x25, 0x04,         // 63
    0x0D, 0x20, 0x2C, 0x08, 0x27, 0x22, 0x06, 0x1C, 0x20, 0x29, 
    0x24, 0x10, 0x00, 0x16, 0x1C, 0x20, 0x0A, 0x2C, 0x05, 0x1F, 
    0x0D, 0x14, 0x06, 0x29, 0x15, 0x1A, 0x32, 0x13, 0x05, 0x30, 
    0x11, 0x29, 0x2D, 0x20, 0x32, 0x16, 0x21, 0x2F, 0x1F, 0x01, 
    0x0D, 0x29, 0x04, 0x2F, 0x21, 0x29, 0x07, 0x16, 0x09, 0x2A, 
    0x17, 0x10, 0x1F, 0x14, 0x0C, 0x04, 0x26, 0x2E, 0x15, 0x1A, 
    0x28, 0x1D, 0x0F, 0x21, 0x05, 0x1D, 0x32, 0x22, 0x27, 0x30, 
    0x06, 0x2B, 0x04, 0x20, 0x31, 0x0B, 0x1A, 0x2E, 0x0C, 0x13, 0x04, 

    0x1B, 0x00, 0x2E, 0x0B, 0x2A, 0x21, 0x30, 0x13, 0x1E, 0x18,         // 64
    0x32, 0x06, 0x16, 0x1E, 0x03, 0x13, 0x18, 0x2E, 0x0B, 0x15, 
    0x07, 0x1F, 0x2F, 0x27, 0x07, 0x31, 0x25, 0x12, 0x16, 0x2F, 
    0x2A, 0x1A, 0x30, 0x0F, 0x22, 0x02, 0x1D, 0x21, 0x0A, 0x17, 
    0x20, 0x07, 0x14, 0x01, 0x1A, 0x0C, 0x05, 0x18, 0x0A, 0x2D, 
    0x25, 0x11, 0x1C, 0x08, 0x18, 0x10, 0x1B, 0x26, 0x2F, 0x03, 
    0x1D, 0x2C, 0x0A, 0x21, 0x32, 0x1E, 0x0F, 0x02, 0x25, 0x0B, 
    0x01, 0x14, 0x2F, 0x0A, 0x26, 0x16, 0x0F, 0x02, 0x1A, 0x0B, 
    0x17, 0x25, 0x0E, 0x1A, 0x00, 0x1E, 0x15, 0x03, 0x1F, 0x19, 0x29, 

    0x24, 0x0E, 0x26, 0x16, 0x1A, 0x0E, 0x09, 0x28, 0x03, 0x2A,         // 65
    0x0F, 0x26, 0x12, 0x2F, 0x0E, 0x2B, 0x26, 0x10, 0x05, 0x32, 
    0x1C, 0x12, 0x0C, 0x22, 0x13, 0x0D, 0x02, 0x1F, 0x09, 0x22, 
    0x00, 0x0C, 0x24, 0x04, 0x27, 0x0C, 0x2A, 0x0F, 0x1B, 0x2B, 
    0x0D, 0x19, 0x26, 0x0A, 0x1E, 0x2A, 0x24, 0x10, 0x2A, 0x15, 
    0x04, 0x20, 0x2E, 0x0D, 0x24, 0x2D, 0x04, 0x0D, 0x20, 0x13, 
    0x0C, 0x24, 0x01, 0x1A, 0x07, 0x16, 0x2B, 0x1B, 0x13, 0x2F, 
    0x2A, 0x20, 0x07, 0x23, 0x11, 0x2D, 0x09, 0x2A, 0x13, 0x2C, 
    0x1D, 0x09, 0x2D, 0x12, 0x0D, 0x24, 0x2C, 0x27, 0x0A, 0x31, 0x06, 

    0x2C, 0x14, 0x08, 0x1F, 0x05, 0x2D, 0x17, 0x1D, 0x11, 0x22,         // 66
    0x09, 0x19, 0x02, 0x23, 0x1B, 0x0A, 0x01, 0x21, 0x1A, 0x28, 
    0x02, 0x26, 0x2B, 0x04, 0x1B, 0x29, 0x18, 0x2E, 0x1A, 0x10, 
    0x26, 0x16, 0x1D, 0x13, 0x2E, 0x19, 0x06, 0x2F, 0x02, 0x26, 
    0x04, 0x31, 0x22, 0x2D, 0x12, 0x06, 0x30, 0x1D, 0x08, 0x23, 
    0x1B, 0x09, 0x16, 0x2A, 0x02, 0x14, 0x1E, 0x29, 0x05, 0x1B, 
    0x31, 0x16, 0x2B, 0x12, 0x23, 0x0C, 0x27, 0x09, 0x20, 0x06, 
    0x17, 0x0F, 0x1B, 0x29, 0x01, 0x1A, 0x1F, 0x25, 0x07, 0x23, 
    0x02, 0x14, 0x21, 0x26, 0x30, 0x07, 0x13, 0x0F, 0x22, 0x17, 0x10, 

    0x03, 0x1A, 0x32, 0x29, 0x13, 0x23, 0x01, 0x2B, 0x07, 0x2F,         // 67
    0x1C, 0x27, 0x2C, 0x0B, 0x16, 0x31, 0x1E, 0x14, 0x2C, 0x0D, 
    0x17, 0x20, 0x08, 0x16, 0x2F, 0x0F, 0x24, 0x05, 0x29, 0x07, 
    0x32, 0x06, 0x2C, 0x09, 0x1F, 0x11, 0x24, 0x15, 0x20, 0x12, 
    0x1D, 0x13, 0x06, 0x0D, 0x27, 0x15, 0x1A, 0x03, 0x27, 0x0D, 
    0x32, 0x0F, 0x25, 0x07, 0x1A, 0x31, 0x0F, 0x17, 0x2C, 0x0A, 
    0x27, 0x06, 0x0E, 0x27, 0x2F, 0x02, 0x18, 0x2E, 0x10, 0x1C, 
    0x26, 0x03, 0x2E, 0x0D, 0x15, 0x31, 0x04, 0x0D, 0x18, 0x10, 
    0x31, 0x29, 0x04, 0x16, 0x0B, 0x20, 0x19, 0x05, 0x2B, 0x08, 0x1E, 

    0x28, 0x0A, 0x1E, 0x04, 0x0D, 0x2F, 0x10, 0x22, 0x18, 0x0C,         // 68
    0x13, 0x05, 0x11, 0x1F, 0x06, 0x29, 0x0F, 0x09, 0x25, 0x06, 
    0x11, 0x2F, 0x0E, 0x1D, 0x25, 0x01, 0x15, 0x0D, 0x1D, 0x14, 
    0x20, 0x10, 0x25, 0x18, 0x04, 0x31, 0x0C, 0x1D, 0x08, 0x2E, 
    0x0B, 0x29, 0x18, 0x1E, 0x02, 0x23, 0x0A, 0x2A, 0x12, 0x18, 
    0x00, 0x2B, 0x1D, 0x11, 0x20, 0x0B, 0x25, 0x08, 0x23, 0x10, 
    0x21, 0x18, 0x1D, 0x09, 0x1F, 0x12, 0x23, 0x05, 0x29, 0x08, 
    0x31, 0x13, 0x22, 0x05, 0x25, 0x1D, 0x13, 0x27, 0x2E, 0x1F, 
    0x0A, 0x1A, 0x0F, 0x1E, 0x2A, 0x03, 0x2E, 0x1C, 0x25, 0x13, 0x2F, 

    0x22, 0x11, 0x17, 0x25, 0x19, 0x1E, 0x0A, 0x26, 0x05, 0x29,         // 69
    0x20, 0x30, 0x19, 0x2D, 0x25, 0x02, 0x22, 0x19, 0x30, 0x1D, 
    0x2A, 0x1A, 0x03, 0x2C, 0x09, 0x1A, 0x31, 0x23, 0x2D, 0x0B, 
    0x1A, 0x02, 0x2B, 0x0E, 0x21, 0x28, 0x02, 0x2C, 0x17, 0x27, 
    0x00, 0x23, 0x2F, 0x11, 0x29, 0x31, 0x0F, 0x1E, 0x2E, 0x21, 
    0x1F, 0x14, 0x04, 0x2F, 0x27, 0x01, 0x19, 0x2E, 0x03, 0x14, 
    0x30, 0x00, 0x2C, 0x15, 0x05, 0x1C, 0x2A, 0x0D, 0x1B, 0x14, 
    0x1E, 0x0C, 0x18, 0x27, 0x11, 0x09, 0x2B, 0x06, 0x1B, 0x00, 
    0x14, 0x26, 0x2D, 0x07, 0x18, 0x11, 0x28, 0x0C, 0x01, 0x19, 0x0D, 

    0x27, 0x01, 0x30, 0x09, 0x2A, 0x03, 0x15, 0x31, 0x1B, 0x0E,         // 70
    0x15, 0x00, 0x08, 0x0F, 0x1A, 0x14, 0x2E, 0x07, 0x12, 0x00, 
    0x0B, 0x23, 0x13, 0x28, 0x11, 0x20, 0x06, 0x12, 0x02, 0x25, 
    0x2C, 0x14, 0x23, 0x09, 0x1A, 0x11, 0x16, 0x25, 0x06, 0x11, 
    0x1C, 0x15, 0x05, 0x0B, 0x1B, 0x08, 0x18, 0x02, 0x10, 0x07, 
    0x0C, 0x29, 0x09, 0x19, 0x0D, 0x2B, 0x1F, 0x16, 0x27, 0x1C, 
    0x0B, 0x25, 0x0F, 0x28, 0x31, 0x0C, 0x16, 0x2F, 0x03, 0x25, 
    0x2C, 0x01, 0x2A, 0x07, 0x2E, 0x20, 0x17, 0x23, 0x0F, 0x2A, 
    0x22, 0x04, 0x0D, 0x22, 0x32, 0x09, 0x21, 0x15, 0x31, 0x1F, 0x06, 

    0x2E, 0x1C, 0x13, 0x20, 0x0E, 0x2C, 0x21, 0x11, 0x03, 0x2D,         // 71
    0x23, 0x2A, 0x1E, 0x21, 0x0A, 0x2A, 0x0C, 0x1E, 0x24, 0x28, 
    0x16, 0x31, 0x06, 0x1E, 0x0C, 0x26, 0x17, 0x2A, 0x19, 0x09, 
    0x1C, 0x06, 0x30, 0x1D, 0x03, 0x2F, 0x0B, 0x1B, 0x23, 0x32, 
    0x0D, 0x20, 0x2D, 0x25, 0x13, 0x20, 0x2C, 0x26, 0x1C, 0x30, 
    0x17, 0x23, 0x2D, 0x1F, 0x15, 0x08, 0x11, 0x06, 0x0E, 0x2B, 
    0x07, 0x1F, 0x17, 0x08, 0x22, 0x01, 0x25, 0x10, 0x20, 0x0A, 
    0x12, 0x1C, 0x21, 0x0E, 0x1B, 0x02, 0x0D, 0x30, 0x15, 0x09, 
    0x2F, 0x18, 0x2A, 0x14, 0x01, 0x1E, 0x1A, 0x07, 0x28, 0x0F, 0x1A, 

    0x07, 0x0B, 0x29, 0x04, 0x15, 0x1C, 0x08, 0x1F, 0x27, 0x09,         // 72
    0x18, 0x0C, 0x12, 0x2F, 0x04, 0x25, 0x16, 0x05, 0x2C, 0x0E, 
    0x1F, 0x08, 0x18, 0x2D, 0x01, 0x2F, 0x08, 0x0F, 0x22, 0x31, 
    0x10, 0x28, 0x0D, 0x14, 0x26, 0x22, 0x2A, 0x09, 0x13, 0x04, 
    0x2A, 0x08, 0x18, 0x02, 0x29, 0x06, 0x0D, 0x15, 0x04, 0x27, 
    0x0E, 0x02, 0x11, 0x05, 0x30, 0x23, 0x29, 0x32, 0x22, 0x1A, 
    0x14, 0x2F, 0x03, 0x1B, 0x11, 0x2C, 0x1A, 0x06, 0x28, 0x17, 
    0x2F, 0x07, 0x16, 0x31, 0x13, 0x29, 0x24, 0x05, 0x21, 0x1C, 
    0x06, 0x10, 0x1F, 0x0C, 0x24, 0x2C, 0x0E, 0x2D, 0x03, 0x23, 0x14, 

    0x24, 0x17, 0x1F, 0x2E, 0x26, 0x01, 0x30, 0x0B, 0x13, 0x1C,         // 73
    0x31, 0x04, 0x27, 0x19, 0x10, 0x1C, 0x32, 0x11, 0x1A, 0x03, 
    0x13, 0x2A, 0x24, 0x0F, 0x15, 0x20, 0x1C, 0x2C, 0x03, 0x15, 
    0x21, 0x00, 0x18, 0x2B, 0x0A, 0x10, 0x01, 0x1F, 0x2D, 0x17, 
    0x24, 0x10, 0x1E, 0x12, 0x31, 0x19, 0x1F, 0x2F, 0x0B, 0x1A, 
    0x22, 0x2A, 0x1B, 0x26, 0x0D, 0x1B, 0x02, 0x18, 0x0A, 0x04, 
    0x28, 0x0D, 0x25, 0x2D, 0x1F, 0x0A, 0x14, 0x32, 0x1D, 0x02, 
    0x24, 0x0D, 0x26, 0x03, 0x1E, 0x08, 0x19, 0x11, 0x2C, 0x0C, 
    0x24, 0x28, 0x03, 0x2F, 0x17, 0x06, 0x12, 0x25, 0x18, 0x0C, 0x2A, 

    0x32, 0x0D, 0x06, 0x11, 0x1A, 0x0F, 0x29, 0x17, 0x2C, 0x02,         // 74
    0x1F, 0x14, 0x22, 0x08, 0x2C, 0x01, 0x20, 0x09, 0x26, 0x30, 
    0x23, 0x0B, 0x03, 0x1C, 0x29, 0x05, 0x12, 0x0A, 0x26, 0x1D, 
    0x0B, 0x2D, 0x1F, 0x05, 0x21, 0x19, 0x2F, 0x15, 0x0D, 0x1E, 
    0x01, 0x30, 0x26, 0x0A, 0x23, 0x0E, 0x01, 0x28, 0x12, 0x2B, 
    0x06, 0x14, 0x0A, 0x2C, 0x16, 0x09, 0x20, 0x10, 0x26, 0x2E, 
    0x12, 0x21, 0x09, 0x15, 0x05, 0x2A, 0x22, 0x0E, 0x09, 0x2B, 
    0x10, 0x1F, 0x2A, 0x0A, 0x2C, 0x0F, 0x30, 0x26, 0x01, 0x13, 
    0x31, 0x15, 0x1B, 0x09, 0x27, 0x1C, 0x20, 0x09, 0x30, 0x1D, 0x00, 

    0x12, 0x1C, 0x2C, 0x23, 0x09, 0x1E, 0x23, 0x06, 0x24, 0x10,         // 75
    0x2A, 0x06, 0x2F, 0x0C, 0x27, 0x16, 0x0C, 0x2B, 0x15, 0x07, 
    0x1B, 0x2C, 0x16, 0x2F, 0x0C, 0x24, 0x30, 0x16, 0x2B, 0x06, 
    0x12, 0x1A, 0x0E, 0x32, 0x12, 0x1D, 0x08, 0x28, 0x05, 0x27, 
    0x1A, 0x0C, 0x16, 0x05, 0x2C, 0x13, 0x1B, 0x21, 0x07, 0x1E, 
    0x17, 0x32, 0x20, 0x00, 0x24, 0x2E, 0x15, 0x2B, 0x0C, 0x1D, 
    0x19, 0x01, 0x31, 0x1D, 0x0F, 0x26, 0x00, 0x18, 0x26, 0x14, 
    0x1B, 0x06, 0x13, 0x1A, 0x21, 0x16, 0x04, 0x1E, 0x18, 0x23, 
    0x07, 0x21, 0x11, 0x2C, 0x0F, 0x03, 0x28, 0x15, 0x04, 0x10, 0x22, 

    0x07, 0x29, 0x02, 0x18, 0x31, 0x04, 0x14, 0x0D, 0x2F, 0x19,         // 76
    0x0E, 0x1D, 0x17, 0x20, 0x10, 0x1B, 0x25, 0x1D, 0x02, 0x21, 
    0x0D, 0x11, 0x1F, 0x06, 0x13, 0x21, 0x01, 0x1B, 0x0D, 0x22, 
    0x30, 0x25, 0x03, 0x28, 0x06, 0x26, 0x0E, 0x22, 0x31, 0x11, 
    0x07, 0x2D, 0x20, 0x29, 0x1E, 0x07, 0x30, 0x16, 0x0E, 0x2D, 
    0x03, 0x0B, 0x11, 0x1C, 0x0E, 0x07, 0x28, 0x02, 0x1F, 0x07, 
    0x10, 0x24, 0x29, 0x0C, 0x19, 0x2E, 0x11, 0x1E, 0x30, 0x03, 
    0x2C, 0x25, 0x31, 0x00, 0x0D, 0x28, 0x0B, 0x2B, 0x09, 0x2E, 
    0x0E, 0x1D, 0x01, 0x24, 0x15, 0x31, 0x0B, 0x2C, 0x24, 0x2A, 0x16, 

    0x25, 0x0C, 0x14, 0x27, 0x0E, 0x25, 0x2C, 0x1D, 0x02, 0x21,         // 77
    0x09, 0x28, 0x00, 0x2B, 0x07, 0x31, 0x05, 0x11, 0x2D, 0x17, 
    0x2F, 0x01, 0x29, 0x19, 0x27, 0x08, 0x2D, 0x13, 0x28, 0x04, 
    0x18, 0x0A, 0x22, 0x16, 0x1B, 0x2E, 0x14, 0x04, 0x19, 0x1F, 
    0x2A, 0x15, 0x0E, 0x00, 0x18, 0x0C, 0x25, 0x03, 0x29, 0x19, 
    0x25, 0x22, 0x29, 0x15, 0x30, 0x1D, 0x12, 0x19, 0x31, 0x25, 
    0x2D, 0x08, 0x14, 0x04, 0x23, 0x08, 0x21, 0x06, 0x0C, 0x21, 
    0x0E, 0x08, 0x14, 0x1E, 0x2E, 0x24, 0x13, 0x1C, 0x11, 0x05, 
    0x27, 0x17, 0x30, 0x09, 0x1A, 0x1F, 0x11, 0x1B, 0x07, 0x0D, 0x2E, 

    0x19, 0x1E, 0x2F, 0x06, 0x20, 0x17, 0x08, 0x10, 0x29, 0x13,         // 78
    0x32, 0x24, 0x12, 0x0B, 0x1E, 0x14, 0x29, 0x0B, 0x26, 0x0A, 
    0x1C, 0x24, 0x09, 0x31, 0x0E, 0x17, 0x1D, 0x0A, 0x24, 0x0F, 
    0x2B, 0x12, 0x2E, 0x09, 0x0F, 0x02, 0x2A, 0x20, 0x12, 0x0A, 
    0x03, 0x21, 0x1B, 0x32, 0x12, 0x21, 0x2C, 0x11, 0x1F, 0x0A, 
    0x13, 0x2E, 0x04, 0x0A, 0x24, 0x05, 0x23, 0x0A, 0x14, 0x03, 
    0x18, 0x20, 0x1D, 0x2F, 0x2A, 0x13, 0x1B, 0x2D, 0x17, 0x12, 
    0x1E, 0x18, 0x29, 0x0F, 0x09, 0x19, 0x03, 0x32, 0x25, 0x19, 
    0x2C, 0x12, 0x0D, 0x26, 0x05, 0x2B, 0x01, 0x21, 0x17, 0x1F, 0x02, 

    0x13, 0x05, 0x23, 0x12, 0x1B, 0x00, 0x30, 0x22, 0x19, 0x07,         // 79
    0x1C, 0x05, 0x1A, 0x2E, 0x24, 0x03, 0x1A, 0x20, 0x16, 0x05, 
    0x2A, 0x0F, 0x15, 0x1E, 0x03, 0x29, 0x21, 0x02, 0x32, 0x1A, 
    0x20, 0x01, 0x1C, 0x25, 0x2C, 0x1F, 0x1A, 0x0C, 0x25, 0x28, 
    0x2F, 0x0D, 0x08, 0x27, 0x23, 0x09, 0x04, 0x17, 0x31, 0x01, 
    0x1C, 0x0F, 0x1A, 0x2C, 0x18, 0x0E, 0x2D, 0x29, 0x1C, 0x0D, 
    0x29, 0x10, 0x0A, 0x16, 0x03, 0x0E, 0x29, 0x02, 0x22, 0x2A, 
    0x04, 0x2F, 0x22, 0x02, 0x28, 0x1F, 0x07, 0x22, 0x0C, 0x02, 
    0x1F, 0x06, 0x22, 0x2D, 0x14, 0x0E, 0x26, 0x09, 0x2F, 0x0F, 0x28, 

    0x31, 0x0E, 0x2A, 0x0A, 0x2D, 0x26, 0x14, 0x0B, 0x2B, 0x0F,         // 80
    0x20, 0x14, 0x29, 0x0D, 0x15, 0x30, 0x0A, 0x2B, 0x0E, 0x31, 
    0x1A, 0x04, 0x21, 0x0B, 0x2C, 0x14, 0x10, 0x2B, 0x15, 0x06, 
    0x0C, 0x29, 0x17, 0x04, 0x11, 0x16, 0x07, 0x30, 0x02, 0x17, 
    0x1E, 0x13, 0x2C, 0x04, 0x16, 0x2A, 0x1B, 0x24, 0x0D, 0x22, 
    0x29, 0x08, 0x1F, 0x02, 0x27, 0x13, 0x01, 0x21, 0x07, 0x23, 
    0x2C, 0x01, 0x27, 0x1B, 0x25, 0x22, 0x16, 0x0C, 0x31, 0x09, 
    0x26, 0x0D, 0x17, 0x13, 0x30, 0x10, 0x18, 0x2B, 0x14, 0x2F, 
    0x0F, 0x2A, 0x18, 0x0B, 0x1E, 0x2F, 0x1C, 0x13, 0x29, 0x05, 0x22, 

    0x02, 0x1A, 0x1F, 0x17, 0x05, 0x0F, 0x1D, 0x06, 0x24, 0x01,         // 81
    0x2E, 0x0A, 0x22, 0x02, 0x1D, 0x06, 0x11, 0x1E, 0x00, 0x23, 
    0x12, 0x27, 0x2F, 0x18, 0x24, 0x06, 0x1C, 0x0C, 0x22, 0x28, 
    0x13, 0x2F, 0x0D, 0x21, 0x31, 0x26, 0x0F, 0x2A, 0x1B, 0x10, 
    0x05, 0x21, 0x19, 0x1D, 0x0B, 0x0F, 0x2F, 0x12, 0x06, 0x2C, 
    0x14, 0x24, 0x31, 0x0C, 0x1D, 0x2F, 0x1A, 0x10, 0x30, 0x12, 
    0x17, 0x1E, 0x32, 0x0C, 0x07, 0x2F, 0x05, 0x1F, 0x10, 0x19, 
    0x1D, 0x06, 0x2C, 0x1C, 0x05, 0x25, 0x0C, 0x26, 0x08, 0x1C, 
    0x16, 0x25, 0x00, 0x21, 0x07, 0x17, 0x03, 0x20, 0x0A, 0x1B, 0x15, 

    0x0D, 0x28, 0x09, 0x30, 0x24, 0x2B, 0x20, 0x1A, 0x31, 0x17,         // 82
    0x27, 0x11, 0x2D, 0x18, 0x2A, 0x23, 0x2C, 0x19, 0x13, 0x29, 
    0x07, 0x1D, 0x02, 0x11, 0x09, 0x30, 0x26, 0x03, 0x2D, 0x09, 
    0x1B, 0x23, 0x06, 0x19, 0x0A, 0x00, 0x1D, 0x21, 0x07, 0x2E, 
    0x28, 0x0F, 0x02, 0x30, 0x27, 0x20, 0x01, 0x26, 0x16, 0x1C, 
    0x0A, 0x04, 0x19, 0x12, 0x07, 0x23, 0x0C, 0x28, 0x05, 0x1B, 
    0x0B, 0x06, 0x11, 0x17, 0x29, 0x12, 0x1B, 0x2C, 0x27, 0x01, 
    0x24, 0x12, 0x28, 0x09, 0x1F, 0x2D, 0x01, 0x1E, 0x11, 0x29, 
    0x04, 0x0D, 0x32, 0x12, 0x2B, 0x27, 0x0C, 0x31, 0x11, 0x2D, 0x26, 

    0x20, 0x2C, 0x11, 0x01, 0x14, 0x0B, 0x03, 0x12, 0x0D, 0x08,         // 83
    0x1D, 0x04, 0x21, 0x07, 0x12, 0x0D, 0x08, 0x25, 0x30, 0x0A, 
    0x17, 0x0D, 0x2A, 0x21, 0x1D, 0x16, 0x11, 0x1F, 0x18, 0x10, 
    0x01, 0x27, 0x10, 0x1D, 0x29, 0x2D, 0x17, 0x0B, 0x14, 0x23, 
    0x0C, 0x2B, 0x1F, 0x12, 0x06, 0x15, 0x1C, 0x09, 0x2E, 0x20, 
    0x0F, 0x29, 0x2D, 0x22, 0x16, 0x2B, 0x03, 0x15, 0x20, 0x27, 
    0x2E, 0x23, 0x2B, 0x20, 0x00, 0x24, 0x08, 0x16, 0x0A, 0x14, 
    0x2D, 0x07, 0x22, 0x15, 0x0E, 0x19, 0x13, 0x31, 0x05, 0x21, 
    0x2C, 0x1F, 0x1B, 0x16, 0x05, 0x10, 0x23, 0x19, 0x01, 0x1E, 0x08, 

    0x18, 0x04, 0x1C, 0x21, 0x19, 0x2F, 0x22, 0x2C, 0x25, 0x20,         // 84
    0x14, 0x30, 0x0C, 0x24, 0x2F, 0x1F, 0x15, 0x03, 0x0F, 0x22, 
    0x2D, 0x24, 0x14, 0x06, 0x2D, 0x00, 0x2A, 0x08, 0x31, 0x22, 
    0x2C, 0x15, 0x30, 0x08, 0x22, 0x12, 0x04, 0x31, 0x25, 0x02, 
    0x1B, 0x07, 0x17, 0x0A, 0x2D, 0x24, 0x0E, 0x28, 0x11, 0x02, 
    0x25, 0x15, 0x0D, 0x00, 0x27, 0x11, 0x1D, 0x2F, 0x08, 0x0F, 
    0x03, 0x18, 0x09, 0x0D, 0x1C, 0x2E, 0x0F, 0x23, 0x30, 0x1F, 
    0x0C, 0x1B, 0x32, 0x02, 0x2C, 0x21, 0x07, 0x28, 0x1B, 0x0A, 
    0x12, 0x07, 0x0C, 0x25, 0x2D, 0x1D, 0x07, 0x2C, 0x15, 0x28, 0x10, 

    0x0A, 0x32, 0x26, 0x0C, 0x27, 0x10, 0x09, 0x17, 0x01, 0x2E,         // 85
    0x07, 0x1A, 0x28, 0x16, 0x01, 0x1A, 0x2D, 0x28, 0x1C, 0x05, 
    0x19, 0x01, 0x32, 0x0C, 0x1A, 0x24, 0x0F, 0x1C, 0x14, 0x04, 
    0x0C, 0x20, 0x03, 0x17, 0x0D, 0x27, 0x1E, 0x0F, 0x2B, 0x1F, 
    0x13, 0x32, 0x22, 0x29, 0x1A, 0x03, 0x31, 0x07, 0x21, 0x18, 
    0x30, 0x06, 0x1E, 0x1A, 0x31, 0x06, 0x0D, 0x29, 0x17, 0x1D, 
    0x2C, 0x13, 0x26, 0x30, 0x14, 0x06, 0x2A, 0x02, 0x1A, 0x05, 
    0x28, 0x10, 0x18, 0x0B, 0x27, 0x10, 0x1D, 0x0D, 0x15, 0x2F, 
    0x18, 0x27, 0x2E, 0x02, 0x12, 0x19, 0x27, 0x0D, 0x22, 0x06, 0x2B, 

    0x24, 0x16, 0x12, 0x06, 0x2B, 0x04, 0x1D, 0x28, 0x11, 0x1F,         // 86
    0x0D, 0x2B, 0x11, 0x0A, 0x26, 0x07, 0x10, 0x0A, 0x23, 0x12, 
    0x2B, 0x10, 0x1C, 0x28, 0x13, 0x09, 0x2E, 0x06, 0x26, 0x2A, 
    0x1B, 0x0F, 0x29, 0x1C, 0x2C, 0x05, 0x19, 0x08, 0x16, 0x06, 
    0x0D, 0x24, 0x01, 0x0C, 0x12, 0x20, 0x14, 0x1B, 0x2B, 0x08, 
    0x13, 0x23, 0x2B, 0x0A, 0x14, 0x20, 0x19, 0x24, 0x01, 0x12, 
    0x25, 0x07, 0x1E, 0x03, 0x19, 0x21, 0x1E, 0x15, 0x0E, 0x2D, 
    0x24, 0x06, 0x2B, 0x20, 0x19, 0x04, 0x2E, 0x25, 0x01, 0x23, 
    0x04, 0x1D, 0x15, 0x20, 0x09, 0x30, 0x02, 0x13, 0x30, 0x1A, 0x12, 

    0x1C, 0x00, 0x2D, 0x1F, 0x17, 0x23, 0x14, 0x32, 0x06, 0x19,         // 87
    0x24, 0x02, 0x1D, 0x22, 0x32, 0x1D, 0x29, 0x17, 0x30, 0x07, 
    0x26, 0x0B, 0x21, 0x04, 0x2C, 0x1F, 0x18, 0x22, 0x0E, 0x17, 
    0x06, 0x31, 0x24, 0x08, 0x11, 0x2F, 0x23, 0x2A, 0x21, 0x2F, 
    0x19, 0x2C, 0x16, 0x1E, 0x2F, 0x0A, 0x26, 0x00, 0x0E, 0x27, 
    0x1D, 0x02, 0x0F, 0x25, 0x03, 0x2E, 0x08, 0x2C, 0x0B, 0x21, 
    0x2F, 0x0C, 0x29, 0x0F, 0x2D, 0x11, 0x09, 0x31, 0x22, 0x0A, 
    0x14, 0x1D, 0x12, 0x03, 0x30, 0x13, 0x09, 0x17, 0x2C, 0x0E, 
    0x2A, 0x11, 0x06, 0x29, 0x0E, 0x24, 0x17, 0x1E, 0x0B, 0x03, 0x2C, 

    0x08, 0x21, 0x0E, 0x08, 0x30, 0x0C, 0x02, 0x22, 0x0B, 0x28,         // 88
    0x13, 0x2F, 0x09, 0x14, 0x04, 0x0D, 0x13, 0x02, 0x1F, 0x1A, 
    0x14, 0x2E, 0x08, 0x17, 0x0F, 0x02, 0x12, 0x30, 0x01, 0x2D, 
    0x1F, 0x12, 0x02, 0x15, 0x1F, 0x0B, 0x01, 0x12, 0x0C, 0x03, 
    0x27, 0x07, 0x0E, 0x28, 0x04, 0x19, 0x2D, 0x1E, 0x12, 0x2E, 
    0x0C, 0x18, 0x2F, 0x1E, 0x16, 0x28, 0x0F, 0x15, 0x1E, 0x0F, 
    0x04, 0x1C, 0x15, 0x23, 0x05, 0x27, 0x1C, 0x03, 0x28, 0x19, 
    0x00, 0x30, 0x26, 0x0D, 0x1D, 0x28, 0x22, 0x10, 0x1F, 0x1B, 
    0x08, 0x23, 0x31, 0x1A, 0x14, 0x2B, 0x05, 0x2D, 0x22, 0x27, 0x0F, 

    0x31, 0x17, 0x27, 0x1B, 0x13, 0x26, 0x2C, 0x1B, 0x11, 0x2E,         // 89
    0x08, 0x17, 0x25, 0x2A, 0x19, 0x2B, 0x24, 0x2E, 0x0C, 0x2A, 
    0x02, 0x1F, 0x1B, 0x31, 0x22, 0x2B, 0x1C, 0x0A, 0x27, 0x15, 
    0x08, 0x23, 0x1A, 0x2A, 0x26, 0x16, 0x1E, 0x2C, 0x24, 0x15, 
    0x1E, 0x12, 0x21, 0x1B, 0x2B, 0x0F, 0x06, 0x16, 0x25, 0x04, 
    0x22, 0x27, 0x07, 0x12, 0x06, 0x1A, 0x23, 0x03, 0x32, 0x26, 
    0x18, 0x2B, 0x00, 0x31, 0x19, 0x0E, 0x2C, 0x16, 0x0F, 0x25, 
    0x1F, 0x0C, 0x17, 0x2B, 0x07, 0x18, 0x02, 0x32, 0x06, 0x14, 
    0x2C, 0x18, 0x0B, 0x00, 0x1E, 0x0A, 0x1B, 0x0E, 0x06, 0x15, 0x1E, 

    0x11, 0x06, 0x2B, 0x02, 0x1F, 0x08, 0x0E, 0x17, 0x24, 0x04,         // 90
    0x1C, 0x21, 0x0F, 0x01, 0x1E, 0x07, 0x20, 0x05, 0x17, 0x0F, 
    0x23, 0x12, 0x0D, 0x04, 0x27, 0x08, 0x17, 0x24, 0x0F, 0x1B, 
    0x28, 0x0E, 0x2E, 0x0B, 0x04, 0x32, 0x0D, 0x19, 0x08, 0x30, 
    0x04, 0x2D, 0x0B, 0x01, 0x13, 0x24, 0x29, 0x0C, 0x32, 0x1A, 
    0x09, 0x14, 0x2C, 0x21, 0x31, 0x0B, 0x2B, 0x1C, 0x07, 0x13, 
    0x0A, 0x24, 0x12, 0x0B, 0x1E, 0x08, 0x24, 0x05, 0x2E, 0x09, 
    0x2A, 0x13, 0x04, 0x22, 0x12, 0x2E, 0x0F, 0x24, 0x0B, 0x28, 
    0x04, 0x10, 0x26, 0x2E, 0x23, 0x12, 0x30, 0x24, 0x19, 0x2A, 0x0A, 
};

// The next 3 cells are for halftoning to the 8 colors that contain
// all combinations of 0x00 and 0xFF.
// These cells contain values between 0x00 and 0xFE (inclusive).

const BYTE HT_SuperCell_RedMono[91*91] = {
    0xA8, 0x3C, 0x72, 0xF9, 0x46, 0x65, 0xB1, 0x72, 0xA1, 0x86,         //  0
    0x03, 0xAD, 0x5E, 0x1D, 0x3C, 0x9B, 0x00, 0xF3, 0x36, 0x17, 
    0xB0, 0x81, 0x19, 0xCF, 0xB4, 0x7D, 0x99, 0xDD, 0x74, 0xEF, 
    0x39, 0x67, 0xF4, 0x43, 0xDA, 0x9B, 0x38, 0x1B, 0xBB, 0x40, 
    0x03, 0x68, 0xF7, 0x9A, 0x0A, 0xEC, 0x33, 0xAA, 0xF1, 0xC6, 
    0x31, 0xE5, 0x98, 0xD2, 0x49, 0xF3, 0x1C, 0x66, 0x3C, 0x16, 
    0xC6, 0x6C, 0x3D, 0xD0, 0x68, 0x33, 0x90, 0x07, 0xAF, 0xDF, 
    0xCC, 0x8E, 0x4A, 0xEE, 0x72, 0xBA, 0xF2, 0x0C, 0xDD, 0x6E, 
    0x12, 0x27, 0xE5, 0x8A, 0xC1, 0x5E, 0xD5, 0x0E, 0x50, 0x88, 0x61, 

    0x91, 0xE9, 0x4F, 0xC1, 0x9D, 0x2E, 0xE1, 0x4F, 0x3A, 0xE6,         //  1
    0x30, 0xF7, 0x95, 0x76, 0xC0, 0x7F, 0x59, 0xAC, 0x92, 0x6A, 
    0xDD, 0x42, 0x64, 0xEA, 0x02, 0x2E, 0x54, 0xA9, 0x2C, 0x51, 
    0xB1, 0xCF, 0x2B, 0xAF, 0x7F, 0x63, 0xFD, 0x75, 0xD3, 0x9B, 
    0xE7, 0xAF, 0x18, 0x74, 0xD5, 0x44, 0xCB, 0x15, 0x59, 0x84, 
    0x08, 0xB2, 0x5B, 0x2F, 0x71, 0xC4, 0x84, 0xE4, 0xA6, 0x80, 
    0xDF, 0x2D, 0xF5, 0x7F, 0x1C, 0xD8, 0x57, 0xEE, 0x38, 0x83, 
    0x12, 0x6A, 0xC3, 0x05, 0xA9, 0x43, 0x8E, 0x33, 0xC3, 0x4E, 
    0xEC, 0xC7, 0x6A, 0x07, 0xF1, 0x40, 0x86, 0xA8, 0xEE, 0xC6, 0x0A, 

    0x2C, 0xB9, 0x1F, 0x89, 0x11, 0xC9, 0x80, 0x1C, 0xC5, 0x68,         //  2
    0xB6, 0x52, 0x24, 0xDA, 0x0F, 0xED, 0x28, 0x40, 0xE8, 0x09, 
    0xBD, 0x25, 0xAD, 0x8D, 0x6E, 0xBD, 0xF5, 0x0C, 0x92, 0xD7, 
    0x7B, 0x00, 0x97, 0x55, 0x17, 0xBA, 0x05, 0x8D, 0x2B, 0x5E, 
    0x23, 0x48, 0xC7, 0x38, 0x8B, 0x60, 0xB0, 0x78, 0xA0, 0x40, 
    0xF9, 0x8D, 0x1A, 0xEB, 0xA3, 0x40, 0x28, 0xCD, 0x03, 0x49, 
    0xB5, 0x0E, 0xAA, 0x47, 0x9D, 0xBF, 0x24, 0x76, 0xC4, 0x55, 
    0xA6, 0xE9, 0x30, 0x83, 0x58, 0x20, 0xD5, 0x5F, 0xA5, 0x81, 
    0x31, 0x97, 0x42, 0xB3, 0x72, 0x14, 0xDF, 0x26, 0x37, 0x6D, 0xDE, 

    0x80, 0x57, 0xDB, 0x68, 0xEE, 0x3C, 0xA5, 0xFD, 0x94, 0x10,         //  3
    0x82, 0xD0, 0xA2, 0x37, 0x62, 0xCB, 0xB1, 0x83, 0xCE, 0x51, 
    0x8B, 0xF5, 0x4E, 0x1C, 0xE3, 0x3C, 0x87, 0x66, 0xBB, 0x20, 
    0x48, 0xE7, 0x6F, 0xCA, 0xEE, 0x45, 0xDE, 0x4F, 0xB5, 0xF5, 
    0x92, 0x7B, 0xE3, 0xA4, 0x1E, 0xFD, 0x02, 0xE7, 0x2F, 0xD9, 
    0x6A, 0x4E, 0xD4, 0x7A, 0x09, 0xB8, 0x60, 0x97, 0x76, 0xF4, 
    0x5F, 0x8F, 0x67, 0xEA, 0x00, 0x88, 0xE0, 0xA2, 0x0D, 0xFD, 
    0x24, 0x45, 0xD4, 0x9A, 0xFA, 0xB3, 0x7C, 0x17, 0xF6, 0x00, 
    0xB8, 0x5B, 0xFB, 0x2D, 0x9B, 0xC9, 0x7B, 0x5C, 0x94, 0xB6, 0x4A, 

    0xFC, 0xA1, 0x07, 0xB1, 0x4D, 0x7A, 0x00, 0x5A, 0x31, 0xDE,         //  4
    0x43, 0x15, 0x73, 0xF3, 0x8D, 0x49, 0x17, 0x6C, 0x23, 0xA4, 
    0x32, 0x74, 0xCE, 0x9C, 0x5B, 0xCA, 0x17, 0xD9, 0x38, 0xF9, 
    0x8B, 0xA7, 0x22, 0x3E, 0x87, 0xA4, 0x24, 0xCE, 0x6A, 0x0C, 
    0xD3, 0x51, 0x07, 0x6A, 0xBF, 0x50, 0x99, 0x65, 0xC8, 0x17, 
    0xA8, 0x29, 0xBF, 0x47, 0x94, 0xFB, 0xD6, 0x1B, 0x3C, 0xC2, 
    0x22, 0xDB, 0x3A, 0xB9, 0x77, 0x59, 0x2F, 0x48, 0x66, 0x95, 
    0x7D, 0xB9, 0x70, 0x18, 0x39, 0x66, 0xDC, 0x3F, 0x92, 0x69, 
    0xE4, 0x1E, 0x7E, 0xD4, 0x4C, 0x23, 0xB4, 0xF7, 0x01, 0xD6, 0x17, 

    0x3F, 0x6F, 0xCB, 0x33, 0x96, 0xE3, 0xCE, 0xB0, 0x70, 0x9C,         //  5
    0xBF, 0xE6, 0x4B, 0xAF, 0x0A, 0xA4, 0xE0, 0xB7, 0xFE, 0x60, 
    0xDC, 0x11, 0x45, 0xB9, 0x07, 0x78, 0xA6, 0x52, 0x9B, 0x6E, 
    0x0D, 0x5C, 0xD6, 0xB6, 0x09, 0x5B, 0x79, 0x96, 0x3C, 0xAE, 
    0x31, 0xBC, 0xF4, 0x92, 0x2E, 0xDD, 0x24, 0x87, 0x4B, 0xB8, 
    0x75, 0x97, 0xF0, 0x23, 0x65, 0x13, 0x51, 0xAE, 0xE5, 0x84, 
    0x51, 0x9C, 0x11, 0xD0, 0x2A, 0xF6, 0xB1, 0xC7, 0xE3, 0x35, 
    0xD0, 0x02, 0x50, 0xDF, 0xBF, 0x09, 0x9A, 0xC1, 0x27, 0xD4, 
    0x4B, 0x9E, 0xC0, 0x05, 0x6A, 0xEB, 0x56, 0x3D, 0xA4, 0x65, 0x92, 

    0xB9, 0x29, 0x8B, 0xF3, 0x18, 0x60, 0x24, 0x44, 0xF3, 0x0B,         //  6
    0x5F, 0x89, 0x2D, 0xCF, 0x68, 0x82, 0x2F, 0x58, 0x04, 0x84, 
    0xC1, 0x94, 0xEC, 0x2F, 0x8F, 0xFB, 0x29, 0xE6, 0x1A, 0xCC, 
    0xB2, 0xED, 0x2B, 0x76, 0xFA, 0xBD, 0xE1, 0x11, 0xF0, 0x73, 
    0x8D, 0x5E, 0x16, 0x44, 0xCF, 0x6F, 0xB5, 0xE5, 0x0F, 0xF7, 
    0x3C, 0x04, 0x80, 0xB0, 0xCE, 0x7C, 0x9D, 0x32, 0x6A, 0x09, 
    0xB6, 0xFE, 0x71, 0x54, 0xA8, 0x92, 0x09, 0x7A, 0x17, 0xA9, 
    0x5B, 0xF5, 0x8A, 0xA3, 0x79, 0x4B, 0xE6, 0x55, 0x7A, 0xAF, 
    0x11, 0x70, 0x37, 0xDF, 0x8D, 0xA7, 0x11, 0x84, 0xE3, 0x2F, 0xD0, 

    0x0A, 0xDD, 0x67, 0x44, 0xBD, 0xA3, 0x86, 0xC4, 0x7A, 0x3A,         //  7
    0xB2, 0x1B, 0xFB, 0x55, 0xBD, 0x42, 0xEF, 0xA6, 0xD0, 0x41, 
    0x20, 0x56, 0x75, 0xD7, 0x62, 0x3F, 0xB8, 0x66, 0x84, 0x46, 
    0x32, 0x82, 0x4F, 0x98, 0x1C, 0x44, 0x2D, 0xA7, 0x4C, 0xD6, 
    0x25, 0xE9, 0xB5, 0x7C, 0x9F, 0x08, 0x38, 0x60, 0x9E, 0x6C, 
    0xC2, 0xDC, 0x62, 0x3A, 0xED, 0x2C, 0xC4, 0xF5, 0x92, 0xD6, 
    0x46, 0x24, 0x89, 0xE8, 0x1C, 0x6D, 0x3F, 0xEE, 0x99, 0x6D, 
    0x2D, 0xAF, 0x44, 0x1B, 0xF0, 0x2B, 0x8A, 0x12, 0xF5, 0x40, 
    0x8D, 0xEE, 0xB2, 0x51, 0x20, 0xCD, 0x72, 0xBE, 0x1B, 0x8A, 0x50, 

    0x7B, 0xA6, 0x14, 0xD7, 0x76, 0x0D, 0xDE, 0x2B, 0x99, 0xE5,         //  8
    0xCA, 0x6D, 0xA5, 0x01, 0xDE, 0x28, 0x90, 0x19, 0x6D, 0x9F, 
    0xF4, 0xB5, 0x0A, 0xA2, 0x18, 0xCC, 0x93, 0x0A, 0xD5, 0xA3, 
    0xE4, 0x03, 0xC9, 0xAC, 0x6D, 0xD2, 0x84, 0x60, 0xC2, 0x14, 
    0x9F, 0x6E, 0x36, 0xE0, 0x53, 0xF8, 0x8B, 0xD1, 0x1E, 0x33, 
    0x85, 0x45, 0xA4, 0x11, 0x94, 0x6E, 0x01, 0x4D, 0x20, 0x5F, 
    0x9E, 0xCA, 0x36, 0xBE, 0x4C, 0xB5, 0xD3, 0x59, 0x25, 0xB7, 
    0xEA, 0x0C, 0x74, 0xD4, 0x5E, 0xC7, 0xA9, 0x63, 0xB9, 0x22, 
    0xCC, 0x5E, 0x0C, 0x81, 0xF8, 0x2F, 0x45, 0xEF, 0x5F, 0xB2, 0xE9, 

    0x58, 0xFA, 0x4E, 0x94, 0x32, 0xF6, 0x4A, 0x6F, 0x06, 0x5B,         //  9
    0x30, 0x8F, 0x3E, 0x7D, 0xAF, 0x75, 0xC7, 0x4E, 0xDA, 0x2E, 
    0x78, 0x45, 0xC9, 0x32, 0xEE, 0x6C, 0x4C, 0xF4, 0x27, 0x57, 
    0x8F, 0x67, 0xF5, 0x13, 0x4B, 0xEC, 0x9B, 0x07, 0xF4, 0x83, 
    0x43, 0xCD, 0x1D, 0xAC, 0x13, 0x73, 0xBC, 0x4D, 0xE6, 0xAE, 
    0xF2, 0x1A, 0xC8, 0xE7, 0x55, 0xBA, 0xE1, 0x84, 0xB3, 0xED, 
    0x0E, 0x6E, 0xDF, 0x05, 0x82, 0xF9, 0x16, 0x8E, 0xCD, 0x3B, 
    0xD7, 0x91, 0xBB, 0x38, 0x9B, 0x08, 0x43, 0xD6, 0x80, 0x51, 
    0x98, 0x30, 0xD8, 0x9D, 0x63, 0xBA, 0x95, 0x04, 0xD3, 0x37, 0x1F, 

    0xC0, 0x84, 0x24, 0xC6, 0xAB, 0x5C, 0xCB, 0xB3, 0xD7, 0xA0,         // 10
    0xF0, 0x11, 0xCF, 0xED, 0x22, 0x5A, 0x0C, 0xF9, 0xB1, 0x06, 
    0x90, 0xE5, 0x5F, 0x97, 0x7F, 0xAC, 0x2F, 0xB4, 0x73, 0xC5, 
    0x3C, 0xB0, 0x2F, 0x7F, 0xBB, 0x33, 0x69, 0xB4, 0x2A, 0x5E, 
    0xBA, 0xFB, 0x62, 0x96, 0xC9, 0x3D, 0x24, 0xA2, 0x01, 0x72, 
    0x50, 0x97, 0x5C, 0x80, 0x21, 0x43, 0x9E, 0x68, 0x28, 0xC7, 
    0x90, 0x42, 0xAE, 0x98, 0x5B, 0x30, 0xA4, 0x71, 0x03, 0x4E, 
    0x7D, 0x5A, 0x15, 0xF6, 0x6C, 0xE0, 0x8E, 0x32, 0xE7, 0x02, 
    0xFE, 0x74, 0xBD, 0x3D, 0x15, 0xDC, 0x52, 0x83, 0xAE, 0x74, 0x9D, 

    0x07, 0x3A, 0xD3, 0x6C, 0x02, 0x8B, 0x1F, 0x40, 0x7F, 0x1C,         // 11
    0x54, 0xB9, 0x66, 0x48, 0x94, 0xE2, 0xA5, 0x81, 0x3D, 0x63, 
    0xC0, 0x35, 0x10, 0xD1, 0x3E, 0x00, 0xE0, 0x85, 0x0E, 0xE8, 
    0x1E, 0xD2, 0x52, 0xE2, 0x93, 0x1E, 0xD0, 0x4D, 0xE1, 0x96, 
    0x35, 0x02, 0x81, 0x43, 0xEF, 0x89, 0xE0, 0x65, 0x8C, 0xCC, 
    0x27, 0xDA, 0x06, 0xA8, 0xC6, 0xFC, 0x10, 0xD5, 0x3B, 0x7B, 
    0x1C, 0xF6, 0x66, 0x2B, 0xE6, 0xC2, 0x43, 0xE0, 0xB4, 0xFD, 
    0xA0, 0x2F, 0xC8, 0x81, 0x22, 0x4F, 0xB3, 0x15, 0x68, 0xC2, 
    0xA1, 0x1A, 0x4D, 0xEF, 0x7B, 0xA5, 0x27, 0xFC, 0x13, 0x49, 0xED, 

    0x65, 0xE3, 0xA2, 0x53, 0xED, 0xD8, 0x71, 0x9B, 0xFD, 0x39,         // 12
    0xDF, 0x7A, 0xA4, 0x16, 0xC5, 0x31, 0x6C, 0x1D, 0xD3, 0x9B, 
    0xF5, 0x7C, 0xA9, 0x69, 0xFD, 0x57, 0xC8, 0x63, 0xA1, 0x4C, 
    0x8D, 0x70, 0xA0, 0x0B, 0x62, 0xFE, 0x77, 0x8C, 0x19, 0xC9, 
    0x75, 0xA7, 0xD2, 0x28, 0x5D, 0x0C, 0xC2, 0x47, 0xFE, 0x38, 
    0xB7, 0x7A, 0xF3, 0x39, 0x72, 0x2C, 0x8A, 0x5E, 0xA8, 0xDB, 
    0x58, 0xBB, 0x15, 0xCC, 0x76, 0x0E, 0x62, 0x8A, 0x21, 0x64, 
    0x10, 0xB1, 0xDD, 0x3F, 0xA7, 0xED, 0x74, 0xD2, 0x95, 0x37, 
    0x5A, 0xDF, 0x8A, 0x06, 0xB7, 0x37, 0x6F, 0xC7, 0x62, 0xD6, 0x8E, 

    0xB5, 0x45, 0x12, 0x93, 0x3D, 0x25, 0xC1, 0x0A, 0x62, 0xC6,         // 13
    0x90, 0x07, 0x37, 0xFA, 0x83, 0x4F, 0xBC, 0xEE, 0x59, 0x13, 
    0x4C, 0x2D, 0xDD, 0x17, 0x8B, 0xB1, 0x1C, 0x3B, 0xF8, 0xBA, 
    0x15, 0xF2, 0x2C, 0xDA, 0xBE, 0x48, 0x05, 0xAB, 0x41, 0xF2, 
    0x59, 0x22, 0xEB, 0xBB, 0xA3, 0x78, 0x33, 0xAF, 0x13, 0x5A, 
    0x94, 0x1F, 0x63, 0xCF, 0x99, 0x55, 0xB5, 0xE7, 0x08, 0x48, 
    0x9C, 0x7F, 0xE9, 0x47, 0x92, 0xA9, 0xF5, 0x32, 0xD1, 0x7F, 
    0xEA, 0x50, 0x6D, 0x98, 0x03, 0xC3, 0x28, 0x44, 0xF2, 0x80, 
    0x21, 0xAA, 0x64, 0xC8, 0x56, 0xEC, 0x91, 0x1D, 0xA8, 0x36, 0x20, 

    0x70, 0x86, 0xF8, 0xBB, 0x7C, 0xA6, 0x52, 0xE4, 0xB2, 0x21,         // 14
    0x4E, 0xCE, 0xAE, 0x57, 0xD9, 0x04, 0x98, 0x28, 0x87, 0xAD, 
    0xCC, 0x8F, 0x5C, 0xC3, 0x37, 0x7B, 0xDC, 0x99, 0x25, 0x80, 
    0x62, 0xC1, 0x4E, 0x7B, 0x34, 0x9F, 0xE4, 0xC4, 0x6A, 0x10, 
    0xB8, 0x86, 0x46, 0x6B, 0x1D, 0xF3, 0xD2, 0x98, 0x79, 0xEA, 
    0xD3, 0x49, 0xA5, 0x0D, 0xEE, 0x1D, 0xCB, 0x32, 0x83, 0xFA, 
    0x1F, 0x3A, 0xAA, 0x01, 0x59, 0xC8, 0x19, 0x9A, 0x55, 0xBF, 
    0x35, 0x91, 0x1C, 0xF9, 0x57, 0x8A, 0x62, 0xA1, 0x09, 0xBB, 
    0xD9, 0x42, 0xF6, 0x29, 0x9D, 0x0F, 0xD6, 0x47, 0x7D, 0xF4, 0xC4, 

    0x0C, 0xCF, 0x38, 0x19, 0x5C, 0xF2, 0x2A, 0x81, 0x37, 0xA2,         // 15
    0x78, 0xE5, 0x66, 0x1D, 0xA5, 0x76, 0xCA, 0x3E, 0xDE, 0x69, 
    0x02, 0xEC, 0x26, 0x99, 0xE8, 0x07, 0x4F, 0x6A, 0xCE, 0x45, 
    0xE5, 0x03, 0x92, 0xB3, 0x11, 0x85, 0x5D, 0x25, 0x96, 0xDB, 
    0x34, 0x9D, 0x0C, 0xE0, 0x92, 0x52, 0x04, 0x61, 0x2C, 0xBA, 
    0x08, 0x84, 0xC1, 0x40, 0x6B, 0x86, 0x4B, 0xA3, 0x69, 0xB8, 
    0xD1, 0x66, 0xDB, 0x79, 0xEE, 0x39, 0x6F, 0xE5, 0x3F, 0xA3, 
    0x05, 0xD8, 0xBB, 0x34, 0xD2, 0x15, 0xEA, 0xC7, 0x5C, 0x34, 
    0x75, 0x13, 0x95, 0x71, 0xE0, 0x3F, 0x65, 0xB1, 0x00, 0x96, 0x52, 

    0xEB, 0xA0, 0x67, 0xC3, 0xD9, 0x0C, 0x93, 0xD0, 0x66, 0xF8,         // 16
    0x18, 0x41, 0x8C, 0xED, 0x33, 0x4A, 0xF2, 0x63, 0x1B, 0xBD, 
    0x42, 0x73, 0xB3, 0x48, 0x6C, 0xC6, 0xA5, 0xEF, 0x0F, 0x90, 
    0xAC, 0x39, 0xD0, 0x57, 0xEB, 0xCB, 0x43, 0xF7, 0x7D, 0x4B, 
    0xC0, 0xFC, 0x57, 0xB3, 0x34, 0xC4, 0x82, 0xD9, 0xA6, 0x4E, 
    0x6F, 0xF9, 0x2E, 0xDD, 0xAD, 0xD6, 0x02, 0xEF, 0x27, 0x4E, 
    0x0B, 0x94, 0x26, 0xBC, 0x1C, 0x8B, 0xB5, 0x0F, 0x7C, 0xF5, 
    0x60, 0x78, 0x46, 0xA1, 0x6B, 0xB4, 0x7B, 0x1E, 0x94, 0xFB, 
    0xAD, 0xD2, 0x4F, 0xBA, 0x1F, 0x82, 0xC6, 0xED, 0x58, 0xD3, 0x2E, 

    0x82, 0x4A, 0x23, 0x8C, 0x73, 0x46, 0xB7, 0x57, 0x01, 0xC2,         // 17
    0x97, 0xB9, 0x08, 0xC6, 0x86, 0xB5, 0x0B, 0xAA, 0x95, 0xFA, 
    0x85, 0xD7, 0x1E, 0xF5, 0x13, 0x8E, 0x2B, 0x3E, 0x7A, 0xC9, 
    0x20, 0x6E, 0xFA, 0x17, 0x76, 0x2B, 0xA4, 0x17, 0xB1, 0x01, 
    0x6D, 0x27, 0x84, 0xD3, 0x74, 0x21, 0xF9, 0x3D, 0x1A, 0xE4, 
    0x98, 0x16, 0x66, 0x8D, 0x1A, 0x5C, 0x97, 0x77, 0xCC, 0xA5, 
    0x7E, 0xF2, 0x46, 0x9A, 0x57, 0xD0, 0x4B, 0xDB, 0x28, 0xC7, 
    0x1F, 0xE2, 0x8D, 0x09, 0xF3, 0x2B, 0x41, 0xD0, 0x4C, 0x6E, 
    0x23, 0x87, 0x06, 0xEF, 0x57, 0xAE, 0x2E, 0x89, 0x1E, 0x73, 0xBC, 

    0x10, 0xDC, 0xAA, 0xFC, 0x2E, 0xA3, 0xED, 0x30, 0xDE, 0x73,         // 18
    0x27, 0x5B, 0xDD, 0x69, 0x22, 0x5A, 0xE3, 0x7B, 0x52, 0x36, 
    0x13, 0xA7, 0x59, 0x7C, 0xD2, 0x55, 0xDD, 0xBB, 0x5E, 0xF3, 
    0x4F, 0x88, 0xA2, 0x3F, 0xBC, 0x8F, 0x65, 0xE1, 0x53, 0xC8, 
    0x95, 0xDC, 0x41, 0x08, 0x9F, 0x4B, 0xB1, 0x93, 0x6C, 0xC1, 
    0x3A, 0xD1, 0xA8, 0x47, 0xEB, 0x31, 0xC3, 0x3D, 0x18, 0xE9, 
    0x5B, 0x2F, 0xC6, 0x70, 0xF8, 0x06, 0xA7, 0x68, 0x9A, 0x84, 
    0x4E, 0xAC, 0x32, 0xCD, 0x54, 0x93, 0xAD, 0xE4, 0x01, 0xA4, 
    0xE8, 0x48, 0xC4, 0x69, 0xA1, 0x0E, 0xDA, 0x46, 0xA4, 0xF8, 0x3E, 

    0xB6, 0x6F, 0x54, 0x04, 0xD4, 0x69, 0x13, 0x84, 0x9F, 0x4D,         // 19
    0xF3, 0x81, 0x32, 0x9A, 0xFE, 0xBE, 0x3C, 0x24, 0xBA, 0xE0, 
    0x67, 0xCC, 0x3C, 0x96, 0xB6, 0x23, 0x86, 0x01, 0x9C, 0x16, 
    0xB5, 0x2E, 0xCA, 0x61, 0xE7, 0x0A, 0xD2, 0x38, 0x7F, 0xF4, 
    0x20, 0x5C, 0xAD, 0xF4, 0x63, 0xE2, 0x0F, 0x58, 0xEE, 0x00, 
    0x7B, 0x55, 0xE3, 0x0A, 0xBC, 0x81, 0xFA, 0x65, 0x9B, 0x44, 
    0xB7, 0xD9, 0x14, 0xAD, 0x2B, 0x7F, 0x42, 0xEF, 0x30, 0xBC, 
    0x0A, 0xFD, 0x61, 0x7D, 0xBB, 0x12, 0x72, 0x57, 0xC0, 0x31, 
    0x61, 0xD8, 0x2C, 0x93, 0x3B, 0xFD, 0x71, 0xB8, 0x09, 0x5B, 0x93, 

    0xF1, 0x1A, 0xCD, 0x7C, 0x95, 0x3F, 0xBC, 0xD7, 0x38, 0xB4,         // 20
    0x0B, 0xD4, 0xA9, 0x53, 0x13, 0x71, 0x9D, 0xD7, 0x88, 0x0B, 
    0x99, 0x27, 0xEF, 0x06, 0x47, 0xFE, 0x67, 0xE6, 0x45, 0xD4, 
    0x6B, 0xE9, 0x04, 0x99, 0x32, 0x7A, 0xB5, 0x1C, 0xAA, 0x42, 
    0x78, 0xC1, 0x15, 0x8E, 0x29, 0xBB, 0x7A, 0xCF, 0x35, 0x8D, 
    0xB6, 0x2C, 0x91, 0x75, 0x4F, 0x25, 0xA9, 0x10, 0xDE, 0x79, 
    0x03, 0x84, 0x61, 0x3C, 0xE6, 0x95, 0xD2, 0x15, 0x5E, 0xE3, 
    0x6E, 0x96, 0x15, 0xDB, 0x29, 0xEC, 0x3B, 0x99, 0xF1, 0x7C, 
    0x91, 0x14, 0xAA, 0x75, 0xC8, 0x21, 0x55, 0xD4, 0x7C, 0xDF, 0x2C, 

    0x4D, 0x96, 0x34, 0xBA, 0x1D, 0xF5, 0x52, 0x7A, 0x20, 0x63,         // 21
    0xC5, 0x45, 0x21, 0xEA, 0x8A, 0xCE, 0x00, 0x66, 0x4C, 0xEB, 
    0x6F, 0xB0, 0x79, 0xC7, 0x6F, 0x9B, 0x37, 0xB9, 0x82, 0x25, 
    0x91, 0x4C, 0x7D, 0xD7, 0x4F, 0xFD, 0x57, 0x8A, 0xE4, 0x09, 
    0x9D, 0xEC, 0x49, 0x76, 0xD8, 0x3B, 0x98, 0x1F, 0xAD, 0x48, 
    0xFD, 0xC8, 0x14, 0xF1, 0x9E, 0xD9, 0x70, 0x53, 0xC6, 0x3A, 
    0xA4, 0xFE, 0x9A, 0xCC, 0x73, 0x1D, 0xBD, 0x7A, 0xA8, 0x44, 
    0xC6, 0x37, 0xB0, 0x4A, 0x9F, 0x84, 0xD4, 0x0B, 0x46, 0x22, 
    0xBB, 0xF5, 0x57, 0x0C, 0xE8, 0x89, 0xAA, 0x3C, 0x23, 0xC0, 0x83, 

    0xAD, 0xD8, 0x63, 0xE4, 0x5B, 0xAD, 0x06, 0xE0, 0x93, 0xEB,         // 22
    0x9B, 0x83, 0x6D, 0xB7, 0x2C, 0x47, 0xB2, 0xF8, 0x1A, 0xBC, 
    0x36, 0x52, 0xDD, 0x24, 0xAC, 0x0E, 0xD1, 0x19, 0x63, 0xAA, 
    0xF9, 0x15, 0xBD, 0x24, 0xA9, 0x10, 0xC9, 0x2A, 0x64, 0xCC, 
    0x6E, 0x22, 0xD1, 0xA5, 0x03, 0x53, 0xEA, 0x64, 0xDA, 0x73, 
    0x1C, 0x59, 0xAB, 0x63, 0x3C, 0x04, 0xBD, 0x93, 0x2D, 0xE6, 
    0x5B, 0x23, 0x46, 0x0A, 0xB2, 0x50, 0x35, 0xFA, 0x00, 0x8D, 
    0x26, 0xD5, 0x74, 0xF4, 0x62, 0x16, 0xBE, 0x67, 0xAA, 0xDF, 
    0x6A, 0x39, 0xD0, 0xB5, 0x43, 0x67, 0x01, 0xF2, 0x97, 0x5F, 0x0C, 

    0x3D, 0x7B, 0x07, 0x9E, 0x29, 0x8A, 0x6C, 0xC7, 0x4D, 0x10,         // 23
    0x35, 0xF9, 0x05, 0xD7, 0x68, 0xE4, 0x7B, 0x34, 0x98, 0x82, 
    0xD1, 0x11, 0x9F, 0x4B, 0xF1, 0x5D, 0x8D, 0xED, 0x4A, 0xD8, 
    0x36, 0xA1, 0x65, 0xEC, 0x84, 0x6B, 0x98, 0xF1, 0x3D, 0x8E, 
    0x51, 0xAF, 0x31, 0x67, 0xFB, 0x84, 0xC1, 0x0D, 0x32, 0x99, 
    0xD0, 0x7F, 0x35, 0xC0, 0xE2, 0x8A, 0x48, 0xF7, 0x17, 0x86, 
    0xBA, 0xD6, 0x7E, 0xF0, 0x67, 0xE2, 0x8F, 0x63, 0xB8, 0x56, 
    0xEB, 0x87, 0x0C, 0x3C, 0xC8, 0x33, 0x77, 0xFC, 0x54, 0x8A, 
    0x04, 0xA0, 0x7A, 0x2C, 0x97, 0xDE, 0xB9, 0x78, 0x47, 0xC9, 0xEC, 

    0x1D, 0xB4, 0xF7, 0x44, 0xC9, 0xE9, 0x39, 0x25, 0xA7, 0x72,         // 24
    0xBC, 0x56, 0xA8, 0x40, 0x95, 0x14, 0xAA, 0x54, 0xDC, 0x25, 
    0x60, 0xFB, 0x88, 0x75, 0x2E, 0xB2, 0x3C, 0x73, 0xC5, 0x0D, 
    0x79, 0x53, 0xCB, 0x2E, 0x41, 0xC2, 0x4E, 0x05, 0xB8, 0xDA, 
    0x10, 0xEF, 0x87, 0x3F, 0xB8, 0x17, 0x6F, 0xA0, 0xF5, 0x4F, 
    0x06, 0xEC, 0x93, 0x12, 0x77, 0x31, 0xD2, 0x63, 0xB2, 0x71, 
    0x08, 0x4E, 0xAB, 0x3D, 0x97, 0x0E, 0xCD, 0x1E, 0xDB, 0x9D, 
    0x19, 0x65, 0xBA, 0x9C, 0xE4, 0x8E, 0xAF, 0x2B, 0x18, 0xC3, 
    0x45, 0xDA, 0x1D, 0xFA, 0x5D, 0x16, 0x37, 0xD2, 0x11, 0x9F, 0x6A, 

    0xE2, 0x4E, 0x91, 0x19, 0x76, 0x51, 0xB3, 0xFD, 0x81, 0xD7,         // 25
    0x17, 0xE0, 0x85, 0x1F, 0xCB, 0x5F, 0xF3, 0x09, 0xBD, 0x74, 
    0xA6, 0x32, 0xC1, 0x04, 0xCD, 0xE3, 0x13, 0x9D, 0x30, 0xB1, 
    0x8F, 0xF4, 0x06, 0x9A, 0xDF, 0x17, 0xEA, 0x81, 0x9E, 0x2B, 
    0x7E, 0xC0, 0x19, 0xD9, 0x92, 0x50, 0xE4, 0x3E, 0xBD, 0x79, 
    0xAE, 0x2B, 0xC9, 0x52, 0xF3, 0xAD, 0x0C, 0x98, 0x3F, 0xCB, 
    0xF1, 0x92, 0x1B, 0xD0, 0x27, 0xBC, 0x4C, 0x85, 0x2F, 0x45, 
    0xC4, 0xF8, 0x4C, 0x23, 0x5D, 0x04, 0x44, 0xD5, 0x98, 0xEA, 
    0x70, 0xB4, 0x50, 0x86, 0xC8, 0xA4, 0x8C, 0x6B, 0xFC, 0x2D, 0x87, 

    0x39, 0xD0, 0x70, 0xDD, 0xBC, 0x09, 0x90, 0x14, 0x58, 0x3E,         // 26
    0x9C, 0x69, 0x4B, 0xEB, 0xB5, 0x28, 0x82, 0x9E, 0x41, 0xEC, 
    0x0D, 0x55, 0xE1, 0x42, 0x90, 0x60, 0x7F, 0xFB, 0x59, 0xE1, 
    0x26, 0x45, 0xB7, 0x6A, 0x88, 0xB3, 0x66, 0x22, 0x55, 0xFB, 
    0x6A, 0x49, 0xA2, 0x59, 0x22, 0xCD, 0x2A, 0x88, 0x1B, 0x5B, 
    0xDD, 0x44, 0x71, 0xA0, 0x28, 0x5B, 0x7E, 0xEB, 0x1E, 0x57, 
    0x2E, 0x6B, 0xE5, 0x5F, 0x7F, 0xF8, 0x6A, 0xAE, 0xE9, 0x70, 
    0x91, 0x08, 0x80, 0xDA, 0x73, 0xF1, 0xBE, 0x7B, 0x5E, 0x38, 
    0x11, 0x90, 0xE1, 0x07, 0x3C, 0xEF, 0x4F, 0x1D, 0xA9, 0x52, 0xC3, 

    0xA0, 0x15, 0x5A, 0x2F, 0x98, 0xE7, 0x62, 0xCD, 0xAF, 0xEF,         // 27
    0x2A, 0xC5, 0x0F, 0x93, 0x6F, 0x46, 0xD5, 0x58, 0x1B, 0xCD, 
    0x8A, 0xB7, 0x6F, 0xA2, 0x29, 0xBF, 0x47, 0xA9, 0x00, 0x73, 
    0xC7, 0x86, 0xE8, 0x13, 0x56, 0x2F, 0xD6, 0xA8, 0xC8, 0x37, 
    0xD1, 0x04, 0xE2, 0x73, 0xF7, 0x9A, 0x66, 0xC7, 0xF1, 0x99, 
    0x11, 0x87, 0xEE, 0x03, 0xD2, 0xB6, 0x39, 0xBF, 0xD9, 0x89, 
    0xA2, 0xC3, 0x0E, 0xB7, 0x30, 0x9D, 0x43, 0x04, 0xC7, 0x24, 
    0xAC, 0x3B, 0xC9, 0xB0, 0x37, 0xA2, 0x4C, 0x0E, 0xF8, 0xB0, 
    0xD1, 0x2C, 0x64, 0xC1, 0x7D, 0x24, 0xB2, 0xD5, 0x79, 0xE6, 0x0A, 

    0xBC, 0x82, 0xFA, 0xAD, 0x4B, 0x27, 0x7B, 0x3B, 0x1F, 0x8E,         // 28
    0x75, 0xE2, 0xB0, 0x32, 0xF7, 0x02, 0xAD, 0xE7, 0x95, 0x67, 
    0x3B, 0xEF, 0x1D, 0x51, 0xF3, 0x10, 0xDB, 0x39, 0xD4, 0x98, 
    0x17, 0x54, 0x34, 0xCE, 0xA5, 0xF8, 0x46, 0x6F, 0x12, 0x85, 
    0xAB, 0x8E, 0x2E, 0xB3, 0x0D, 0x40, 0xAF, 0x01, 0x77, 0x47, 
    0xCE, 0xB5, 0x37, 0x65, 0x82, 0xF9, 0x12, 0x72, 0x5E, 0x00, 
    0xFC, 0x42, 0x86, 0x4F, 0xEC, 0x17, 0xD6, 0x8B, 0x5C, 0xF0, 
    0x52, 0xE1, 0x63, 0x12, 0x8C, 0x25, 0xE4, 0x94, 0x26, 0x84, 
    0x48, 0xA8, 0xF4, 0x4B, 0xA2, 0xE5, 0x5E, 0x03, 0x34, 0x91, 0x64, 

    0x26, 0x3E, 0xC9, 0x00, 0x89, 0xBD, 0xF6, 0x9E, 0xD6, 0x5E,         // 29
    0x04, 0x41, 0x7F, 0x5A, 0xCB, 0x88, 0x2E, 0x75, 0x25, 0xC0, 
    0x12, 0x83, 0xAD, 0xD4, 0x76, 0xB0, 0x6B, 0x89, 0x25, 0x5F, 
    0xF1, 0xAA, 0x72, 0x93, 0x20, 0x80, 0x02, 0x94, 0xEC, 0x61, 
    0x20, 0xF4, 0x7B, 0x5E, 0xC8, 0x86, 0x59, 0xE5, 0x35, 0xA6, 
    0x6F, 0x24, 0xE3, 0xA8, 0x19, 0x54, 0x90, 0xA5, 0x40, 0xB6, 
    0x78, 0x1F, 0xDC, 0x97, 0x6A, 0xB1, 0x76, 0x26, 0xA4, 0x0D, 
    0x7C, 0x31, 0x98, 0xFE, 0x52, 0xBC, 0x64, 0xCC, 0x58, 0xDD, 
    0x6D, 0x13, 0x8D, 0x1D, 0x75, 0x3A, 0xCA, 0x9A, 0xF6, 0x4B, 0xCF, 

    0xED, 0x9B, 0x5C, 0x73, 0xDC, 0x1B, 0x69, 0x0D, 0x4A, 0xB9,         // 30
    0xFB, 0xA3, 0xD4, 0x25, 0x9F, 0x53, 0xC3, 0x49, 0xF5, 0xA1, 
    0xDC, 0x63, 0x42, 0x03, 0x90, 0x22, 0x4E, 0xF7, 0xA2, 0xBE, 
    0x40, 0xD1, 0x07, 0xEC, 0x50, 0xC8, 0xE1, 0xB8, 0x3A, 0xD5, 
    0x4B, 0xBF, 0x35, 0xDF, 0x16, 0xF1, 0x20, 0xBB, 0xD3, 0x1A, 
    0xFE, 0x5D, 0x8F, 0x45, 0xCD, 0xB4, 0x2A, 0xEC, 0xCC, 0x26, 
    0xE3, 0x5D, 0xC5, 0x05, 0x49, 0xE1, 0x35, 0xFB, 0xC0, 0x8F, 
    0xD7, 0xB7, 0x1A, 0x71, 0xCD, 0x01, 0x7A, 0x3A, 0xA4, 0x0B, 
    0xC2, 0xE9, 0x37, 0xD3, 0xB5, 0x16, 0x87, 0x65, 0xB7, 0x1C, 0x72, 

    0x52, 0x19, 0xE7, 0x29, 0x9F, 0x55, 0xC7, 0x81, 0xE5, 0x92,         // 31
    0x2D, 0x61, 0x13, 0xE8, 0x72, 0x0F, 0xD8, 0x93, 0x07, 0x57, 
    0x33, 0x99, 0xFE, 0xBB, 0x5A, 0xE8, 0xC2, 0x0A, 0x36, 0x6E, 
    0x13, 0x84, 0x5D, 0xB5, 0x2E, 0x69, 0x26, 0x7B, 0x17, 0xAD, 
    0x74, 0x08, 0x9B, 0x4D, 0xA9, 0x6B, 0x95, 0x4A, 0x81, 0x55, 
    0x99, 0x08, 0xDA, 0x74, 0x32, 0xE5, 0x6A, 0x0F, 0x85, 0x52, 
    0xAA, 0x90, 0x3B, 0xA2, 0xCA, 0x13, 0x92, 0x5A, 0x41, 0x6D, 
    0x21, 0x5C, 0xEA, 0xA6, 0x35, 0xEF, 0xB3, 0x1D, 0xF6, 0x41, 
    0x7D, 0x52, 0x9B, 0x62, 0xFE, 0x50, 0xE7, 0x10, 0x41, 0xDA, 0xAC, 

    0x87, 0xC6, 0x7D, 0xB7, 0x3D, 0xF2, 0x30, 0xA7, 0x3F, 0x11,         // 32
    0x78, 0xC2, 0x90, 0x40, 0xAA, 0xFA, 0x38, 0x68, 0xBD, 0x7D, 
    0xCE, 0x11, 0x77, 0x27, 0xD2, 0x30, 0x96, 0x79, 0xE1, 0xC8, 
    0x96, 0xFC, 0x39, 0xD7, 0x8C, 0xA8, 0x49, 0x9A, 0xFE, 0x58, 
    0x93, 0xED, 0xCE, 0x84, 0x30, 0xD7, 0x27, 0xAE, 0x0F, 0xEA, 
    0xB7, 0x3B, 0xBE, 0x17, 0x9D, 0x7D, 0x49, 0xC6, 0x36, 0xF3, 
    0x0A, 0x73, 0x25, 0xF8, 0x84, 0x67, 0xAB, 0xD3, 0x2A, 0xC7, 
    0xE4, 0x3F, 0x8B, 0x0F, 0x4C, 0x80, 0x96, 0xD6, 0x69, 0x91, 
    0xB7, 0x20, 0xCA, 0x03, 0x8C, 0x28, 0xA0, 0xC8, 0x7C, 0x95, 0x0D, 

    0xFC, 0x45, 0x0A, 0xD8, 0x6B, 0x8F, 0x04, 0xD1, 0x64, 0xB4,         // 33
    0xE9, 0x4D, 0xD0, 0x67, 0x1E, 0x88, 0xB3, 0x1A, 0xF0, 0x26, 
    0xA7, 0xE8, 0x3F, 0x8B, 0xA5, 0x6D, 0x45, 0xB1, 0x59, 0x1C, 
    0x49, 0xAA, 0x21, 0x79, 0x0D, 0xF2, 0xD1, 0x09, 0x40, 0xBB, 
    0x21, 0x3A, 0x5A, 0x10, 0xC1, 0x53, 0xF8, 0x73, 0xC8, 0x35, 
    0x7C, 0x64, 0xF5, 0x54, 0xD6, 0x02, 0xF0, 0xAC, 0x98, 0x62, 
    0xD0, 0xB0, 0xD9, 0x5B, 0x3F, 0x23, 0xEA, 0x0F, 0x84, 0x9C, 
    0x07, 0xAD, 0x69, 0xDB, 0xC3, 0x60, 0x24, 0x4F, 0x07, 0xDE, 
    0x30, 0xF3, 0x6D, 0xB0, 0x58, 0xDA, 0x70, 0x4D, 0x23, 0xE2, 0x35, 

    0x70, 0x9D, 0x60, 0xAF, 0x19, 0xE0, 0x58, 0x7B, 0xF4, 0x1F,         // 34
    0x98, 0x33, 0x01, 0xEE, 0xBC, 0x4B, 0x74, 0xD9, 0x40, 0x93, 
    0x4D, 0x6F, 0xB6, 0x18, 0xF6, 0x07, 0xD9, 0x29, 0xF4, 0x7F, 
    0xD3, 0x64, 0xE8, 0xC1, 0x52, 0x6D, 0xB7, 0x65, 0xE1, 0x7E, 
    0xD2, 0x6E, 0xAE, 0xF4, 0x7C, 0xA1, 0x03, 0x47, 0x8F, 0xDF, 
    0x1F, 0xAC, 0x8E, 0x28, 0xA6, 0x88, 0x2D, 0x55, 0x13, 0x7F, 
    0x2E, 0x50, 0x16, 0x96, 0xE4, 0xBC, 0x76, 0x52, 0xF1, 0x48, 
    0x7A, 0xFA, 0x22, 0x9A, 0x32, 0xE9, 0xAD, 0xC8, 0x7C, 0xA2, 
    0x49, 0x87, 0x17, 0xE5, 0x2E, 0xBF, 0x09, 0xF7, 0xA7, 0x5F, 0xBC, 

    0xD8, 0x3A, 0xEF, 0x2E, 0x9A, 0x43, 0xBC, 0x9F, 0x38, 0x54,         // 35
    0xD5, 0x77, 0xAF, 0x83, 0x29, 0xCF, 0x08, 0xA1, 0x61, 0xC3, 
    0x00, 0xD9, 0x5B, 0xC9, 0x83, 0x60, 0xBA, 0x90, 0x0F, 0xA0, 
    0x3B, 0x01, 0x8E, 0x40, 0xA2, 0x2A, 0x8F, 0x1E, 0xA3, 0x36, 
    0x01, 0xE5, 0x8C, 0x20, 0x3B, 0x61, 0xE6, 0xB0, 0x26, 0x58, 
    0xBF, 0x05, 0x46, 0xEA, 0x5F, 0xCE, 0x6E, 0xBE, 0xDF, 0xB4, 
    0xF7, 0x8B, 0xBF, 0x6B, 0x0B, 0x9F, 0x32, 0xC8, 0xA5, 0x2B, 
    0xC0, 0x60, 0xB4, 0x51, 0x83, 0x19, 0x6C, 0x3C, 0xFA, 0x1E, 
    0xBD, 0xD8, 0x53, 0x97, 0x79, 0x3E, 0x8F, 0xCE, 0x33, 0x8D, 0x02, 

    0xA5, 0x21, 0x84, 0xC4, 0x76, 0xFB, 0x2A, 0x10, 0xCA, 0x8C,         // 36
    0x0D, 0xFE, 0x5A, 0x3B, 0xE1, 0x8F, 0x53, 0xEC, 0x2A, 0x85, 
    0xFA, 0x34, 0x9A, 0x49, 0x27, 0xEB, 0x32, 0x4D, 0x6B, 0xEC, 
    0xBF, 0x73, 0xDA, 0x19, 0xEF, 0xCB, 0x4A, 0xF7, 0x59, 0xC7, 
    0x98, 0x5D, 0x45, 0xC7, 0xDC, 0x91, 0x1B, 0xCF, 0x6B, 0xFB, 
    0x87, 0xDB, 0x71, 0xC3, 0x11, 0x3D, 0xFC, 0x1D, 0x38, 0x76, 
    0x04, 0x3F, 0xEB, 0x29, 0xD5, 0x5A, 0x8C, 0x04, 0x6B, 0xDF, 
    0x11, 0x3B, 0xE2, 0x02, 0xF1, 0xA1, 0xD9, 0x0D, 0x95, 0x5C, 
    0x78, 0x34, 0xAE, 0x0E, 0xF3, 0xA9, 0x5D, 0x14, 0x78, 0xF0, 0x56, 

    0xCD, 0x65, 0xDF, 0x4B, 0x14, 0x5D, 0x86, 0xDA, 0x69, 0xB4,         // 37
    0x61, 0xC2, 0x16, 0xA0, 0x6F, 0x19, 0xAE, 0x78, 0xD4, 0x19, 
    0xA9, 0x7D, 0x0D, 0xE2, 0xA3, 0x78, 0xD0, 0xA8, 0xD8, 0x17, 
    0x94, 0x28, 0xAB, 0x61, 0x86, 0x05, 0x75, 0xBB, 0x10, 0x80, 
    0xEF, 0x16, 0xA6, 0x75, 0x0B, 0xB6, 0x77, 0x37, 0xA3, 0x0E, 
    0x4F, 0x31, 0x9C, 0x24, 0xB2, 0x7D, 0xA7, 0x8D, 0x5C, 0xA3, 
    0xD8, 0x62, 0xA1, 0x7C, 0xAE, 0x38, 0xFD, 0xCF, 0x4D, 0x83, 
    0x9F, 0xD1, 0x94, 0x78, 0xC6, 0x42, 0x80, 0x55, 0xE7, 0xC8, 
    0x00, 0xEB, 0x62, 0xD0, 0x4B, 0x21, 0xE1, 0xC5, 0x4A, 0xB3, 0x17, 

    0x41, 0x96, 0x08, 0xA9, 0xE7, 0xC2, 0xA4, 0x47, 0xE9, 0x2B,         // 38
    0x41, 0x91, 0xE4, 0x50, 0xB8, 0xF6, 0x31, 0x43, 0x98, 0x63, 
    0x47, 0xD1, 0x67, 0xBD, 0x1A, 0x5A, 0x04, 0x86, 0x2F, 0x65, 
    0x43, 0xE7, 0x51, 0xC2, 0x34, 0xDE, 0x9B, 0x40, 0xDB, 0x2F, 
    0x6D, 0xBE, 0x3A, 0xFC, 0x57, 0x2F, 0xF0, 0x53, 0x8B, 0xD2, 
    0xAF, 0x7A, 0xF5, 0x64, 0xD4, 0x51, 0x06, 0xC9, 0xE6, 0x48, 
    0x24, 0xC7, 0x14, 0x49, 0xDE, 0x74, 0x19, 0xB0, 0x23, 0xF1, 
    0x46, 0x6E, 0x24, 0x35, 0x63, 0x13, 0xC0, 0x2B, 0xAB, 0x40, 
    0x8B, 0xA0, 0x26, 0x73, 0xC3, 0x87, 0x67, 0x94, 0x28, 0xE3, 0x83, 

    0xF9, 0xC0, 0x77, 0x29, 0x8B, 0x37, 0x01, 0x75, 0x1C, 0x9F,         // 39
    0xF2, 0x71, 0x25, 0xD2, 0x0B, 0x68, 0xD9, 0xB3, 0x07, 0xF2, 
    0xB8, 0x1E, 0xED, 0x36, 0x8E, 0xF3, 0xC5, 0x48, 0xFC, 0xB1, 
    0xCC, 0x80, 0x09, 0xFA, 0x6E, 0xA9, 0x14, 0x62, 0x8C, 0xAB, 
    0x4D, 0xDE, 0x23, 0x84, 0xD1, 0x96, 0xC3, 0x16, 0xE3, 0x3E, 
    0x24, 0xC6, 0x0A, 0x43, 0x88, 0xEF, 0x34, 0x78, 0x16, 0xB3, 
    0x89, 0x6D, 0xF2, 0x91, 0x09, 0xC3, 0x52, 0x9A, 0x66, 0xB8, 
    0x15, 0xC7, 0xE6, 0xAB, 0xF7, 0x9A, 0xD7, 0x89, 0x64, 0x1F, 
    0xDB, 0x4F, 0xF6, 0xAA, 0x06, 0x43, 0xFC, 0x0F, 0xA5, 0x5C, 0x31, 

    0x16, 0x51, 0xEA, 0x64, 0xD3, 0x57, 0xEE, 0xB2, 0xCF, 0x84,         // 40
    0x06, 0xBF, 0x39, 0x7E, 0x9D, 0x2B, 0x88, 0x59, 0xCE, 0x76, 
    0x30, 0x9E, 0x80, 0x55, 0xB4, 0x3D, 0x6D, 0xA2, 0x14, 0x77, 
    0x1D, 0xA5, 0x3D, 0x97, 0x1D, 0x54, 0xEE, 0xCA, 0x29, 0xF9, 
    0x05, 0x99, 0x62, 0xB2, 0x3F, 0x07, 0x7A, 0xAA, 0x63, 0x84, 
    0xEB, 0x57, 0xAA, 0xDD, 0x29, 0xBC, 0x9D, 0x60, 0xF8, 0x39, 
    0xDF, 0x4E, 0xB6, 0x2C, 0x66, 0xEA, 0x84, 0x36, 0xE2, 0x2F, 
    0x8E, 0x5D, 0x07, 0x81, 0x50, 0x37, 0x6D, 0x09, 0xFD, 0xC3, 
    0x71, 0x10, 0x85, 0x36, 0xDC, 0x99, 0xBB, 0x3A, 0x79, 0xD8, 0xB2, 

    0x88, 0xA1, 0x3B, 0xB7, 0x15, 0x9B, 0x7C, 0x4D, 0x33, 0x65,         // 41
    0xDC, 0x58, 0xA7, 0xFA, 0x45, 0xBF, 0xF0, 0x20, 0x3E, 0x94, 
    0x51, 0xCA, 0x02, 0xD5, 0x26, 0xE1, 0x0C, 0x8C, 0xDB, 0x4F, 
    0xED, 0x5A, 0xDD, 0xB9, 0x81, 0xC1, 0x24, 0x77, 0xB6, 0x5C, 
    0x7D, 0xCC, 0x14, 0xE6, 0x6B, 0xF5, 0x4D, 0x29, 0xCD, 0x00, 
    0x9E, 0x70, 0x17, 0x92, 0x6B, 0x14, 0x42, 0xD1, 0xA7, 0x7D, 
    0x02, 0x9A, 0x3D, 0xD5, 0xA3, 0x41, 0xB6, 0x00, 0xCC, 0x73, 
    0xFA, 0xA3, 0x41, 0xBD, 0xDC, 0x24, 0xE8, 0xB8, 0x52, 0x99, 
    0x2F, 0xB5, 0xCF, 0x58, 0x78, 0x27, 0x53, 0xE9, 0xC5, 0x03, 0x69, 

    0x28, 0xDD, 0x06, 0x85, 0xF6, 0x2B, 0xCB, 0x0B, 0xFC, 0xB9,         // 42
    0x21, 0x96, 0x12, 0xCA, 0x5D, 0x05, 0x7D, 0xA6, 0xE3, 0xBD, 
    0x17, 0xFE, 0x61, 0x99, 0x78, 0xAC, 0x5A, 0xB9, 0x37, 0xC4, 
    0x26, 0x93, 0x13, 0x62, 0x38, 0xD8, 0x48, 0xA0, 0x0F, 0xD7, 
    0x45, 0xA8, 0x35, 0x87, 0x25, 0xCA, 0xB4, 0x8E, 0xF0, 0x50, 
    0x34, 0xC1, 0xFD, 0x4A, 0xC9, 0xEC, 0x81, 0x0D, 0x56, 0x2C, 
    0xCB, 0x63, 0xFB, 0x0D, 0x7F, 0x21, 0xF6, 0x6A, 0xA6, 0x4D, 
    0x11, 0xD0, 0x75, 0x1A, 0x94, 0x79, 0xA8, 0x3C, 0x1C, 0x7A, 
    0xE2, 0x45, 0x92, 0x1A, 0xF3, 0xAF, 0x8D, 0x21, 0x5A, 0x96, 0xF1, 

    0xB4, 0x60, 0xC5, 0x49, 0x6C, 0xAD, 0x5E, 0x8B, 0xA3, 0x39,         // 43
    0x7D, 0xEC, 0x3D, 0x76, 0x92, 0xE8, 0x3A, 0x68, 0x0D, 0x5C, 
    0x81, 0xA4, 0x2F, 0xE5, 0x16, 0x41, 0xF8, 0x22, 0x82, 0x65, 
    0xAB, 0x74, 0xC9, 0xF0, 0x00, 0x8F, 0x66, 0xF5, 0x39, 0x8A, 
    0x19, 0xF3, 0x58, 0xD5, 0x97, 0x42, 0x0E, 0x5C, 0x7C, 0xB1, 
    0xE1, 0x1E, 0x79, 0x2D, 0x9F, 0x52, 0xB4, 0xDB, 0x95, 0xED, 
    0xB4, 0x19, 0x75, 0xBF, 0x56, 0xD2, 0x8A, 0x45, 0x22, 0xC4, 
    0x85, 0x2A, 0xE9, 0x56, 0xC7, 0x04, 0x5D, 0x89, 0xF0, 0xC8, 
    0x61, 0x03, 0xEA, 0xB7, 0x64, 0x08, 0xD2, 0x71, 0xAB, 0x35, 0x4A, 

    0x76, 0x1F, 0x94, 0xE5, 0x33, 0xD6, 0x22, 0xDF, 0x13, 0x5B,         // 44
    0xCA, 0x51, 0xB0, 0x28, 0xD3, 0x1D, 0xB5, 0xD7, 0x92, 0xEF, 
    0x36, 0xC5, 0x7C, 0x53, 0xBF, 0x8F, 0x67, 0xC8, 0xE0, 0x12, 
    0xF4, 0x2D, 0x42, 0x83, 0xA9, 0xDF, 0x1B, 0xC6, 0x71, 0xDE, 
    0x9B, 0x6E, 0xB2, 0x02, 0x74, 0xA6, 0xE1, 0xC3, 0x15, 0x3F, 
    0x66, 0x94, 0xB7, 0xD8, 0x0B, 0x72, 0x3A, 0x1E, 0x6A, 0x45, 
    0x85, 0x35, 0xE3, 0x95, 0x28, 0xAA, 0x13, 0xDC, 0x93, 0xF0, 
    0x5F, 0xAB, 0x3A, 0xB0, 0xF9, 0x46, 0xDB, 0xBE, 0x10, 0x49, 
    0xA2, 0x84, 0x2D, 0x4F, 0xD9, 0x83, 0x44, 0xF6, 0x19, 0xE2, 0xCC, 

    0xA6, 0xFE, 0x57, 0x15, 0xA0, 0x7D, 0x42, 0xBB, 0x72, 0xF1,         // 45
    0x91, 0x01, 0xDB, 0x62, 0x9C, 0x4C, 0x81, 0x57, 0x2A, 0xCB, 
    0x4E, 0x1E, 0xEC, 0x09, 0xDB, 0x2B, 0xA6, 0x01, 0x49, 0x9D, 
    0x5B, 0xD6, 0xB1, 0x5E, 0x26, 0x3F, 0x9B, 0x4F, 0x06, 0xB8, 
    0x24, 0x43, 0xE3, 0x51, 0xF7, 0x21, 0x6A, 0x31, 0xF9, 0xA0, 
    0xD2, 0x06, 0x5A, 0x40, 0xF1, 0x8E, 0xBE, 0xF8, 0xAA, 0x08, 
    0xDC, 0xA0, 0x4D, 0x6A, 0xF1, 0x3F, 0x60, 0xB8, 0x77, 0x31, 
    0x05, 0xD9, 0x8A, 0x11, 0x74, 0xAB, 0x35, 0x69, 0x9B, 0x29, 
    0xED, 0xC3, 0x72, 0xA7, 0x36, 0x9E, 0x13, 0xB5, 0x86, 0x65, 0x0D, 

    0x80, 0x3A, 0xD2, 0x72, 0xC0, 0x0C, 0xF7, 0x85, 0x4E, 0x26,         // 46
    0xC2, 0x44, 0x7F, 0xF8, 0x11, 0xC5, 0xF2, 0x03, 0xAA, 0x6D, 
    0x8C, 0xB2, 0x66, 0xA2, 0x87, 0x5A, 0xF0, 0x72, 0x86, 0xBF, 
    0x1C, 0x8C, 0x09, 0xC5, 0xFE, 0x6F, 0xBF, 0x85, 0xEB, 0x5B, 
    0x82, 0xCA, 0x2D, 0x90, 0xBF, 0x47, 0x88, 0xAE, 0x52, 0x82, 
    0x33, 0xE8, 0x86, 0xA2, 0xC6, 0x1B, 0x57, 0x29, 0x74, 0xC6, 
    0x59, 0x24, 0xCF, 0x03, 0xBD, 0x82, 0xEA, 0x0B, 0x53, 0xC1, 
    0xA0, 0x6E, 0x4B, 0xE2, 0x2C, 0x93, 0x18, 0xF5, 0x7D, 0xB7, 
    0x5C, 0x12, 0xDE, 0x1C, 0xFD, 0x62, 0xCC, 0x50, 0x27, 0xC1, 0x44, 

    0xEC, 0x00, 0xAB, 0x29, 0xEB, 0x55, 0x98, 0x1C, 0xAB, 0xE1,         // 47
    0x6A, 0xA7, 0x1C, 0xB9, 0x36, 0x6D, 0x43, 0x95, 0xDD, 0x24, 
    0xF4, 0x0D, 0xCC, 0x49, 0x23, 0xB8, 0x3E, 0xCE, 0x25, 0xF9, 
    0x3C, 0xE2, 0x75, 0x49, 0x9F, 0x12, 0xE1, 0x42, 0x2D, 0x9F, 
    0xFB, 0x0A, 0xA7, 0x67, 0x11, 0xD4, 0xEB, 0x05, 0xCA, 0x20, 
    0x6C, 0xBD, 0x13, 0x35, 0x63, 0xE0, 0x82, 0xD8, 0x93, 0x34, 
    0xF0, 0x7A, 0xA7, 0x3B, 0x91, 0x18, 0x68, 0x9E, 0xE1, 0x3C, 
    0xFE, 0x1C, 0xC9, 0xA7, 0x62, 0xE8, 0xC4, 0x56, 0x09, 0xD2, 
    0x34, 0x9D, 0x42, 0x89, 0xB9, 0x2E, 0x75, 0xEE, 0x9C, 0xD8, 0x94, 

    0x5B, 0xCB, 0x64, 0x8F, 0x3F, 0x7A, 0xD6, 0xC4, 0x45, 0x09,         // 48
    0x8B, 0x31, 0xD3, 0x53, 0x8D, 0xDA, 0xB3, 0x31, 0x60, 0xC0, 
    0x4C, 0x79, 0x31, 0xFB, 0x74, 0xD8, 0x14, 0x9A, 0x6A, 0xA8, 
    0x62, 0x9B, 0x2C, 0xD2, 0x7F, 0x36, 0x60, 0xB0, 0xD8, 0x1D, 
    0x72, 0x56, 0xDA, 0x36, 0x7A, 0xAC, 0x34, 0x73, 0x98, 0xF0, 
    0xA7, 0x4B, 0xFB, 0x77, 0xB4, 0x01, 0x39, 0xA1, 0x12, 0x68, 
    0xB0, 0x16, 0xE4, 0x70, 0xFB, 0xC6, 0x34, 0xD1, 0x21, 0x7E, 
    0x61, 0x97, 0x34, 0x83, 0x02, 0x42, 0x88, 0xAE, 0x3E, 0x91, 
    0xF1, 0x69, 0xCA, 0x57, 0x10, 0xE3, 0x91, 0x05, 0x39, 0x6F, 0x1F, 

    0xBC, 0x86, 0x1A, 0xE0, 0xBA, 0x05, 0x33, 0x63, 0x7E, 0xFB,         // 49
    0xC5, 0x60, 0xEF, 0x9F, 0x08, 0x7C, 0x1F, 0xEB, 0x83, 0x14, 
    0x9E, 0xDE, 0x94, 0xB0, 0x06, 0x90, 0x55, 0xED, 0x37, 0x05, 
    0xCD, 0x50, 0xEF, 0x0D, 0xB7, 0xF2, 0x91, 0x07, 0x7E, 0xC5, 
    0x39, 0x8F, 0xB9, 0xEF, 0x99, 0x1D, 0x58, 0xD0, 0x40, 0x65, 
    0x17, 0x8D, 0xD3, 0x22, 0x97, 0xEA, 0x4D, 0xBB, 0xFA, 0x50, 
    0xD4, 0x95, 0x5E, 0x1D, 0x4C, 0xA9, 0x77, 0x51, 0x92, 0xBB, 
    0x08, 0xE3, 0x53, 0xF3, 0xB4, 0xCF, 0x1D, 0x70, 0xE0, 0x1F, 
    0x7F, 0x00, 0xE5, 0xAC, 0x79, 0x47, 0xBD, 0x5E, 0xAF, 0xE6, 0x3F, 

    0x10, 0xFA, 0x35, 0x9E, 0x5C, 0xF6, 0xA4, 0xDC, 0x18, 0x95,         // 50
    0x3E, 0x0F, 0x76, 0x2D, 0xB7, 0xFD, 0x69, 0x4B, 0xA6, 0xD0, 
    0x37, 0x53, 0x1A, 0x62, 0xE3, 0x44, 0xC6, 0x7E, 0xB5, 0xE4, 
    0x8C, 0x19, 0xAB, 0x6E, 0x53, 0x20, 0xDB, 0x67, 0x47, 0xA2, 
    0xE7, 0x19, 0x50, 0x26, 0x63, 0xBF, 0xFE, 0x85, 0x0F, 0xB7, 
    0xDE, 0x38, 0x60, 0xC4, 0x44, 0x69, 0xD0, 0x72, 0x2D, 0x86, 
    0x08, 0x43, 0xB5, 0xDC, 0x8E, 0x2B, 0xE7, 0x0D, 0xF4, 0x43, 
    0xCF, 0xAE, 0x16, 0x77, 0x28, 0x65, 0xFC, 0x45, 0xC5, 0xA4, 
    0x50, 0xB9, 0x3D, 0x20, 0x9E, 0xD4, 0x2C, 0xF9, 0x1A, 0x7D, 0xA1, 

    0x53, 0x72, 0xD0, 0x49, 0x80, 0x29, 0x8C, 0x47, 0xAE, 0x59,         // 51
    0xB2, 0xE8, 0x90, 0xCC, 0x41, 0x15, 0x97, 0xBE, 0x05, 0x6E, 
    0xF8, 0xB3, 0x7F, 0xCA, 0x36, 0xA5, 0x18, 0x5E, 0x24, 0x4B, 
    0x75, 0xC5, 0x33, 0x88, 0xCE, 0xA4, 0x33, 0xC1, 0xF8, 0x0F, 
    0x87, 0xD2, 0xAB, 0x80, 0xD6, 0x03, 0x46, 0xA5, 0xE6, 0x2E, 
    0x79, 0xA3, 0x06, 0x82, 0xF5, 0x18, 0x8C, 0x0C, 0xA5, 0xC5, 
    0xEA, 0x79, 0x2F, 0xC5, 0x05, 0x7E, 0xCB, 0x5F, 0xA8, 0x75, 
    0x2D, 0x64, 0x9C, 0xD7, 0x49, 0x90, 0xA6, 0x0C, 0x87, 0x2D, 
    0xF8, 0x6C, 0x8B, 0xEF, 0x64, 0x0A, 0x89, 0x6D, 0xCA, 0x47, 0xDC, 

    0x92, 0x25, 0xAC, 0x0E, 0xBF, 0xD3, 0x15, 0x74, 0xF0, 0x2C,         // 52
    0xD9, 0x1D, 0x4A, 0x6E, 0xE5, 0x5F, 0xD5, 0x3F, 0xE5, 0x2B, 
    0x8A, 0x0B, 0xEB, 0x28, 0x75, 0xF3, 0x87, 0xD1, 0xFC, 0xA9, 
    0x2C, 0xDE, 0x5E, 0xF9, 0x04, 0x4D, 0x74, 0x94, 0x2D, 0x59, 
    0x72, 0x3B, 0x11, 0xF5, 0x37, 0x95, 0x74, 0x20, 0x5D, 0xCD, 
    0x4C, 0xF2, 0xBA, 0x3B, 0x9E, 0x32, 0xB9, 0xE6, 0x3D, 0x61, 
    0x21, 0x9B, 0xF7, 0x54, 0xA3, 0x40, 0xB3, 0x22, 0x87, 0x11, 
    0xEF, 0x8D, 0x36, 0xB9, 0xEC, 0x17, 0xCE, 0x56, 0xE8, 0x63, 
    0x0E, 0xC3, 0x33, 0xCA, 0x43, 0xE0, 0xB1, 0x33, 0x98, 0x03, 0xBA, 

    0x79, 0xE9, 0x5F, 0xF4, 0x6B, 0x38, 0xE6, 0xB4, 0x01, 0x8E,         // 53
    0x65, 0x9E, 0xC7, 0x06, 0xAC, 0x8F, 0x24, 0x7B, 0x9C, 0x5F, 
    0xBC, 0x56, 0x9F, 0x4C, 0xBA, 0x01, 0x47, 0x9D, 0x11, 0x65, 
    0x94, 0x0B, 0xB3, 0x3A, 0x91, 0xEB, 0xB5, 0x18, 0xDF, 0xAA, 
    0xEE, 0xC7, 0x60, 0xA1, 0x6A, 0xC5, 0xEA, 0xB4, 0x88, 0x09, 
    0x99, 0x31, 0x71, 0xE0, 0x5B, 0xD4, 0x6E, 0x51, 0x8F, 0xD9, 
    0xB1, 0x47, 0x11, 0x76, 0xDE, 0x6C, 0xFA, 0x38, 0xDA, 0xBE, 
    0x4E, 0xD2, 0x04, 0x5D, 0x88, 0x30, 0x70, 0xB0, 0x3B, 0x98, 
    0xDB, 0xA4, 0x19, 0x70, 0x95, 0x16, 0x4E, 0xF2, 0x5E, 0xE7, 0x2E, 

    0xC0, 0x0A, 0x99, 0x27, 0x8A, 0xAA, 0x4F, 0x67, 0xCA, 0x40,         // 54
    0xBE, 0x31, 0x85, 0xF7, 0x56, 0x36, 0xC0, 0xF4, 0x19, 0xDB, 
    0x33, 0xCC, 0x13, 0x8C, 0xDC, 0x69, 0xC4, 0x77, 0x3F, 0xC1, 
    0xEA, 0x54, 0x7E, 0xC9, 0x6B, 0x20, 0xD5, 0x66, 0x8B, 0x39, 
    0x02, 0x94, 0x44, 0xE5, 0x2B, 0x0D, 0x55, 0x39, 0xF7, 0xC1, 
    0x64, 0xD8, 0x10, 0x88, 0x1D, 0xA9, 0x10, 0xFE, 0x30, 0x02, 
    0x6C, 0xCF, 0x90, 0xB9, 0x30, 0x16, 0x8E, 0x57, 0x9D, 0x6B, 
    0x1A, 0xA7, 0x75, 0xDE, 0x44, 0xA0, 0xF4, 0x02, 0xD1, 0x75, 
    0x25, 0x80, 0x58, 0xF6, 0xB6, 0x79, 0xC6, 0x22, 0x7E, 0xA3, 0x4A, 

    0xDC, 0x42, 0xCB, 0x56, 0xBD, 0x09, 0x83, 0x1F, 0xFC, 0x79,         // 55
    0x16, 0xEA, 0x4D, 0x20, 0x78, 0xDF, 0x0C, 0x6F, 0x4A, 0xA3, 
    0x82, 0xE9, 0x70, 0xB2, 0x1B, 0x38, 0xF0, 0x23, 0xD9, 0x8B, 
    0x32, 0xAC, 0x15, 0xE5, 0x30, 0xAF, 0x47, 0x0C, 0xCD, 0x55, 
    0xB9, 0x78, 0x1A, 0xB2, 0x84, 0xDD, 0x9C, 0x6F, 0x29, 0x7E, 
    0x20, 0xAF, 0x50, 0xC7, 0xF0, 0x48, 0x96, 0x79, 0xC5, 0x9E, 
    0xF3, 0x23, 0x5E, 0xEE, 0x50, 0xD7, 0xC1, 0x00, 0xED, 0x30, 
    0x89, 0xF6, 0x2B, 0xBA, 0x12, 0xC6, 0x4F, 0x8E, 0x33, 0xBB, 
    0x46, 0xE6, 0xAE, 0x03, 0x3A, 0xE4, 0x55, 0xAC, 0xD3, 0x14, 0x69, 

    0xAC, 0x21, 0x76, 0xE2, 0x45, 0xEF, 0xD0, 0xA3, 0x46, 0xAE,         // 56
    0xD5, 0x6B, 0xA6, 0xD7, 0xB8, 0x97, 0x51, 0xAE, 0xD0, 0x02, 
    0x67, 0x24, 0x48, 0xFB, 0x5A, 0xA6, 0x82, 0xB0, 0x4F, 0x05, 
    0x6C, 0xF7, 0x4A, 0x9E, 0x5B, 0x81, 0xFD, 0xA1, 0x7B, 0xE6, 
    0x22, 0xFA, 0xCF, 0x65, 0x4A, 0xBE, 0x19, 0xD2, 0xA8, 0xDB, 
    0x46, 0xF4, 0x9F, 0x26, 0x72, 0xBB, 0x2A, 0xDF, 0x58, 0x43, 
    0x88, 0x38, 0xAC, 0x08, 0x82, 0xA1, 0x42, 0x7B, 0xAB, 0x5A, 
    0xC4, 0x3D, 0x92, 0x61, 0xE9, 0x7B, 0x18, 0xE0, 0x5F, 0xF9, 
    0x0E, 0x8F, 0x4D, 0xD1, 0x66, 0x25, 0x96, 0x07, 0x3D, 0xF0, 0x89, 

    0x5A, 0xFE, 0xA4, 0x12, 0x94, 0x31, 0x5D, 0x26, 0x90, 0x0C,         // 57
    0x52, 0x8D, 0x03, 0x43, 0x63, 0x15, 0xF0, 0x80, 0x31, 0xF6, 
    0xBA, 0x9A, 0xC4, 0x2F, 0x7B, 0xE4, 0x14, 0x63, 0xE7, 0xA2, 
    0xC6, 0x1B, 0x89, 0xCF, 0x01, 0xC3, 0x25, 0x4F, 0x30, 0xA9, 
    0x61, 0x3E, 0x9D, 0x06, 0xEC, 0x32, 0x80, 0x51, 0x00, 0x69, 
    0x8E, 0x0C, 0x59, 0x8A, 0x3C, 0xE6, 0x63, 0x0A, 0xB0, 0x1B, 
    0xBF, 0xE2, 0x6F, 0xCB, 0x2A, 0x60, 0xE8, 0x1F, 0xCD, 0x0F, 
    0x70, 0xE2, 0x0A, 0xA8, 0x27, 0x9C, 0x68, 0xB3, 0x1F, 0xA0, 
    0x6F, 0xD9, 0x1F, 0xA1, 0x86, 0xC4, 0xFB, 0x7C, 0x63, 0xBA, 0x29, 

    0x03, 0x7F, 0x36, 0x63, 0xC4, 0x79, 0xB1, 0xDE, 0x71, 0xE7,         // 58
    0xC8, 0x3A, 0xF9, 0xC3, 0x87, 0x38, 0xC9, 0x1E, 0x9F, 0x5B, 
    0x3E, 0x10, 0x88, 0xD5, 0x06, 0x99, 0x3C, 0xBD, 0x1F, 0x7A, 
    0x34, 0xDA, 0x70, 0x3B, 0xED, 0x90, 0x71, 0xE1, 0xC5, 0x08, 
    0x8D, 0xC3, 0x28, 0x89, 0xAC, 0x6B, 0xE1, 0x92, 0xFD, 0xC0, 
    0x37, 0xE4, 0xB5, 0xD3, 0x0F, 0xA6, 0x8D, 0xD4, 0x70, 0xE9, 
    0x7F, 0x50, 0x20, 0x92, 0xF9, 0xBA, 0x37, 0x9B, 0x50, 0xFB, 
    0xAE, 0x4B, 0x7E, 0xD7, 0x51, 0xFD, 0x3E, 0xCB, 0x7E, 0x49, 
    0xBA, 0x32, 0x62, 0xF1, 0x0C, 0x70, 0x2D, 0xD8, 0x9D, 0x43, 0xCE, 

    0x99, 0xE7, 0xB0, 0xD7, 0x21, 0xF7, 0x02, 0x40, 0xB8, 0x5B,         // 59
    0x1A, 0xA1, 0x70, 0x2A, 0xE9, 0xA4, 0x6D, 0x48, 0xE3, 0x76, 
    0xC9, 0xE7, 0x53, 0x6B, 0xB5, 0x4E, 0xCE, 0x89, 0xFE, 0x56, 
    0x94, 0x4E, 0xB8, 0x12, 0xAA, 0x5C, 0x18, 0x9C, 0x58, 0xF4, 
    0x6E, 0xDE, 0x58, 0xF4, 0x40, 0x11, 0xB2, 0x25, 0x4B, 0x17, 
    0x9C, 0x73, 0x1F, 0x68, 0xFA, 0x53, 0x21, 0x41, 0x9A, 0x33, 
    0x07, 0xA1, 0xD8, 0x43, 0x6B, 0x0A, 0x89, 0xD8, 0x77, 0x39, 
    0x95, 0x22, 0xB7, 0x32, 0xC1, 0x04, 0x8A, 0x2C, 0xD9, 0x08, 
    0xEB, 0x85, 0xCB, 0x41, 0xBA, 0x50, 0xA8, 0x5B, 0x16, 0xED, 0x70, 

    0x52, 0x3D, 0x0D, 0x8C, 0x4A, 0x9E, 0x67, 0x88, 0x21, 0xF3,         // 60
    0x7E, 0xBD, 0x11, 0x93, 0x57, 0x0E, 0xDB, 0xBD, 0x06, 0x8D, 
    0x26, 0xAE, 0x1A, 0xF6, 0x32, 0xE1, 0x65, 0x0E, 0x30, 0xAF, 
    0xE3, 0x25, 0xF4, 0x7F, 0x48, 0xDB, 0xBE, 0x37, 0x80, 0x1F, 
    0x46, 0xA6, 0x0B, 0x77, 0xD3, 0x56, 0xC9, 0x78, 0xA3, 0xEB, 
    0x5B, 0xC9, 0x92, 0x2E, 0xBE, 0x7D, 0xCB, 0xEE, 0x5E, 0xC4, 
    0xF8, 0x73, 0xB8, 0x12, 0xAA, 0xDF, 0x54, 0x29, 0xBF, 0x15, 
    0xCD, 0x68, 0xF3, 0x5C, 0x9D, 0x74, 0xE6, 0xA6, 0x5D, 0x96, 
    0x6D, 0x13, 0xA7, 0x23, 0x8E, 0xE6, 0x11, 0xC2, 0x86, 0x33, 0xB5, 

    0xDE, 0x7D, 0xBF, 0x5A, 0xE5, 0x28, 0xDA, 0xC7, 0x9F, 0x4B,         // 61
    0x30, 0xD5, 0x4F, 0xE1, 0xC0, 0x83, 0x34, 0x95, 0x51, 0xFD, 
    0x64, 0x3C, 0x7C, 0xA5, 0x8E, 0x21, 0x7A, 0xA4, 0xD4, 0x6A, 
    0x05, 0x9E, 0x61, 0xCE, 0x2E, 0x88, 0x09, 0xEB, 0xA9, 0xD5, 
    0xBE, 0x2F, 0x90, 0xBB, 0x23, 0x9B, 0xE8, 0x32, 0x66, 0xCF, 
    0x3E, 0x07, 0xF1, 0x47, 0x9D, 0x04, 0x3B, 0xAC, 0x13, 0x86, 
    0x47, 0x26, 0x5F, 0xF1, 0x80, 0x22, 0xA0, 0xF2, 0x5E, 0x84, 
    0xE4, 0x07, 0x90, 0x27, 0xDC, 0x55, 0x40, 0x19, 0xF6, 0x28, 
    0xC1, 0x4D, 0xFC, 0x68, 0xD3, 0x43, 0x76, 0xF6, 0x4D, 0xD5, 0x10, 

    0x95, 0x23, 0xFA, 0x18, 0x77, 0xB9, 0x39, 0x59, 0x0C, 0xDD,         // 62
    0x8F, 0x65, 0xAB, 0x40, 0x20, 0xF6, 0x5D, 0xAC, 0x1C, 0xCF, 
    0x9A, 0xC2, 0xD9, 0x00, 0x48, 0xB8, 0xEF, 0x50, 0x3B, 0xBE, 
    0x7C, 0x3F, 0xB6, 0x18, 0xA0, 0xFB, 0x53, 0x71, 0x3D, 0x0E, 
    0x73, 0xFA, 0x4E, 0xDD, 0x69, 0x3A, 0x88, 0x0B, 0xB8, 0x23, 
    0x82, 0xAC, 0x78, 0xD5, 0x61, 0xE2, 0x95, 0x73, 0x2F, 0xB5, 
    0xDE, 0x9B, 0xC7, 0x32, 0x50, 0xC0, 0x6F, 0x02, 0xB7, 0x40, 
    0xA2, 0x51, 0xC8, 0x7C, 0x13, 0xB1, 0xD3, 0x81, 0xBA, 0x45, 
    0xD8, 0x99, 0x30, 0x82, 0x08, 0xA3, 0x20, 0x93, 0x27, 0xA6, 0x62, 

    0x35, 0xAD, 0x68, 0xCC, 0x9D, 0x08, 0x84, 0xF7, 0x73, 0xA7,         // 63
    0x26, 0xFE, 0x04, 0x7A, 0x9C, 0x6C, 0x0A, 0xEA, 0x75, 0x31, 
    0x57, 0x13, 0x6B, 0xF1, 0x5D, 0xCB, 0x0B, 0x96, 0xE2, 0x29, 
    0xF8, 0x8D, 0xD6, 0x58, 0x77, 0xBA, 0x23, 0x99, 0xE0, 0x8B, 
    0x56, 0xA0, 0x18, 0x80, 0x0F, 0xEF, 0xAB, 0x53, 0xF5, 0x93, 
    0xE0, 0x56, 0x35, 0x12, 0xAE, 0x2A, 0x52, 0xFC, 0xCE, 0x61, 
    0x01, 0x78, 0x1C, 0xE6, 0x95, 0xD6, 0x36, 0x93, 0xD3, 0x18, 
    0x74, 0xEE, 0x39, 0xA8, 0xF8, 0x31, 0x64, 0x10, 0x94, 0x71, 
    0x01, 0x5F, 0xDF, 0xC4, 0x56, 0xF0, 0xBA, 0x5F, 0xC8, 0x7B, 0xEC, 

    0xD0, 0x50, 0x8E, 0x32, 0x5E, 0xEB, 0x48, 0xB4, 0x15, 0xCA,         // 64
    0x4D, 0x87, 0xBE, 0xE8, 0x29, 0xD3, 0xB7, 0x42, 0xBF, 0x88, 
    0xE7, 0xB1, 0x2D, 0x85, 0xA0, 0x36, 0x7E, 0x60, 0x1B, 0xA1, 
    0x53, 0x12, 0x35, 0xE9, 0x04, 0x44, 0xD7, 0x5F, 0xB4, 0x2B, 
    0xCA, 0xE8, 0x3C, 0xAE, 0xC8, 0x49, 0x73, 0xD3, 0x39, 0x6C, 
    0x0C, 0xB3, 0xCD, 0x90, 0xEF, 0x79, 0xBB, 0x0B, 0x49, 0x92, 
    0xEB, 0x3D, 0xAB, 0x7E, 0x44, 0x0F, 0xFE, 0x56, 0x7B, 0xE1, 
    0x2C, 0xB4, 0x0E, 0x6C, 0x4D, 0x98, 0xC1, 0xF0, 0x2A, 0xE2, 
    0xB6, 0x88, 0x16, 0xAD, 0x2B, 0x70, 0x3C, 0xDA, 0x1B, 0x4B, 0x02, 

    0x81, 0xF2, 0x0D, 0xDC, 0xAF, 0x26, 0xCE, 0x8D, 0x37, 0x64,         // 65
    0xE4, 0x1A, 0x3E, 0x5D, 0xA6, 0x4C, 0x81, 0x22, 0xD9, 0x06, 
    0x4C, 0x92, 0xD3, 0x45, 0xDD, 0x17, 0xFB, 0xB5, 0xCD, 0x74, 
    0xDB, 0xBC, 0x6F, 0xA9, 0x93, 0xC8, 0x7E, 0x10, 0xEB, 0x4C, 
    0x00, 0x66, 0x88, 0xE2, 0x2B, 0x9D, 0x06, 0xBA, 0x1D, 0xA3, 
    0x42, 0xFB, 0x1C, 0x64, 0x3F, 0x22, 0xD7, 0x88, 0xAE, 0x2D, 
    0xBE, 0x68, 0xD7, 0x15, 0xB9, 0x6B, 0xA6, 0x1E, 0xB0, 0x48, 
    0x90, 0x5D, 0xD2, 0x8B, 0xE6, 0x03, 0x79, 0x3B, 0xA2, 0x5C, 
    0x21, 0xF1, 0x42, 0x7B, 0xE9, 0x99, 0x14, 0x8A, 0xFD, 0xA1, 0xBC, 

    0x23, 0x43, 0xC5, 0x7E, 0x4E, 0x9B, 0x6F, 0x1F, 0xEF, 0xA0,         // 66
    0x7C, 0xB2, 0xDB, 0x8B, 0x18, 0xF8, 0xAE, 0x60, 0x9B, 0x6D, 
    0xF9, 0x18, 0x71, 0x21, 0xBE, 0x67, 0x8D, 0x4C, 0x38, 0x02, 
    0x89, 0x40, 0xF2, 0x2E, 0x5C, 0x21, 0xF6, 0x3B, 0xAC, 0x82, 
    0xC2, 0x99, 0x1D, 0x59, 0x7C, 0xFD, 0x5E, 0x87, 0xED, 0x77, 
    0xC7, 0x59, 0xAA, 0x81, 0xE1, 0x9F, 0x60, 0x17, 0x6D, 0xF5, 
    0x0E, 0x8A, 0x4A, 0xF6, 0x5C, 0xD1, 0x89, 0x39, 0xE7, 0x08, 
    0xBE, 0xFA, 0x1F, 0x41, 0xB2, 0x2A, 0xDC, 0x52, 0xCD, 0x7D, 
    0x38, 0xC7, 0xA3, 0x51, 0x05, 0xCF, 0xB1, 0x55, 0x77, 0x38, 0x60, 

    0x97, 0xB1, 0x6A, 0x1C, 0xFC, 0x01, 0xE0, 0x57, 0xC2, 0x44,         // 67
    0x0B, 0x61, 0x31, 0xC6, 0x6F, 0x3F, 0x10, 0xEB, 0x27, 0xB4, 
    0x39, 0xC9, 0xA2, 0xF3, 0x52, 0xA9, 0x0D, 0xD4, 0x97, 0xF5, 
    0x5B, 0xA5, 0x0E, 0x85, 0xE2, 0xB0, 0x70, 0x97, 0x25, 0x6B, 
    0xF9, 0x35, 0xD4, 0xB7, 0x13, 0x3B, 0xD6, 0x26, 0x46, 0xDC, 
    0x10, 0x96, 0x2C, 0xCA, 0x03, 0x51, 0xF1, 0xC6, 0x39, 0xCF, 
    0x54, 0xA9, 0x27, 0x9A, 0x35, 0x06, 0xEE, 0x6E, 0xC9, 0x65, 
    0x82, 0x4E, 0xA1, 0x75, 0xCC, 0x65, 0x92, 0xB8, 0x09, 0xFE, 
    0x9B, 0x65, 0x1B, 0xD7, 0x8A, 0x6A, 0x41, 0xC3, 0x0E, 0xE9, 0xCB, 

    0x07, 0xEF, 0x2E, 0x93, 0xC3, 0x3D, 0x82, 0xA8, 0x15, 0x8E,         // 68
    0xCC, 0xF9, 0x94, 0x00, 0xE2, 0x9C, 0xCF, 0x78, 0x4F, 0xDB, 
    0x80, 0x5A, 0x04, 0x8B, 0x28, 0x77, 0xEC, 0x2F, 0x66, 0xBA, 
    0x28, 0xD5, 0x6C, 0xBF, 0x47, 0x0A, 0x56, 0xC4, 0xDC, 0x51, 
    0x14, 0xA5, 0x48, 0xE9, 0xA7, 0x8A, 0xC2, 0x98, 0x63, 0xAB, 
    0x3B, 0x73, 0xEB, 0x44, 0xBA, 0x7E, 0x25, 0xA9, 0x90, 0x76, 
    0x22, 0xE2, 0xC9, 0x72, 0xBD, 0x7F, 0xA4, 0x24, 0x41, 0xAC, 
    0x33, 0xDA, 0x0D, 0xEE, 0x3A, 0x18, 0xE8, 0x2E, 0x88, 0x4C, 
    0x12, 0xDD, 0x7E, 0xB5, 0x36, 0xF7, 0x23, 0xE1, 0x93, 0x2D, 0x6F, 

    0x83, 0x47, 0xDA, 0x59, 0xAC, 0x67, 0xD1, 0x34, 0xF4, 0x6D,         // 69
    0x25, 0x53, 0xAC, 0x48, 0x7E, 0x58, 0x31, 0xC0, 0x0A, 0x98, 
    0x2F, 0xB8, 0xD6, 0x3F, 0xE2, 0xC0, 0x47, 0x82, 0xA4, 0x19, 
    0xE9, 0x3A, 0x96, 0x1A, 0xD0, 0x8C, 0xF0, 0x3E, 0x06, 0x92, 
    0xCC, 0x86, 0x64, 0x05, 0x77, 0x4F, 0x18, 0xEA, 0x01, 0x80, 
    0xB9, 0xD1, 0x19, 0x65, 0x92, 0xDE, 0x48, 0x6B, 0x05, 0xE8, 
    0x9F, 0x62, 0x0A, 0x41, 0xD8, 0x1D, 0x51, 0xDD, 0x8F, 0xF5, 
    0x18, 0xC6, 0x68, 0x96, 0xAF, 0x80, 0x4E, 0xA7, 0x67, 0xE4, 
    0xBC, 0x2D, 0x55, 0xED, 0x11, 0x97, 0x5C, 0x7E, 0xAF, 0x53, 0xD6, 

    0xA1, 0xC7, 0x76, 0x0A, 0x32, 0xEA, 0x0E, 0x93, 0x51, 0xB9,         // 70
    0xE6, 0x88, 0x2D, 0xC3, 0xF2, 0x1C, 0xA6, 0x84, 0xFD, 0x64, 
    0xE3, 0x1E, 0x71, 0x9E, 0x5C, 0x23, 0xB0, 0x0B, 0xDE, 0x4D, 
    0x76, 0xB2, 0x54, 0xFB, 0x66, 0x34, 0xA5, 0x7A, 0xB6, 0xE6, 
    0x6F, 0x23, 0xF4, 0xBD, 0x2E, 0xD4, 0x68, 0xB0, 0x38, 0xF9, 
    0x26, 0x56, 0x9E, 0xF3, 0x30, 0x11, 0xB3, 0xFD, 0x41, 0xB9, 
    0x33, 0x86, 0xEE, 0x8F, 0x59, 0xFB, 0xB9, 0x79, 0x01, 0x5A, 
    0x9A, 0x7E, 0x2C, 0x4A, 0x07, 0xBF, 0xF2, 0x14, 0xCC, 0x36, 
    0x70, 0x8F, 0xA4, 0x43, 0x71, 0xAA, 0xDB, 0x00, 0x3B, 0xFA, 0x15, 

    0x38, 0x1B, 0xB3, 0xF8, 0x97, 0x7C, 0x5E, 0xCA, 0x1F, 0x9F,         // 71
    0x09, 0x69, 0xD9, 0x12, 0xB4, 0x68, 0xE0, 0x46, 0x29, 0xA7, 
    0x4C, 0x89, 0xF2, 0x14, 0xD3, 0x86, 0xFD, 0x59, 0xC6, 0x95, 
    0x05, 0xCE, 0x23, 0x7C, 0xB9, 0x16, 0xE4, 0x27, 0x62, 0x19, 
    0x44, 0xB2, 0x39, 0x8E, 0xE4, 0x9C, 0x41, 0x8D, 0xC3, 0x6A, 
    0xDA, 0x82, 0x09, 0xB7, 0x74, 0xD4, 0x5A, 0x85, 0xCD, 0x13, 
    0x56, 0xC2, 0x1B, 0xB0, 0x2F, 0x9D, 0x14, 0x44, 0xCD, 0xB2, 
    0x3C, 0xE2, 0xB6, 0xFC, 0xCF, 0x55, 0x75, 0x42, 0x8C, 0xA9, 
    0x1D, 0xEA, 0x04, 0xBD, 0xD4, 0x1F, 0x46, 0xC5, 0x72, 0xB5, 0x64, 

    0xED, 0x91, 0x69, 0x43, 0xD2, 0x2A, 0xAA, 0xE5, 0x3F, 0x76,         // 72
    0xC4, 0x3C, 0xA1, 0x79, 0x41, 0x92, 0x06, 0xBB, 0x7D, 0xD1, 
    0x08, 0xBC, 0x34, 0x53, 0xAB, 0x68, 0x1B, 0xA2, 0x30, 0x80, 
    0xF2, 0x3F, 0x99, 0xE6, 0x44, 0x9D, 0x56, 0xC4, 0x8E, 0xFE, 
    0x9D, 0xDD, 0x5C, 0x16, 0x71, 0x09, 0xF3, 0x28, 0x54, 0x0E, 
    0xA6, 0x49, 0xC9, 0x37, 0x96, 0x45, 0xA3, 0x1E, 0x69, 0x91, 
    0xF6, 0x70, 0x46, 0xDF, 0x7B, 0x60, 0xD3, 0x97, 0x67, 0xF1, 
    0x24, 0x74, 0x16, 0x61, 0x85, 0x1E, 0x9C, 0xDC, 0x07, 0xF8, 
    0x61, 0xC4, 0x78, 0x33, 0x58, 0x82, 0xE5, 0x99, 0x2A, 0x89, 0xD0, 

    0x59, 0x28, 0xE1, 0x15, 0x54, 0xC1, 0x17, 0x58, 0x8A, 0xFC,         // 73
    0x2A, 0xE0, 0x55, 0xF7, 0x27, 0xD4, 0x56, 0xF0, 0x20, 0x61, 
    0xE8, 0x6E, 0x9A, 0xC8, 0x00, 0xEA, 0x48, 0x77, 0xE7, 0x14, 
    0x5D, 0xAB, 0x65, 0x0E, 0xC1, 0x76, 0x0B, 0xD9, 0x32, 0x54, 
    0x02, 0x7A, 0xC5, 0xAB, 0x4D, 0xCF, 0xB6, 0x7C, 0xCD, 0xE8, 
    0x8B, 0x23, 0xF7, 0x5F, 0xDD, 0x02, 0xED, 0x38, 0xDB, 0xA9, 
    0x35, 0xCE, 0x9C, 0x03, 0xC4, 0x25, 0xED, 0x34, 0x0D, 0x86, 
    0x4F, 0xD9, 0xA2, 0x3D, 0xAD, 0xE7, 0x32, 0xC2, 0x57, 0x85, 
    0x40, 0x25, 0xDB, 0x98, 0xF9, 0xB1, 0x0E, 0x60, 0xF3, 0x0A, 0x40, 

    0x7D, 0xC5, 0xAF, 0x9C, 0x83, 0xF4, 0x6F, 0xA5, 0x0C, 0xB3,         // 74
    0x64, 0x91, 0x04, 0xC7, 0x9A, 0x6C, 0xAF, 0x38, 0x8F, 0xA5, 
    0x44, 0x2A, 0xF7, 0x7D, 0x3A, 0x93, 0xCD, 0xB4, 0x3E, 0xBC, 
    0xD3, 0x29, 0x83, 0xDA, 0x37, 0xF6, 0x93, 0x67, 0xB8, 0x85, 
    0xCE, 0x48, 0x1F, 0xF8, 0x86, 0x23, 0x68, 0x12, 0x9B, 0x3C, 
    0x64, 0xB1, 0x79, 0x2E, 0x8C, 0xC3, 0x73, 0xBB, 0x4E, 0x08, 
    0x7F, 0x1E, 0x53, 0xF4, 0x41, 0x85, 0xA9, 0x72, 0xE3, 0xA4, 
    0xC0, 0x10, 0x89, 0xD2, 0x02, 0x4C, 0x6E, 0xA5, 0x2B, 0xD2, 
    0x9C, 0xB4, 0x67, 0x15, 0x4B, 0x30, 0x78, 0xC9, 0x4E, 0xBA, 0xA3, 

    0xE8, 0x02, 0x3E, 0x6D, 0x0F, 0xB2, 0x46, 0xE7, 0x38, 0xD7,         // 75
    0x20, 0xAD, 0x81, 0x43, 0x14, 0xE7, 0x1D, 0x7A, 0xC2, 0x12, 
    0xCD, 0x87, 0x1C, 0x56, 0xDA, 0x6D, 0x2B, 0x0C, 0x98, 0x72, 
    0x4C, 0xF9, 0xB6, 0x21, 0x5C, 0xAC, 0x4B, 0x27, 0xEB, 0x14, 
    0xA4, 0xE8, 0x69, 0x9B, 0x34, 0xE1, 0xAA, 0x50, 0xFD, 0x1E, 
    0xC5, 0x06, 0xE7, 0xAA, 0x16, 0x58, 0x29, 0x88, 0xF2, 0x65, 
    0xB8, 0xE7, 0x89, 0x69, 0xB9, 0x1B, 0x55, 0xC7, 0x45, 0x28, 
    0x5B, 0xF9, 0x30, 0x72, 0xB3, 0xF7, 0x8D, 0x10, 0xE4, 0x71, 
    0x0C, 0x4F, 0xE2, 0x81, 0xC2, 0xEC, 0x91, 0x16, 0xDE, 0x71, 0x1D, 

    0x62, 0x8C, 0xF6, 0xCA, 0x33, 0xD9, 0x1E, 0x99, 0x7A, 0x55,         // 76
    0xC3, 0x4A, 0xEE, 0x69, 0xB5, 0x8D, 0x50, 0xFA, 0x5F, 0xDE, 
    0x4F, 0xAA, 0xE1, 0xB9, 0x12, 0xA8, 0xF8, 0x64, 0xD8, 0x24, 
    0x8B, 0x01, 0x68, 0x91, 0xCA, 0x07, 0xDE, 0xA0, 0x73, 0x59, 
    0x3D, 0x29, 0xB9, 0x0B, 0x5A, 0xC0, 0x3A, 0x8E, 0xBE, 0x76, 
    0x48, 0xD6, 0x67, 0x44, 0xD2, 0xFB, 0xA0, 0x0F, 0xAD, 0x2D, 
    0xD5, 0x26, 0xA5, 0x0D, 0xD3, 0x94, 0xFA, 0x05, 0x91, 0xDA, 
    0x77, 0x9A, 0x4B, 0xDE, 0x58, 0x18, 0xC4, 0x61, 0xB0, 0x3C, 
    0xFD, 0xBE, 0x23, 0xA0, 0x02, 0x5B, 0xAF, 0x41, 0x9C, 0x30, 0xD1, 

    0xA7, 0x25, 0x4A, 0x64, 0xA1, 0x81, 0x5F, 0xCE, 0x02, 0xF4,         // 77
    0x9C, 0x12, 0xCC, 0x38, 0xDF, 0x30, 0xCA, 0x03, 0x97, 0x26, 
    0x78, 0x08, 0x5D, 0x95, 0x35, 0x85, 0x4E, 0xBE, 0x41, 0xEC, 
    0xA8, 0xCD, 0x44, 0xE4, 0x72, 0x3C, 0x86, 0x20, 0xC9, 0xF5, 
    0x8D, 0xD5, 0x80, 0xDD, 0x77, 0xF3, 0x00, 0x6E, 0x2C, 0xE3, 
    0x87, 0xA5, 0x29, 0x94, 0x78, 0x34, 0x61, 0xE3, 0x3E, 0x7D, 
    0x97, 0x60, 0x3D, 0xEE, 0x4C, 0x71, 0x32, 0xAE, 0x66, 0x1B, 
    0xB2, 0x0B, 0xC3, 0x22, 0xA1, 0x85, 0x35, 0xEC, 0x1E, 0x95, 
    0x7B, 0x63, 0x3E, 0xE9, 0x74, 0xCC, 0x20, 0x6C, 0xFE, 0x85, 0x48, 

    0xEE, 0xC2, 0x97, 0xE2, 0x08, 0xFB, 0x2E, 0xB8, 0x41, 0x87,         // 78
    0x66, 0x32, 0x77, 0xA5, 0x0B, 0x61, 0x7E, 0xAA, 0x49, 0xED, 
    0xBB, 0x8E, 0xFD, 0x49, 0xC5, 0xE5, 0x05, 0x9B, 0x7C, 0x12, 
    0x60, 0x2F, 0x9E, 0x12, 0xB6, 0xFC, 0x5E, 0xBA, 0x44, 0x05, 
    0xAD, 0x5F, 0x13, 0x42, 0xA9, 0x4D, 0x99, 0xD9, 0xAD, 0x0E, 
    0x5C, 0x18, 0xF5, 0xB6, 0x05, 0xC9, 0x83, 0xBF, 0x54, 0xC9, 
    0x01, 0xE3, 0xAF, 0x7F, 0x17, 0xA3, 0xDF, 0x4A, 0xCB, 0xF3, 
    0x3F, 0xE6, 0x82, 0x68, 0xF3, 0x46, 0xCE, 0x7E, 0x52, 0xD0, 
    0x06, 0xA7, 0xD4, 0x8F, 0x2D, 0x4A, 0xDC, 0xB4, 0x07, 0xBD, 0x1A, 

    0x53, 0x83, 0x18, 0x42, 0xB4, 0x52, 0x95, 0x6D, 0xEA, 0x21,         // 79
    0xD6, 0xB1, 0xFE, 0x51, 0x96, 0xBC, 0xF2, 0x2A, 0xD1, 0x67, 
    0x3E, 0x2A, 0xCF, 0x16, 0x7B, 0x29, 0x68, 0xF0, 0x37, 0xB3, 
    0xDA, 0x78, 0xF2, 0x54, 0x31, 0x93, 0x0F, 0xDD, 0x9D, 0x75, 
    0x27, 0xC6, 0xFC, 0x96, 0x28, 0xCE, 0x1E, 0x5A, 0x37, 0xF1, 
    0x96, 0xC2, 0x39, 0x5E, 0xE5, 0x4E, 0x1B, 0xA8, 0x2B, 0xF7, 
    0x6D, 0x49, 0x20, 0xC8, 0x61, 0xC0, 0x0B, 0x83, 0x2A, 0x6E, 
    0x8D, 0x54, 0x2B, 0xD5, 0x1B, 0xB5, 0x08, 0xA2, 0x2F, 0xB6, 
    0xE8, 0x2A, 0x57, 0x0F, 0xF7, 0x9C, 0x81, 0x37, 0x62, 0xD8, 0x75, 

    0x0A, 0xDB, 0x6A, 0xCB, 0x7D, 0x1D, 0xDE, 0x0E, 0xA2, 0xC4,         // 80
    0x58, 0x07, 0x83, 0x1D, 0xE5, 0x3E, 0x12, 0x76, 0x91, 0x0C, 
    0xE6, 0x7D, 0xAB, 0x66, 0xA0, 0xDB, 0xB7, 0x20, 0xCE, 0x8C, 
    0x4C, 0x19, 0xC1, 0x85, 0xD5, 0xAD, 0x6C, 0x2B, 0x54, 0xEE, 
    0x86, 0x50, 0x34, 0x74, 0xBC, 0x68, 0xED, 0x89, 0xC9, 0x69, 
    0x43, 0xDF, 0x71, 0x8C, 0x25, 0x9E, 0xF0, 0x65, 0x91, 0x19, 
    0xA2, 0xD6, 0x89, 0xFE, 0x36, 0x8C, 0xF0, 0x5A, 0xA1, 0xC3, 
    0x00, 0xA8, 0xBF, 0x90, 0x4E, 0x71, 0xDF, 0x5D, 0xF6, 0x6C, 
    0x45, 0x86, 0xC8, 0x75, 0xB6, 0x5E, 0x14, 0xEF, 0x90, 0x28, 0xA0, 

    0xBB, 0x3B, 0xA4, 0x30, 0xF1, 0x62, 0xC6, 0x46, 0x80, 0x2C,         // 81
    0x97, 0xE3, 0x3A, 0xC6, 0x8B, 0x6D, 0xD7, 0xB7, 0x45, 0xA3, 
    0xC8, 0x51, 0x01, 0xF3, 0x31, 0x47, 0x95, 0x57, 0x70, 0x0F, 
    0xED, 0x98, 0x2C, 0x60, 0x15, 0x46, 0xE8, 0x8A, 0xCA, 0x15, 
    0xB7, 0xE5, 0xAE, 0x1B, 0xE0, 0x06, 0x49, 0xA3, 0x16, 0x7F, 
    0x03, 0xA4, 0x2F, 0xBA, 0xD3, 0x74, 0x0A, 0xD5, 0x39, 0xC5, 
    0x76, 0x0F, 0x59, 0x27, 0x9E, 0x4A, 0x23, 0xCF, 0x18, 0xE1, 
    0x3B, 0xFA, 0x60, 0x0F, 0xEC, 0x9F, 0x27, 0x8E, 0x0F, 0xAB, 
    0x1B, 0x9D, 0xE0, 0x33, 0x47, 0xE4, 0xC1, 0x4D, 0xAF, 0x41, 0xF7, 

    0x5D, 0x8B, 0xE9, 0x00, 0x89, 0xA0, 0x26, 0xB1, 0x67, 0xF8,         // 82
    0x48, 0x71, 0xA9, 0x5F, 0x29, 0xA7, 0x53, 0x2E, 0xFB, 0x6E, 
    0x1E, 0x8A, 0xBB, 0x5F, 0xD5, 0x80, 0x09, 0xF8, 0xA8, 0x3B, 
    0xBC, 0x52, 0xDC, 0xB1, 0xF4, 0x7B, 0x00, 0xB1, 0x33, 0x73, 
    0x3E, 0x0B, 0x8D, 0x5B, 0x9F, 0x7E, 0xC0, 0x34, 0xFC, 0xB6, 
    0xD6, 0x59, 0xF6, 0x0D, 0x54, 0x3B, 0xB7, 0x83, 0x57, 0xE9, 
    0x46, 0xBC, 0xE7, 0xAC, 0x6B, 0xE9, 0xB3, 0x88, 0x6C, 0x50, 
    0x96, 0x73, 0x33, 0xCD, 0x7A, 0x49, 0xC8, 0x3E, 0xBE, 0x7D, 
    0xED, 0x5A, 0x00, 0xAC, 0x8C, 0x2C, 0x71, 0x04, 0xE0, 0x76, 0x22, 

    0xE3, 0x1B, 0x4B, 0xB1, 0x57, 0x3A, 0xD1, 0xE5, 0x04, 0xAD,         // 83
    0x1E, 0xD5, 0x0E, 0xF6, 0xCB, 0x02, 0xEB, 0x95, 0x0F, 0xD4, 
    0x3D, 0xE9, 0x27, 0x90, 0x16, 0xC0, 0xDF, 0x35, 0x7F, 0xD8, 
    0x72, 0x04, 0x8B, 0x6A, 0x22, 0xA6, 0xD4, 0x58, 0xFA, 0xA2, 
    0xD5, 0x66, 0xBE, 0x43, 0xF7, 0x2C, 0xDD, 0x74, 0x54, 0x2A, 
    0x90, 0x21, 0x79, 0x9A, 0xDC, 0x91, 0xFC, 0x22, 0xAC, 0x05, 
    0x99, 0x31, 0x7A, 0x1B, 0xD6, 0x0A, 0x5F, 0x34, 0xF2, 0xB5, 
    0x14, 0xD9, 0xA0, 0x1F, 0xB9, 0x03, 0xFE, 0x73, 0xD8, 0x26, 
    0x48, 0xC0, 0x6B, 0xFC, 0x1B, 0xD1, 0xA5, 0x87, 0x54, 0xCB, 0x9C, 

    0x66, 0xBE, 0x75, 0xD4, 0xFD, 0x72, 0x14, 0x9A, 0x5C, 0x8A,         // 84
    0xC0, 0x7A, 0x4D, 0x8F, 0x3D, 0x82, 0x6B, 0xBB, 0x5D, 0x81, 
    0xA8, 0x56, 0xCD, 0xB0, 0x4B, 0x72, 0x27, 0xB3, 0x4F, 0x19, 
    0x9F, 0xFD, 0x38, 0xCC, 0x54, 0x8F, 0x2C, 0x78, 0x17, 0x48, 
    0x82, 0xF1, 0x22, 0xCC, 0x0F, 0x63, 0x9A, 0x18, 0xAF, 0xE3, 
    0x6B, 0xCC, 0x46, 0xBF, 0x1A, 0x5D, 0x31, 0x70, 0xD6, 0x7E, 
    0xF8, 0x63, 0xD0, 0x96, 0x40, 0x80, 0xCB, 0x9F, 0x06, 0xD4, 
    0x38, 0x7F, 0x44, 0xE3, 0x88, 0x67, 0xAC, 0x1A, 0x5E, 0xAF, 
    0x90, 0x2D, 0xD7, 0x9A, 0x61, 0x4A, 0xED, 0x27, 0xBB, 0x3E, 0x0C, 

    0xCF, 0x28, 0x98, 0x10, 0x30, 0xBF, 0x8C, 0x46, 0xF1, 0x2D,         // 85
    0x41, 0xE7, 0xA3, 0x22, 0xB6, 0xDE, 0x18, 0x36, 0xCA, 0x23, 
    0xF4, 0x0C, 0x77, 0x36, 0xFC, 0x9E, 0x5C, 0x8B, 0xEE, 0xC1, 
    0x2E, 0x58, 0xB8, 0x12, 0xEE, 0x3D, 0xBD, 0xEA, 0x94, 0xB6, 
    0x06, 0x54, 0xA1, 0x71, 0x89, 0xD6, 0x4A, 0xC5, 0x85, 0x3E, 
    0x0E, 0xA8, 0xEE, 0x34, 0x84, 0xE8, 0xC7, 0x9E, 0x15, 0x4C, 
    0x2A, 0xAF, 0x12, 0x56, 0xB6, 0xE5, 0x22, 0x4C, 0x74, 0x91, 
    0x5D, 0xF5, 0xB3, 0x5B, 0x2D, 0xE9, 0x3A, 0x8B, 0xDF, 0x0B, 
    0xF5, 0x78, 0x53, 0x0A, 0x7F, 0xC2, 0x10, 0x6D, 0x93, 0xFA, 0x81, 

    0x4F, 0xF2, 0x42, 0xAB, 0x81, 0x54, 0xE0, 0x1F, 0xB3, 0x77,         // 86
    0xCC, 0x15, 0x69, 0xF2, 0x60, 0x44, 0x9F, 0xE8, 0x8C, 0x4D, 
    0x9B, 0x64, 0xDC, 0x8A, 0x04, 0xC4, 0x1E, 0xD6, 0x08, 0x69, 
    0x8E, 0xE6, 0x7E, 0x9C, 0x6D, 0xDA, 0x08, 0x68, 0x25, 0xDF, 
    0xC6, 0x2F, 0xE6, 0x3C, 0xB7, 0x2E, 0xEB, 0x0B, 0x5D, 0xF1, 
    0x97, 0x52, 0x15, 0x66, 0xAE, 0x00, 0x49, 0x68, 0xF0, 0xC3, 
    0x94, 0xDB, 0x39, 0xF5, 0x6C, 0x33, 0xAD, 0xFC, 0xC4, 0x21, 
    0xA7, 0x31, 0x0D, 0x97, 0xCE, 0x14, 0x9D, 0x4E, 0xC2, 0x42, 
    0xA6, 0x1E, 0xCB, 0xB1, 0xF2, 0x3F, 0xA0, 0xE4, 0x36, 0x1A, 0xAE, 

    0x09, 0x8F, 0x6B, 0xEA, 0xCA, 0x06, 0xA6, 0x6A, 0xD7, 0x09,         // 87
    0x9B, 0x54, 0xBC, 0x87, 0x08, 0xC4, 0x78, 0x59, 0x05, 0xD0, 
    0x2F, 0xBB, 0x1E, 0xAB, 0x5F, 0xE4, 0x4A, 0x7B, 0xA6, 0x45, 
    0xD2, 0x0C, 0x4A, 0x2C, 0xAD, 0x51, 0x89, 0xA8, 0x40, 0x5A, 
    0x77, 0x97, 0x64, 0xCE, 0x01, 0x99, 0x6A, 0xAD, 0xD0, 0x36, 
    0xBD, 0x7A, 0xCE, 0x95, 0xDD, 0x7B, 0xB3, 0x21, 0x8A, 0x5B, 
    0x08, 0x6F, 0x83, 0xC1, 0x03, 0x9E, 0x76, 0x10, 0x56, 0xE0, 
    0x6B, 0xC2, 0xE4, 0x6E, 0x47, 0xBE, 0x75, 0xEE, 0x21, 0x6E, 
    0x89, 0xE9, 0x45, 0x2A, 0x8F, 0x1C, 0x61, 0xC8, 0x56, 0xD7, 0x6F, 

    0xE5, 0xC0, 0x35, 0x1A, 0x62, 0x3E, 0xF6, 0x2A, 0x8B, 0x5D,         // 88
    0xFC, 0x2A, 0xDD, 0x3A, 0xA4, 0xD8, 0x2E, 0xFD, 0xB3, 0x6C, 
    0xE7, 0x85, 0x4B, 0xEC, 0x2B, 0x85, 0xB6, 0x30, 0xF9, 0x23, 
    0xB2, 0x6F, 0xCB, 0xF8, 0x14, 0xC2, 0x31, 0xCC, 0xF9, 0xA2, 
    0x11, 0xF0, 0x1B, 0x87, 0x5C, 0xFB, 0x41, 0x81, 0x27, 0x6E, 
    0x04, 0xFE, 0x26, 0x58, 0x3B, 0x28, 0xEC, 0xD1, 0x42, 0xAE, 
    0xE7, 0x47, 0xA2, 0x2A, 0xDD, 0x58, 0xCF, 0x8B, 0x35, 0x9C, 
    0x01, 0x42, 0x81, 0x17, 0xFA, 0xA3, 0x07, 0x5A, 0xB1, 0xCA, 
    0x03, 0x5E, 0x9C, 0x6C, 0xE3, 0x79, 0xB2, 0x02, 0x83, 0x9C, 0x2D, 

    0x79, 0x55, 0x9F, 0xDF, 0xB6, 0x7C, 0x98, 0x52, 0xC1, 0x36,         // 89
    0xB6, 0x8F, 0x11, 0x7A, 0x55, 0x19, 0x91, 0x4A, 0x1F, 0x9E, 
    0x3D, 0x0A, 0xC6, 0x71, 0xA4, 0x0E, 0xD1, 0x69, 0x96, 0x59, 
    0xE2, 0x32, 0x93, 0x5F, 0x83, 0xEA, 0x6C, 0x0C, 0x7C, 0x2C, 
    0xC2, 0x4A, 0xAB, 0xDD, 0x28, 0xC3, 0x12, 0xE3, 0x9E, 0xDA, 
    0x8C, 0x43, 0xA9, 0xE9, 0xC2, 0x6C, 0x92, 0x0D, 0x78, 0x2C, 
    0xCD, 0x1A, 0xEE, 0x5F, 0x87, 0x3F, 0x1A, 0xE8, 0xC0, 0x7C, 
    0xF7, 0xAF, 0xD7, 0x5A, 0x8C, 0x3D, 0xDA, 0x86, 0x28, 0xFC, 
    0x3A, 0xDA, 0xBD, 0x0E, 0xCF, 0x49, 0xFE, 0x34, 0xE0, 0x47, 0xB2, 

    0x24, 0xD1, 0x03, 0x87, 0x25, 0xD4, 0x0B, 0xEC, 0x1A, 0xD9,         // 90
    0x6E, 0x46, 0xCB, 0xF0, 0xB0, 0xE1, 0x67, 0xC5, 0x7E, 0xD6, 
    0x59, 0xF9, 0x97, 0x34, 0x56, 0xF2, 0x42, 0x1B, 0xC1, 0x09, 
    0x87, 0xA7, 0x10, 0xBF, 0x21, 0x4C, 0xAB, 0xE0, 0x58, 0x91, 
    0xD9, 0x82, 0x30, 0x54, 0xB2, 0x70, 0x90, 0x61, 0x1C, 0x4C, 
    0xB8, 0x68, 0x18, 0x80, 0x07, 0xA7, 0x50, 0xBE, 0xFC, 0x9A, 
    0x55, 0x8A, 0xAD, 0x0B, 0xB8, 0xF9, 0xA5, 0x6C, 0x4B, 0x26, 
    0x5D, 0x1C, 0x9E, 0x2C, 0xCB, 0x1C, 0x66, 0xA8, 0x47, 0x91, 
    0xAE, 0x7F, 0x54, 0x36, 0xA1, 0x20, 0x96, 0x70, 0xBD, 0x1A, 0xF6, 
};

const BYTE HT_SuperCell_GreenMono[91*91] = {
    0x59, 0x31, 0xD4, 0x47, 0x1D, 0x89, 0x68, 0xB8, 0x58, 0xF1,         //  0
    0x10, 0x83, 0x25, 0xF7, 0x1B, 0xC4, 0xE3, 0x63, 0x4B, 0x00, 
    0xA6, 0x56, 0x9A, 0x19, 0x69, 0xB1, 0x55, 0x81, 0x3D, 0x9A, 
    0x72, 0xE3, 0x7C, 0xC6, 0x87, 0x63, 0xB9, 0xED, 0x43, 0x77, 
    0xF6, 0x69, 0x4A, 0x2D, 0xF9, 0x07, 0xD9, 0x7B, 0x99, 0x3B, 
    0x5D, 0x15, 0xEE, 0x59, 0x93, 0x25, 0xC9, 0xEC, 0x0E, 0x4D, 
    0x21, 0xDD, 0x6D, 0x0A, 0xE8, 0x24, 0xD0, 0xB8, 0x59, 0x86, 
    0x26, 0xEC, 0x1E, 0x49, 0x82, 0x18, 0x95, 0x7B, 0x2B, 0xAF, 
    0x85, 0xC8, 0x65, 0xFA, 0x10, 0xA3, 0x36, 0xEE, 0x65, 0xD6, 0x01, 

    0xCC, 0x81, 0x10, 0x9A, 0xC5, 0xDB, 0x43, 0x22, 0xC7, 0x46,         //  1
    0xD8, 0x67, 0xD1, 0xA8, 0x6C, 0x45, 0x11, 0x96, 0xCF, 0xFB, 
    0x1F, 0xE0, 0x80, 0x3C, 0xC3, 0xDE, 0x2C, 0xD2, 0x10, 0xDA, 
    0x2A, 0x5A, 0x23, 0xA7, 0x14, 0xD5, 0x4B, 0x82, 0x0B, 0xD8, 
    0x1B, 0xA6, 0x8D, 0xB4, 0x70, 0x92, 0x39, 0x21, 0xBD, 0xDC, 
    0x90, 0x78, 0xB8, 0x0C, 0xD6, 0x3C, 0x7B, 0x56, 0xA6, 0xBD, 
    0x77, 0x95, 0x48, 0xB7, 0x82, 0x9D, 0x73, 0x01, 0x3D, 0xCB, 
    0xA2, 0x41, 0x93, 0xC1, 0xFA, 0x5C, 0xD7, 0xC3, 0x64, 0xDA, 
    0x39, 0x01, 0xB6, 0x54, 0x81, 0xD2, 0x1B, 0xBC, 0x92, 0x2A, 0xB2, 

    0x48, 0xA6, 0xF2, 0x5D, 0x79, 0x03, 0x9F, 0xE8, 0x8E, 0x76,         //  2
    0x2C, 0x9F, 0x4D, 0x31, 0xD8, 0x8A, 0xEF, 0x74, 0x37, 0xAB, 
    0x6A, 0xCC, 0x25, 0xF2, 0x53, 0x03, 0x71, 0x95, 0xB7, 0x4B, 
    0xC3, 0x9D, 0xF9, 0x3D, 0xE6, 0x9C, 0x20, 0xAE, 0x59, 0xB1, 
    0xC4, 0x41, 0x24, 0xE5, 0x17, 0xD1, 0x64, 0xF4, 0x51, 0x03, 
    0x30, 0xE6, 0x3F, 0x6A, 0xF4, 0xB2, 0x15, 0x97, 0x32, 0xE8, 
    0x04, 0xC5, 0x2B, 0xFA, 0x14, 0x44, 0xED, 0xA8, 0x8E, 0xF8, 
    0x0E, 0x6A, 0xE5, 0x04, 0x30, 0xB3, 0x3E, 0x0F, 0xA5, 0x50, 
    0xF4, 0x73, 0x9C, 0x22, 0xE5, 0x4C, 0x9E, 0x71, 0x41, 0xFC, 0x6E, 

    0xD8, 0x22, 0x38, 0xBD, 0x40, 0xF8, 0x54, 0x6E, 0x11, 0xAD,         //  3
    0xF6, 0x03, 0xC1, 0x7A, 0x0C, 0xA4, 0x3E, 0xBC, 0x17, 0x88, 
    0x2F, 0x50, 0xB4, 0x75, 0x98, 0xAF, 0xFD, 0x37, 0x63, 0xF0, 
    0x81, 0x06, 0x70, 0x54, 0x85, 0x34, 0x6E, 0xFD, 0x8D, 0x2E, 
    0x67, 0xF2, 0x7B, 0x56, 0xBF, 0x45, 0xAA, 0x81, 0xA2, 0x74, 
    0xB0, 0xCC, 0x96, 0x23, 0x82, 0x4B, 0xD0, 0xFE, 0x63, 0x89, 
    0x51, 0xD9, 0x60, 0xA5, 0x6E, 0xBF, 0x28, 0x63, 0x1A, 0x4E, 
    0xB9, 0x84, 0x55, 0xA6, 0x71, 0x8E, 0xEF, 0x73, 0x28, 0x90, 
    0x16, 0xCC, 0x40, 0xBE, 0x6C, 0x28, 0xEB, 0x09, 0xC3, 0x89, 0x12, 

    0x58, 0x75, 0xE4, 0x85, 0x1E, 0xCD, 0xB1, 0x27, 0xE1, 0x40,         //  4
    0x5E, 0x95, 0xE4, 0x54, 0xFE, 0x26, 0x68, 0xDC, 0x55, 0xEA, 
    0xC3, 0x95, 0x08, 0xD5, 0x21, 0x47, 0x84, 0x17, 0xA6, 0x23, 
    0x42, 0xAB, 0xD8, 0xC6, 0x0D, 0xB5, 0xD0, 0x11, 0x4A, 0xDC, 
    0x0C, 0xA4, 0xD0, 0x00, 0x9D, 0x28, 0xE3, 0x10, 0x41, 0xEB, 
    0x58, 0x14, 0x49, 0xAF, 0xA2, 0x00, 0x6C, 0x29, 0xB9, 0x14, 
    0xA8, 0x25, 0x8B, 0x35, 0xE3, 0x4E, 0xD4, 0xB0, 0xE2, 0x77, 
    0xD9, 0x29, 0xD3, 0x44, 0xE2, 0x16, 0x53, 0xD2, 0xB6, 0xE7, 
    0x5A, 0x7B, 0xE0, 0x0E, 0x8F, 0xCA, 0x85, 0x56, 0xDF, 0x36, 0xA0, 

    0xF5, 0x98, 0x0B, 0xAF, 0x68, 0x90, 0x38, 0x85, 0xBA, 0xCE,         //  5
    0x7D, 0x1D, 0x42, 0x86, 0xB0, 0xCA, 0x8C, 0x04, 0xA3, 0x6E, 
    0x14, 0xF8, 0x68, 0x38, 0xEC, 0x62, 0xC6, 0xE5, 0x6D, 0xC1, 
    0xDE, 0x59, 0x1E, 0x90, 0x48, 0xE9, 0x5E, 0x9F, 0xC5, 0x75, 
    0x91, 0x39, 0x5E, 0x89, 0xFC, 0x7A, 0x58, 0xBB, 0xD5, 0x1D, 
    0x85, 0xFA, 0x73, 0xDE, 0x57, 0xE7, 0xC2, 0x94, 0x43, 0xDF, 
    0x71, 0xF3, 0xB8, 0x07, 0x7C, 0x99, 0x0C, 0x88, 0x2C, 0x3F, 
    0x9A, 0x12, 0xB3, 0x88, 0x25, 0xC5, 0x9C, 0x0B, 0x7E, 0x3B, 
    0xC1, 0x2E, 0x95, 0x53, 0xF1, 0x61, 0x30, 0xA5, 0x1C, 0x79, 0xBA, 

    0x50, 0x31, 0xD4, 0x47, 0xDE, 0x0E, 0xED, 0x5D, 0x06, 0x2F,         //  6
    0xA3, 0xDD, 0xBC, 0x14, 0x64, 0x38, 0xEB, 0x49, 0xCF, 0x37, 
    0x83, 0x45, 0xA7, 0x88, 0xB9, 0x0C, 0x9B, 0x45, 0x04, 0x90, 
    0x35, 0x7A, 0xF3, 0x68, 0xA3, 0x37, 0x81, 0x23, 0x40, 0xF0, 
    0x1D, 0xE6, 0xBC, 0x49, 0x1B, 0xC4, 0x31, 0x92, 0x6C, 0x33, 
    0xB8, 0x9B, 0x0A, 0x42, 0x8B, 0x31, 0x78, 0x11, 0xCA, 0x81, 
    0x1B, 0x3B, 0x62, 0xEB, 0xC3, 0x39, 0x6D, 0xFD, 0x60, 0xC9, 
    0xED, 0x6F, 0x3A, 0xFB, 0x60, 0x7C, 0x33, 0xF6, 0x62, 0x9E, 
    0x07, 0xFB, 0xAE, 0x24, 0xB2, 0x05, 0xC0, 0xF9, 0x66, 0xCF, 0x07, 

    0xA8, 0x6B, 0x89, 0x21, 0xA2, 0x4F, 0xC5, 0x9E, 0x70, 0xFA,         //  7
    0x4A, 0x69, 0x32, 0xF2, 0xA6, 0x0E, 0x74, 0x98, 0x1D, 0xB1, 
    0xE3, 0xC1, 0x27, 0x56, 0xDD, 0x76, 0x2A, 0xD3, 0x7C, 0xF9, 
    0xA5, 0x13, 0xB8, 0x29, 0xC9, 0x01, 0xF6, 0xB9, 0x94, 0x5F, 
    0xAB, 0x71, 0x2E, 0xDE, 0xA8, 0x6A, 0xEE, 0x0B, 0xA5, 0xE5, 
    0x62, 0x2B, 0xBF, 0xD7, 0x19, 0xF8, 0xA4, 0x60, 0xEA, 0x4E, 
    0x9B, 0xD2, 0xA6, 0x43, 0x16, 0xD9, 0xAB, 0x24, 0xBA, 0x0E, 
    0x8C, 0x55, 0xC0, 0x00, 0xA8, 0xDF, 0x51, 0xB2, 0x20, 0xDC, 
    0x6A, 0x85, 0x45, 0x74, 0xD5, 0x47, 0x82, 0x3A, 0x9B, 0x4A, 0xDE, 

    0x18, 0xEE, 0xB7, 0x5E, 0xFD, 0x75, 0x16, 0x3C, 0xD2, 0x89,         //  8
    0x1A, 0xC5, 0x94, 0x7A, 0x4E, 0xC4, 0xD9, 0x59, 0xF6, 0x69, 
    0x07, 0x7B, 0xD4, 0x15, 0xAA, 0x4A, 0xF1, 0xB3, 0x56, 0x20, 
    0x49, 0xCE, 0x85, 0x5A, 0xDF, 0x74, 0x4F, 0xD5, 0x10, 0x32, 
    0xCA, 0x05, 0x98, 0x7E, 0x11, 0x3C, 0xD0, 0x7B, 0x41, 0xC9, 
    0x4D, 0xEB, 0x6F, 0x99, 0x64, 0xBB, 0x48, 0x26, 0xB2, 0x0B, 
    0xFB, 0x2D, 0x73, 0x8A, 0x5D, 0x9C, 0x51, 0xE8, 0x48, 0x72, 
    0xA9, 0x1E, 0xD4, 0x90, 0x40, 0x1A, 0xCB, 0x83, 0x48, 0xBC, 
    0x2A, 0xC6, 0x17, 0xED, 0x9F, 0x6B, 0xE3, 0x14, 0xAF, 0x28, 0x7D, 

    0x94, 0x41, 0x05, 0xCB, 0x2A, 0x8A, 0xB5, 0xE9, 0x29, 0xAE,         //  9
    0x57, 0xEB, 0x00, 0xDB, 0x28, 0x88, 0x20, 0xB5, 0x3E, 0x95, 
    0x31, 0xA5, 0x65, 0xFA, 0x35, 0x94, 0x6A, 0x0F, 0x98, 0xC5, 
    0x6A, 0xE9, 0x0A, 0x42, 0xAD, 0x91, 0x1A, 0xA5, 0x6B, 0x84, 
    0xFB, 0x53, 0xD4, 0x5E, 0xF6, 0x8F, 0x55, 0xBB, 0x25, 0x90, 
    0x07, 0x7F, 0x22, 0x3B, 0xCE, 0x06, 0x8D, 0xD9, 0x6E, 0x88, 
    0x5A, 0xC0, 0x05, 0xB3, 0xF7, 0x2F, 0x83, 0x02, 0x95, 0xE1, 
    0x32, 0xF3, 0x48, 0x78, 0xF0, 0x6C, 0x9D, 0x05, 0xEE, 0xA2, 
    0x5C, 0xE3, 0x97, 0x58, 0x34, 0x1F, 0xC8, 0x8E, 0x5F, 0xF5, 0xC4, 

    0x57, 0xDF, 0x73, 0x97, 0x53, 0xDB, 0x44, 0x6E, 0x95, 0x0D,         // 10
    0x77, 0xB3, 0x3C, 0x6C, 0xBC, 0xFB, 0x4A, 0x7A, 0x15, 0xD0, 
    0xED, 0x53, 0x0F, 0x8C, 0xC0, 0x18, 0xCE, 0x3B, 0xE5, 0x83, 
    0x2E, 0xA9, 0x95, 0xFE, 0x21, 0x62, 0xEB, 0x45, 0xDA, 0xBA, 
    0x3C, 0x9E, 0x1C, 0xBF, 0x2B, 0xB0, 0x03, 0xDA, 0x5F, 0xFD, 
    0xA6, 0xD9, 0xB4, 0xF5, 0x55, 0x77, 0xF0, 0x38, 0xC9, 0x22, 
    0xE2, 0x92, 0x4C, 0xDE, 0x1C, 0xC8, 0x69, 0xB6, 0xCE, 0x16, 
    0x85, 0x60, 0xA3, 0x12, 0xBA, 0x2B, 0xDC, 0x3C, 0x77, 0x13, 
    0x88, 0x3E, 0x03, 0xCD, 0xB7, 0x86, 0x50, 0xEA, 0x00, 0x75, 0x36, 

    0xA4, 0xC0, 0x33, 0xED, 0x1D, 0xAA, 0x03, 0xC6, 0x4E, 0xF4,         // 11
    0xD7, 0x1E, 0x8B, 0xA4, 0x5B, 0x09, 0x9F, 0xE7, 0xC0, 0x87, 
    0x42, 0xB1, 0xE0, 0x73, 0x4F, 0xED, 0x7F, 0xA4, 0x52, 0x16, 
    0xDC, 0x4D, 0x27, 0x6C, 0xB5, 0xCD, 0x2D, 0x8B, 0x08, 0x63, 
    0x28, 0x7A, 0xEC, 0x4B, 0x73, 0xE5, 0x3F, 0xA0, 0x7D, 0x19, 
    0x3D, 0x67, 0x16, 0x84, 0x2C, 0xA9, 0x19, 0x9A, 0x63, 0xAF, 
    0x42, 0x18, 0xD0, 0x63, 0x9E, 0x49, 0xEE, 0x28, 0x5B, 0x42, 
    0xB1, 0xC8, 0x35, 0xE8, 0x53, 0x8C, 0x61, 0xB6, 0xD6, 0x51, 
    0xF3, 0xAD, 0x6C, 0x7F, 0xFE, 0x0D, 0xA3, 0x2F, 0xB3, 0xCF, 0x1D, 

    0x66, 0x86, 0x14, 0xB7, 0x66, 0x83, 0xF8, 0x32, 0xA7, 0x69,         // 12
    0x41, 0xC1, 0x54, 0xEF, 0x35, 0xD2, 0x71, 0x31, 0x57, 0x02, 
    0x79, 0x22, 0xCC, 0x39, 0xA7, 0x24, 0x5A, 0x00, 0xFA, 0xB5, 
    0x67, 0xC2, 0x7C, 0xD5, 0x04, 0x4F, 0x7A, 0xC1, 0xF4, 0x96, 
    0xE1, 0xB2, 0x07, 0xA7, 0x87, 0x20, 0x6A, 0xEF, 0x4B, 0xC6, 
    0x8A, 0xD2, 0x4F, 0x9D, 0xE2, 0xC5, 0x5A, 0xD7, 0x02, 0x7F, 
    0xF6, 0xA9, 0x8B, 0x32, 0x76, 0x09, 0xAC, 0x8E, 0xDD, 0x75, 
    0xFA, 0x08, 0x6D, 0x98, 0xCD, 0x0C, 0xFC, 0x19, 0x94, 0x2C, 
    0xC8, 0x1C, 0xDA, 0x27, 0x40, 0x63, 0xD9, 0x7A, 0x42, 0x90, 0xE3, 

    0x3D, 0xFA, 0x49, 0xD3, 0x9A, 0x2C, 0x5D, 0xD4, 0x81, 0x18,         // 13
    0x99, 0x2C, 0xD4, 0x10, 0x81, 0xB9, 0x17, 0x91, 0xAD, 0xF3, 
    0xC6, 0x9A, 0x65, 0x08, 0xE5, 0x8E, 0xD7, 0xC2, 0x78, 0x3B, 
    0x9C, 0x1B, 0xF3, 0x3E, 0x92, 0xEF, 0xAC, 0x16, 0x40, 0x57, 
    0x1F, 0xCE, 0x63, 0x3D, 0xD8, 0xC0, 0x94, 0x0E, 0xB1, 0x2C, 
    0xEA, 0x01, 0xBB, 0x72, 0x0C, 0x45, 0x87, 0x31, 0xEA, 0x4F, 
    0x27, 0x71, 0x0E, 0xF1, 0xB0, 0xDB, 0x7C, 0x15, 0x37, 0x9C, 
    0x29, 0x8A, 0xDD, 0x22, 0x41, 0x79, 0xA3, 0x4C, 0x71, 0xAB, 
    0x65, 0x8F, 0x52, 0x9F, 0xE7, 0x91, 0xBA, 0x18, 0xF7, 0x56, 0x09, 

    0xC8, 0xAA, 0x75, 0x07, 0x54, 0xE4, 0xAE, 0x0E, 0x49, 0xB1,         // 14
    0xE5, 0x7C, 0x65, 0xAF, 0x49, 0xEB, 0x62, 0xDA, 0x40, 0x6E, 
    0x2D, 0x4E, 0xFE, 0x82, 0xBC, 0x41, 0x64, 0x2C, 0x91, 0x12, 
    0xE9, 0x49, 0x88, 0xB2, 0x1F, 0x5A, 0x33, 0x6E, 0xD4, 0xA7, 
    0x78, 0x36, 0x8C, 0xF1, 0x12, 0x54, 0x34, 0xCB, 0x59, 0x92, 
    0x66, 0x40, 0xF8, 0x24, 0xA6, 0xF2, 0x6C, 0xC2, 0xA7, 0x91, 
    0xC8, 0xDC, 0x5F, 0xBF, 0x3A, 0x23, 0x5D, 0xF4, 0xC0, 0x61, 
    0xCC, 0x48, 0xAC, 0x60, 0xBD, 0xDF, 0x30, 0xC5, 0xEB, 0x05, 
    0x41, 0xF7, 0x0E, 0xBC, 0x59, 0x12, 0x37, 0x6B, 0xC4, 0xA6, 0x7E, 

    0x19, 0x36, 0x91, 0xEA, 0xBB, 0x1F, 0x6D, 0x90, 0xF2, 0xCB,         // 15
    0x44, 0x06, 0xFD, 0x93, 0x1D, 0xA0, 0x29, 0xBC, 0x0C, 0x8E, 
    0xD2, 0x13, 0xA1, 0x2F, 0x6D, 0x17, 0xF5, 0xAA, 0x4F, 0xD0, 
    0x5E, 0xC8, 0x0C, 0x65, 0xE1, 0xBF, 0x9A, 0xE9, 0x86, 0x00, 
    0xFC, 0xBB, 0x17, 0x9C, 0x6E, 0xAA, 0xFA, 0x75, 0xE6, 0x16, 
    0xC0, 0x7D, 0x99, 0x5B, 0xD1, 0x3C, 0x9A, 0x0E, 0x2B, 0x64, 
    0x3B, 0x1A, 0x99, 0x4E, 0x86, 0xC9, 0x98, 0x46, 0xA4, 0x04, 
    0xE6, 0x1F, 0x83, 0xF2, 0x02, 0x8E, 0x64, 0x1E, 0x85, 0xDB, 
    0xB2, 0x80, 0xD2, 0x2D, 0x75, 0xC7, 0xF0, 0x8A, 0x4A, 0x24, 0xEC, 

    0x61, 0xDC, 0x69, 0x27, 0x4C, 0x96, 0xDD, 0x36, 0x5A, 0x15,         // 16
    0x86, 0xBE, 0x56, 0x36, 0xDC, 0x77, 0x4F, 0xF9, 0xA4, 0x5A, 
    0xEC, 0xB8, 0x5D, 0xCE, 0xE0, 0x9F, 0x7F, 0x08, 0xE7, 0xB3, 
    0x23, 0x7F, 0xA2, 0xCF, 0x2D, 0x72, 0x0B, 0x48, 0x2C, 0xC7, 
    0x4C, 0x68, 0xE2, 0x43, 0xD5, 0x2A, 0x8D, 0x0A, 0x46, 0xAC, 
    0xDF, 0x2A, 0xC5, 0x34, 0x7E, 0x1A, 0xE3, 0x53, 0xD2, 0xFE, 
    0x80, 0xAD, 0xE8, 0x00, 0xFA, 0x65, 0x12, 0xE5, 0x31, 0x8C, 
    0x6F, 0xB3, 0x54, 0x2E, 0xA7, 0x49, 0xF5, 0xAE, 0x47, 0x6A, 
    0x22, 0x3A, 0x60, 0xA5, 0xDE, 0x43, 0x9F, 0x08, 0xE2, 0x73, 0x9B, 

    0xB7, 0x0C, 0xC9, 0xA0, 0xF6, 0x76, 0x01, 0xC5, 0xA5, 0x71,         // 17
    0xAE, 0x22, 0xCF, 0x6D, 0xB5, 0x01, 0xC9, 0x83, 0x35, 0x19, 
    0x79, 0x3E, 0x89, 0x04, 0x4F, 0x27, 0xC9, 0x66, 0x37, 0x97, 
    0x6C, 0xF5, 0x39, 0x5C, 0x91, 0xF9, 0xAC, 0xD1, 0x61, 0xA1, 
    0x8B, 0x22, 0xB0, 0x7B, 0x04, 0xBE, 0x5C, 0xDB, 0x9C, 0x23, 
    0x52, 0x72, 0x08, 0xE9, 0xAE, 0x63, 0xBD, 0x8E, 0x72, 0x12, 
    0xBD, 0x45, 0x29, 0x78, 0xB5, 0x2F, 0xD5, 0x74, 0xBC, 0x56, 
    0xFE, 0x12, 0xDB, 0xBF, 0x70, 0x16, 0xD0, 0x94, 0x0D, 0xBD, 
    0xCF, 0x9A, 0xEF, 0x03, 0x85, 0x21, 0x5F, 0xB4, 0x2F, 0xCC, 0x43, 

    0xFD, 0x4E, 0x7F, 0x39, 0x15, 0xCC, 0x46, 0x8B, 0x25, 0xF5,         // 18
    0x34, 0xE1, 0x89, 0x14, 0xF0, 0x94, 0x3E, 0x65, 0xD0, 0xE4, 
    0xAD, 0x26, 0xE8, 0xC1, 0x79, 0xF1, 0x3D, 0x8D, 0xD3, 0x10, 
    0x48, 0xAD, 0x02, 0xE4, 0x18, 0x4F, 0x27, 0x7B, 0xF2, 0x0F, 
    0xE6, 0x40, 0xCD, 0x57, 0xEE, 0x85, 0x38, 0xC4, 0x64, 0x84, 
    0xFC, 0xA0, 0xD6, 0x86, 0x47, 0xF7, 0x03, 0x3A, 0xA6, 0x4F, 
    0xE1, 0x63, 0x92, 0xD9, 0x54, 0x8C, 0xA7, 0x4A, 0x0B, 0xCC, 
    0x2B, 0x9F, 0x78, 0x3B, 0xEE, 0x87, 0x56, 0x34, 0x77, 0xFD, 
    0x51, 0x18, 0x6E, 0x4E, 0xC3, 0xFA, 0x79, 0xD3, 0x59, 0x8F, 0x22, 

    0x6F, 0x97, 0xE6, 0xBF, 0x60, 0xAA, 0xEC, 0x68, 0xD3, 0x53,         // 19
    0x94, 0x67, 0x3D, 0xA4, 0x51, 0x26, 0xE9, 0xA0, 0x0A, 0x50, 
    0x92, 0x67, 0xB2, 0x1A, 0x99, 0x5B, 0xAF, 0x1A, 0xF8, 0xBE, 
    0x89, 0xDB, 0x72, 0xBD, 0x7E, 0xC8, 0x96, 0x57, 0xB6, 0x3A, 
    0x71, 0xA8, 0x12, 0x94, 0x2E, 0xA9, 0x17, 0xF4, 0x3E, 0xBA, 
    0x1B, 0x3B, 0x5B, 0x15, 0xA8, 0x2B, 0x79, 0xC3, 0xF1, 0x1E, 
    0x9C, 0x09, 0xC0, 0x38, 0x11, 0xEE, 0x25, 0x83, 0xE8, 0x94, 
    0x67, 0x45, 0xCF, 0x0D, 0xA1, 0x23, 0xB4, 0xE7, 0x9E, 0x27, 
    0xAB, 0x8D, 0xDE, 0xB3, 0x29, 0x93, 0x0F, 0x3C, 0xF0, 0x01, 0xAB, 

    0x29, 0x46, 0x09, 0x71, 0x20, 0x88, 0x34, 0x0B, 0xB5, 0x1B,         // 20
    0xC2, 0x04, 0xF8, 0xCD, 0x69, 0x87, 0xB7, 0x31, 0x75, 0xC5, 
    0x1C, 0xF4, 0x4E, 0x36, 0xE2, 0x0A, 0xA6, 0x70, 0x50, 0x29, 
    0x60, 0x1D, 0x40, 0xA0, 0x35, 0xEF, 0x07, 0xDD, 0x22, 0x94, 
    0xDA, 0x50, 0xF9, 0x6F, 0xDA, 0x53, 0x73, 0x91, 0x0B, 0xDC, 
    0x70, 0xCC, 0xB4, 0x76, 0xDF, 0x93, 0xD3, 0x55, 0x32, 0x7B, 
    0xCA, 0x70, 0xF8, 0xAC, 0x6E, 0xCB, 0x61, 0xB8, 0x3D, 0x18, 
    0xB4, 0xF4, 0x8F, 0x55, 0xC6, 0x66, 0xD5, 0x04, 0x69, 0x41, 
    0xD2, 0x76, 0x0D, 0x3A, 0x81, 0xE6, 0xA4, 0x6E, 0xBB, 0x81, 0xD0, 

    0xF2, 0xB1, 0xD9, 0x9B, 0xF8, 0x52, 0xD7, 0x9D, 0x75, 0xE9,         // 21
    0x4B, 0x9E, 0x77, 0x1D, 0xBE, 0x08, 0xDA, 0x54, 0xFB, 0xA4, 
    0x3A, 0x82, 0xD3, 0x90, 0x6C, 0xC8, 0x45, 0x88, 0xB6, 0xE5, 
    0x9B, 0xCA, 0xFB, 0x58, 0x1F, 0x6A, 0xAA, 0x49, 0x75, 0xBE, 
    0x03, 0x86, 0x2B, 0xC1, 0x1B, 0xB6, 0xE9, 0x4D, 0xA8, 0x5C, 
    0x99, 0x01, 0xF3, 0x28, 0x3F, 0x68, 0x19, 0xAB, 0x8D, 0xEA, 
    0x2B, 0x52, 0x20, 0x84, 0x47, 0x9A, 0x05, 0xF9, 0x59, 0xDA, 
    0x7C, 0x01, 0x38, 0xE6, 0x79, 0x2A, 0x46, 0x83, 0xBD, 0xF0, 
    0x21, 0x48, 0xED, 0xC7, 0x69, 0x4C, 0x1B, 0xD8, 0x25, 0x44, 0x62, 

    0x10, 0x7D, 0x2F, 0x5B, 0xC3, 0x29, 0xB2, 0x3D, 0x5B, 0x89,         // 22
    0xD7, 0x28, 0xB3, 0x4E, 0xE7, 0x45, 0x79, 0x22, 0x8E, 0x11, 
    0xCC, 0x63, 0x02, 0xAF, 0x22, 0xFD, 0x2D, 0xDB, 0x0C, 0x39, 
    0x6B, 0x06, 0x83, 0xB7, 0xD7, 0x93, 0x39, 0xCC, 0xFE, 0x5A, 
    0x38, 0xCC, 0xA3, 0x5E, 0x3C, 0x80, 0x13, 0xCF, 0x26, 0xEE, 
    0x30, 0x85, 0x52, 0x9D, 0xBD, 0xFC, 0x4B, 0xE2, 0x0D, 0x61, 
    0xB8, 0xD8, 0x9D, 0xEA, 0x17, 0xE1, 0x39, 0x77, 0xA3, 0x2A, 
    0xC6, 0x61, 0xA5, 0x1F, 0xAD, 0xF3, 0x9D, 0xE0, 0x14, 0x59, 
    0x94, 0xB9, 0x60, 0x9F, 0x12, 0xCE, 0xB0, 0x56, 0x94, 0xDD, 0xA1, 

    0xC9, 0x51, 0xD3, 0x8F, 0x05, 0x79, 0xE0, 0x0F, 0xFD, 0x1F,         // 23
    0x42, 0x6E, 0xD1, 0x8A, 0x2C, 0x9B, 0xAE, 0xC7, 0x5D, 0xDF, 
    0x46, 0x9B, 0xF1, 0x43, 0x81, 0x5A, 0xA0, 0x75, 0xC7, 0x8D, 
    0xED, 0xA5, 0x46, 0x14, 0x77, 0xEA, 0x0E, 0x85, 0x19, 0xAE, 
    0xE9, 0x69, 0x18, 0xF2, 0x96, 0xC4, 0x43, 0x9D, 0x7A, 0xC1, 
    0x44, 0xDC, 0xC5, 0x1E, 0x82, 0x0A, 0x96, 0x71, 0xCD, 0x43, 
    0x81, 0x02, 0x39, 0x64, 0xBA, 0x81, 0xB1, 0xD6, 0x1B, 0x8C, 
    0x45, 0xE2, 0x82, 0xD6, 0x4B, 0x08, 0x61, 0x32, 0xB0, 0x7A, 
    0xCD, 0x00, 0x8A, 0x2A, 0xF3, 0x86, 0x30, 0xFC, 0x74, 0x19, 0x3B, 

    0x6B, 0xA5, 0x1E, 0xE6, 0x44, 0xA2, 0x62, 0x90, 0xB9, 0xCB,         // 24
    0x96, 0xE6, 0x07, 0x5E, 0xF9, 0x6D, 0x0D, 0xEE, 0x31, 0x7C, 
    0xB9, 0x1E, 0x74, 0xD8, 0xC1, 0x0F, 0xE7, 0x20, 0x46, 0x5D, 
    0x27, 0xC2, 0x66, 0xD0, 0x2E, 0x56, 0xC0, 0x6B, 0x9D, 0x30, 
    0x92, 0x43, 0xD5, 0x77, 0x08, 0xDC, 0x63, 0xFD, 0x06, 0x6C, 
    0xAD, 0x12, 0x65, 0xEC, 0x5B, 0xCA, 0x3C, 0xB5, 0x1E, 0x99, 
    0xF7, 0xB0, 0x79, 0xC7, 0x26, 0x55, 0x11, 0x6A, 0x4D, 0xF5, 
    0xB7, 0x32, 0x0F, 0x64, 0x92, 0xC5, 0x87, 0xD2, 0x4A, 0x1E, 
    0xF4, 0x3A, 0xE0, 0x50, 0xAA, 0x42, 0x6D, 0x08, 0xB7, 0xEA, 0x8C, 

    0x04, 0xF2, 0x3A, 0x7C, 0xBE, 0xF5, 0x22, 0x40, 0x78, 0x13,         // 25
    0x54, 0x30, 0xA1, 0xC2, 0x19, 0xCC, 0x3F, 0x82, 0xA3, 0x06, 
    0xEA, 0x58, 0x30, 0xA4, 0x3B, 0x8E, 0x68, 0xB2, 0xF7, 0x9F, 
    0xDA, 0x18, 0x8A, 0xF6, 0x98, 0xAB, 0x3E, 0xF3, 0x4D, 0xDA, 
    0x0B, 0x80, 0xB6, 0x57, 0x31, 0xAE, 0x20, 0x92, 0x35, 0xE5, 
    0x51, 0x9A, 0x7D, 0x3A, 0xA6, 0x26, 0xD9, 0x5C, 0xE9, 0x2E, 
    0x50, 0x16, 0xDB, 0x44, 0xFD, 0x94, 0xCB, 0xE9, 0xAC, 0x06, 
    0x75, 0x98, 0xE9, 0xBF, 0x3A, 0xFD, 0x21, 0x6E, 0xE5, 0x99, 
    0x5F, 0x7F, 0xB0, 0x70, 0x0C, 0xE2, 0xC0, 0x9A, 0x38, 0x5A, 0xD0, 

    0x4D, 0x84, 0xAE, 0x5F, 0x16, 0x4E, 0xD2, 0xAB, 0xED, 0x64,         // 26
    0xB4, 0xF4, 0x79, 0x3A, 0x91, 0x55, 0xDE, 0xB7, 0x4B, 0x68, 
    0xCB, 0xAB, 0x8A, 0x0A, 0xE4, 0x52, 0xD2, 0x31, 0x01, 0x87, 
    0x52, 0xB7, 0x40, 0x07, 0x5E, 0x25, 0xCB, 0x00, 0xB1, 0x79, 
    0xC2, 0xF8, 0x16, 0x9C, 0xED, 0x87, 0x4F, 0xD1, 0xB8, 0x87, 
    0x18, 0xF9, 0xBB, 0x04, 0xE5, 0x8B, 0x74, 0x08, 0xAB, 0x7B, 
    0xD5, 0x8F, 0x62, 0x9D, 0x06, 0x6D, 0x2C, 0x41, 0x9B, 0x5D, 
    0xD3, 0x4E, 0x28, 0x71, 0x17, 0xA1, 0x40, 0xB8, 0x09, 0xAE, 
    0x2A, 0xC8, 0x19, 0xD8, 0x8F, 0x57, 0x1E, 0xD4, 0x86, 0x22, 0xA9, 

    0x28, 0xC4, 0x0D, 0xD8, 0x9E, 0x88, 0x71, 0x03, 0x35, 0x8A,         // 27
    0xD4, 0x0D, 0x52, 0xDB, 0xB3, 0x76, 0x2A, 0x12, 0xFE, 0x8F, 
    0x1A, 0x41, 0xF1, 0x64, 0xB3, 0x18, 0x9D, 0x7C, 0xC4, 0x69, 
    0x2E, 0xE2, 0x75, 0xC6, 0xE4, 0x7B, 0x8E, 0xDF, 0x2D, 0x58, 
    0x21, 0x65, 0x39, 0xCB, 0x42, 0x6D, 0xE3, 0x11, 0x5C, 0x3B, 
    0xD7, 0x2A, 0x58, 0xD1, 0x68, 0x43, 0xF1, 0x9E, 0x38, 0xC0, 
    0x58, 0x23, 0xEE, 0x33, 0xAF, 0xE6, 0xBC, 0x82, 0x22, 0xC2, 
    0x15, 0xF3, 0xA9, 0x8D, 0xD4, 0x57, 0x80, 0xEE, 0x5A, 0x8A, 
    0x45, 0xFB, 0x65, 0x33, 0xB9, 0xF0, 0x7B, 0x47, 0xF5, 0x6F, 0xDB, 

    0x61, 0xFE, 0x73, 0x2E, 0xEA, 0x3D, 0xBB, 0xE7, 0xA2, 0x49,         // 28
    0x23, 0xA5, 0x88, 0x32, 0x00, 0xE9, 0x9D, 0x61, 0xC0, 0x2F, 
    0xDE, 0x71, 0xC7, 0x26, 0x82, 0xFB, 0x4B, 0xDF, 0x3E, 0xF0, 
    0xAC, 0x11, 0x99, 0x48, 0xB0, 0x17, 0x44, 0x69, 0x98, 0xF0, 
    0xA8, 0x8F, 0xDF, 0x78, 0x02, 0xBC, 0x2B, 0xA7, 0x75, 0xC2, 
    0x98, 0x70, 0xAA, 0x20, 0x97, 0x11, 0xC6, 0x25, 0x6E, 0xF5, 
    0x0E, 0xA6, 0xC3, 0x7A, 0x4A, 0x8E, 0x0C, 0x56, 0xF9, 0x6B, 
    0x8B, 0x36, 0x5A, 0x02, 0xEC, 0xB1, 0x10, 0xCD, 0x26, 0xDC, 
    0xBB, 0x05, 0x9C, 0x7F, 0x4F, 0x2A, 0xA0, 0x02, 0xB3, 0x17, 0x8F, 

    0xA2, 0x40, 0x94, 0x55, 0xC2, 0x10, 0x5A, 0x28, 0x6A, 0xCB,         // 29
    0xF0, 0x5B, 0xC3, 0xF7, 0x67, 0x46, 0xCD, 0x7D, 0x43, 0xA3, 
    0x80, 0x02, 0x9D, 0x54, 0xBD, 0x35, 0x70, 0x0A, 0xBB, 0x1D, 
    0x8C, 0x5E, 0xFD, 0x29, 0x6C, 0xF2, 0xCD, 0xAE, 0x14, 0x3E, 
    0xCB, 0x4C, 0x1B, 0xB5, 0x94, 0xF1, 0x49, 0x8D, 0xF7, 0x07, 
    0x50, 0xE8, 0x39, 0x7D, 0xD8, 0xB0, 0x63, 0x8C, 0xD3, 0x3F, 
    0x92, 0x72, 0x29, 0xD6, 0x15, 0x6A, 0xC5, 0xD7, 0xA1, 0x2D, 
    0xDF, 0xB0, 0xCD, 0x79, 0x2C, 0x49, 0x72, 0x99, 0x3E, 0x68, 
    0x83, 0x4D, 0xE5, 0xC7, 0x0F, 0xD7, 0x6A, 0xC9, 0x52, 0xE8, 0x37, 

    0x07, 0xE3, 0xAE, 0x1E, 0x7A, 0xF6, 0x92, 0xDA, 0x80, 0x0E,         // 30
    0x91, 0x2B, 0x72, 0x16, 0x97, 0xB9, 0x0F, 0xF2, 0x1D, 0xC6, 
    0x56, 0xF7, 0x39, 0xE5, 0x0D, 0xD4, 0x92, 0xA5, 0x55, 0x77, 
    0xDC, 0x38, 0xB8, 0x87, 0x0B, 0xA2, 0x35, 0x5D, 0xE5, 0x86, 
    0x05, 0x6C, 0xFC, 0x32, 0x58, 0x1A, 0xC3, 0x68, 0x32, 0xD5, 
    0x81, 0x17, 0xB3, 0xEE, 0x4A, 0x2E, 0xF8, 0x52, 0x06, 0xBA, 
    0x5C, 0xEC, 0x4E, 0xB4, 0xF7, 0x9F, 0x3B, 0x1C, 0x4D, 0x7D, 
    0x09, 0x63, 0x41, 0xE5, 0x91, 0xC4, 0xFA, 0x1A, 0xC2, 0xF2, 
    0x16, 0xA9, 0x2E, 0x5C, 0xA6, 0x87, 0xFA, 0x34, 0x95, 0x77, 0xD1, 

    0xB2, 0x7D, 0x35, 0xD8, 0xB3, 0x65, 0x1B, 0xAA, 0x34, 0xC0,         // 31
    0x50, 0xAE, 0xD7, 0x3F, 0xDE, 0x85, 0x36, 0x58, 0x93, 0xDC, 
    0x13, 0xAB, 0x6A, 0x8B, 0xAE, 0x60, 0x2D, 0xF4, 0xCE, 0x40, 
    0xA0, 0x03, 0xD2, 0x4F, 0xE1, 0x8E, 0x1F, 0x79, 0xBD, 0x55, 
    0xDC, 0xA0, 0x88, 0xC9, 0x73, 0x9F, 0xDD, 0x10, 0xB1, 0x47, 
    0x9D, 0xC8, 0x62, 0x02, 0x6F, 0x89, 0x1C, 0xA3, 0xE4, 0x99, 
    0x32, 0xC4, 0x00, 0x89, 0x20, 0x5A, 0xE5, 0x92, 0xB8, 0xEC, 
    0xCB, 0x9B, 0x1B, 0xB7, 0x0E, 0x67, 0x33, 0xAD, 0x7D, 0x47, 
    0x98, 0xD8, 0x74, 0xF1, 0x1D, 0x3F, 0x5F, 0x0D, 0xAC, 0x24, 0x5E, 

    0xF8, 0x16, 0x69, 0x91, 0x00, 0x3F, 0xD2, 0x4C, 0xFA, 0x67,         // 32
    0xDF, 0x05, 0x7C, 0xB1, 0x22, 0x70, 0xE8, 0xAA, 0x6A, 0x3F, 
    0x88, 0x2B, 0xD8, 0x15, 0x44, 0xEA, 0x7E, 0x10, 0x8B, 0x23, 
    0xE9, 0x6C, 0x82, 0x2E, 0xBC, 0x57, 0xD0, 0xFA, 0x10, 0x39, 
    0xB7, 0x23, 0x49, 0x09, 0xEB, 0x37, 0x7F, 0x55, 0xEC, 0x72, 
    0x26, 0xFE, 0x33, 0x9B, 0xCE, 0xB6, 0xDA, 0x3C, 0x68, 0x1E, 
    0x7E, 0xDC, 0xAD, 0x6F, 0x36, 0xCA, 0x79, 0x0E, 0x61, 0x42, 
    0x22, 0x72, 0xF8, 0x7F, 0x4D, 0xE1, 0x94, 0x56, 0x02, 0xCF, 
    0x26, 0x58, 0x0C, 0xB5, 0x90, 0xDE, 0xC0, 0x7F, 0xEB, 0xCA, 0x48, 

    0x3A, 0xC7, 0xE1, 0x4D, 0xF2, 0xBF, 0x96, 0x7A, 0x13, 0xA7,         // 33
    0x2D, 0x97, 0x47, 0xFB, 0x59, 0xC2, 0x06, 0xD2, 0x20, 0xF5, 
    0xBF, 0x5C, 0xB5, 0x78, 0x9E, 0x1D, 0xC8, 0x4E, 0xAA, 0x64, 
    0xC1, 0x43, 0xAE, 0xF6, 0x13, 0x74, 0x41, 0xAB, 0x96, 0x70, 
    0xEE, 0x67, 0xAF, 0xD7, 0x5D, 0xBA, 0x22, 0xCD, 0x8C, 0x05, 
    0xBC, 0x5B, 0x7C, 0xE4, 0x3D, 0x5D, 0x0A, 0x81, 0xCA, 0xFA, 
    0x57, 0x25, 0x42, 0x9D, 0xE0, 0xB1, 0x2C, 0xFD, 0xC6, 0x8B, 
    0xAB, 0x50, 0xD1, 0x34, 0xA8, 0xCB, 0x1F, 0xE7, 0xB9, 0x66, 
    0xEA, 0x86, 0xC4, 0x4D, 0x79, 0x31, 0x9A, 0x42, 0x18, 0x6F, 0x9E, 

    0x8C, 0x62, 0xA5, 0x2C, 0x73, 0x24, 0x5B, 0xE8, 0x3B, 0x87,         // 34
    0xEF, 0x6C, 0xCC, 0x14, 0xA3, 0x34, 0x8C, 0x55, 0x9D, 0x75, 
    0x04, 0xE4, 0x33, 0xFD, 0x57, 0xBA, 0x6A, 0xE0, 0x33, 0xFB, 
    0x0E, 0x93, 0x1C, 0x5F, 0x9D, 0xE7, 0x05, 0x80, 0x2B, 0xC2, 
    0x14, 0x93, 0x2F, 0x78, 0x13, 0x91, 0xFA, 0x44, 0xAC, 0x3B, 
    0xDF, 0x93, 0x0D, 0xAC, 0x24, 0x92, 0xED, 0x4D, 0xAB, 0x0D, 
    0xB9, 0x8D, 0xF1, 0x60, 0x0B, 0x4F, 0xA1, 0x6C, 0x3B, 0x02, 
    0xEE, 0x2C, 0x92, 0x66, 0x05, 0x84, 0x3C, 0x6E, 0x8B, 0x2E, 
    0xA7, 0x40, 0xFC, 0x22, 0xD2, 0x09, 0xF5, 0x66, 0xDA, 0xBB, 0x06, 

    0x32, 0xBD, 0x0C, 0x87, 0xDE, 0xAB, 0x0B, 0xB9, 0xD3, 0x53,         // 35
    0x0F, 0xB4, 0x32, 0x7E, 0xDC, 0x67, 0xF1, 0x42, 0xCA, 0x30, 
    0xAE, 0x47, 0x8F, 0x0A, 0xD2, 0x2B, 0x9A, 0x04, 0x7A, 0xB5, 
    0x54, 0xDC, 0xC5, 0x7F, 0x32, 0xB6, 0xCD, 0x58, 0xF3, 0x46, 
    0xDB, 0x57, 0xCA, 0xF0, 0xAA, 0x4A, 0x6B, 0x1B, 0x76, 0xCB, 
    0x52, 0x2C, 0xEF, 0x50, 0xD4, 0x6D, 0xC2, 0x1A, 0x96, 0x39, 
    0x75, 0xD0, 0x17, 0xC0, 0x88, 0xE7, 0x20, 0x85, 0xD1, 0xB5, 
    0x5E, 0xDD, 0x18, 0xC1, 0xF0, 0x59, 0xAE, 0xF4, 0x0F, 0xDB, 
    0x60, 0x07, 0x97, 0x6C, 0xB2, 0x5F, 0xA2, 0x27, 0x85, 0x54, 0xED, 

    0xD4, 0x4C, 0xF6, 0x58, 0xCC, 0x34, 0x8F, 0x6F, 0x25, 0xA1,         // 36
    0xC8, 0x5C, 0xEC, 0x4E, 0x92, 0x0D, 0xB5, 0x1B, 0xE1, 0x82, 
    0x5F, 0xC7, 0x6E, 0xAB, 0x4C, 0x87, 0xE9, 0x41, 0xCF, 0x8F, 
    0x2C, 0x73, 0x3A, 0xEB, 0x53, 0x25, 0x91, 0x1A, 0xB0, 0x77, 
    0xA1, 0x00, 0x86, 0x3D, 0x23, 0xDC, 0xC6, 0xA0, 0xE5, 0x12, 
    0x9B, 0x6E, 0xB2, 0x81, 0x11, 0xA2, 0x33, 0x7E, 0xF1, 0x62, 
    0xE6, 0x52, 0x30, 0x72, 0x3B, 0xC8, 0x61, 0xF0, 0x14, 0x4B, 
    0x81, 0xA6, 0x6F, 0x99, 0x32, 0xD5, 0x16, 0x97, 0x54, 0xBD, 
    0x7B, 0xAE, 0x28, 0xDD, 0x37, 0xE9, 0x47, 0xCD, 0xAD, 0x20, 0x7A, 

    0x15, 0x95, 0x71, 0x23, 0x9E, 0x4C, 0xFD, 0x44, 0xE1, 0x78,         // 37
    0x1E, 0x8A, 0x02, 0xAF, 0x2B, 0xD1, 0x79, 0x61, 0x99, 0x0E, 
    0xF6, 0x25, 0xDF, 0x1C, 0xF3, 0x67, 0x14, 0xA8, 0x6E, 0x1B, 
    0xE5, 0xA0, 0x01, 0xAA, 0xCF, 0x83, 0xE6, 0x67, 0xD7, 0x3E, 
    0x25, 0xFC, 0xC0, 0x75, 0x99, 0x5C, 0x05, 0x7E, 0x30, 0x60, 
    0xF7, 0xC6, 0x25, 0xDB, 0x3E, 0xFC, 0x5C, 0xD5, 0x26, 0xB1, 
    0x06, 0x99, 0xAB, 0xFB, 0x96, 0x06, 0xA9, 0x33, 0x93, 0xE0, 
    0x1D, 0x39, 0xCB, 0x0A, 0x4E, 0x8A, 0x68, 0xCE, 0x3E, 0x1B, 
    0xF6, 0x4A, 0xC2, 0x7F, 0x14, 0x95, 0x78, 0x02, 0xFD, 0x41, 0xA0, 

    0xC5, 0x2F, 0xE1, 0xB5, 0x11, 0x7D, 0xBA, 0x04, 0x98, 0x36,         // 38
    0xF7, 0xCE, 0x6F, 0xE4, 0x9C, 0x41, 0xFE, 0x34, 0xC3, 0x4E, 
    0xA7, 0x43, 0x99, 0x7F, 0x36, 0xBB, 0xDA, 0x58, 0xF8, 0x47, 
    0xC1, 0x5C, 0xF3, 0x47, 0x6F, 0x0E, 0x3A, 0xA0, 0x09, 0x8D, 
    0xB6, 0x6A, 0x50, 0x0F, 0xEC, 0xBB, 0x3A, 0xF2, 0xBE, 0x8B, 
    0x3F, 0x01, 0x5A, 0x94, 0x66, 0xB6, 0x05, 0x9D, 0x51, 0xCB, 
    0x83, 0x3E, 0xC9, 0x14, 0x5C, 0xDB, 0x7A, 0x51, 0xC4, 0x66, 
    0xB1, 0xF4, 0x62, 0xD9, 0xAC, 0xFC, 0x2B, 0xB0, 0x76, 0xD5, 
    0x8B, 0x31, 0xE8, 0x57, 0xA9, 0x41, 0xBE, 0x59, 0x91, 0x69, 0xE6, 

    0x5B, 0x85, 0x44, 0xCF, 0x64, 0xE5, 0x52, 0xD1, 0x63, 0xB5,         // 39
    0x57, 0xA3, 0x48, 0x20, 0x60, 0x84, 0xA9, 0x1D, 0xE7, 0x85, 
    0x6B, 0xD8, 0x15, 0xC5, 0x55, 0xA0, 0x25, 0x84, 0x08, 0x98, 
    0x78, 0x13, 0x88, 0x27, 0x9B, 0xFE, 0xC5, 0x4E, 0xEE, 0x59, 
    0xD1, 0x2E, 0xE2, 0xA5, 0x34, 0x6D, 0x90, 0x4E, 0x1A, 0xDA, 
    0xAE, 0x7D, 0xE9, 0xBD, 0x17, 0x7A, 0xE4, 0x35, 0x73, 0x18, 
    0xDD, 0x6D, 0x27, 0xE5, 0x84, 0x3D, 0xBC, 0x26, 0xF7, 0x05, 
    0x88, 0x29, 0x96, 0x3F, 0x78, 0x12, 0x58, 0xE9, 0x23, 0xA2, 
    0x00, 0x63, 0x96, 0x0C, 0xC9, 0xF3, 0x1B, 0xD5, 0x29, 0xBB, 0x0F, 

    0xB0, 0xFA, 0x01, 0x92, 0x2A, 0xAC, 0x16, 0x82, 0x22, 0xE5,         // 40
    0x31, 0x12, 0x82, 0xC2, 0xED, 0x08, 0xCF, 0x73, 0x47, 0x00, 
    0xBF, 0x31, 0x60, 0xEF, 0x04, 0x8C, 0xD1, 0x3C, 0xB4, 0xE3, 
    0x37, 0xD4, 0xB4, 0xDD, 0x60, 0xB1, 0x22, 0x73, 0xBD, 0x13, 
    0x7B, 0x9C, 0x15, 0x7F, 0xC3, 0x18, 0xDD, 0xA6, 0x7C, 0x34, 
    0x54, 0x9F, 0x29, 0x46, 0xF4, 0x3B, 0x8B, 0xC7, 0xA8, 0xF9, 
    0x45, 0xB7, 0x8F, 0x52, 0xAC, 0x1B, 0xE3, 0x9E, 0x78, 0x41, 
    0xDB, 0x58, 0xC1, 0x1F, 0xE3, 0xA1, 0xC2, 0x89, 0x4B, 0x6A, 
    0xEF, 0xB3, 0xD3, 0x7C, 0x26, 0x65, 0xA6, 0x7F, 0xEC, 0x3B, 0x7C, 

    0x27, 0x4C, 0xA8, 0x74, 0xEF, 0x3C, 0x9A, 0xF3, 0xBD, 0x77,         // 41
    0x92, 0xAE, 0xD6, 0x3F, 0xB5, 0x31, 0x59, 0x97, 0xDA, 0xB1, 
    0xF8, 0x8C, 0xAB, 0x7A, 0xD8, 0x48, 0x71, 0xF2, 0x62, 0x20, 
    0xA4, 0x67, 0x2D, 0x50, 0x16, 0x7E, 0x43, 0xE1, 0x93, 0x33, 
    0xF6, 0x45, 0xD7, 0x5F, 0xF7, 0x4B, 0xB7, 0x5C, 0x06, 0xFD, 
    0xC8, 0x0F, 0xD7, 0x74, 0x97, 0xCD, 0x1F, 0x63, 0x29, 0x86, 
    0x0C, 0x60, 0xF0, 0x01, 0xCD, 0x6B, 0x8A, 0x0D, 0x57, 0xBF, 
    0xA3, 0x11, 0xEF, 0x87, 0x4F, 0x6E, 0x31, 0x0E, 0xDF, 0xC5, 
    0x40, 0x20, 0x52, 0x36, 0xE0, 0x8B, 0x3A, 0x13, 0x50, 0x9C, 0xDB, 

    0xC0, 0x6A, 0xDF, 0x19, 0x51, 0xD6, 0x6E, 0x32, 0x5B, 0x06,         // 42
    0x49, 0xFA, 0x5C, 0x0F, 0x6F, 0xA0, 0xF6, 0x3A, 0x17, 0x62, 
    0x23, 0x52, 0x0F, 0x34, 0xB9, 0x1C, 0xA6, 0x0F, 0xCA, 0x86, 
    0x4C, 0xFA, 0x8C, 0xCA, 0xE7, 0x98, 0xBB, 0x02, 0x6B, 0xA9, 
    0x58, 0xBF, 0x23, 0x94, 0x09, 0x7A, 0x2F, 0xE5, 0x92, 0xB6, 
    0x67, 0x8B, 0x4D, 0xB8, 0x13, 0x54, 0xA2, 0xEF, 0x4B, 0xD5, 
    0xA0, 0xC3, 0x2C, 0x97, 0x44, 0xFA, 0x38, 0xC8, 0xE7, 0x30, 
    0x81, 0x6C, 0x36, 0xB4, 0x0A, 0xCB, 0xF8, 0x9B, 0x71, 0x17, 
    0xA4, 0x85, 0xFC, 0xBC, 0x9C, 0x54, 0xF6, 0xB2, 0xCE, 0x65, 0x0A, 

    0x9F, 0x34, 0x84, 0xC7, 0xB4, 0x8E, 0x0A, 0xC9, 0xA0, 0xE1,         // 43
    0xC1, 0x25, 0x7E, 0xE8, 0x8F, 0x1D, 0xC5, 0x83, 0xAF, 0x78, 
    0x9C, 0xC8, 0xDF, 0x69, 0xFD, 0x91, 0x5F, 0xBC, 0x31, 0xE0, 
    0x13, 0xB9, 0x24, 0x74, 0x0B, 0x3A, 0xF8, 0x53, 0xD1, 0x1A, 
    0xE0, 0x82, 0xAF, 0x36, 0xD3, 0xA5, 0xC8, 0x21, 0x71, 0x3D, 
    0x18, 0xE4, 0x2C, 0xEF, 0x6D, 0xDA, 0x02, 0x78, 0xB3, 0x1A, 
    0x70, 0x3F, 0xD7, 0x74, 0xB6, 0x1F, 0x5F, 0xAB, 0x90, 0x1E, 
    0xFE, 0xCB, 0x5B, 0xE0, 0x93, 0x3B, 0x57, 0xAF, 0x36, 0x8C, 
    0xDB, 0x5E, 0x07, 0x70, 0x1B, 0xD6, 0x03, 0x6E, 0x90, 0x3E, 0xEB, 

    0x53, 0xF7, 0x08, 0x63, 0x22, 0x43, 0xFC, 0x54, 0x82, 0x1D,         // 44
    0x66, 0xA8, 0x3D, 0xB9, 0x52, 0xDD, 0x44, 0x06, 0xE6, 0x2C, 
    0xEF, 0x3B, 0xB2, 0x86, 0x3F, 0x24, 0xE9, 0x83, 0x59, 0x98, 
    0x6F, 0xE9, 0x43, 0xA8, 0xC3, 0x66, 0x89, 0x27, 0x7A, 0x9C, 
    0x38, 0x06, 0x71, 0xE4, 0x61, 0x42, 0x8A, 0x55, 0xED, 0xA1, 
    0xCF, 0x58, 0x93, 0xA9, 0x3A, 0x8E, 0xC1, 0x33, 0xE2, 0x57, 
    0xF4, 0x85, 0x18, 0x55, 0xEA, 0x81, 0xDA, 0x10, 0x71, 0x53, 
    0xB1, 0x01, 0xA0, 0x28, 0x6F, 0xD9, 0x80, 0x03, 0xEE, 0x4C, 
    0xC3, 0x32, 0xE2, 0xAD, 0x4D, 0x7A, 0xC1, 0x2F, 0xE4, 0x19, 0x7B, 

    0x22, 0x93, 0xCE, 0xA2, 0xE4, 0x7A, 0xAB, 0x14, 0xEA, 0x37,         // 45
    0xD3, 0x88, 0x01, 0xCF, 0x2D, 0x76, 0xA9, 0x61, 0xCF, 0x4D, 
    0x93, 0x1B, 0x5D, 0x09, 0xA2, 0xC2, 0x47, 0x01, 0xCD, 0x3F, 
    0xB0, 0x08, 0x8F, 0x56, 0xF0, 0x1C, 0xD7, 0xB4, 0xED, 0x4A, 
    0xC9, 0xF3, 0x4F, 0x97, 0x26, 0xFB, 0x17, 0xCE, 0x08, 0x81, 
    0x26, 0xB5, 0x07, 0x62, 0x1D, 0xFC, 0x46, 0x84, 0x25, 0x95, 
    0x06, 0xB6, 0xE0, 0xA6, 0x08, 0x48, 0x9E, 0x32, 0xED, 0xD0, 
    0x3B, 0x79, 0x49, 0xF5, 0x13, 0xA7, 0x2F, 0xC6, 0x66, 0xB2, 
    0x0F, 0x7C, 0x98, 0x23, 0xEF, 0x8F, 0x46, 0xA4, 0x5F, 0xCB, 0xB1, 

    0xDB, 0x69, 0x41, 0x27, 0x56, 0xCA, 0x3A, 0x6B, 0xB8, 0x9A,         // 46
    0x4A, 0xEE, 0x6A, 0x96, 0xF9, 0x15, 0x8B, 0xBF, 0x25, 0x72, 
    0xBB, 0x7C, 0xCA, 0xF3, 0x50, 0xE0, 0x7C, 0xAA, 0xF6, 0x1F, 
    0xDB, 0x64, 0xCC, 0x28, 0x82, 0x4B, 0xA5, 0x34, 0x0C, 0x64, 
    0x88, 0xA9, 0x18, 0xC7, 0x79, 0xB8, 0x99, 0x6B, 0xB0, 0x52, 
    0xF8, 0x70, 0xE6, 0xC7, 0x7D, 0xB2, 0x5E, 0xD9, 0xAE, 0x69, 
    0xCC, 0x35, 0x63, 0x29, 0x8E, 0xCF, 0x62, 0xBD, 0x82, 0x17, 
    0x96, 0xE4, 0xBA, 0x86, 0xCA, 0x47, 0xE8, 0x96, 0x1B, 0x84, 
    0xF6, 0x41, 0x60, 0xC8, 0x3A, 0xD3, 0x1E, 0xFE, 0x0C, 0x84, 0x4B, 

    0x0F, 0xBE, 0x7F, 0xEB, 0x88, 0x19, 0x98, 0xDD, 0x2D, 0x77,         // 47
    0x0F, 0xB5, 0x1E, 0x48, 0xB0, 0x59, 0xE7, 0x49, 0x9F, 0xF6, 
    0x02, 0xDD, 0x2F, 0x6D, 0x96, 0x19, 0x67, 0x32, 0x8D, 0x53, 
    0x7E, 0x2D, 0x9B, 0xE6, 0xB9, 0x03, 0x71, 0x94, 0xDD, 0xBA, 
    0x21, 0x46, 0x6C, 0xEB, 0x02, 0x5A, 0x3D, 0xEC, 0x2D, 0xD6, 
    0x37, 0x8D, 0x44, 0x27, 0xD8, 0x0A, 0x97, 0x3D, 0x12, 0xF8, 
    0x49, 0xA3, 0x7A, 0xF2, 0xB9, 0x36, 0xF6, 0x0C, 0x54, 0xAE, 
    0x64, 0x33, 0x0F, 0x54, 0x69, 0x19, 0x7B, 0x52, 0xE0, 0x36, 
    0x9E, 0xD6, 0xB5, 0x0B, 0x7F, 0x59, 0xB4, 0x70, 0x99, 0x38, 0xF2, 

    0xAA, 0x34, 0xD6, 0x06, 0xB1, 0xF6, 0x60, 0x0B, 0xC0, 0xF9,         // 48
    0x5E, 0xDB, 0x83, 0xCC, 0x26, 0x7B, 0x0A, 0xD5, 0x1D, 0x69, 
    0x47, 0x91, 0xAF, 0x11, 0xD9, 0x3C, 0xB6, 0xCA, 0x0E, 0xA5, 
    0xBF, 0xFC, 0x50, 0x19, 0x67, 0xD3, 0xF9, 0x57, 0x40, 0x78, 
    0xF6, 0xD1, 0xA0, 0x35, 0xBD, 0x86, 0xD9, 0x10, 0x7C, 0x9A, 
    0x14, 0xC3, 0x5D, 0xA0, 0x73, 0x37, 0xED, 0xC8, 0x78, 0x9A, 
    0x21, 0xDE, 0x0B, 0x43, 0x83, 0x1D, 0x72, 0x95, 0xDF, 0x23, 
    0xF8, 0xC6, 0x92, 0xDD, 0xA3, 0xF1, 0xBE, 0x26, 0xCC, 0x59, 
    0x12, 0x66, 0x30, 0xF9, 0x9E, 0x17, 0xE7, 0x31, 0xD7, 0xBD, 0x61, 

    0x77, 0x95, 0x51, 0x6E, 0x2F, 0x44, 0xA8, 0x80, 0x4F, 0x92,         // 49
    0x27, 0xA2, 0x35, 0x67, 0xF0, 0xBF, 0x99, 0x3B, 0x82, 0xB4, 
    0xE9, 0x35, 0x77, 0x4B, 0xA4, 0x83, 0xF2, 0x4D, 0xE7, 0x68, 
    0x3A, 0x07, 0x75, 0xAA, 0x39, 0x89, 0x23, 0xC2, 0x11, 0x9C, 
    0x33, 0x15, 0x82, 0x56, 0xE0, 0x20, 0xAE, 0x4F, 0xCA, 0x60, 
    0xAA, 0xE8, 0x01, 0xF7, 0xBD, 0x59, 0x88, 0x2B, 0x4C, 0xE7, 
    0x66, 0x88, 0xB2, 0xD2, 0x56, 0xE8, 0xAC, 0x3B, 0xC8, 0x4A, 
    0xA4, 0x75, 0x25, 0x46, 0x03, 0x89, 0x43, 0x9F, 0x75, 0xAA, 
    0xEB, 0x7F, 0x95, 0x4B, 0xCB, 0x67, 0x89, 0x4E, 0x00, 0x8B, 0x27, 

    0xED, 0x11, 0xE2, 0xB8, 0xD2, 0x8F, 0xE3, 0x30, 0xD3, 0x11,         // 50
    0xC7, 0x44, 0xE3, 0x04, 0xA1, 0x31, 0x61, 0xFE, 0xC5, 0x52, 
    0x15, 0xD1, 0xB7, 0xFB, 0x61, 0x04, 0x2E, 0x9E, 0x24, 0x87, 
    0xDD, 0xC6, 0x90, 0xE2, 0xBC, 0x52, 0xA7, 0x7F, 0xE6, 0xCB, 
    0x67, 0xB7, 0xEF, 0x0C, 0x9A, 0x6D, 0x36, 0x92, 0xFE, 0x21, 
    0x46, 0x76, 0x97, 0x41, 0x22, 0xDA, 0x0E, 0xA5, 0xBE, 0x03, 
    0xCF, 0x50, 0x26, 0x93, 0x16, 0xC0, 0x5C, 0x02, 0x77, 0x91, 
    0x11, 0x5F, 0xEE, 0xB3, 0xCE, 0x6B, 0x1C, 0xFA, 0x06, 0x3C, 
    0xBD, 0x21, 0xD0, 0x05, 0xAA, 0x2C, 0xD1, 0xA3, 0xF5, 0x58, 0xCC, 

    0x46, 0xA4, 0x2C, 0x7D, 0x16, 0x52, 0x01, 0xB5, 0x64, 0xEE,         // 51
    0x85, 0x6D, 0xB7, 0x8C, 0x4E, 0xDC, 0x14, 0x74, 0x27, 0xA3, 
    0x8E, 0x65, 0x2D, 0x1A, 0xC2, 0xDD, 0x73, 0xD2, 0x59, 0xB4, 
    0x1C, 0x45, 0x5B, 0x16, 0x2D, 0xF1, 0x08, 0x5F, 0x29, 0x51, 
    0x91, 0x41, 0x72, 0xCC, 0x47, 0xF3, 0xC1, 0x04, 0x79, 0xB5, 
    0xDE, 0x19, 0xD1, 0x69, 0x8D, 0xB5, 0x6D, 0xF8, 0x59, 0x83, 
    0x3E, 0xBA, 0xFE, 0x6C, 0xDC, 0x34, 0x9E, 0xFA, 0xD4, 0x2A, 
    0xE7, 0xC3, 0x36, 0x7C, 0x4D, 0xE7, 0xB1, 0x5D, 0x87, 0xDC, 
    0x6C, 0x48, 0xF1, 0x75, 0x56, 0xE9, 0x12, 0x7A, 0x34, 0xB0, 0x1C, 

    0x6A, 0xC4, 0x59, 0xF0, 0xA9, 0x6C, 0xFE, 0x7D, 0x3D, 0x9E,         // 52
    0x4B, 0x26, 0xFA, 0x17, 0x75, 0xB9, 0x8F, 0xD2, 0x44, 0xEA, 
    0x0C, 0xDF, 0x80, 0x9C, 0x3D, 0xA8, 0x4F, 0x93, 0x09, 0xEE, 
    0x78, 0xA2, 0xF5, 0x7A, 0xC8, 0x6D, 0xD8, 0x98, 0xB9, 0xFD, 
    0x00, 0xE1, 0x1D, 0xA6, 0x2B, 0x86, 0x5C, 0xD7, 0x53, 0x31, 
    0x87, 0x5B, 0xA6, 0x10, 0xEF, 0x2F, 0x4A, 0x99, 0x28, 0xE2, 
    0xA0, 0x2E, 0x80, 0x06, 0xAA, 0x64, 0x7E, 0x25, 0x52, 0xAB, 
    0x3B, 0x87, 0x0A, 0xA5, 0x26, 0x8F, 0x3B, 0xD6, 0x2B, 0x98, 
    0x0E, 0xA8, 0x89, 0x38, 0xBE, 0x90, 0x41, 0xC4, 0x64, 0xE3, 0x83, 

    0xFB, 0x04, 0x9A, 0x3F, 0x24, 0xCA, 0x98, 0x1D, 0xC5, 0x14,         // 53
    0xBA, 0xD6, 0x5F, 0xAA, 0x3F, 0xEC, 0x57, 0x06, 0xB3, 0x79, 
    0x58, 0xC4, 0x49, 0xF0, 0x7A, 0x14, 0xF7, 0x3C, 0xBE, 0x69, 
    0x28, 0xD0, 0x03, 0x9A, 0x42, 0xA8, 0x4C, 0x21, 0x70, 0x33, 
    0xA2, 0x7C, 0xC5, 0x67, 0xE8, 0x13, 0xA9, 0x25, 0x9C, 0xEA, 
    0xC9, 0x2A, 0xE2, 0x50, 0xC4, 0x7A, 0xDF, 0x16, 0xCA, 0x6B, 
    0x11, 0xEA, 0x5B, 0xC5, 0x44, 0xE4, 0x0F, 0xC7, 0x8E, 0x6E, 
    0xBD, 0x5B, 0xD4, 0xFD, 0x65, 0xC4, 0x09, 0x78, 0xBF, 0xE9, 
    0x57, 0xC8, 0x24, 0xE1, 0x17, 0x60, 0xF9, 0x9D, 0x2A, 0x0F, 0x97, 

    0x30, 0xCE, 0x75, 0xDD, 0x86, 0x55, 0x2E, 0xD8, 0x58, 0xE8,         // 54
    0x73, 0x09, 0x96, 0x31, 0xD5, 0x1B, 0xA7, 0x83, 0xF5, 0x2C, 
    0x9A, 0x37, 0xB0, 0x05, 0x5F, 0xC6, 0x8A, 0x20, 0xD9, 0x96, 
    0x43, 0xB1, 0x80, 0x33, 0xE7, 0x14, 0x89, 0xED, 0xC7, 0x48, 
    0xD8, 0x57, 0x2E, 0x95, 0x4F, 0xD1, 0x72, 0xF5, 0x41, 0x66, 
    0x07, 0x98, 0x6E, 0xB0, 0x3F, 0x0A, 0xAC, 0x7F, 0x39, 0xB9, 
    0x89, 0x4C, 0xD5, 0x97, 0x26, 0x88, 0xB2, 0xED, 0x3E, 0x07, 
    0xF4, 0x1B, 0x93, 0x42, 0x1E, 0xE4, 0x9E, 0x4B, 0x14, 0x85, 
    0x2F, 0xFC, 0x6C, 0x9E, 0x80, 0xD4, 0x06, 0x6F, 0xD9, 0xBC, 0x4A, 

    0xA9, 0x5C, 0x20, 0xB9, 0x0A, 0xEE, 0xB6, 0x69, 0x90, 0x38,         // 55
    0xAB, 0x4F, 0xF0, 0x83, 0xBB, 0x71, 0x46, 0x22, 0xCC, 0x6F, 
    0xE3, 0x18, 0xD5, 0x91, 0xE1, 0x29, 0x71, 0xAB, 0x5A, 0x11, 
    0xFE, 0x57, 0xE1, 0x6B, 0xC2, 0x5E, 0xB2, 0x09, 0x7F, 0x9B, 
    0x12, 0xB1, 0xF8, 0x06, 0xB6, 0x33, 0x8E, 0x0B, 0xB4, 0x7E, 
    0xC0, 0x39, 0xEB, 0x1D, 0x8A, 0xFC, 0x57, 0xD5, 0x50, 0xF5, 
    0x2A, 0xB0, 0x0B, 0x74, 0xF5, 0x51, 0x2E, 0x60, 0x9C, 0xD5, 
    0x78, 0x4D, 0xC6, 0x73, 0xAF, 0x80, 0x5A, 0xF7, 0xB3, 0x65, 
    0xA4, 0x43, 0x01, 0xBA, 0x4C, 0x30, 0xB0, 0x45, 0x8F, 0x60, 0xE1, 

    0x0C, 0x8F, 0xF5, 0x66, 0x96, 0x36, 0x7B, 0x13, 0xF7, 0x1F,         // 56
    0x7C, 0xC0, 0x24, 0x65, 0x00, 0xF9, 0xC6, 0x9E, 0x53, 0x08, 
    0xAC, 0x64, 0x80, 0x52, 0x3B, 0xB3, 0xD4, 0x41, 0xE7, 0x82, 
    0xC1, 0x30, 0x0D, 0xA7, 0x1F, 0xFA, 0x45, 0xCF, 0x61, 0x2A, 
    0xEA, 0x6E, 0x3F, 0x81, 0xE3, 0x62, 0xC4, 0x57, 0xDD, 0x18, 
    0xF9, 0x5A, 0x80, 0xCC, 0x5E, 0xA1, 0x24, 0x8E, 0x00, 0xA4, 
    0x63, 0xE2, 0x40, 0xBD, 0x19, 0xA2, 0xDB, 0x84, 0x1E, 0xB6, 
    0x34, 0xA5, 0xE1, 0x00, 0x32, 0xCD, 0x17, 0x38, 0xD3, 0x1D, 
    0xC5, 0x7E, 0xDC, 0x28, 0xF3, 0xC6, 0x79, 0xEC, 0x19, 0x37, 0x7B, 

    0xC1, 0x42, 0x2A, 0xD4, 0x4A, 0xA6, 0xDE, 0x4E, 0xC2, 0x9C,         // 57
    0xE3, 0x40, 0xD9, 0xAD, 0x3E, 0x8E, 0x61, 0x30, 0xE8, 0x8C, 
    0x43, 0xFD, 0x2A, 0xA3, 0xEA, 0x1C, 0x65, 0x00, 0xA3, 0x23, 
    0x62, 0x9B, 0xD8, 0x83, 0x39, 0x9A, 0x78, 0x30, 0xE2, 0xBF, 
    0x4C, 0x94, 0xD3, 0x24, 0x9F, 0x13, 0xF1, 0x2E, 0x98, 0x4F, 
    0xA5, 0x2A, 0xBB, 0x04, 0xDA, 0x33, 0xE4, 0xBC, 0x6F, 0xD8, 
    0x15, 0x7E, 0x94, 0x59, 0xCD, 0x6A, 0x02, 0xC3, 0x57, 0xEA, 
    0x8D, 0x21, 0x60, 0x8B, 0xF2, 0x64, 0xAA, 0x8D, 0x72, 0x47, 
    0xE9, 0x56, 0x9B, 0x66, 0x8C, 0x5B, 0x0D, 0xAC, 0xD6, 0x9F, 0xF2, 

    0x54, 0xDD, 0xAD, 0x7F, 0x1B, 0xC8, 0x02, 0x94, 0x32, 0x5A,         // 58
    0x08, 0x69, 0x95, 0x16, 0xCC, 0xDF, 0x10, 0xB6, 0x75, 0xD6, 
    0x1A, 0xC5, 0xB1, 0x08, 0x73, 0x97, 0xF9, 0x8D, 0xD0, 0x4A, 
    0xF0, 0x73, 0x42, 0xBC, 0x63, 0xDD, 0x15, 0xA5, 0x86, 0x04, 
    0xA7, 0x19, 0x56, 0xB9, 0x73, 0x42, 0x87, 0xAF, 0x6F, 0x21, 
    0xD9, 0x8F, 0x48, 0x6E, 0x9A, 0x4F, 0x79, 0x1C, 0x44, 0x9B, 
    0x37, 0xFB, 0x21, 0xDD, 0x38, 0x8A, 0xF9, 0x32, 0x75, 0x0B, 
    0x49, 0xF8, 0xBA, 0x3D, 0xA1, 0x47, 0xDF, 0x05, 0xF1, 0x9D, 
    0x0C, 0x33, 0xAF, 0x10, 0xD2, 0x25, 0x97, 0x4F, 0x2C, 0x65, 0x15, 

    0x76, 0x98, 0x06, 0x64, 0xF0, 0x89, 0x5F, 0xF3, 0x74, 0xD6,         // 59
    0xB4, 0xFB, 0x2F, 0x74, 0x54, 0x85, 0x46, 0xF3, 0x23, 0x57, 
    0x9C, 0x76, 0x59, 0xDA, 0x45, 0xC8, 0x55, 0x37, 0x77, 0xBE, 
    0x09, 0xAC, 0x28, 0xF5, 0x02, 0xC7, 0x5A, 0xEF, 0x47, 0x70, 
    0xFC, 0x7D, 0xE0, 0x37, 0xEC, 0xC8, 0x5A, 0x01, 0xD3, 0xB7, 
    0x76, 0x15, 0xEF, 0xC6, 0x13, 0xF5, 0xAA, 0xCB, 0xEE, 0x5B, 
    0xC9, 0xAD, 0x67, 0x9F, 0x11, 0xB4, 0x54, 0x9C, 0xE4, 0xB2, 
    0xD3, 0x6D, 0x0F, 0xCF, 0x27, 0x84, 0xC1, 0x35, 0x5E, 0xBE, 
    0x84, 0xCD, 0x76, 0xE8, 0x3A, 0xB5, 0xFE, 0x74, 0xCA, 0x8B, 0xBC, 

    0x3E, 0xFB, 0x4C, 0xBD, 0x25, 0x3B, 0xBA, 0x27, 0xA4, 0x13,         // 60
    0x48, 0x80, 0xA9, 0xE5, 0xB7, 0x21, 0x9F, 0x6D, 0xAD, 0xCF, 
    0x3B, 0x10, 0xF0, 0x2E, 0x88, 0x18, 0xB8, 0x11, 0xE6, 0x32, 
    0x87, 0xDF, 0x53, 0x96, 0x7A, 0x36, 0x8D, 0xB9, 0x24, 0xC9, 
    0x35, 0xC1, 0x60, 0x07, 0xA1, 0x1C, 0x97, 0xFC, 0x4A, 0x35, 
    0xE3, 0x60, 0xA1, 0x3C, 0x89, 0x2D, 0x6A, 0x06, 0x8B, 0x26, 
    0x78, 0x09, 0x4C, 0xE7, 0x79, 0x45, 0xCF, 0x12, 0x86, 0x5A, 
    0x37, 0x9B, 0x80, 0x5E, 0xE5, 0x13, 0x70, 0x96, 0xDA, 0x22, 
    0x3F, 0xF9, 0x18, 0x4B, 0x88, 0x62, 0xD6, 0x42, 0x0B, 0xEC, 0x24, 

    0xA4, 0x1A, 0x8B, 0xD7, 0x9B, 0xE2, 0x80, 0x56, 0xE7, 0x8C,         // 61
    0xCD, 0x25, 0x5D, 0x04, 0x44, 0xED, 0xC9, 0x07, 0x4C, 0x87, 
    0xE2, 0xB9, 0x7F, 0x9E, 0xD5, 0x62, 0xF3, 0x9A, 0x6B, 0xA6, 
    0x5A, 0x1A, 0xCE, 0x23, 0xDC, 0xAB, 0x52, 0x0A, 0xDD, 0x62, 
    0x93, 0x13, 0xAC, 0x8A, 0x6C, 0xD0, 0x30, 0x67, 0x84, 0xA4, 
    0x0A, 0xBF, 0x23, 0x72, 0xE1, 0xCE, 0x51, 0xA2, 0x40, 0xBA, 
    0xEB, 0x97, 0xD2, 0x29, 0xBF, 0xF2, 0x2F, 0x6F, 0xC3, 0x19, 
    0xA9, 0x22, 0xF1, 0xB9, 0x4E, 0xB0, 0xFC, 0x1A, 0x50, 0xAC, 
    0x6C, 0x91, 0x59, 0xC3, 0xA5, 0x04, 0x31, 0x94, 0xAE, 0x57, 0xD2, 

    0x62, 0xE6, 0x74, 0x10, 0x68, 0x47, 0x0B, 0xC7, 0x1C, 0x41,         // 62
    0x67, 0xF2, 0x96, 0xD6, 0x7E, 0x66, 0x33, 0x90, 0xF7, 0x15, 
    0x2F, 0x63, 0x44, 0x05, 0xB2, 0x2A, 0x82, 0x40, 0xD7, 0x0D, 
    0xFB, 0x91, 0x70, 0xB8, 0x60, 0x2E, 0xF6, 0x76, 0xA1, 0x2B, 
    0xE8, 0x4C, 0xD8, 0x3D, 0xF5, 0x4D, 0xB1, 0xD8, 0x1F, 0xEC, 
    0x52, 0x80, 0xF9, 0x55, 0xAD, 0x1C, 0x7E, 0xFE, 0xD3, 0x5E, 
    0x15, 0x36, 0x6B, 0x90, 0x04, 0x5D, 0xA6, 0xDE, 0x48, 0xFE, 
    0x76, 0xD5, 0x43, 0x03, 0x9E, 0x37, 0x65, 0xCE, 0x82, 0xED, 
    0x02, 0xB4, 0xDF, 0x2D, 0xF2, 0x76, 0xBE, 0xE7, 0x78, 0x38, 0x87, 

    0xC4, 0x29, 0xAC, 0x38, 0xCD, 0xB4, 0xFD, 0x97, 0x72, 0xAC,         // 63
    0xC0, 0x10, 0x3C, 0xBA, 0x19, 0x9B, 0xDE, 0x5D, 0xBC, 0x76, 
    0x9F, 0xC9, 0xFB, 0x71, 0xE6, 0x54, 0xAF, 0x20, 0x5F, 0xB3, 
    0x47, 0xC3, 0x3A, 0x06, 0xEA, 0x90, 0x14, 0xCE, 0x46, 0x82, 
    0xB3, 0x7A, 0x1F, 0xBC, 0x29, 0x7F, 0x08, 0x8E, 0x44, 0xC1, 
    0x93, 0x2E, 0xD2, 0x02, 0x95, 0x38, 0xC1, 0x10, 0x2B, 0x89, 
    0xAA, 0xCA, 0xF9, 0x40, 0xAE, 0x83, 0x25, 0x93, 0x10, 0xB5, 
    0x2E, 0x5D, 0xC6, 0x72, 0x89, 0xDE, 0x0A, 0xA5, 0x27, 0x46, 
    0xD4, 0x34, 0x72, 0x13, 0x8E, 0x49, 0x1C, 0x5F, 0x27, 0xF8, 0x00, 

    0x4C, 0xD9, 0x55, 0xF4, 0x8D, 0x21, 0x5C, 0x3D, 0xEA, 0x2C,         // 64
    0x8E, 0xD3, 0x83, 0x59, 0xFE, 0x2E, 0xA9, 0x1D, 0x3E, 0xE8, 
    0x55, 0x26, 0x8C, 0x35, 0xC1, 0x10, 0x90, 0xEB, 0xC6, 0x7E, 
    0x29, 0xEB, 0x82, 0xA2, 0x49, 0xC5, 0x67, 0xB0, 0x21, 0xFA, 
    0x09, 0x54, 0xEB, 0x92, 0x5E, 0xE3, 0xC7, 0x6D, 0xDF, 0x0D, 
    0x66, 0xA8, 0x45, 0xBC, 0x6A, 0xF0, 0x5F, 0x9E, 0x72, 0xE7, 
    0x45, 0x77, 0x17, 0xBB, 0x51, 0xED, 0x67, 0xCB, 0x5B, 0x7F, 
    0xE5, 0x90, 0x1D, 0xEE, 0x27, 0xBD, 0x7E, 0x57, 0xC1, 0x8E, 
    0x64, 0x9D, 0xCC, 0x56, 0xAF, 0xE3, 0xC7, 0x89, 0xD7, 0xB2, 0x97, 

    0x1B, 0xA3, 0x7C, 0x0D, 0x63, 0xAE, 0x7E, 0x01, 0xCF, 0x54,         // 65
    0x18, 0x62, 0xE3, 0x09, 0xB2, 0x4E, 0x71, 0xD0, 0x85, 0x01, 
    0xB4, 0xD9, 0x12, 0xA5, 0x64, 0xDD, 0x32, 0x6E, 0x06, 0x53, 
    0xA4, 0x13, 0x63, 0xD5, 0x1F, 0x86, 0x34, 0xDF, 0x5E, 0x98, 
    0xD4, 0xC0, 0x73, 0x0D, 0xB6, 0x21, 0x99, 0x53, 0x2A, 0xB6, 
    0xF6, 0x15, 0x7B, 0xE8, 0x13, 0x85, 0x46, 0xD0, 0x33, 0xBE, 
    0x0C, 0x9F, 0x5F, 0xE2, 0x21, 0xC3, 0x0A, 0xE0, 0x3E, 0xA0, 
    0x07, 0xB9, 0x4A, 0xA7, 0x62, 0x3F, 0xF5, 0x32, 0xE1, 0x1E, 
    0xF0, 0x0B, 0x7D, 0xFC, 0x40, 0x08, 0xA0, 0x56, 0x0F, 0x44, 0x6B, 

    0x82, 0xEC, 0x39, 0xC3, 0xE8, 0x30, 0xDC, 0xBD, 0x9C, 0x7C,         // 66
    0xF7, 0xA8, 0x37, 0x76, 0xCC, 0x8A, 0x0D, 0xF5, 0xBE, 0x47, 
    0x96, 0x77, 0x52, 0xF4, 0x83, 0x4B, 0xB8, 0x9A, 0xF8, 0xD0, 
    0x88, 0xE0, 0x34, 0xB2, 0x56, 0xEB, 0xA1, 0x03, 0x7B, 0x2E, 
    0x4D, 0x24, 0xA9, 0x3A, 0xFE, 0x7B, 0x3F, 0xEE, 0xA3, 0x7D, 
    0x38, 0xD6, 0x50, 0xA1, 0x35, 0xDF, 0xAC, 0x05, 0xF7, 0x52, 
    0x82, 0xD3, 0x39, 0x88, 0xA2, 0x36, 0x7D, 0xAF, 0x29, 0xF6, 
    0x52, 0x77, 0xD9, 0x0C, 0x94, 0xCF, 0x12, 0x9F, 0x7C, 0x5A, 
    0xBA, 0x4B, 0xA7, 0x20, 0x93, 0x6D, 0x35, 0xD2, 0x7D, 0xF3, 0xBE, 

    0xD0, 0x07, 0x68, 0x95, 0x16, 0x4B, 0x89, 0x5F, 0x14, 0x2F,         // 67
    0xC7, 0x48, 0x96, 0x28, 0xF0, 0x40, 0xAF, 0x5B, 0x24, 0x6F, 
    0xF1, 0x21, 0xBB, 0x3A, 0x03, 0xCA, 0x1F, 0x61, 0x3A, 0x1B, 
    0x4D, 0xAB, 0x7D, 0xFD, 0x0E, 0x74, 0x41, 0xBC, 0xF2, 0xAD, 
    0x85, 0xEA, 0x67, 0x95, 0x4B, 0xD5, 0x00, 0xBF, 0x18, 0x59, 
    0x95, 0xC2, 0x1C, 0x8B, 0xBE, 0x5C, 0x23, 0x92, 0x67, 0xA7, 
    0x2B, 0xF1, 0xB6, 0x00, 0x70, 0xFB, 0x49, 0x98, 0x69, 0xCA, 
    0x21, 0xC3, 0x36, 0xFB, 0x6C, 0x48, 0xB7, 0x68, 0xD9, 0x11, 
    0x93, 0x2C, 0xE2, 0x63, 0xD5, 0xB9, 0xEC, 0x1B, 0xA7, 0x3C, 0x26, 

    0x8E, 0x48, 0xB8, 0xDA, 0x76, 0xA6, 0xF9, 0x3D, 0xE0, 0xAD,         // 68
    0x6E, 0x05, 0xD9, 0xBD, 0x68, 0x18, 0x92, 0xDB, 0xA2, 0x3B, 
    0xC4, 0x5E, 0xE1, 0xAA, 0x93, 0xEA, 0x7E, 0xD7, 0xB1, 0x75, 
    0xC4, 0x00, 0x5E, 0x2B, 0xBE, 0x96, 0xD6, 0x61, 0x1F, 0x3B, 
    0xC9, 0x05, 0xD1, 0x17, 0xB8, 0x60, 0x9B, 0x6C, 0xD7, 0x2F, 
    0xEF, 0x76, 0x61, 0xFB, 0x29, 0xD3, 0x78, 0xBB, 0x3F, 0xDF, 
    0x70, 0x1A, 0x4B, 0xCA, 0x55, 0xB3, 0x23, 0xE7, 0x0C, 0x86, 
    0xA1, 0x5C, 0x83, 0xA9, 0x1D, 0xE3, 0x88, 0x29, 0x4E, 0xC6, 
    0xF8, 0x6F, 0xBE, 0x34, 0x15, 0x74, 0x4A, 0x95, 0x5E, 0xDF, 0x66, 

    0xA4, 0xFC, 0x1E, 0x53, 0x2C, 0xCE, 0x09, 0x74, 0x96, 0x51,         // 69
    0xEB, 0x88, 0x56, 0x1F, 0xA1, 0xE8, 0x4C, 0x10, 0x7D, 0xE4, 
    0x07, 0x87, 0x17, 0x72, 0x27, 0x5B, 0x41, 0x0A, 0x8C, 0xF3, 
    0x37, 0xE8, 0x93, 0xD1, 0x68, 0x37, 0x13, 0x84, 0xDE, 0x91, 
    0x58, 0x77, 0x35, 0xEE, 0x80, 0x24, 0xF6, 0x3B, 0x86, 0xB0, 
    0x0F, 0x44, 0xB9, 0x03, 0x80, 0x4E, 0xF2, 0x19, 0xCE, 0x09, 
    0x97, 0xAF, 0x8B, 0xEC, 0x18, 0xD2, 0x81, 0x59, 0xD6, 0x45, 
    0xF0, 0x04, 0xD4, 0x2D, 0x76, 0xC7, 0x05, 0xF3, 0xAE, 0x3C, 
    0x81, 0x00, 0x51, 0x8C, 0xF1, 0xB0, 0x04, 0xCC, 0x28, 0xB7, 0x14, 

    0x35, 0x76, 0x9B, 0xE3, 0x8B, 0x5D, 0xB4, 0x28, 0xC8, 0x34,         // 70
    0x1C, 0xBA, 0xFA, 0x7D, 0x38, 0xCE, 0x70, 0xBE, 0x2F, 0xB2, 
    0x4D, 0xA1, 0xD4, 0x44, 0xFE, 0xC2, 0xA3, 0xE0, 0x56, 0x20, 
    0x6D, 0xA8, 0x1E, 0x44, 0xE6, 0xB4, 0xF3, 0x4D, 0xA7, 0x10, 
    0xFB, 0xB4, 0x9F, 0x56, 0xC6, 0x45, 0xAB, 0x0B, 0xE2, 0x72, 
    0xD1, 0x99, 0xE2, 0x3E, 0xB3, 0x9B, 0x36, 0x65, 0x88, 0x51, 
    0xFC, 0x5E, 0x39, 0x79, 0xA7, 0x33, 0x9C, 0x17, 0xB8, 0x2F, 
    0x70, 0xAD, 0x4A, 0xEC, 0x9E, 0x45, 0x5E, 0x91, 0x70, 0x1A, 
    0xA2, 0xE0, 0xCD, 0xA0, 0x3A, 0x81, 0x58, 0xF9, 0x8C, 0x72, 0xE9, 

    0x55, 0xD2, 0x03, 0x42, 0xAD, 0x1A, 0xEE, 0x82, 0xE6, 0x69,         // 71
    0x9F, 0x4A, 0x0D, 0xAB, 0x5A, 0x90, 0x28, 0xFC, 0x57, 0x8A, 
    0xF3, 0x32, 0x67, 0xB7, 0x81, 0x16, 0x72, 0x30, 0x9B, 0xC0, 
    0xDC, 0x53, 0x84, 0xAF, 0x07, 0x7D, 0x21, 0xC9, 0x6A, 0x40, 
    0xC2, 0x4A, 0x0C, 0x8A, 0x1C, 0xE0, 0x68, 0x93, 0x4E, 0x24, 
    0x60, 0x31, 0x86, 0x65, 0xEC, 0x15, 0xC1, 0xE7, 0xA4, 0x29, 
    0xC6, 0x1F, 0xE4, 0x0C, 0x5A, 0xDE, 0x66, 0xF7, 0x7B, 0x9D, 
    0xD0, 0x16, 0x89, 0x6B, 0x10, 0xB8, 0xDA, 0x30, 0xE4, 0xBC, 
    0x63, 0x28, 0x40, 0x6B, 0x11, 0xDB, 0xBC, 0x2F, 0x49, 0x09, 0xC7, 

    0x22, 0xB4, 0x63, 0xF4, 0x7C, 0xD6, 0x39, 0x51, 0x04, 0xAF,         // 72
    0x80, 0xE3, 0xCF, 0x2D, 0xC4, 0x12, 0xD7, 0x9D, 0x09, 0x6B, 
    0xC0, 0x1C, 0xDE, 0x0A, 0x96, 0x3A, 0xCB, 0xF6, 0x0F, 0x7D, 
    0x3C, 0x16, 0xD4, 0x66, 0xA4, 0x58, 0x95, 0x30, 0xD8, 0x86, 
    0x1F, 0x6F, 0xEB, 0xD6, 0x71, 0xBA, 0x30, 0xEC, 0xC8, 0xA1, 
    0xF8, 0xBF, 0x0A, 0xD7, 0x2A, 0x92, 0x73, 0x0B, 0x40, 0xB6, 
    0x70, 0x8F, 0xD0, 0x9B, 0xC1, 0x45, 0x03, 0xC4, 0x46, 0x1E, 
    0x5C, 0xF9, 0xB5, 0x37, 0xD1, 0x25, 0x7B, 0xA6, 0x09, 0x53, 
    0xEF, 0x83, 0xC1, 0xFC, 0xA8, 0x24, 0x6F, 0x99, 0xD4, 0xA7, 0x86, 

    0x6B, 0xE1, 0x8D, 0x30, 0x10, 0x69, 0x92, 0xB7, 0xD1, 0x5D,         // 73
    0x17, 0x3D, 0x6C, 0x86, 0xF1, 0x65, 0x7E, 0x3C, 0xBA, 0xDC, 
    0x42, 0x7B, 0xA0, 0x53, 0xF0, 0x63, 0xB0, 0x45, 0x69, 0xE3, 
    0xB3, 0x90, 0xEF, 0x2C, 0x46, 0xFA, 0xBB, 0x78, 0x01, 0xF2, 
    0x98, 0xCA, 0x26, 0xA9, 0x50, 0x03, 0x8B, 0x46, 0x1F, 0x80, 
    0x16, 0x4A, 0xA9, 0x7D, 0x5B, 0xC9, 0x4D, 0xDB, 0x7F, 0xEE, 
    0x03, 0x42, 0x68, 0x2E, 0x7C, 0xEF, 0x91, 0x6F, 0xAA, 0xE4, 
    0x93, 0x28, 0x51, 0xE1, 0x97, 0x59, 0xFD, 0x3E, 0x8D, 0xD5, 
    0x20, 0x9C, 0x07, 0x5D, 0x88, 0x48, 0xED, 0x19, 0x51, 0xF4, 0x3E, 

    0x9C, 0x18, 0x50, 0xCC, 0xBB, 0xA6, 0x1F, 0xFE, 0x43, 0x8D,         // 74
    0xF3, 0xC1, 0xA5, 0x01, 0x4C, 0xB3, 0x1F, 0xE7, 0x51, 0x19, 
    0x98, 0xED, 0x35, 0xBB, 0x23, 0xD9, 0x02, 0x8B, 0xA4, 0x31, 
    0x59, 0x04, 0xC2, 0x81, 0xB4, 0x11, 0x36, 0xE2, 0x51, 0xAC, 
    0x3E, 0x61, 0x83, 0x38, 0x9C, 0xFC, 0xD0, 0x73, 0xAC, 0x5C, 
    0xD9, 0x92, 0xD1, 0x34, 0xFD, 0x1A, 0xAD, 0x30, 0x9C, 0x55, 
    0xD6, 0xA8, 0xF6, 0x12, 0xB7, 0x3C, 0x1F, 0xDB, 0x39, 0x09, 
    0x68, 0xC9, 0x78, 0x01, 0x82, 0xC7, 0x12, 0x6B, 0xC2, 0x46, 
    0x73, 0x38, 0xB8, 0xE1, 0x34, 0xCD, 0xB3, 0x7E, 0x66, 0x0F, 0xC0, 

    0x77, 0xFB, 0xA4, 0x3C, 0xED, 0x5A, 0x36, 0x80, 0x0C, 0xA1,         // 75
    0x24, 0x55, 0x31, 0xDD, 0x97, 0x33, 0xC5, 0x92, 0x74, 0xAD, 
    0x62, 0x06, 0xD4, 0x69, 0x80, 0xA3, 0x50, 0xEB, 0x1A, 0xCD, 
    0xFC, 0x76, 0x4C, 0x1F, 0xE7, 0x70, 0xCD, 0xA1, 0x68, 0x23, 
    0xD4, 0x08, 0xF4, 0xBE, 0x19, 0x65, 0x2A, 0xB8, 0x08, 0xF3, 
    0x2D, 0x65, 0x0E, 0x51, 0x9F, 0x85, 0xE5, 0x64, 0x11, 0xBE, 
    0x25, 0x7D, 0x4E, 0xC7, 0x5B, 0x9F, 0xCE, 0x54, 0x8D, 0xBC, 
    0xEE, 0x40, 0xAB, 0xF4, 0x2C, 0x4E, 0xB2, 0xE5, 0x19, 0xA3, 
    0xF7, 0xCD, 0x53, 0x1D, 0x9E, 0x6A, 0x02, 0xD9, 0xA5, 0xE6, 0x2D, 

    0xD6, 0x0C, 0x65, 0x86, 0x01, 0x9A, 0xC4, 0xDF, 0x64, 0xD3,         // 76
    0x74, 0xE5, 0x8A, 0xBF, 0x72, 0xF9, 0x58, 0x07, 0xEE, 0x40, 
    0xCD, 0x87, 0x4B, 0x12, 0xC4, 0x28, 0x7A, 0xC7, 0x5E, 0x82, 
    0x27, 0x9D, 0xDE, 0xA7, 0x5B, 0x95, 0x4A, 0x0D, 0x8C, 0xE6, 
    0xB5, 0x90, 0x4E, 0x70, 0xE2, 0x8D, 0x52, 0xE9, 0x43, 0x97, 
    0xCA, 0x79, 0xEC, 0xB7, 0x6D, 0x00, 0x44, 0xCF, 0x76, 0xFA, 
    0x3B, 0x93, 0x1C, 0xE9, 0x88, 0x06, 0x6B, 0xFD, 0x2D, 0x79, 
    0x13, 0x99, 0x1C, 0x61, 0xD7, 0x9D, 0x76, 0x31, 0x8E, 0x5F, 
    0x0E, 0x80, 0xAC, 0x78, 0xF6, 0x2D, 0x94, 0x43, 0x21, 0x84, 0x4F, 

    0x3E, 0xB3, 0xD1, 0x2D, 0xE4, 0x74, 0x1C, 0x49, 0xAB, 0x33,         // 77
    0xB9, 0x09, 0x66, 0x1E, 0x43, 0x12, 0x85, 0xD3, 0x2B, 0xBB, 
    0x23, 0xFB, 0xA4, 0xDA, 0x8F, 0xF7, 0x41, 0x0E, 0xA7, 0x3E, 
    0xBE, 0x65, 0x0B, 0x3F, 0xC6, 0x2B, 0xF1, 0xBB, 0x2E, 0x75, 
    0x41, 0x14, 0xC7, 0x2F, 0xB2, 0x0A, 0xA1, 0xC6, 0x80, 0x12, 
    0x4F, 0xA2, 0x1E, 0xD7, 0x31, 0xF4, 0xB9, 0x8D, 0x1B, 0x9F, 
    0x63, 0xB3, 0xDA, 0x70, 0x2C, 0xAF, 0xC4, 0x1B, 0xAC, 0xDE, 
    0x53, 0xD5, 0x84, 0xBE, 0x36, 0x0D, 0xF0, 0x49, 0xD9, 0xC4, 
    0x2C, 0xEB, 0x3F, 0x09, 0xC6, 0x51, 0xBE, 0xF3, 0x5C, 0xCA, 0x97, 

    0x6B, 0x1F, 0x94, 0x4B, 0xAD, 0x55, 0xF0, 0x8D, 0x15, 0xF6,         // 78
    0x4F, 0x98, 0xEB, 0xAA, 0xDB, 0xC8, 0xA2, 0x5F, 0x7B, 0x99, 
    0x54, 0x7F, 0x1B, 0x6B, 0x30, 0x5C, 0xB0, 0xE1, 0x8B, 0xF2, 
    0x19, 0xD6, 0x8D, 0xF8, 0x72, 0x16, 0x84, 0x5E, 0xCF, 0xFD, 
    0x64, 0xAA, 0xEF, 0x5D, 0xDA, 0x78, 0x3F, 0x27, 0x61, 0xDD, 
    0xB8, 0x37, 0x8A, 0x4D, 0xA6, 0x7D, 0x23, 0x58, 0xEA, 0x35, 
    0xCD, 0x47, 0x0C, 0xA1, 0x55, 0xEF, 0x41, 0x87, 0x49, 0x69, 
    0xB8, 0x23, 0x4A, 0xEC, 0x6D, 0xB7, 0x87, 0x20, 0xA7, 0x71, 
    0x50, 0xBA, 0x91, 0x61, 0xE2, 0x84, 0x11, 0x72, 0xAC, 0x09, 0xE4, 

    0xBD, 0xF4, 0x7B, 0xDC, 0x11, 0xCB, 0x2A, 0xA3, 0x6B, 0xCC,         // 79
    0x7C, 0x24, 0x39, 0x5D, 0x89, 0x4A, 0x28, 0xF5, 0x35, 0xDB, 
    0x00, 0xBF, 0x3D, 0xEB, 0xAA, 0x17, 0xD1, 0x66, 0x2A, 0x70, 
    0x4C, 0xAC, 0x56, 0x32, 0x9F, 0xD7, 0xAB, 0x37, 0x03, 0x99, 
    0x1D, 0x83, 0x29, 0x96, 0x15, 0xA9, 0xFA, 0xCE, 0x93, 0x20, 
    0xF6, 0x6F, 0xCF, 0x08, 0x62, 0xDC, 0x3D, 0xA2, 0xBC, 0x05, 
    0x7C, 0xF3, 0xBF, 0x37, 0xD6, 0x7B, 0x0E, 0xE3, 0xA3, 0x03, 
    0xF8, 0x76, 0xA3, 0x07, 0x96, 0x3F, 0xD0, 0x58, 0xF9, 0x02, 
    0x8A, 0xD4, 0x24, 0xA2, 0x1A, 0xAE, 0x39, 0xE0, 0x28, 0x7E, 0x35, 

    0x51, 0x06, 0x63, 0x33, 0x9E, 0x81, 0x5D, 0xC0, 0x3D, 0x0E,         // 80
    0xAE, 0xD6, 0x9F, 0xFC, 0x1A, 0x73, 0xAF, 0x12, 0xB7, 0x66, 
    0xA0, 0xE6, 0x5D, 0xC6, 0x75, 0x89, 0x49, 0x03, 0xA3, 0xC3, 
    0xE4, 0x11, 0x7A, 0xCE, 0x07, 0x4D, 0xE8, 0x7A, 0xC5, 0x4B, 
    0xB5, 0xE4, 0x51, 0xD3, 0x37, 0x66, 0x49, 0x01, 0x71, 0xA6, 
    0x56, 0x13, 0xAD, 0xE8, 0x8F, 0xBE, 0x14, 0x6F, 0xE0, 0x5E, 
    0x91, 0x1A, 0x69, 0x8A, 0x1E, 0x9C, 0x63, 0xBA, 0x2D, 0x90, 
    0x3C, 0xD9, 0x2B, 0xC3, 0x5B, 0xE6, 0x15, 0x77, 0x99, 0x47, 
    0xE8, 0x38, 0x79, 0xFE, 0x45, 0x68, 0xD1, 0x91, 0x5A, 0xFB, 0xA2, 

    0x87, 0xD0, 0xB6, 0xEF, 0x48, 0xD8, 0x05, 0xFB, 0x84, 0xE1,         // 81
    0x53, 0x6F, 0x02, 0x47, 0xB9, 0xE0, 0x92, 0x55, 0xEA, 0x3F, 
    0x77, 0x22, 0x94, 0x0D, 0x35, 0xE0, 0xBA, 0xFC, 0x7E, 0x38, 
    0x8F, 0x2B, 0xED, 0xB4, 0x8C, 0x70, 0x1E, 0x95, 0x5B, 0xDA, 
    0x39, 0x74, 0x08, 0xBB, 0x84, 0xE9, 0x8E, 0xBF, 0xE4, 0x33, 
    0xD7, 0x94, 0x2F, 0x5C, 0x23, 0x4C, 0xF8, 0x8B, 0x42, 0x27, 
    0xD1, 0xAF, 0x4D, 0xEB, 0xC6, 0x3D, 0xFA, 0x4F, 0xD2, 0x6D, 
    0xB2, 0x58, 0x85, 0xF1, 0x33, 0x8A, 0xBD, 0x32, 0xCC, 0x1C, 
    0xB5, 0x5C, 0x0F, 0xB7, 0xD9, 0x8A, 0x26, 0xB4, 0x3D, 0xCC, 0x1E, 

    0xEA, 0x42, 0x27, 0x8B, 0x19, 0x70, 0xAF, 0x43, 0x20, 0x99,         // 82
    0x30, 0xE8, 0x85, 0xCE, 0x65, 0x0D, 0x3C, 0xCA, 0x87, 0x0B, 
    0xCF, 0xB6, 0x4C, 0xF4, 0x64, 0x9B, 0x2D, 0x5D, 0x1C, 0xD1, 
    0x67, 0xA5, 0x5B, 0x3F, 0x27, 0xF7, 0xBE, 0x35, 0xF1, 0x10, 
    0x8E, 0xC7, 0xF9, 0x6B, 0x28, 0xB0, 0x16, 0x61, 0x24, 0x7E, 
    0x45, 0xC3, 0x77, 0xF1, 0xCB, 0x80, 0xA8, 0x0E, 0xC9, 0x9B, 
    0xFD, 0x33, 0xA2, 0x01, 0x77, 0xA9, 0x12, 0x82, 0x25, 0xE9, 
    0x10, 0xCF, 0x1C, 0x6D, 0xAC, 0x10, 0x62, 0xE1, 0xA0, 0x6A, 
    0x84, 0xCE, 0x97, 0x32, 0x60, 0x0C, 0xE6, 0x74, 0x01, 0x97, 0x64, 

    0x0F, 0x71, 0xAE, 0x5C, 0xCD, 0xEB, 0x55, 0xA5, 0xD0, 0x61,         // 83
    0xBF, 0x1A, 0xA8, 0x35, 0x97, 0xF2, 0x77, 0x26, 0xA8, 0x62, 
    0xFE, 0x29, 0x7D, 0xCC, 0xB1, 0x15, 0x8C, 0xD8, 0xB7, 0x4B, 
    0xF4, 0x04, 0xBF, 0xDB, 0x9D, 0x51, 0x13, 0xAE, 0x69, 0xA0, 
    0x2F, 0x53, 0x21, 0xAD, 0x58, 0xD9, 0x3D, 0xEF, 0x9A, 0xB6, 
    0xFE, 0x0E, 0x3C, 0xA4, 0x02, 0x38, 0x65, 0xEA, 0x7C, 0x54, 
    0x0A, 0x8C, 0x61, 0xD4, 0x2B, 0x65, 0xDD, 0xC3, 0xA1, 0x48, 
    0x8C, 0x37, 0xA2, 0xD8, 0x45, 0xFC, 0x95, 0x48, 0x07, 0xF5, 
    0x2B, 0x45, 0xEC, 0x7E, 0xC8, 0x9E, 0x48, 0xBF, 0xEF, 0x4C, 0xB0, 

    0xC9, 0x91, 0xF9, 0x09, 0x9B, 0x2B, 0x89, 0x18, 0x7B, 0xF4,         // 84
    0x45, 0x73, 0xED, 0x5D, 0x20, 0xB1, 0xD3, 0x5C, 0xE4, 0x1A, 
    0x90, 0x3D, 0xA3, 0x04, 0x52, 0xE3, 0x46, 0x6C, 0x0D, 0x95, 
    0x78, 0x36, 0x88, 0x1F, 0x6B, 0xC8, 0xE1, 0x80, 0x43, 0xD4, 
    0xB7, 0x7D, 0xDD, 0x9B, 0x05, 0x80, 0xC9, 0x73, 0x0A, 0x4D, 
    0x6C, 0x8E, 0xDC, 0x53, 0x95, 0xE0, 0xBB, 0x20, 0x39, 0xC3, 
    0x71, 0xDE, 0x42, 0xBB, 0xF5, 0x9C, 0x33, 0x58, 0x05, 0x73, 
    0xF7, 0xBC, 0x62, 0x00, 0x84, 0xBA, 0x21, 0x7B, 0xC0, 0x5E, 
    0xD6, 0xAA, 0x03, 0x53, 0x2A, 0xF7, 0x20, 0x5E, 0x89, 0x2F, 0xDE, 

    0x1C, 0x54, 0x3C, 0xC7, 0x73, 0x45, 0xC3, 0xE3, 0x37, 0x0E,         // 85
    0xAF, 0x91, 0x08, 0xD9, 0x81, 0x3F, 0x03, 0x98, 0x47, 0xBB, 
    0x71, 0xD8, 0x5D, 0xE9, 0x76, 0x24, 0xC0, 0xF7, 0xA7, 0x27, 
    0xDF, 0xCB, 0x60, 0xF1, 0x8F, 0x07, 0x5F, 0x28, 0x96, 0x00, 
    0xF5, 0x18, 0x60, 0x34, 0xF2, 0x49, 0x9E, 0x33, 0xBD, 0xE2, 
    0x29, 0xAD, 0x1E, 0xBF, 0x76, 0x17, 0x5D, 0x91, 0xAC, 0xE6, 
    0x2E, 0xA9, 0x17, 0x84, 0x0D, 0x4D, 0x7D, 0xF1, 0xB8, 0xD5, 
    0x21, 0x4D, 0x94, 0xEC, 0x2E, 0x54, 0xCE, 0xE6, 0x28, 0x91, 
    0x15, 0x71, 0x99, 0xDB, 0xB5, 0x6F, 0x95, 0xD8, 0x12, 0xA9, 0x6A, 

    0xA0, 0x7F, 0xDA, 0x1E, 0xA9, 0xF4, 0x00, 0x68, 0x9E, 0xD8,         // 86
    0x5A, 0x30, 0xC5, 0xA4, 0x4F, 0xF8, 0xBD, 0x7C, 0x30, 0xEF, 
    0x0A, 0xC1, 0x21, 0x8D, 0xAF, 0x9D, 0x34, 0x81, 0x40, 0x68, 
    0xB1, 0x48, 0x0D, 0xB8, 0x44, 0xA8, 0xFE, 0xBA, 0xDC, 0x68, 
    0x4A, 0xA6, 0x8A, 0xC3, 0x72, 0xB1, 0x19, 0xF7, 0x58, 0x7B, 
    0xCD, 0x49, 0x66, 0xEA, 0x43, 0xC8, 0xFB, 0x46, 0x74, 0x19, 
    0x8F, 0x51, 0xE5, 0x68, 0xAD, 0xCE, 0x1D, 0x8E, 0x31, 0x5F, 
    0x84, 0xDE, 0x14, 0xCB, 0x6F, 0xAD, 0x0A, 0x66, 0xA9, 0x46, 
    0xB8, 0xFB, 0x26, 0x62, 0x3E, 0x0D, 0xBC, 0x42, 0x78, 0xFD, 0x46, 

    0xE2, 0xB3, 0x2E, 0x67, 0x8F, 0x56, 0xBA, 0x8D, 0x4A, 0xC1,         // 87
    0x7F, 0xFB, 0x46, 0x1A, 0x8D, 0x6B, 0x22, 0xDE, 0xA2, 0x64, 
    0x95, 0x4F, 0xF9, 0x39, 0x12, 0x5A, 0xEB, 0x01, 0xC9, 0xE7, 
    0x15, 0xA0, 0x7E, 0xE1, 0x2F, 0x85, 0x55, 0x3A, 0x20, 0x8F, 
    0xC9, 0x31, 0xEC, 0x0E, 0x3E, 0xD1, 0x5F, 0x90, 0x25, 0xA1, 
    0x05, 0xF5, 0x99, 0x13, 0x86, 0x2F, 0xA8, 0x0B, 0xCE, 0xEF, 
    0x6B, 0xC9, 0x26, 0x9D, 0x34, 0xED, 0xBB, 0x67, 0xA7, 0x0B, 
    0xB3, 0x3F, 0x75, 0xB5, 0x39, 0x8A, 0xF5, 0x3D, 0x84, 0xE9, 
    0x5B, 0x38, 0xC9, 0x8D, 0xF1, 0x81, 0xE8, 0x23, 0xCA, 0x90, 0x07, 

    0x62, 0x44, 0xF6, 0xC5, 0x14, 0xDE, 0x24, 0x3C, 0xEC, 0x13,         // 88
    0x29, 0x9A, 0x74, 0xD4, 0xB6, 0x38, 0xD0, 0x54, 0x11, 0xB8, 
    0x25, 0x7C, 0xAA, 0x6F, 0xDD, 0xC2, 0x74, 0x98, 0x4D, 0x87, 
    0x5D, 0xFA, 0x24, 0x6A, 0xC4, 0x16, 0xD0, 0xA4, 0x7A, 0xF0, 
    0x15, 0x6D, 0xAC, 0x56, 0xE0, 0x84, 0x0B, 0xB6, 0xDE, 0x42, 
    0xC2, 0x7E, 0x36, 0xB5, 0xD5, 0x68, 0x95, 0x5B, 0xB6, 0x42, 
    0x02, 0xB4, 0xFC, 0x47, 0x76, 0x06, 0x50, 0xE1, 0x42, 0xCA, 
    0xFE, 0x9F, 0x2C, 0xF0, 0x5E, 0x1C, 0x9A, 0xCF, 0x2D, 0x10, 
    0xD7, 0x81, 0x08, 0xB1, 0x21, 0x4C, 0x9E, 0x6C, 0x51, 0x2E, 0xC2, 

    0x21, 0xAD, 0x0A, 0x7E, 0x4F, 0xA1, 0x79, 0xCE, 0x6F, 0xA8,         // 89
    0x5F, 0xE3, 0x04, 0x5B, 0xEB, 0x0B, 0x97, 0x77, 0xF4, 0x3F, 
    0xE5, 0xD0, 0x08, 0x4B, 0xA0, 0x43, 0x2A, 0xD6, 0x1D, 0xBF, 
    0x36, 0x8F, 0xD3, 0x53, 0xA1, 0x75, 0xE4, 0x08, 0x5C, 0xB7, 
    0x4E, 0xD2, 0x7F, 0x1F, 0x99, 0x30, 0xED, 0x6D, 0x52, 0x8B, 
    0x20, 0x68, 0xE0, 0x50, 0x03, 0xF4, 0x1D, 0xDE, 0x2A, 0x9D, 
    0x83, 0x5F, 0x18, 0x89, 0xDB, 0xB3, 0x90, 0x17, 0x9B, 0x76, 
    0x13, 0x50, 0x8D, 0x08, 0xDA, 0xBD, 0x50, 0x6E, 0xBB, 0x98, 
    0x6A, 0xA8, 0x50, 0xD6, 0x72, 0xE2, 0x05, 0xD3, 0xA9, 0xF2, 0x79, 

    0xE7, 0x93, 0x69, 0xEA, 0xB6, 0x32, 0xFD, 0x09, 0x93, 0x34,         // 90
    0xB2, 0xC4, 0x44, 0x9E, 0x7E, 0x50, 0xAD, 0x26, 0xC2, 0x8C, 
    0x6E, 0x32, 0xBE, 0xEE, 0x87, 0x0F, 0xF7, 0xA7, 0x65, 0xEE, 
    0x0B, 0xB2, 0x43, 0x02, 0xF4, 0x28, 0x3C, 0x90, 0xCB, 0x2B, 
    0x9A, 0x04, 0xE3, 0xC0, 0x61, 0xA7, 0x48, 0xC4, 0x11, 0xFC, 
    0xA8, 0xCA, 0x2D, 0xA3, 0x76, 0xBA, 0x47, 0x8A, 0x6D, 0xCB, 
    0xF2, 0x38, 0xA5, 0xC7, 0x57, 0x38, 0x6A, 0xF4, 0x2D, 0xDB, 
    0x64, 0xB6, 0xD2, 0x6D, 0xA6, 0x37, 0xE6, 0x05, 0xF8, 0x4B, 
    0x1B, 0xE9, 0x2A, 0x93, 0x3E, 0xBF, 0x5C, 0x86, 0x17, 0x47, 0x9D, 
};

const BYTE HT_SuperCell_BlueMono[91*91] = {
    0xE3, 0xAB, 0x6E, 0x4F, 0xBB, 0xEA, 0x9A, 0x02, 0xCD, 0x4D,         //  0
    0xDC, 0x1E, 0xF8, 0x5D, 0xE3, 0x3C, 0x67, 0x8C, 0xC8, 0xFB, 
    0x2B, 0xD8, 0xBC, 0x6B, 0x91, 0x54, 0xF0, 0x14, 0xAB, 0x1E, 
    0xF5, 0x03, 0x79, 0x9C, 0x55, 0xBA, 0x1F, 0xA5, 0x53, 0xCA, 
    0x72, 0xB3, 0x7B, 0xF8, 0x9E, 0x2D, 0x8B, 0x0E, 0x9F, 0x4F, 
    0xCE, 0x93, 0x0C, 0x48, 0xBB, 0x02, 0x74, 0x54, 0xC8, 0xE8, 
    0x95, 0x20, 0xEB, 0xA6, 0x66, 0xD5, 0x5B, 0x86, 0x9D, 0x57, 
    0x18, 0x90, 0xE9, 0x83, 0xBD, 0x2E, 0x94, 0xD6, 0x7D, 0x99, 
    0xEB, 0xA4, 0x6E, 0x42, 0x22, 0xCC, 0x0F, 0x68, 0xE0, 0x05, 0xB8, 

    0x80, 0x10, 0xF3, 0x33, 0x7E, 0x1C, 0x64, 0xF9, 0x33, 0xA1,         //  1
    0x6A, 0x83, 0x36, 0xC5, 0x71, 0xB6, 0xF0, 0x52, 0x00, 0x97, 
    0x81, 0x10, 0xF0, 0x3A, 0xA8, 0x02, 0xCC, 0x3E, 0xE0, 0x5A, 
    0x94, 0x67, 0xC4, 0x21, 0xE0, 0x88, 0x65, 0xED, 0x0B, 0x8F, 
    0x23, 0x3D, 0xC1, 0x1C, 0x70, 0xEA, 0x5A, 0xDC, 0x6C, 0x1D, 
    0xEF, 0x36, 0x7A, 0xD0, 0x61, 0x9D, 0xED, 0x35, 0xAA, 0x07, 
    0x42, 0xD1, 0x75, 0x17, 0xBE, 0x08, 0xFC, 0x34, 0xD0, 0x74, 
    0xF4, 0xC0, 0x26, 0x4A, 0x07, 0xE1, 0x6B, 0x45, 0x03, 0x61, 
    0x28, 0x86, 0x0C, 0xDD, 0x93, 0x75, 0xAA, 0x2C, 0x53, 0x8D, 0x49, 

    0xCD, 0x61, 0x93, 0xC9, 0xE3, 0x3F, 0xB1, 0x81, 0x5E, 0xE6,         //  2
    0x0A, 0xD3, 0xAC, 0x21, 0x8B, 0x11, 0x2F, 0xD8, 0xA6, 0x3A, 
    0x5F, 0xA9, 0x75, 0x1B, 0xE1, 0x81, 0x63, 0xB0, 0x77, 0xA2, 
    0x25, 0xD6, 0x34, 0xB0, 0x6C, 0x07, 0xC3, 0x35, 0xD3, 0xA8, 
    0x63, 0xD9, 0x93, 0x5B, 0xC7, 0x09, 0xA8, 0x41, 0xAF, 0xBF, 
    0x75, 0xA2, 0xDE, 0x28, 0x81, 0x40, 0xCB, 0x14, 0xBA, 0x85, 
    0x6D, 0xA2, 0x48, 0x8B, 0xDE, 0x4B, 0x71, 0xAB, 0x14, 0x47, 
    0xAE, 0x38, 0x79, 0xAA, 0xCB, 0x87, 0x19, 0xF5, 0xAA, 0xC4, 
    0x4B, 0xFB, 0xBA, 0x65, 0x49, 0xF0, 0x3D, 0xB9, 0xF8, 0xA0, 0x1F, 

    0x31, 0xB1, 0x24, 0x58, 0x06, 0x8E, 0xD4, 0x18, 0xBF, 0x2A,         //  3
    0x96, 0x41, 0x5B, 0xEA, 0xBE, 0x60, 0x9B, 0x79, 0x1F, 0xC0, 
    0xE8, 0x43, 0x96, 0xC8, 0x4B, 0x9B, 0x25, 0xFD, 0x09, 0x3A, 
    0xB9, 0x53, 0xF9, 0x8F, 0x46, 0xE8, 0x9E, 0x58, 0x88, 0x42, 
    0xF3, 0x01, 0x46, 0xE5, 0x39, 0x91, 0x7B, 0x26, 0xEB, 0x00, 
    0x3C, 0x5C, 0x0F, 0xAE, 0xE7, 0x1D, 0x8B, 0x63, 0xF9, 0x4E, 
    0xD9, 0x0F, 0xF0, 0x28, 0xB1, 0x80, 0x20, 0xC9, 0xE7, 0x87, 
    0x04, 0xDF, 0x55, 0xFE, 0x62, 0x33, 0x9E, 0xBC, 0x20, 0xDD, 
    0x76, 0x34, 0x9E, 0x20, 0xD6, 0x07, 0x80, 0xD1, 0x12, 0x6D, 0xE7, 

    0x52, 0xFE, 0x79, 0xA4, 0xC2, 0x6D, 0x48, 0xE4, 0x52, 0x86,         //  4
    0xF5, 0xB8, 0x76, 0x06, 0x48, 0xFC, 0xC7, 0x50, 0xF1, 0x6C, 
    0x0A, 0xD4, 0x22, 0x64, 0xF3, 0x34, 0xC4, 0x57, 0xD7, 0x84, 
    0xEB, 0x0C, 0x7B, 0x1C, 0xD1, 0x2E, 0x7A, 0x12, 0xE0, 0x25, 
    0x76, 0xBA, 0x80, 0xAD, 0x23, 0xFA, 0x4F, 0xD5, 0x63, 0x88, 
    0xCD, 0xFB, 0x8F, 0x4B, 0xBD, 0x55, 0xA4, 0xD5, 0x3B, 0x1C, 
    0xAF, 0x57, 0xC2, 0x66, 0x38, 0xF3, 0x95, 0x40, 0x5C, 0xB8, 
    0x6A, 0x9D, 0x1C, 0xBA, 0x0D, 0xD4, 0x72, 0x52, 0x39, 0x9B, 
    0x13, 0xC9, 0x57, 0x7E, 0xC0, 0x9B, 0x5C, 0x2A, 0x87, 0x46, 0xBA, 

    0x80, 0xD2, 0x0F, 0x3B, 0xF1, 0x25, 0x9B, 0x0A, 0xA4, 0x6B,         //  5
    0x12, 0x35, 0xDE, 0xA5, 0x81, 0x31, 0x0C, 0x93, 0x3D, 0xB3, 
    0x88, 0x54, 0xB0, 0x7E, 0x07, 0xB5, 0x73, 0x1B, 0xAB, 0x45, 
    0x6A, 0xCE, 0xA1, 0x5F, 0xB5, 0x52, 0xF0, 0xC1, 0x69, 0x9C, 
    0xCB, 0x56, 0x12, 0xCF, 0x64, 0x9B, 0xC0, 0x11, 0x9F, 0x47, 
    0xB4, 0x18, 0x6A, 0x2C, 0xF1, 0x05, 0x71, 0x26, 0x9D, 0x79, 
    0xE6, 0x8A, 0x20, 0x99, 0xD4, 0x05, 0x6E, 0xA6, 0x11, 0xF8, 
    0x25, 0xD7, 0x82, 0x3D, 0x91, 0x47, 0xEF, 0x8A, 0xE6, 0x62, 
    0x85, 0xE2, 0x0B, 0xEB, 0x27, 0x3F, 0xB5, 0xE5, 0xAB, 0xDC, 0x01, 

    0x42, 0xAC, 0x65, 0x92, 0x53, 0xCB, 0x7D, 0xFC, 0x3F, 0xD8,         //  6
    0xC1, 0x51, 0x94, 0x2A, 0xD0, 0xB2, 0x6B, 0xD5, 0x16, 0xE0, 
    0x27, 0xFB, 0x33, 0xDA, 0x91, 0x40, 0xE8, 0x88, 0xC9, 0x12, 
    0x95, 0x2B, 0x3F, 0xF3, 0x02, 0x94, 0x22, 0xAD, 0x3A, 0x09, 
    0xFD, 0x3C, 0x90, 0xED, 0x19, 0x40, 0x80, 0x32, 0xF4, 0x71, 
    0x35, 0xE4, 0xC6, 0x9F, 0x81, 0xD7, 0xB0, 0xF4, 0x5D, 0xCB, 
    0x01, 0x40, 0xFC, 0x77, 0x4F, 0xB4, 0xE6, 0x2C, 0xCD, 0x7B, 
    0x51, 0x34, 0xC0, 0x69, 0xDB, 0xAE, 0x30, 0x09, 0xCB, 0x23, 
    0xB9, 0x46, 0xA5, 0x68, 0x92, 0xFC, 0x6A, 0x14, 0x39, 0x62, 0x9A, 

    0xD8, 0x18, 0xBD, 0xE4, 0x15, 0xAE, 0x36, 0x5D, 0xB5, 0x2B,         //  7
    0x7B, 0xEB, 0x16, 0x75, 0x55, 0xE4, 0x42, 0xAD, 0x7D, 0x5E, 
    0x9D, 0x70, 0xBD, 0x19, 0x58, 0xCF, 0x63, 0x34, 0xF7, 0x54, 
    0xBD, 0xE8, 0x80, 0xC3, 0x6B, 0xD4, 0x82, 0x4E, 0xE5, 0x8A, 
    0x62, 0xA4, 0x29, 0x70, 0xAC, 0xE2, 0x5A, 0xC8, 0xAD, 0x07, 
    0x9B, 0x7A, 0x52, 0x10, 0x36, 0x65, 0x43, 0x11, 0x88, 0x31, 
    0xBA, 0x6B, 0xAE, 0x14, 0xC4, 0x34, 0x61, 0x8C, 0x47, 0xAF, 
    0xE3, 0x99, 0x0A, 0xF3, 0x17, 0x5D, 0xC6, 0x6D, 0xA3, 0x3F, 
    0xF9, 0x78, 0x2D, 0xD4, 0x51, 0x04, 0xBE, 0x7F, 0xF4, 0xC4, 0x2C, 

    0xEF, 0x56, 0x8A, 0x32, 0x79, 0xEB, 0x0E, 0xD2, 0x88, 0x01,         //  8
    0x99, 0x5F, 0xB1, 0xF4, 0x05, 0x89, 0x1F, 0xF8, 0x31, 0xC4, 
    0x03, 0x49, 0x89, 0xE3, 0x9C, 0x2A, 0xA5, 0x00, 0x78, 0xAC, 
    0x21, 0x68, 0x0F, 0xA6, 0x2F, 0x58, 0xF7, 0x12, 0x72, 0xB9, 
    0x1F, 0xE3, 0xC3, 0x4F, 0xCC, 0x0F, 0x8D, 0x24, 0xDE, 0x62, 
    0xD0, 0x1C, 0xAF, 0xE9, 0xCE, 0x97, 0xBE, 0xDF, 0x51, 0xED, 
    0x92, 0x4C, 0xD8, 0x2E, 0xED, 0x7F, 0x9E, 0x1B, 0xEF, 0x00, 
    0x6B, 0xC8, 0x85, 0x45, 0xAB, 0x81, 0x24, 0xF4, 0x8D, 0x5C, 
    0x00, 0x96, 0xC6, 0x1A, 0x80, 0xDB, 0x97, 0x4F, 0x1A, 0x91, 0x73, 

    0xAD, 0x29, 0xCF, 0x62, 0xC6, 0x4A, 0x96, 0x6A, 0xEF, 0x4C,         //  9
    0xE1, 0x35, 0xCD, 0x4B, 0xA0, 0xC8, 0x67, 0x94, 0x4E, 0xD9, 
    0xAE, 0xEE, 0x37, 0x68, 0x0B, 0xEA, 0xC3, 0x90, 0xD9, 0x3E, 
    0xE2, 0x91, 0x4B, 0xD7, 0x97, 0x1C, 0xAF, 0xC5, 0x33, 0xD8, 
    0x56, 0x97, 0x03, 0x89, 0x32, 0xF7, 0x6D, 0x9D, 0x3E, 0x89, 
    0x2E, 0xF7, 0x43, 0x7D, 0x58, 0x19, 0x2F, 0x6D, 0xA4, 0x27, 
    0xCE, 0x0D, 0x79, 0xA4, 0x5D, 0x09, 0xB7, 0xCA, 0x58, 0x93, 
    0x39, 0x20, 0x59, 0xD1, 0x2E, 0xE1, 0xB2, 0x4F, 0x13, 0xDF, 
    0xB0, 0x6D, 0x3B, 0xE9, 0xB4, 0x45, 0x25, 0xE8, 0xA8, 0x5C, 0x08, 

    0x49, 0x7C, 0xFA, 0x03, 0xA2, 0x25, 0xA9, 0x39, 0x19, 0xC8,         // 10
    0xA3, 0x17, 0x6C, 0x28, 0x80, 0x3C, 0xEB, 0x0E, 0xA4, 0x28, 
    0x76, 0x18, 0xCF, 0xB8, 0x80, 0x55, 0x41, 0x6C, 0x23, 0x5D, 
    0xC0, 0x19, 0xFC, 0x71, 0x40, 0xE5, 0x7E, 0x48, 0x9D, 0x0B, 
    0x7B, 0x3D, 0xF1, 0x69, 0xA2, 0x43, 0xC1, 0x09, 0xF0, 0x57, 
    0xB8, 0x6D, 0x91, 0x02, 0xB6, 0xFE, 0x83, 0xD6, 0x07, 0x8B, 
    0x5E, 0xF7, 0x3E, 0x89, 0xDE, 0x45, 0xFB, 0x36, 0x79, 0xD3, 
    0xE7, 0xB1, 0xFC, 0x93, 0x6C, 0x04, 0x40, 0xD4, 0x77, 0xBE, 
    0x1E, 0xF0, 0x56, 0x9C, 0x10, 0x68, 0xC7, 0x72, 0x3E, 0xE0, 0xCC, 

    0xB6, 0x1A, 0x98, 0x4F, 0xDB, 0x6E, 0xF8, 0x7F, 0xAF, 0x57,         // 11
    0x79, 0x8F, 0xFE, 0xAE, 0xDA, 0x1C, 0xAD, 0x57, 0x83, 0xF5, 
    0x5E, 0x9A, 0x4F, 0x23, 0xFE, 0x97, 0x1A, 0xF2, 0xCD, 0x9C, 
    0x2E, 0x7C, 0xB2, 0x04, 0xA8, 0x5F, 0x0E, 0xDC, 0x63, 0xF9, 
    0xB1, 0xD2, 0x29, 0xBD, 0x12, 0x7F, 0x54, 0xD4, 0xB0, 0x17, 
    0xDF, 0x24, 0xC8, 0xE6, 0x38, 0x5F, 0xAB, 0x48, 0xC3, 0x39, 
    0xB9, 0x99, 0x22, 0xC7, 0x18, 0x73, 0x96, 0x22, 0xA3, 0x0F, 
    0x43, 0x83, 0x0B, 0x48, 0xB9, 0xF0, 0x8C, 0xA0, 0x32, 0x60, 
    0x8E, 0x2E, 0xD2, 0x77, 0x34, 0xF3, 0xAB, 0x0A, 0x9C, 0x31, 0x86, 

    0xE7, 0x6C, 0xC3, 0x33, 0x87, 0x16, 0x53, 0xC4, 0x2D, 0xD9,         // 12
    0x0E, 0x4A, 0xC2, 0x08, 0x54, 0x71, 0xD5, 0xBF, 0x35, 0xCA, 
    0x0D, 0xE8, 0x7C, 0xAC, 0x3C, 0xD4, 0x77, 0xB4, 0x06, 0x85, 
    0xE7, 0x50, 0xD0, 0x37, 0xF1, 0x95, 0xCC, 0x36, 0x8C, 0x21, 
    0x4B, 0x94, 0x5B, 0xE9, 0xAB, 0xD8, 0x21, 0x87, 0x48, 0x7D, 
    0x9D, 0x61, 0x3F, 0xAA, 0x76, 0x16, 0xE2, 0x23, 0xF4, 0x74, 
    0x0F, 0x66, 0xE9, 0x5B, 0xB3, 0xD3, 0x4D, 0xE6, 0x62, 0xC3, 
    0x6F, 0xA2, 0x61, 0xCB, 0x26, 0x76, 0x58, 0x17, 0xFD, 0xC8, 
    0x49, 0xA6, 0x14, 0xC1, 0x8A, 0xD5, 0x4A, 0x80, 0xFC, 0x66, 0x11, 

    0x43, 0x2A, 0xEE, 0x5E, 0xB1, 0xE4, 0x97, 0x08, 0xED, 0x63,         // 13
    0xB7, 0xE8, 0x39, 0x89, 0xF0, 0x95, 0x49, 0x01, 0x77, 0x97, 
    0x46, 0xB3, 0x1B, 0xDE, 0x60, 0x0A, 0x9F, 0x32, 0x49, 0x66, 
    0xB9, 0x17, 0x6F, 0x8D, 0x56, 0x1E, 0x78, 0xA7, 0xE7, 0x71, 
    0xC0, 0x0F, 0x84, 0x25, 0x40, 0x63, 0xFD, 0xA5, 0x28, 0xCF, 
    0x07, 0xF6, 0x86, 0x0E, 0xD8, 0xC1, 0x94, 0x7E, 0x51, 0xAB, 
    0xDD, 0xC0, 0x43, 0x8E, 0x34, 0x02, 0x87, 0xB5, 0x1B, 0xF4, 
    0x2C, 0xDE, 0x17, 0xEC, 0xAE, 0x3D, 0xDD, 0xB3, 0x7B, 0x05, 
    0xDB, 0x6B, 0xF6, 0x54, 0x02, 0x64, 0x29, 0xBC, 0x20, 0xAD, 0xD5, 

    0x91, 0xA5, 0x7A, 0x07, 0xD0, 0x28, 0x49, 0x78, 0xA3, 0x36,         // 14
    0x92, 0x1F, 0xA6, 0x64, 0x14, 0x31, 0xE5, 0xA1, 0xD9, 0x25, 
    0x66, 0xCD, 0x6F, 0x30, 0x90, 0xC7, 0x6C, 0xE1, 0xC3, 0xFA, 
    0x3F, 0x9F, 0xEC, 0x11, 0xDA, 0xBD, 0x30, 0x50, 0x02, 0xD1, 
    0x35, 0xF2, 0xB1, 0x70, 0xC5, 0x95, 0x00, 0x5C, 0xEB, 0x6F, 
    0x3A, 0xBC, 0x58, 0xB1, 0x49, 0x2C, 0x60, 0x05, 0xCC, 0x3C, 
    0x27, 0x85, 0x17, 0xA6, 0xF8, 0x6C, 0xDB, 0x3E, 0x7D, 0x53, 
    0x8E, 0xBD, 0x45, 0x7A, 0x8E, 0x08, 0xC6, 0x2B, 0x4F, 0xA1, 
    0x28, 0x82, 0x40, 0x98, 0xB6, 0xE6, 0x92, 0xD1, 0x45, 0x7A, 0x55, 

    0xF7, 0x1C, 0xD7, 0x46, 0x9C, 0x68, 0xF6, 0xC1, 0x1A, 0x70,         // 15
    0xCB, 0x56, 0x7B, 0xD3, 0xAD, 0xC0, 0x72, 0x18, 0x57, 0xFB, 
    0xA5, 0x05, 0xF0, 0xB8, 0x4C, 0xF6, 0x1E, 0x55, 0x95, 0x0F, 
    0x82, 0x30, 0xC2, 0x4C, 0xA2, 0x64, 0xFE, 0x87, 0xB2, 0x5E, 
    0x9B, 0x49, 0xD4, 0x17, 0xDF, 0x33, 0x79, 0xBD, 0x2F, 0xA3, 
    0x8F, 0xDA, 0x1D, 0xE6, 0x70, 0xFA, 0xBB, 0xAA, 0xE7, 0x90, 
    0x5E, 0xF0, 0x6E, 0xCD, 0x53, 0x27, 0xC0, 0x10, 0xAC, 0xCB, 
    0x05, 0x6C, 0x9D, 0x22, 0x51, 0xF7, 0x97, 0x6D, 0xEC, 0x87, 
    0xA9, 0xE3, 0x1A, 0xD6, 0x25, 0x3E, 0x6E, 0x11, 0xED, 0xB5, 0x0A, 

    0x74, 0x5B, 0xB5, 0x85, 0x18, 0xB7, 0x34, 0x83, 0xDA, 0x48,         // 16
    0xFA, 0x07, 0xE1, 0x28, 0x5B, 0xF7, 0x3D, 0x8C, 0xBA, 0x2C, 
    0x85, 0x40, 0x95, 0x18, 0x81, 0x3B, 0xAF, 0x7D, 0x2D, 0xA9, 
    0x63, 0xDE, 0x91, 0x2A, 0x7A, 0x09, 0xCD, 0x1B, 0xEA, 0x26, 
    0x81, 0x0A, 0x66, 0x8D, 0x4E, 0xA2, 0xE7, 0x51, 0xD4, 0x0B, 
    0x47, 0x79, 0x31, 0x96, 0x15, 0x85, 0x39, 0x21, 0x77, 0x11, 
    0xC4, 0x9E, 0x06, 0x3A, 0x9A, 0xEB, 0x77, 0x95, 0xFD, 0x48, 
    0xE7, 0x35, 0xCA, 0xE3, 0xB1, 0x63, 0x1A, 0x3F, 0xBF, 0x11, 
    0x3A, 0x66, 0xB4, 0x59, 0x7A, 0xF7, 0xA4, 0x53, 0x86, 0x35, 0xC8, 

    0x27, 0xE3, 0x33, 0xF4, 0x70, 0xDD, 0x5E, 0x00, 0xB1, 0x8E,         // 17
    0x34, 0xA2, 0x88, 0x46, 0x99, 0x09, 0xA5, 0x63, 0xD1, 0x50, 
    0xE1, 0x69, 0xD3, 0x59, 0xE3, 0xBF, 0x01, 0xED, 0xD5, 0x46, 
    0xBC, 0x04, 0x59, 0xF5, 0xB7, 0x48, 0x94, 0x3F, 0x75, 0xD6, 
    0xBC, 0xFA, 0xA5, 0x30, 0xED, 0x10, 0x90, 0x1F, 0xB3, 0x67, 
    0xF9, 0xAC, 0xCC, 0x62, 0xA5, 0xD3, 0x5B, 0xEE, 0x48, 0xDB, 
    0x2E, 0x4E, 0xBB, 0xE3, 0x84, 0x13, 0x4D, 0x2D, 0x61, 0x17, 
    0x7C, 0xA3, 0x5B, 0x0A, 0x30, 0xD9, 0xA5, 0x81, 0xD3, 0x5A, 
    0x99, 0xFB, 0x07, 0x8E, 0xC2, 0x0C, 0xCF, 0x29, 0xE0, 0x5E, 0x9D, 

    0x8C, 0x49, 0xA2, 0x0B, 0xC6, 0x27, 0x9E, 0xE7, 0x50, 0x13,         // 18
    0xC4, 0x60, 0x1A, 0xEE, 0x76, 0xD6, 0x25, 0xEC, 0x12, 0x9C, 
    0x24, 0xBD, 0x0D, 0xA0, 0x26, 0x61, 0x96, 0x6F, 0x1A, 0x88, 
    0xEF, 0x78, 0xCA, 0x19, 0x86, 0xE5, 0xC1, 0x5E, 0xA5, 0x36, 
    0x56, 0x21, 0x7D, 0xCD, 0x5B, 0xBF, 0x75, 0x3C, 0xDD, 0x86, 
    0x35, 0x54, 0x0E, 0xF2, 0x4C, 0x01, 0x91, 0xBF, 0xAA, 0x65, 
    0x87, 0xFC, 0x73, 0x1F, 0x60, 0xC7, 0xAA, 0xB7, 0xD6, 0x90, 
    0xC0, 0x24, 0xF9, 0x8D, 0x76, 0xBC, 0x52, 0x04, 0xF1, 0x2E, 
    0x79, 0xC8, 0x42, 0xE0, 0x4D, 0x34, 0x71, 0x90, 0xB8, 0x01, 0xD5, 

    0x15, 0xC8, 0x7F, 0x63, 0x4A, 0x89, 0x3F, 0xC7, 0x6A, 0xF3,         // 19
    0x7A, 0xDA, 0xAA, 0xB6, 0x37, 0x57, 0x87, 0xB5, 0x42, 0x7C, 
    0xF5, 0x71, 0x38, 0xEB, 0x7A, 0xDB, 0x40, 0xC7, 0x5D, 0xA4, 
    0x3B, 0x22, 0x99, 0x3F, 0x65, 0x0F, 0x32, 0xF5, 0x0A, 0x8B, 
    0xB2, 0xDD, 0x44, 0x06, 0xB0, 0x29, 0xFB, 0x5C, 0x9D, 0x16, 
    0xE4, 0xC5, 0x72, 0xB0, 0x33, 0xE4, 0x6D, 0x3F, 0x17, 0xD1, 
    0x0C, 0x9B, 0x47, 0xA9, 0xDA, 0x35, 0xE7, 0x03, 0x6D, 0x3E, 
    0xDE, 0x6A, 0x49, 0xCF, 0x3C, 0xED, 0x25, 0x9D, 0x6A, 0xB7, 
    0x16, 0xA0, 0x27, 0x7C, 0xB7, 0x99, 0xEE, 0x1E, 0x6B, 0xFE, 0x56, 

    0xA7, 0xF2, 0x20, 0xD9, 0xBB, 0xFB, 0x19, 0x80, 0x2A, 0xA3,         // 20
    0x1F, 0x3D, 0x59, 0x03, 0xE5, 0xC3, 0x2D, 0x68, 0xCF, 0x02, 
    0xB1, 0x4A, 0x8E, 0xC3, 0x50, 0x0B, 0xB0, 0x2B, 0xF5, 0x0A, 
    0xD3, 0x68, 0xE8, 0xAE, 0xDB, 0x9C, 0x7B, 0xA9, 0x6A, 0xEC, 
    0x17, 0x6F, 0x96, 0xF0, 0x69, 0x83, 0xC7, 0x03, 0xB7, 0x78, 
    0x2D, 0x92, 0x25, 0xDB, 0x7B, 0xAB, 0x1F, 0xF7, 0x7C, 0xB5, 
    0x42, 0xD8, 0x27, 0x8A, 0x0C, 0x75, 0x51, 0x86, 0xF3, 0x1D, 
    0xA1, 0x0C, 0xB8, 0x96, 0x14, 0x67, 0x8A, 0xCA, 0x3D, 0xE0, 
    0x4F, 0xD8, 0x61, 0xF2, 0x14, 0x5E, 0xC6, 0x4B, 0xA1, 0x38, 0x83, 

    0x2B, 0x71, 0x3C, 0x93, 0x05, 0xA8, 0x60, 0xEA, 0xBB, 0x4A,         // 21
    0x8E, 0xCD, 0xF9, 0x6F, 0x8C, 0x12, 0x9B, 0xFD, 0x52, 0x89, 
    0xD8, 0x18, 0xA7, 0x30, 0xF8, 0x91, 0xD2, 0x74, 0x98, 0x4D, 
    0xBB, 0x8A, 0x4A, 0x2B, 0xC5, 0x23, 0x4C, 0xDA, 0x2F, 0x4F, 
    0xBD, 0x31, 0xD0, 0x4B, 0x1F, 0x9A, 0x3D, 0xDB, 0x4F, 0xF5, 
    0x5E, 0xA6, 0x48, 0x09, 0xC2, 0x4F, 0xCE, 0x9D, 0x2C, 0x5A, 
    0xEF, 0x6C, 0xB7, 0x55, 0xF8, 0xC0, 0x9A, 0x27, 0xBD, 0x55, 
    0x7B, 0xED, 0x2E, 0x54, 0xE7, 0xBA, 0x33, 0xFE, 0x1A, 0x81, 
    0x95, 0x01, 0xA9, 0x8F, 0x45, 0xE3, 0x06, 0x86, 0xDA, 0x12, 0xC3, 

    0x59, 0x9D, 0xE4, 0x50, 0x77, 0x37, 0x9B, 0x0D, 0xD6, 0x68,         // 22
    0x13, 0xB7, 0x30, 0xA1, 0x45, 0xDC, 0x76, 0x1A, 0xBA, 0x36, 
    0x6E, 0xEE, 0x5A, 0x80, 0x20, 0x67, 0x3B, 0x18, 0xDF, 0x82, 
    0x25, 0xF7, 0x06, 0x7A, 0x58, 0xFA, 0x8A, 0x00, 0xA4, 0x91, 
    0xE6, 0x85, 0x0D, 0xAC, 0xC2, 0xE8, 0x65, 0x25, 0x91, 0x0D, 
    0xBE, 0xD9, 0x85, 0xFE, 0x6C, 0x30, 0x83, 0x07, 0xDA, 0x8D, 
    0x35, 0x02, 0xCB, 0x93, 0x3E, 0x1F, 0xE9, 0x44, 0xAB, 0xCC, 
    0x38, 0x8D, 0xD3, 0x78, 0xA1, 0x07, 0x75, 0x54, 0xA9, 0x5E, 
    0xED, 0x3F, 0x75, 0x2E, 0xCC, 0x6B, 0xA9, 0x42, 0xB9, 0x65, 0xE2, 

    0x09, 0xCA, 0x1E, 0xB2, 0xF1, 0xD0, 0x54, 0x83, 0x30, 0xB0,         // 23
    0xF1, 0x56, 0x83, 0x1B, 0xCC, 0x5F, 0xA9, 0x4B, 0xE8, 0x97, 
    0x23, 0xC2, 0x06, 0xD5, 0xA2, 0xE5, 0xBE, 0x58, 0xA5, 0x3F, 
    0x66, 0xAC, 0xCE, 0x94, 0xB4, 0x1B, 0xC1, 0x71, 0xD4, 0x15, 
    0x68, 0x3B, 0xFA, 0x77, 0x59, 0x10, 0x7D, 0xB1, 0xCB, 0x6F, 
    0x3E, 0x19, 0x57, 0x9C, 0x1D, 0xBA, 0xED, 0x55, 0x6D, 0xC2, 
    0xA1, 0x77, 0xEB, 0x14, 0x6A, 0xA4, 0x60, 0x7C, 0x13, 0xF7, 
    0x67, 0x00, 0xB3, 0x23, 0x3D, 0xC5, 0xDB, 0x96, 0x0D, 0xC1, 
    0x25, 0xD2, 0xB6, 0xFC, 0x1D, 0x97, 0x32, 0x77, 0xF0, 0x3A, 0x89, 

    0xFA, 0x4A, 0x86, 0x63, 0x12, 0x2B, 0xBC, 0xDE, 0x4C, 0x90,         // 24
    0x74, 0x08, 0xE1, 0xBC, 0x3B, 0xF4, 0x2A, 0x84, 0x08, 0xCE, 
    0x55, 0x84, 0xAD, 0x60, 0x42, 0x0E, 0x81, 0xFE, 0x02, 0xC7, 
    0xE4, 0x15, 0x55, 0x36, 0xE3, 0x65, 0x3C, 0xF0, 0x5A, 0x34, 
    0xC5, 0xA2, 0x4F, 0xCA, 0x34, 0xA1, 0xF4, 0x4A, 0x2C, 0xEE, 
    0xA7, 0x7A, 0xE9, 0x41, 0xD3, 0x8F, 0x3A, 0xA8, 0x13, 0xFB, 
    0x24, 0x4A, 0xA8, 0x80, 0xE0, 0xC9, 0x05, 0xDC, 0x8F, 0x2E, 
    0xA0, 0xDA, 0x57, 0xF9, 0x66, 0x88, 0x47, 0x2D, 0xE3, 0x7A, 
    0x98, 0x4B, 0x0E, 0x60, 0x83, 0xC1, 0xE9, 0x15, 0x92, 0x22, 0xB2, 

    0x72, 0x2E, 0xC1, 0xDC, 0x9F, 0x89, 0x69, 0x05, 0xEC, 0x22,         // 25
    0xD5, 0x4A, 0xAB, 0x6D, 0x90, 0x0D, 0x9E, 0xD6, 0x62, 0xB3, 
    0x3B, 0xFB, 0x32, 0xDF, 0x8F, 0x6E, 0xB3, 0x29, 0x94, 0x72, 
    0x32, 0x88, 0xF2, 0x73, 0x09, 0x99, 0xA7, 0x10, 0xB8, 0x81, 
    0xE2, 0x1D, 0x8D, 0x07, 0xDD, 0x86, 0x1A, 0xD4, 0x67, 0x8C, 
    0x23, 0xC9, 0x07, 0xB0, 0x64, 0x0F, 0x74, 0xDF, 0x49, 0x88, 
    0x65, 0xD9, 0x2C, 0x55, 0x21, 0x8A, 0x39, 0xA8, 0x56, 0xC6, 
    0x47, 0x7A, 0x1D, 0x93, 0xCD, 0x13, 0xF3, 0xA7, 0x67, 0x3C, 
    0xF5, 0x6F, 0xA8, 0xE0, 0x4D, 0x09, 0x69, 0xB3, 0x51, 0xCF, 0x5C, 

    0xDE, 0x99, 0x01, 0x41, 0x57, 0xFD, 0x3A, 0xA7, 0x71, 0xC5,         // 26
    0x9C, 0x2A, 0xF8, 0x16, 0x5B, 0xCA, 0x72, 0x30, 0xF3, 0x14, 
    0x95, 0x73, 0x1F, 0xB6, 0x16, 0xEF, 0x39, 0x64, 0xD9, 0x4A, 
    0xC1, 0xA4, 0x1F, 0xBB, 0xD4, 0x53, 0x7D, 0xD7, 0x28, 0x9C, 
    0x45, 0x6B, 0xEC, 0xB4, 0x63, 0x3F, 0xBC, 0x9C, 0x02, 0xDE, 
    0x47, 0x97, 0x6C, 0xDD, 0x2B, 0xF6, 0xC0, 0x1C, 0xA2, 0xCE, 
    0x17, 0xB9, 0x94, 0xEE, 0xC1, 0x4A, 0xFE, 0x6E, 0x26, 0xE5, 
    0x15, 0xBD, 0xEA, 0x34, 0xAF, 0x4F, 0x7F, 0x24, 0xD6, 0x06, 
    0xC5, 0x1B, 0x91, 0x36, 0xCA, 0x9E, 0xDE, 0x2E, 0xF5, 0xAA, 0x14, 

    0xC6, 0x81, 0xED, 0x75, 0xB9, 0x18, 0xCB, 0x92, 0x15, 0x40,         // 27
    0x5F, 0x7C, 0xBF, 0x35, 0xA4, 0xEE, 0x42, 0xBF, 0x8C, 0x52, 
    0xDE, 0xA6, 0x59, 0xCA, 0x4E, 0x99, 0xD3, 0xB9, 0x23, 0xF4, 
    0x09, 0x78, 0x45, 0x94, 0x26, 0xFD, 0x19, 0x49, 0x70, 0xF6, 
    0x0B, 0xCE, 0x2F, 0x7D, 0x21, 0xFD, 0x54, 0x78, 0x38, 0xB8, 
    0x5E, 0xFA, 0x35, 0x86, 0x4C, 0x99, 0x7F, 0x5E, 0x30, 0x6F, 
    0xF4, 0x40, 0x5F, 0x0F, 0x72, 0x9C, 0x1B, 0xC8, 0x82, 0x9E, 
    0x68, 0x8D, 0x50, 0x7E, 0x0B, 0xE4, 0xC0, 0x5D, 0x90, 0xA5, 
    0x81, 0x52, 0xE8, 0x21, 0x7E, 0x3E, 0x5D, 0x88, 0x05, 0x7B, 0x43, 

    0x1D, 0x5F, 0x3A, 0xA3, 0x29, 0xDF, 0x7B, 0x53, 0xF5, 0xAF,         // 28
    0xE6, 0x01, 0x93, 0xDC, 0x4B, 0x85, 0x05, 0x65, 0x23, 0xD1, 
    0x39, 0x01, 0x8B, 0xE9, 0x33, 0x82, 0x07, 0x53, 0x7F, 0x9A, 
    0x5D, 0xEB, 0xC9, 0x6B, 0x39, 0x86, 0xC3, 0xE5, 0xB0, 0x55, 
    0x8A, 0xB9, 0x49, 0xA4, 0xCC, 0x96, 0x11, 0xC4, 0xEF, 0x80, 
    0x0F, 0xA4, 0x18, 0xB9, 0xD0, 0x01, 0x3D, 0xEF, 0xC6, 0x8D, 
    0x05, 0xAE, 0x7D, 0xD8, 0x36, 0xBB, 0x60, 0xE8, 0x10, 0x45, 
    0xF5, 0x05, 0xD4, 0xBA, 0x62, 0x96, 0x35, 0x16, 0xF2, 0x43, 
    0x28, 0xCC, 0x6D, 0xB8, 0xFA, 0x10, 0xD4, 0xBE, 0x4C, 0xE5, 0xB0, 

    0xF9, 0xBC, 0x12, 0xCF, 0x87, 0x47, 0x10, 0xB8, 0x26, 0x86,         // 29
    0x2E, 0xCF, 0x54, 0x73, 0x1C, 0xD1, 0x9E, 0xE6, 0xAF, 0x70, 
    0xB6, 0xF4, 0x66, 0x13, 0xA9, 0x61, 0xF8, 0xAB, 0x15, 0xCE, 
    0x3B, 0xA7, 0x0F, 0xDA, 0xB5, 0x5E, 0x9D, 0x04, 0x35, 0xD2, 
    0x2B, 0x71, 0xF2, 0x03, 0x68, 0x32, 0xE5, 0x6E, 0x1E, 0xAE, 
    0xD1, 0x43, 0x76, 0xEE, 0x5D, 0xA1, 0xD9, 0xAD, 0x22, 0x4B, 
    0xE1, 0xCB, 0x1B, 0xA0, 0xF4, 0x02, 0x94, 0x50, 0xAD, 0xC1, 
    0x2F, 0xA4, 0x41, 0x21, 0xFD, 0x47, 0xD1, 0x7A, 0xB7, 0x68, 
    0xDD, 0xAA, 0x00, 0x49, 0xAC, 0x6B, 0x8E, 0x1D, 0x9F, 0x68, 0x2C, 

    0x4E, 0x98, 0x73, 0xF4, 0x60, 0x9F, 0xED, 0x66, 0xD8, 0x46,         // 30
    0x6A, 0xB6, 0x13, 0xFB, 0xB8, 0x2B, 0x78, 0x3D, 0x11, 0x8E, 
    0x2B, 0x4A, 0xC4, 0x78, 0xDE, 0x21, 0xC7, 0x44, 0xEA, 0x69, 
    0x26, 0x8D, 0x52, 0x2F, 0xED, 0x1C, 0x44, 0x83, 0x69, 0x99, 
    0xE3, 0x19, 0x90, 0x53, 0xDD, 0x83, 0x44, 0xA4, 0x50, 0x2C, 
    0x67, 0xE2, 0x93, 0x23, 0x39, 0x70, 0x19, 0x54, 0x81, 0x9F, 
    0x6D, 0x38, 0x56, 0x88, 0x47, 0x79, 0xD6, 0x2A, 0x72, 0xE2, 
    0x5E, 0x7C, 0xDF, 0x8F, 0x6E, 0xA6, 0x03, 0xE5, 0x3C, 0x8C, 
    0x15, 0x5C, 0xEC, 0x92, 0x24, 0xDB, 0x53, 0xF1, 0x37, 0xD6, 0x87, 

    0x04, 0xDE, 0x30, 0x49, 0x0B, 0xC3, 0x3A, 0x8F, 0x08, 0x9E,         // 31
    0xEF, 0x8B, 0x38, 0x9D, 0x5A, 0xEB, 0x4E, 0xCB, 0xF7, 0x57, 
    0xE1, 0x95, 0x24, 0x9F, 0x3C, 0x94, 0x70, 0x2D, 0x8A, 0xB4, 
    0xDF, 0xC5, 0x7B, 0xA2, 0x6F, 0xAC, 0xC5, 0xF8, 0xA8, 0x0E, 
    0x50, 0xB5, 0xCF, 0x2F, 0xAC, 0xBF, 0x0C, 0xD3, 0x90, 0xF6, 
    0xBD, 0x05, 0x4D, 0xB5, 0xCB, 0x96, 0xEC, 0xBC, 0x09, 0xF4, 
    0x28, 0xA7, 0xED, 0xBD, 0x24, 0xC6, 0x39, 0xFA, 0x09, 0x90, 
    0x18, 0xC4, 0x55, 0x0D, 0xCA, 0x30, 0x67, 0x9D, 0x25, 0xFA, 
    0xB3, 0x34, 0xC3, 0x7C, 0x38, 0xB5, 0x13, 0xC6, 0x76, 0x21, 0xA9, 

    0x6E, 0x90, 0xC9, 0xA5, 0xE8, 0x78, 0x21, 0xD1, 0x70, 0xBE,         // 32
    0x1E, 0x4F, 0xE4, 0x75, 0x06, 0x8B, 0xA9, 0x1D, 0x82, 0xBE, 
    0x0B, 0xD3, 0x62, 0xFC, 0x51, 0x04, 0xBF, 0xDC, 0x50, 0x08, 
    0x59, 0x1F, 0xF1, 0x01, 0x3E, 0xD5, 0x11, 0x4C, 0x28, 0xEB, 
    0x7F, 0x37, 0x6E, 0xF9, 0x1C, 0x77, 0xF0, 0x61, 0x1B, 0x7B, 
    0x54, 0xA4, 0x81, 0xFD, 0x0B, 0x7E, 0x2C, 0x67, 0xD8, 0x44, 
    0xC9, 0x7D, 0x07, 0x6C, 0xE5, 0x5C, 0xA7, 0x85, 0xBD, 0x53, 
    0x9E, 0xF7, 0x28, 0xAD, 0xE3, 0x82, 0xBF, 0x4F, 0xCF, 0x5F, 
    0x84, 0xDA, 0x0E, 0x4E, 0xF6, 0x67, 0x84, 0x3D, 0x99, 0x5A, 0xEA, 

    0x43, 0x19, 0x67, 0x28, 0x8D, 0x5A, 0xB5, 0x49, 0xFC, 0x37,         // 33
    0x62, 0xC4, 0x18, 0xA8, 0xD2, 0x2F, 0x61, 0x9C, 0x38, 0x6E, 
    0x47, 0x84, 0x1B, 0xC8, 0xAF, 0xEA, 0x7D, 0x1B, 0xA7, 0xFB, 
    0x76, 0xA8, 0x4B, 0x93, 0xE4, 0x59, 0x8A, 0x74, 0xC9, 0x5E, 
    0xA2, 0xC7, 0x08, 0x8B, 0x5C, 0x41, 0x9B, 0x38, 0xA9, 0xE0, 
    0x30, 0xD8, 0x20, 0x65, 0x42, 0xD2, 0x4D, 0xA6, 0x86, 0x5D, 
    0x1A, 0x94, 0x50, 0xB5, 0x13, 0x9A, 0x1E, 0x6B, 0x40, 0xD5, 
    0x31, 0x6C, 0x89, 0x41, 0x60, 0x11, 0xF5, 0x1F, 0x93, 0x12, 
    0x3E, 0x6F, 0x96, 0xA6, 0xCA, 0x05, 0xE2, 0xAE, 0xFE, 0x11, 0xC1, 

    0xDC, 0xAF, 0xF7, 0x4E, 0xD7, 0x04, 0xE0, 0x93, 0x14, 0xAF,         // 34
    0x86, 0xDD, 0x95, 0x69, 0x45, 0xE5, 0xBB, 0x0E, 0xD5, 0xB2, 
    0xF2, 0xA6, 0x41, 0x7A, 0x12, 0x5B, 0x98, 0x41, 0x67, 0x95, 
    0x38, 0xD1, 0x81, 0x2A, 0xB2, 0x1D, 0xA2, 0xE1, 0x39, 0x8F, 
    0x1B, 0xDF, 0x55, 0xA8, 0xE6, 0xB9, 0x00, 0xCE, 0x6F, 0x11, 
    0x91, 0x43, 0xC3, 0x99, 0xE1, 0xB2, 0x12, 0xF6, 0x25, 0xD0, 
    0xA9, 0xFC, 0x32, 0xD3, 0x83, 0x4A, 0xE9, 0xCE, 0x0E, 0xF1, 
    0xA7, 0x00, 0xCD, 0xEC, 0xB3, 0x38, 0xA5, 0x70, 0xE9, 0xC2, 
    0xAE, 0xE4, 0x1E, 0x5A, 0x2C, 0x90, 0x4B, 0x1C, 0x7A, 0x37, 0x8C, 

    0x0A, 0x78, 0x22, 0xBE, 0x80, 0xA1, 0x34, 0x56, 0x7B, 0xE5,         // 35
    0x02, 0x4B, 0x2B, 0xF6, 0x0C, 0x8E, 0x72, 0xFE, 0x5E, 0x32, 
    0x03, 0x91, 0xE9, 0x2F, 0x9E, 0xD8, 0x25, 0xEE, 0xCC, 0x0C, 
    0xE7, 0x16, 0x62, 0xF8, 0xCD, 0x67, 0x32, 0xBB, 0x04, 0xFB, 
    0x48, 0x7B, 0x2A, 0x95, 0x32, 0xD5, 0x8E, 0x55, 0xFB, 0xA0, 
    0x5F, 0xF2, 0x6D, 0x16, 0x3A, 0x5F, 0x8D, 0x6F, 0x9B, 0x3E, 
    0x69, 0x0F, 0x9D, 0x61, 0xF1, 0x2E, 0xAB, 0x57, 0x8F, 0x73, 
    0x3B, 0x94, 0x4E, 0x1B, 0x7E, 0xDC, 0x8E, 0x47, 0x2F, 0x62, 
    0x02, 0x4D, 0xC6, 0xEC, 0x7F, 0xD3, 0xB4, 0x61, 0xD9, 0xB8, 0x66, 

    0x50, 0xD6, 0x92, 0x3F, 0x13, 0x65, 0xF5, 0xC0, 0x28, 0xC9,         // 36
    0x68, 0xA6, 0x7F, 0xB4, 0x58, 0xC6, 0x19, 0x46, 0x8A, 0xE3, 
    0x78, 0x4F, 0xD0, 0x66, 0xC3, 0x4A, 0x76, 0xB4, 0x31, 0x88, 
    0x4E, 0xB9, 0x9A, 0x44, 0x08, 0x8D, 0xF0, 0x57, 0x9B, 0x6A, 
    0xCF, 0xAD, 0xEB, 0x0E, 0x6F, 0x4B, 0x1E, 0x7E, 0x28, 0x3C, 
    0xC9, 0x04, 0xA6, 0x89, 0xEF, 0xC7, 0x34, 0xE7, 0x00, 0xD7, 
    0x81, 0xE1, 0x46, 0xC5, 0x09, 0x75, 0xBA, 0x14, 0xC6, 0x23, 
    0xB2, 0xE7, 0x70, 0xB9, 0x2C, 0x53, 0x09, 0xBC, 0xD9, 0x89, 
    0xF3, 0x79, 0x93, 0x36, 0x67, 0x16, 0xF4, 0x44, 0xA0, 0x29, 0xF0, 

    0x31, 0xAC, 0x5B, 0xD0, 0xEB, 0xB1, 0x1A, 0x6B, 0x97, 0x41,         // 37
    0xF1, 0x36, 0xD2, 0x22, 0xE2, 0x32, 0xA2, 0xCC, 0x20, 0xAA, 
    0x2B, 0xB4, 0x14, 0x88, 0x20, 0xFA, 0x01, 0xA9, 0x5E, 0xC2, 
    0x6F, 0xDB, 0x24, 0xA9, 0x74, 0xC6, 0x1A, 0x7C, 0x41, 0xBE, 
    0x17, 0x38, 0x5F, 0xB4, 0xF4, 0xA0, 0xDF, 0xC4, 0xB0, 0xE8, 
    0x79, 0x47, 0xBE, 0x2A, 0x76, 0x0B, 0xAC, 0x5C, 0xBB, 0x4E, 
    0x29, 0xB6, 0x88, 0x24, 0x97, 0xE1, 0x36, 0x85, 0xEB, 0x4D, 
    0xD7, 0x5A, 0x15, 0xFB, 0x98, 0xCC, 0xF1, 0x78, 0x16, 0x9F, 
    0x27, 0x3F, 0xA7, 0x0A, 0xC0, 0xAA, 0x31, 0x75, 0x01, 0x8F, 0xC3, 

    0x7C, 0xFB, 0x09, 0x70, 0x29, 0x47, 0x84, 0xCE, 0x0B, 0xBA,         // 38
    0x8C, 0x10, 0x5B, 0x96, 0x65, 0x81, 0x51, 0xED, 0x69, 0xBF, 
    0xDC, 0x6F, 0xF3, 0x3D, 0xB6, 0x92, 0x54, 0xD9, 0x23, 0xEA, 
    0x14, 0x3A, 0x8E, 0x58, 0xED, 0x38, 0xAC, 0xE0, 0x0C, 0xF2, 
    0xA0, 0x8C, 0xDA, 0x43, 0x7B, 0x12, 0x61, 0x44, 0x0B, 0x95, 
    0x21, 0xE1, 0x63, 0xD2, 0x50, 0x96, 0xDC, 0x1A, 0x78, 0x9E, 
    0xEA, 0x12, 0x59, 0xF7, 0x68, 0x44, 0xCC, 0x63, 0x2D, 0xA3, 
    0x0C, 0x8E, 0xCD, 0x3E, 0x74, 0x5E, 0x28, 0xA7, 0x4E, 0x6B, 
    0xB3, 0xDD, 0x5A, 0xF7, 0x49, 0xE1, 0x87, 0xC7, 0xEC, 0x62, 0x14, 

    0x98, 0x4D, 0xBC, 0x8A, 0xC6, 0x9D, 0xDF, 0x35, 0xE8, 0x53,         // 39
    0x70, 0xAE, 0xDE, 0x19, 0xFA, 0xB6, 0x01, 0x96, 0x16, 0x56, 
    0x40, 0x07, 0x9B, 0x5A, 0xE4, 0x36, 0x7C, 0xBB, 0x46, 0x9C, 
    0x7E, 0xFE, 0xCC, 0x0F, 0xB3, 0x5F, 0x27, 0xCD, 0x86, 0x5B, 
    0x22, 0x73, 0x03, 0xC7, 0x2E, 0xBE, 0x8B, 0xF5, 0x72, 0x51, 
    0xA8, 0x87, 0x0D, 0xA3, 0xF3, 0x26, 0x44, 0xC5, 0xFB, 0x34, 
    0x6A, 0xCC, 0xA3, 0x30, 0xC0, 0xA1, 0x02, 0xFE, 0x91, 0x6E, 
    0xC0, 0x38, 0x7D, 0xA6, 0x04, 0xC1, 0x8B, 0x3D, 0xC7, 0xFD, 
    0x07, 0xC2, 0x24, 0x72, 0x96, 0x10, 0x69, 0x1D, 0xB1, 0x47, 0xDD, 

    0x6A, 0x22, 0x38, 0xDA, 0x54, 0x06, 0x7B, 0x5D, 0xA4, 0x28,         // 40
    0xF6, 0x42, 0xC3, 0x76, 0x46, 0xCD, 0x39, 0xD7, 0x7C, 0xF8, 
    0x8F, 0xBD, 0xD8, 0x80, 0x0D, 0xCE, 0x1D, 0xF5, 0x6C, 0x06, 
    0xB1, 0x4D, 0x76, 0x3D, 0xE1, 0x7D, 0x9A, 0x4A, 0xA5, 0x32, 
    0xD3, 0xAE, 0xFE, 0x5E, 0x9B, 0xE4, 0x34, 0x1C, 0xB8, 0xD6, 
    0x33, 0xFD, 0x4C, 0x31, 0x8C, 0x69, 0xB0, 0x7D, 0x57, 0x08, 
    0x8D, 0x3D, 0x73, 0xDD, 0x19, 0x7E, 0x58, 0xB4, 0x1B, 0xE3, 
    0x53, 0xD9, 0x1E, 0xE2, 0x57, 0xEE, 0x13, 0xDB, 0x96, 0x33, 
    0x63, 0x9E, 0x85, 0xCE, 0x30, 0xB0, 0x4F, 0xD4, 0x8B, 0x34, 0xA4, 

    0xCB, 0xED, 0xAC, 0x74, 0x27, 0xFA, 0xBA, 0x15, 0x8F, 0xC8,         // 41
    0x03, 0x89, 0x29, 0x9F, 0x0F, 0x85, 0x62, 0xAE, 0x2B, 0xA2, 
    0x36, 0x61, 0x25, 0x4B, 0xA6, 0x68, 0xB1, 0x40, 0x8B, 0xD3, 
    0x2E, 0xBD, 0x16, 0x9E, 0xC5, 0x00, 0xFA, 0x1D, 0x77, 0xEC, 
    0x67, 0x47, 0x26, 0x82, 0x10, 0x4E, 0xA6, 0xDA, 0x7E, 0x02, 
    0x64, 0xBA, 0x73, 0xDD, 0xBE, 0x06, 0xE6, 0x1C, 0xAA, 0xD3, 
    0xB5, 0xF4, 0x0F, 0x4D, 0x8C, 0xE9, 0x28, 0xD2, 0x3F, 0x85, 
    0x06, 0xAE, 0x69, 0x92, 0x24, 0xAD, 0x81, 0x52, 0x20, 0x7B, 
    0xD8, 0x48, 0x1B, 0xE9, 0x60, 0xC2, 0xFA, 0x2C, 0x71, 0xF2, 0x1A, 

    0x80, 0x03, 0x5B, 0xE6, 0x99, 0x45, 0x6C, 0xEC, 0x3A, 0x72,         // 42
    0xD8, 0x61, 0xE8, 0x56, 0xB2, 0xF3, 0x1B, 0xE5, 0x53, 0x0A, 
    0xEA, 0x76, 0xCB, 0xFD, 0x8D, 0x28, 0xE9, 0x10, 0xA4, 0x51, 
    0xE7, 0x5F, 0xF1, 0x84, 0x59, 0x34, 0x6A, 0xD2, 0xB6, 0x29, 
    0xC2, 0x8F, 0xDD, 0xB4, 0xED, 0x6C, 0x88, 0x3B, 0x5A, 0xA1, 
    0xE6, 0x14, 0x9C, 0x1D, 0x82, 0x5A, 0xC3, 0x39, 0xEE, 0x46, 
    0x21, 0x7B, 0x9D, 0xD1, 0xBC, 0x38, 0x71, 0x9A, 0x5F, 0xEE, 
    0xC6, 0x36, 0xF3, 0x4C, 0xCB, 0x34, 0x64, 0xE7, 0xC9, 0xAF, 
    0x10, 0xF0, 0x6C, 0xA7, 0x02, 0x41, 0x7A, 0xA5, 0x0B, 0xBA, 0x55, 

    0x96, 0xBF, 0x2E, 0x8A, 0x0D, 0xA6, 0xD2, 0x1F, 0xAE, 0x4B,         // 43
    0x99, 0x31, 0xBD, 0x22, 0xD5, 0x47, 0x94, 0xC0, 0x77, 0xD7, 
    0xB4, 0x1A, 0x9E, 0x06, 0x42, 0xD6, 0x7E, 0x63, 0xDD, 0x20, 
    0x73, 0x97, 0x2A, 0x48, 0xDC, 0xBA, 0x92, 0x12, 0x58, 0xAA, 
    0x0D, 0x3C, 0x61, 0x1B, 0x37, 0xC1, 0x0B, 0xFA, 0xC9, 0x30, 
    0x8B, 0x46, 0xCA, 0x50, 0xF7, 0x32, 0x97, 0x66, 0x80, 0x9B, 
    0x60, 0xDF, 0x2B, 0x56, 0x09, 0xA6, 0xF6, 0x12, 0xB9, 0x26, 
    0x75, 0x8E, 0x14, 0xA7, 0x73, 0xFB, 0xB8, 0x00, 0x40, 0x8B, 
    0x5A, 0xBA, 0x3A, 0x8E, 0xE0, 0x98, 0x1F, 0xD9, 0x65, 0xE2, 0x3D, 

    0xFE, 0x6F, 0xD7, 0x4F, 0xC9, 0x34, 0x57, 0x83, 0xE4, 0xC4,         // 44
    0x10, 0xFD, 0x6B, 0x95, 0x7C, 0x05, 0x6A, 0x29, 0x42, 0x8D, 
    0x5F, 0x48, 0x84, 0xC3, 0x5E, 0xB5, 0x2D, 0x98, 0x4A, 0xBF, 
    0xA8, 0x0A, 0xCE, 0xAE, 0x10, 0x73, 0xEE, 0x42, 0xDD, 0x71, 
    0xF8, 0xCA, 0x9E, 0x76, 0xD2, 0xAB, 0x55, 0x94, 0x20, 0xB5, 
    0x68, 0xF1, 0x2A, 0x6F, 0xAC, 0xD0, 0x18, 0xDE, 0x26, 0xC8, 
    0x03, 0xBC, 0x71, 0xF2, 0x88, 0x65, 0x44, 0x81, 0xD8, 0x4D, 
    0xA5, 0x5C, 0xDB, 0x40, 0x0B, 0x8A, 0x2B, 0xA0, 0x70, 0xF6, 
    0x34, 0xD2, 0x79, 0x19, 0x5E, 0xC8, 0x4D, 0x8E, 0x37, 0xA2, 0x17, 

    0xB3, 0x46, 0x1E, 0xAF, 0x67, 0xE6, 0xA0, 0x04, 0x63, 0x35,         // 45
    0x86, 0xB2, 0x45, 0x12, 0xEE, 0xB1, 0xC8, 0xFB, 0xA4, 0x24, 
    0xC6, 0xF5, 0x30, 0xDF, 0x7A, 0x12, 0xF2, 0xCA, 0x03, 0xF9, 
    0x3B, 0x86, 0x65, 0xF6, 0x3B, 0xAB, 0x20, 0x82, 0x9E, 0x26, 
    0x4C, 0x7F, 0x02, 0xF4, 0x44, 0x1E, 0xE9, 0x71, 0x4F, 0xD5, 
    0x0D, 0x80, 0xBC, 0xDF, 0x03, 0x45, 0x74, 0xA8, 0x4C, 0xFC, 
    0x3B, 0x8D, 0x44, 0xB1, 0x20, 0xDD, 0xC0, 0x2F, 0x94, 0x0C, 
    0xFA, 0x22, 0xC7, 0x96, 0xE3, 0x58, 0xD4, 0x4F, 0xDA, 0x26, 
    0x9D, 0x08, 0xB0, 0xFC, 0x2B, 0xB2, 0xE5, 0x06, 0xC4, 0x83, 0x5F, 

    0x0E, 0xE1, 0x85, 0xF2, 0x11, 0x77, 0x2A, 0xF9, 0x91, 0xDA,         // 46
    0x57, 0x21, 0xE3, 0xA2, 0x73, 0x3A, 0x59, 0x16, 0x82, 0xE7, 
    0x01, 0xA6, 0x69, 0x21, 0xAC, 0x52, 0x8E, 0x34, 0x75, 0x92, 
    0x54, 0xE4, 0x1A, 0x99, 0x55, 0xD9, 0x60, 0xC9, 0x08, 0xBC, 
    0xE7, 0x2E, 0xB4, 0x57, 0x92, 0x79, 0xCC, 0x04, 0x9F, 0xEC, 
    0x43, 0x9A, 0x20, 0x55, 0x8C, 0xA0, 0xF2, 0x0C, 0x83, 0xA0, 
    0x6B, 0xE8, 0x15, 0xD0, 0x54, 0x98, 0x00, 0x5A, 0xEA, 0x6B, 
    0xB7, 0x45, 0x7E, 0x64, 0x1E, 0xB6, 0x7A, 0x19, 0xBF, 0x86, 
    0x5F, 0xE2, 0x48, 0x97, 0x6F, 0x3E, 0x7C, 0x5B, 0xF6, 0x27, 0xD4, 

    0x93, 0xA9, 0x35, 0x5F, 0x98, 0xD6, 0xBC, 0x44, 0xA7, 0x0C,         // 47
    0xBD, 0x77, 0xCE, 0x53, 0x2A, 0xE0, 0x8D, 0xD6, 0x33, 0x52, 
    0x79, 0x41, 0x94, 0xED, 0xC0, 0x3B, 0xDC, 0x60, 0xBB, 0x1F, 
    0xC8, 0x2C, 0xB6, 0x7E, 0x03, 0xBB, 0x2D, 0xF3, 0x52, 0x8C, 
    0x65, 0xAA, 0xD7, 0x1A, 0xE4, 0x2A, 0xA9, 0x3C, 0x83, 0x26, 
    0xB2, 0x60, 0xFC, 0xB5, 0x33, 0x67, 0xBD, 0x5B, 0xD5, 0x30, 
    0x0F, 0xC1, 0xAA, 0x6E, 0x3A, 0xFD, 0x75, 0xD2, 0x9F, 0x37, 
    0x8A, 0xE4, 0x03, 0xAA, 0xF0, 0x37, 0x9A, 0xE9, 0x47, 0x10, 
    0xB6, 0x73, 0x24, 0xD4, 0x0F, 0xEF, 0x9F, 0x18, 0xB4, 0x6F, 0x3A, 

    0x53, 0x78, 0x00, 0xCD, 0x3F, 0x19, 0x59, 0x7C, 0x2F, 0x6A,         // 48
    0xF5, 0x39, 0x91, 0x14, 0xC4, 0x9E, 0x08, 0x6B, 0xB8, 0x9A, 
    0xDB, 0xBE, 0x18, 0x5F, 0x07, 0x73, 0xA1, 0x12, 0xEC, 0xAA, 
    0x5D, 0x77, 0xD4, 0x33, 0xEC, 0x8A, 0x6E, 0x9A, 0x35, 0xDC, 
    0x18, 0x3C, 0x83, 0xBC, 0x6B, 0x9E, 0x61, 0xE2, 0xBC, 0x68, 
    0xCF, 0x0A, 0x7E, 0xD4, 0x15, 0xE3, 0x3B, 0x20, 0xB1, 0xEB, 
    0x5A, 0x7E, 0x2D, 0xE2, 0x85, 0x29, 0xB4, 0x4C, 0x11, 0xC9, 
    0x27, 0x52, 0xBB, 0x2F, 0xCD, 0x50, 0x07, 0x67, 0xA1, 0xDB, 
    0x36, 0xF2, 0x89, 0x54, 0xBB, 0x84, 0x32, 0xE0, 0x47, 0x9B, 0xE9, 

    0x1F, 0xBB, 0xFA, 0xA1, 0x87, 0xE2, 0xAB, 0xF0, 0xC5, 0x8B,         // 49
    0x18, 0xB0, 0x65, 0xED, 0x7E, 0x40, 0xF6, 0x4D, 0xCE, 0x0D, 
    0x5E, 0x31, 0xE5, 0x86, 0xCB, 0xFA, 0x27, 0x7F, 0x45, 0xD0, 
    0x09, 0xFD, 0x48, 0xA9, 0x57, 0x23, 0xC7, 0x0E, 0xB7, 0x80, 
    0xC5, 0xF8, 0x52, 0x08, 0x41, 0xF3, 0x1D, 0x4E, 0x11, 0xF5, 
    0x3A, 0x93, 0x2C, 0x4D, 0x9E, 0x79, 0xCA, 0x90, 0x72, 0x42, 
    0x97, 0xD1, 0x50, 0x06, 0xC4, 0x9A, 0x17, 0xEC, 0x85, 0x63, 
    0xDB, 0x96, 0xF8, 0x5E, 0x74, 0x92, 0xBB, 0xFC, 0x21, 0x8D, 
    0x5B, 0xC2, 0x02, 0xA6, 0x28, 0xD9, 0x63, 0xC8, 0x7A, 0x0A, 0xC4, 

    0x8B, 0x41, 0x6E, 0x4E, 0x29, 0x6A, 0x05, 0x50, 0x23, 0xDA,         // 50
    0x5A, 0xE4, 0x02, 0xB8, 0x5C, 0x1B, 0xB3, 0x7A, 0x27, 0x88, 
    0xFE, 0x77, 0xA4, 0x4D, 0x2E, 0xB0, 0x50, 0xC2, 0x96, 0x2E, 
    0x85, 0x9F, 0x19, 0x6B, 0x9A, 0xDD, 0x43, 0xFB, 0x61, 0x46, 
    0x0B, 0x73, 0xA3, 0xDF, 0xC2, 0x7F, 0x96, 0xD4, 0x76, 0xA5, 
    0x53, 0xEA, 0xC6, 0x6D, 0xF2, 0x0E, 0x55, 0xF6, 0x01, 0xC9, 
    0x18, 0xF9, 0xA6, 0x65, 0xEF, 0x42, 0x72, 0xCC, 0x3B, 0xB1, 
    0x1E, 0x80, 0x11, 0xA3, 0x25, 0xD6, 0x39, 0x77, 0x51, 0xCF, 
    0x2E, 0x9A, 0x68, 0xE9, 0x77, 0x46, 0x06, 0x90, 0x2B, 0xF3, 0x65, 

    0xE5, 0xD2, 0x15, 0xC4, 0xEE, 0xB0, 0xCE, 0x7F, 0x99, 0x41,         // 51
    0xA3, 0x29, 0x82, 0x44, 0xD2, 0x92, 0xE7, 0x38, 0xDC, 0xAE, 
    0x47, 0x1E, 0xD7, 0x0A, 0x8E, 0x66, 0xDD, 0x00, 0xF1, 0x63, 
    0xDA, 0x36, 0xC5, 0xEE, 0x0A, 0x75, 0xAB, 0x17, 0x92, 0xE6, 
    0xB3, 0x31, 0x91, 0x24, 0x5A, 0x12, 0x3A, 0xB5, 0x2B, 0x8F, 
    0x05, 0xAC, 0x1F, 0xB1, 0x33, 0x8B, 0xBA, 0x2E, 0xAC, 0x64, 
    0x87, 0x27, 0x3C, 0x95, 0x1A, 0xB6, 0x55, 0x8F, 0x04, 0xF5, 
    0x71, 0x36, 0xCF, 0x4D, 0xEC, 0x84, 0x15, 0xDC, 0xB5, 0x0C, 
    0x7C, 0xF8, 0x1F, 0x4D, 0xCA, 0xA0, 0xFD, 0xB6, 0x55, 0xA1, 0x38, 

    0xAF, 0x2F, 0x99, 0x7E, 0x0D, 0x4B, 0x32, 0xE7, 0x1A, 0xC0,         // 52
    0x6D, 0xD3, 0x9C, 0xF6, 0x24, 0x71, 0x06, 0x99, 0x54, 0x11, 
    0xC9, 0x92, 0x59, 0xB3, 0xF3, 0x3B, 0xAA, 0x74, 0x4B, 0x1F, 
    0xAE, 0x6F, 0x4D, 0x82, 0x3A, 0xD6, 0x4E, 0xC1, 0x6E, 0x20, 
    0xCF, 0x5C, 0xF3, 0x6F, 0xD4, 0xAB, 0xFE, 0x63, 0xE7, 0x6C, 
    0xDE, 0x7F, 0x4B, 0xE2, 0x5E, 0xD8, 0x49, 0x78, 0xDC, 0x44, 
    0xE4, 0xB7, 0x70, 0xD0, 0x7F, 0xDA, 0x21, 0xE6, 0xC1, 0x49, 
    0xA0, 0xE2, 0xB6, 0x6D, 0x05, 0xB0, 0x62, 0x9C, 0x42, 0xE3, 
    0xAB, 0x3F, 0xD4, 0x8E, 0x14, 0x38, 0x82, 0x17, 0xDB, 0x7C, 0x0F, 

    0x74, 0x52, 0xE8, 0x5C, 0xBB, 0x93, 0x74, 0xA8, 0x5F, 0xF8,         // 53
    0x0E, 0x4A, 0x74, 0x37, 0xA9, 0x58, 0xBC, 0xD2, 0x6A, 0xF3, 
    0x75, 0x26, 0xE9, 0x72, 0x18, 0xCE, 0x23, 0xBD, 0x8C, 0xC4, 
    0xE9, 0x06, 0x9A, 0xCE, 0xB4, 0x29, 0x89, 0xEA, 0x34, 0xA0, 
    0x49, 0x84, 0x00, 0xB0, 0x35, 0x84, 0x4C, 0x0C, 0xC1, 0x22, 
    0x58, 0xBB, 0x16, 0x92, 0x2A, 0x9C, 0x0A, 0xC4, 0x1E, 0x9C, 
    0x0F, 0x53, 0xF1, 0x0A, 0x5C, 0x36, 0xA4, 0x6A, 0x30, 0x8C, 
    0x5F, 0x0B, 0x42, 0x8D, 0xC4, 0x48, 0xF6, 0x2C, 0x8C, 0x5D, 
    0x18, 0x72, 0xB3, 0x5B, 0xC1, 0xDF, 0x65, 0x3D, 0xBE, 0x4A, 0xCB, 

    0x95, 0x04, 0xCD, 0x20, 0xFD, 0x2A, 0xD2, 0x12, 0x96, 0x34,         // 54
    0x89, 0xE4, 0xBB, 0x0A, 0x90, 0xF0, 0x1E, 0x46, 0x8B, 0x3B, 
    0xBA, 0xA3, 0x37, 0xC5, 0x4B, 0x87, 0x5D, 0xFC, 0x11, 0x3D, 
    0x77, 0x30, 0xF7, 0x16, 0x66, 0xF2, 0x07, 0x57, 0x7D, 0xDB, 
    0x13, 0xE9, 0xC5, 0x4E, 0xE0, 0x16, 0xCA, 0x8C, 0x3E, 0x9D, 
    0xCF, 0x39, 0xFC, 0x68, 0xC8, 0xEF, 0x62, 0x89, 0xFA, 0x74, 
    0xCB, 0x83, 0x2C, 0x9D, 0xBF, 0xF8, 0x8B, 0x15, 0xB7, 0xEF, 
    0x24, 0xAE, 0xFE, 0x29, 0xDA, 0x1D, 0x71, 0xD2, 0x00, 0xF0, 
    0xC7, 0x2C, 0xEA, 0x07, 0x7C, 0x24, 0x9B, 0xE8, 0x8A, 0x1D, 0xF9, 

    0x67, 0xB7, 0x39, 0x79, 0xA0, 0x69, 0x3F, 0xEC, 0x51, 0xD5,         // 55
    0xA8, 0x1F, 0x66, 0xD0, 0x4F, 0x7B, 0xD9, 0xB3, 0x28, 0xE1, 
    0x01, 0x55, 0x8B, 0x0E, 0x9E, 0xEA, 0x33, 0xA7, 0x68, 0xDF, 
    0x90, 0xA7, 0x5A, 0x7F, 0x40, 0x92, 0xA4, 0xCB, 0x21, 0xB8, 
    0x6B, 0xA4, 0x60, 0x1F, 0xA2, 0x6B, 0xEE, 0xB3, 0x74, 0xF4, 
    0x11, 0x78, 0xA2, 0x02, 0x85, 0x22, 0xB3, 0x43, 0x27, 0x59, 
    0x37, 0xA6, 0xDA, 0x49, 0x19, 0x72, 0x43, 0xE1, 0x51, 0x73, 
    0xD3, 0x84, 0x6A, 0x57, 0x9F, 0x86, 0xBA, 0x4C, 0xA5, 0x68, 
    0xB0, 0x8A, 0x49, 0xA2, 0xF7, 0x50, 0xA9, 0x01, 0x6D, 0xB3, 0x2A, 

    0x3F, 0xEC, 0x8B, 0x51, 0xD5, 0x08, 0x86, 0xB1, 0x72, 0x01,         // 56
    0x83, 0x40, 0xFC, 0x27, 0xA3, 0x37, 0x09, 0x6C, 0x9B, 0xC3, 
    0x6F, 0xFB, 0xCF, 0x65, 0xD8, 0x77, 0x04, 0x93, 0x4E, 0xCC, 
    0x19, 0x49, 0xE2, 0xAD, 0xC6, 0x1C, 0x70, 0x38, 0xFD, 0x8A, 
    0x44, 0x2F, 0x8D, 0xF9, 0x81, 0x29, 0x50, 0x03, 0x5C, 0x27, 
    0x8B, 0x4A, 0xD5, 0x59, 0xBF, 0x3D, 0xE0, 0x99, 0xD1, 0xB2, 
    0xE7, 0x03, 0x6F, 0x93, 0xD1, 0xAE, 0x07, 0xCC, 0x97, 0x0E, 
    0x45, 0xB8, 0x16, 0xE4, 0x41, 0x11, 0xE8, 0x25, 0x80, 0x31, 
    0x51, 0xDF, 0x1A, 0x68, 0x33, 0x8D, 0xD3, 0x31, 0xF0, 0x56, 0xD5, 

    0x9F, 0x11, 0xC9, 0x1C, 0xAF, 0xE3, 0x4D, 0xC3, 0x37, 0xF0,         // 57
    0x61, 0xBF, 0x94, 0x76, 0xE2, 0xC4, 0x8F, 0xF8, 0x52, 0x15, 
    0x86, 0x3F, 0x25, 0xB7, 0x1B, 0x45, 0xCA, 0xE6, 0x22, 0xAE, 
    0x6D, 0xC0, 0x36, 0x01, 0xD9, 0x56, 0xE3, 0xAA, 0x5B, 0x06, 
    0xEB, 0xC1, 0x10, 0xB7, 0x39, 0xD0, 0x94, 0xBF, 0xE8, 0xAB, 
    0xDC, 0xB7, 0x33, 0xE9, 0x1A, 0x78, 0x5C, 0x08, 0x7E, 0x1A, 
    0x8E, 0x5C, 0xFC, 0x2E, 0x52, 0xED, 0x60, 0x7E, 0x29, 0xA8, 
    0xEB, 0x2F, 0xCC, 0xAB, 0x76, 0xC9, 0x5C, 0xA0, 0xF4, 0xCE, 
    0x0D, 0x73, 0xC8, 0xB2, 0xD8, 0x16, 0x60, 0x7D, 0x97, 0x0D, 0x82, 

    0xC2, 0x72, 0x36, 0xF3, 0x66, 0x29, 0x97, 0x1C, 0xD0, 0xA1,         // 58
    0x2C, 0xDA, 0x0C, 0x57, 0x20, 0x3F, 0x61, 0x1E, 0xD2, 0x36, 
    0xEB, 0xA7, 0x95, 0x53, 0xF4, 0xB2, 0x5C, 0x7A, 0x36, 0xEE, 
    0x0C, 0x84, 0xFB, 0x64, 0x95, 0x2A, 0xBB, 0x15, 0x7C, 0xD0, 
    0xAA, 0x4C, 0xDA, 0x6F, 0x57, 0xE5, 0x17, 0x83, 0x2D, 0x40, 
    0x64, 0x09, 0x7D, 0x98, 0xAF, 0xF7, 0xC5, 0x47, 0xF2, 0x67, 
    0xD6, 0x3F, 0xB8, 0x80, 0x1D, 0x99, 0x37, 0xB7, 0xF9, 0x5A, 
    0x87, 0x6E, 0x50, 0x0D, 0xF9, 0x2D, 0x91, 0x07, 0x4A, 0xB5, 
    0x92, 0xFC, 0x2A, 0x83, 0x49, 0xF2, 0xBC, 0x40, 0xB4, 0xE0, 0x47, 

    0xEE, 0x55, 0x90, 0xA3, 0x43, 0x7D, 0xFA, 0x6D, 0x55, 0x12,         // 59
    0x91, 0x48, 0xAB, 0xEF, 0x87, 0xB1, 0xE8, 0xA0, 0x79, 0xBA, 
    0x5D, 0x08, 0xE5, 0x7E, 0x34, 0x87, 0x11, 0xC3, 0x99, 0x5E, 
    0xD2, 0x9F, 0x21, 0xA9, 0x3D, 0x80, 0xF5, 0x45, 0xB5, 0x23, 
    0x64, 0x85, 0x2C, 0x98, 0x06, 0xA4, 0x47, 0xC8, 0x74, 0x9B, 
    0xCD, 0xF4, 0x25, 0x4F, 0x69, 0x0F, 0x8A, 0xA2, 0x2C, 0xB7, 
    0x22, 0x9E, 0x0E, 0xCE, 0xE7, 0x69, 0xC6, 0x1B, 0x46, 0x9B, 
    0x06, 0xDC, 0x9F, 0x8B, 0x3E, 0xB9, 0x6B, 0xE2, 0x79, 0x1E, 
    0x5A, 0x3C, 0x9C, 0x04, 0x6C, 0x99, 0x10, 0xD1, 0x29, 0x66, 0x1C, 

    0xB6, 0x08, 0xDE, 0x16, 0xBC, 0xD6, 0x04, 0xB5, 0xD9, 0x7C,         // 60
    0xF6, 0x6E, 0xBC, 0x19, 0x66, 0xD0, 0x02, 0x4F, 0x29, 0x93, 
    0xD7, 0x46, 0x6B, 0x16, 0xD1, 0x9C, 0x2C, 0xF9, 0x43, 0x7D, 
    0x2D, 0x4F, 0x70, 0xDF, 0xC7, 0x13, 0x69, 0x90, 0xEA, 0x37, 
    0xDF, 0x14, 0xF5, 0xCA, 0x78, 0xF1, 0x67, 0x21, 0xEC, 0x10, 
    0x59, 0x86, 0xB3, 0xE6, 0x2C, 0xD9, 0x3B, 0x63, 0xE6, 0x7B, 
    0x50, 0xE9, 0x72, 0x47, 0xA8, 0x00, 0x8A, 0xD4, 0x79, 0xE4, 
    0x34, 0xC5, 0x24, 0xEC, 0x62, 0xD6, 0x20, 0xB2, 0x33, 0xDB, 
    0xC4, 0x70, 0xB4, 0xE7, 0xCA, 0x39, 0x79, 0x58, 0xFD, 0xA3, 0x89, 

    0x41, 0xCA, 0x62, 0x87, 0x31, 0x51, 0x9C, 0x44, 0x23, 0xAD,         // 61
    0x35, 0x05, 0xD7, 0x39, 0x9D, 0x47, 0x83, 0xBF, 0xF6, 0x71, 
    0x1B, 0x9F, 0xC8, 0xAF, 0x43, 0xEA, 0x65, 0xAD, 0x05, 0xE1, 
    0xB2, 0xF1, 0x08, 0x87, 0x54, 0xA1, 0xD7, 0x03, 0x51, 0x76, 
    0x97, 0xBA, 0x69, 0x3B, 0xB6, 0x2E, 0x8F, 0xD6, 0xB1, 0x37, 
    0xC1, 0x1D, 0x3E, 0xCA, 0x92, 0x79, 0xB9, 0x17, 0xCD, 0x04, 
    0x8C, 0xBE, 0x2B, 0x93, 0x5D, 0x34, 0xF4, 0x58, 0x11, 0xB9, 
    0x61, 0xAE, 0x45, 0x82, 0x01, 0xA1, 0x52, 0xEA, 0x98, 0x82, 
    0x09, 0xEE, 0x2D, 0x4F, 0x18, 0xAB, 0xE2, 0x93, 0x05, 0x70, 0x2D, 

    0xF1, 0x75, 0x25, 0xF8, 0xC3, 0x6C, 0xDF, 0x82, 0xEB, 0x65,         // 62
    0xCD, 0x8D, 0x53, 0x7B, 0xF9, 0x2F, 0xDD, 0x5E, 0x0D, 0x42, 
    0xE8, 0x81, 0x30, 0xE1, 0x58, 0x0F, 0x7E, 0xC9, 0x53, 0x89, 
    0x25, 0xC2, 0x9A, 0x37, 0xE9, 0x26, 0x43, 0xC0, 0xAB, 0xCA, 
    0x0B, 0x44, 0x8C, 0x1B, 0x56, 0xCE, 0x0C, 0x49, 0x63, 0x89, 
    0xFA, 0x73, 0x9F, 0x60, 0x00, 0x46, 0xFE, 0x97, 0x58, 0xA8, 
    0x38, 0xF5, 0x12, 0xCB, 0xDF, 0x7B, 0xAC, 0x2B, 0x9F, 0x3F, 
    0xFB, 0x15, 0x74, 0xE1, 0xCB, 0x3A, 0x7B, 0x15, 0x5C, 0x43, 
    0xA5, 0x60, 0x8A, 0xD0, 0x64, 0xC0, 0x22, 0x50, 0xBD, 0xDB, 0xAF, 

    0x4E, 0x98, 0xA8, 0x58, 0x0C, 0x8F, 0x19, 0x3A, 0xBD, 0x13,         // 63
    0x43, 0xA5, 0xE0, 0x27, 0xC4, 0xAD, 0x1D, 0x90, 0xA3, 0xCF, 
    0xB7, 0x51, 0x00, 0x72, 0x8F, 0xA4, 0x35, 0xDE, 0x19, 0xA0, 
    0x44, 0x66, 0x1D, 0xCF, 0x6C, 0x82, 0xFC, 0x62, 0x1B, 0xF2, 
    0x58, 0xD1, 0xE6, 0xA5, 0xFE, 0x6F, 0xA8, 0xEE, 0x9E, 0x05, 
    0x44, 0xD1, 0x13, 0xF1, 0xA6, 0xD2, 0x22, 0x6F, 0x30, 0xD6, 
    0x75, 0x52, 0x9D, 0x68, 0x3F, 0x15, 0xC2, 0xE8, 0x6C, 0x84, 
    0xCA, 0x94, 0x4C, 0xAA, 0x19, 0x92, 0xFD, 0xAF, 0xC5, 0xF3, 
    0x20, 0xD8, 0x14, 0xA2, 0xFA, 0x36, 0x86, 0xEC, 0x3C, 0x60, 0x15, 

    0x8A, 0x00, 0xE8, 0x36, 0xD6, 0xA7, 0xF5, 0x62, 0x9A, 0x79,         // 64
    0xFD, 0x1C, 0x70, 0x98, 0x10, 0x63, 0x79, 0xEB, 0x38, 0x6B, 
    0x24, 0x9B, 0xF1, 0xC6, 0x23, 0xFB, 0xBD, 0x5B, 0x71, 0xEF, 
    0xD3, 0x83, 0xF5, 0x4E, 0xAC, 0x09, 0x92, 0xA8, 0x31, 0x73, 
    0xA1, 0x25, 0x64, 0x03, 0x84, 0x3F, 0x17, 0x7C, 0x32, 0xE4, 
    0xBB, 0x57, 0x8C, 0x2A, 0x78, 0x51, 0x8A, 0xBF, 0xED, 0x0D, 
    0x94, 0xE1, 0x31, 0xA9, 0xFD, 0x97, 0x4C, 0x0C, 0xBB, 0x37, 
    0x04, 0x64, 0xEF, 0x33, 0xC2, 0x6F, 0x4C, 0x09, 0x86, 0x37, 
    0x74, 0xBC, 0x48, 0x82, 0x02, 0x98, 0x6B, 0x0D, 0x9E, 0x80, 0xD1, 

    0xB7, 0x46, 0xC3, 0x6F, 0x86, 0x49, 0x2D, 0xC9, 0x0D, 0xD7,         // 65
    0x4B, 0xBF, 0x5A, 0xED, 0x48, 0xD9, 0xC1, 0x50, 0x18, 0xFE, 
    0x8C, 0x5C, 0x3B, 0xAD, 0x62, 0x41, 0x0B, 0x9C, 0x2F, 0xAF, 
    0x01, 0x3B, 0xB5, 0x13, 0xC6, 0x3B, 0xD4, 0x4E, 0x88, 0xDC, 
    0x41, 0x7F, 0xC0, 0x33, 0x99, 0xD7, 0xB7, 0x51, 0xD4, 0x6A, 
    0x16, 0xA3, 0xEA, 0x43, 0xB6, 0xE4, 0x13, 0x44, 0xA3, 0x61, 
    0x3C, 0xB7, 0x06, 0x86, 0x22, 0x6E, 0xDC, 0x88, 0x5E, 0xF1, 
    0xD5, 0xA1, 0x23, 0xB1, 0x58, 0xE3, 0x30, 0xD7, 0x62, 0xE1, 
    0x94, 0x2D, 0xE7, 0x5D, 0x42, 0xB8, 0xE1, 0xC7, 0x31, 0xF8, 0x21, 

    0xDE, 0x68, 0x27, 0xA0, 0x1A, 0xE3, 0x75, 0x91, 0x57, 0xAF,         // 66
    0x2C, 0x80, 0x08, 0xB4, 0x8B, 0x32, 0x04, 0xA7, 0x82, 0xC9, 
    0x0A, 0xC0, 0xDB, 0x13, 0x8B, 0xD2, 0x78, 0xEA, 0x84, 0x53, 
    0xC3, 0x72, 0x92, 0x5F, 0xE8, 0x7E, 0x20, 0xEE, 0x0B, 0xC2, 
    0x15, 0xF8, 0xAB, 0xE5, 0x5B, 0x21, 0xF2, 0x92, 0x27, 0xB3, 
    0x89, 0x2D, 0x71, 0xD3, 0x0A, 0x65, 0x9A, 0xD0, 0x19, 0x87, 
    0xF8, 0x6E, 0xD9, 0x5C, 0xB4, 0x3E, 0xC5, 0x2D, 0xA5, 0x1C, 
    0x74, 0x4A, 0x87, 0xD2, 0x06, 0x83, 0x9F, 0xBD, 0x22, 0xB3, 
    0x0B, 0x66, 0xAA, 0xC2, 0xF2, 0x23, 0x63, 0x4B, 0xAE, 0x74, 0x52, 

    0x0D, 0x83, 0xFD, 0xCF, 0x60, 0xB4, 0x04, 0xDC, 0x25, 0xEE,         // 67
    0x90, 0xC7, 0xDD, 0x3A, 0x6E, 0xF8, 0x96, 0x65, 0xE0, 0x40, 
    0x76, 0xA2, 0x2A, 0x6E, 0xED, 0x4A, 0xB6, 0x19, 0xD0, 0x25, 
    0xFE, 0x1D, 0xE2, 0x2F, 0x9D, 0x54, 0xB9, 0x69, 0xA5, 0x59, 
    0x93, 0x61, 0x1D, 0x43, 0xC7, 0x6C, 0x82, 0x10, 0xC6, 0x40, 
    0xFC, 0x4D, 0xBE, 0x24, 0x85, 0xF9, 0x4B, 0x74, 0xE0, 0x31, 
    0xC7, 0x1C, 0x46, 0xC4, 0xEF, 0x09, 0x79, 0xEB, 0x52, 0x90, 
    0xC1, 0x10, 0xE8, 0x43, 0x6D, 0xF7, 0x13, 0x42, 0x79, 0x50, 
    0xF9, 0xCF, 0x13, 0x70, 0x39, 0xA3, 0x81, 0x19, 0xDB, 0x28, 0x98, 

    0xCC, 0x35, 0x9A, 0x13, 0x41, 0xEE, 0x52, 0xAB, 0x7A, 0x3C,         // 68
    0x61, 0x1A, 0x54, 0x9C, 0x21, 0xCE, 0x4D, 0x2C, 0xBA, 0x1C, 
    0x56, 0xEF, 0x48, 0x95, 0xBC, 0x03, 0x6B, 0x40, 0x93, 0x64, 
    0xA4, 0x50, 0xBD, 0x78, 0x15, 0xF9, 0x3E, 0x91, 0x2B, 0xEB, 
    0x39, 0xD2, 0x79, 0x98, 0x08, 0xB0, 0x34, 0xD7, 0x5C, 0x7A, 
    0x02, 0xDA, 0x92, 0x56, 0xA3, 0x37, 0xBC, 0x29, 0xB0, 0x51, 
    0xAA, 0x7B, 0x95, 0x2F, 0xA0, 0x59, 0xB1, 0x17, 0xCE, 0x29, 
    0xFB, 0x5F, 0xAD, 0x1B, 0xBA, 0x91, 0x5E, 0xC6, 0xEA, 0x9E, 
    0x33, 0x85, 0x4D, 0x99, 0xD5, 0x0D, 0xEB, 0x8F, 0xBE, 0x5F, 0xED, 

    0xAD, 0x55, 0x73, 0xBE, 0x7F, 0x97, 0x32, 0xC2, 0x18, 0xD1,         // 69
    0xA3, 0xF6, 0x7F, 0xE5, 0xBD, 0x0B, 0xAD, 0x7D, 0xF4, 0x93, 
    0xD3, 0x84, 0x0F, 0xE0, 0x2F, 0x86, 0xF7, 0xB0, 0xE6, 0x38, 
    0x83, 0x08, 0xD8, 0x49, 0xA7, 0xCC, 0x08, 0xE0, 0x77, 0xC8, 
    0x00, 0xB3, 0xEF, 0x54, 0xCE, 0xF7, 0x4C, 0x9A, 0xE8, 0xA9, 
    0x9D, 0x68, 0x14, 0xEF, 0xC4, 0x04, 0x81, 0xEC, 0x0E, 0x67, 
    0xF3, 0x01, 0xE1, 0x6A, 0x1B, 0x8E, 0xD6, 0x43, 0x87, 0x66, 
    0x9A, 0x3B, 0x7C, 0xC8, 0x55, 0x2E, 0xDB, 0x1E, 0x87, 0x00, 
    0x64, 0xBF, 0xE7, 0x24, 0x7B, 0x56, 0xC9, 0x3E, 0x05, 0x7D, 0x41, 

    0xC5, 0x07, 0xF3, 0x2C, 0xD4, 0x10, 0x6A, 0xFB, 0x88, 0x47,         // 70
    0x6A, 0x00, 0x2B, 0x4B, 0x86, 0x64, 0xE9, 0x25, 0x5D, 0x02, 
    0x38, 0xB1, 0x62, 0xCB, 0x58, 0xA3, 0x1E, 0x5B, 0x0C, 0xBE, 
    0xDE, 0x67, 0xB1, 0x2C, 0x85, 0x58, 0x6E, 0xBE, 0x1F, 0x55, 
    0x8E, 0x69, 0x1A, 0x3A, 0x89, 0x27, 0x78, 0x0A, 0x53, 0x23, 
    0x3C, 0xCE, 0x30, 0x7D, 0x44, 0xDB, 0x9D, 0x6E, 0xC6, 0x90, 
    0x3A, 0xBB, 0x4D, 0xCA, 0xF8, 0x3D, 0x71, 0xEE, 0x10, 0xBE, 
    0xDF, 0x03, 0xD7, 0x26, 0xEA, 0xA1, 0x74, 0xB3, 0x4B, 0xD4, 
    0xAC, 0x15, 0x43, 0xAF, 0xFE, 0x30, 0xA8, 0x69, 0xF7, 0xA0, 0x1D, 

    0xE8, 0x90, 0x5F, 0xA4, 0x48, 0xE1, 0xA9, 0x56, 0x0E, 0xE4,         // 71
    0xB2, 0xD6, 0x96, 0xA8, 0x31, 0xD5, 0x3F, 0x98, 0xB5, 0xCC, 
    0x71, 0xFA, 0x1D, 0x97, 0x3E, 0xC2, 0x75, 0xD3, 0x7F, 0x2E, 
    0x8E, 0x20, 0xF4, 0x95, 0x11, 0xED, 0x3A, 0x89, 0xB1, 0xFC, 
    0x41, 0xA3, 0xE5, 0xBC, 0x62, 0xA5, 0xE0, 0xBF, 0x90, 0xF6, 
    0x75, 0xB3, 0xE5, 0x9B, 0x69, 0x27, 0x57, 0x1C, 0x46, 0xDC, 
    0x22, 0x9E, 0x77, 0x2B, 0xAE, 0x07, 0xBB, 0x51, 0xA1, 0x35, 
    0x59, 0x8E, 0xA7, 0x46, 0x88, 0x08, 0x41, 0xF6, 0x6C, 0x30, 
    0xEE, 0x7C, 0xD7, 0x67, 0x04, 0x96, 0x82, 0x26, 0xCB, 0x4E, 0x85, 

    0x23, 0x39, 0xCF, 0x16, 0x6D, 0x8C, 0x28, 0x9D, 0xC7, 0x2D,         // 72
    0x78, 0x3C, 0x5C, 0xF0, 0x13, 0xBA, 0x72, 0x18, 0xE2, 0x45, 
    0x9B, 0x2A, 0x7C, 0xE3, 0x07, 0xF1, 0x29, 0x4A, 0xAF, 0xF9, 
    0x52, 0xC9, 0x42, 0x64, 0xC3, 0xAC, 0xD5, 0x2C, 0x5F, 0x14, 
    0xD4, 0x28, 0x7C, 0x0A, 0xD1, 0x1F, 0x41, 0x6B, 0x15, 0xC6, 
    0x47, 0x09, 0x58, 0x18, 0xF3, 0xB2, 0xCE, 0xFD, 0xAD, 0x85, 
    0x65, 0xF0, 0x0F, 0x87, 0x56, 0xDE, 0x84, 0x1F, 0xCD, 0x75, 
    0xF0, 0x22, 0x70, 0xF7, 0x62, 0xD2, 0xB9, 0x19, 0xAA, 0x8D, 
    0x1D, 0x51, 0x9B, 0x3C, 0xB8, 0xDD, 0x46, 0xE6, 0x10, 0xB1, 0x64, 

    0xB9, 0x77, 0x9C, 0xEC, 0xC2, 0x03, 0xF2, 0x3A, 0x60, 0x8D,         // 73
    0xF8, 0x15, 0xC5, 0x7F, 0x53, 0x8F, 0xFC, 0x56, 0x84, 0x0E, 
    0x60, 0xD5, 0xB9, 0x4C, 0x6A, 0xA1, 0x8C, 0xE0, 0x0F, 0x6A, 
    0xA8, 0x01, 0x7A, 0xDB, 0x31, 0x52, 0x05, 0xA0, 0xE3, 0x76, 
    0xB7, 0x50, 0x96, 0x5A, 0xFA, 0x7F, 0x9F, 0xED, 0x36, 0x82, 
    0xAD, 0xD6, 0x88, 0xBF, 0x42, 0x8B, 0x0C, 0x7A, 0x32, 0x12, 
    0xCC, 0x43, 0xBD, 0xE5, 0x9C, 0x32, 0x65, 0xFE, 0x91, 0x0A, 
    0xB5, 0x41, 0xC1, 0x10, 0x99, 0x28, 0x80, 0x55, 0xDD, 0x3D, 
    0xB8, 0xCD, 0x10, 0xF0, 0x73, 0x1D, 0x5D, 0xBC, 0x7A, 0x3C, 0xD7, 

    0xFC, 0x44, 0x1D, 0x56, 0x82, 0x4D, 0xD0, 0x76, 0xDD, 0x08,         // 74
    0xA0, 0x66, 0xAF, 0x27, 0xDF, 0x06, 0xA5, 0x2E, 0xC1, 0xF3, 
    0xB0, 0x37, 0x11, 0x90, 0xD0, 0x1A, 0x59, 0x33, 0xC0, 0x94, 
    0x37, 0xE3, 0x9C, 0x19, 0xA8, 0x7E, 0xEF, 0x6D, 0x42, 0x98, 
    0x07, 0xF2, 0xC2, 0x32, 0xB2, 0x48, 0x06, 0xCB, 0x5A, 0xDC, 
    0x1E, 0x64, 0x31, 0xDE, 0x71, 0x2D, 0xA3, 0x52, 0xBF, 0xEB, 
    0x5D, 0xAA, 0x2E, 0x6C, 0x17, 0xD6, 0xAD, 0x46, 0x2D, 0xDA, 
    0x50, 0x9B, 0xD7, 0x35, 0xE0, 0x4D, 0xF2, 0xC0, 0x04, 0x61, 
    0xF9, 0x69, 0x89, 0x2D, 0xC4, 0x8D, 0xA2, 0x2F, 0xF2, 0x92, 0x01, 

    0x5D, 0x8E, 0xDF, 0xB2, 0x2F, 0x98, 0xB0, 0x20, 0xB7, 0x53,         // 75
    0xD6, 0x20, 0xED, 0x3E, 0xC8, 0x6E, 0x3C, 0xDB, 0x69, 0x26, 
    0x88, 0xDD, 0x71, 0xEE, 0x3C, 0xB8, 0xF6, 0x72, 0xD9, 0x1F, 
    0x5D, 0x84, 0x49, 0xFC, 0x5B, 0x95, 0x29, 0xCC, 0x1B, 0xC5, 
    0x85, 0x3C, 0x70, 0x17, 0xDF, 0x63, 0x8B, 0xA8, 0x26, 0x99, 
    0x76, 0xFC, 0xA3, 0x01, 0xB7, 0xEA, 0x69, 0xDC, 0x3D, 0x91, 
    0x7D, 0x04, 0xFA, 0x95, 0x4E, 0xC3, 0x02, 0x7A, 0xC1, 0x67, 
    0x87, 0x1C, 0x5E, 0x84, 0xA7, 0x71, 0x14, 0x9A, 0x7A, 0xB2, 
    0x22, 0xA7, 0x54, 0xDD, 0x4A, 0x0D, 0xCB, 0x6B, 0x15, 0x51, 0xAC, 

    0x26, 0xD0, 0x0A, 0x78, 0xF9, 0x12, 0x68, 0x40, 0xEF, 0x7D,         // 76
    0x45, 0x91, 0x73, 0xA1, 0x50, 0x87, 0xBB, 0x93, 0x0B, 0xA7, 
    0x43, 0x58, 0xA0, 0x1D, 0x61, 0xAA, 0x03, 0x8A, 0x42, 0xAB, 
    0xF2, 0xBE, 0x0D, 0xCD, 0x21, 0xBF, 0x45, 0xAF, 0xF9, 0x54, 
    0x25, 0xE6, 0xA1, 0xCF, 0x98, 0x24, 0xF4, 0x6E, 0x45, 0xE7, 
    0x0D, 0x3A, 0x56, 0x8E, 0x48, 0x23, 0xC9, 0x08, 0x9E, 0x23, 
    0x4F, 0xB6, 0xCF, 0x3D, 0x7F, 0xEC, 0x56, 0x98, 0xF3, 0x0F, 
    0xE1, 0xBA, 0xFA, 0x01, 0x41, 0xCD, 0x37, 0xD9, 0x30, 0xE8, 
    0x45, 0x95, 0x06, 0xB6, 0x6D, 0xFB, 0x38, 0xE2, 0xB5, 0xD3, 0x71, 

    0xBB, 0x3C, 0x66, 0xC8, 0x45, 0xBE, 0xDE, 0x93, 0x0C, 0xA6,         // 77
    0x2E, 0xCC, 0x02, 0xDA, 0x23, 0xF7, 0x18, 0x58, 0xE6, 0x77, 
    0xEF, 0x05, 0xCE, 0x81, 0xC5, 0x29, 0xE7, 0x5F, 0xCC, 0x13, 
    0x78, 0x32, 0xAC, 0x6F, 0x8B, 0xEB, 0x67, 0x14, 0x7D, 0x9B, 
    0xD5, 0x69, 0x49, 0x01, 0x7B, 0x3F, 0xBC, 0x11, 0xCF, 0x7E, 
    0xBE, 0xAB, 0xCF, 0x6D, 0xF5, 0x95, 0x59, 0x80, 0xF8, 0xBD, 
    0xE6, 0x28, 0x64, 0x14, 0xB2, 0x2A, 0xA6, 0x20, 0x3B, 0xA9, 
    0x47, 0x27, 0x68, 0x96, 0xE9, 0xB7, 0x62, 0x8F, 0x57, 0x17, 
    0xC5, 0x75, 0xF3, 0x2F, 0x84, 0x9F, 0x58, 0x88, 0x22, 0x41, 0xEB, 

    0x7F, 0x97, 0xED, 0x21, 0xA1, 0x74, 0x2A, 0x51, 0xD0, 0x61,         // 78
    0xFD, 0xB7, 0x5B, 0x37, 0x98, 0x64, 0xD0, 0x3A, 0xC0, 0x31, 
    0x90, 0xB8, 0x2D, 0xF8, 0x47, 0x75, 0x92, 0x33, 0xB5, 0x4C, 
    0xDB, 0x5A, 0xEC, 0x2D, 0x4A, 0x08, 0xD7, 0xA5, 0x5C, 0x33, 
    0x0F, 0xA9, 0x89, 0xFE, 0x59, 0xAA, 0xE1, 0x54, 0x9D, 0x31, 
    0x60, 0xEC, 0x16, 0x34, 0xB9, 0x18, 0xB1, 0x32, 0x65, 0x11, 
    0x78, 0xA5, 0x93, 0xF1, 0xD7, 0x60, 0x88, 0xE4, 0x75, 0x5C, 
    0x97, 0x7B, 0xD1, 0x4C, 0x2F, 0x80, 0x0E, 0xFC, 0xBB, 0x81, 
    0xDE, 0x5C, 0x40, 0xBF, 0x17, 0xD8, 0x05, 0xA9, 0x75, 0x9B, 0x08, 

    0x5F, 0x18, 0xB4, 0x59, 0x8A, 0x02, 0xF4, 0xAF, 0x7F, 0x24,         // 79
    0x8F, 0x17, 0x82, 0xE9, 0xB9, 0x0E, 0x85, 0xA5, 0x70, 0x1B, 
    0xD7, 0x4E, 0x6C, 0x98, 0x0E, 0xD1, 0xA6, 0x0A, 0xFE, 0x85, 
    0xA2, 0x05, 0x8F, 0xBC, 0xDD, 0x9F, 0x82, 0x3D, 0xBB, 0xCD, 
    0xF0, 0x43, 0x29, 0xC5, 0xB2, 0x2D, 0x16, 0x76, 0xF9, 0x03, 
    0x8E, 0x4D, 0x83, 0xDD, 0x78, 0x45, 0xE6, 0xD2, 0x8D, 0x41, 
    0xCE, 0x51, 0x31, 0x6E, 0x0E, 0x47, 0xCE, 0x09, 0xAF, 0xD5, 
    0x12, 0xEF, 0xAD, 0x0B, 0xCA, 0x9E, 0x26, 0xAC, 0x3F, 0x09, 
    0x9C, 0x20, 0xAD, 0xE5, 0x65, 0x47, 0xC3, 0x2D, 0xF1, 0x4D, 0xCB, 

    0xFA, 0x48, 0xD5, 0x35, 0xE4, 0xC3, 0x66, 0x39, 0xDB, 0x4E,         // 80
    0xA2, 0x67, 0xD1, 0x43, 0x6D, 0xF2, 0x33, 0xDA, 0x46, 0xFB, 
    0x82, 0x15, 0xA7, 0x38, 0xE0, 0x66, 0x4F, 0xD9, 0x6D, 0x1E, 
    0x3B, 0xD2, 0x73, 0x16, 0x56, 0x6E, 0x22, 0xF3, 0x0A, 0x73, 
    0x99, 0x63, 0xE0, 0x14, 0x6E, 0xD7, 0x88, 0xB8, 0x41, 0xAC, 
    0xD2, 0x28, 0xA0, 0x0C, 0xC7, 0x62, 0x04, 0xAA, 0x25, 0xB4, 
    0xE2, 0x06, 0xC6, 0x8A, 0xBD, 0xAB, 0x72, 0x3E, 0xFB, 0x2F, 
    0xC1, 0x42, 0x73, 0x5E, 0xF5, 0x52, 0x78, 0xDC, 0x68, 0xF0, 
    0x4B, 0xD7, 0x7B, 0x37, 0x97, 0xEE, 0x8C, 0x63, 0xD2, 0x1B, 0xAE, 

    0x0C, 0x82, 0x9B, 0x73, 0x1A, 0x4B, 0x92, 0x1E, 0xB9, 0x07,         // 81
    0xEA, 0x31, 0xAF, 0x09, 0x93, 0x1E, 0x56, 0x9A, 0x00, 0xB0, 
    0x5A, 0xC7, 0xEE, 0x7A, 0xB9, 0x1D, 0x8C, 0x3F, 0xAC, 0xC9, 
    0x62, 0xEF, 0x44, 0xA7, 0xFB, 0xBF, 0x4C, 0xD3, 0x87, 0x53, 
    0x1B, 0xA9, 0x7D, 0x94, 0x38, 0x4C, 0xEF, 0x5B, 0x1C, 0xE2, 
    0x64, 0xB8, 0xF8, 0x3F, 0x95, 0xEE, 0x83, 0x52, 0xF6, 0x5B, 
    0x73, 0x9A, 0xFD, 0x3E, 0x26, 0xEF, 0x17, 0x9D, 0x52, 0x7D, 
    0x94, 0x1C, 0xE2, 0x8C, 0x18, 0xBA, 0x3C, 0xC3, 0x28, 0x8F, 
    0x70, 0xBD, 0x00, 0xA7, 0x26, 0x76, 0x10, 0xA5, 0x33, 0x87, 0x6A, 

    0x42, 0xC9, 0x2D, 0xF4, 0xB5, 0xD8, 0xA4, 0x83, 0xF9, 0x74,         // 82
    0xC6, 0x54, 0xE3, 0x78, 0xD4, 0xB2, 0xE2, 0x7E, 0x61, 0xD1, 
    0x24, 0x93, 0x0C, 0x54, 0x30, 0xF5, 0xC2, 0x11, 0xE6, 0x2F, 
    0x8B, 0xB3, 0x1C, 0x7F, 0x35, 0x00, 0x91, 0xA7, 0x26, 0xEC, 
    0xC9, 0x4E, 0x08, 0xF5, 0xC8, 0xA2, 0x06, 0xC3, 0x72, 0x8C, 
    0x33, 0x13, 0x80, 0x59, 0x23, 0xB4, 0x3B, 0xCC, 0x17, 0x89, 
    0x39, 0x1C, 0x57, 0x77, 0xD1, 0x5C, 0x88, 0xDD, 0xC7, 0x04, 
    0xB9, 0x59, 0xCC, 0x30, 0xA0, 0xE6, 0x03, 0x99, 0x56, 0xD0, 
    0x12, 0x44, 0xFE, 0x59, 0xD9, 0xC7, 0x3E, 0xF8, 0x56, 0xE7, 0xBF, 

    0xA2, 0xE2, 0x58, 0x06, 0x67, 0x37, 0x10, 0x5D, 0x42, 0x2B,         // 83
    0x91, 0x12, 0xAA, 0x24, 0x5B, 0x40, 0x28, 0xBB, 0xF4, 0x32, 
    0x76, 0x44, 0xD6, 0xA6, 0x94, 0x6F, 0x57, 0x9E, 0x79, 0x50, 
    0x07, 0xC6, 0x53, 0x95, 0xCF, 0xE5, 0x77, 0x38, 0x66, 0xB0, 
    0x3E, 0xDC, 0xA0, 0x5D, 0x1F, 0x6D, 0x8F, 0x30, 0xEB, 0xA1, 
    0x4D, 0xCE, 0xE6, 0xAD, 0x71, 0xDC, 0x0F, 0x6B, 0xA2, 0xC4, 
    0xEC, 0xB0, 0xD8, 0xA1, 0x02, 0xB9, 0x2A, 0x70, 0x32, 0x66, 
    0xE7, 0x24, 0xAE, 0x6C, 0x45, 0x7F, 0x63, 0xF9, 0x19, 0xA7, 
    0xE2, 0xA0, 0x8B, 0x72, 0x17, 0x4F, 0xB2, 0x7E, 0x03, 0x96, 0x27, 

    0x7C, 0x14, 0x8D, 0xA6, 0x7F, 0xEF, 0xAE, 0xDD, 0xBE, 0xA3,         // 84
    0x64, 0xF5, 0x3D, 0xB6, 0xEF, 0x9E, 0x6D, 0x0D, 0x4D, 0xAB, 
    0xE6, 0xB6, 0x68, 0x21, 0xE4, 0x02, 0xD3, 0x2A, 0xF8, 0xAF, 
    0xDE, 0x6B, 0xF2, 0x27, 0xAE, 0x5C, 0x13, 0xF7, 0xBE, 0x0A, 
    0x88, 0x24, 0x74, 0x33, 0xE3, 0xB7, 0x49, 0xCD, 0x57, 0x0B, 
    0xBE, 0x6D, 0x41, 0x00, 0xC4, 0x55, 0x93, 0xF1, 0x2B, 0x4B, 
    0x0D, 0x7C, 0x2C, 0x44, 0x8D, 0xE9, 0x4E, 0xB3, 0xF3, 0x9B, 
    0x3E, 0x8B, 0xFD, 0x09, 0xDE, 0xA8, 0x24, 0xCC, 0x89, 0x35, 
    0x5D, 0x23, 0x3D, 0xBA, 0xE4, 0x95, 0x23, 0xDE, 0x69, 0xCB, 0x51, 

    0x32, 0xFD, 0xC0, 0x3B, 0xC8, 0x52, 0x2F, 0x75, 0x03, 0xE8,         // 85
    0x22, 0x82, 0xCB, 0x70, 0x04, 0x84, 0xE5, 0xCA, 0x8D, 0x1A, 
    0x7F, 0x06, 0xFD, 0x3E, 0x84, 0xB8, 0x4C, 0x8F, 0x64, 0x15, 
    0x3B, 0xA1, 0x0F, 0x75, 0x40, 0xC5, 0x98, 0x4B, 0xD9, 0x9C, 
    0x5F, 0xFC, 0xAC, 0xD0, 0x84, 0x11, 0xF9, 0x23, 0xA6, 0x7C, 
    0xF6, 0x21, 0x9A, 0x84, 0xFB, 0x1F, 0x42, 0xD1, 0x76, 0x95, 
    0xDF, 0x62, 0xC1, 0xF6, 0x64, 0x21, 0xD3, 0x0A, 0x84, 0x17, 
    0xCA, 0x50, 0x78, 0x36, 0xC4, 0x51, 0x95, 0x40, 0x69, 0xF1, 
    0x7C, 0xC7, 0xEC, 0x08, 0x5D, 0x81, 0xC5, 0x40, 0xAC, 0x1C, 0xD8, 

    0xB6, 0x71, 0x5B, 0x1E, 0xDB, 0x14, 0x92, 0xCD, 0x54, 0x9B,         // 86
    0x44, 0xDA, 0x54, 0x35, 0xC2, 0x25, 0x51, 0x31, 0xB3, 0x5B, 
    0xD8, 0x52, 0x90, 0xC9, 0x62, 0x2E, 0xEA, 0x1C, 0xBF, 0xD6, 
    0x89, 0x4C, 0xCF, 0x8E, 0xDF, 0x19, 0x7D, 0x2B, 0x70, 0x1F, 
    0x44, 0xB7, 0x04, 0x3C, 0x59, 0xA4, 0x66, 0x88, 0xDC, 0x2B, 
    0x60, 0xB4, 0xDB, 0x35, 0x64, 0xA3, 0x7E, 0xB8, 0x05, 0x5D, 
    0xBA, 0x23, 0x97, 0x0E, 0x7E, 0xA9, 0x98, 0x6A, 0x49, 0xE3, 
    0xB5, 0x20, 0xD9, 0xA3, 0x81, 0x16, 0xE9, 0xBD, 0x05, 0xB2, 
    0x14, 0x94, 0x6C, 0xA3, 0x2E, 0xF2, 0x0C, 0x60, 0xF6, 0x85, 0x5D, 

    0x90, 0x00, 0xE5, 0x9B, 0x76, 0xB4, 0x66, 0xFC, 0x1E, 0x80,         // 87
    0xB6, 0x0B, 0x91, 0xAE, 0xFE, 0x94, 0xD0, 0x76, 0xF6, 0x22, 
    0xC0, 0x38, 0xA8, 0x16, 0xE0, 0x9F, 0x7A, 0xAD, 0x46, 0x77, 
    0x21, 0xFA, 0xB9, 0x2A, 0x56, 0xF1, 0xB4, 0xD3, 0xAA, 0xEE, 
    0x81, 0xDF, 0x6F, 0x98, 0xF1, 0x32, 0xC2, 0x02, 0x45, 0xC8, 
    0x91, 0x09, 0x4D, 0xBE, 0x0E, 0xE9, 0x28, 0xE1, 0x36, 0xA6, 
    0xF0, 0x3E, 0xD0, 0x4A, 0xE4, 0x56, 0x2F, 0xFA, 0xAC, 0x32, 
    0x67, 0x94, 0x59, 0x0E, 0xF2, 0x61, 0x2F, 0x76, 0xDE, 0x45, 
    0xD5, 0x54, 0x1E, 0xCF, 0x45, 0xB7, 0x74, 0x99, 0x39, 0x0E, 0xE1, 

    0x28, 0xA8, 0x48, 0x2B, 0xF4, 0x3D, 0x0C, 0xAC, 0x36, 0xCA,         // 88
    0x5F, 0xF1, 0x30, 0x65, 0x16, 0x43, 0x60, 0x08, 0x9C, 0x84, 
    0x67, 0xEA, 0x29, 0x74, 0x4A, 0x0C, 0x5A, 0xF6, 0x06, 0xE3, 
    0x9D, 0x5A, 0x0B, 0x69, 0x9F, 0x36, 0x03, 0x5D, 0x3E, 0x0D, 
    0xC6, 0x26, 0x48, 0xCA, 0x16, 0x7D, 0xE7, 0x9A, 0x5B, 0xEA, 
    0x3D, 0x79, 0xF0, 0x97, 0x72, 0xCA, 0x4A, 0x6D, 0x98, 0x4E, 
    0x15, 0x8E, 0x6C, 0xB1, 0x1A, 0xC6, 0x8C, 0x0E, 0xCD, 0x7E, 
    0x00, 0xF6, 0xBF, 0x41, 0x91, 0xCB, 0xAE, 0x53, 0x9F, 0x8A, 
    0x2A, 0xB0, 0xF9, 0x86, 0x64, 0xD8, 0x17, 0xE5, 0xAF, 0xC7, 0x4C, 

    0xF7, 0x77, 0xC7, 0x89, 0x60, 0xC3, 0xDE, 0x8A, 0x58, 0xEA,         // 89
    0x29, 0x75, 0xBE, 0xD4, 0x7E, 0xDC, 0xB9, 0xE9, 0x3B, 0xD5, 
    0x0C, 0xA0, 0x88, 0xF7, 0xAD, 0xD8, 0x8F, 0x33, 0xC8, 0x69, 
    0x2B, 0xB3, 0x84, 0xD7, 0xC1, 0x72, 0x97, 0xE0, 0xB8, 0x6A, 
    0x96, 0x5C, 0xA9, 0x89, 0xDB, 0x4E, 0x21, 0x71, 0xBA, 0x13, 
    0xAD, 0xC5, 0x26, 0x59, 0x1E, 0x85, 0xB2, 0x10, 0xFE, 0xC2, 
    0x7C, 0xDA, 0x02, 0xF7, 0x80, 0x46, 0xE1, 0x70, 0x4B, 0xBB, 
    0x9F, 0x3B, 0x77, 0xDA, 0x22, 0x7A, 0x0B, 0xFC, 0x1D, 0x68, 
    0xE2, 0x7B, 0x37, 0x01, 0x9A, 0x31, 0x89, 0x48, 0x20, 0x6A, 0x98, 

    0x58, 0x1F, 0xD9, 0x0A, 0x9F, 0x27, 0x48, 0x74, 0xB8, 0x13,         // 90
    0x8F, 0xA6, 0x4A, 0x04, 0x97, 0x26, 0xA2, 0x1B, 0x73, 0x4C, 
    0xB4, 0x5D, 0x42, 0x13, 0xC8, 0x2A, 0x73, 0xB9, 0x4E, 0x87, 
    0xCD, 0x46, 0xEA, 0x39, 0x13, 0xFE, 0x44, 0x81, 0x2B, 0xF6, 
    0x15, 0xE5, 0x37, 0x07, 0x61, 0xB6, 0xD1, 0x3D, 0xFD, 0x82, 
    0x2D, 0x65, 0xDF, 0xAA, 0xF7, 0x3A, 0xD9, 0x8D, 0x26, 0x63, 
    0x35, 0xB6, 0x5A, 0x38, 0x9A, 0x27, 0xB5, 0x17, 0xEC, 0x2C, 
    0xD7, 0x63, 0x12, 0xAD, 0x5A, 0xEB, 0x4C, 0xB5, 0x39, 0xC9, 
    0x12, 0x4F, 0xC2, 0xE9, 0xB2, 0x59, 0xF5, 0xB6, 0x7F, 0xD3, 0x32, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\formatconverter.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Format Converter
*
* Abstract:
*
*   A class which converts scanlines from one pixel format to another.
*   
* Created:
*
*   12/10/1999 agodfrey
*       Created it (using source in Imaging\Api\ConvertFmt.cpp)
*
\**************************************************************************/

#ifndef _FORMATCONVERTER_HPP
#define _FORMATCONVERTER_HPP

#include "ScanOperation.hpp"

/**************************************************************************\
*
* Description:
*
*   Class for handling the pixel format conversion for a scanline
*
\**************************************************************************/

class EpFormatConverter
{
public:
    EpFormatConverter()
    {
        TempBuf[0] = NULL;
        TempBuf[1] = NULL;
        ClonedSourcePalette = NULL;
    }
    
    ~EpFormatConverter()
    {
        FreeBuffers();
    }

    HRESULT
    Initialize(
        const BitmapData *dstbmp,
        const ColorPalette *dstpal,
        const BitmapData *srcbmp,
        const ColorPalette *srcpal
        );

    BOOL
    CanDoConvert(
        const PixelFormatID srcFmt,
        const PixelFormatID dstFmt
        );

    VOID Convert(VOID *dst, const VOID *src)
    {
        PipelineItem *pipelinePtr = &Pipeline[0];
        const VOID *currentSrc = src;
        VOID *currentDst = pipelinePtr->Dst;
        
        // Do the intermediate operations, if any
        
        while (currentDst)
        {
            pipelinePtr->Op(currentDst, currentSrc, Width, &OperationParameters);
            pipelinePtr++;
            currentSrc = currentDst;
            currentDst = pipelinePtr->Dst;
        }
        
        // Do the last operation, to the final destination
        
        pipelinePtr->Op(dst, currentSrc, Width, &OperationParameters);
    }

private:
    // We represent the pipeline with an array of PipelineItem structures.
    // PixelFormat is the destination pixel format.
    // Dst is the destination temporary buffer, or NULL for the last
    //   item in the pipeline (in which case we output to the final 
    //   destination.)
        
    struct PipelineItem
    {
        ScanOperation::ScanOpFunc Op;
        PixelFormatID PixelFormat;
        VOID *Dst;
    };

    HRESULT AddOperation(
        PipelineItem **pipelinePtr,
        const ScanOperation::ScanOpFunc newOperation,
        PixelFormatID pixelFormat
        );
        
    VOID FreeBuffers()
    {
        if (TempBuf[0])
        {   
            GpFree(TempBuf[0]); 
            TempBuf[0] = NULL;
        }
        if (TempBuf[1])
        {    
            GpFree(TempBuf[1]); 
            TempBuf[1] = NULL;
        }
        if (ClonedSourcePalette)
        {
            GpFree(ClonedSourcePalette);
            ClonedSourcePalette = NULL;
        }
    }
    
    UINT Width;                 // scanline width

    ColorPalette *ClonedSourcePalette;    
    ScanOperation::OtherParams OperationParameters;
    PipelineItem Pipeline[3];   // the scan operation pipeline
    VOID *TempBuf[2];           // temporary buffers for indirect conversion
};

/**************************************************************************\
*
* Function Description:
*
*   Halftone an image from 32bpp to 8bpp.
*
*   The GIF encoder wants to use our halftone code to convert from 32bpp 
*   to 8bpp. But neither it nor Imaging want to use our full-blown AlphaBlender
*   interface, because that pulls in all of the scan operation code. This
*   function exposes the 8bpp halftone code to the GIF encoder, to address
*   its specific needs.
*
*   !!![agodfrey] This needs to be revisited. The way I see it working
*      eventually: We get rid of this function and EpFormatConverter; all
*      clients use EpAlphaBlender to get what they want. (Imaging format
*      conversion would ask for a 'SrcCopy' operation.) But this would
*      require EpAlphaBlender to be expanded - it would need to support an
*      arbitrary input format, at least for SrcCopy.
*
* Arguments:
*
*   [IN]      src        - pointer to scan0 of source image
*   [IN]      srcStride  - stride of src image (can be negative)
*   [IN]      dst        - pointer to scan0 of destination 8-bpp image
*   [IN]      dstStride  - stride of dst image (can be negative)
*   [IN]      width      - image width
*   [IN]      height     - image height
*   [IN]      orgX       - where the upper-left corner of image starts
*   [IN]      orgY       - for computing the halftone cell origin
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/29/1999 DCurtis
*     Created it.
*   01/20/2000 AGodfrey
*     Moved it from Imaging\Api\Colorpal.cpp/hpp.
*
\**************************************************************************/

VOID
Halftone32bppTo8bpp(
    const BYTE* src,
    INT srcStride,
    BYTE* dst,
    INT dstStride,
    UINT width,
    UINT height,
    INT orgX,
    INT orgY
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\httables.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   HtTables.hpp
*
* Abstract:
*
*   Tables for doing halftoning, using Daniel Chou's supercell technique
*
* Created:
*
*   10/29/1999 DCurtis
*
\**************************************************************************/

#ifndef _HTTABLES_HPP
#define _HTTABLES_HPP

typedef struct {
    WORD            palVersion;
    WORD            palNumEntries;
    PALETTEENTRY    palPalEntry[256];
} GDIP_LOGPALETTE256;

extern GDIP_LOGPALETTE256 HTColorPalette;
extern GDIP_LOGPALETTE256 Win9xHalftonePalette;
extern const BYTE GammaTable216[];
extern const BYTE InverseGammaTable216[];
extern const BYTE GammaTable16[];
extern const BYTE InverseGammaTable16[];
extern const BYTE HT_216_8x8[];
extern const BYTE HT_SuperCell_Red216[];
extern const BYTE HT_SuperCell_Green216[];
extern const BYTE HT_SuperCell_Blue216[];
extern const BYTE HT_SuperCell_RedMono[];
extern const BYTE HT_SuperCell_GreenMono[];
extern const BYTE HT_SuperCell_BlueMono[];

#endif // _HTTABLES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\nearestneighbor.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   nearestneighbor.cpp
*
* Abstract:
*
*   Nearest Neighbor Resampling code
*
* Created:
*
*   3/3/2000 asecchia
\**************************************************************************/

#include "precomp.hpp"

DpOutputNearestNeighborSpan::DpOutputNearestNeighborSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    Scan     = scan;
    NWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap   = bitmap;

    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL)dBitmap->Height;
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}


GpStatus
DpOutputNearestNeighborSpan::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    GpPointF p1, p2;
    p1.X = (REAL) xMin;
    p1.Y = p2.Y = (REAL) y;
    p2.X = (REAL) xMax;

    DeviceToWorld.Transform(&p1);
    DeviceToWorld.Transform(&p2);

    // Convert to Fixed point notation - 16 bits of fractional precision.
    FIX16 dx, dy, x0, y0;
    x0 = GpRound(p1.X*FIX16_ONE);
    y0 = GpRound(p1.Y*FIX16_ONE);

    ASSERT(xMin < xMax);
    dx = GpRound(((p2.X - p1.X)*FIX16_ONE)/(xMax-xMin));
    dy = GpRound(((p2.Y - p1.Y)*FIX16_ONE)/(xMax-xMin));

    return OutputSpanIncremental(y, xMin, xMax, x0, y0, dx, dy);
}

GpStatus
DpOutputNearestNeighborSpan::OutputSpanIncremental(
    INT      y,
    INT      xMin,
    INT      xMax,
    FIX16    x0,
    FIX16    y0,
    FIX16    dx,
    FIX16    dy
    )
{
    INT width  = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, width);
    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    INT ix;
    INT iy;

    // For all pixels in the destination span...
    for(int i=0; i<width; i++)
    {
        // .. compute the position in source space.

        // round to the nearest neighbor
        ix = (x0 + FIX16_HALF) >> FIX16_SHIFT;
        iy = (y0 + FIX16_HALF) >> FIX16_SHIFT;

        if( ((UINT)ix >= (UINT)BmpData.Width ) ||
            ((UINT)iy >= (UINT)BmpData.Height) )
        {
            ApplyWrapMode(NWrapMode, ix, iy, BmpData.Width, BmpData.Height);
        }

        // Make sure the pixel is within the bounds of the source before
        // accessing it.

        if( (ix >= 0) &&
            (iy >= 0) &&
            (ix < (INT)BmpData.Width) &&
            (iy < (INT)(BmpData.Height)) )
        {
            *buffer++ = *(srcPtr0+stride*iy+ix);
        }
        else
        {
            // This means that this source pixel is outside of the valid
            // bits in the source. (edge condition)
            *buffer++ = ClampColor;
        }


        // Update source position
        x0 += dx;
        y0 += dy;
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\line.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   One-pixel-wide solid aliased lines
*
* Abstract:
*
*   Draws aliased solid-color lines which are one pixel wide.
*   Supports clipping against complex clipping regions. 
*
* History:
*
*   03/31/1999 AMatos
*       Created it.
*   08/17/1999 AGodfrey
*       Separated aliased from antialiased.
*
\**************************************************************************/

#include "precomp.hpp" 

#pragma optimize("a",on)

//------------------------------------------------------------------------
// Global array that stores all the different options of drawing functions. 
// If the order of the functions change, the offset constants must also 
// change.  
//------------------------------------------------------------------------

#define FUNC_X_MAJOR     0
#define FUNC_Y_MAJOR     1
#define FUNC_CLIP_OFFSET 2

typedef VOID (OnePixelLineDDAAliased::*DDAFunc)(DpScanBuffer*);

static DDAFunc gDrawFunctions[] = { 
    OnePixelLineDDAAliased::DrawXMajor, 
    OnePixelLineDDAAliased::DrawYMajor, 
    OnePixelLineDDAAliased::DrawXMajorClip, 
    OnePixelLineDDAAliased::DrawYMajorClip, 
};

//------------------------------------------------------------------------
// Constants used for manipulating fixed point and doing all the bitwise 
// operations on the aliased and antialiased DDA. I know some of these
// are already defined elsewhere, but I do it again here as it might be nice to 
// keep this independent of the rest of gdiplus. 
//------------------------------------------------------------------------

// Fixed point 

#define RealToFix GpRealToFix4 

#define FBITS     4
#define FMASK     0xf
#define FINVMASK  0xfffffff0
#define FSIZE     16
#define FHALF     8
#define FHALFMASK 7

/**************************************************************************\
*
* Function Description:
*
* Does all the DDA setup that is common to aliased and antialiased
* lines. 
*
* Arguments:
*
*   [IN] point1   - end point
*   [IN] point2   - end point
*   [IN] drawLast - FALSE if the line is to be end-exclusive

* Return Value:
*
* Returns TRUE if the drawing should continue, meaning the line
* has non-zero length. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL
OnePixelLineDDAAliased::SetupCommon( 
    GpPointF *point1, 
    GpPointF *point2, 
    BOOL drawLast,
    INT width
    )
{
    MaximumWidth = width;
    
    // Turn the points into fixed 28.4 

    INT x1 = RealToFix(point1->X); 
    INT x2 = RealToFix(point2->X); 
    
    REAL rDeltaX = point2->X - point1->X; 
    REAL rDeltaY = point2->Y - point1->Y; 

    if( rDeltaX == 0 && rDeltaY == 0 ) 
    {
        return FALSE; 
    }

    INT xDir = 1; 

    if(rDeltaX < 0)
    {
        rDeltaX = -rDeltaX; 
        xDir = -1; 
    }

    INT y1 = RealToFix(point1->Y); 
    INT y2 = RealToFix(point2->Y); 

    INT yDir = 1; 

    if( rDeltaY < 0)
    {
        rDeltaY = -rDeltaY; 
        yDir = -1;
    }

    Flipped = FALSE; 

    if( rDeltaY >= rDeltaX ) 
    {
        // y-major 
                
        // Invert the endpoints if necessary       

        if(yDir == -1)
        {
            INT tmp = y1; 
            y1 = y2; 
            y2 = tmp; 
            tmp = x1;
            x1 = x2; 
            x2 = tmp; 
            xDir = -xDir; 
            Flipped = TRUE; 
        }

        // Determine the Slope 
        
        Slope = xDir*rDeltaX/rDeltaY; 

        // Initialize the Start and End points 

        IsXMajor = FALSE; 
        MajorStart = y1; 
        MajorEnd = y2; 
        MinorStart = x1; 
        MinorEnd = x2; 
        MinorDir = xDir;

        // Mark that we'll use the y-major functions. 

        DrawFuncIndex = FUNC_Y_MAJOR; 
    }
    else
    {
        // x-major        

        // Invert the endpoints if necessary        

        if(xDir == -1)
        {
            INT tmp = x1; 
            x1 = x2; 
            x2 = tmp; 
            tmp = y1;
            y1 = y2; 
            y2 = tmp; 
            yDir = -yDir; 
            Flipped = TRUE; 
        }

        Slope = yDir*rDeltaY/rDeltaX; 

        // Initialize the rest

        IsXMajor = TRUE; 
        MajorStart = x1; 
        MajorEnd = x2; 
        MinorStart = y1; 
        MinorEnd = y2; 
        MinorDir = yDir; 

        // Mark that we'll use the x-major functions. 

        DrawFuncIndex = FUNC_X_MAJOR;
    }

    // Initialize the Deltas. In fixed point. 

    DMajor = MajorEnd - MajorStart; 
    DMinor = (MinorEnd - MinorStart)*MinorDir; 

    // Mark if we're drawing end-exclusive 

    IsEndExclusive = !drawLast; 

    return TRUE; 
}


//------------------------------------------------------------------------
// Functions specific to the aliased lines
//------------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Does the part of the DDA setup that is specific for aliased lines. 
*
* Basically it uses the diamond rule to find the integer endpoints 
* based on the fixed point values and substitutes these for the 
* integer results coordinates. Also calculates the error values. 
*
* Arguments:
*
* Return Value:
*
* Returns FALSE if the drawing should not continue, meaning the line
* has a length of less than 1, and should not be drawn by the GIQ rule.
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAliased::SetupAliased()
{            
    // Do the GIQ rule to determine which pixel to start at.         

    BOOL SlopeIsOne = (DMajor == DMinor); 
    BOOL SlopeIsPosOne =  SlopeIsOne && (1 == MinorDir); 

    // These will store the integer values. 

    INT major, minor;
    INT majorEnd, minorEnd;

    // Find the rounded values in fixed point. The rounding
    // rules when a coordinate is halfway between two 
    // integers is given by the GIQ rule. 

    minor    = (MinorStart + FHALFMASK) & FINVMASK;
    minorEnd = (MinorEnd   + FHALFMASK) & FINVMASK; 

    BOOL isEndIn, isStartIn; 

    if(IsXMajor)
    {   
        if(SlopeIsPosOne)
        {
            major    = (MajorStart + FHALF) & FINVMASK;
            majorEnd = (MajorEnd   + FHALF) & FINVMASK;         
        }
        else
        {
            major    = (MajorStart + FHALFMASK) & FINVMASK;
            majorEnd = (MajorEnd   + FHALFMASK) & FINVMASK;                 
        }

        isStartIn = IsInDiamond(MajorStart - major, MinorStart - minor, 
            SlopeIsOne, SlopeIsPosOne);
        isEndIn   = IsInDiamond(MajorEnd - majorEnd, MinorEnd - minorEnd, 
            SlopeIsOne, SlopeIsPosOne);
    }
    else
    {
        major = (MajorStart + FHALFMASK) & FINVMASK;
        majorEnd = (MajorEnd + FHALFMASK) & FINVMASK;                 
        
        isStartIn = IsInDiamond(MinorStart - minor, MajorStart - major, 
            FALSE, FALSE);
        isEndIn   = IsInDiamond(MinorEnd - minorEnd, MajorEnd - majorEnd, 
            FALSE, FALSE);
    }

    // Determine if we need to advance the initial point. 

    if(!(Flipped && IsEndExclusive))
    {
        if(((MajorStart & FMASK) <= FHALF) && !isStartIn)
        {
            major += FSIZE;    
        }
    }
    else
    {   
        if(isStartIn || ((MajorStart & FMASK) <= FHALF))
        {
            major += FSIZE; 
        }
    }
    
    // Adjust the initial minor coordinate accodingly

    minor = GpFloor(MinorStart + (major - MajorStart)*Slope); 

    // Bring the initial major coordinate to integer

    major = major >> FBITS;                 

    // Do the same for the end point. 

    if(!Flipped && IsEndExclusive)
    {
        if(((MajorEnd & FMASK) > FHALF) || isEndIn)
        {
            majorEnd -= FSIZE;    
        }
    }
    else
    {   
        if(!isEndIn && ((MajorEnd & FMASK) > FHALF))
        {
            majorEnd -= FSIZE; 
        }
    }

    minorEnd = GpFloor(MinorEnd + (majorEnd - MajorEnd)*Slope); 

    majorEnd = majorEnd >> FBITS;

    // If End is smaller than Start, that means we have a line that
    // is smaller than a pixel and bu the diamond rule it should
    // not be drawn. 

    if(majorEnd < major)
    {
        return FALSE; 
    }

    // Get the error correction values. 
    
    ErrorUp     = DMinor << 1; 
    ErrorDown   = DMajor << 1; 

   
    INT MinorInt;

    // Take out the fractions from the DDA. GDI's rounding
    // doesn't depend on direction, so for compatability
    // round down as GDI does when LINEADJUST281816 is
    // defined (see Office 10 bug 281816).  Otherwise the rounding 
    // rule for the minor coordinate depends on the direction
    // we are going. 
    
#ifdef LINEADJUST281816
    MinorInt = (minor + FHALFMASK) & FINVMASK;
    minorEnd = (minorEnd + FHALFMASK) >> FBITS; 
#else
    if(MinorDir == 1)
    {
        MinorInt = (minor + FHALF) & FINVMASK;
        minorEnd = (minorEnd + FHALF) >> FBITS; 
    }
    else
    {
        MinorInt = (minor + FHALFMASK) & FINVMASK;
        minorEnd = (minorEnd + FHALFMASK) >> FBITS; 
    }
#endif   

    // Calculate the initial error based on our fractional 
    // position in fixed point and convert to integer. 

    Error = -ErrorDown*(FHALF + MinorDir*(MinorInt - minor)); 
    minor = MinorInt >> FBITS; 
    Error >>= FBITS;  

    // Update the class variables

    MinorStart = minor; 
    MinorEnd   = minorEnd; 
    MajorStart = major; 
    MajorEnd   = majorEnd; 
            
    return TRUE; 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawYMajor(
    DpScanBuffer *scan
    )
{
    // Do the DDA loop for the case where there is no complex 
    // clipping region. 
    
    ARGB *buffer;          
    INT numPixels = MajorEnd - MajorStart; 

    while(numPixels >= 0) 
    {
        buffer = scan->NextBuffer(MinorStart, MajorStart, 1);          

        *buffer = Color;
        MajorStart++; 
        Error += ErrorUp; 
    
        if( Error > 0 ) 
        {
            MinorStart += MinorDir; 
            Error -= ErrorDown; 
        }

        numPixels--; 
    } 
    
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID 
OnePixelLineDDAAliased::DrawXMajor(
    DpScanBuffer *scan
    )
{    
    INT numPixels = MajorEnd - MajorStart + 1; 
    ARGB *buffer;  
    INT width = 0;

    const INT maxWidth = MaximumWidth;
    // Run the DDA. First accumulate the width, and when 
    // the scanline changes write the whole scanline at
    // once. 

    buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 

    while(numPixels--) 
    {
        MajorStart++;
        *buffer++ = Color; 
        width++; 
        Error += ErrorUp; 

        if( Error > 0 && numPixels) 
        {              
            MinorStart += MinorDir;    
            Error -= ErrorDown;       
            scan->UpdateWidth(width);           
            buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 
            width = 0; 
        }
    }

    scan->UpdateWidth(width); 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawYMajorClip(
    DpScanBuffer *scan
    )
{
    INT saveMajor2 = MajorEnd; 
    INT saveMinor2 = MinorEnd; 
    
    // Do the DDA if all the clipping left the line 
    // valid. 

    if(StepUpAliasedClip())
    {                   
        // The length given by the minor coord. Whichever length
        // comes to 0 first, minor or major, we stop. 
    
        INT minorDiff = (MinorEnd - MinorStart)*MinorDir; 

        ARGB *buffer;          
        INT numPixels = MajorEnd - MajorStart; 

        while((minorDiff >= 0) && (numPixels >= 0)) 
        {
            buffer = scan->NextBuffer(MinorStart, MajorStart, 1);          
    
            *buffer = Color;
            MajorStart++; 
            Error += ErrorUp; 
        
            if( Error > 0 ) 
            {
                MinorStart += MinorDir; 
                Error -= ErrorDown; 
                minorDiff--; 
            }
    
            numPixels--; 
        } 

    }

    // Restore the saved end values

    MajorEnd = saveMajor2; 
    MinorEnd = saveMinor2; 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawXMajorClip(
    DpScanBuffer *scan
    )
{
    INT saveMajor2 = MajorEnd; 
    INT saveMinor2 = MinorEnd; 
    const INT maxWidth = MaximumWidth;

    if(StepUpAliasedClip())
    {
        INT minorDiff = (MinorEnd - MinorStart)*MinorDir; 

        INT numPixels = MajorEnd - MajorStart + 1; 
        ARGB *buffer;  
    
        INT width = 0;
    
        // Run the DDA for the case where there is no 
        // complex clipping region, which is a lot easier. 
    
        buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 

        while(numPixels--) 
        {
            MajorStart++;
            width++; 
            *buffer++ = Color; 
            Error += ErrorUp; 
    
            if( Error > 0 && numPixels) 
            {   
                MinorStart += MinorDir;
                Error -= ErrorDown;                 
                minorDiff--; 
                scan->UpdateWidth(width); 
                
                // If all of the scanlines in the minor direction have
                // been filled, then quit now.
                if(minorDiff < 0)
                {
                    break;
                }

                buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 
                width = 0; 

            }
        }
        scan->UpdateWidth(width); 
    }

    MajorEnd = saveMajor2; 
    MinorEnd = saveMinor2; 
}

/**************************************************************************\
*
* Function Description:
*
* Steps the DDA until the start point is at the edge of the 
* clipping rectangle. Also, correct the end values so that 
* they stop at the end of the rectangle. The caller must save 
* these values to restore at the end of the loop. 
*
* Arguments:
*
* Return Value:
*
* 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL
OnePixelLineDDAAliased::StepUpAliasedClip()
{
    // Step up on the DDA untill the major coordinate 
    // is aligned with the rectangles edge

    while(MajorStart < MajorIn) 
    {
        MajorStart++; 
        Error += ErrorUp;     
        if( Error > 0 ) 
        {
            MinorStart += MinorDir; 
            Error -= ErrorDown; 
        }                   
    }

    // If the minor coordinate is still out, step up untill 
    // this one is also aligned. In doing that we might pass
    // the on the major coordinate, in which case we are done
    // and there is no intersection. 

    INT minorDiff = (MinorIn - MinorStart)*MinorDir; 

    while(minorDiff > 0 && MajorStart <= MajorOut)
    {
        MajorStart++; 
        Error += ErrorUp;     
        if( Error > 0 ) 
        {
            MinorStart += MinorDir;
            minorDiff--;
            Error -= ErrorDown; 
        }                   
    }
        
    minorDiff = (MinorEnd - MinorOut)*MinorDir;
    
    if(minorDiff > 0)
    {
        if((MinorStart - MinorOut)*MinorDir > 0)
        {
            return FALSE; 
        }
        MinorEnd = MinorOut;    
    }
    
    if(MajorOut < MajorEnd) 
    {
        MajorEnd = MajorOut; 
    }
    
    // Return if the line is still valid. 

    return(MajorStart <= MajorEnd);
}


//--------------------------------------------------------------------
// Auxiliary functions 
//--------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Clips the line against a rectangle. It assumes that the line endpoints 
* are stored in the class in floating point format. This sets an 
* order in which this function can be called. It must be after the 
* SetupCommon function and before the specific setups for antialiasing 
* and aliasing. This is a pain, but it's better than requirering on of
* these to have to know about clipping. The clipping here is done by 
* using the Slope and InvSlope members of the class to advance the 
* endpoints to the rectangle edges. Thus the function also assumes that
* Slope and InvSlope have been calculated.
*
* Arguments:
*
*   [IN] clipRect - The rectangle to clip against

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL 
OnePixelLineDDAAliased::ClipRectangle(
    const GpRect* clipRect
    )
{

    INT clipBottom, clipTop, clipLeft, clipRight; 

    // Set the major and minor edges of the clipping
    // region, converting to fixed point 28.4. Note that
    // we don't convert to the pixel center, but to a 
    // that goes all the way up to the pixel edges. This 
    // makes a difference for antialiasing. We don't go all
    // the way to the edge since some rounding rules could 
    // endup lighting the next pixel outside of the clipping
    // area. That's why we add/subtract 7 instead of 8 for the
    // bottom and right, since these are exclusive. 
    // For the left and top, subtract 8 (1/2 pixel), since here
    // we are inclusive.
    
    INT majorMin = (clipRect->GetLeft() << FBITS) - FHALF;
    INT majorMax = ((clipRect->GetRight() - 1) << FBITS) + FHALFMASK; 
    INT minorMax = ((clipRect->GetBottom() - 1) << FBITS) + FHALFMASK; 
    INT minorMin = (clipRect->GetTop() << FBITS) - FHALF; 

    if(!IsXMajor)
    {
        INT tmp; 
        tmp      = majorMin; 
        majorMin = minorMin; 
        minorMin = tmp; 
        tmp      = majorMax; 
        majorMax = minorMax; 
        minorMax = tmp; 
    }

    // First clip in the major coordinate 

    BOOL minOut, maxOut; 

    minOut = MajorStart < majorMin; 
    maxOut = MajorEnd > majorMax; 

    if( minOut || maxOut )
    {
        if(MajorStart > majorMax || MajorEnd < majorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            MinorStart += GpFloor((majorMin - MajorStart)*Slope); 
            MajorStart = majorMin;
        }

        if(maxOut)
        {
            MinorEnd += GpFloor((majorMax - MajorEnd)*Slope); 
            MajorEnd = majorMax; 

            // If we clipped the last point, we don't need to be IsEndExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    // Now clip the minor coordinate 

    INT *pMajor1, *pMinor1, *pMajor2, *pMinor2; 

    if(MinorDir == 1)
    {
        pMajor1 = &MajorStart; 
        pMajor2 = &MajorEnd; 
        pMinor1 = &MinorStart; 
        pMinor2 = &MinorEnd; 
    }
    else
    {
        pMajor1 = &MajorEnd; 
        pMajor2 = &MajorStart; 
        pMinor1 = &MinorEnd; 
        pMinor2 = &MinorStart; 
    }

    minOut = *pMinor1 < minorMin; 
    maxOut = *pMinor2 > minorMax; 

    if(minOut || maxOut)
    {
        if(*pMinor1 > minorMax || *pMinor2 < minorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            *pMajor1 += GpFloor((minorMin - *pMinor1)*InvSlope); 
            *pMinor1 = minorMin;
        }

        if(maxOut)
        {
            *pMajor2 += GpFloor((minorMax - *pMinor2)*InvSlope); 
            *pMinor2 = minorMax;

            // If we clipped the last point, we don't need to be endExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    return(TRUE); 
}

/**************************************************************************\
*
* Function Description:
*
* Given the fractional parts of a coordinate in fixed point, this 
* function returns if the coordinate is inside the diamond at the 
* nearest integer position. 
*
* Arguments:
*
*   [IN] xFrac - Fractional part of the x coordinate 
*   [IN] yFrac - Fractional part of the y coordinate 
*   [IN] SlopeIsOne    - TRUE if the line has Slope +/- 1 
*   [IN] SlopeIsPosOne - TRUE if the line has Slope +1 

* Return Value:
*
* TRUE if the coordinate is inside the diamond 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL 
OnePixelLineDDAAliased::IsInDiamond( 
    INT xFrac, 
    INT yFrac, 
    BOOL SlopeIsOne, 
    BOOL SlopeIsPosOne 
    )
{
    // Get the fractional parts of the fix points, and the
    // sum of their absolute values. 

    INT fracSum = 0; 

    if(xFrac > 0) 
    {
        fracSum += xFrac; 
    }
    else
    {
        fracSum -= xFrac; 
    }

    if(yFrac > 0) 
    {
        fracSum += yFrac; 
    }
    else
    {
        fracSum -= yFrac; 
    }

    // Return true if the point is inside the diamond.

    if(fracSum < FHALF) 
    {
        return TRUE; 
    }

    // Check the cases where we are at the two vertices of the
    // diamond which are considered inside. 

    if(yFrac == 0) 
    {
        if((SlopeIsPosOne && xFrac == -FHALF) || 
           (!SlopeIsPosOne && xFrac == FHALF))
        {
            return TRUE; 
        }
    }

    if((xFrac == 0) && (yFrac == FHALF))
    {
        return TRUE; 
    }

    // Check for the cases where we are at the edges of the 
    // diamond with a Slope of one. 

    if (SlopeIsOne && (fracSum == FHALF))
    {
        if (SlopeIsPosOne && (xFrac < 0) && (yFrac > 0))
        {
            return TRUE;
        }

        if (!SlopeIsPosOne && (xFrac > 0) && (yFrac > 0))
        {
            return TRUE;
        }    
    }
    
    return FALSE;
}

typedef GpStatus DrawSolidLineFunc(
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    );
        
DrawSolidLineFunc DrawSolidLineOnePixelAliased;
DrawSolidLineFunc DrawSolidLineOnePixelAntiAliased;

/**************************************************************************\
*
* Function Description:
*
*   Called back by the path enumeration function, this draws a list
*   of lines.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/2000 andrewgo
*
\**************************************************************************/

struct EpSolidStrokeOnePixelContext
{
    DrawSolidLineFunc *DrawLineFunction;
    DpScanBuffer *Scan;
    GpRect *ClipBoundsPointer;
    DpClipRegion *ClipRegion;
    ARGB Argb;
    BOOL DrawLast;   // TRUE if draw last pixel in subpaths
};

BOOL
DrawSolidStrokeOnePixel(
    VOID *voidContext,
    POINT *point,     // 28.4 format, an arary of size 'count'
    INT vertexCount,
    PathEnumerateTermination lastSubpath
    )
{
    EpSolidStrokeOnePixelContext *context 
        = static_cast<EpSolidStrokeOnePixelContext*>(voidContext);

    ASSERT(vertexCount >= 2);

    for (INT i = vertexCount - 1; i != 0; i--, point++)
    {
        PointF pointOne(TOREAL((point)->x) / 16, TOREAL((point)->y) / 16);
        PointF pointTwo(TOREAL((point + 1)->x) / 16, TOREAL((point + 1)->y) / 16) ;

        // Note that we're always drawing the last pixel, which is
        // fine when we're 100% opaque, because we'll be re-drawing
        // the same pixel for consecutive joined lines (it's a little
        // more work, but the cost is small and is actually comparable 
        // to the overhead of deciding whether to do the last pixel
        // or not).
        //
        // This is the wrong thing to do for non-opaque lines, because
        // of the redraw issue.  But we shouldn't be coming through
        // here for the non-opaque case anyway, since any self-overlaps
        // of the lines will cause pixel overdraw, which produces the
        // 'wrong' result (or at least different from the 'right' result
        // as defined by the widener code).

        (context->DrawLineFunction)(
            context->Scan,
            context->ClipBoundsPointer,
            context->ClipRegion,
            &pointOne,
            &pointTwo,
            context->Argb,
            (lastSubpath==PathEnumerateCloseSubpath) || context->DrawLast
        );
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a one-pixel wide path with a solid color.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] pen        - the pen to use
*   [IN] drawLast   - TRUE if last pixels in subpaths are to be drawn.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DpDriver::SolidStrokePathOnePixel(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen,
    BOOL drawLast
    )
{
    GpBrush *brush = GpBrush::GetBrush(pen->Brush);

    ASSERT(pen->Brush->Type == BrushTypeSolidColor);
    ASSERT(pen->Brush->SolidColor.IsOpaque());

    // Antialiased lines are usually drawn using aarasterizer.cpp 
    // rather than aaline.cpp.  If aaline.cpp is to be used, define
    // AAONEPIXELLINE_SUPPORT
    
#ifdef AAONEPIXELLINE_SUPPORT
    DrawSolidLineFunc *drawLineFunc = context->AntiAliasMode 
        ? DrawSolidLineOnePixelAntiAliased 
        : DrawSolidLineOnePixelAliased;
#else
    ASSERT(context->AntiAliasMode == 0);
    DrawSolidLineFunc *drawLineFunc = DrawSolidLineOnePixelAliased;
#endif
    
    // Determine if alpha blending is necessary 

    BOOL noTransparentPixels;
    
    noTransparentPixels = (!context->AntiAliasMode) &&
                          (brush->IsOpaque());

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    GpSolidFill * solidBrush = static_cast<GpSolidFill *>(brush);
    
    ARGB argb = solidBrush->GetColor().GetValue(); 

    DpClipRegion *clipRegion = &context->VisibleClip; 

    GpRect clipBounds; 
    GpRect *clipBoundsPointer; 
    RECT clipRect;
    RECT *clipRectPointer;
    DpRegion::Visibility visibility;

    visibility = clipRegion->GetRectVisibility(
                drawBounds->X,
                drawBounds->Y,
                drawBounds->X + drawBounds->Width,
                drawBounds->Y + drawBounds->Height);

    if (visibility == DpRegion::TotallyVisible)
    {
        clipBoundsPointer = NULL; 
        clipRectPointer = NULL;
        clipRegion = NULL; 
    }
    else
    {
        // !!![andrewgo] Is clipBoundsPointer actually needed?

        clipRegion->GetBounds(&clipBounds);
        clipBoundsPointer = &clipBounds;

        // Scale the clip bounds rectangle by 16 to account for our scaling 
        // to 28.4 coordinates:

        clipRect.left = clipBounds.GetLeft() << 4;
        clipRect.top = clipBounds.GetTop() << 4;
        clipRect.right = clipBounds.GetRight() << 4;
        clipRect.bottom = clipBounds.GetBottom() << 4;
        clipRectPointer = &clipRect;

        // !!![andrewgo] Why is this needed?  Why wasn't this covered in 
        //               GetRectVisibility?

        if (clipRegion->IsSimple())
        {
            clipRegion = NULL;
        }
    }

    EpSolidStrokeOnePixelContext drawContext;

    drawContext.DrawLineFunction = drawLineFunc;
    drawContext.Scan = &scan;
    drawContext.ClipBoundsPointer = clipBoundsPointer;
    drawContext.ClipRegion = clipRegion;
    drawContext.Argb = argb;
    drawContext.DrawLast = drawLast;

    // Scale the transform by 16 to get 28.4 units:

    GpMatrix transform = context->WorldToDevice;
    transform.AppendScale(TOREAL(16), TOREAL(16));

    FixedPointPathEnumerate(path, 
                            &transform,
                            clipRectPointer,
                            PathEnumerateTypeStroke,
                            DrawSolidStrokeOnePixel,
                            &drawContext);

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
* Draws a one-pixe-wide line with a solid color. Calls on the 
* OnePixelLineDDAAliased class to do the actual drawing. 
*
* Arguments:
*
*   [IN] scan         - The DpScanBuffer to access the drawing surface 
*   [IN] clipRect     - A single rectangle that includes all the clipping 
*                       region. If there is no clipping, should be set to NULL.                          
*   [IN] clipRegionIn - A complex clipping region. If the clipping region is 
*                       simple, this should be NULL, and clipRect will be used. 
*   [IN] point1       - line end point 
*   [IN] point2       - line end point 
*   [IN] inColor      - the solid color
*   [IN] drawLast     - FALSE if the line is to be end-exclusive.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DrawSolidLineOnePixelAliased( 
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    )
{
    // Take out the const for now because the Enumeration method
    // is not const. 

    DpClipRegion *clipRegion = const_cast<DpClipRegion*>(clipRegionIn); 

    // Setup the common part of the DDA

    OnePixelLineDDAAliased dda; 

    INT width = scan->GetSurface()->Width;
    
    if(clipRect)
    {
        // We have a bug in the driver architecture which allows the 
        // surface associated with the scan to be smaller than the actual
        // surface in the screen case (EpScanGdiDci).
        // Therefore we need to look at the visible clip bounds also.
        // If it turns out that the visible clip is bigger, our maximum
        // width needs to be expanded.
        // 350997 Aliased line is not clipped to surface

        width = max(width, clipRect->Width);
    }

    if(!dda.SetupCommon(point1, point2, drawLast, width))
    {
        return Ok;
    }

    dda.Color = GpColor::ConvertToPremultiplied(inColor); 
    
    // Now handle the different clipping cases 

    if(!clipRect)
    {
        // This is easy, there is no clipping so just draw.

        if(!dda.SetupAliased())
        {
            return Ok; 
        }

        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

        return Ok;
    }
    else
    {
        // The inverse of the Slope might be needed. 
       
        // Can't use the inverse slope if the slope is zero.

        if(dda.Slope==0.0F) 
        {
            dda.InvSlope=0.0F;
        } 
        else 
        {
            dda.InvSlope =  (1.0F/dda.Slope); 
        }

        // First of all clip against the bounding rectangle 

        if(!dda.ClipRectangle(clipRect))
        {
            return Ok;            
        }

        // Do the specific setup 

        if(!dda.SetupAliased())
        {
            return Ok; 
        }

        // For each clip rectangle we store it's limits in 
        // an array of four elements. We then index this array using 
        // the variables below which depend on the slope and 
        // direction of the line in the following way: majorIn is edge crossed 
        // to go into the rect in the major direction, majorOut is the edge 
        // crossed to go out of the rect in the major direction, and so on.
        // The same for xIn, xOut, yIn, yOut. 

        INT majorIn, majorOut, minorIn, minorOut; 
        INT xIn, xOut, yIn, yOut;
        
        // Direction to enumerate the rectangles which depends on the 
        // line 

        DpClipRegion::Direction enumDirection; 
        
        INT clipBounds[4]; 
               
        // We store all our info in terms of major and minor 
        // direction, but to deal with cliping rectangles we
        // need to know them in terms of x and y, so calculate
        // xDir, yDir, the advance slope. 

        REAL xAdvanceRate; 
        INT  xDir, yDir; 
        INT  yEndLine;        
    
        // If the line crosses a span completely, (xStart, yStart)
        // is the position where it enters the span and (xEnd, yEnd)
        // is the position that it leaves. If it starts inside the 
        // span, then (xStart, yStart) is the start point

        REAL yStart, xStart, xEnd, yEnd; 

        if(dda.IsXMajor)
        {
            // Calculate the in-out indices

            majorIn  = xIn  = 0; 
            majorOut = xOut = 2; 
            if(dda.MinorDir == 1)
            {
                minorIn  = 1;
                minorOut = 3;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn  = 3;
                minorOut = 1;
                enumDirection = DpClipRegion::BottomLeftToTopRight; 
            }
            
            yIn = minorIn;
            yOut = minorOut;

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MinorStart; 
            xStart = (REAL)dda.MajorStart;

            // Always advance in positive direction when X is major
            xAdvanceRate = REALABS(dda.InvSlope); 
            xDir = 1; 
            yDir = dda.MinorDir; 
            yEndLine =  dda.MinorEnd; 
        }
        else
        {
            majorIn = yIn =  1; 
            majorOut = yOut = 3; 
            if(dda.MinorDir == 1)
            {
                minorIn = 0;
                minorOut = 2;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn = 2;
                minorOut = 0;
                enumDirection = DpClipRegion::TopRightToBottomLeft;
            }
            
            xIn = minorIn; 
            xOut = minorOut; 

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MajorStart;
            xStart = (REAL)dda.MinorStart; 

            xAdvanceRate = dda.Slope; 
            xDir = dda.MinorDir; 
            yDir = 1;
            yEndLine = dda.MajorEnd; 
        }

        // Update the drawing function to the correct 
        // slipping version

        dda.DrawFuncIndex += FUNC_CLIP_OFFSET; 
    
        if(!clipRegion)
        {
            // In this case there is only a single rect, so just
            // draw clipped to that 

            // Store the rectangle in an array so we can atribute the 
            // right values to the MajorIn, majorOut, etc... variables. 
            // Remember that bottom and right are exclusive. 

            clipBounds[0] = clipRect->GetLeft(); 
            clipBounds[1] = clipRect->GetTop(); 
            clipBounds[2] = clipRect->GetRight() - 1; 
            clipBounds[3] = clipRect->GetBottom() - 1; 

            dda.MajorIn  = clipBounds[majorIn]; 
            dda.MajorOut = clipBounds[majorOut]; 
            dda.MinorIn  = clipBounds[minorIn]; 
            dda.MinorOut = clipBounds[minorOut]; 

            (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

            return Ok;
        }
        else
        {
            BOOL agregating = FALSE; 
            INT  agregateBounds[4];

            // We have a complex clipping region. So what we'll do 
            // is clip against each individual rectangle in the 
            // cliping region. 

            clipRegion->StartEnumeration(GpFloor(yStart), enumDirection);            

            GpRect rect; 

            // Get the first rectangle. 

            INT numRects = 1;        

            clipRegion->Enumerate(&rect, numRects); 
            
            clipBounds[0] = rect.GetLeft(); 
            clipBounds[1] = rect.GetTop(); 
            clipBounds[2] = rect.GetRight() - 1; 
            clipBounds[3] = rect.GetBottom() - 1; 
            
            // Store the y position into the span 

            INT currSpanYMin = clipBounds[yIn]; 

            // We need some special treatment for the case where the 
            // line is horizontal, since is this case it's not going 
            // to cross different spans. And it it's not in the current
            // span, it's totally clipped out. 

            if(dda.IsXMajor && dda.ErrorUp == 0)
            {
                if(yStart >= clipBounds[1] && yStart <= clipBounds[3])
                {
                    xStart  = (REAL)dda.MajorStart;
                    xEnd    = (REAL)dda.MajorEnd; 
                }
                else
                {
                    return Ok; 
                }
            }
            else
            {
                if(yStart < clipBounds[1] || yStart > clipBounds[3])
                {
                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate; 
                    yStart  = (REAL)clipBounds[yIn];
                }

                // Account for initial DDA error when calculating xEnd so that clipping
                // will track what the DDA is actually drawing.
                xEnd = xStart + ((clipBounds[yOut] - yStart)*yDir - ((REAL)dda.Error / (REAL)dda.ErrorDown))*xAdvanceRate; 
            }
            
            yEnd = (REAL)clipBounds[yOut]; 

            while(1)
            {
                // Get to the first rectangle on the span that crosses the
                // line 
                
                while((xStart - clipBounds[xOut])*xDir > 0)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1)
                    {
                        goto draw_agregated;
                    }
                    if(clipBounds[yIn] != currSpanYMin)
                    {
                        // There may be pending aggregated drawing operations.  If so
                        // perform them now before doing the next span.
                        if (agregating)
                            break;
                        else
                            goto process_next_span; 
                    }
                }

                // Draw on all the rectangles that intersect the 
                // line 

                if((xStart - clipBounds[xIn])*xDir > 0 && 
                   (clipBounds[xOut] - xEnd)*xDir > 0)
                {
                    if(agregating) 
                    {
                        if((clipBounds[xIn] - agregateBounds[xIn])*xDir < 0)
                        {
                            agregateBounds[xIn] = clipBounds[xIn];        
                        }
                        if((clipBounds[xOut] - agregateBounds[xOut])*xDir > 0)
                        {
                            agregateBounds[xOut] = clipBounds[xOut];        
                        }
                        agregateBounds[yOut] = clipBounds[yOut];
                    }
                    else
                    {
                        agregateBounds[0] = clipBounds[0];
                        agregateBounds[1] = clipBounds[1];
                        agregateBounds[2] = clipBounds[2];
                        agregateBounds[3] = clipBounds[3];

                        agregating = TRUE; 
                    }
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        agregating = FALSE; 
                    }
                    while((xEnd - clipBounds[xIn])*xDir > 0)
                    {
                        dda.MajorIn  = clipBounds[majorIn]; 
                        dda.MajorOut = clipBounds[majorOut]; 
                        dda.MinorIn  = clipBounds[minorIn]; 
                        dda.MinorOut = clipBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        numRects = 1; 
                        
                        clipRegion->Enumerate(&rect, numRects); 
                        
                        clipBounds[0] = rect.GetLeft(); 
                        clipBounds[1] = rect.GetTop(); 
                        clipBounds[2] = rect.GetRight() - 1; 
                        clipBounds[3] = rect.GetBottom() - 1; 
    
                        if(numRects != 1) 
                        {
                            goto draw_agregated;
                        }
                        if(clipBounds[yIn] != currSpanYMin)
                        {
                            goto process_next_span; 
                        }
                    }
                }

                // Get to the next span

                while(clipBounds[yIn] == currSpanYMin)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                }

process_next_span:

                if((clipBounds[yIn] - yEndLine)*yDir > 0)
                {
                    // We are done. 
                    goto draw_agregated; 
                }

                if((clipBounds[yIn] - yEnd)*yDir == 1)
                {
                    xStart  = xEnd;
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
                        
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        agregating = FALSE; 
                    }

                    xStart  = xStart + (clipBounds[yIn] - yStart)*yDir*xAdvanceRate;
                }

                yStart  = (REAL)clipBounds[yIn];                 
                // Add 1 to make the amount added to xStart proportional to height of
                // the clipping rectangle, since clipBounds are inset by 1.
                xEnd    = xStart + ((clipBounds[yOut] - yStart)*yDir + 1)*xAdvanceRate; 
                yEnd    = (REAL)clipBounds[yOut];
                currSpanYMin = GpFloor(yStart); 
            }

draw_agregated: 

            if(agregating)
            {
                dda.MajorIn  = agregateBounds[majorIn]; 
                dda.MajorOut = agregateBounds[majorOut]; 
                dda.MinorIn  = agregateBounds[minorIn]; 
                dda.MinorOut = agregateBounds[minorOut]; 
                
                (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan);                 
            }

        }
    }

    return Ok; 
}

#pragma optimize("a", off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\nearestneighbor.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   nearestneighbor.hpp
*
* Abstract:
*
*   Nearest Neighbor Resampling code
*
* Created:
*
*   3/3/2000 asecchia
\**************************************************************************/

#pragma once

class DpOutputNearestNeighborSpan : public DpOutputSpan
{
public:
    DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *  Scan;
    WrapMode NWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;
    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:
    DpOutputNearestNeighborSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
    );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
    );

    virtual GpStatus OutputSpanIncremental(
        INT      y,
        INT      xMin,
        INT      xMax,
        FIX16    x0,
        FIX16    y0,
        FIX16    dx,
        FIX16    dy
    );

    virtual BOOL IsValid() const { return (dBitmap!=NULL); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\line.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Line.hpp
*
* Abstract:
*
* Definition of the classes used for drawing one-pixel-wide lines. 
*
* History:
*
*   3/31/1999 AMatos
*       Created it
*   9/17/1999 AGodfrey
*       Separated aliased from antialiased
*
\**************************************************************************/

#ifndef LINE_HPP
#define LINE_HPP

// If line coordinate rounding is NOT to be dependent on line direction,
// then define the following (see Office 10 bug 281816).  The original
// behavior of the DDA is to have rounding dependent on line direction,
// so don't define the following if you want that behavior.
#define LINEADJUST281816

// This class implements drawing of solid one-pixel wide lines. 
// The lines can be aliased or anti-aliased and supports clipping. 
// The class keeps all the DDA state as member variables. Note that 
// currently it must be declared on the stack because of the Real 
// member (!!!Take this out) 

class OnePixelLineDDAAliased
{

public:

    // General members, used by aliased and anti-aliased 
    // drawing. 

    BOOL IsXMajor;                  
    BOOL Flipped;                  // Set when the end-points are switched
    INT  DMajor, DMinor;           // Deltas
    INT  MinorDir;                 // 1 if minor is increasing and -1 if not. 
    INT  MajorStart, MajorEnd;     // Major limits. 
    INT  MinorStart, MinorEnd;     // Minor limits. 
    REAL Slope;                    // Slope and its inverse. 
    REAL InvSlope;
    ARGB Color;                    // The solid color in ARGB format. 
    INT  ErrorUp;                  // Increase in the error
    INT  ErrorDown;                // Decrease when steping
    BOOL IsEndExclusive;           

    // Aliased specific 
    
    INT Error;                     // The current error for aliased lines. 

    // Used for clipping 

    INT MajorIn;                    // The limits of the clipping rectangle. 
    INT MajorOut;
    INT MinorIn;
    INT MinorOut; 

    // Index of the drawing function to be used. 

    INT DrawFuncIndex; 
    
    // Maximum width of the clipping rectangle in pixels.
    
    INT MaximumWidth;

public: 

    // Public Functions 

    BOOL     SetupAliased();
    BOOL     SetupCommon( GpPointF *point1, GpPointF *point2, BOOL drawLast, INT width );
    VOID     DrawXMajor(DpScanBuffer *scan); 
    VOID     DrawYMajor(DpScanBuffer *scan); 
    VOID     DrawXMajorClip(DpScanBuffer *scan); 
    VOID     DrawYMajorClip(DpScanBuffer *scan); 
    BOOL     IsInDiamond( INT xFrac, INT yFrac, BOOL slopeIsOne, 
                BOOL slopeIsPosOne );
    BOOL     ClipRectangle(const GpRect* clipRect);
    BOOL     StepUpAliasedClip();
};

    // Antialiased lines are usually drawn using aarasterizer.cpp 
    // rather than aaline.cpp.  If aaline.cpp is to be used, define
    // AAONEPIXELLINE_SUPPORT

#ifdef AAONEPIXELLINE_SUPPORT

class OnePixelLineDDAAntiAliased
{

public:

    // General members, used by aliased and anti-aliased 
    // drawing. 

    BOOL IsXMajor;                  
    BOOL Flipped;                  // Set when the end-points are switched
    INT  DMajor, DMinor;           // Deltas
    INT  MinorDir;                 // 1 if minor is increasing and -1 if not. 
    INT  MajorStart, MajorEnd;     // Major limits. 
    INT  MinorStart, MinorEnd;     // Minor limits. 
    REAL Slope;                    // Slope and its inverse. 
    REAL InvSlope;
    ARGB Color;                    // The solid color in ARGB format. 
    INT  ErrorUp;                  // Increase in the error
    INT  ErrorDown;                // Decrease when steping
    BOOL IsEndExclusive;           

    // AntiAliased specific 

    REAL InvDelta;                  // The inverse of the major delta, needed 
                                    // to calculate the 4 end points of the 
                                    // aa line. 
    REAL LineLength; 

    // An antialised line is drawed as 2 or three common lines. The dda state
    // must be kept for each. All variables that end with First refer to the
    // first one of this line, and all that end with Last refers to the last. 

    INT  ErrorFirst;                // The DDA error.                
    INT  ErrorLast; 
    INT  FracStart;                 // The fraction of the start and end 
    INT  FracEnd;                   // points that are covered due to the cap.  
    INT  MinorFirst;                // The minor position of each DDA. 
    INT  MinorLast; 
    INT  MajorFirst;                // The major position of each DDA
    INT  MajorLast;
    INT  SwitchFirstLast;           // Specifies if the first and last DDAs 
                                    // should be switched, which is simpler in 
                                    // some cases for the x-major line. 
    INT  AlphaFirst;                // The currently calculated coverage for
    INT  AlphaLast;                 // each DDA. 
    INT  AlphaMid; 
    INT  AlphaBiasFirst;            // Bias for calculating the coverage. 
    INT  AlphaBiasLast; 

    // Used for clipping 

    INT MajorIn;                    // The limits of the clipping rectangle. 
    INT MajorOut;
    INT MinorIn;
    INT MinorOut; 

    // Index of the drawing function to be used. 

    INT DrawFuncIndex; 

public: 

    // Public Functions 

    BOOL     SetupAntiAliased();
    BOOL     SetupCommon( GpPointF *point1, GpPointF *point2, BOOL drawLast );
    VOID     DrawXMajor(DpScanBuffer *scan); 
    VOID     DrawYMajor(DpScanBuffer *scan); 
    VOID     DrawXMajorClip(DpScanBuffer *scan); 
    VOID     DrawYMajorClip(DpScanBuffer *scan); 
    BOOL     ClipRectangle(const GpRect* clipRect);
};

#endif  // AAONEPIXELLINE_SUPPORT
                                             
#endif  // LINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\output.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Output.hpp
*
* Abstract:
*
*   Classes to output a span for a particular brush type
*
* Created:
*
*   2/24/1999 DCurtis
*
\**************************************************************************/

#ifndef _OUTPUT_HPP
#define _OUTPUT_HPP

void ApplyWrapMode(INT WrapMode, INT &x, INT &y, INT w, INT h);

//--------------------------------------------------------------------------
// Solid color output
//--------------------------------------------------------------------------

class DpOutputSolidColorSpan : public DpOutputSpan
{
public:
    ARGB            Argb;
    DpScanBuffer *  Scan;

public:
    DpOutputSolidColorSpan(ARGB argb, DpScanBuffer * scan)
    {
        Argb = argb;
        Scan = scan;
    }

    GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual BOOL IsValid() const { return TRUE; }
    virtual DpScanBuffer* GetScanBuffer(){ return Scan; }
};

//--------------------------------------------------------------------------
// Gradient output base class
//--------------------------------------------------------------------------

class DpOutputGradientSpan : public DpOutputSpan
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagOutputGradientSpan : ObjectTagInvalid;
    }

public:
    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagOutputGradientSpan) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid OutputGradientSpan");
        }
    #endif

        return (Tag == ObjectTagOutputGradientSpan);
    }

public:
    DpScanBuffer *  Scan;
    const GpBrush* Brush;
    INT BrushType;
    INT WrapMode;
    INT CompositingMode;
    GpRectF BrushRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;
    REAL A[4], R[4], G[4], B[4];

public:

    DpOutputGradientSpan() { SetValid (TRUE); }

    DpOutputGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    ~DpOutputGradientSpan()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

protected:

    VOID InitDefaultColorArrays(const GpElementaryBrush* brush)
    {
        const GpGradientBrush *gradBrush
            = static_cast<const GpGradientBrush*> (brush);

        if(gradBrush->UsesDefaultColorArray())
        {
            GpColor colors[4];  // Default array is up to
                                // 4 colors.

            gradBrush->GetColors(colors);
            INT num = gradBrush->GetNumberOfColors();

            for(INT i = 0; i < num; i++)
            {
                ARGB argb = colors[i].GetPremultipliedValue();
                A[i] = (REAL)GpColor::GetAlphaARGB(argb);
                R[i] = (REAL)GpColor::GetRedARGB(argb);
                G[i] = (REAL)GpColor::GetGreenARGB(argb);
                B[i] = (REAL)GpColor::GetBlueARGB(argb);
            }
        }
    }

};

//--------------------------------------------------------------------------
// Handle one-dimension gradients (we call 'em 'textures' for reasons that
// should be obvious)
//--------------------------------------------------------------------------

class DpOutputOneDGradientSpan : public DpOutputGradientSpan
{
protected:
    INT      OneDDataMultiplier;
    INT      OneDDataCount;
    ARGB*    OneDData;
    BOOL     IsHorizontal;
    BOOL     IsVertical;

public:

    DpOutputOneDGradientSpan()
    {
        Initialize();
    }

    DpOutputOneDGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context,
        BOOL isHorizontal = TRUE,
        BOOL isVertical = FALSE
        );

    ~DpOutputOneDGradientSpan();

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );

protected:
    VOID Initialize()
    {
        OneDDataMultiplier = 1;
        OneDDataCount = 0;
        OneDData = NULL;
        IsHorizontal = FALSE;
        IsVertical = FALSE;
        SetValid(FALSE);
    }

    GpStatus AllocateOneDData(BOOL isHorizontal,BOOL isVertical);
    VOID SetupRectGradientOneDData();
    VOID SetupRadialGradientOneDData();

};

//--------------------------------------------------------------------------
// Linear gradients
//--------------------------------------------------------------------------

// The AGRB64TEXEL structure is sort of funky in order to optimize the
// inner loop of our C-code linear gradient routine.

struct AGRB64TEXEL      // Note that it's 'AGRB', not 'ARGB'
{
    UINT32 A00rr00bb;   // Texel's R and B components
    UINT32 A00aa00gg;   // Texel's A and G components
};

// # of pixels in our 1-D texture:

//#define ONEDMAXIMUMTEXELS 32
#define ONEDMAXIMUMTEXELS 1024


// # of fractional bits that we iterate across the texture with:

#define ONEDNUMFRACTIONALBITS 16

// Get the integer portion of our fixed point texture coordinate, using
// a floor function:

#define ONEDGETINTEGERBITS(x) ((x) >> ONEDNUMFRACTIONALBITS)

// Get the 8-bit fractional portion of our fixed point texture coordinate.
// We could round, but I can't be bothered:

#define ONEDGETFRACTIONAL8BITS(x) ((x) >> ((ONEDNUMFRACTIONALBITS - 8)) & 0xff)

class DpOutputLinearGradientSpan : public DpOutputGradientSpan
{
protected:

    GpMatrix DeviceToNormalized;    // Transforms from the device-space brush
                                    //   parallogram to fixed-point-scaled
                                    //   brush texture coordinates
    INT32 M11;                      // Fixed point representation of
                                    //   M11 element of DeviceToNormalized
    INT32 M21;                      // Fixed point representation of
                                    //   M21 element of DeviceToNormalized
    INT32 Dx;                       // Fixed point representation of
                                    //   Dx element of DeviceToNormalized
    INT32 XIncrement;               // Fixed point increment (in format
                                    //   defined by ONEDNUMFRACTIONALBITS)
                                    //   representing texture x-distance
                                    //   traveled for every x pixel increment
                                    //   in device space
    UINT32 IntervalMask;            // One less than the number of texels in
                                    //   our texture
    UINT32 NumberOfIntervalBits;    // log2 of the number of texels

    union
    {
        ULONGLONG StartTexelArgb[ONEDMAXIMUMTEXELS];
                                    // Array of colors (at 16-bits per channel,
                                    //   with zeroes in the significant bytes)
                                    //   representing the start color of the
                                    //   linear approximation at interval 'x'
                                    //   (in A-R-G-B format)
        AGRB64TEXEL StartTexelAgrb[ONEDMAXIMUMTEXELS];
                                    // Similarly, but for the non-MMX renderer
                                    //   (in A-G-R-B format)
    };
    union
    {
        ULONGLONG EndTexelArgb[ONEDMAXIMUMTEXELS];
                                    // End color for the interval (in A-R-G-B
                                    //   format)
        AGRB64TEXEL EndTexelAgrb[ONEDMAXIMUMTEXELS];
                                    // Similarly, but for the non-MMX renderer
                                    //   (in A-G-R-B format)
    };

public:

    DpOutputLinearGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context
        );

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Gradient special case - MMX
//--------------------------------------------------------------------------

class DpOutputLinearGradientSpan_MMX : public DpOutputLinearGradientSpan
{
public:

    DpOutputLinearGradientSpan_MMX(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context
        );

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Path gradients
//--------------------------------------------------------------------------

class DpOutputOneDPathGradientSpan : public DpOutputOneDGradientSpan
{
public:

    DpOutputOneDPathGradientSpan()
    {
        BLTransforms = NULL;
        Count = 0;
    }

    ~DpOutputOneDPathGradientSpan()
    {
        if(BLTransforms)
            delete[] BLTransforms;
    }

    DpOutputOneDPathGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context,
        BOOL isHorizontal = TRUE,
        BOOL isVertical = FALSE
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

protected:
    VOID SetupPathGradientOneDData(BOOL gammaCorrect);

protected:
    GpBilinearTransform* BLTransforms;
    INT Count;
};

class DpTriangleData
{
friend class DpOutputTriangleGradientSpan;
friend class DpOutputPathGradientSpan;

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagTriangleData : ObjectTagInvalid;
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagTriangleData) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid TriangleData");
        }
    #endif

        return (Tag == ObjectTagTriangleData);
    }

public:

    DpTriangleData();
    ~DpTriangleData()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    VOID SetTriangle(
        GpPointF& pt0, 
        GpPointF& pt1, 
        GpPointF& pt2,
        GpColor& color0, 
        GpColor& color1, 
        GpColor& color2,
        BOOL isPolygonMode = FALSE,
        BOOL isGammaCorrected = FALSE
    );
    GpStatus OutputSpan(ARGB* buffer, INT compositingMode,
                INT y, INT &xMin, INT &xMax);

private:
    BOOL GetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x, GpPointF* s);
    BOOL SetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x);

private:

    BOOL    IsPolygonMode;
    BOOL    GammaCorrect;
    INT     Index[3];
    REAL    X[3];
    REAL    Y[3];
    
    GpFColor128 Color[3];
    
    REAL    Falloff0;
    REAL    Falloff1;
    REAL    Falloff2;
    INT     BlendCount0;
    INT     BlendCount1;
    INT     BlendCount2;
    REAL*   BlendFactors0;
    REAL*   BlendFactors1;
    REAL*   BlendFactors2;
    REAL*   BlendPositions0;
    REAL*   BlendPositions1;
    REAL*   BlendPositions2;
    ARGB*   PresetColors;
    BOOL    UsesPresetColors;

    REAL    Xmin, Xmax;
    REAL    M[3];      // dx/dy
    REAL    DeltaY[3]; // Inverse of dy.

    PointF  STGradient[2];  // Cached starting and ending fractional values of
                            // the color gradients for the current XSpan

    REAL    XSpan[2];       // Cached X range covered by this triangle for
                            // the current value of Y being output
};

//--------------------------------------------------------------------------
// Triangle Gradients
//--------------------------------------------------------------------------

class DpOutputTriangleGradientSpan : public DpOutputGradientSpan
{
public:

    DpOutputTriangleGradientSpan() {}

    DpOutputTriangleGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

private:
    DpTriangleData Triangle;

};

//--------------------------------------------------------------------------
// Path Gradients
//--------------------------------------------------------------------------

class DpOutputPathGradientSpan : public DpOutputGradientSpan
{
public:
    INT         Count;
    DpTriangleData** Triangles;

public:

    DpOutputPathGradientSpan()
    {
        Count = 0;
        Triangles = NULL;
        SetValid(FALSE);
    }

    DpOutputPathGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual ~DpOutputPathGradientSpan();
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

protected:

    VOID FreeData();
};

//--------------------------------------------------------------------------
// Textures
//--------------------------------------------------------------------------

class DpOutputBilinearSpan : public DpOutputSpan
{
protected:

    const GpBitmap *Bitmap;
    const DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *Scan;
    WrapMode BilinearWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;

    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:

    DpOutputBilinearSpan(
        const GpTexture *textureBrush,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context
        );

    DpOutputBilinearSpan(
        const DpBitmap *bitmap,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        );

    DpOutputBilinearSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
        );

    virtual ~DpOutputBilinearSpan();

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );

    virtual BOOL IsValid() const
    {
        return ((dBitmap != NULL) || (Bitmap != NULL));
    }

    DpScanBuffer* GetScanBuffer()
    {
        return Scan;
    }
};

//--------------------------------------------------------------------------
// Textures - MMX
//
// The MMX code uses the same setup as the non-MMX, hence the reason
// we're derived from it.
//--------------------------------------------------------------------------

class DpOutputBilinearSpan_MMX : public DpOutputBilinearSpan
{
protected:

    BOOL TranslateMatrixValid; // TRUE if Dx, and Dy are valid
    BOOL ScaleMatrixValid;     // TRUE if M11-M22 are valid
    INT M11;                   // 16.16 fixed point representation of the
    INT M12;                   //   device-to-world transform
    INT M21;
    INT M22;
    INT Dx;
    INT Dy;

    INT UIncrement;         // Increment in texture space for every one-
    INT VIncrement;         //   pixel-to-the-right in device space

    INT ModulusWidth;       // Modulus value for doing tiling
    INT ModulusHeight;

    INT XEdgeIncrement;     // Edge condition increments.
    INT YEdgeIncrement;

public:

    VOID InitializeFixedPointState();

    DpOutputBilinearSpan_MMX(
        const GpTexture *textureBrush,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context
        ) : DpOutputBilinearSpan(textureBrush, scan, worldToDevice, context)
    {
        InitializeFixedPointState();
    }

    DpOutputBilinearSpan_MMX(
        const DpBitmap *bitmap,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        ) : DpOutputBilinearSpan(
            bitmap,
            scan,
            worldToDevice,
            context,
            imageAttributes
        )
    {
        InitializeFixedPointState();
    }

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
        
    virtual BOOL IsValid() const
    {
        return (ScaleMatrixValid && DpOutputBilinearSpan::IsValid());
    }
};

//--------------------------------------------------------------------------
// Textures - Identity transform
//
// Actually, this object handles texture output for any translating
// transform, so long as the translate is integer.
//
//--------------------------------------------------------------------------

class DpOutputBilinearSpan_Identity : public DpOutputBilinearSpan
{
protected:

    INT Dx;
    INT Dy;

    BOOL PowerOfTwo;    // True if both texture dimensions power of two

public:

    DpOutputBilinearSpan_Identity(
        const GpTexture *textureBrush,
        DpScanBuffer * scan,
        GpMatrix *worldToDevice,
        DpContext *context
        ) : DpOutputBilinearSpan(textureBrush, scan, worldToDevice, context)
    {
        PowerOfTwo = !(BmpData.Width & (BmpData.Width - 1)) &&
                     !(BmpData.Height & (BmpData.Height - 1));

        // Compute the device-to-world transform (easy, eh?):

        Dx = -GpRound(worldToDevice->GetDx());
        Dy = -GpRound(worldToDevice->GetDy());
    }

    DpOutputBilinearSpan_Identity(
        const DpBitmap *bitmap,
        DpScanBuffer * scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        ) : DpOutputBilinearSpan(
            bitmap,
            scan,
            worldToDevice,
            context,
            imageAttributes
        )
    {
        PowerOfTwo = !(BmpData.Width & (BmpData.Width - 1)) &&
                     !(BmpData.Height & (BmpData.Height - 1));

        // Compute the device-to-world transform (easy, eh?):

        Dx = -GpRound(worldToDevice->GetDx());
        Dy = -GpRound(worldToDevice->GetDy());
    }

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Hatch brushes
//--------------------------------------------------------------------------

class DpOutputHatchSpan : public DpOutputSpan
{
public:
    DpScanBuffer *  Scan;
    ARGB ForeARGB;
    ARGB BackARGB;
    ARGB AverageARGB;
    BYTE Data[8][8];

protected:    
    INT m_BrushOriginX;
    INT m_BrushOriginY;
    

public:
    DpOutputHatchSpan(
        const GpHatch *hatchBrush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual ~DpOutputHatchSpan()
    {
    }

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual BOOL IsValid() const { return TRUE; }
    DpScanBuffer* GetScanBuffer(){ return Scan; }

};

class DpOutputStretchedHatchSpan : public DpOutputHatchSpan
{
public:
    DpOutputStretchedHatchSpan(
        const GpHatch *hatchBrush,
        DpScanBuffer * scan,
        DpContext* context,
        INT scaleFactor
        ) : DpOutputHatchSpan(hatchBrush,
                              scan,
                              context)
    {
        ScaleFactor = scaleFactor;
    }
    
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

private:
    INT ScaleFactor;
};

#endif // _OUTPUT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\palettemap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Object which maps one palette to another.
*
*   It only maps colors which match exactly - its purpose is to deal
*   with, e.g., the halftone palette which has identical colors on different
*   platforms, but colors may be in different positions.
*
* Revision History:
*
*   12/09/1999 ericvan
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Imaging\Api. Renamed it to EpPaletteMap.
*       Replaced the halftoning function pointer with 'isVGAOnly'.
*
\**************************************************************************/

#include "precomp.hpp"

//#define GDIPLUS_WIN9X_HALFTONE_MAP

#if defined(GDIPLUS_WIN9X_HALFTONE_MAP)

// The first array maps from our halftone color palette to the Windows 9x
// halftone color palette, while the second array does the reverse. Negative
// values indicate an unmatched color:
//
//   -1  no exact match (Win9x is missing 4 of our halftone colors)
//   -2  magic color

INT HTToWin9xPaletteMap[256] = {
      0,   1,   2,   3,   4,   5,   6,   7,
     -2,  -2,  -2,  -2, 248, 249, 250, 251,
    252, 253, 254, 255,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,
      0,  60,  95, 133, 161, 252,  33,  66,
    101, 166, 199,  -1,  39,  72, 107, 138,
    172, 205,  45,  78, 112, 129, 178, 211,
     51,  84, 118, 149, 184, 217, 250,  -1,
    123, 155, 190, 254,  29,  61,  96, 162,
    196,  -1,  34,  67, 102, 134, 167, 200,
     40,  73, 108, 139, 173, 206,  46,  79,
    113, 144, 179, 212,  52,  85, 119, 150,
    185, 218,  -1,  90, 124, 156, 191, 223,
     30,  62,  97, 135, 163, 197,  35,  68,
    103, 140, 168, 201,  41,  74, 109, 174,
    207, 230,  47,  80, 114, 145, 180, 213,
     53,  86, 151, 157, 186, 219,  57,  91,
    228, 192, 224, 232,  31,  63,  98, 131,
    164, 198,  36,  69, 104, 130, 169, 202,
     42,  75, 110, 141, 175, 208,  48,  81,
    115, 146, 181, 214,  54,  87, 120, 152,
    187, 220,  58,  92, 125, 158, 193, 225,
     32,  64,  99, 132, 165, 128,  37,  70,
    105, 136, 170, 203,  43,  76, 111, 142,
    176, 209,  49,  82, 116, 147, 182, 215,
     55,  88, 121, 153, 188, 221,  59,  93,
    126, 159, 194, 226, 249,  65, 100, 137,
    127, 253,  38,  71, 106, 143, 171, 204,
     44,  77, 227, 177, 210, 231,  50,  83,
    117, 148, 183, 216,  56,  89, 122, 154,
    189, 222, 251,  94, 229, 160, 195, 255
};

INT HTFromWin9xPaletteMap[256] = {
      0,   1,   2,   3,   4,   5,   6,   7,
     -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  76, 112, 148,
    184,  46,  82, 118, 154, 190, 226,  52,
     88, 124, 160, 196, 232,  58,  94, 130,
    166, 202, 238,  64, 100, 136, 172, 208,
    244, 142, 178, 214,  41,  77, 113, 149,
    185, 221,  47,  83, 119, 155, 191, 227,
     53,  89, 125, 161, 197, 233,  59,  95,
    131, 167, 203, 239,  65, 101, 137, 173,
    209, 245, 107, 143, 179, 215, 251,  42,
     78, 114, 150, 186, 222,  48,  84, 120,
    156, 192, 228,  54,  90, 126, 162, 198,
     60,  96, 132, 168, 204, 240,  66, 102,
    174, 210, 246,  72, 108, 180, 216, 224,
    189,  61, 157, 151, 187,  43,  85, 115,
    193, 223,  55,  91, 121, 163, 199, 229,
     97, 133, 169, 205, 241,  67, 103, 138,
    175, 211, 247,  73, 109, 139, 181, 217,
    253,  44,  79, 116, 152, 188,  49,  86,
    122, 158, 194, 230,  56,  92, 127, 164,
    200, 235,  62,  98, 134, 170, 206, 242,
     68, 104, 140, 176, 212, 248,  74, 110,
    145, 182, 218, 254,  80, 117, 153,  50,
     87, 123, 159, 195, 231,  57,  93, 128,
    165, 201, 236,  63,  99, 135, 171, 207,
    243,  69, 105, 141, 177, 213, 249, 111,
    146, 183, 219, 234, 144, 252, 129, 237,
    147,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -2,  -2,
     12,  13,  14,  15,  16,  17,  18,  19
};

#endif

BYTE
GetNearestColorIndex(
    GpColor color,
    ColorPalette *palette
    )
{
    INT i;
    BYTE nearestIndex = 0;
    INT nearestDistance = INT_MAX;

    // Note: This does not optimize for the exact match case because it's
    //       assumed we already did this check first.
    
    for (i = 0; i < (INT) palette->Count; i++)
    {
        // Compute the distance (squared) between colors:

        GpColor palColor = GpColor(palette->Entries[i]);

        INT r = (INT) color.GetRed() - (INT) palColor.GetRed();
        INT g = (INT) color.GetGreen() - (INT) palColor.GetGreen();
        INT b = (INT) color.GetBlue() - (INT) palColor.GetBlue();

        INT distance = (r * r) + (g * g) + (b * b);

        if (distance < nearestDistance)
        {
            nearestDistance = distance;
            nearestIndex = static_cast<BYTE>(i);

            if (nearestDistance == 0)
            {
                break;
            }
        }
    }

    return nearestIndex;
}

VOID
EpPaletteMap::CreateFromColorPalette(
    ColorPalette *palette
    )
{
    INT i;
    INT matchCount = 0;

#if defined(GDIPLUS_WIN9X_HALFTONE_MAP)

    // Check for the Win9x halftone palette:

    PALETTEENTRY *palEntry = Win9xHalftonePalette.palPalEntry;

    for (i = 0; i < 256; i++, palEntry++)
    {
        // Ignore magic or unmatched colors:

        if (HTFromWin9xPaletteMap[i] >= 0)
        {
            GpColor palColor(palette->Entries[i]);

            if ((palColor.GetRed() != palEntry->peRed) ||
                (palColor.GetGreen() != palEntry->peGreen) ||
                (palColor.GetBlue() != palEntry->peBlue))
            {
                break;
            }
        }
    }

    if (i == 256) // --- Win9x halftone palette ---
    {
        matchCount = 212;

        for (i = 0; i < 256; i++)
        {
            INT win9xIndex = HTToWin9xPaletteMap[i];

            if (win9xIndex >= 0)
            {
                translate[i] = static_cast<BYTE>(win9xIndex);
            }
            else
            {
                GpColor halftoneColor;

                if (win9xIndex == -1)
                {
                    halftoneColor =
                        GpColor(HTColorPalette.palPalEntry[i].peRed,
                                HTColorPalette.palPalEntry[i].peGreen,
                                HTColorPalette.palPalEntry[i].peBlue);
                }
                else
                {
                    ASSERT(win9xIndex == -2);
                    ASSERT((i >= 8) && (i <= 11));

                    COLORREF systemColor = Globals::SystemColors[i + 8];
                    
                    halftoneColor = GpColor(GetRValue(systemColor),
                                            GetGValue(systemColor),
                                            GetBValue(systemColor));
                }

                translate[i] = GetNearestColorIndex(halftoneColor,
                                                    palette);
            }
        }
    }
    else // --- Any other palette ---

#endif

    {
        for (i = 0; i < 256; i++)
        {
            GpColor color;
            
            if ((i > 11) || (i < 8))
            {
                color = GpColor(HTColorPalette.palPalEntry[i].peRed,
                                HTColorPalette.palPalEntry[i].peGreen,
                                HTColorPalette.palPalEntry[i].peBlue);
            }
            else
            {
                COLORREF systemColor = Globals::SystemColors[i + 8];
                
                color = GpColor(GetRValue(systemColor),
                                GetGValue(systemColor),
                                GetBValue(systemColor));
            }

            // First look for exact matches:
    
            INT j;

            for (j = 0; j < (INT) palette->Count; j++)
            {
                if (GpColor(palette->Entries[j]).IsEqual(color))
                {
                    // We found an exact match:

                    translate[i] = static_cast<BYTE>(j);

                    if (i >= 40)
                    {
                        matchCount++;
                    }

                    break;
                }
            }

            // If we didn't find an exact match, look for the nearest:

            if (j == (INT) palette->Count)
            {
                translate[i] = GetNearestColorIndex(color,
                                                    palette);
            }
        }
    }

    uniqueness = 0;

    // See comments in UpdateTranslate to see why we look for 212 colors.
    
    isVGAOnly = (matchCount >= 212) ? FALSE : TRUE;
}

EpPaletteMap::EpPaletteMap(HDC hdc, ColorPalette **palette, BOOL isDib8)
{
    // isDib8 is TRUE when the caller has already determined that the HDC
    // bitmap is an 8 bpp DIB section. If the caller hasn't determined, we
    // check here:

    if (!isDib8 && (GetDCType(hdc) == OBJ_MEMDC))
    {
        HBITMAP hbm = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);

        if (hbm)
        {
            DIBSECTION dibInfo;
            INT infoSize = GetObjectA(hbm, sizeof(dibInfo), &dibInfo);

            // Comment below copied from GpGraphics::GetFromGdiBitmap:
            //
            // WinNT/Win95 differences in GetObject:
            //
            // WinNT always returns the number of bytes filled, either
            // sizeof(BITMAP) or sizeof(DIBSECTION).
            //
            // Win95 always returns the original requested size (filling the
            // remainder with NULLs).  So if it is a DIBSECTION, we expect
            // dibInfo.dsBmih.biSize != 0; otherwise it is a BITMAP.

            if ((infoSize == sizeof(DIBSECTION)) &&
                (Globals::IsNt || dibInfo.dsBmih.biSize))
            {
                if (dibInfo.dsBmih.biBitCount == 8)
                {
                    isDib8 = TRUE;
                }
            }
        }
    }

    // If we've got an 8 bpp DIB section, extract its color table and create
    // the palette map from this. Otherwise, call UpdateTranslate which will
    // handle screen and compatible bitmaps.
    
    if (isDib8)
    {
        // Get the color table from the DIBSection

        RGBQUAD colorTable[256];
        GetDIBColorTable(hdc, 0, 256, colorTable);

        // Create a GDI+ ColorPalette object from it
        // Note: the reason we use "255" here is because
        // ColorPalette object already has 1 allocation for ARGB

        ColorPalette *newPalette =
            static_cast<ColorPalette *>(
                GpMalloc(sizeof(ColorPalette) + 255 * sizeof(ARGB)));

        if (newPalette)
        {
            newPalette->Flags = 0;
            newPalette->Count = 256;

            for (int i = 0; i < 256; i++)
            {
                newPalette->Entries[i] =
                    MAKEARGB(255,
                             colorTable[i].rgbRed,
                             colorTable[i].rgbGreen,
                             colorTable[i].rgbBlue);
            }

            CreateFromColorPalette(newPalette);

            if (palette)
            {
                *palette = newPalette;
            }
            else
            {
                GpFree(newPalette);
            }

            SetValid(TRUE);
            return;
        }

        SetValid(FALSE);
    }
    else
    {
        UpdateTranslate(hdc, palette);
    }
}

EpPaletteMap::~EpPaletteMap()
{
    SetValid(FALSE);    // so we don't use a deleted object
}

VOID EpPaletteMap::UpdateTranslate(HDC hdc, ColorPalette **palette)
{
    SetValid(FALSE);
    
    HPALETTE hSysPal = NULL;
    struct
    {
        LOGPALETTE logpalette;
        PALETTEENTRY palEntries[256];
    } pal;

    pal.logpalette.palVersion = 0x0300;
    
    // <SystemPalette>
    
    // !!! [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
    //    doesn't do what MSDN says it does. It seems to return the number
    //    of entries in the logical palette of the DC instead. So we have
    //    to make it up ourselves.
    
    pal.logpalette.palNumEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) *
                                          GetDeviceCaps(hdc, PLANES)));

    GetSystemPaletteEntries(hdc, 0, 256, &pal.logpalette.palPalEntry[0]);

    hSysPal = CreatePalette(&pal.logpalette);

    if (hSysPal == NULL) 
    {
        return;
    }

    if (palette) 
    {
        // system palette is required for ScanDci case.

        if (*palette == NULL)
        {   
            *palette = (ColorPalette*)GpMalloc(sizeof(ColorPalette)+sizeof(ARGB)*256); 
           
            if (*palette == NULL) 
            {
                goto exit;
            }
        }
        (*palette)->Count = pal.logpalette.palNumEntries;

        for (INT j=0; j<pal.logpalette.palNumEntries; j++) 
        {
            (*palette)->Entries[j] = GpColor::MakeARGB(0xFF,
                                                       pal.logpalette.palPalEntry[j].peRed,
                                                       pal.logpalette.palPalEntry[j].peGreen,
                                                       pal.logpalette.palPalEntry[j].peBlue);
        }
    }

    {    
        GpMemset(translate, 0, 256);
        
        INT         matchCount;
        INT             i;
        PALETTEENTRY *  halftonePalEntry = HTColorPalette.palPalEntry;
        COLORREF        halftoneColor;
        COLORREF        sysColor;
        COLORREF        matchedColor;
        UINT            matchingIndex;
        
        // Create a translation table for the 216 halftone colors, and count
        // how many exact matches we get.
        
        for (i = 0, matchCount = 0; i < 256; i++, halftonePalEntry++)
        {
           if ((i > 11) || (i < 8))
           {
               halftoneColor = PALETTERGB(halftonePalEntry->peRed, 
                                          halftonePalEntry->peGreen, 
                                          halftonePalEntry->peBlue);
           }
           else    // it is one of the magic 4 changeable system colors
           {
               halftoneColor = Globals::SystemColors[i + 8] | 0x02000000;
           }
        
           // See if the color is actually available in the system palette.
        
           matchedColor = ::GetNearestColor(hdc, halftoneColor) | 0x02000000;
        
           // Find the index of the matching color in the system palette
           
           matchingIndex = ::GetNearestPaletteIndex(hSysPal, matchedColor);
        
           if (matchingIndex == CLR_INVALID)
           {
               goto exit;
           }
        
           // We should never match to an entry outside of the device palette.
           ASSERT(matchingIndex < pal.logpalette.palNumEntries);

           translate[i] = static_cast<BYTE>(matchingIndex);
        
           sysColor = PALETTERGB(pal.logpalette.palPalEntry[matchingIndex].peRed,
                                 pal.logpalette.palPalEntry[matchingIndex].peGreen,
                                 pal.logpalette.palPalEntry[matchingIndex].peBlue);
        
           // see if we got an exact match
        
           if ((i >= 40) && (sysColor == halftoneColor))
           {
               matchCount++;
           }
        }
        
        // If we matched enough colors, we'll do 216-color halftoning.
        // Otherwise, we'll have to halftone with the VGA colors.
        // The palette returned from CreateHalftonePalette() on Win9x has
        // only 212 of the required 216 halftone colors.  (On NT it has all 216).
        // The 4 colors missing from the Win9x halftone palette are:
        //      0x00, 0x33, 0xFF
        //      0x00, 0xFF, 0x33
        //      0x33, 0x00, 0xFF
        //      0x33, 0xFF, 0x00
        // We require that all 212 colors be available because our GetNearestColor
        // API assumes that all 216 colors are there if we're doing 216-color
        // halftoning.
        
        SetValid(TRUE);
        
        if (matchCount >= 212)
        {
           isVGAOnly = FALSE;
        }
        else
        {
           isVGAOnly = TRUE;
        }
    }

exit:
    DeleteObject(hSysPal);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\palettemap.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Object which maps one palette to another.
*
*   It only maps colors which match exactly - its purpose is to deal
*   with, e.g., the halftone palette which has identical colors on different
*   platforms, but colors may be in different positions.
*
* Revision History:
*
*   12/09/1999 ericvan
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Imaging\Api. Renamed it to EpPaletteMap.
*
\**************************************************************************/

#ifndef __PALETTEMAP_HPP
#define __PALETTEMAP_HPP

class EpPaletteMap;

class EpPaletteMap
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPaletteMap : ObjectTagInvalid;
    }

private:
    UINT        uniqueness;
    BYTE        translate[256];
    BOOL        isVGAOnly;
    
public:
    VOID
    CreateFromColorPalette(
        ColorPalette *palette
        );
    
    EpPaletteMap(
        HDC hdc, 
        ColorPalette **palette = NULL,
        BOOL isDib8 = FALSE);
    
    ~EpPaletteMap();
    
    VOID UpdateTranslate(
        HDC hdc, 
        ColorPalette **palette = NULL);
    
    VOID UpdateTranslate();
    
    VOID SetUniqueness(UINT Uniqueness)
    {
        uniqueness = Uniqueness;
    }
    
    UINT GetUniqueness()
    {
        return uniqueness;
    }
    
    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPaletteMap) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PaletteMap");
        }
    #endif

        return (Tag == ObjectTagPaletteMap);
    }

    __forceinline BYTE Translate(BYTE i) const
    {
        return translate[i];
    }
    
    BOOL IsVGAOnly() const
    {
        return isVGAOnly;
    }

    const BYTE *GetTranslate() const
    {
        return translate;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scan.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal "scan class" prototypes. These classes represent a set of
*   "primitive" operations, which are characterized by being quick to render,
*   and fairly simple to represent.
*
*   [agodfrey] At time of writing, they are all scan-line operations, so the
*   name "scan class" kinda fits; however, we may need to add ones which
*   aren't scan-line oriented - e.g. one for aliased single-pixel-wide 
*   opaque solid-filled lines.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*   02/22/2000 agodfrey
*       For ClearType, but also useful for other future improvements:
*       Expanded it to allow different types of record.
*       Cleared up some of the CachedBitmap confusion,
*       and removed the confusion between "opaque" and "SourceCopy".
*                  
\**************************************************************************/

#ifndef _SCAN_HPP
#define _SCAN_HPP

#include <dciman.h>
#include "alphablender.hpp"

struct EpScanRecord;

// This color is used as a default to detect bugs.

const ARGB HorridInfraPurpleColor = 0x80ff80ff;

// blenderNum: 
//   Used when an operation mixes different scan types.
//   We don't use an enum because the meaning of each blender depends
//   on the situation.
//
//   At the time of writing, only CachedBitmap uses this - to select
//   between the regular and opaque scan types.
// BlenderMax: The number of different scan types allowed in one
//   Start() ... End() sequence. e.g. if this is 2, blenderNum can be 0 or 1.

typedef VOID *(EpScan::* NEXTBUFFERFUNCTION)(
    INT x, 
    INT y, 
    INT newWidth, 
    INT updateWidth, 
    INT blenderNum
);

const INT BlenderMax = 2;

//--------------------------------------------------------------------------
// Scan iterator class
//
// [agodfrey]: The naming is confusing. Suggestions:
//             Rename "EpScan*" to "EpScanIterator". 
//             Rename "NEXTBUFFERFUNCTION"
//               to something about "next scan", not "next buffer".
//             Make a stronger name distinction between EpScanIterator* and 
//             EpScanBufferNative. 
//
// NOTE: These classes are not reentrant, and therefore cannot be used
//       by more than one thread at a time.  In actual use, this means
//       that their use must be synchronized under the device lock.
//--------------------------------------------------------------------------

class EpScan
{
public:

    // Some scan types have settings which are constant for an entire
    // Start() ... End() operation. Right now, there are only a few such 
    // settings. So, we just pass them as parameters with defaults.
    //
    // But if this grows, we might need to put them in a structure, 
    // or pass them in a separate call.
    //
    // pixFmtGeneral - the input pixel format for the color data,
    //   in the "Blend" and "CT" scan types.
    // pixFmtOpaque - the input pixel format for the color data,
    //   in the "Opaque" scan type.
    // solidColor - the solid fill color for "*SolidFill" scan types.
    //   The default is chosen to detect bugs.

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral = PixelFormat32bppPARGB,
        PixelFormatID pixFmtOpaque = PixelFormat32bppPARGB,
        ARGB solidColor = HorridInfraPurpleColor
    ) 
    {
        // Common initialization stuff.
        
        BlenderConfig[0].ScanType = scanType;
        BlenderConfig[0].SourcePixelFormat = pixFmtGeneral;
        
        // For now, blender 1 is only used for CachedBitmap rendering;
        // it's the blender for the opaque, "native format" data.
        
        BlenderConfig[1].ScanType = EpScanTypeOpaque;
        BlenderConfig[1].SourcePixelFormat = pixFmtOpaque;
        
        CurrentX = 0;
        CurrentY = 0;
        
        DitherOriginX = context->RenderingOriginX;
        DitherOriginY = context->RenderingOriginY;
        
        return TRUE;
    }
    
    virtual VOID End(INT currentWidth) = 0;

    virtual VOID *GetCurrentBuffer() = 0;

    virtual BYTE *GetCurrentCTBuffer() = 0;

    virtual VOID Flush() = 0;

    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of Blend and Opaque

    // If a scan class doesn't support it, it returns FALSE.

    virtual BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX,
        INT minY,
        INT maxX, 
        INT maxY
    ) 
    {
        return FALSE;
    }
    
    // The x and y coordinates for the current scanline (blending scanline).
    // not the current requested next buffer.
    
    INT CurrentX;
    INT CurrentY;
    
    // The origin for the dither pattern.
    
    INT DitherOriginX;
    INT DitherOriginY;

    // "Blender configuration"
    //
    // For one Start() ... End() sequence, at most two different scan types are
    // used, and often there's just one. 
    // So, we allocate two EpAlphaBlender objects, and set them up 
    // appropriately during Start().
    //
    // Right now, the second one is only used for CachedBitmap. But in the
    // future, it might be used e.g. to mix "solidfill" scans with 
    // "blend" scans for antialiased solid fills. In that case, Start() will
    // need more parameters to tell it how to set up the blender objects.
    //
    // Note:
    //
    // In V2, we may want to avoid reinitializing the AlphaBlenders
    // for every primitive. But that'll take some work - there are many reasons
    // we might need to reinitialize. It wouldn't be enough to have
    // an EpAlphaBlender for each scan type (and I wouldn't recommend it 
    // anyway.)

    // !!! [agodfrey] "EpBlenderConfig" and "BlenderConfig" could do with
    //     better names. But I can't think of any.
    
    struct EpBlenderConfig
    {
        EpAlphaBlender AlphaBlender;
        PixelFormatID SourcePixelFormat;
        EpScanType ScanType;
        
        VOID Initialize(
            PixelFormatID dstFormat,
            const DpContext *context,
            const ColorPalette *dstpal,
            VOID **tempBuffers,
            BOOL dither16bpp,
            BOOL useRMW,
            ARGB solidColor)
        {
            AlphaBlender.Initialize(
                ScanType,
                dstFormat,
                SourcePixelFormat,
                context,
                dstpal,
                tempBuffers,
                dither16bpp,
                useRMW,
                solidColor);
        }
    };
    
    EpBlenderConfig BlenderConfig[BlenderMax];
    
    // LastBlenderNum:
    // Used by the flush mechanism in the NextBuffer functions 
    // to figure out which AlphaBlender to use to flush the buffer.
    
    INT LastBlenderNum;
};

//--------------------------------------------------------------------------
// Scan buffer class
//
// This class is intended to be used be any drawing code wishing to output
// to a scan buffer; callers should not use the EpScan class directly.
//--------------------------------------------------------------------------

template<class T>
class EpScanBufferNative
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagScanBufferNative : ObjectTagInvalid;
    }

private:

    DpBitmap *Surface;
    EpScan *Scan;
    NEXTBUFFERFUNCTION NextBufferFunction;
    INT CurrentWidth;

public:

    // noTransparentPixels - TRUE if there will be no transparent pixels.
    //   If you're not sure, set it to FALSE.
    //
    //   If it's set to TRUE, we'll substitute "Opaque" scan types for "Blend"
    //   scan types - if the pixels are all opaque, they're equivalent,
    //   and "Opaque" is faster.
    // solidColor - The solid color for *SolidFill scan types.    
    //   The default is chosen to detect bugs.
    
    EpScanBufferNative(
        EpScan *scan,
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        BOOL noTransparentPixels = FALSE,
        EpScanType scanType = EpScanTypeBlend,
        PixelFormatID pixFmtGeneral = PixelFormat32bppPARGB,
        PixelFormatID pixFmtOpaque = PixelFormat32bppPARGB,
        ARGB solidColor = HorridInfraPurpleColor
        )
    {
        if (   noTransparentPixels
            && (scanType == EpScanTypeBlend))
        {
            scanType = EpScanTypeOpaque;
        }
        
        CurrentWidth = 0;
        Surface = surface;
        Scan = scan;
        SetValid(Scan->Start(
            driver,
            context,
            surface,
            &NextBufferFunction,
            scanType,
            pixFmtGeneral,
            pixFmtOpaque,
            solidColor
        ));
    }
    
    ~EpScanBufferNative()
    {
        if (IsValid())
        {
            Scan->End(CurrentWidth);
        }
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of SourceOver and SourceCopy.

    // If it's unsupported, it returns FALSE.

    BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX, 
        INT minY,
        INT maxX, 
        INT maxY
    ) 
    {
        return Scan->ProcessBatch(batchStart, batchEnd, minX, minY, maxX, maxY);
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagScanBufferNative) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid ScanBufferNative");
        }
    #endif

        return (Tag == ObjectTagScanBufferNative);
    }

    // NextBuffer() flushes the previous scan (if there was one) and
    // returns a pointer to the new buffer.  Note that NextBuffer()
    // will never fail (but the constructor to EpScanBufferNative might
    // have!).
    //
    // blenderNum: 
    //     Used when an operation mixes different scan types.
    //     We don't use an enum because the meaning of each blender depends
    //     on the situation.
    //
    //     At the time of writing, only CachedBitmap uses this - to select
    //     between the regular and opaque scan types.
    //
    // Note: The contents of the buffer are not zeroed by NextBuffer().
    //       Use NextBufferClear() if you want the contents zeroed if
    //       you're doing an accumulation type of operation.
    //
    // Note: NextBuffer() may or may not return the same pointer as the
    //       previous NextBuffer() call.

    T *NextBuffer(
        INT x, INT y,
        INT nextWidth,
        INT blenderNum = 0
    )
    {
        ASSERT(IsValid());
        T *buffer = (T *)((Scan->*NextBufferFunction)(
            x, 
            y, 
            nextWidth, 
            CurrentWidth,
            blenderNum
        ));
        CurrentWidth = nextWidth;
        return buffer;
    }

    T *NextBufferClear(
        INT x, INT y, 
        INT width,
        INT blenderNum = 0
    )
    {
        T *buffer = NextBuffer(x, y, width, blenderNum);
        GpMemset(buffer, 0, width * sizeof(T));
        return buffer;
    }
    
    // !!! [agodfrey]: It would be better to remove the CurrentWidth member,
    //     and have UpdateWidth call a member in the Scan object.
    //
    //     It would also make this class' NextBuffer implementation less 
    //     confusing - it wouldn't mix parameters describing the next scan 
    //     with parameters describing the current one.

    VOID UpdateWidth(INT width)
    {
        // The width can only be shrunk:

        ASSERT(width <= CurrentWidth);
        CurrentWidth = width;
    }

    DpBitmap *GetSurface()
    {
        return Surface;
    }

    T *GetCurrentBuffer()
    {
        return (T *)(Scan->GetCurrentBuffer());
    }

    BYTE *GetCurrentCTBuffer()
    {
        return Scan->GetCurrentCTBuffer();
    }
};


class EpPaletteMap;

//--------------------------------------------------------------------------
// Direct access to the bits
//--------------------------------------------------------------------------

// [agodfrey] EpScanEngine and EpScanBitmap have some common code. Consider
//    merging that code into a single class, derived from EpScan, and then
//    deriving EpScanEngine and EpScanBitmap from it.

class EpScanEngine : public EpScan
{
private:

    BYTE *Dst;
    BYTE *Bits;
    INT Stride;
    INT PixelSize;       // Presumably the pixel size of the destination.
    DpBitmap * Surface;
    
    VOID *Buffers[5];

private:

    VOID *NextBuffer(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );

public:

    EpScanEngine() {}
    ~EpScanEngine() {}

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral, 
        PixelFormatID pixFmtOpaque ,
        ARGB solidColor
    );

    virtual VOID End(INT updateWidth);
    virtual VOID* GetCurrentBuffer() { return static_cast<VOID *>(Buffers[3]); }
    virtual BYTE* GetCurrentCTBuffer() 
    { 
        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));

        return static_cast<BYTE *>(Buffers[4]);
    }
    virtual VOID Flush() {}
};

//--------------------------------------------------------------------------
// Access to the GpBitmap bits
//
// This scan interface is used for scan drawing to a GpBitmap object.
// The GpBitmap object is the internal representation of a GDI+ bitmap.
//--------------------------------------------------------------------------

class EpScanBitmap;
typedef VOID (EpScanBitmap::*SCANENDFUNCTION)(INT updateWidth);

class EpScanBitmap : public EpScan
{
private:

    DpBitmap* Surface;
    GpBitmap* Bitmap;
    INT Width;
    INT Height;

    BOOL BitmapLocked;
    BitmapData LockedBitmapData;
    UINT BitmapLockFlags;

    VOID* CurrentScan;  // only used by NextBufferNative
    INT PixelSize;      // only used by NextBufferNative
    
    VOID *Buffers[5];

    SCANENDFUNCTION EndFunc;

private:

    VOID *NextBuffer32ARGB(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );
    
    VOID *NextBufferNative(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
    VOID End32ARGB(INT updateWidth);
    VOID EndNative(INT updateWidth);

public:

    EpScanBitmap()
    {
        Buffers[0] = NULL;
        BitmapLocked = FALSE;
        Bitmap = NULL;
    }

    ~EpScanBitmap() { FreeData(); }

    VOID SetBitmap(GpBitmap* bitmap)
    {
        Bitmap = bitmap;
    }

    VOID FreeData()
    {
        if (Buffers[0])
            GpFree(Buffers[0]);

        Buffers[0] = NULL;
    }

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );

    virtual VOID End(INT updateWidth);

    virtual VOID *GetCurrentBuffer()
    { 
        return static_cast<ARGB *>(Buffers[3]); 
    }

    virtual BYTE* GetCurrentCTBuffer() 
    { 
        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));

        return static_cast<BYTE *>(Buffers[4]); 
    }
    
    virtual VOID Flush();

    GpBitmap *GetBitmap()
    {
        return Bitmap;
    }
};

//--------------------------------------------------------------------------
// Use either GDI or DCI for all scan drawing
//--------------------------------------------------------------------------

// MAKE_*WORD_ALIGNED:
// Increments the pointer, if necessary, to the next aligned address.
//
// WARNING: If you use this, you need to remember the original pointer,
// so that you can free the memory later.
//
// "p = MAKE_QWORD_ALIGNED(blah, p)" is a bug.

#define MAKE_QWORD_ALIGNED(type, p) (\
    reinterpret_cast<type>((reinterpret_cast<INT_PTR>(p) + 7) & ~7))

#define MAKE_DWORD_ALIGNED(type, p) (\
    reinterpret_cast<type>((reinterpret_cast<INT_PTR>(p) + 3) & ~3))

// Adds the given number of bytes to a pointer

#define ADD_POINTER(type, p, increment) (\
    reinterpret_cast<type>(reinterpret_cast<BYTE *>(p) + (increment)))

#define ASSERT_DWORD_ALIGNED(p) ASSERTMSG(!(reinterpret_cast<INT_PTR>(p) & 3), ("'" #p "' not DWORD aligned"))
#define ASSERT_QWORD_ALIGNED(p) ASSERTMSG(!(reinterpret_cast<INT_PTR>(p) & 7), ("'" #p "' not QWORD aligned"))

// The variable-format structure for all batch record types.
// Must be stored at a QWORD-aligned location

struct EpScanRecord
{
    UINT16 BlenderNum;  // Identifies the AlphaBlender to be used to render
                        // the scan. (0 through BlenderMax-1).
    UINT16 ScanType;    // EpScanType explicitly coerced into 2 bytes.
    INT X;
    INT Y;
    INT Width;          // Number of pixels to output
    INT OrgWidth;       // The original width when the record was allocated.
                        // (The width may change later, and we need the original
                        //  width in order to calculate the positions of 
                        //  the variable-length records.)

    // Different scan types have different fields after the header:
    // 1) EpScanTypeOpaque, EpScanTypeBlend: 
    //    A color buffer, of "Width" pixels, in some pixel format. 8-byte aligned.
    // 2) EpScanTypeCT:
    //    A color buffer, of "Width" pixels, in some pixel format. 8-byte aligned.
    //    A CT coverage buffer, of "Width" bytes. 4-byte aligned.
    // 3) EpScanTypeCTSolidFill:
    //    A CT coverage buffer, of "Width" bytes. 4-byte aligned.

    // Return the color buffer, of "Width" pixels. Valid for
    // EpScanTypeOpaque, EpScanTypeBlend and EpScanTypeCT.
    
    VOID *GetColorBuffer()
    {
        if (GetScanType() == EpScanTypeCTSolidFill)
            return NULL;
        return CalculateColorBufferPosition(
            this,
            GetScanType()
            );
    }
    
    EpScanType GetScanType()
    {
        return static_cast<EpScanType>(ScanType);
    }
    
    VOID SetScanType(EpScanType type)
    {
        ASSERT(type < (1<<sizeof(ScanType)));

        ScanType = static_cast<UINT16>(type);
    }
    
    // A safe way to set blenderNum - the cast is protected by an assertion.

    VOID SetBlenderNum(INT blenderNum)
    {
        ASSERT(   (blenderNum >= 0)
               && (blenderNum < BlenderMax));

        BlenderNum = static_cast<UINT16>(blenderNum);
    }

    // Return the CT buffer, of "Width" pixels.
    // Valid for EpScanTypeCT and EpScanTypeCTSolidFill only.
    //
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    BYTE *GetCTBuffer(
        INT colorFormatSize
        )
    {
        EpScanType type = GetScanType();
        ASSERT(   (type == EpScanTypeCT)
               || (type == EpScanTypeCTSolidFill));
        
        if (type == EpScanTypeCT)
        {
            return CalculateCTBufferPosition(
                this,
                type,
                OrgWidth,
                colorFormatSize);
        }
        else
        {
            return CalculateCTBufferPositionCTSolidFill(this);
        }
    }
    
    // Calculates the position of the next scan record, given enough data
    // about the current one.
    //
    // This is like NextScanRecord, but it doesn't require the "currentRecord"
    // pointer to point to valid memory. Instead, the necessary data is
    // passed in parameters.
    //
    // Callers can use this to decide whether the record will fit into
    // available memory.  
    //
    // currentRecord   - points to the "current" record. This doesn't need
    //                   to be a valid record, and the memory it points to
    //                   doesn't need to be big enough to hold the current
    //                   record. Must be QWORD-aligned.
    // type            - the type of record
    // width           - the actual number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    static EpScanRecord *CalculateNextScanRecord(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT colorFormatSize
        )
    {
        return InternalCalculateNextScanRecord(
            currentRecord,
            type,
            width,
            width,
            colorFormatSize);
    }
    
    // Returns a pointer to the next scan record, based on the current,
    // valid scan record.
    //
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    EpScanRecord *NextScanRecord(
        INT colorFormatSize
        )
    {
        return InternalCalculateNextScanRecord(
            this,
            GetScanType(),
            Width,
            OrgWidth,
            colorFormatSize);
    }

private:
    
    // These functions are 'static' to emphasize that they're usable on
    // EpScanRecord pointers which don't point to valid memory.

    // Calculates the position of the next scan record, given enough data
    // about the current one.
    //
    // currentRecord   - points to the "current" record. This doesn't need
    //                   to be a valid record, and the memory it points to
    //                   doesn't need to be big enough to hold the current
    //                   record. Must be QWORD-aligned.
    // type            - the type of record
    // width           - the actual number of pixels
    // orgWidth        - the "original" width - the width at the time the
    //                   scan was first allocated. Can't be smaller than
    //                   'width'.
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    static EpScanRecord *InternalCalculateNextScanRecord(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT orgWidth,
        INT colorFormatSize
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        
        EpScanRecord *p;
 
        // If width < orgWidth, we can reclaim some of the space at the end.
        // However, the record positions are based on orgWidth, so
        // only the final record can be shrunk.
        //
        // So, the pattern for the below is:
        // 1) Get the pointer to the last field, using "orgWidth".
        // 2) Add the field size, using "width" (not "orgWidth").
        // 3) QWORD-align it.
            
        switch (type)
        {
        case EpScanTypeBlend:
        case EpScanTypeOpaque:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateColorBufferPosition(currentRecord, type),
                width * colorFormatSize);
            break;
        
        case EpScanTypeCT:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateCTBufferPosition(
                    currentRecord, 
                    type, 
                    orgWidth, 
                    colorFormatSize),
                width);
            break;
        
        case EpScanTypeCTSolidFill:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateCTBufferPositionCTSolidFill(
                    currentRecord),
                width);
            break;
        }

        return MAKE_QWORD_ALIGNED(EpScanRecord *, p);
    }
    
    // Return a pointer to the color buffer. Valid for
    // EpScanTypeOpaque, EpScanTypeBlend and EpScanTypeCT.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    
    static VOID *CalculateColorBufferPosition(
        EpScanRecord *currentRecord,
        EpScanType type
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        ASSERT(   (type == EpScanTypeOpaque)
               || (type == EpScanTypeBlend)
               || (type == EpScanTypeCT));
        
        // Since the pointer is QWORD-aligned, we can do this by adding
        // the 'QWORD-aligned size' of this structure. 
        // 
        // The "regular" way would be to add the size and then 
        // QWORD-align the pointer. But this is more efficient, because
        // qwordAlignedSize is a compile-time constant.
        
        const INT qwordAlignedSize = (sizeof(EpScanRecord) + 7) & ~7;

        return ADD_POINTER(VOID *, currentRecord, qwordAlignedSize);
    }

    // Return a pointer to the CT buffer.
    // Valid for EpScanTypeCT only.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    // width           - the number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    static BYTE *CalculateCTBufferPosition(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT colorFormatSize
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        ASSERT(type == EpScanTypeCT);
        
        BYTE *p = ADD_POINTER(
            BYTE *,
            CalculateColorBufferPosition(currentRecord, type),
            colorFormatSize * width);
            
        return MAKE_DWORD_ALIGNED(BYTE *, p);
    }
    
    // Return a pointer to the CT buffer, of "Width" pixels. 
    // Valid for EpScanTypeCTSolidFill only.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    // width           - the number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    static BYTE *CalculateCTBufferPositionCTSolidFill(
        EpScanRecord *currentRecord
    )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);

        BYTE *p = reinterpret_cast<BYTE *>(currentRecord+1);
            
        ASSERT_DWORD_ALIGNED(p);
            
        return p;
    }

};

// Queue data structures:

enum GdiDciStatus
{
    GdiDciStatus_TryDci,    // We're to try using DCI, but it hasn't been 
                            //   initialized yet (which if it fails will 
                            //   cause us to fall back to GDI)
    GdiDciStatus_UseDci,    // We successfully initialized DCI, so use it 
                            //   for all drawing
    GdiDciStatus_UseGdi,    // Use only GDI for all drawing
};

// Minimum buffer size for the DCI drawing queue:

#define SCAN_BUFFER_SIZE 64*1024

class EpScanGdiDci : public EpScan
{

private:

    // Persistent state:

    GdiDciStatus Status;                // Class status
    GpDevice* Device;                   // Associate device; must exist for
                                        //   the lifetime of this object
    DpContext* Context;                 // Points to the context object related
                                        //   to any records sitting in the batch.
                                        //   May be invalid if the batch is
                                        //   empty.
    DpBitmap* Surface;                  // Similarly points to the surface
                                        //   related to any records sitting in
                                        //   the batch.
    BOOL IsPrinter;                     // Is the destination a printer?
    DCISURFACEINFO *DciSurface;         // DCI surface state, allocated by
                                        //   DCI
    INT PixelSize;                      // Pixel size, in bytes for the current
                                        // batch record
    VOID *Buffers[5];                   // Temporary scan buffers
                                        
    // Cache objects:

    HRGN CacheRegionHandle;             // Region we hang on to so that we
                                        //   don't have to re-create on every
                                        //   query
    RGNDATA *CacheRegionData;           // Clipping data allocation (may be 
                                        //   NULL)
    INT CacheDataSize;
    RECT *EnumerateRect;
    INT EnumerateCount;

    // Bounds accumulation:

    INT MinX;
    INT MaxX;
    INT MinY;
    INT MaxY;                           // Note that YMax is 'inclusive'

    // Global offset for the batch processing.

    INT BatchOffsetX;
    INT BatchOffsetY;
    
    // For *SolidFill scan types, we need to record the solid color passed
    // to Start(). We use it when we call EpAlphaBlender::Initialize()
    
    ARGB SolidColor;                  

    // Enumeration information:

    VOID *BufferMemory;                 // Points to start of buffer memory
                                        // block
    EpScanRecord *BufferStart;          // Points to queue buffer start.
                                        // QWORD-aligned.
    EpScanRecord *BufferEnd;            // Points to end of queue buffer
    EpScanRecord *BufferCurrent;        // Points to current queue position
    INT BufferSize;                     // Size of queue buffer in bytes

private:

    VOID *NextBuffer(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );
    
    VOID LazyInitialize();
    VOID EmptyBatch();

    VOID DownloadClipping_Dci(HDC hdc, POINT *clientOffset);
    VOID ProcessBatch_Dci(HDC hdc, EpScanRecord* bufferStart, EpScanRecord* bufferEnd);
    BOOL Reinitialize_Dci();
    VOID LazyInitialize_Dci();
    
    EpScanRecord* FASTCALL DrawScanRecords_Dci(
        BYTE* bits, INT stride,
        EpScanRecord* record, 
        EpScanRecord* endRecord, 
        INT xOffset, INT yOffset,
        INT xClipLeft, INT yClipTop, 
        INT xClipRight, INT yClipBottom
    );

    VOID ProcessBatch_Gdi(
        HDC hdc, 
        EpScanRecord* bufferStart, 
        EpScanRecord* bufferEnd
    );

    // Perform SrcOver blend using GDI for 32bpp (P)ARGB source pixels only.

    VOID SrcOver_Gdi_ARGB(
        HDC destinationHdc, 
        HDC dibSectionHdc, 
        VOID *dibSection,
        EpScanRecord *scanRecord
    );

public:

    // Pass TRUE for 'tryDci' if it's okay to try using DCI for our rendering;
    // otherwise only use GDI:

    EpScanGdiDci(GpDevice *device, BOOL tryDci = FALSE);

    ~EpScanGdiDci();

    virtual BOOL Start(
        DpDriver *driver, 
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );
    
    virtual VOID End(INT updateWidth);

    virtual VOID* GetCurrentBuffer()
    {
        return BufferCurrent->GetColorBuffer();
    }

    virtual BYTE* GetCurrentCTBuffer() 
    { 
        // We assume that in ClearType cases,
        // there is only one scan type for the Start()...End() sequence

        ASSERT(BufferCurrent->BlenderNum == 0);
        
        // This should only be called for ClearType scan types

        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));
        
        ASSERT(BlenderConfig[0].ScanType == BufferCurrent->GetScanType());
        
        return BufferCurrent->GetCTBuffer(
            GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
            );
    }
    
    virtual VOID Flush();

    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of SourceOver and SourceCopy.

    virtual BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX,
        INT minY,
        INT maxX,
        INT maxY
    );
};

#endif // !_SCAN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scan.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains all the 32-bit scan-buffer routines for the default supported
*   bitmap formats.
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Scan class helper function that SrcOver alpha blends two ARGB buffers.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*   [IN] scanType - The type of scan.
*   [IN] pixFmtGeneral - the input pixel format for the color data,
*          in the "Blend" and "CT" scan types.
*   [IN] pixFmtOpaque - the input pixel format for the color data,
*          in the "Opaque" scan type.
*   [IN] solidColor - the solid fill color for "*SolidFill" scan types.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanEngine::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral,
        pixFmtOpaque,
        solidColor
    );    
    
    // DIBSection destinations don't have an alpha channel
    
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    Surface = surface;

    if(surface->Type == DpBitmap::D3D)
    {
        DDSURFACEDESC2             ddsd;

        memset(&ddsd, 0, sizeof(ddsd));
         ddsd.dwSize = sizeof(ddsd);

        HRESULT err;

        err = Surface->DdrawSurface7->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
        if(err != DD_OK)
            return(FALSE);

        Surface->Bits = ddsd.lpSurface;
        Surface->Delta = ddsd.lPitch;
    }

    Dst = NULL;
    Stride = surface->Delta;
    Bits = (BYTE*) surface->Bits;
    PixelSize = GetPixelFormatSize(surface->PixelFormat) >> 3;

    // [agodfrey] This Scan class is only designed for use with formats
    // which are supported natively, so it ignores the DIBSection and
    // corresponding PixelFormatID returned by GetScanBuffers.

    PixelFormatID dstFormat = surface->PixelFormat;

    ASSERTMSG(dstFormat != PIXFMT_UNDEFINED,(("Unexpected surface format")));

    *nextBuffer = (NEXTBUFFERFUNCTION) EpScanEngine::NextBuffer;

    if (!driver->Device->GetScanBuffers(
        surface->Width, 
        NULL, 
        NULL, 
        NULL, 
        Buffers)
       )
    {
        return NULL;
    }
  
    // initialize the AlphaBlenders.

    BlenderConfig[0].Initialize(
        dstFormat,
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    BlenderConfig[1].Initialize(
        dstFormat, 
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID *EpScanEngine::NextBuffer(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    if (updateWidth != 0)
    {
        // Make sure we're not drawing outside the bounds of the surface.
        // If these ASSERTs are triggered, the clipping code is broken.
        // This class absolutely must have input clipped to the surface
        // bounds otherwise we will AV writing on bad memory, or corrupt some
        // other data structure.
        
        ASSERT( CurrentX >= 0 );
        ASSERT( CurrentY >= 0 );
        ASSERT( CurrentX + updateWidth <= Surface->Width );
        ASSERT( CurrentY < Surface->Height );
        
        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            Dst, 
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX, 
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );
    }
        
    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;
    
    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Calculate the destination for the scan:
    
    Dst = Bits + (y * Stride) + (x * PixelSize);

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanEngine::End(
    INT updateWidth
    )
{
    // Flush the last scan:

    NextBuffer(0, 0, 0, updateWidth, 0);

    if(Surface->Type == DpBitmap::D3D)
    {
        Surface->DdrawSurface7->Unlock(NULL);
        Surface->Bits = NULL;
        Surface->Delta = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Scan class helper function that SrcOver alpha blends two ARGB buffers.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*   [IN] scanType - The type of scan.
*   [IN] pixFmtGeneral - the input pixel format for the color data,
*          in the "Blend" and "CT" scan types.
*   [IN] pixFmtOpaque - the input pixel format for the color data,
*          in the "Opaque" scan type.
*   [IN] solidColor - the solid fill color for "*SolidFill" scan types.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

BOOL
EpScanBitmap::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral, 
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );    
    
    GpStatus status;
    BOOL writeOnly = FALSE;
    GpCompositingMode compositingMode = context->CompositingMode;
    
    Surface = surface;

    if (scanType == EpScanTypeOpaque)
    {
        writeOnly = TRUE;
    }
    else
    {
        // Work out if this operation will write transparent pixels (alpha != 1)
        // into the surface for the first time.

        switch (surface->SurfaceTransparency)
        {
        case TransparencyUnknown:
        case TransparencyNoAlpha:
        break;
        
        case TransparencyOpaque:
            // If the surface contains only opaque pixels, the SourceOver
            // operation will produce only opaque pixels. So for SourceOver,
            // a transition from TransparencyOpaque to TransparencyUnknown is
            // impossible.
            
            if (   (scanType == EpScanTypeBlend)
                && (compositingMode == CompositingModeSourceOver))
            {
                break;
            }
            
            // Else, fall through:
        
        case TransparencySimple:
            // !!![agodfrey]: Theoretically, if the destination pixel format
            //    is 1555, we could set it to 'TransparencySimple' here.
            
            surface->SurfaceTransparency = TransparencyUnknown;
            Bitmap->SetTransparencyHint(surface->SurfaceTransparency);
            break;
            
        default:
            RIP(("Unrecognized surface transparency"));    
            break;
        }
    }

    // Pick the appropriate blending function based on the format of the
    // bitmap.
    
    ASSERTMSG(Bitmap != NULL, ("EpScanBitmap not initialized"));

    PixelFormatID dstFormat;
    if (FAILED(Bitmap->GetPixelFormatID(&dstFormat)))
        return FALSE;

    switch (dstFormat)
    {
    case PIXFMT_16BPP_RGB555:
    case PIXFMT_16BPP_RGB565:
    case PIXFMT_24BPP_RGB:
    case PIXFMT_32BPP_RGB:
    case PIXFMT_32BPP_ARGB:
    case PIXFMT_24BPP_BGR:
    case PIXFMT_32BPP_PARGB:

        // Since we're doing just one lock of the whole image, we have
        // to allow read-modify-write since only a portion of the bitmap
        // may be written.

        BitmapLockFlags = (IMGLOCK_WRITE | IMGLOCK_READ);

        *nextBuffer = (NEXTBUFFERFUNCTION) EpScanBitmap::NextBufferNative;
        EndFunc = (SCANENDFUNCTION) EpScanBitmap::EndNative;

        status = Bitmap->LockBits(NULL, BitmapLockFlags,
                                  dstFormat, &LockedBitmapData);
        if (status == Ok)
        {
            CurrentScan = NULL;
            PixelSize = GetPixelFormatSize(dstFormat) >> 3;
            break;
        }

        // else fall into the generic case and use 32bpp ARGB

    default:

        // When locking a scanline at a time and the mode is SourceCopy,
        // the read is unnecessary.

        if (writeOnly)
        {
            BitmapLockFlags = IMGLOCK_WRITE;
        }
        else
        {
            BitmapLockFlags = (IMGLOCK_WRITE | IMGLOCK_READ);
        }
    
        dstFormat = PIXFMT_32BPP_ARGB;

        *nextBuffer = (NEXTBUFFERFUNCTION) EpScanBitmap::NextBuffer32ARGB;
        EndFunc = (SCANENDFUNCTION) EpScanBitmap::End32ARGB;

        break;
    }

    // Allocate the temporary buffers. 
    // Buffers[3] will be given to the caller to be used to pass scans to us.
    // Buffers[4] will be used for ClearType data.

    if (Buffers[0] == NULL)
    {
        Size bitmapSize;
        status = Bitmap->GetSize(&bitmapSize);

        if (status == Ok)
        {
            Width  = bitmapSize.Width;
            Height = bitmapSize.Height;

            Buffers[0] = GpMalloc(sizeof(ARGB64) * bitmapSize.Width * 5);
            
            if (Buffers[0])
            {
                int i;
                for (i=1;i<5;i++)
                {
                    Buffers[i] = static_cast<BYTE *>(Buffers[i-1]) + 
                                 sizeof(ARGB64) * bitmapSize.Width;
                }
            }
            else
            {
                ONCE(WARNING(("(once) Buffer allocation failed")));
                return FALSE;
            }
        }
        else
        {
            ONCE(WARNING(("(once) GetSize failed")));
            return FALSE;
        }
    }
    
    // initialize the AlphaBlenders.

    BlenderConfig[0].Initialize(
        dstFormat,
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    BlenderConfig[1].Initialize(
        dstFormat, 
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   NextBuffer function used when we have low-level functions that match
*   native format of the GpBitmap and we can read/write directly into the
*   bitmap bits.
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID *EpScanBitmap::NextBufferNative(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    // Flush the previous buffer:

    if ((updateWidth != 0) && (CurrentScan != NULL))
    {
        ASSERTMSG(Buffers[0] != NULL, ("no buffers"));
        ASSERTMSG(updateWidth <= Width, ("updateWidth too big"));

        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            CurrentScan,
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX,
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );
    }
    
    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;

    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Get the next destination scan:

    CurrentScan = NULL;

    // Check that surface clipping has been done properly.
    
    if((y >= 0) && (y < Height) && (x >= 0) && (x < Width))
    {
        // Clip against the right edge of the bitmap. newWidth is an upper
        // bound only - not guaranteed to be clipped.
        
        if (newWidth > (Width - x))
        {
            newWidth = Width - x;
        }
    
        if (newWidth > 0)
        {
            CurrentScan = static_cast<VOID *>
                            (static_cast<BYTE *>(LockedBitmapData.Scan0)
                             + (y * LockedBitmapData.Stride)
                             + (x * PixelSize));
        }
    }
    else
    {
        // If we hit this, we're hosed. The OutputSpan routines in the
        // DpOutputSpan classes are built assuming correct clipping (at least
        // to the data buffer) and hence, if we hit this assert, we're going 
        // to crash horibly later writing all over memory when we start writing
        // outside of the bounds of the destination allocation.
    
        // if you're here, someone broke clipping or the dpi computation.
    
        ASSERTMSG(!((y >= 0) && (y < Height) && (x >= 0) && (x < Width)),
                  (("EpScanBitmap::NextBufferNative: x, y out of bounds")));

    }

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Generic NextBuffer function that accesses GpBitmap bits
*   via GpBitmap::Lock/UnlockBits for each scan.
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID *EpScanBitmap::NextBuffer32ARGB(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    // Flush the previous buffer:

    if (updateWidth != 0 && BitmapLocked)
    {
        ASSERTMSG(Buffers[0] != NULL, ("no buffers"));
        ASSERTMSG(LockedBitmapData.Scan0 != NULL, ("no previous buffer"));

        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            LockedBitmapData.Scan0, 
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX, 
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );

        Bitmap->UnlockBits(&LockedBitmapData);
        BitmapLocked = FALSE;
    }
    else if (BitmapLocked)
    {
        EpScanBitmap::Flush();
    }

    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;
    
    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Lock the next destination:

    // Check that surface clipping has been done properly.

    if((y >= 0) && (y < Height) && (x >= 0) && (x < Width))
    {
        // Clip against the right edge of the bitmap. newWidth is an upper
        // bound only - not guaranteed to be clipped. LockBits needs it
        // to be clipped.
        
        if (newWidth > (Width - x))
        {
            newWidth = Width - x;
        }
    
        if (newWidth > 0)
        {
            GpRect nextRect(x, y, newWidth, 1);
    
            GpStatus status = Bitmap->LockBits(
                &nextRect, 
                BitmapLockFlags,
                PixelFormat32bppARGB, 
                &LockedBitmapData
            );
    
            if (status == Ok)
                BitmapLocked = TRUE;
        }
    
    } 
    else
    {
        // If we hit this, we're hosed. The OutputSpan routines in the
        // DpOutputSpan classes are built assuming correct clipping (at least
        // to the data buffer) and hence, if we hit this assert, we're going 
        // to crash horibly later writing all over memory when we start writing
        // outside of the bounds of the destination allocation.
    
        // if you're here, someone broke clipping or the dpi computation.
        
        ASSERTMSG(!((y >= 0) && (y < Height) && (x >= 0) && (x < Width)),
                  (("EpScanBitmap::NextBufferNative: x, y out of bounds")));
    }

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID
EpScanBitmap::End32ARGB(
    INT updateWidth
    )
{
    // Flush the last scan:

    EpScanBitmap::NextBuffer32ARGB(0, 0, 0, updateWidth, 0);
}

VOID
EpScanBitmap::EndNative(
    INT updateWidth
    )
{
    // Flush the last scan and release bitmap access:

    EpScanBitmap::NextBufferNative(0, 0, 0, updateWidth, 0);
    Bitmap->UnlockBits(&LockedBitmapData);
}

VOID
EpScanBitmap::End(
    INT updateWidth
    )
{
    (this->*EndFunc)(updateWidth);

    // Lock/UnlockBitmap has to be very aggressive about setting
    // TransparancyUnknown in the GpBitmap since the caller could be
    // doing anything to the alpha channel.  However, the EpScanBitmap
    // knows what it is doing, so the surface->SurfaceTransparency is
    // more accurate.

    Bitmap->SetTransparencyHint(Surface->SurfaceTransparency);
}

/**************************************************************************\
*
* Function Description:
*
*   Flush any batched rendering and optionally wait for rendering to finish.
*
* Return Value:
*
*   NONE
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID EpScanBitmap::Flush()
{
    if (BitmapLocked && Bitmap)
    {
        Bitmap->UnlockBits(&LockedBitmapData);
        BitmapLocked = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\precomp.hpp ===
#ifdef _M_IX86
#pragma warning(disable:4799)       // No EMMS.
#endif
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\sdkinc\gdiplusimaging.h"

#include "..\..\ddkinc\ddiplus.hpp"
#include "..\..\privinc\pixelformats.h"

#include "scan.hpp"
#include "scandib.hpp"

// Hack:
#include "..\..\privinc\imaging.h"
#include "..\imaging\api\ImgUtils.hpp"
#include "..\imaging\api\colorpal.hpp"
#include "..\Entry\device.hpp"
#include "..\Entry\ImageAttr.hpp"
#include "..\Entry\gpbitmap.hpp"
#include "..\Entry\brush.hpp"
#include "..\Entry\pen.hpp"
#include "..\Entry\QuadTransforms.hpp"
#include "..\Entry\geometry.hpp"
// EndHack

#include "ScanOperationInternal.hpp"
#include "srgb.hpp"

#include "vgahash.hpp"
#include "formatconverter.hpp"
#include "alphablender.hpp"
#include "httables.hpp"
#include "output.hpp"
#include "bicubic.hpp"
#include "nearestneighbor.hpp"
#include "aarasterizer.hpp"
#include "line.hpp"
#include "stretch.hpp"

// Hack:
// font stuff

#define _NO_DDRAWINT_NO_COM

#include "..\fondrv\tt\ttfd\fontddi.h"
#include "..\Entry\fontface.hpp"
#include "..\Entry\facerealization.hpp"
#include "..\Entry\aatext.hpp"
// EndHack
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scandci.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the scan-buffer routines for DCI and GDI.
*
* Plan:
*
*   !!! [agodfrey] 
*       For batching across primitives, the DpContext code
*       needs to flush the batch whenever the Context changes state.
*    
*       If that isn't feasible for some kinds of state, then EpScanGdiDci
*       could keep its own DpContext, updated when "context update" records
*       are inserted into the batch. (This would happen during a call to
*       Start()).
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Engine\Entry.
*   03/23/2000 andrewgo
*       Integrate DCI and GDI scan cases, for IsMoveSizeActive handling.
*   02/22/2000 agodfrey
*       For ClearType, but also useful for other future improvements:
*       Expanded the batch structure to allow different types of record.
*
\**************************************************************************/

#include "precomp.hpp"

#include <limits.h>

/**************************************************************************\
*
* Function Description:
*
*   Downloads the clipping rectangles for the specified window.  Updates
*   internal class clipping variables and returns the window offset to
*   be used.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::DownloadClipping_Dci(
    HDC hdc,
    POINT *clientOffset         // In/Out
    )
{
    INT i;
    RECT *rect;

    HRGN regionHandle = CacheRegionHandle;
    RGNDATA *data = CacheRegionData;
    INT size = CacheDataSize;

    // Query the VisRgn:

    INT getResult = GetRandomRgn(hdc, regionHandle, SYSRGN);
    if (getResult == TRUE)
    {
        INT newSize = GetRegionData(regionHandle, size, data);

        // The spec says that  GetRegionData returns '1' in the event of 
        // success, but NT returns the actual number of bytes written if 
        // successful, and returns '0' if the buffer wasn't large enough:

        if ((newSize < 1) || (newSize > size))
        {
            do {
                newSize = GetRegionData(regionHandle, 0, NULL);

                // Free the old buffer and allocate a new one:

                GpFree(data);
                data = NULL;
                size = 0;

                if (newSize < 1)
                    break;

                data = static_cast<RGNDATA*>(GpMalloc(newSize));
                if (data == NULL)
                    break;

                size = newSize;
                newSize = GetRegionData(CacheRegionHandle, size, data);

                // On NT, it's possible due to multithreading that the
                // regionHandle could have increased in complexity since we
                // asked for the size.  (On Win9x, this isn't possible due
                // to the fact that BeginAccess acquires the Win16Lock.)
                // So in the rare case that this might happen, loop again:

            } while (newSize < size);

            CacheRegionData = data;
            CacheDataSize = size;
        }

        if (data != NULL)
        {
            INT xOffset = clientOffset->x;
            INT yOffset = clientOffset->y;

            // Set up some enumeration state:

            EnumerateCount = data->rdh.nCount;
            EnumerateRect = reinterpret_cast<RECT*>(&data->Buffer[0]);

            // Handle our multimon goop:

            INT screenOffsetX = Device->ScreenOffsetX;
            INT screenOffsetY = Device->ScreenOffsetY;

            if ((screenOffsetX != 0) || (screenOffsetY != 0))
            {
                // Adjust for screen offset for the multimon case:

                xOffset -= screenOffsetX;
                yOffset -= screenOffsetY;

                // Adjust and intersect every clip rectangle to account for
                // this monitor's location:
                
                if(Globals::IsNt)
                {
                    for (rect = EnumerateRect, i = EnumerateCount; 
                         i != 0; 
                         i--, rect++)
                    {
                        // subtract off the screen origin so we can get 
                        // screen relative rectangles. This is only appropriate
                        // on NT - Win9x is window relative.
                                                
                        rect->left -= screenOffsetX;
                        rect->right -= screenOffsetX;
                        rect->top -= screenOffsetY;
                        rect->bottom -= screenOffsetY;
                        
                        // Clamp to the screen dimension.
                        
                        if (rect->left < 0) 
                        {
                            rect->left = 0;
                        }
        
                        if (rect->right > Device->ScreenWidth) 
                        {
                            rect->right = Device->ScreenWidth;
                        }
        
                        if (rect->top < 0) 
                        {
                            rect->top = 0;
                        }
        
                        if (rect->bottom > Device->ScreenHeight) 
                        {
                            rect->bottom = Device->ScreenHeight;
                        }
                    }
                }
            }

            // On Win9x, GetRandomRgn returns the rectangles in window
            // coordinates, not screen coordinates, so we adjust them
            // here:

            if (!Globals::IsNt)
            {
                for (rect = EnumerateRect, i = EnumerateCount; 
                     i != 0; 
                     rect++, i--)
                {
                    // Add the screen relative window offset to the rect.
                    // The rect is window relative on Win9x, so this 
                    // calculation will give us the screen relative rectangle
                    // we need.
                    
                    rect->left += xOffset;
                    rect->right += xOffset;
                    rect->top += yOffset;
                    rect->bottom += yOffset;
        
                    // clamp to the screen dimentions.
                                
                    if (rect->left < 0) 
                    {
                        rect->left = 0;
                    }
                    
                    if (rect->top < 0) 
                    {
                        rect->top = 0;
                    }
                    
                    if (rect->right > Device->ScreenWidth) 
                    {
                        rect->right = Device->ScreenWidth;
                    }

                    if (rect->bottom > Device->ScreenHeight) 
                    {
                        rect->bottom = Device->ScreenHeight;
                    }
                }
            }

            // Return the offset:

            clientOffset->x = xOffset;
            clientOffset->y = yOffset;

            return;
        }
    }

    // Something failed (could have been a bad 'hdc' specified, or low
    // memory).  As a result we set the clip regionHandle to 'empty':

    EnumerateCount = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Sits in a tight loop to read the scan data structures, do any 
*   necessary clipping, and render the result.
*
* Return Value:
*
*   Points to the queue record it couldn't understand (typically a 
*   header record), or end of the buffer if reached.
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanRecord*
FASTCALL
EpScanGdiDci::DrawScanRecords_Dci(
    BYTE* bits,
    INT stride,
    EpScanRecord* record,
    EpScanRecord* endRecord,
    INT xOffset,
    INT yOffset,
    INT xClipLeft,
    INT yClipTop,
    INT xClipRight,
    INT yClipBottom
    )
{
    INT blenderNum;
    INT x;
    INT y;
    INT width;
    INT xLeft;
    INT xRight;
    INT count;

    INT pixelSize = PixelSize;

    // Set up the AlphaBlender objects
    
    PixelFormatID dstFormat = Surface->PixelFormat;
    
    BOOL result = Device->GetScanBuffers(
        Surface->Width,
        NULL,
        NULL,
        NULL,
        Buffers);
        
    if (result && (dstFormat != PIXFMT_UNDEFINED))
    {
        // Palette and PaletteMap are set up by Start().
        // initialize the AlphaBlenders.

        BlenderConfig[0].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
        
        BlenderConfig[1].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
    }    
    else
    {
        ONCE(WARNING(("DrawScanRecords_Dci: Unrecognized pixel format")));
        return endRecord;
    }
    
    INT ditherOriginX = DitherOriginX;
    INT ditherOriginY = DitherOriginY;
    
    do {


        // SrcOver_Gdi_ARGB assumes that if the format is lower than 8bpp,
        // then the DIBSection format is 8bpp.

        // Bug 310285:  This assert is disabled and should be reinvestigated
        // for v2.  It is likely the Surface pointer needs to be changed
        // to the real surface that's being rendered.
        
        //ASSERT(   (Surface->PixelFormat == PixelFormatUndefined)
        //       || (GetPixelFormatSize(Surface->PixelFormat) >= 8)
        //       || (dstFormat == PixelFormat8bppIndexed));
        
        blenderNum = record->BlenderNum;
        ASSERT(record->GetScanType() == BlenderConfig[blenderNum].ScanType);

        x = record->X + xOffset + BatchOffsetX;
        y = record->Y + yOffset + BatchOffsetY;
        width = record->Width;

        INT recordFormatSize =  
            GetPixelFormatSize(BlenderConfig[blenderNum].SourcePixelFormat) >> 3;

        if ((y >= yClipTop) && (y < yClipBottom))
        {
            xRight = x + width;
            if (xRight > xClipRight)
                xRight = xClipRight;

            xLeft = x;
            if (xLeft < xClipLeft)
                xLeft = xClipLeft;

            count = xRight - xLeft;
            if (count > 0)
            {
                BYTE *src = NULL;
                BYTE *ctBuffer = NULL;
                EpScanType scanType = record->GetScanType();
                
                if (scanType != EpScanTypeCTSolidFill)
                {
                    src = reinterpret_cast<BYTE*>(record->GetColorBuffer());
                    src += (xLeft - x)*recordFormatSize;
                }
                
                if (   (scanType == EpScanTypeCT)
                    || (scanType == EpScanTypeCTSolidFill))
                {
                    ctBuffer = record->GetCTBuffer(
                        GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
                        );
                    ctBuffer += (xLeft - x);
                }
                
                BYTE *dst = bits + (y * stride) + (xLeft * pixelSize);
                    
                BlenderConfig[blenderNum].AlphaBlender.Blend(
                    dst, 
                    src, 
                    count, 
                    xLeft - ditherOriginX, 
                    y     - ditherOriginY,
                    ctBuffer
                );
            }
        }

        // Advance to the next record:

        record = record->NextScanRecord(recordFormatSize);

    } while (record < endRecord);

    return(record);
}

/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue.
*
*   Note that it does not empty the queue; the caller is responsible.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::ProcessBatch_Dci(
    HDC hdc,                // Only used to query window offset and clipping
    EpScanRecord *buffer,
    EpScanRecord *bufferEnd
    )
{
    INT i;
    RECT *clipRect;
    EpScanRecord *nextBuffer;
    POINT clientOffset;
    POINT duplicateOffset;
    INT result;
    
    while (TRUE)
    {
        // Peek at the window offset so that we can specify the bounds on
        // the DCI lock properly.  Note that the window offset may change
        // between the time we do this peak, and the time we do the
        // BeginAccess.
        //
        // GetDCOrgEx may fail if the DC is bad, in which case we shouldn't
        // draw anything:
    
        if (!GetDCOrgEx(hdc, &clientOffset))
        {
            return;
        }

        // Adjust for the monitor's offset:

        INT xOffset = clientOffset.x - Device->ScreenOffsetX;
        INT yOffset = clientOffset.y - Device->ScreenOffsetY;

        // Clip to the surface bounds (multi-mon might cause the bounds
        // to be bigger than our surface):
    
        INT x = max(MinX + xOffset, 0);
        INT y = max(MinY + yOffset, 0);

        // MaxY is inclusive:

        INT width  = min(MaxX + xOffset,     Device->ScreenWidth) - x;
        INT height = min(MaxY + yOffset + 1, Device->ScreenHeight) - y;

        if ((width <= 0) || (height <= 0))
        {
            return;
        }

        // Acquire the DCI lock:
        
        result = Globals::DciBeginAccessFunction(
            DciSurface, 
            x, y, 
            width, 
            height
         );

        if (result < DCI_OK)
        {
            // The DCI lock failed.  There are really two possible reasons:
            //
            //  1.  There was a mode change;
            //  2.  The system at some point switched to a secure desktop
            //      (such as by Ctrl-Alt-Del or by a screen saver) on NT.
            //
            // For the former case, we get a WM_DISPLAYCHANGED notification 
            // message, and we have code that recreates all the GDI+ surface
            // representations (because a color-depth change happened, or
            // the multi-mon configuration might have changed, and we can't
            // recover from either of those this deep in the rendering
            // pipeline).
            //
            // For the second case, we get no notification other than the 
            // DCI lock failure.  So for this case, we try to reinitialize
            // our DCI state right here.  

            if (!Reinitialize_Dci())
            {
                return;
            }
            
            result = Globals::DciBeginAccessFunction(
                DciSurface, 
                x, y, 
                width, 
                height
            );
        }

        // If we failed to get a DCI lock, don't bother processing any
        // of the queue.  We're outta here:
    
        if (result < DCI_OK)
        {
            return;
        }

        // Check the window offset again and verify that it's still
        // the same as the value we used to compute the lock rectangle:

        GetDCOrgEx(hdc, &duplicateOffset);

        if ((duplicateOffset.x == clientOffset.x) &&
            (duplicateOffset.y == clientOffset.y))
        {
            break;
        }

        // The window moved between the time we computed the
        // DCI lock area and the time we actually did the DCI 
        // lock.  Unlock and repeat:
        
        Globals::DciEndAccessFunction(DciSurface);
    } 

    // Every time we acquire the DCI lock, we have to requery the
    // clipping.  
    //
    // Now that we've acquired the DCI lock (or we failed to acquire
    // it but won't actually draw anything), then it's safe to
    // download the clipping, because it won't change until we do
    // the DCI unlock:

    DownloadClipping_Dci(hdc, &clientOffset);

    // Copy the data to the surface:

    BYTE *bits = reinterpret_cast<BYTE*>(DciSurface->dwOffSurface);
    INT stride = DciSurface->lStride;

    // We don't have to do any rendering when the clipping is empty:

    if (EnumerateCount != 0)
    {
        while (buffer < bufferEnd)
        {
            // Redraw each scan buffer once for every clip rectangle:

            i = EnumerateCount;
            clipRect = EnumerateRect;
            
            do {
                nextBuffer = DrawScanRecords_Dci(
                    bits, 
                    stride,
                    buffer, 
                    bufferEnd,
                    clientOffset.x,
                    clientOffset.y,
                    clipRect->left, 
                    clipRect->top, 
                    clipRect->right, 
                    clipRect->bottom
                );
                
            } while (clipRect++, --i);

            buffer = nextBuffer;
        }
    }

    // Unlock the primary:

    Globals::DciEndAccessFunction(DciSurface);   
}

/**************************************************************************\
*
* Function Description:
*
*   Try to re-initialize DCI after a Lock failure (as may be caused by
*   a switch to a secure desktop).  This will succeed only if the mode
*   is exactly the same resolution and color depth as it was before
*   (otherwise our clipping or halftone or whatever would be wrong if
*   we continued).
*
* Return Value:
*
*   TRUE if successfully re-initialized; FALSE if not (with the side
*   effect that we switch to using GDI).
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanGdiDci::Reinitialize_Dci()
{
    ASSERT(Status == GdiDciStatus_UseDci);

    DWORD oldBitCount = DciSurface->dwBitCount;
    DWORD oldWidth = DciSurface->dwWidth;
    DWORD oldHeight = DciSurface->dwHeight;

    Globals::DciDestroyFunction(DciSurface);

    DciSurface = NULL;

    if (Globals::DciCreatePrimaryFunction(Device->DeviceHdc, 
                                          &DciSurface) == DCI_OK)
    {
        if ((DciSurface->dwBitCount == oldBitCount) &&
            (DciSurface->dwWidth == oldWidth) &&
            (DciSurface->dwHeight == oldHeight))
        {
            return(TRUE);
        }
    }

    // Uh oh, we failed to recreate exactly the same surface.  Switch
    // over to using GDI:

    Status = GdiDciStatus_UseGdi;

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Return the PixelFormatID for the given DCI surface.
*
*   Added because of bug #96879 - when I fixed it, I found that 
*   DCI would then succeed on the ATI Mach 64 GX's
*   non-standard 32bpp mode, and we were happily trying to draw it
*   (and getting our colors mixed up).
*
* Arguments:
*
*   si - The DCISURFACEINFO to examine
*
* Return Value:
*
*   The PixelFormatID.
*
* History:
*
*   09/10/2000 agodfrey
*       Created it.
*
\**************************************************************************/

static PixelFormatID
ExtractPixelFormatFromDCISurface(
    DCISURFACEINFO *si
    )
{
    // 8bpp
    if (si->dwBitCount == 8)
    {
        return PixelFormat8bppIndexed;
    }
    
    // 24bpp RGB and 32bpp RGB
    if ((si->dwMask[0] == 0x00ff0000) &&       
        (si->dwMask[1] == 0x0000ff00) &&     
        (si->dwMask[2] == 0x000000ff))        
    {                                             
        if (si->dwBitCount == 24)
        {
            return PixelFormat24bppRGB;
        }
        else if (si->dwBitCount == 32)
        {
            return PixelFormat32bppRGB;
        }
    }

    // 16bpp 555
    if ((si->dwMask[0] == 0x00007c00) &&  
        (si->dwMask[1] == 0x000003e0) &&
        (si->dwMask[2] == 0x0000001f) && 
        (si->dwBitCount == 16))       
    {
        return PixelFormat16bppRGB555;
    }
    
    // 16bpp 565
    if ((si->dwMask[0] == 0x0000f800) &&  
        (si->dwMask[1] == 0x000007e0) &&
        (si->dwMask[2] == 0x0000001f) && 
        (si->dwBitCount == 16))       
    {
        return PixelFormat16bppRGB565;
    }

    // Unsupported format
    return PixelFormatUndefined;
}

/**************************************************************************\
*
* Function Description:
*
*   Does all the initialization needed for DCI.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::LazyInitialize_Dci()
{
    // If a mirror driver is active, never use DCI:

    if (Globals::IsMirrorDriverActive || Globals::g_fAccessibilityPresent)
    {
        Status = GdiDciStatus_UseGdi;
        return;
    }

    // Use the LoadLibrary critical section to protect access
    // to our global variables.

    LoadLibraryCriticalSection llcs;

    // We'll lose memory if we're called more than once:

    ASSERT(Status == GdiDciStatus_TryDci);

    // DCIMAN32 exists on all versions of Win9x and NT4 and newer.  

    if (Globals::DcimanHandle == NULL)
    {
        // Note: [minliu: 12/18/2000] The reason I added this following line
        // here:
        // 1) This is Office bug #300329
        // 2) The basic problem is that on Windows 98, with ATI Fury Pro/Xpert
        // 2000 Pro (English) card, with latest display driver,
        // wme_w98_r128_4_12_6292.exe. The floating point control state get
        // changed after we call LoadLibraryA("dciman32.dll"). Apparently the
        // display driver changes it. We are going to reporting this problem to
        // ATI Tech. In the meantime we need to check this in so that
        // PowerPointer can be launched on that machine

        FPUStateSandbox fps;

        HMODULE module = LoadLibraryA("dciman32.dll");
        if (module)
        {
            Globals::DciEndAccessFunction = (DCIENDACCESSFUNCTION)
                GetProcAddress(module, "DCIEndAccess");
            Globals::DciBeginAccessFunction = (DCIBEGINACCESSFUNCTION)
                GetProcAddress(module, "DCIBeginAccess");
            Globals::DciDestroyFunction = (DCIDESTROYFUNCTION)
                GetProcAddress(module, "DCIDestroy");
            Globals::DciCreatePrimaryFunction = (DCICREATEPRIMARYFUNCTION)
                GetProcAddress(module, "DCICreatePrimary");

            if ((Globals::DciEndAccessFunction     != NULL) &&
                (Globals::DciBeginAccessFunction   != NULL) &&
                (Globals::DciDestroyFunction       != NULL) &&
                (Globals::DciCreatePrimaryFunction != NULL))
            {
                Globals::DcimanHandle = module;
            }
            else
            {
                // It failed, so free the library.

                FreeLibrary(module);
            }
        }    
    }

    if (Globals::DcimanHandle != NULL)
    {
        if (Globals::DciCreatePrimaryFunction(Device->DeviceHdc,
                                              &DciSurface) == DCI_OK)
        {
            // Check that the format is one we can handle natively.

            if (EpAlphaBlender::IsSupportedPixelFormat(
                    ExtractPixelFormatFromDCISurface(DciSurface)))
            {
                PixelSize = DciSurface->dwBitCount >> 3;

                CacheRegionHandle = CreateRectRgn(0, 0, 0, 0);
                if (CacheRegionHandle)
                {
                    // Okay, initialize the whole class:

                    // We're all set to use DCI:

                    Status = GdiDciStatus_UseDci;
                    return;
                }
            }
            
            Globals::DciDestroyFunction(DciSurface);
            DciSurface = NULL;
        }
    }

    // Darn, we can't use DCI.  

    Status = GdiDciStatus_UseGdi;
}

/**************************************************************************\
*
* Function Description:
*
*   Handles a SrcOver call via GDI routines, making sure to do the
*   smallest GDI calls possible
*
* Return Value:
*
*   None
*
* History:
*
*   03/22/2000 andrewgo
*       Created it.
*
\**************************************************************************/

static BOOL OptimizeRuns(ARGB *src, INT width)
{
    if (width <= 8)
        return TRUE;

    BYTE * alpha = reinterpret_cast<BYTE*>(src) + 3;
    UINT numberOfRuns = 0;
    BOOL inRun = FALSE;
    for (INT pos = 0; pos < width; ++pos, alpha += 4)
    {
        if (static_cast<BYTE>(*alpha + 1) <= 1)
        {
            if (inRun)
            {
                ++numberOfRuns;
                if (numberOfRuns > 4)
                    return TRUE;
                inRun = FALSE;
            }
        }
        else
        {
            inRun = TRUE;
        }
    }
    return FALSE;
} // OptimizeRuns

VOID
EpScanGdiDci::SrcOver_Gdi_ARGB(
    HDC destinationHdc,
    HDC dibSectionHdc,
    VOID *dibSection,
    EpScanRecord *scanRecord
    )
{
    BYTE* alpha;
    INT left;
    INT right;
    INT bltWidth;
    
    VOID *src = NULL;
    BYTE *ctBuffer = NULL;
    EpScanType scanType = scanRecord->GetScanType();
    
    if (scanType != EpScanTypeCTSolidFill)
    {
        src = scanRecord->GetColorBuffer();
    }

    if (   (scanType == EpScanTypeCT)
        || (scanType == EpScanTypeCTSolidFill))
    {
        ctBuffer = scanRecord->GetCTBuffer(
            GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
            );
    }
    
    INT x = scanRecord->X;
    INT y = scanRecord->Y;
    INT width = scanRecord->Width;

    if (GetPixelFormatSize(Surface->PixelFormat) < 8)
    {
        // [agodfrey]: #98904 - we hit an assert or potential AV in 
        //   Convert_8_sRGB, because the buffer contains values that 
        //   are out-of-range of the palette. To fix this, zero the
        //   temporary buffer whenever we're in less than 8bpp mode.
        
        GpMemset(dibSection, 0, width);
    }

    BOOL optimizeStretchBlt = FALSE;
    if (   (BlenderConfig[0].ScanType == EpScanTypeCT)
        || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill))
        optimizeStretchBlt = TRUE;
    else
        optimizeStretchBlt = OptimizeRuns(
            reinterpret_cast<ARGB *>(src), 
            width
            );

    if (optimizeStretchBlt)
    {
        StretchBlt(dibSectionHdc, 0, 0, width, 1, 
                   destinationHdc, x, y, width, 1, 
                   SRCCOPY);
    }
    else
    {
        ASSERT(src != NULL);
        
        // We discovered on NT5 that some printer drivers will fall over
        // if we ask to blt from their surface.  Consequently, we must
        // ensure we never get into this code path for printers!
    
        // [ericvan] This improperly asserts on compatible printer DC's
        // [agodfrey] No, see Start().

        // ASSERT(GetDeviceCaps(destinationHdc, TECHNOLOGY) != DT_RASPRINTER);

        // Only read those pixels that we have to read.  In benchmarks
        // where we're going through GDI to the screen or to a compatible
        // bitmap, we're getting killed by our per-pixel read costs.
        // Terminal Server at least has the 'frame buffer' sitting in
        // system memory, but with NetMeeting we still have to read from
        // video memory.
        //
        // Unfortunately, the per-call overhead of StretchBlt is fairly
        // high (but not too bad when we're using a DIB-section - it 
        // beats the heck out of StretchDIBits).

        alpha = reinterpret_cast<BYTE*>(src) + 3;
        right = 0;
        while (TRUE)
        {
            // Find the first translucent pixel:

            left = right;
            while ((left < width) && (static_cast<BYTE>(*alpha + 1) <= 1))
            {
                left++;
                alpha += 4;
            }

            // If there are no more runs of translucent pixels,
            // we're done:

            if (left >= width)
                break;

            // Now find the next completely transparent or opaque 
            // pixel:

            right = left;
            while ((right < width) && (static_cast<BYTE>(*alpha + 1) > 1))
            {
                right++;
                alpha += 4;
            }

            bltWidth = right - left;

            // BitBlt doesn't work on Multimon on Win2K when the destinationHdc
            // is 8bpp.  But StretchBlt does work.

            StretchBlt(dibSectionHdc, left, 0, bltWidth, 1, 
                       destinationHdc, x + left, y, bltWidth, 1, 
                       SRCCOPY);
        }
    }

    // Do the blend:

    BlenderConfig[scanRecord->BlenderNum].AlphaBlender.Blend(
        dibSection, 
        src, 
        width, 
        x - DitherOriginX, 
        y - DitherOriginY,
        ctBuffer
    );

    if (optimizeStretchBlt)
    {
        StretchBlt(destinationHdc, x, y, width, 1,
                   dibSectionHdc, 0, 0, width, 1,
                   SRCCOPY);
    }
    else
    {
        // Write the portions that aren't completely transparent back 
        // to the screen:

        alpha = reinterpret_cast<BYTE*>(src) + 3;
        right = 0;
        while (TRUE)
        {
            // Find the first non-transparent pixel:

            left = right;
            while ((left < width) && (*alpha == 0))
            {
                left++;
                alpha += 4;
            }

            // If there are no more runs of non-transparent pixels,
            // we're done:

            if (left >= width)
                break;

            // Now find the next completely transparent pixel:

            right = left;
            while ((right < width) && (*alpha != 0))
            {
                right++;
                alpha += 4;
            }

            bltWidth = right - left;

            // BitBlt doesn't work on Multimon on Win2K when the 
            // destinationHdc is 8bpp.  But StretchBlt does work.

            StretchBlt(destinationHdc, x + left, y, bltWidth, 1,
                       dibSectionHdc, left, 0, bltWidth, 1,
                       SRCCOPY);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue and resets it to be empty.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::ProcessBatch_Gdi(
    HDC destinationHdc,
    EpScanRecord *buffer,
    EpScanRecord *bufferEnd
    )
{
    ULONG type;
    INT x;
    INT y;
    INT width;
    VOID *dibSection;
    HDC dibSectionHdc;

    // Set up the AlphaBlender objects
    
    PixelFormatID dstFormat;

    // We must never be called with an empty batch.
    
    ASSERT(MaxX >= MinX);
    
    // We should be using Surface->Width as an upper bound on 
    // our internal blending buffer, but because of other bugs
    // we're potentially using the wrong Surface here.
    // Instead we use the width of the bounding rectangle for
    // all the spans in the batch.
    
    BOOL result = Device->GetScanBuffers(
        //Surface->Width,
        MaxX - MinX,
        &dibSection,
        &dibSectionHdc,
        &dstFormat,
        Buffers
    );
        
    if (result && (dstFormat != PIXFMT_UNDEFINED))
    {
        // Palette and PaletteMap are set up by Start().
        // initialize the AlphaBlenders.
        
        BlenderConfig[0].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
        
        BlenderConfig[1].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
    }    
    else
    {
        ONCE(WARNING(("EmptyBatch_Gdi: Unrecognized pixel format")));
        return;
    }
    
    INT ditherOriginX = DitherOriginX;
    INT ditherOriginY = DitherOriginY;
    
    do {
        INT blenderNum = buffer->BlenderNum;
        
        x = buffer->X + BatchOffsetX;
        y = buffer->Y + BatchOffsetY;
        width = buffer->Width;

        // This must never happen. If it does, we are going to write off
        // the end of our DIBSection and blending buffers. On win9x this will
        // overwrite some stuff in GDI and bring down the entire system.
        // On NT we'll AV and bring down the app.
                
        ASSERT(width <= Device->BufferWidth);
        
        EpScanType scanType = buffer->GetScanType();
        
        if (scanType != EpScanTypeOpaque)
        {
            SrcOver_Gdi_ARGB(
                destinationHdc, 
                dibSectionHdc, 
                dibSection, 
                buffer
            );
        }
        else
        {
            ASSERT(scanType == EpScanTypeOpaque);

            // Do the copy:
    
            BlenderConfig[blenderNum].AlphaBlender.Blend(
                dibSection, 
                buffer->GetColorBuffer(),
                width, 
                x - ditherOriginX, 
                y - ditherOriginY,
                NULL
            );
    
            // Write the result back to the screen:
    
            StretchBlt(destinationHdc, x, y, width, 1, 
                       dibSectionHdc, 0, 0, width, 1, 
                       SRCCOPY);
        }

        // Advance to the next buffer:

        buffer = buffer->NextScanRecord(
            GetPixelFormatSize(BlenderConfig[blenderNum].SourcePixelFormat) >> 3
        );

    } while (buffer < bufferEnd);
}


/**************************************************************************\
*
* Function Description:
*
*   Takes a batch as input and calls the internal flush 
*   mechanism to process it after which it restores the 
*   internal state.
*
* Notes
*   
*   This routine can handle multiple pixel formats with different
*   SourceOver or SourceCopy combinations.
*
* Return Value:
*
*   TRUE
*
* History:
*
*   5/4/2000 asecchia
*       Created it.
*
\**************************************************************************/
    
BOOL EpScanGdiDci::ProcessBatch(
    EpScanRecord *batchStart, 
    EpScanRecord *batchEnd,
    INT minX,
    INT minY, 
    INT maxX,
    INT maxY
)
{
    // NOTE: From the comments for class EpScan:
    // NOTE: These classes are not reentrant, and therefore cannot be used
    //       by more than one thread at a time.  In actual use, this means
    //       that their use must be synchronized under the device lock.
    
    // Flush the batch
    
    Flush();

    // Save the buffers
    
    EpScanRecord *bs = BufferStart;          // Points to queue buffer start
    EpScanRecord *be = BufferEnd;            // Points to end of queue buffer
    EpScanRecord *bc = BufferCurrent;        // Points to current queue position
    INT size = BufferSize;                   // Size of queue buffer in bytes
    
    // Set up the buffers for the new batch.
    
    BufferStart   = batchStart;
    BufferEnd     = batchEnd;
    BufferCurrent = batchEnd;

    // note this implies that the buffer is not larger than MAXINT
    // !!! [asecchia] not sure if the Flush needs this to be set.

    BufferSize    = (INT)((INT_PTR)batchEnd - (INT_PTR)batchStart);

    // Set the bounds:
    // Don't need to save the old bounds because the flush will reset them.

    MinX = minX;
    MinY = minY;
    MaxX = maxX;
    MaxY = maxY;

    // Set the batch offset to the drawing offset.

    BatchOffsetX = minX;
    BatchOffsetY = minY;

    // Flush the batch.
    
    Flush();

    // Restore the buffers.

    BufferStart = bs;
    BufferEnd = be;
    BufferCurrent = bc;
    BufferSize = size;

    BatchOffsetX = 0;
    BatchOffsetY = 0;

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Instantiates a scan instance for rendering to the screen via either
*   DCI or GDI.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanGdiDci::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    // This sets up BlenderConfig[]. Mostly, these will be used at the time
    // we flush the batch. But BlenderConfig[0].ScanType is also used in
    // GetCurrentCTBuffer().
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );

    BOOL bRet = TRUE;
    
    // Record the solid color for later
    
    SolidColor = solidColor;

    // The ScanBuffer and EpScan classes _MUST_ be protected by
    // the Device Lock - if you hit this ASSERT, go and acquire
    // the Devlock before entering the driver.
    // EpScanGdiDci is used exclusively for drawing to the screen, therefore
    // we assert on the DesktopDriver Device being locked. If you're locking
    // some other device, that's also a bug - use a different EpScan class.

    ASSERT(Globals::DesktopDriver->Device->DeviceLock.IsLockedByCurrentThread());

    // First check to see if we have something in the queue for a different
    // Graphics (which can happen with multiple threads drawing to different 
    // windows, since we only have one queue):

    if ((context != Context) || (surface != Surface))
    {
        // Check to see if we have to do a lazy initialize:
    
        if (Status == GdiDciStatus_TryDci)
        {
            LazyInitialize_Dci();
        }

        EmptyBatch();

        // We stash away a pointer to the context.  Note that the GpGraphics
        // destructor always calls us to flush, thus ensuring that we
        // won't use a stale Context pointer in the EmptyBatch call above.

        Context = context;
        Surface = surface;
    }

    GpCompositingMode compositingMode = context->CompositingMode;
    
    // !!![andrewgo] We discovered that NT will fall over with some printer
    //               drivers if we ask to read from the printer surface.
    //               But we should never be hitting the scan interface in
    //               the printer case!  (Scans are too much overhead, and
    //               alpha should be handled via screen-door anyway.)

    // [ericvan] This improperly asserts on compatible printer DC's
    // [agodfrey] No, we should have a separate scan class for that case
    //            - one which doesn't batch up the scans, and doesn't try to
    //            use DCI. Printer DC's also shouldn't have a pointer
    //            to the desktop device.
    //            If this is fixed, the assertion below can be reenabled.
    
    //ASSERT(GetDeviceCaps(Context->Hdc, TECHNOLOGY) != DT_RASPRINTER);

    // GDI and DCI destinations don't have an alpha channel:
    
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    // Allocate our queue buffer, if necessary:

    // This makes some assumptions:
    // 1) The records in blender 0 are bigger than records in blender 1.
    // 2) The biggest color buffer format is 4 bytes per pixel.
    
    EpScanRecord *maxRecordEnd = EpScanRecord::CalculateNextScanRecord(
        BufferCurrent,
        BlenderConfig[0].ScanType,
        surface->Width,
        4);
        
    INT_PTR requiredSize = reinterpret_cast<BYTE *>(maxRecordEnd) - 
                           reinterpret_cast<BYTE *>(BufferCurrent);
    
    if (requiredSize > BufferSize)
    {
        // If we need to resize, it follows that there should be nothing
        // sitting in the queue for this surface:
        //
        // [agodfrey] It does? More explanation needed.

        ASSERT(BufferCurrent == BufferStart);

        // Free the old queue and allocate a new one:

        GpFree(BufferMemory);

        // Scan records are much smaller than 2GB, so 'requiredSize' will fit
        // into an INT.
        
        ASSERT(requiredSize < INT_MAX);
    
        BufferSize = (INT)max(requiredSize, SCAN_BUFFER_SIZE);
        
        // We may need up to 7 extra bytes in order to QWORD align BufferStart.
        
        BufferMemory = GpMalloc(BufferSize+7);
        if (BufferMemory == NULL)
        {
            BufferSize = 0;
            bRet = FALSE;
            return bRet;
        }
        BufferStart = MAKE_QWORD_ALIGNED(EpScanRecord *, BufferMemory);

        // Make sure that we didn't overstep the 7 
        // padding bytes in the allocation.
        
        ASSERT(((INT_PTR) BufferStart) - ((INT_PTR) BufferMemory) <= 7);

        BufferEnd = reinterpret_cast<EpScanRecord *>
                        (reinterpret_cast<BYTE*>(BufferStart) + BufferSize);

        BufferCurrent = BufferStart;
    }

    *nextBuffer = (NEXTBUFFERFUNCTION) EpScanGdiDci::NextBuffer;

    // Cache the translation vector and palette for the device.  We only 
    // need to do so in 8bpp mode.
    //
    // Update the color palette and palette map if necessary.

    if (Device->Palette != NULL)
    {
        // Grab the DC just for the purposes of looking at the palette
        // selected:

        HDC destinationHdc = context->GetHdc(surface);

        EpPaletteMap *paletteMap = context->PaletteMap;
        if (paletteMap != NULL) 
        {
            // IsValid() check isn't necessary because if we are in an
            // invalid state, we may be able to get out of it in
            // UpdateTranslate()

            if (paletteMap->GetUniqueness() != Globals::PaletteChangeCount)
            {
                paletteMap->UpdateTranslate(destinationHdc);
                paletteMap->SetUniqueness(Globals::PaletteChangeCount);
            }
        }
        else
        {
            paletteMap = new EpPaletteMap(destinationHdc);

            if (paletteMap != NULL)
            {
                paletteMap->SetUniqueness(Globals::PaletteChangeCount);

                // This is very silly, but we must update this map to
                // the entire DpContext chain...
                // !!![andrewgo] Is this thread safe?
                // !!![andrewgo] Is this stuff cleaned up?
                // !!![andrewgo] This all looks really wrong...

                DpContext* curContext = Context;
                while (curContext != NULL)
                {
                    curContext->PaletteMap = paletteMap;
                    curContext = curContext->Prev;
                }
            }
            else
            {
                bRet = FALSE;
            }
        }

        context->ReleaseHdc(destinationHdc);
    }

    return bRet;
}


/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue and resets it to be empty.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::EmptyBatch()
{
    // Watch out for an empty batch (which can happen with Flush or with 
    // the first allocation of the queue buffer):

    if (BufferCurrent != BufferStart)
    {
        // If we're emptying a non-empty batch, it follows that we
        // should no longer be unsure whether we'll be using DCI or GDI:

        ASSERT(Status != GdiDciStatus_TryDci);

        // Remember where we are in the queue:

        EpScanRecord *bufferStart = BufferStart;
        EpScanRecord *bufferEnd = BufferCurrent;
    
        // Reset the queue before doing anything else, in case whatever
        // we're doing causes us to force a 'surface->Flush()' call
        // (which would re-enter this routine):
    
        BufferCurrent = BufferStart;

        // Use DCI to process the queue if DCI was successfully enabled.
        //
        // On NT we also add the weird condition that we won't invoke
        // DCI if the user is actively moving a window around.  The 
        // reason is that NT is forced to repaint the whole desktop if
        // the Visrgn for any window changes while a DCI primary surface
        // lock is held (this is how NT avoids having something like
        // the Win16Lock, which would let a user-mode app prevent windows
        // from moving, an obvious robustness issue).
        //
        // Note that the 'IsMoveSizeActive' thing is not a fool-proof 
        // solution for avoiding whole-desktop repaints (since there's
        // a chance the user could still move a window while we're 
        // in ProcessBatch_Dci), but as a heuristic it works quite well.
        //
        // To summarize, drop through to GDI rendering codepath if any
        // of the following conditions are TRUE:
        //
        //  ICM required
        //      Thus we must go through GDI to use ICM2.0 support.
        //
        //  DCI disabled
        //      We have no choice but to fallback to GDI.
        //
        //  GDI layering
        //      GDI layering means that GDI is hooking rendering to the
        //      screen and invisibly redirecting output to a backing store.
        //      Thus, the actual rendering surface is inaccessible via DCI
        //      and we must fallback to GDI.
        //
        //  Window move or resize processing
        //      To prevent excessive repainting

        if ((Context->IcmMode != IcmModeOn) && 
            (Context->GdiLayered == FALSE) &&
            (Status == GdiDciStatus_UseDci) && 
            (!Globals::IsMoveSizeActive) &&
            (!Globals::g_fAccessibilityPresent))
        {
            // If the Graphics was derived using an Hwnd, we have to use that
            // to first get an HDC which we can query for clipping.
            //
            // Note that we don't need a 'clean' DC in order to query the
            // clipping, so we don't call GetHdc() if we already have a DC
            // hanging around:

            HDC hdc = Context->Hdc;
            if (Context->Hwnd != NULL)
            {
                hdc = Context->GetHdc(Surface);   
            }                                   

            ProcessBatch_Dci(hdc, bufferStart, bufferEnd);

            if (Context->Hwnd != NULL)
            {
                Context->ReleaseHdc(hdc, Surface);
            }
        }
        else
        {
            // We need a clean DC if we're going to draw using GDI:

            HDC hdc = Context->GetHdc(Surface);

            ProcessBatch_Gdi(hdc, bufferStart, bufferEnd);

            Context->ReleaseHdc(hdc);
        }

        // Reset our bounds.  

        MinX = INT_MAX;
        MinY = INT_MAX;
        MaxX = INT_MIN;
        MaxY = INT_MIN;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes any buffers in the DCI queue.  Note that the DCI queue can
*   be accumulated over numerous API calls without flushing, which forces
*   us to expose a Flush mechanism to the application.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::Flush()
{
    // Note that we might be called to Flush even before we've
    // initialized DCI:

    EmptyBatch();
}

/**************************************************************************\
*
* Function Description:
*
*   Ends the previous buffer (if there was one), and returns the
*   next buffer for doing a SrcOver blend.
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID *EpScanGdiDci::NextBuffer(
    INT x,
    INT y,
    INT nextWidth,
    INT currentWidth,
    INT blenderNum
    )
{
    ASSERT(nextWidth >= 0);
    ASSERT(currentWidth >= 0);

    // Avoid pointer aliasing by loading up a local copy:

    EpScanRecord *bufferCurrent = BufferCurrent;

    // The first call that a drawing routine makes to us always has
    // a 'currentWidth' of 0 (since it doesn't have a 'current'
    // buffer yet):

    if (currentWidth != 0)
    {
        // Accumulate the bounds using the final, completed scan:

        INT xCurrent = bufferCurrent->X;
        MinX = min(MinX, xCurrent);
        MaxX = max(MaxX, xCurrent + currentWidth);

        INT yCurrent = bufferCurrent->Y;
        MinY = min(MinY, yCurrent);
        MaxY = max(MaxY, yCurrent);

        // Complete the previous scan request.

        // Now that we know how much the caller actually wrote into
        // the buffer, update the width in the old record and advance
        // to the next:

        bufferCurrent->Width = currentWidth;
                
        bufferCurrent = bufferCurrent->NextScanRecord(
            GetPixelFormatSize(
                BlenderConfig[bufferCurrent->BlenderNum].SourcePixelFormat
            ) >> 3
        );

        // Don't forget to update the class version:

        BufferCurrent = bufferCurrent;
    }

    // From here on, the code is operating on the current scan request
    // I.e. bufferCurrent applies to the current scan - it has been updated
    // and no longer refers to the last scan.
    
    // See if there's room in the buffer for the next scan:

    // bufferCurrent is not initialized for this scan yet, so we can't rely
    // on it having a valid PixelFormat - we need to get the PixelFormat
    // from the context of the call.

    PixelFormatID pixFmt = BlenderConfig[blenderNum].SourcePixelFormat;

    EpScanRecord* scanEnd = EpScanRecord::CalculateNextScanRecord(
        bufferCurrent,
        BlenderConfig[blenderNum].ScanType,
        nextWidth,
        GetPixelFormatSize(pixFmt) >> 3
    );

    if (scanEnd > BufferEnd)
    {
        EmptyBatch();

        // Reload our local variable:

        bufferCurrent = BufferCurrent;
    }

    // Remember the x and y for the brush offset (halftone & dither).
    // Note: We do not have to remember x and y in CurrentX and CurrentY
    // because we remember them in bufferCurrent (below).
    // CurrentX = x;
    // CurrentY = y;
    
    // Initialize the bufferCurrent.
    // We initialize everything except the width - which we don't know till
    // the caller is done and we get called for the subsequent scan.
    
    bufferCurrent->SetScanType(BlenderConfig[blenderNum].ScanType);
    bufferCurrent->SetBlenderNum(blenderNum);
    bufferCurrent->X = x;
    bufferCurrent->Y = y;
    bufferCurrent->OrgWidth = nextWidth;
   
    // Note: we don't actually use LastBlenderNum in the EpScanGdiDci
    // See EpScanEngine for a class that uses it.
    // LastBlenderNum = blenderNum;
    
    return bufferCurrent->GetColorBuffer();
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer for this API call.
*   Note that this does not force a flush of the buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::End(
    INT updateWidth
    )
{
    // Get the last record into the queue:

    NextBuffer(0, 0, 0, updateWidth, 0);

    // Note that we do not flush the buffer here for DCI!  This is VERY 
    // INTENDED, to allow spans to be batched across primitives.  In fact, 
    // THAT'S THE WHOLE POINT OF THE BATCHING!

    // !!![andrewgo] Actually, our scan architecture needs to be fixed
    //               to allow this for the GDI cases too.  If I don't
    //               flush here for the GDI case, we die running
    //               Office CITs in Graphics::GetHdc when we do the
    //               EmptyBatch, because there's a stale Context in 
    //               the non-empty batch buffer from previous drawing
    //               that didn't get flushed on ~GpGraphics because
    //               the driver didn't pass the Flush through to the
    //               scan class!

    // if (Status != GdiDciStatus_UseDci)
    {
        EmptyBatch();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for all GDI/DCI drawing.  
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanGdiDci::EpScanGdiDci(GpDevice *device, BOOL tryDci)
{
    Device = device;
    Status = (tryDci) ? GdiDciStatus_TryDci : GdiDciStatus_UseGdi;

    Context = NULL;
    Surface = NULL;

    BufferSize = 0;
    BufferMemory = NULL;
    BufferCurrent = NULL;
    BufferStart = NULL;
    BufferEnd = NULL;
    CacheRegionHandle = NULL;
    CacheRegionData = NULL;
    CacheDataSize = 0;

    MinX = INT_MAX;
    MinY = INT_MAX;
    MaxX = INT_MIN;
    MaxY = INT_MIN;

    BatchOffsetX = 0;
    BatchOffsetY = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor for the GDI/DCI interface.  Typically only called when
*   the 'device' is destroyed.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanGdiDci::~EpScanGdiDci()
{
    if (Status == GdiDciStatus_UseDci)
    {
        // DciDestroy doesn't do anything if 'DciSurface' is NULL:

        Globals::DciDestroyFunction(DciSurface);
    }

    DeleteObject(CacheRegionHandle);
    GpFree(CacheRegionData);
    GpFree(BufferMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scandib.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal output banding class for use with printing.
*
*   This class supports two major forms of DIB banding.  Both are useful
*   when printing.
*  
*      1. Output at a 'capped DPI' either 32bpp or 24bpp.
*      2. Output at a 'device DPI' only the alpha channel.
*
* Revision History:
*
*   07/26/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef __SCANDIB_HPP
#define __SCANDIB_HPP

// Internally generate a bottom up DIB
#define PRINT_BOTTOM_UP 1

enum ScanDIBOptions
{     
    ScanCappedBounds    = 0x00000001,     // allocate 24bpp buffer at capped size
    ScanDeviceBounds    = 0x00000002,     // allocate 1bpp mask at device size
    ScanCapped32bpp     = 0x00000004,     // otherwise the default is 24bpp
    ScanCapped32bppOver = 0x00000008,     // otherwise the default is 24bpp
    ScanCappedOver      = 0x00000010,     // do whiteness source over on 24bpp
    ScanDeviceZeroOut   = 0x00000020,     // zero out 0's in capped buffer when
                                          // generating 0's in alpha mask buffer
                                          // !! ONLY if dev/cap is integer.
    ScanDeviceAlpha     = 0x00000040,     // generate alpha vs. opaque 1bpp mask
    ScanBleedOut        = 0x00000080,     // bleed color data
    
    ScanDeviceFlags     = ScanDeviceAlpha | ScanDeviceZeroOut | ScanDeviceBounds,
    ScanCappedFlags     = ScanCappedBounds | ScanCapped32bpp | ScanCappedOver |
                          ScanCapped32bppOver
};

class EpScanDIB : public EpScan
{
private:
   GpRect     CappedBounds;      // bounds at capped DPI (24bpp)
   GpRect     DeviceBounds;      // bounds at device DPI (1bpp)

   INT        CappedStride;

   GpPoint    MinBound;
   GpPoint    MaxBound;
   
   INT        ScaleX;
   INT        ScaleY;

   // Last output scan operation
   INT        OutputX, OutputY, OutputWidth, OutputBleed, OutputLastY;
   
   // 32bpp/24bpp DIB section
   BYTE*      BufStart; 
   ARGB*      Buf32bpp;
   ARGB*      CurBuffer;
   struct {
       BITMAPINFO BMI;
       RGBQUAD rgbQuad[4];
   } Buf;
   
   // Transparency mask
   BYTE*      MaskStart;
   INT        MaskStride;        // # of bytes in one stride
   struct {
       BITMAPINFO BMI;
       RGBQUAD rgbQuad[4];
   } Mask;

   // pointer to 32bpp scanline which we halftone FROM into the 1bpp mask above
   ARGB*      AlphaStart;

   // array for keeping count for zeroing out scans of capped image
   BYTE*      ZeroStart;

   NEXTBUFFERFUNCTION NextBuffer;
   DWORD      ScanOptions;
   BOOL       RenderAlpha;
   BOOL       Rasterizing;

   // padding of pixels that we don't zeroout.
   INT        ZeroOutPad;

private:
    // output at capped dpi at 32bpp
    VOID *NextBufferFunc32bpp(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 32bpp
    VOID *NextBufferFunc32bppOver(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp
    VOID *NextBufferFunc24bpp(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp
    VOID *NextBufferFunc24bppBleed(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp, does implicit alpha blend on white 
    // surface
    VOID *NextBufferFunc24bppOver(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
                                       
    // output alpha mask at device dpi at 1bpp
    VOID *NextBufferFuncAlpha(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output opaque mask at device dpi at 1bpp
    VOID *NextBufferFuncOpaque(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
    // doesn't output a mask, but zero's out clipped portions of 24bpp DIB
    VOID *NextBufferFuncZeroOut(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
public:
    EpScanDIB();

    ~EpScanDIB() {}

    virtual BOOL Start(
        DpDriver *driver, 
        DpContext *context, 
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *nextBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );
    
    VOID End(INT updateWidth);

    VOID Flush();

    // ARGB buffer
    BYTE *GetStartBuffer()
    {
        return BufStart;
    }

    BITMAPINFO *GetBufferBITMAPINFO()
    {
        return &Buf.BMI;
    }

    DWORD GetBufferStride()
    {
        return CappedStride;
    }

    // Mask Buffer
    BYTE *GetMaskBuffer()
    {
        return MaskStart;
    }

    DWORD GetMaskStride()
    {
        return MaskStride;
    }

    BITMAPINFO *GetMaskBITMAPINFO()
    {
         return &Mask.BMI;
    }
    
    VOID *GetCurrentBuffer() 
    {
        return CurBuffer;
    }
    
    virtual BYTE* GetCurrentCTBuffer() 
    { 
        // Since this class is meant for printers, higher-level
        // code should prevent us from getting here.
        // GpGraphics::GetTextRenderingHintInternal() guards against this.
        
        ASSERT(FALSE);
        return NULL;
    }

    DWORD GetOptions() 
    {
        return ScanOptions;
    }

    BOOL GetActualBounds(GpRect *rect);

    VOID SetRenderMode(BOOL RenderAlpha, GpRect* newBounds);
    
    // Allocate DIB and monochrome DIB memory
    GpStatus CreateBufferDIB(const GpRect* boundsCap,
                             const GpRect* boundsDev,
                             DWORD scanDIBOptions,
                             INT scaleX,
                             INT scaleY);

    VOID DestroyBufferDIB();

    INT GetZeroOutPad()
    {
        return ZeroOutPad;
    }

    VOID SetZeroOutPad(INT pad)
    {
        ASSERT(pad >= 0);
        ZeroOutPad = pad;
    }

    VOID ResetZeroOutPad()
    {
        ZeroOutPad = 2;
    }

#if 0
    // create 1bpp monochrome mask of DIB
    GpStatus CreateAlphaMask();

    // create simple opaque monochrome mask of DIB (alpha>0 => opaque)
    GpStatus CreateOpaqueMask();    // not used
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scanoperation.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   Definitions for the ScanOperation namespace.
*
* Notes:
*
*   EpAlphaBlender, EpFormatConverter, and the scan operations, all use the
*   idea of the "closest" canonical format to a particular format.
*   We define this as follows: If the format is not extended,
*   the closest canonical format is sRGB. Otherwise, it's sRGB64.
*
* Revision History:
*
*   01/04/2000 agodfrey
*     Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace ScanOperation
{
    /**************************************************************************\
    *
    * Operations which copy pixels, preserving the pixel format.
    *
    \**************************************************************************/
    
    ScanOpFunc CopyOps[PIXFMT_MAX] =
    {
        NULL,           // PIXFMT_UNDEFINED
        Copy_1,         // PIXFMT_1BPP_INDEXED
        Copy_4,         // PIXFMT_4BPP_INDEXED
        Copy_8,         // PIXFMT_8BPP_INDEXED
        Copy_16,        // PIXFMT_16BPP_GRAYSCALE
        Copy_16,        // PIXFMT_16BPP_RGB555
        Copy_16,        // PIXFMT_16BPP_RGB565
        Copy_16,        // PIXFMT_16BPP_ARGB1555
        Copy_24,        // PIXFMT_24BPP_RGB
        Copy_32,        // PIXFMT_32BPP_RGB
        Copy_32,        // PIXFMT_32BPP_ARGB
        Copy_32,        // PIXFMT_32BPP_PARGB
        Copy_48,        // PIXFMT_48BPP_RGB
        Copy_64,        // PIXFMT_64BPP_ARGB
        Copy_64,        // PIXFMT_64BPP_PARGB
        Copy_24         // PIXFMT_24BPP_BGR
    };
    
    /**************************************************************************\
    *
    * Operations which convert into the closest canonical format.
    *
    \**************************************************************************/
    
    ScanOpFunc ConvertIntoCanonicalOps[PIXFMT_MAX] =
    {
        NULL,                  // PIXFMT_UNDEFINED
        Convert_1_sRGB,        // PIXFMT_1BPP_INDEXED
        Convert_4_sRGB,        // PIXFMT_4BPP_INDEXED
        Convert_8_sRGB,        // PIXFMT_8BPP_INDEXED
        NULL, // !!! TODO      // PIXFMT_16BPP_GRAYSCALE
        Convert_555_sRGB,      // PIXFMT_16BPP_RGB555
        Convert_565_sRGB,      // PIXFMT_16BPP_RGB565
        Convert_1555_sRGB,     // PIXFMT_16BPP_ARGB1555
        Convert_24_sRGB,       // PIXFMT_24BPP_RGB
        Convert_32RGB_sRGB,    // PIXFMT_32BPP_RGB
        Copy_32,               // PIXFMT_32BPP_ARGB
        AlphaDivide_sRGB,      // PIXFMT_32BPP_PARGB
        Convert_48_sRGB64,     // PIXFMT_48BPP_RGB
        Copy_64,               // PIXFMT_64BPP_ARGB
        AlphaDivide_sRGB64,    // PIXFMT_64BPP_PARGB
        Convert_24BGR_sRGB     // PIXFMT_24BPP_BGR
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scandib.cpp ===
/**************************************************************************\
*  
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal scan class.
*   Use ARGB buffer for all scan drawing, and Blt to destination when done.
*
* Revision History:
*
*   07/26/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#ifdef DBGALPHA
const ULONG gDebugAlpha = 0;
#endif

#define ALPHA_BYTE_INDEX 3
#define SRC_PIX_SIZE 4

#define RoundDWORD(x) (x + ((x%sizeof(DWORD))>0?(sizeof(DWORD)-(x%sizeof(DWORD))):0))
#define IsInteger(x) (GpFloor(x) == x)

static int TranslateHTTable = 0;

EpScanDIB::EpScanDIB() :
   BufStart(NULL),
   CurBuffer(NULL),
   MaskStart(NULL),
   AlphaStart(NULL),
   OutputWidth(-1),
   OutputBleed(0),
   NextBuffer(NULL),
   ZeroOutPad(2)
{
}

/**************************************************************************\
*
* Function Description:
*
*   Starts a scan.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [IN] compositeMode - Alpha blend mode
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

BOOL
EpScanDIB::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer, 
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );    
    
    // Printer surfaces don't have an alpha channel.
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    *nextBuffer = NextBuffer;
    ASSERT(NextBuffer != NULL);

    // !! Add more asserts for valid state.
    OutputX = -1;
    OutputY = -1;
    OutputWidth = -1;
    OutputBleed = -1;
    Rasterizing = TRUE;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID 
EpScanDIB::End(INT updateWidth)
{
    // it is the driver's job to decide what to do with us and they
    // MUST call ReleaseBuffer() as appropriate

    // Flush the last scan... This is always required, since at the very
    // least, we unpremultiply the scan line.

    Rasterizing = FALSE;

    if (RenderAlpha)
    {
        if (!(ScanOptions & ScanDeviceZeroOut))
        {
            (this->*NextBuffer)(
                DeviceBounds.X + DeviceBounds.Width,
                DeviceBounds.Y + DeviceBounds.Height, 
                0, 
                updateWidth,
                0
            );
        }
        else if (OutputWidth > 0)
        {
            // we must flush the last zeroArray.
            BYTE* bitsPtr = BufStart + CappedStride * 
              ((CappedBounds.Height-1) - ((OutputY/ScaleY) - CappedBounds.Y));
            DWORD* zeroPtr = (DWORD*) ZeroStart;

            INT count = CappedBounds.Width;
            while (count--)
            {
                if (*zeroPtr++ == 0)
                { 
                    *bitsPtr++ = '\0';
                    *bitsPtr++ = '\0';
                    *bitsPtr++ = '\0';
                }
                else
                {
                    bitsPtr += 3;
                }
            }
        }
    }
    else
    {
        (this->*NextBuffer)(
            CappedBounds.X + CappedBounds.Width,
            CappedBounds.Y + CappedBounds.Height, 
            0, 
            updateWidth,
            0
        );
    }

    // Ensure we don't flush if we're called on another band
    OutputWidth = -1;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc32bpp - Handles output when we are rasterizing at capped
*                       dpi to a 32bpp unpremultiplied DIB
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc32bpp(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && (ScanOptions & ScanCapped32bpp));

    // !! Remove this when we standardize on unpremultiplied
#if 1
    if (OutputWidth > 0) 
    {
        while (OutputWidth--) 
        {
            // unpremultiply
            *CurBuffer = Unpremultiply(*CurBuffer);
            CurBuffer++;
        }
    }

    OutputWidth = newWidth;
#endif

    // return pointer directly into our 32bpp buffer
    return (CurBuffer = (((ARGB*)BufStart) + 
                         ((CappedBounds.Height - 1) - (y - CappedBounds.Y)) * 
                             CappedBounds.Width +
                         (x - CappedBounds.X)));
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc32bppOver - Handles output when we are rasterizing at capped
*                           DPI to a 32bpp unpremultiplied DIB.  Blends any
*                           alpha with background WHITENESS.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc32bppOver(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && (ScanOptions & ScanCapped32bppOver));

    // !! Remove this when we standardize on unpremultiplied
#if 1
    if (OutputWidth > 0) 
    {
        while (OutputWidth--) 
        {
            // An adaptation of the blending code from Andrew Godfrey's 
            // BlendOver function, but onto a white surface.  This is done to
            // improve the output quality of postscript.

            GpColor color(*CurBuffer);
            UINT32 alpha = color.GetAlpha();
            
            UINT32 alphaContrib;
            
            if (alpha == 0) 
            {
                *CurBuffer++ = 0x00FFFFFF;
            }
            else if (alpha == 255)
            {
                CurBuffer++;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst
                UINT32 multA = 255 - alpha;
          
                UINT32 D1_000000FF = 0xFF;
                UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
                UINT32 D3_000000FF = (D2_0000FFFF & 0x0000ff00) >> 8;
                UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
           
                alphaContrib = D4_0000FF00 >> 8;
            
                // store: (1-alpha)*0xFF + color for each B, G, R
                *CurBuffer++ = ((DWORD)(alphaContrib + color.GetBlue()) << GpColor::BlueShift) |
                               ((DWORD)(alphaContrib + color.GetGreen()) << GpColor::GreenShift) |
                               ((DWORD)(alphaContrib + color.GetRed()) << GpColor::RedShift) |
                               (alpha << GpColor::AlphaShift);
            }
        }
    }

    OutputWidth = newWidth;
#endif

    // return pointer directly into our 32bpp buffer
    return (CurBuffer = (((ARGB*)BufStart) + 
                         ((CappedBounds.Height - 1) - (y - CappedBounds.Y)) * 
                             CappedBounds.Width +
                         (x - CappedBounds.X)));
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bpp - Handles output when we are rasterizing at capped
*                       dpi to a 24bpp unpremultiplied DIB.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bpp(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && !(ScanOptions & ScanCapped32bpp));

    if (OutputWidth > 0) 
    {
        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputX - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        ARGB* srcPos = Buf32bpp;

        while (OutputWidth--) 
        {
            // convert from 32 ARGB to 24bpp RGB
#if 1
            // !! Remove this when we standardize on non-premultiplied
            GpColor color(Unpremultiply(*srcPos++));
#else
            GpColor color(*srcPos++);
#endif
            // NOTICE: Bytes are stored as Blue, Green, Red.
            *dstPos++ = (BYTE)color.GetBlue();
            *dstPos++ = (BYTE)color.GetGreen();
            *dstPos++ = (BYTE)color.GetRed();
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bppBleed - Handles output when we are rasterizing at capped
*                            dpi to a 24bpp unpremultiplied DIB.  It bleeds
*                            the output to left and right of the scanned area.
*                            This prevents black jaggies from appearing in the
*                            output.
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bppBleed(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && 
           !(ScanOptions & ScanCapped32bpp) &&
           (ScanOptions & ScanBleedOut));

    if (OutputWidth > 0) 
    {
        ARGB* srcPos = Buf32bpp;
        GpColor color(Unpremultiply(*srcPos));

        if ((OutputLastY == -1) && ((OutputY-CappedBounds.Y) != 0))
        {
            // Bleed up all previous subsequent scan lines.
            // compute destination location into 24bpp buffer
            BYTE* clearPos = BufStart + CappedStride * (CappedBounds.Height - 
                                 (OutputY - CappedBounds.Y));
            INT capHeight = OutputY - CappedBounds.Y;

            for (int cntY=0; cntY<capHeight; cntY++)
            {
                for (int cntX=0; cntX<CappedBounds.Width; cntX++)
                {
                    clearPos[cntX*3] = (BYTE)color.GetBlue();
                    clearPos[cntX*3+1] = (BYTE)color.GetGreen();
                    clearPos[cntX*3+2] = (BYTE)color.GetRed();
                }
                clearPos += CappedStride;
            }
        }

        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputBleed - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        
        // Bleed to the left
        INT count = OutputBleed;
        while (count++ < OutputX) 
        {
            *dstPos++ = (BYTE)color.GetBlue();
            *dstPos++ = (BYTE)color.GetGreen();
            *dstPos++ = (BYTE)color.GetRed();
        }

        // Output source pixels into destination surface
        count = OutputWidth;
        while (count--) 
        {
            // convert from 32 ARGB to 24bpp RGB
            GpColor refColor = color;                  // save last ARGB color

            color.SetValue(Unpremultiply(*srcPos++));
            
            // NTRAID#NTBUG9-436131-2001-07-13-jerryste "P1CD: Printing:When printing the image, noise will appear in the surrounding of the image." 
            // Real problem: color bitmap and scaled-up alpha mask misalignment. halftoned low-alpha region let black see through

            // Problems in DriverPrint::DrawImage
            //           1) Calculation of boundsCap in integers has rounding error
            //           2) Low level scanline rendering code offset coordinates by 0.5 before rounding
            //           3) Scale integer version of boundsCap to boundsDev introduces more error
            //           4) Single precision floating-point number calculation can lose precision 

            // We do not have a clean way to fix the real problem for the moment (7/28/01).

            // Workaround: Change color to (white+neighbour)/2 when alpha is low to remove black pixels. Neighbor is
            // either the previous pixel, or the next pixel if the previous pixel has a small alpha
            
            const BYTE smallalpha = 10;

            if ( color.GetAlpha()<smallalpha )                              // if alpha is low
            {
                if ( ( refColor.GetAlpha()<smallalpha) && (count!=0) )      // if previous pixel has small alpha and there is next pixel
                    refColor.SetValue(Unpremultiply(*srcPos));              // use next pixel 
                
                if ( refColor.GetAlpha()>=smallalpha )
                {
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetBlue() )  / 2 );   // blend with white
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetGreen() ) / 2 );
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetRed() )   / 2 );
                }
                else
                {
                    *dstPos++ = 255;                                    // set to white
                    *dstPos++ = 255;
                    *dstPos++ = 255;
                }
            }
            else
            {
                *dstPos++ = (BYTE)color.GetBlue();
                *dstPos++ = (BYTE)color.GetGreen();
                *dstPos++ = (BYTE)color.GetRed();
            }
        }

        // Bleed to the right
        if (y != OutputY)
        {
            count = CappedBounds.X + CappedBounds.Width - OutputX - OutputWidth;
            while (count--)
            {
                *dstPos++ = (BYTE)color.GetBlue();
                *dstPos++ = (BYTE)color.GetGreen();
                *dstPos++ = (BYTE)color.GetRed();
            }
        }
        
        // Bleed down all subsequent scan lines.  This should only happen when called
        // implicitly by EpScanDIB::End()
        if ((newWidth == 0) && 
            (x == CappedBounds.X + CappedBounds.Width) &&
            (y == CappedBounds.Y + CappedBounds.Height) &&
            (OutputY != 0))
        {
            // Bleed down all previous subsequent scan lines.
            // compute destination location into 24bpp buffer
            BYTE* clearPos = BufStart;
            INT capHeight = (CappedBounds.Height - 1) - (OutputY - CappedBounds.Y);

            for (int cntY=0; cntY<capHeight; cntY++)
            {
                for (int cntX=0; cntX<CappedBounds.Width; cntX++)
                {
                    clearPos[cntX*3] = (BYTE)color.GetBlue();
                    clearPos[cntX*3+1] = (BYTE)color.GetGreen();
                    clearPos[cntX*3+2] = (BYTE)color.GetRed();
                }
                clearPos += CappedStride;
            }
        }
    }

    // Compute size of bleed scan range
    if (y == OutputY) 
    {
        ASSERT(x >= OutputX + OutputWidth);

        OutputBleed = OutputX + OutputWidth;
    }
    else
    {
        OutputBleed = CappedBounds.X;
    }

    OutputLastY = OutputY;

    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bppOver - Handles output when we are rasterizing at capped
*                           dpi to a 24bpp unpremultiplied DIB.  We do an
*                           implicit blend onto a white opaque surface.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bppOver(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && 
           !(ScanOptions & ScanCapped32bpp) &&
           (ScanOptions & ScanCappedOver));

    if (OutputWidth > 0) 
    {
        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputX - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        ARGB* srcPos = Buf32bpp;

        while (OutputWidth--) 
        {
            // An adaptation of the blending code from Andrew Godfrey's 
            // BlendOver function, but onto a white surface.  This is done to
            // improve the output quality of postscript.

            GpColor color(*srcPos++);
            UINT32 alpha = color.GetAlpha();
            
            UINT32 alphaContrib;
            
            if (alpha == 0) 
            {
                *dstPos++ = 0xFF;
                *dstPos++ = 0xFF;
                *dstPos++ = 0xFF;
            }
            else if (alpha == 255)
            {
                *dstPos++ = color.GetBlue();
                *dstPos++ = color.GetGreen();
                *dstPos++ = color.GetRed();
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst
                UINT32 multA = 255 - alpha;
          
                UINT32 D1_000000FF = 0xFF;
                UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
                UINT32 D3_000000FF = (D2_0000FFFF & 0x0000ff00) >> 8;
                UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
           
                alphaContrib = D4_0000FF00 >> 8;
            
                // convert from 32 ARGB to 24bpp RGB
                // store: (1-alpha)*0xFF + color for each B, G, R
                *dstPos++ = (BYTE)(alphaContrib + color.GetBlue());
                *dstPos++ = (BYTE)(alphaContrib + color.GetGreen());
                *dstPos++ = (BYTE)(alphaContrib + color.GetRed());
            }
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncAlpha - Handles output when we are rasterizing at device
*                       dpi to a 1bpp mask, we generate the mask on the fly
*                       using DonC's halftoning table.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncAlpha(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT((ScanOptions & ScanDeviceBounds) && (ScanOptions & ScanDeviceAlpha));

    if (OutputWidth > 0) 
    {
        // update bounding box for this band
        if (OutputX < MinBound.X) MinBound.X = OutputX;
        if (OutputY < MinBound.Y) MinBound.Y = OutputY;
        if ((OutputX + OutputWidth) > MaxBound.X) MaxBound.X = OutputX + OutputWidth;
        if (OutputY > MaxBound.Y) MaxBound.Y = OutputY;
        
        INT startX = OutputX - DeviceBounds.X;
        INT endX = startX + OutputWidth;
        
        // !! Shift '91' into some global constant!?!
        INT orgX = OutputX % 91;
        INT orgY = (OutputY + TranslateHTTable) % 91;
        INT htIndex = orgY*91 + orgX;

        // compute destination location into 24bpp buffer
#ifdef PRINT_BOTTOM_UP
        BYTE* dstPos = MaskStart +
                       MaskStride * ((DeviceBounds.Height - 1) - 
                                     (OutputY - DeviceBounds.Y)) + (startX >> 3);
#else
        BYTE* dstPos = MaskStart +
                       MaskStride * (OutputY - DeviceBounds.Y) + (startX >> 3);
#endif
        ARGB* srcPos = AlphaStart;

        BYTE outByte = 0;

        // using FOR loop makes it easier to detect relative bit position
        for (INT xPos = startX; xPos < endX; xPos++)
        {
            GpColor color(*srcPos++);
            
            INT maskBit = color.GetAlpha() >
                              HT_SuperCell_GreenMono[htIndex++] ? 1 : 0;
            
            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0)
               *dstPos++ |= outByte;

            if (++orgX >= 91) 
            {
                orgX = 0;
                htIndex = orgY*91;
            }
        }
        
        // output the last partial byte
        if ((xPos % 8) != 0) 
        {
            *dstPos |= outByte << (8 - (xPos % 8));
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncOpaque - Handles output when we are rasterizing at device
*                       dpi to a 1bpp opaque mask (1 if alpha > 0, 0 otherwise)
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncOpaque(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT((ScanOptions & ScanDeviceBounds) && !(ScanOptions & ScanDeviceAlpha));
    
    if (OutputWidth > 0) 
    {
        // update bounding box for this band
        if (OutputX < MinBound.X) MinBound.X = OutputX;
        if (OutputY < MinBound.Y) MinBound.Y = OutputY;
        if ((OutputX + OutputWidth) > MaxBound.X) MaxBound.X = OutputX + OutputWidth;
        if (OutputY > MaxBound.Y) MaxBound.Y = OutputY;
        
        INT startX = OutputX - DeviceBounds.X;
        INT endX = startX + OutputWidth;
        
        // compute destination location into 24bpp buffer
        BYTE* dstPos = MaskStart +
                       MaskStride * ((DeviceBounds.Height - 1) -
                                  (OutputY - DeviceBounds.Y)) + (startX >> 3);
        ARGB* srcPos = AlphaStart;

        BYTE outByte = 0;

        // using FOR loop makes it easier to detect relative bit position
        for (INT xPos = startX; xPos < endX; xPos++)
        {
            GpColor color(*srcPos++);
            
            INT maskBit = (color.GetAlpha() == 0) ? 0 : 1;
            
            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0)
                *dstPos++ |= outByte;
        }
        
        // output the last partial byte
        if ((xPos % 8) != 0) 
        {
            *dstPos |= outByte << (8 - (xPos % 8));
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncZeroOut - Handles output where we aren't rasterizing to a 
*                         DIB section, but only zeroing out portions of the
*                         the original 24bpp bitmap
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/10/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncZeroOut(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT(!(ScanOptions & ScanDeviceBounds) && !(ScanOptions & ScanDeviceAlpha)
           && !(ScanOptions & (ScanCapped32bpp | ScanCapped32bppOver))
           && (ScanOptions & ScanDeviceZeroOut));

    ASSERT(ZeroOutPad >= 0);
    
    // THIS IS AN IMPORTANT CONDITION.  If it's untrue, then we may fail to
    // generate proper masks in some cases.  Also causes problems in zeroing out.
    ASSERT(y>=OutputY);

    if (newWidth > 0) 
    {
        // update bounding box for this band
        if (x < MinBound.X) 
        {
            MinBound.X = x;
        }
        if (y < MinBound.Y) 
        {
            MinBound.Y = y;
        }
        if ((x + newWidth) > MaxBound.X) 
        {
            MaxBound.X = x + newWidth;
        }
        if (y > MaxBound.Y) 
        {
            MaxBound.Y = y;
        }
    }

    if (OutputWidth < 0) 
    {
        OutputX = x;
        OutputY = y;
    }

    if ((y/ScaleY) != (OutputY/ScaleY)) 
    {
        // tally counts and zero out
        BYTE* bitsPtr = BufStart + CappedStride * 
                                          ((CappedBounds.Height - 1) -
                                          ((OutputY/ScaleY) - CappedBounds.Y));
        DWORD* zeroPtr = (DWORD*) ZeroStart;

        INT count = CappedBounds.Width;
        while (count--)
        {
            if (*zeroPtr++ == 0)
            {
                *bitsPtr++ = '\0';
                *bitsPtr++ = '\0';
                *bitsPtr++ = '\0';
            }
            else
            {
                bitsPtr += 3;
            }
        }

        ZeroMemory(ZeroStart, (CappedBounds.Width+ZeroOutPad)*sizeof(DWORD));
    }

    // bleed the color ZeroOutPad pixels to left and right
    INT xPos = (x/ScaleX) - CappedBounds.X;
    INT count = (newWidth/ScaleX) + ((newWidth % ScaleX) ? 1 : 0) + 1;

    // Calculate how many pixels on the left we can pad
    INT subtract = min(xPos, ZeroOutPad);
    if (subtract > 0)
    {
        xPos -= subtract;
        count += subtract;
    }

    count = min(count+ZeroOutPad, CappedBounds.Width + ZeroOutPad - xPos);

    DWORD *zeroPtr = ((DWORD*)ZeroStart) + xPos;
    ASSERT((xPos+count) <= CappedBounds.Width + ZeroOutPad);
    while (count--) 
    {
        *zeroPtr += 1;
        zeroPtr++;
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
*   Sets the bounds of the current scan.
*
* Arguments:
*
*   [IN] bounds - the bounds.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID EpScanDIB::SetRenderMode(
    BOOL renderAlpha,
    GpRect *newBounds
    )
{
    RenderAlpha = renderAlpha;

    MinBound.X = INFINITE_MAX;
    MinBound.Y = INFINITE_MAX;
    MaxBound.X = INFINITE_MIN;
    MaxBound.Y = INFINITE_MIN;

    if (RenderAlpha)
    {
        DeviceBounds = *newBounds;
        
        ZeroMemory(AlphaStart, DeviceBounds.Width * sizeof(ARGB));
        
        if (ScanOptions & ScanDeviceBounds) 
        {
            ZeroMemory(MaskStart, MaskStride * DeviceBounds.Height);

            if (ScanOptions & ScanDeviceAlpha) 
            {
                NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncAlpha;
            }
            else
            {
                NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncOpaque;
            }
        }
        else
        {
            ASSERT(ScanOptions & ScanDeviceZeroOut);
            ASSERT(!(ScanOptions & (ScanCapped32bpp | ScanCapped32bppOver)));
            
            ZeroMemory(ZeroStart, (CappedBounds.Width + ZeroOutPad)*sizeof(DWORD));
            NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncZeroOut;
        }
        
        CurBuffer = AlphaStart;
    }
    else
    {
        CappedBounds = *newBounds;

        if (ScanOptions & ScanCapped32bpp)
        {
            ZeroMemory(BufStart, CappedBounds.Width
                       * CappedBounds.Height * sizeof(ARGB));
            NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc32bpp;
        }
        else if (ScanOptions & ScanCapped32bppOver)
        {
            ZeroMemory(BufStart, CappedBounds.Width
                       * CappedBounds.Height * sizeof(ARGB));
            NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc32bppOver;
        }
        else
        {
            ASSERT(CappedStride != 0);
            
            ZeroMemory(BufStart, CappedStride * CappedBounds.Height);

            if (ScanOptions & ScanCappedOver) 
            {
                NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bppOver;
            }
            else
            {
                if (ScanOptions & ScanBleedOut) 
                {
                    NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bppBleed;
                }
                else
                {
                    NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bpp;
                }
            }
            CurBuffer = Buf32bpp;
        }
    }

    OutputWidth = -1;
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes the current scan.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID 
EpScanDIB::Flush()
{
}

/**************************************************************************\
*
* Function Description:
*
*   Resets the DIBSection buffer, safely releasing resources and resetting
*   them.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/26/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID
EpScanDIB::DestroyBufferDIB()
{
    if (BufStart != NULL) 
    {
        GpFree(BufStart);
    }

    if (AlphaStart != NULL)
    {
        GpFree(AlphaStart);
    }

    BufStart    = NULL;
    Buf32bpp    = NULL;
    CurBuffer   = NULL;

    // Transparency mask
    MaskStart   = NULL;

    // Alpha buffer
    AlphaStart  = NULL;
    ZeroStart   = NULL;
    RenderAlpha = FALSE;
    ScanOptions = 0;
    OutputWidth = -1;

    NextBuffer = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   In pre-multiplies an ARGB value
*
* Arguments:
*
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
EpScanDIB::CreateBufferDIB(
    const GpRect* BoundsCap,
    const GpRect* BoundsDev,
    DWORD options,
    INT scaleX,
    INT scaleY)
{
    ScanOptions = options;
    CappedBounds = *BoundsCap;
    DeviceBounds = *BoundsDev;

    ScaleX = scaleX;
    ScaleY = scaleY;

    if (options & ScanCappedBounds) 
    {
        ZeroMemory(&Buf.BMI, sizeof(Buf.BMI));
   
        Buf.BMI.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        Buf.BMI.bmiHeader.biWidth       =  CappedBounds.Width;
        Buf.BMI.bmiHeader.biHeight      = CappedBounds.Height;
        Buf.BMI.bmiHeader.biPlanes      = 1;
    
        if (options & (ScanCapped32bpp | ScanCapped32bppOver)) 
        {
            RGBQUAD red = { 0, 0, 0xFF, 0}; // red
            RGBQUAD green = { 0, 0xFF, 0, 0}; // green
            RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

            Buf.BMI.bmiColors[0] = red;
            Buf.BMI.bmiColors[1] = green;
            Buf.BMI.bmiColors[2] = blue;
            
            Buf.BMI.bmiHeader.biBitCount = 32;
            Buf.BMI.bmiHeader.biCompression = BI_BITFIELDS;
        }
        else
        {   
            Buf.BMI.bmiHeader.biHeight += 2;
            Buf.BMI.bmiHeader.biBitCount = 24;
            Buf.BMI.bmiHeader.biClrUsed = 0;
            Buf.BMI.bmiHeader.biCompression = BI_RGB;
        }

        if (options & (ScanCapped32bpp | ScanCapped32bppOver)) 
        {
            CappedStride = CappedBounds.Width*sizeof(ARGB);
        }
        else
        { 
            // use extra allocation at the end of DIB for temp 32bpp storage
            CappedStride = RoundDWORD((CappedBounds.Width * 3));
        }

        BufStart = (BYTE*) GpMalloc(CappedStride * 
                                    Buf.BMI.bmiHeader.biHeight);
         
        if (BufStart == NULL)
            return OutOfMemory;

        if (options & (ScanCapped32bpp | ScanCapped32bppOver))
        {
            Buf32bpp = NULL;
        }
        else
        {
            Buf.BMI.bmiHeader.biHeight -= 2;
            Buf32bpp = (ARGB*) (BufStart + CappedStride*CappedBounds.Height);
        }
    }
    else
    {
        BufStart = NULL;
        Buf32bpp = NULL;
    }
   
    if (options & ScanDeviceBounds) 
    {
        ZeroMemory(&Mask.BMI, sizeof(Mask.BMI));
        
        // if we do zeroing out of the capped bitmap, then we require that
        // their sizes be an integer ratio of each other (device>= capped).

        ASSERT(!(options & ScanDeviceZeroOut) ||
               ((options & ScanDeviceZeroOut) &&
                IsInteger((REAL)DeviceBounds.Height/(REAL)CappedBounds.Height) &&
                IsInteger((REAL)DeviceBounds.Width/(REAL)CappedBounds.Width)));

        ASSERT(DeviceBounds.Height > 0);

        Mask.BMI.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        Mask.BMI.bmiHeader.biWidth       = DeviceBounds.Width;
        Mask.BMI.bmiHeader.biHeight      = DeviceBounds.Height;
        Mask.BMI.bmiHeader.biPlanes      = 1;
        Mask.BMI.bmiHeader.biBitCount    = 1;
        Mask.BMI.bmiHeader.biCompression = BI_RGB;

        RGBQUAD opaque = { 0,0,0,0 };
        RGBQUAD transparent = { 0xFF, 0xFF, 0xFF, 0xFF }; 

        Mask.BMI.bmiColors[0] = transparent;
        Mask.BMI.bmiColors[1] = opaque;

        MaskStride = (DeviceBounds.Width - 1) >> 3;
        MaskStride = MaskStride + (sizeof(DWORD) - MaskStride % sizeof(DWORD));
        
        INT AlphaSize = DeviceBounds.Width * sizeof(ARGB);

        AlphaStart = (ARGB*) GpMalloc(MaskStride * DeviceBounds.Height + 
                                      AlphaSize);

        if (AlphaStart == NULL) 
        {
            return OutOfMemory;
        }

        // device space bounds only for alpha channel
        MaskStart = (BYTE*)(AlphaStart) + AlphaSize;
        ASSERT(MaskStart != NULL);

        ZeroStart = NULL;
    }
    else
    {
        MaskStart = NULL;

        if (ScanOptions & ScanDeviceZeroOut)
        {
            // device space bounds only for alpha channel
            AlphaStart = (ARGB*) GpMalloc(DeviceBounds.Width * sizeof(ARGB) +
                                          (CappedBounds.Width+ZeroOutPad) * sizeof(DWORD));
            if (AlphaStart == NULL)
                return OutOfMemory;

            // array for maintaining zero out counts
            ZeroStart = (BYTE*)(AlphaStart + DeviceBounds.Width);
        }
        else
        {
            AlphaStart = NULL;
            ZeroStart = NULL;
        }
    }

    // To prevent bad output when overlapping images have same alpha value
    // we increment our position in the HT Table matrix.
    TranslateHTTable++;
    
    // NOTE: We don't bother filling the monochrome DIB with 0's or 1's
    return Ok;
}

BOOL EpScanDIB::GetActualBounds(GpRect *rect)
{
    if (!(ScanOptions & (ScanDeviceBounds | ScanDeviceZeroOut))) 
    {
        rect->X = 0;
        rect->Y = 0;
        rect->Width = DeviceBounds.Width;
        rect->Height = DeviceBounds.Height;
        return TRUE;
    }

    if (MaxBound.X <= 0) 
    {
        return FALSE;
    }

    ASSERT(MaxBound.X > -1 && MaxBound.Y > -1);

    GpRect tempRect;

    // relative to (0, 0) in device units (not device space)
    tempRect.X = (rect->X = MinBound.X - DeviceBounds.X);
    tempRect.Y = (rect->Y = MinBound.Y - DeviceBounds.Y);
    rect->Width = MaxBound.X - MinBound.X;
    rect->Height = MaxBound.Y - MinBound.Y + 1;

    // Round bounds to multiples of ScaleX, ScaleY.  This is so 
    // We map between capped and device rectangles easily
    
    rect->X = (rect->X / ScaleX) * ScaleX;
    rect->Y = (rect->Y / ScaleY) * ScaleY;

    rect->Width = rect->Width + tempRect.X - rect->X;
    rect->Height = rect->Height + tempRect.Y - rect->Y;

    INT remainderX = rect->Width % ScaleX;
    INT remainderY = rect->Height % ScaleY;

    if (remainderX > 0) rect->Width += (ScaleX - remainderX);
    if (remainderY > 0) rect->Height += (ScaleY - remainderY);
    
    ASSERT((rect->X + rect->Width) <= (DeviceBounds.Width + ScaleX));
    ASSERT((rect->Y + rect->Height) <= (DeviceBounds.Height + ScaleY));

    return TRUE;
}

// !! Out of commission for the time being.
#if 0
/**************************************************************************\
*
* Function Description:
*
*   Creates a monochrome bitmap from the alpha channel of the DIB.
*   This code uses DonC's halftoning table cells to determine the pattern
*   for use in mask generation.
*
*   NOTE: The mask is generated at device Dpi not capped Dpi.
*
* Arguments:
*
*   zeroOut - only modify the original DIB for non-Postscript since we
*             OR the dib in.  For PS, we use imagemask exclusively.
* 
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
EpScanDIB::CreateAlphaMask()
{
    DWORD MaskStride;

    MaskStride = (ScanBounds.Width - 1) >> 3;
    MaskStride = MaskStride + ( 4 - (MaskStride % 4));
    
    // SetBounds() multiplies the ScanBounds for the DPI scaling.
    INT width = ScanBounds.Width;
    INT height = ScanBounds.Height;

    INT orgXsrc = ScanBounds.X + TranslateHTTable;
    INT orgYsrc = ScanBounds.Y + TranslateHTTable;

    BYTE* dst = MaskStart;
    BYTE* src = AlphaStart;
    ARGB* orig = BufStart;

    INT srcStride = ScanBounds.Width;
    INT dstStride = MaskStride;

    if (width == 0)
    {
        return GenericError;
    }

    for (INT yPos=0; yPos < height; yPos++)
    {
        src = AlphaStart + yPos*srcStride;
        dst = MaskStart + yPos*dstStride;
        
        INT orgX = orgXsrc % 91;
        INT orgY = orgYsrc % 91;

        INT     htStartX   = orgX;
        INT     htStartRow = orgY * 91;
        INT     htIndex    = htStartRow + orgX;

        BYTE    outByte = 0;

        for (INT xPos=0; xPos < width; xPos++)
        {
            // unpremultiply or zero out only once per pixel of source image
            // at capped DPI

           if (((yPos % MaskScaleY) == 0) && ((xPos % MaskScaleX) == 0))
           {
               // Check if we should ZERO out his pixel in the original
               // source image.  We do so if all alpha values for this pixel
               // in the device DPI alpha image are 0.  This is done for 
               // better compression in the postscript output case.

               BOOL zeroIt = TRUE;
               
               for (INT xTmp=0; xTmp < MaskScaleX; xTmp++)
               {
                   for (INT yTmp=0; yTmp < MaskScaleY; yTmp++)
                   {
                       if (*(src + xTmp + (yTmp * srcStride)) != 0)
                       {   
                           zeroIt = FALSE;
                           break;
                       }
                   }
               }

               if (zeroIt)
                   *orig = 0;
               else
                   *orig = Unpremultiply(*(ARGB*)orig);
               
               orig++;
           }
            
            INT maskBit = *src++ > HT_SuperCell_GreenMono[htIndex] ? 0 : 1;

            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0) 
                *dst++ = outByte;

            htIndex++;
            if (++orgX >= 91)
            {
                orgX = 0;
                htIndex = htStartRow;
            }
        }
   
        // output last partial byte
        if ((xPos % 8) != 0) 
        {
           // shift remaining bits & output
           outByte = outByte << (8 - (xPos % 8));
           *dst = outByte;
        }

        orgYsrc++;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a 0-1 bitmap where we know the alpha channel is always
*   0x00 or 0xFF.  We iterate through the bits and where-ever pixel is != 0 we
*   output a 1 otherwise a 0.  This is better than the Floyd-Steinberg 
*   which still produces spurious 0 bits even though there shouldn't really
*   be any.
*
* Arguments:
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus 
EpScanDIB::CreateOpaqueMask()
{
    ARGB*   orig = BufStart;
    BYTE*   AlphaPos = AlphaStart;
    BYTE*   MaskPos = MaskStart;
    
    INT    DstWidth = ScanBounds.Width;
    INT    DstHeight = ScanBounds.Height;
    INT    SrcWidth = ScanBounds.Width;
    INT    &Height = ScanBounds.Height;

    LONG    BitStride = (DstWidth - 1) >> 3;
    
    BitStride = BitStride + (4 - (BitStride % 4));

    BYTE    outByte = 0;
    
    for (INT y=0; y<DstHeight; y++)
    {
        AlphaPos = AlphaStart + SrcWidth*y;
        MaskPos  = MaskStart + BitStride*y;
            
        for (INT x=0; x<DstWidth; x++)
        {
            if (((y % MaskScaleY) == 0) && ((x % MaskScaleX) == 0))
            {
               // Check if we should ZERO out his pixel in the original
               // source image.  We do so if all alpha values for this pixel
               // in the device DPI alpha image are 0.  This is done for 
               // better compression in the postscript output case.
               
               BOOL zeroIt = TRUE;
    
               for (INT xTmp=0; xTmp < MaskScaleX; xTmp++)
               {
                  for (INT yTmp=0; yTmp < MaskScaleY; yTmp++)
                  {
                     if (*(AlphaPos + xTmp + (yTmp * SrcWidth)) != 0)
                     {   
                        zeroIt = FALSE;
                        break;
                     }
                  }
               }

               // no need to unpremultiply since this is a 0-1 source image
               if (zeroIt)
                   *orig = 0;
    
               orig++;
            }
            
            BYTE alpha = *AlphaPos++;
            
            outByte = (outByte << 1) | ((alpha != 0) ? 0:1);

            if (((x + 1) % 8) == 0) 
                *MaskPos++ = outByte;
        }

        if ((x % 8) != 0) 
        {
            *MaskPos = (BYTE)(outByte << (8 - (x % 8)));
        }
    }

    return Ok;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soblend.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Blend" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
* Revision History:
*
*   12/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Blend: Does a SrcOver alpha-blend operation.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (usually equal to dst).
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use BlendingScan.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   This is a ternary operation. We take pixels from 'src', blend pixels
*   from 'otherParams->BlendingScan' over them, and write the result to 'dst'.
*
*   Since the formats of the 'dst' and 'src' scans are the same for all
*   the blend functions we implement, the naming is simplified to list just
*   the format of BlendingScan, then the format of 'dst'.
*
*   src and dst may be equal; otherwise, they must point to scans which do
*   not overlap in memory.
*
*   The blend operation adheres to the following rule:
*   "If the blending alpha value is zero, do not write the destination pixel."
*   
*   In other words, it is also a 'WriteRMW' operation. This allows us to
*   avoid a separate 'WriteRMW' step in some cases. See SOReadRMW.cpp and 
*   SOWriteRMW.cpp.
*
*   The impact of this is that you have to be careful if you want 'blend'
*   to be a true ternary operation. Remember, if a blend pixel
*   is transparent, NOTHING gets written to the corresponding destination
*   pixel. One way to solve this is to make sure that the final operation in
*   your pipeline is a WriteRMW operation.
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*   12/07/1999 agodfrey
*       Included the 32bpp blend (moved from from Ddi/scan.cpp)
*   01/06/2000 agodfrey
*       Added AndrewGo's code for 565, 555, RGB24 and BGR24. Changed the
*       blends to be 'almost' ternary operations.
*
\**************************************************************************/


VOID FASTCALL
ScanOperation::BlendLinear_sRGB_32RGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while ((count>0) && (((*((DWORD*)bl))>>24)==0xFF))
            {
                *d=*bl;
                count--;
                d++;
                bl++;
                s++;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            GammaConvert_sRGB_sRGB64(buffer1,s,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination.
            // Must blend using the previous result as the bl
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(d,buffer1,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_32RGB_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while ((count>0) && (((*((DWORD*)bl))>>24)==0xFF))
            {
                *d=*bl;
                count--;
                d++;
                bl++;
                s++;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            GammaConvert_sRGB_sRGB64(buffer1,s,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            // Must blend using the previous result as the bl
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(d,buffer1,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_565(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_565_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_565(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_565_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_565_MMX(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_565_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_565_MMX(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_555(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_555_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_555(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_555_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_555_MMX(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_555_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_555_MMX(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

// Blend sRGB over sRGB, ignoring the non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)

    ASSERT(count>0);

    UINT32 dstPixel;
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                //
                // Dst = B + (1-Alpha) * S
                //

                dstPixel = *s;

                ULONG Multa = 255 - alpha;
                ULONG _D1_00AA00GG = (dstPixel & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (dstPixel & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = blendPixel + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *d = dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)
    using namespace sRGB;
    DEFINE_POINTERS(ARGB64, ARGB64)
    const void *pbl=otherParams->BlendingScan;
    static ULONGLONG halfMask=0x0080008000800080;
    DWORD dwBlendPixel;

    _asm {
        mov        ecx,count                   ; ecx=pixel counter
        mov        ebx,pbl                     ; ebx=blend pixel pointer
        mov        esi,s                       ; esi=source pixel pointer
        mov        edi,d                       ; edi=dest pixel pointer
        pxor       mm7,mm7                     ; mm7=[0|0|0|0]
        movq       mm3,halfMask

main_loop:
        mov        eax,DWORD ptr [ebx]
        mov        edx,eax                     ; eax=blend pixel
        shr        edx,24                      ; edx=alpha
        cmp        edx,0                       ; For some reason, doing a jz right after a shr stalls
        jz         alpha_blend_done            ; if alpha=0, no blending

        cmp        edx,0xFF
        jne        alpha_blend
        mov        [edi],eax                   ; if alpha=0xFF, copy bl to dest
        jmp        alpha_blend_done

alpha_blend:
        movd       mm4,eax

        mov        eax,[esi]                   ; eax=source
        movd       mm0,eax                     ; mm0=[0|0|AR|GB]
        punpcklbw  mm0,mm7                     ; mm0=[A|R|G|B]

        xor        edx,0xFF                    ; C=255-Alpha
        movd       mm2,edx                     ; mm2=[0|0|0|C]
        punpcklwd  mm2,mm2                     ; mm2=[0|0|C|C]
        punpckldq  mm2,mm2                     ; mm2=[C|C|C|C]

        pmullw     mm0,mm2
        paddw      mm0,mm3                     ; mm0=[AA|RR|GG|BB]
        movq       mm2,mm0                     ; mm2=[AA|RR|GG|BB]

        psrlw      mm0,8                       ; mm0=[A|R|G|B]
        paddw      mm0,mm2                     ; mm0=[AA|RR|GG|BB]
        psrlw      mm0,8                       ; mm0=[A|R|G|B]

        packuswb   mm0,mm0                     ; mm0=[AR|GB|AR|GB]
        paddd      mm0,mm4                     ; Add the blend pixel
        movd       edx,mm0                     ; edx=[ARGB] -> result pixel
        mov        [edi],edx

alpha_blend_done:
        add        edi,4
        add        esi,4
        add        ebx,4
        dec        ecx
        jg         main_loop

        emms
    }
#endif
}

// Blend from sRGB64 to sRGB64.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    DEFINE_BLEND_POINTER(ARGB64)
    using namespace sRGB;
    
    while (count--)
    {
        sRGB64Color blendPixel;
        blendPixel.argb = *bl;
        INT16 alpha = blendPixel.a;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            sRGB64Color dstPixel;

            if (alpha == SRGB_ONE)
            {
                dstPixel.argb = blendPixel.argb;
            }
            else
            {
                //
                // Dst = Src + (1-Alpha) * Dst
                //

                dstPixel.argb = *s;

                INT Multa = SRGB_ONE - alpha;
                
                dstPixel.r = ((dstPixel.r * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.r;
                dstPixel.g = ((dstPixel.g * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.g;
                dstPixel.b = ((dstPixel.b * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.b;
                dstPixel.a = ((dstPixel.a * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.a;
            }

            *d = dstPixel.argb;
        }

        bl++;
        s++;
        d++;
    }
}

// Blend from sRGB64 to sRGB64 MMX.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)
    using namespace sRGB;
    DEFINE_POINTERS(ARGB64, ARGB64)
    const void *pbl=otherParams->BlendingScan;
    static ULONGLONG ullSRGBHalfMask=0x1000100010001000;

    _asm {
        mov        ecx,count                   ; ecx=pixel counter
        mov        ebx,pbl                     ; ebx=blend pixel pointer
        mov        esi,s                       ; esi=source pixel pointer
        mov        edi,d                       ; edi=dest pixel pointer
        movq       mm4,ullSRGBHalfMask         ; mm4=mask with srgb half

main_loop:
        movsx      eax,word ptr [ebx+3*2]      ; eax=alpha
        or         eax,eax                     ; eax==0?
        jz         alpha_blend_done            ; if alpha=0, no blending

        movq       mm0,[ebx]                   ; mm0=blend pixel
        cmp        eax,SRGB_ONE                ; if alpha=SRGB_ONE, dest=blend
        jne        alpha_blend
        movq       [edi],mm0                   ; copy blend pixel to dest
        jmp        alpha_blend_done

alpha_blend:
        ; Get SRGB_ONE-Alpha
        neg        eax
        add        eax,SRGB_ONE                ; C=SRGB_ONE-Alpha
        movd       mm2, eax                    ; mm2=[0|0|0|C]
        punpcklwd  mm2, mm2
        punpckldq  mm2, mm2                    ; mm2=[C|C|C|C]

        ; Blend pixels
        movq       mm1,[esi]                   ; mm1=[A|R|G|B] source pixel
        movq       mm3,mm1                     ; mm3=[A|R|G|B] source pixel
        pmullw     mm1,mm2                     ; low word of source*C
        paddw      mm1,mm4                     ; add an srgb half for rounding
        psrlw      mm1,SRGB_FRACTIONBITS       ; truncate low SRGB_FRACTIONBITS
        pmulhw     mm3,mm2                     ; high word of source*C
        psllw      mm3,SRGB_INTEGERBITS        ; truncate high SRGB_INTEGERBITS
        por        mm1,mm3                     ; mm1=[A|R|G|B]
        paddw      mm1,mm0                     ; add blend pixel
        movq       [edi],mm1                   ; copy result to dest

alpha_blend_done:
        add        edi,8
        add        esi,8
        add        ebx,8

        dec        ecx
        jg         main_loop
        emms
    }
#endif
}


// Blend from sRGB to 16bpp 565, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 27;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            // Blend: S + [ (255 - sA) * D ] / 255

            // First, convert the source pixel from 32bpp BGRA to
            // 5-5-5 16bpp, pre-multiplied.  
            //
            // Note: No rounding needs to be done on this conversion!

            blendPixel = ((blendPixel >> 8) & 0xf800) |
                         ((blendPixel >> 5) & 0x07e0) |
                         ((blendPixel >> 3) & 0x001f);
        
            if (alpha == 31)
            {
                dstPixel = blendPixel;
            }
            else
            {
                dstPixel = (UINT32) *s;

                UINT32 multA = 31 - alpha;

                UINT32 D1_00rr00bb = (dstPixel & 0xf81f);
                UINT32 D2_rrrrbbbb = D1_00rr00bb * multA + 0x00008010;
                UINT32 D3_00rr00bb = (D2_rrrrbbbb & 0x001f03e0) >> 5;
                UINT32 D4_rrxxbbxx = ((D2_rrrrbbbb + D3_00rr00bb) >> 5) & 0xf81f;

                UINT32 D1_000000gg = (dstPixel & 0x7e0) >> 5;
                UINT32 D2_0000gggg = D1_000000gg * 2 * multA + 0x00000020;
                UINT32 D3_000000gg = (D2_0000gggg & 0x00000fc0) >> 6;
                UINT32 D4_0000ggxx = ((D2_0000gggg + D3_000000gg) & 0x0fc0) >> 1;

                dstPixel = (UINT16) ((D4_rrxxbbxx | D4_0000ggxx) + blendPixel);
            }

            *d = (UINT16) dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 555, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 27;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            // Blend: S + [ (255 - sA) * D ] / 255

            // First, convert the source pixel from 32bpp BGRA to
            // 5-5-5 16bpp, pre-multiplied.  
            //
            // Note: No rounding needs to be done on this conversion!

            blendPixel = ((blendPixel & 0x00f80000) >> 9) | 
                         ((blendPixel & 0x0000f800) >> 6) | 
                         ((blendPixel & 0x000000f8) >> 3);

            if (alpha == 31)
            {
                dstPixel = blendPixel;
            }                       
            else
            {
                dstPixel = (UINT32) *s;

                UINT32 multA = 31 - alpha;

                UINT32 D1_00rr00bb = (dstPixel & 0x7c1f);
                UINT32 D2_rrrrbbbb = D1_00rr00bb * multA + 0x00004010;
                UINT32 D3_00rr00bb = (D2_rrrrbbbb & 0x000f83e0) >> 5;
                UINT32 D4_rrxxbbxx = ((D2_rrrrbbbb + D3_00rr00bb) >> 5) & 0x7c1f;

                UINT32 D1_000000gg = (dstPixel & 0x3e0) >> 5;
                UINT32 D2_0000gggg = D1_000000gg * multA + 0x00000010;
                UINT32 D3_000000gg = (D2_0000gggg & 0x000003e0) >> 5;
                UINT32 D4_0000ggxx = (D2_0000gggg + D3_000000gg) & 0x03e0;

                dstPixel = (UINT16) ((D4_rrxxbbxx | D4_0000ggxx) + blendPixel);
            }

            *d = (UINT16) dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB to RGB24, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);
    
    do {

        if (((UINT_PTR) d & 0x3) == 0)
        {
            while (count >= 4)
            {
                BYTE *bb = (BYTE *) bl;

                if ((bb[3] & bb[7] & bb[11] & bb[15]) != 0xFF)
                {
                    break;
                }

                ((UINT32 *) d)[0] = (bb[4] << 24)  | (bb[2] << 16)  | (bb[1] << 8)  | bb[0];
                ((UINT32 *) d)[1] = (bb[9] << 24)  | (bb[8] << 16)  | (bb[6] << 8)  | bb[5];
                ((UINT32 *) d)[2] = (bb[14] << 24) | (bb[13] << 16) | (bb[12] << 8) | bb[10];

                count -= 4;
                bl += 4;
                d += 12;
                s += 12;
            }
        }
        
        if (count == 0)
        {
            break;
        }

        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst

                UINT32 multA = 255 - alpha;

                UINT32 D1_000000GG = *(s + 1);
                UINT32 D2_0000GGGG = D1_000000GG * multA + 0x00800080;
                UINT32 D3_000000GG = (D2_0000GGGG & 0xff00ff00) >> 8;
                UINT32 D4_0000GG00 = (D2_0000GGGG + D3_000000GG) & 0xFF00FF00;

                UINT32 D1_00RR00BB = *(s) | (ULONG) *(s + 2) << 16;
                UINT32 D2_RRRRBBBB = D1_00RR00BB * multA + 0x00800080;
                UINT32 D3_00RR00BB = (D2_RRRRBBBB & 0xff00ff00) >> 8;
                UINT32 D4_00RR00BB = ((D2_RRRRBBBB + D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = (D4_0000GG00 | D4_00RR00BB) + blendPixel;
            }

            *(d)     = (BYTE) (dstPixel);
            *(d + 1) = (BYTE) (dstPixel >> 8);
            *(d + 2) = (BYTE) (dstPixel >> 16);
        }

        bl++;
        d += 3;
        s += 3;
    } while (--count != 0);
}

// Blend from sRGB to BGR24, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_24BGR(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst

                UINT32 multA = 255 - alpha;

                UINT32 D1_000000GG = *(s + 1);
                UINT32 D2_0000GGGG = D1_000000GG * multA + 0x00800080;
                UINT32 D3_000000GG = (D2_0000GGGG & 0xff00ff00) >> 8;
                UINT32 D4_0000GG00 = (D2_0000GGGG + D3_000000GG) & 0xFF00FF00;

                UINT32 D1_00RR00BB = *(s) | (ULONG) *(s + 2) << 16;
                UINT32 D2_RRRRBBBB = D1_00RR00BB * multA + 0x00800080;
                UINT32 D3_00RR00BB = (D2_RRRRBBBB & 0xff00ff00) >> 8;
                UINT32 D4_00RR00BB = ((D2_RRRRBBBB + D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = (D4_0000GG00 | D4_00RR00BB) + blendPixel;
            }

            *(d)     = (BYTE) (dstPixel >> 16);
            *(d + 1) = (BYTE) (dstPixel >> 8);
            *(d + 2) = (BYTE) (dstPixel);
        }

        bl++;
        d += 3;
        s += 3;
    } while (--count != 0);
}

/*

!!![agodfrey]
So we're going to move to standardizing on non-premultiplied alpha.
When we do, the above routines will all have to change - but we may
want to keep the above versions around too.

Below, I've implemented the sRGB and sRGB64 versions for a non-premultiplied
source. Now, these really blend from a non-premultiplied source, 
to a pre-multiplied destination. You can see this from the fact that they 
are equivalent to combining the above pre-multiplied Blends with an
AlphaMultiply step on the source data.

Since pre-multiplied and non-premultiplied formats are identical for alpha==1,
the functions below work fine when the destination has no alpha (i.e. alpha==1).

Otherwise, we can use them when the destination is in premultiplied format.
If we somehow let the user draw to such a destination, they can use an off-screen
premultiplied buffer to accumulate drawing, and then using a
pre-multiplied blend, draw that to the final destination. This gives them
the same functionality that standardizing on pre-multiplied alpha is supposed
to give.

// Blend sRGB over sRGB, ignoring the non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Dst * (1-Alpha) + Src * Alpha
                
                dstPixel = *s;

                ULONG invalpha = 255 - alpha;
                
                ULONG _D1_00AA00GG = (dstPixel & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (dstPixel & 0x00ff00ff);
                
                // For the alpha channel, the result we want is this:
                //
                //     Dst = Dst * (1-Alpha) + Src.
                //
                // Or equivalently:
                //
                //     Dst = Dst * (1-Alpha) + Alpha.
                //                
                // We want to apply the same operations to the alpha channel as
                // we do to the others. So, to get the above result from
                //
                //     Dst = Dst * (1-Alpha) + Src * Alpha
                //
                // we fake a 'Src' value of 1 (represented by 255).
                
                ULONG _S1_00ff00GG = (blendPixel & 0xff00ff00) >> 8 + 0xff0000;
                ULONG _S1_00RR00BB = (blendPixel & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * invalpha + 
                                     _S1_00ff00GG * alpha +
                                     0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * invalpha + 
                                     _S1_00RR00BB * alpha + 
                                     0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                
                dstPixel = _D4_AA00GG00 + _D4_00RR00BB;
            }

            *d = dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB64 to sRGB64.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    DEFINE_BLEND_POINTER(ARGB64)
    using namespace sRGB;
    
    while (count--)
    {
        sRGB64Color blendPixel;
        blendPixel.argb = *bl;
        INT alpha = blendPixel.a;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            sRGB64Color dstPixel;

            if (alpha == SRGB_ONE)
            {
                dstPixel.argb = blendPixel.argb;
            }
            else
            {
                // Dst = Dst * (1-Alpha) + Src * Alpha

                dstPixel.argb = *s;

                INT invalpha = SRGB_ONE - alpha;
                
                dstPixel.r = ((dstPixel.r * invalpha) + 
                              (blendPixel.r * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.g = ((dstPixel.g * invalpha) + 
                              (blendPixel.g * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.b = ((dstPixel.b * invalpha) + 
                              (blendPixel.b * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.a = (((dstPixel.a * invalpha) + SRGB_HALF) >> 
                              SRGB_FRACTIONBITS) + 
                             blendPixel.a;
            }

            *d = dstPixel.argb;
        }

        bl++;
        s++;
        d++;
    }
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scanoperation.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   Public scan-operation definitions (in the ScanOperation namespace).
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*   
* Created:
*
*   07/16/1999 agodfrey
*
\**************************************************************************/

#ifndef _SCANOPERATION_HPP
#define _SCANOPERATION_HPP

#include "palettemap.hpp"

namespace ScanOperation
{
    // OtherParams:
    //   If a scan operation needs extra information about how to perform
    //   an operation, it is passed in the OtherParams structure.
    
    struct OtherParams
    {
        const ColorPalette* Srcpal; // source palette
        const ColorPalette* Dstpal; // destination palette
        
        const EpPaletteMap *PaletteMap; // palette translation vector, used when 
                                        // halftoning
        
        INT X,Y; // x and y coordinates of the leftmost pixel of the scan.
                 // Used when halftoning/dithering

        BOOL DoingDither; // dithering enabled (for 16bpp)
        
        BYTE *CTBuffer;  // ClearType coverage buffer, used for ClearType
                         // scan types.
        ARGB SolidColor; // Solid fill color, used in the OpaqueSolidFill and
                         // CTSolidFill scan types.
        ULONG TextContrast; // Text contrast value for blending, used in CTFill and CTSolidFill types
        
        // blendingScan: Used in the RMW optimization (see ReadRMW and 
        //   WriteRMW). Can be in either ARGB or ARGB64 format.
        
        const void *BlendingScan;

        void *TempBuffers[3];
    };
    
    /**************************************************************************\
    *
    * Operation Description:
    *
    *   ScanOpFunc is the signature of every Scan Operation.
    *
    * Arguments:
    *
    *   dst         - The destination scan
    *   src         - The source scan
    *   count       - The length of the scan, in pixels
    *   otherParams - Additional data.
    *
    * Return Value:
    *
    *   None
    *
    * Notes:
    *
    *   The formats of the destination and source depend on the specific
    *   scan operation.
    *
    *   dst and src must point to non-overlapping buffers. The one exception
    *   is that they may be equal, but some scan operations don't allow this
    *   (most notably, those which deal with different-sized source and
    *   destination formats.)
    *
    *   If you know which operations you're going to be invoking, you can
    *   omit to set fields in otherParams, trusting that they won't be
    *   used. This can be error-prone, which is why we try to limit
    *   the code which uses scan operations directly.
    *   As an example, if you know you're not going to deal with palettized
    *   formats, you don't need to set up Srcpal, Dstpal or PaletteMap.
    *
    \**************************************************************************/

    // The common scan operation function signature
    
    typedef VOID (FASTCALL *ScanOpFunc)(
        VOID *dst, 
        const VOID *src, 
        INT count, 
        const OtherParams *otherParams
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soalphamultiply.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "AlphaMultiply" and "AlphaDivide" scan operations.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   These scan operations multiply/divide the color components by the alpha
*   component. API-level input colors are (usually) specified in 
*   'non-premultiplied'. Given a non-premultiplied
*   color (R, G, B, A), its 'premultiplied' form is (RA, GA, BA, A).
*
* Notes:
*
*   Since "AlphaMultiply" loses information, "AlphaDivide" is not a true
*   inverse operation. (But it is an inverse if all pixels have an alpha of 1.)
*
*   If the alpha is 0, "AlphaDivide" won't cause a divide-by-zero exception or
*   do anything drastic. But it may do something random. Currently, the pixel 
*   value is unchanged. It could, instead, set the pixel to 0.
*
* Revision History:
*
*   12/14/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   AlphaMultiply/AlphaDivide: Convert between premultiplied and
*       non-premultiplied alpha.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   !!![agodfrey] Currently we use 'Unpremultiply' from imgutils.cpp. 
*   While we may keep the tables and lookup in imgutils.cpp, 
*   it needs better naming, and we want the alpha=0 and alpha=255 cases in
*   here, not out-of-line in imgutils.cpp.
*
* History:
*
*   12/14/1999 agodfrey
*       Created it.
*
\**************************************************************************/

ARGB Unpremultiply(ARGB argb);

// AlphaDivide from 32bpp PARGB

VOID FASTCALL
ScanOperation::AlphaDivide_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)

    while (count--)
    {
        sRGB::sRGBColor c;
        c.argb = *s;
        if (sRGB::isTranslucent(c.argb))
        {
            c.argb = Unpremultiply(c.argb);
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// !!![agodfrey] This should be sorted out. It should be out-of-line, and kept
//     with its mates in imgutils.cpp (which should maybe move), but it 
//     shouldn't have a translucency check (we want to do that in
//     AlphaMultiply_sRGB).

ARGB MyPremultiply(ARGB argb)
{
    ARGB a = (argb >> ALPHA_SHIFT);

    ARGB _000000gg = (argb >> 8) & 0x000000ff;
    ARGB _00rr00bb = (argb & 0x00ff00ff);

    ARGB _0000gggg = _000000gg * a + 0x00000080;
    _0000gggg += (_0000gggg >> 8);

    ARGB _rrrrbbbb = _00rr00bb * a + 0x00800080;
    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

    return (a << ALPHA_SHIFT) |
           (_0000gggg & 0x0000ff00) |
           ((_rrrrbbbb >> 8) & 0x00ff00ff);
}

// AlphaMultiply from 32bpp ARGB

VOID FASTCALL
ScanOperation::AlphaMultiply_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)

    while (count--)
    {
        sRGB::sRGBColor c;
        c.argb = *s;
        ARGB alpha = c.argb & 0xff000000;
        
        if (alpha != 0xff000000)
        {
            if (alpha != 0x00000000)
            {
                c.argb = MyPremultiply(c.argb);
            }
            else
            {
                c.argb = 0;
            }
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// !!![agodfrey] We may want to round off, in both AlphaDivide_sRGB64 and
//     AlphaMultiply_sRGB64.

// AlphaDivide from 64bpp PARGB

VOID FASTCALL
ScanOperation::AlphaDivide_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)

    while (count--)
    {
        using namespace sRGB;
        
        sRGB64Color c;
        c.argb = *s;
        if (isTranslucent64(c.a))
        {
            c.r = ((INT) c.r << SRGB_FRACTIONBITS) / c.a;
            c.g = ((INT) c.g << SRGB_FRACTIONBITS) / c.a;
            c.b = ((INT) c.b << SRGB_FRACTIONBITS) / c.a;
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// AlphaMultiply from 64bpp ARGB

VOID FASTCALL
ScanOperation::AlphaMultiply_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)

    while (count--)
    {
        using namespace sRGB;
        
        sRGB64Color c;
        c.argb = *s;
        if (c.a != SRGB_ONE)
        {
            if (c.a != 0)
            {
                c.r = ((INT) c.r * c.a) >> SRGB_FRACTIONBITS;
                c.g = ((INT) c.g * c.a) >> SRGB_FRACTIONBITS;
                c.b = ((INT) c.b * c.a) >> SRGB_FRACTIONBITS;
            }
            else
            {
                c.argb = 0;
            }
        }
        *d = c.argb;
        d++;
        s++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soconvert.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Convert" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for converting pixels from
*   one format, to another of equal or greater color precision.
*   (Conversion to a lesser color precision is done with either a "Quantize"
*   operation or a "Halftone" operation.)
*
* Notes:
*
*   If the source format doesn't have alpha, we assume an alpha of 1.
*
*   If the source format has a palette, it is supplied in otherParams->Srcpal.
*
*   When converting to greater color precision, we need to be careful.
*   The operation must:
*     + Map 0 to 0
*     + Map the maximum value to the maxmimum value (e.g. in 555->32bpp,
*       it must map 31 to 255).
*
*   In addition, we desire that the mapping is as close to linear as possible.
*
*   Currently (12/16/1999), our 16bpp->32bpp code does have slight rounding
*   errors. e.g. we get a different value from "round(x*31/255)" when x is
*   3, 7, 24, or 28. This is probably acceptable. We could also speed
*   the code up by using byte lookup tables. (From an unpublished paper
*   by Blinn & Marr of MSR.)
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved it to from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Convert: Convert pixel format up to 32bpp ARGB.
*
* Arguments:
*
*   dst         - The destination scan (32bpp ARGB)
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional conversion data.
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Convert from 1bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_1_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    ASSERT(otherParams->Srcpal->Count >= 2);
    
    UINT n, bits;

    ARGB c0 = otherParams->Srcpal->Entries[0];
    ARGB c1 = otherParams->Srcpal->Entries[1];

    // NOTE: We choose code size over speed here

    while (count)
    {
        bits = *s++;
        n = count > 8 ? 8 : count;
        count -= n;

        while (n--)
        {
            *d++ = (bits & 0x80) ? c1 : c0;
            bits <<= 1;
        }
    }
}

// Convert from 4bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_4_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    
    const ARGB* colors = otherParams->Srcpal->Entries;
    UINT n = count >> 1;

    // Handle whole bytes

    while (n--)
    {
        UINT bits = *s++;

        ASSERT((bits >> 4)  < otherParams->Srcpal->Count);
        ASSERT((bits & 0xf) < otherParams->Srcpal->Count);
        
        d[0] = colors[bits >> 4];
        d[1] = colors[bits & 0xf];

        d += 2;
    }

    // Handle the last odd nibble, if any

    if (count & 1)
        *d = colors[*s >> 4];
}

// Convert from 8bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    
    const ARGB* colors = otherParams->Srcpal->Entries;
    
    while (count--)
    {
#if DBG
        if (*s >= otherParams->Srcpal->Count)
        {
            WARNING(("Palette missing entries on conversion from 8bpp to sRGB"));
        }
#endif
        *d++ = colors[*s++];
    }
}

// Convert 16bpp RGB555 to sRGB

VOID FASTCALL
ScanOperation::Convert_555_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB r = (v >> 10) & 0x1f;
        ARGB g = (v >>  5) & 0x1f;
        ARGB b = (v      ) & 0x1f;

        *d++ = ALPHA_MASK |
               (((r << 3) | (r >> 2)) << RED_SHIFT) |
               (((g << 3) | (g >> 2)) << GREEN_SHIFT) |
               (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 16bpp RGB565 to sRGB

VOID FASTCALL
ScanOperation::Convert_565_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB r = (v >> 11) & 0x1f;
        ARGB g = (v >>  5) & 0x3f;
        ARGB b = (v      ) & 0x1f;

        *d++ = ALPHA_MASK |
              (((r << 3) | (r >> 2)) << RED_SHIFT) |
              (((g << 2) | (g >> 4)) << GREEN_SHIFT) |
              (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 16bpp ARGB1555 to sRGB

VOID FASTCALL
ScanOperation::Convert_1555_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB a = (v & 0x8000) ? ALPHA_MASK : 0;
        ARGB r = (v >> 10) & 0x1f;
        ARGB g = (v >>  5) & 0x1f;
        ARGB b = (v      ) & 0x1f;

        *d++ = a |
               (((r << 3) | (r >> 2)) << RED_SHIFT) |
               (((g << 3) | (g >> 2)) << GREEN_SHIFT) |
               (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 24bpp RGB to sRGB

VOID FASTCALL
ScanOperation::Convert_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    
    while (count--)
    {
        *d++ = ALPHA_MASK |
               ((ARGB) s[0] << BLUE_SHIFT) |
               ((ARGB) s[1] << GREEN_SHIFT) |
               ((ARGB) s[2] << RED_SHIFT);

        s += 3;
    }
}

// Convert from 24bpp BGR to sRGB

VOID FASTCALL
ScanOperation::Convert_24BGR_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    
    while (count--)
    {
        *d++ = ALPHA_MASK |
               ((ARGB) s[0] << RED_SHIFT) |
               ((ARGB) s[1] << GREEN_SHIFT) |
               ((ARGB) s[2] << BLUE_SHIFT);

        s += 3;
    }
}

// Convert from 32bpp RGB to sRGB

VOID FASTCALL
ScanOperation::Convert_32RGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++ | ALPHA_MASK;
    }
}

// Convert from 48bpp RGB to sRGB64

VOID FASTCALL
ScanOperation::Convert_48_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(INT16, ARGB64)
    
    while (count--)
    {
        using namespace sRGB;
        sRGB64Color c;
        c.a = SRGB_ONE;
        c.b = s[0];
        c.g = s[1];
        c.r = s[2];
        
        *d++ = c.argb;

        s += 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\scanoperationinternal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   The internal portion of the ScanOperation namespace.
*
*   This is kept separate from ScanOperation.hpp so that files which use
*   AlphaBlender.hpp or FormatConvert.hpp don't end up including all these
*   implementation details.
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview of scan operations.
*   
* Created:
*
*   07/16/1999 agodfrey
*
\**************************************************************************/

#ifndef _SCANOPERATIONINTERNAL_HPP
#define _SCANOPERATIONINTERNAL_HPP

#include "ScanOperation.hpp"
#include "CPUSpecificOps.hpp"

namespace ScanOperation
{
    // Helper macros for defining scan operations
    
    #define DEFINE_POINTERS(srctype, dsttype) \
        const srctype* s = static_cast<const srctype *>(src); \
        dsttype* d = static_cast<dsttype *>(dst);
    
    #define DEFINE_BLEND_POINTER(type) \
        const type* bl = static_cast<const type *>(otherParams->BlendingScan);
            
    // Convert: Convert to a higher-precision format
    
    VOID FASTCALL Convert_1_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_4_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_555_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_565_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_1555_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_24BGR_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_32RGB_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_48_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // Quantize: Quickly convert to a lower-precision format
    
    VOID FASTCALL Quantize_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_1555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_24BGR(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_32RGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB64_48(VOID *, const VOID *, INT, const OtherParams *);
 
    // Halftone: Halftone to a palettized screen format
    
    VOID FASTCALL HalftoneToScreen_sRGB_8_216(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL HalftoneToScreen_sRGB_8_16(VOID *, const VOID *, INT, const OtherParams *);
    
    // Dither: Dither to a 16bpp format
    
    VOID FASTCALL Dither_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);
    
    // Copy: Copy a scan, in the same format
    
    VOID FASTCALL Copy_1(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_4(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_8(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_16(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_32(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_48(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_64(VOID *, const VOID *, INT, const OtherParams *);
    
    // GammaConvert: Convert between formats with differing gamma ramps
    
    VOID FASTCALL GammaConvert_sRGB64_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL GammaConvert_sRGB_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    
    // Blend: An alpha-blend 'SourceOver' operation.
        
    VOID FASTCALL Blend_sRGB_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_sRGB_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB64_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB64_sRGB64_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_24BGR(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_32RGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_32RGB_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);

    // ReadRMW: For each pixel in "otherParams->blendingScan" that is 
    //   translucent (i.e. has (0 < alpha < 1)), copy the 
    //   corresponding pixel from "src" to "dst".
    
    VOID FASTCALL ReadRMW_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_8_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_32_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_32_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // WriteRMW: For each pixel in "otherParams->blendingScan" that is not
    //   completely transparent (i.e. has (alpha != 0)), copy the 
    //   corresponding pixel from "src" to "dst".
    
    VOID FASTCALL WriteRMW_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_8_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_32_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_32_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // AlphaMultiply: Multiply each component by the alpha value
    
    VOID FASTCALL AlphaMultiply_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL AlphaMultiply_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    
    // AlphaDivide: Divide each component by the alpha value
    
    VOID FASTCALL AlphaDivide_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL AlphaDivide_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // ClearType blend
    // solid brush case
    VOID FASTCALL CTBlendSolid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);

    // arbitrary brush case
    VOID FASTCALL CTBlendCARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);   

    // These arrays organize the operations according to their use,
    // indexed by a pixel format:
    //
    // ConvertCopyOps: Copy pixels of the given format
    // ConvertIntoCanonicalOps: Convert from the given format into the
    //   closest canonical format.

    extern ScanOpFunc CopyOps[PIXFMT_MAX];
    extern ScanOpFunc ConvertIntoCanonicalOps[PIXFMT_MAX];
    
    // These are specific to EpAlphaBlender, and can't be used by 
    // EpFormatConverter (not without changing its logic).
    //
    // All 16bpp/15bpp functions must fully support OtherParams::DoingDither.
    //
    // ABConvertFromCanonicalOps: Convert to the given format from the closest
    //   canonical format.
    // BlendOpsLowQuality: Blend directly to the given format.
    // BlendOpsHighQuality: Gamma-corrected blend directly to the given format
    //   (with the source data in 32BPP_PARGB format).

    extern ScanOpFunc ABConvertFromCanonicalOps[PIXFMT_MAX];
    extern ScanOpFunc BlendOpsLowQuality[PIXFMT_MAX];
    extern ScanOpFunc BlendOpsHighQuality[PIXFMT_MAX];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soctblend.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains ClearType scan operations
*
* Revision History:
*
*   07/19/2000 mleonov
*       Created it.
*   01/11/2001 mleonov
*       Reengineered ClearType architecture to allow variable length scan records
*
\**************************************************************************/

#include "precomp.hpp"

static inline VOID
SetupGammaTables(ULONG ulGamma, const BYTE ** gamma, const BYTE ** gammaInv)
{
    static BYTE const * const gammaTables[] =
    {
        Globals::TextContrastTableIdentity, Globals::TextContrastTableIdentity,
        Globals::TextContrastTablesDir[0],  Globals::TextContrastTablesInv[0],
        Globals::TextContrastTablesDir[1],  Globals::TextContrastTablesInv[1],
        Globals::TextContrastTablesDir[2],  Globals::TextContrastTablesInv[2],
        Globals::TextContrastTablesDir[3],  Globals::TextContrastTablesInv[3],
        Globals::TextContrastTablesDir[4],  Globals::TextContrastTablesInv[4],
        Globals::TextContrastTablesDir[5],  Globals::TextContrastTablesInv[5],
        Globals::TextContrastTablesDir[6],  Globals::TextContrastTablesInv[6],
        Globals::TextContrastTablesDir[7],  Globals::TextContrastTablesInv[7],
        Globals::TextContrastTablesDir[8],  Globals::TextContrastTablesInv[8],
        Globals::TextContrastTablesDir[9],  Globals::TextContrastTablesInv[9],
        Globals::TextContrastTablesDir[10], Globals::TextContrastTablesInv[10],
        Globals::TextContrastTablesDir[11], Globals::TextContrastTablesInv[11]
    };

    if (ulGamma > 12)
    {
        ASSERT(FALSE);
        ulGamma = 12;
    }
    *gamma    = gammaTables[2 * ulGamma];
    *gammaInv = gammaTables[2 * ulGamma + 1];
} // SetupGammaTables

static __forceinline BYTE
BlendOneChannel(BYTE alphaCT, BYTE alphaBrush, BYTE foreground, BYTE background, const BYTE * gamma, const BYTE * gammaInv)
{
    ASSERT(0 <= alphaCT && alphaCT <= CT_SAMPLE_F);
    if (alphaCT == 0)
        return background;
    foreground = gamma[foreground];
    background = gamma[background];
    ULONG ulongRet = ULONG(0.5 + background + ((double)alphaBrush * (foreground - background) * alphaCT) / (255 * CT_SAMPLE_F));
    ASSERT(ulongRet <= 255);
    BYTE ret = (BYTE)ulongRet;
    ret = gammaInv[ret];
    return ret;
} // BlendOneChannel

namespace
{

class ClearTypeSolidBlend
{
    const ARGB      ArgbF;
    const BYTE *    ClearTypeBits;

public:
    ClearTypeSolidBlend(const ScanOperation::OtherParams * otherParams)
        : ClearTypeBits(otherParams->CTBuffer), ArgbF(otherParams->SolidColor)
    {}

    // always call IsCompletelyTransparent in the beginning of RMW operation
    bool IsCompletelyTransparent() const
    {
        return GetAlpha() == 0;
    }
    BYTE GetCT() const
    {
        return *ClearTypeBits;
    }
    ARGB GetARGB() const
    {
        return ArgbF;
    }
    BYTE GetAlpha() const
    {
        return (BYTE)GpColor::GetAlphaARGB(ArgbF);
    }
    BYTE GetRed() const
    {
        return (BYTE)GpColor::GetRedARGB(ArgbF);
    }
    BYTE GetGreen() const
    {
        return (BYTE)GpColor::GetGreenARGB(ArgbF);
    }
    BYTE GetBlue() const
    {
        return (BYTE)GpColor::GetBlueARGB(ArgbF);
    }
    bool IsOpaque() const
    {
        return GetCT() == CT_LOOKUP - 1 && GetAlpha() == 255;
    }
    bool IsTransparent() const
    {
        // we took care of zero GetAlpha() in IsCompletelyTransparent()
        return GetCT() == 0;
    }
    bool IsTranslucent() const
    {
        return !IsTransparent() && !IsOpaque();
    }
    void operator++()
    {
        ++ClearTypeBits;
    }
}; // class ClearTypeSolidBlend

class ClearTypeCARGBBlend
{
    const ARGB *    ArgbBrushBits;
    const BYTE *    ClearTypeBits;
public:
    ClearTypeCARGBBlend(const ScanOperation::OtherParams * otherParams)
        : ClearTypeBits(otherParams->CTBuffer),
          ArgbBrushBits(static_cast<const ARGB*>(otherParams->BlendingScan))
    {}

    bool IsCompletelyTransparent() const
    {
        return false;
    }
    BYTE GetCT() const
    {
        return *ClearTypeBits;
    }
    ARGB GetARGB() const
    {
        return *ArgbBrushBits;
    }
    BYTE GetAlpha() const
    {
        return (BYTE)GpColor::GetAlphaARGB(*ArgbBrushBits);
    }
    BYTE GetRed() const
    {
        return (BYTE)GpColor::GetRedARGB(*ArgbBrushBits);
    }
    BYTE GetGreen() const
    {
        return (BYTE)GpColor::GetGreenARGB(*ArgbBrushBits);
    }
    BYTE GetBlue() const
    {
        return (BYTE)GpColor::GetBlueARGB(*ArgbBrushBits);
    }
    bool IsOpaque() const
    {
        return GetCT() == CT_LOOKUP - 1 && GetAlpha() == 255;
    }
    bool IsTransparent() const
    {
        return GetCT() == 0 || GetAlpha() == 0;
    }
    bool IsTranslucent() const
    {
        return !IsTransparent() && !IsOpaque();
    }
    void operator++()
    {
        ++ClearTypeBits;
        ++ArgbBrushBits;
    }
}; // class ClearTypeCARGBBlend

} // namespace

template <class BLENDTYPE>
static VOID ClearTypeBlend(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(ARGB, ARGB)

    ASSERT(count > 0);

    ULONG gammaValue = otherParams->TextContrast;

    const BYTE * gamma, * gammaInv;
    SetupGammaTables(gammaValue, &gamma, &gammaInv);

    do {
        if (bl.IsTransparent())
            ; // fully transparent case, nothing to do
        else if (bl.IsOpaque())
        {   // fully opaque case, copy the foreground color
            *d = bl.GetARGB();
        }
        else
        {
            const BYTE blendIndex = bl.GetCT();
            ASSERT(0 <= blendIndex && blendIndex <= CT_LOOKUP - 1);

            const Globals::F_RGB blend = Globals::gaOutTable[blendIndex];
            const ARGB source = *s;
            const BYTE alphaBrush = bl.GetAlpha();

            const BYTE dstRed = BlendOneChannel(
                blend.kR,
                alphaBrush,
                bl.GetRed(),
                (BYTE)GpColor::GetRedARGB(source),
                gamma,
                gammaInv);

            const BYTE dstGre = BlendOneChannel(
                blend.kG,
                alphaBrush,
                bl.GetGreen(),
                (BYTE)GpColor::GetGreenARGB(source),
                gamma,
                gammaInv);

            const BYTE dstBlu = BlendOneChannel(
                blend.kB,
                alphaBrush,
                bl.GetBlue(),
                (BYTE)GpColor::GetBlueARGB(source),
                gamma,
                gammaInv);

            *d = GpColor::MakeARGB(255, dstRed, dstGre, dstBlu);
        }
        ++bl;
        ++s;
        ++d;
    } while (--count);
} // ClearTypeBlend


VOID FASTCALL
ScanOperation::CTBlendCARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    ClearTypeBlend(dst, src, count, otherParams, bl);
} // ScanOperation::CTBlendCARGB

VOID FASTCALL
ScanOperation::CTBlendSolid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    ClearTypeBlend(dst, src, count, otherParams, bl);
} // ScanOperation::CTBlendSolid

template <class BLENDTYPE>
static VOID
CTReadRMW16(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(UINT16, UINT16)
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (bl.IsTranslucent())
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        ++bl;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (bl.IsTranslucent())
        {
            ++bl;
            if (bl.IsTranslucent())
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else
        {
            ++bl;
            if (bl.IsTranslucent())
            {
                // Only the second pixel has partial alpha, so do a word read:

                *(d + 1) = *(s + 1);
            }
        }

        d += 2;
        s += 2;
        ++bl;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (bl.IsTranslucent())
        {
            *(d) = *(s);
        }
    }
} // CTReadRMW16

VOID FASTCALL ScanOperation::ReadRMW_16_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTReadRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_16_CT_CARGB

VOID FASTCALL ScanOperation::ReadRMW_16_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTReadRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_16_CT_Solid

template <class BLENDTYPE>
static VOID
CTReadRMW24(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(BYTE, BYTE)
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (bl.IsTranslucent())
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        ++bl;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!bl.IsTranslucent())
        {
            ++bl;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (bl.IsTranslucent())
        {
            ++bl;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
} // CTReadRMW24

VOID FASTCALL ScanOperation::ReadRMW_24_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTReadRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_24_CT_CARGB

VOID FASTCALL ScanOperation::ReadRMW_24_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTReadRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_24_CT_Solid


template <class BLENDTYPE>
static VOID
CTWriteRMW16(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(UINT16, UINT16)

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (!bl.IsTransparent())
        {
            *(d) = *(s);
        }

        d++;
        s++;
        ++bl;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (!bl.IsTransparent())
        {
            ++bl;
            if (!bl.IsTransparent())
            {
                // Both pixels have partial bl, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial bl, so do a word read:

                *(d) = *(s);
            }
        }
        else
        {
            ++bl;
            if (!bl.IsTransparent())
            {
                // Only the second pixel has partial bl, so do a word read:

                *(d + 1) = *(s + 1);
            }
        }

        d += 2;
        s += 2;
        ++bl;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (!bl.IsTransparent())
        {
            *(d) = *(s);
        }
    }
} // CTWriteRMW16

VOID FASTCALL ScanOperation::WriteRMW_16_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTWriteRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_16_CT_CARGB

VOID FASTCALL ScanOperation::WriteRMW_16_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTWriteRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_16_CT_Solid


template <class BLENDTYPE>
static VOID
CTWriteRMW24(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
    ASSERT(count>0);

    do {
        if (!bl.IsTransparent())
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        ++bl;
    } while (--count != 0);
} // CTWriteRMW24


VOID FASTCALL ScanOperation::WriteRMW_24_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTWriteRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_24_CT_CARGB

VOID FASTCALL ScanOperation::WriteRMW_24_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTWriteRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_24_CT_CARGB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\socopy.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Copy" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   Scan operations for copying a scan. Because the operation doesn't need
*   to interpret the pixel data, we only need one function per pixel
*   size (in bits).
*
* Notes:
*
*   The destination and source scans must not overlap in memory.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved it from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Copy: Copy a scan, to the same destination format.
*
* Arguments:
*
*   dst         - The destination scan (same format as src)
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Copy 1bpp

VOID FASTCALL
ScanOperation::Copy_1(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, (count + 7) >> 3);
}

// Copy 4bpp

VOID FASTCALL
ScanOperation::Copy_4(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, (4*count + 4) >> 3);
}

// Copy 8bpp

VOID FASTCALL
ScanOperation::Copy_8(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, count);
}

// Copy 16bpp

VOID FASTCALL
ScanOperation::Copy_16(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 2*count);
}

// Copy 24bpp

VOID FASTCALL
ScanOperation::Copy_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 3*count);
}

// Copy 32bpp

VOID FASTCALL
ScanOperation::Copy_32(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++;
    }
}

// Copy 48bpp

VOID FASTCALL
ScanOperation::Copy_48(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 6*count);
}

// Copy 64bpp

VOID FASTCALL
ScanOperation::Copy_64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    
    while (count--)
    {
        *d++ = *s++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\sodither.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module name:
*
*   The "Dither" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
* Revision History:
*
*   01/19/2000 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Dither: Dither from 32bpp ARGB to 16bpp.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use X and Y.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   Special cases which alpha-blend and dither in one step, should probably
*   go in this file, but be named e.g. Blend_sRGB_565_Dithered.
*
* History:
*
*   01/19/2000 andrewgo
*       Created it.
*   01/19/2000 agodfrey
*       Stashed it here for the time being.
*
\**************************************************************************/

UINT32 Saturate5Bit[] = { 0,  1,  2,  3,  4,  5,  6,  7,
                          8,  9,  10, 11, 12, 13, 14, 15,
                          16, 17, 18, 19, 20, 21, 22, 23,
                          24, 25, 26, 27, 28, 29, 30, 31,
                          31 };

UINT32 Saturate6Bit[] = { 0,  1,  2,  3,  4,  5,  6,  7,
                          8,  9,  10, 11, 12, 13, 14, 15,
                          16, 17, 18, 19, 20, 21, 22, 23,
                          24, 25, 26, 27, 28, 29, 30, 31,
                          32, 33, 34, 35, 36, 37, 38, 39,
                          40, 41, 42, 43, 44, 45, 46, 47,
                          48, 49, 50, 51, 52, 53, 54, 55,
                          56, 57, 58, 59, 60, 61, 62, 63,
                          63 };

UINT32 Dither5BitR[16] = { 0x00000000, 0x00040000, 0x00010000, 0x00050000,
                           0x00060000, 0x00020000, 0x00070000, 0x00030000,
                           0x00010000, 0x00050000, 0x00000000, 0x00040000,
                           0x00070000, 0x00030000, 0x00060000, 0x00020000 };

UINT32 Dither5BitG[16] = { 0x00000000, 0x00000400, 0x00000100, 0x00000500,
                           0x00000600, 0x00000200, 0x00000700, 0x00000300,
                           0x00000100, 0x00000500, 0x00000000, 0x00000400,
                           0x00000700, 0x00000300, 0x00000600, 0x00000200 };

UINT32 Dither6BitG[16] = { 0x00000000, 0x00000200, 0x00000000, 0x00000200,
                           0x00000300, 0x00000100, 0x00000300, 0x00000100,
                           0x00000000, 0x00000200, 0x00000000, 0x00000200, 
                           0x00000300, 0x00000100, 0x00000300, 0x00000100 };

UINT32 Dither5BitB[16] = { 0x00000000, 0x00000004, 0x00000001, 0x00000005,
                           0x00000006, 0x00000002, 0x00000007, 0x00000003, 
                           0x00000001, 0x00000005, 0x00000000, 0x00000004,
                           0x00000007, 0x00000003, 0x00000006, 0x00000002 };

// The following 'Dither565' and 'Dither555' matrices are 4 by 4
// arrays for adding straight to an ARGB dword value.  Every row
// is repeated to allow us to do 128-bit reads with wrapping.

UINT32 Dither565[32] = { 0x00000000, 0x00040204, 0x00010001, 0x00050205,
                         0x00000000, 0x00040204, 0x00010001, 0x00050205,
                         0x00060306, 0x00020102, 0x00070307, 0x00030103,
                         0x00060306, 0x00020102, 0x00070307, 0x00030103,
                         0x00010001, 0x00050205, 0x00000000, 0x00040204,
                         0x00010001, 0x00050205, 0x00000000, 0x00040204,
                         0x00070307, 0x00030103, 0x00060306, 0x00020102,
                         0x00070307, 0x00030103, 0x00060306, 0x00020102 };

UINT32 Dither555[32] = { 0x00000000, 0x00040404, 0x00010101, 0x00050505, 
                         0x00000000, 0x00040404, 0x00010101, 0x00050505, 
                         0x00060606, 0x00020202, 0x00070707, 0x00030303,
                         0x00060606, 0x00020202, 0x00070707, 0x00030303,
                         0x00010101, 0x00050505, 0x00000000, 0x00040404,
                         0x00010101, 0x00050505, 0x00000000, 0x00040404,
                         0x00070707, 0x00030303, 0x00060606, 0x00020202,
                         0x00070707, 0x00030303, 0x00060606, 0x00020202 };

// The 'DitherNone' matrix allows us to disable dithering in a dithering
// routine:

UINT32 DitherNone[4] = { 0, 0, 0, 0 };

// Dither to 16bpp 565

VOID FASTCALL
ScanOperation::Dither_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Quantize_sRGB_565(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);
    
    INT x = otherParams->X;
    INT y = otherParams->Y;

    // !!![andrewgo] Are we getting the window-relative (x, y)?  (Don't think so!)

    INT startDitherIndex = (y & 3) * 4;

    do {
        UINT32 src = *s;
        x = (x & 3) + startDitherIndex;

        *d = (WORD)
             (Saturate5Bit[((src & 0xff0000) + Dither5BitR[x]) >> 19] << 11) +
             (Saturate6Bit[((src & 0x00ff00) + Dither6BitG[x]) >> 10] << 5) +
             (Saturate5Bit[((src & 0x0000ff) + Dither5BitB[x]) >> 3]);

        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Dither to 16bpp 555

VOID FASTCALL
ScanOperation::Dither_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Quantize_sRGB_555(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);
    
    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;

    do {
        UINT32 src = *s;
        x = (x & 3) + startDitherIndex;

        *d = (WORD)
             (Saturate5Bit[((src & 0xff0000) + Dither5BitR[x]) >> 19] << 10) +
             (Saturate5Bit[((src & 0x00ff00) + Dither5BitG[x]) >> 11] << 5) +
             (Saturate5Bit[((src & 0x0000ff) + Dither5BitB[x]) >> 3]);

        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 565, with dithering.

VOID FASTCALL
ScanOperation::Dither_Blend_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Blend_sRGB_565(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;
        x = (x & 3) + startDitherIndex;

        if (alpha != 0)
        {
            UINT32 srcPixel;
            UINT r, g, b;

            r = blendPixel & 0xff0000;
            g = blendPixel & 0x00ff00;
            b = blendPixel & 0x0000ff;
            
            if (alpha != 255)
            {
                srcPixel = *s;
        
                UINT sr = (srcPixel >> 11) & 0x1f;
                UINT sg = (srcPixel >>  5) & 0x3f;
                UINT sb = (srcPixel      ) & 0x1f;

                sr = (sr << 3) | (sr >> 2);
                sg = (sg << 2) | (sg >> 4);
                sb = (sb << 3) | (sb >> 2);

                //
                // Dst = B + (1-Alpha) * S
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_000000GG = sg;
                ULONG _D1_00RR00BB = sb | (sr << 16);

                ULONG _D2_0000GGGG = _D1_000000GG * Multa + 0x00000080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_000000GG = (_D2_0000GGGG & 0x0000ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_0000GG00 = (_D2_0000GGGG + _D3_000000GG) & 0x0000FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                r += _D4_00RR00BB; // The BB part will be shifted off
                g += _D4_0000GG00;
                b += _D4_00RR00BB & 0x0000ff;
            }

            *d = (WORD)
                 (Saturate5Bit[(r + Dither5BitR[x]) >> 19] << 11) +
                 (Saturate6Bit[(g + Dither6BitG[x]) >> 10] << 5) +
                 (Saturate5Bit[(b + Dither5BitB[x]) >> 3]);
        }

        bl++;
        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 555, with dithering.

VOID FASTCALL
ScanOperation::Dither_Blend_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Blend_sRGB_555(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;
        x = (x & 3) + startDitherIndex;

        if (alpha != 0)
        {
            UINT32 srcPixel;
            UINT r, g, b;

            r = blendPixel & 0xff0000;
            g = blendPixel & 0x00ff00;
            b = blendPixel & 0x0000ff;
            
            if (alpha != 255)
            {
                srcPixel = *s;

                UINT sr = (srcPixel >> 10) & 0x1f;
                UINT sg = (srcPixel >>  5) & 0x1f;
                UINT sb = (srcPixel      ) & 0x1f;

                sr = (sr << 3) | (sr >> 2);
                sg = (sg << 3) | (sg >> 2);
                sb = (sb << 3) | (sb >> 2);
                
                //
                // Dst = B + (1-Alpha) * S
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_000000GG = sg;
                ULONG _D1_00RR00BB = sb | (sr << 16);

                ULONG _D2_0000GGGG = _D1_000000GG * Multa + 0x00000080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_000000GG = (_D2_0000GGGG & 0x0000ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_0000GG00 = (_D2_0000GGGG + _D3_000000GG) & 0x0000FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                r += _D4_00RR00BB; // The BB part will be shifted off
                g += _D4_0000GG00;
                b += _D4_00RR00BB & 0x0000ff;
            }

            *d = (WORD)
                 (Saturate5Bit[(r + Dither5BitR[x]) >> 19] << 10) +
                 (Saturate5Bit[(g + Dither5BitG[x]) >> 11] << 5) +
                 (Saturate5Bit[(b + Dither5BitB[x]) >> 3]);
        }

        bl++;
        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Generate 555 versions of the routines defined in 'sodither.inc'

#define DITHER_BLEND_555 1

#include "SODither.inc"

// Generate 565 versions of the routines defined in 'sodither.inc'

#undef DITHER_BLEND_555 
#define DITHER_BLEND_555 0

#include "SODither.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\sohalftone.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "HalftoneToScreen" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
*   The "ToScreen" indicates that we make assumptions that are
*   screen-specific. For instance, we special-case the 20 default system 
*   colors.
*
* Revision History:
*
*   10/29/1999 DCurtis
*       Wrote it.
*   12/02/1999 agodfrey
*       Moved it from Imaging\Api\Colorpal.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

#define DIV_51(ulNumerator, ulQuotient, ulRemainder)\
{ \
    ulQuotient = Div51lut[ulNumerator].quotient; \
    ulRemainder = Div51lut[ulNumerator].remainder; \
}

static struct
{
    BYTE quotient;
    BYTE remainder;
}
Div51lut[256] =
{
    0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,
    0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07,
    0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b,
    0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f,
    0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13,
    0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17,
    0x00, 0x18, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b,
    0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f,
    0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23,
    0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27,
    0x00, 0x28, 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b,
    0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f,
    0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x01, 0x00,
    0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04,
    0x01, 0x05, 0x01, 0x06, 0x01, 0x07, 0x01, 0x08,
    0x01, 0x09, 0x01, 0x0a, 0x01, 0x0b, 0x01, 0x0c,
    0x01, 0x0d, 0x01, 0x0e, 0x01, 0x0f, 0x01, 0x10,
    0x01, 0x11, 0x01, 0x12, 0x01, 0x13, 0x01, 0x14,
    0x01, 0x15, 0x01, 0x16, 0x01, 0x17, 0x01, 0x18,
    0x01, 0x19, 0x01, 0x1a, 0x01, 0x1b, 0x01, 0x1c,
    0x01, 0x1d, 0x01, 0x1e, 0x01, 0x1f, 0x01, 0x20,
    0x01, 0x21, 0x01, 0x22, 0x01, 0x23, 0x01, 0x24,
    0x01, 0x25, 0x01, 0x26, 0x01, 0x27, 0x01, 0x28,
    0x01, 0x29, 0x01, 0x2a, 0x01, 0x2b, 0x01, 0x2c,
    0x01, 0x2d, 0x01, 0x2e, 0x01, 0x2f, 0x01, 0x30,
    0x01, 0x31, 0x01, 0x32, 0x02, 0x00, 0x02, 0x01,
    0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x02, 0x05,
    0x02, 0x06, 0x02, 0x07, 0x02, 0x08, 0x02, 0x09,
    0x02, 0x0a, 0x02, 0x0b, 0x02, 0x0c, 0x02, 0x0d,
    0x02, 0x0e, 0x02, 0x0f, 0x02, 0x10, 0x02, 0x11,
    0x02, 0x12, 0x02, 0x13, 0x02, 0x14, 0x02, 0x15,
    0x02, 0x16, 0x02, 0x17, 0x02, 0x18, 0x02, 0x19,
    0x02, 0x1a, 0x02, 0x1b, 0x02, 0x1c, 0x02, 0x1d,
    0x02, 0x1e, 0x02, 0x1f, 0x02, 0x20, 0x02, 0x21,
    0x02, 0x22, 0x02, 0x23, 0x02, 0x24, 0x02, 0x25,
    0x02, 0x26, 0x02, 0x27, 0x02, 0x28, 0x02, 0x29,
    0x02, 0x2a, 0x02, 0x2b, 0x02, 0x2c, 0x02, 0x2d,
    0x02, 0x2e, 0x02, 0x2f, 0x02, 0x30, 0x02, 0x31,
    0x02, 0x32, 0x03, 0x00, 0x03, 0x01, 0x03, 0x02,
    0x03, 0x03, 0x03, 0x04, 0x03, 0x05, 0x03, 0x06,
    0x03, 0x07, 0x03, 0x08, 0x03, 0x09, 0x03, 0x0a,
    0x03, 0x0b, 0x03, 0x0c, 0x03, 0x0d, 0x03, 0x0e,
    0x03, 0x0f, 0x03, 0x10, 0x03, 0x11, 0x03, 0x12,
    0x03, 0x13, 0x03, 0x14, 0x03, 0x15, 0x03, 0x16,
    0x03, 0x17, 0x03, 0x18, 0x03, 0x19, 0x03, 0x1a,
    0x03, 0x1b, 0x03, 0x1c, 0x03, 0x1d, 0x03, 0x1e,
    0x03, 0x1f, 0x03, 0x20, 0x03, 0x21, 0x03, 0x22,
    0x03, 0x23, 0x03, 0x24, 0x03, 0x25, 0x03, 0x26,
    0x03, 0x27, 0x03, 0x28, 0x03, 0x29, 0x03, 0x2a,
    0x03, 0x2b, 0x03, 0x2c, 0x03, 0x2d, 0x03, 0x2e,
    0x03, 0x2f, 0x03, 0x30, 0x03, 0x31, 0x03, 0x32,
    0x04, 0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03,
    0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07,
    0x04, 0x08, 0x04, 0x09, 0x04, 0x0a, 0x04, 0x0b,
    0x04, 0x0c, 0x04, 0x0d, 0x04, 0x0e, 0x04, 0x0f,
    0x04, 0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13,
    0x04, 0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17,
    0x04, 0x18, 0x04, 0x19, 0x04, 0x1a, 0x04, 0x1b,
    0x04, 0x1c, 0x04, 0x1d, 0x04, 0x1e, 0x04, 0x1f,
    0x04, 0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23,
    0x04, 0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27,
    0x04, 0x28, 0x04, 0x29, 0x04, 0x2a, 0x04, 0x2b,
    0x04, 0x2c, 0x04, 0x2d, 0x04, 0x2e, 0x04, 0x2f,
    0x04, 0x30, 0x04, 0x31, 0x04, 0x32, 0x05, 0x00
};

// LUT's which act on inputs in the range 0-5.

static BYTE Mult6plus40LUT[] =
{
    40, 40+6, 40+6*2, 40+6*3, 40+6*4, 40+6*5
};

static BYTE Mult36LUT[] =
{
    0, 36, 36*2, 36*3, 36*4, 36*5
};

// Halftone dither pattern arrays.

#define HALFTONE_SIZE 91

#if defined(_X86_)

// The following packed tables are used for the MMX implementation. To enable
// the MMX implementation, define HALFTONE_MMX. Define HALFTONE_SIZE to either
// 23 or 91 for the respective table. However, only 91 is currently supported
// because the C version does not support 23. Also, these tables should be
// moved to the HtTables files, along with the HALFTONE_SIZE definition.

#define HALFTONE_MMX

#if defined(HALFTONE_MMX)

#if (HALFTONE_SIZE == 23)

const DWORD HT_SuperCell_Packed[23*23] = {
    0x00220C18, 0x0010181F, 0x00180829, 0x00052A17, 0x00320225,         //  0
    0x001A2C04, 0x0020071B, 0x000F3111, 0x00041D2F, 0x000A131D,
    0x0021180F, 0x0027032A, 0x000F1E16, 0x0003322D, 0x002B2308,
    0x00261031, 0x00152901, 0x002B0326, 0x0009251C, 0x00261D07,
    0x000F1721, 0x001F0626, 0x00142C0E, 

    0x000C1D24, 0x002E2903, 0x00260F13, 0x001E2307, 0x0029190C,         //  1
    0x00021F32, 0x00151022, 0x002D1902, 0x0026280A, 0x00180929,
    0x00122F06, 0x002A0F19, 0x001B2802, 0x00200C12, 0x0018011C,
    0x000A1820, 0x001F0913, 0x000D2118, 0x0022120C, 0x00170529,
    0x00073115, 0x002A2205, 0x0003132C, 

    0x001B2608, 0x0016002F, 0x0001311A, 0x000E142D, 0x00130D1D,         //  2
    0x000A2F12, 0x00230417, 0x0007252C, 0x001E0D1A, 0x002F0014,
    0x000D2324, 0x00051A30, 0x002F061E, 0x000C1626, 0x00252B0C,
    0x00011D28, 0x00303005, 0x00190D2E, 0x00042723, 0x002F1903,
    0x001C0B30, 0x00102A1B, 0x00310911, 

    0x00240F15, 0x0009171F, 0x002C1E0D, 0x00200623, 0x002F2701,         //  3
    0x0019092A, 0x002B2108, 0x000E1425, 0x00132E0D, 0x00011D21,
    0x00251110, 0x001A2C0B, 0x00151E05, 0x0006252E, 0x002D1207,
    0x00162210, 0x0011052B, 0x0025160D, 0x000F2D1D, 0x00280F12,
    0x00131F09, 0x00270321, 0x00061A28, 

    0x001D2E02, 0x00290829, 0x00142406, 0x000C2D13, 0x00061B27,         //  4
    0x00271210, 0x00032B1E, 0x001C1A05, 0x0022052E, 0x002B2800,
    0x0009172B, 0x001F0418, 0x00270B21, 0x00103014, 0x001C0E1A,
    0x00210821, 0x00082916, 0x002D1C07, 0x001D0127, 0x000A2417,
    0x00012E2B, 0x0020130C, 0x000D2819, 

    0x0012200F, 0x00041522, 0x00191031, 0x00250317, 0x001D0D20,         //  5
    0x0011260B, 0x00170230, 0x00310F13, 0x000B2019, 0x0018081E,
    0x00122F0A, 0x00301027, 0x00082111, 0x002B0226, 0x0004192D,
    0x00282E02, 0x000E1325, 0x0002231B, 0x00160A32, 0x00231600,
    0x002C0723, 0x00191C06, 0x002E052F, 

    0x00220A16, 0x00312F08, 0x0008291A, 0x002A1903, 0x0000222C,         //  6
    0x002E1506, 0x000D2D17, 0x00250A23, 0x00062729, 0x00291610,
    0x00032431, 0x001B1C04, 0x000D2A1A, 0x00221507, 0x0017250E,
    0x00131E0A, 0x0032032A, 0x00200E13, 0x002A320A, 0x00101F11,
    0x00072A1B, 0x00140D29, 0x000A251E, 

    0x00011827, 0x001C012C, 0x00101D11, 0x001F0724, 0x0013320E,         //  7
    0x0023061C, 0x00051E27, 0x001D1902, 0x0015310D, 0x001F1108,
    0x00240122, 0x002C0D14, 0x0015052C, 0x0000311F, 0x002E0830,
    0x001F1018, 0x00052C1D, 0x00192605, 0x000D1A22, 0x001B102C,
    0x00300215, 0x001E300E, 0x00291204, 

    0x00172C0B, 0x00281013, 0x000B241E, 0x002F0D2A, 0x00171F09,         //  8
    0x000A1131, 0x002C2A10, 0x00110C1E, 0x002E042F, 0x000B1D17,
    0x00102C1B, 0x00062725, 0x001D1A10, 0x00291201, 0x00092323,
    0x000F1C11, 0x00260A27, 0x0009142E, 0x00280417, 0x0003241F,
    0x00251609, 0x00052030, 0x000E1B23, 

    0x00232703, 0x00130930, 0x00052E18, 0x00241600, 0x00022915,         //  9
    0x00200020, 0x00281804, 0x001B240A, 0x00031323, 0x00262303,
    0x0019082D, 0x002F1505, 0x0012210D, 0x00220729, 0x00182D09,
    0x002D0016, 0x001B2903, 0x0014210D, 0x002E2E07, 0x00180826,
    0x00112801, 0x00200E19, 0x002D061D, 

    0x00081424, 0x002F1F0E, 0x001E0528, 0x002A1B0C, 0x001A0A25,         // 10
    0x000F222D, 0x00063019, 0x0016052A, 0x00302D0E, 0x00081A28,
    0x001F0F12, 0x0002301D, 0x00270C2E, 0x00082918, 0x000E1720,
    0x00021331, 0x00230E1C, 0x00061B24, 0x00200B13, 0x000B172B,
    0x002C2D10, 0x001A032D, 0x000C2214, 

    0x00210C2A, 0x00182B07, 0x00101220, 0x0008251A, 0x00142C05,         // 11
    0x0032140F, 0x00250914, 0x000E1E1F, 0x00210D17, 0x00132809,
    0x002B0221, 0x000F2515, 0x00161C07, 0x00300427, 0x00201E0C,
    0x002A2706, 0x0012310F, 0x0031052A, 0x000F2A18, 0x00001F1E,
    0x0028110B, 0x00061B21, 0x00143005, 

    0x0005271B, 0x002B0115, 0x0001192F, 0x00230C12, 0x002C032B,         // 12
    0x000A1A26, 0x001E110A, 0x00012A2F, 0x00291703, 0x001B0726,
    0x000B2031, 0x00241400, 0x001C0923, 0x00042E12, 0x0014101D,
    0x0019032B, 0x00091822, 0x001C2301, 0x00241408, 0x00160131,
    0x001D2604, 0x00230A28, 0x0031180D, 

    0x00110F2D, 0x00261D0F, 0x001A3104, 0x000C2722, 0x001F1F0C,         // 13
    0x00042F1C, 0x00192306, 0x002D0222, 0x00112511, 0x00053219,
    0x0031110F, 0x00072B1C, 0x0029190B, 0x000C262F, 0x002D2204,
    0x00260B13, 0x0002201B, 0x002A082E, 0x000B2815, 0x002F0E25,
    0x00102C12, 0x00092217, 0x0019071F, 

    0x001E2408, 0x000A1524, 0x00300518, 0x00120F29, 0x00291601,         // 14
    0x00160732, 0x00250D16, 0x000B1D2A, 0x0023140C, 0x00150B2D,
    0x00211C08, 0x0019022B, 0x00120E25, 0x00230618, 0x00051520,
    0x000E2F27, 0x0020120B, 0x00142B0E, 0x00051820, 0x00181E0A,
    0x0028041C, 0x0003162B, 0x00252F01, 

    0x002A0219, 0x00022A31, 0x0017200B, 0x00220A1D, 0x00082C13,         // 15
    0x000F2720, 0x0030190E, 0x00052D1B, 0x001A2202, 0x002D0423,
    0x0001281F, 0x000F2114, 0x002E3002, 0x001D1B0D, 0x00162908,
    0x0032012C, 0x001B1C02, 0x00240519, 0x002E0B28, 0x001E3103,
    0x000C112F, 0x002D1C0D, 0x00140C22, 

    0x000F1928, 0x001C1011, 0x002D2E05, 0x0004182D, 0x002B2209,         // 16
    0x001A0127, 0x001F1304, 0x00130725, 0x0027102F, 0x000E2F12,
    0x001D1806, 0x00260828, 0x0006111C, 0x000B2332, 0x002A0D16,
    0x00101F12, 0x00042D23, 0x000C1530, 0x00112610, 0x00012018,
    0x00220924, 0x001A2D06, 0x00062314, 

    0x002E2802, 0x0024081F, 0x000D1C15, 0x00150424, 0x00210F19,         // 17
    0x000B1E2E, 0x00022B16, 0x002B260A, 0x00071A1D, 0x00210C17,
    0x000A252E, 0x002C150A, 0x00192B0F, 0x00220321, 0x00001829,
    0x0027071B, 0x00182306, 0x002C0E1D, 0x00271908, 0x0015012A,
    0x0031290F, 0x000D171E, 0x0020052D, 

    0x00051325, 0x000A2F19, 0x001A0C2A, 0x00272403, 0x0012310F,         // 18
    0x002F1507, 0x00240B1F, 0x0018052A, 0x00112010, 0x00312A04,
    0x00160025, 0x00031F19, 0x00140A2C, 0x00302603, 0x00123009,
    0x0021130F, 0x000A2A2D, 0x001F0414, 0x00052F22, 0x001B2401,
    0x00091332, 0x00290E15, 0x00171E09, 

    0x0011002F, 0x00232110, 0x0031150B, 0x0000281C, 0x001D0630,         // 19
    0x00081A26, 0x000D2313, 0x00273000, 0x00031431, 0x001C0722,
    0x0023120C, 0x002A3106, 0x000C1720, 0x001D0F14, 0x00081B26,
    0x002D0B1F, 0x001A1D02, 0x00101227, 0x002E0919, 0x00241B0D,
    0x00130620, 0x0002321A, 0x0025260E, 

    0x001E0A21, 0x00152B05, 0x00081B2C, 0x000F1122, 0x002B0916,         // 20
    0x00212C0A, 0x00150221, 0x001E0E1A, 0x002C190E, 0x000D2D1C,
    0x00071C28, 0x00102411, 0x00260430, 0x0004221B, 0x00292B0C,
    0x0016012F, 0x00022612, 0x00222D09, 0x0007172E, 0x000D2A25,
    0x002A2005, 0x00180C28, 0x00301A07, 

    0x00032515, 0x002D1026, 0x001C051A, 0x00282E01, 0x00172110,         // 21
    0x0003122B, 0x002F1D05, 0x0007292D, 0x00132208, 0x00240A14,
    0x00190F2D, 0x002D0818, 0x001E2D01, 0x00170B29, 0x00221505,
    0x000E201A, 0x002F0E23, 0x0027061E, 0x00172104, 0x001C0F16,
    0x00210212, 0x00092D2C, 0x000E161D, 

    0x00280331, 0x00073011, 0x00231F09, 0x000B162E, 0x00110B1E,         // 22
    0x0025250D, 0x000C1727, 0x00280D16, 0x001B0324, 0x00302B03,
    0x00012123, 0x0015270A, 0x00091220, 0x00311A0F, 0x00120624,
    0x00072E15, 0x001D1B0B, 0x0004142B, 0x00122F0F, 0x00320A30,
    0x0000271A, 0x002C110B, 0x001A2000 
};

#elif (HALFTONE_SIZE == 91)

const DWORD HT_SuperCell_Packed[91*91] = {
    0x00112005, 0x00262810, 0x001C081C, 0x00012422, 0x00242C0D,         //  0
    0x001E1704, 0x000F1E14, 0x001C0E32, 0x0012210A, 0x00180323,
    0x00312F07, 0x0010182C, 0x001F2B01, 0x002C0120, 0x00262D05,
    0x00130B26, 0x0032051E, 0x00021F16, 0x0027230B, 0x002D3201,
    0x000F112A, 0x00192107, 0x002D140D, 0x00092D1D, 0x000F1D15,
    0x00190F21, 0x00142103, 0x0006192E, 0x001B2610, 0x0003142C,
    0x00271C02, 0x001E0531, 0x00021A1A, 0x00250B13, 0x00071721,
    0x00131F0D, 0x00270E2C, 0x002D0312, 0x000D2522, 0x00251B0A,
    0x0031021C, 0x001E1D0F, 0x0001231A, 0x00142901, 0x00300113,
    0x00043129, 0x00280717, 0x00111A2F, 0x00031413, 0x000B2622,
    0x00282009, 0x00052E15, 0x00140330, 0x00092024, 0x0024150D,
    0x00022B32, 0x002C0A1B, 0x001E0421, 0x00262F0B, 0x002E2304,
    0x000B2C15, 0x001D062C, 0x00261D04, 0x00093011, 0x001E041E,
    0x00282B08, 0x00160920, 0x00310E18, 0x00102013, 0x00061821,
    0x000A2B2D, 0x00160416, 0x00232C04, 0x00032418, 0x001C180D,
    0x000D2D29, 0x00021515, 0x00301A08, 0x00062A19, 0x001C1014,
    0x002E1804, 0x002A0B12, 0x00051E1C, 0x00170125, 0x000C2F2B,
    0x001F120A, 0x0008272F, 0x002F031E, 0x00221E06, 0x00170831,
    0x001F320E, 

    0x00150A19, 0x0004192F, 0x00222F02, 0x000C1428, 0x00130B19,         //  1
    0x0029072C, 0x0006251E, 0x00222B01, 0x00270B28, 0x00052412,
    0x0029071D, 0x00011E18, 0x00150927, 0x001B110B, 0x000C1D1C,
    0x0019240E, 0x00202F03, 0x00101422, 0x00150932, 0x001D0114,
    0x00062C19, 0x0025062F, 0x001E1903, 0x00042627, 0x00320C11,
    0x00290632, 0x0021290A, 0x00110926, 0x00292F06, 0x00220720,
    0x000F2A15, 0x0009201E, 0x002A2B0B, 0x0010112C, 0x00192E06,
    0x001F0817, 0x0000231E, 0x001B1803, 0x00083030, 0x00130716,
    0x00052D2B, 0x00101126, 0x002D160C, 0x001B0F2C, 0x00081C1C,
    0x00251504, 0x000A2720, 0x002E2C07, 0x00200D1D, 0x0018072C,
    0x00301603, 0x000F1A27, 0x00200E1A, 0x00293009, 0x001C081F,
    0x000B2613, 0x00181A03, 0x00052128, 0x00111111, 0x00190D31,
    0x00061B25, 0x00291509, 0x0002241B, 0x00190E2D, 0x002C180D,
    0x00071330, 0x00211B00, 0x00033228, 0x00272609, 0x00180A1B,
    0x002E1202, 0x001D250C, 0x000C152B, 0x00310C23, 0x00110131,
    0x00252006, 0x0016081D, 0x00280C24, 0x000C1E31, 0x0023071F,
    0x0004272A, 0x000B3218, 0x001D0E30, 0x00312106, 0x00031915,
    0x0025091B, 0x00182D11, 0x00110D29, 0x00031522, 0x000B2A16,
    0x00300F24, 

    0x0029240A, 0x000E111F, 0x002C0215, 0x0017200A, 0x002F1A05,         //  2
    0x000A3126, 0x0019130F, 0x002C0419, 0x000B161F, 0x001E1B05,
    0x000E2930, 0x00221308, 0x002B2310, 0x0007282C, 0x002F0717,
    0x0003172F, 0x002A0329, 0x00251B07, 0x00042711, 0x00301027,
    0x000D1D1F, 0x002B0A11, 0x00102B1B, 0x0016022D, 0x001C2206,
    0x000D3119, 0x00021C1F, 0x0030150F, 0x00150E1B, 0x00082312,
    0x001A0C2B, 0x00321308, 0x00140128, 0x0021260F, 0x002D051D,
    0x000D1331, 0x00312C0C, 0x00161028, 0x002A2008, 0x001F0F11,
    0x002B0B1F, 0x00242507, 0x000B2B15, 0x00270520, 0x00172D0B,
    0x001F0930, 0x000F1E11, 0x001A0225, 0x00132210, 0x0025310C,
    0x0001291B, 0x00160512, 0x002D2606, 0x00041D2A, 0x00120219,
    0x00250F25, 0x002A2E0A, 0x000A142E, 0x0031280D, 0x00240418,
    0x000E311D, 0x002F0B12, 0x00112A24, 0x00240117, 0x00132E06,
    0x000C2523, 0x002B031C, 0x001B1110, 0x000B162E, 0x00210124,
    0x00112F10, 0x00041D27, 0x0029051A, 0x00183111, 0x0021290A,
    0x002C0F17, 0x0008262D, 0x001F2F02, 0x00121211, 0x0019220B,
    0x00280223, 0x00141B01, 0x0025130D, 0x000F2B1E, 0x001C0524,
    0x002E2303, 0x00061326, 0x002B1C0E, 0x00272501, 0x001D0013,
    0x00061C2C, 

    0x00190728, 0x00212B0F, 0x0007272B, 0x001E0D21, 0x00032531,         //  3
    0x00260116, 0x00122108, 0x00001C2D, 0x00152F0C, 0x002F102A,
    0x00180214, 0x00093125, 0x00120C20, 0x00271A04, 0x001F300D,
    0x000A121F, 0x000F2613, 0x00180D1A, 0x00092D2C, 0x0022170C,
    0x00172904, 0x00022225, 0x00230F14, 0x002C1B0B, 0x00051423,
    0x00261013, 0x0017002B, 0x001E2700, 0x000D1F30, 0x002C0327,
    0x0024190E, 0x00053122, 0x001C1C01, 0x000A2116, 0x00031824,
    0x00242804, 0x00061C13, 0x00220021, 0x000E1617, 0x00022925,
    0x00151E02, 0x001A0232, 0x00051A24, 0x00122105, 0x002C0C27,
    0x00002415, 0x0032111A, 0x0005192B, 0x00291204, 0x00071B32,
    0x001D0F26, 0x00230A20, 0x0008142F, 0x001A2B10, 0x00301805,
    0x000E232C, 0x001F0917, 0x0014001F, 0x001B1F01, 0x00021723,
    0x001F2207, 0x0016072F, 0x001E1F03, 0x0004122A, 0x00321C0F,
    0x00170C19, 0x00062A2C, 0x00121F0A, 0x002F2D05, 0x00002317,
    0x002B0E31, 0x00241806, 0x00082121, 0x00141100, 0x00011C1F,
    0x000F1628, 0x001A0313, 0x002D1B0D, 0x00022A2C, 0x00321606,
    0x000E2E1B, 0x00200A28, 0x00012513, 0x00290D2C, 0x00131D08,
    0x000A2A31, 0x001A0419, 0x00203009, 0x00150C2E, 0x000E171D,
    0x00232E05, 

    0x00002122, 0x00121B00, 0x0031051A, 0x000F1812, 0x00232C0C,         //  4
    0x001A0A1D, 0x00320F24, 0x00202A05, 0x00280622, 0x00062518,
    0x00251F02, 0x002E150E, 0x001B051B, 0x00022131, 0x00160024,
    0x00242B00, 0x002D1E0B, 0x001D0722, 0x002B2103, 0x0012041D,
    0x00280C30, 0x001B1508, 0x0009302B, 0x0013081E, 0x00202C02,
    0x000A2428, 0x002D180B, 0x00072D21, 0x00271108, 0x00012B18,
    0x00172504, 0x00111030, 0x002B071A, 0x00260B2C, 0x00172F09,
    0x00120E29, 0x002B091A, 0x00092F2E, 0x001D2306, 0x0030072B,
    0x0008301B, 0x0022120D, 0x00310919, 0x001D3210, 0x000C132B,
    0x00222A01, 0x00140522, 0x001E2F08, 0x000B251F, 0x002D0417,
    0x0011210A, 0x002A2E01, 0x000C2416, 0x00241023, 0x0015120D,
    0x00013221, 0x00081D12, 0x002D2A08, 0x00260E26, 0x000C2E2C,
    0x002B1110, 0x00072B21, 0x0027170C, 0x000E281E, 0x001B0527,
    0x00202302, 0x00290815, 0x00240F25, 0x001E0620, 0x00151B0E,
    0x0019071D, 0x000E2A13, 0x001C082C, 0x002D250D, 0x0027062F,
    0x001E2E08, 0x0007221C, 0x00260922, 0x00150E27, 0x001D0513,
    0x0005202E, 0x002C1A0A, 0x00190621, 0x00082F19, 0x0023160C,
    0x002B0A13, 0x000F1820, 0x0001212A, 0x00320617, 0x00082724,
    0x002D130D, 

    0x00260219, 0x001C1409, 0x000A302F, 0x00281026, 0x00141E03,         //  5
    0x0005162B, 0x00092713, 0x000F1830, 0x001C0D12, 0x0013091D,
    0x000C192E, 0x00052C28, 0x00232506, 0x00101812, 0x00300F19,
    0x00120A28, 0x00061630, 0x000E3115, 0x00001226, 0x001F1C0F,
    0x00072E17, 0x002F0121, 0x00241E0F, 0x000E2719, 0x00310431,
    0x001A1F0E, 0x00110B1B, 0x0022052D, 0x00131D10, 0x001C0C24,
    0x002F061D, 0x00202009, 0x00082C12, 0x000E161F, 0x0030240E,
    0x00200422, 0x001A1F03, 0x0014130C, 0x00260B1D, 0x00101B13,
    0x0028150A, 0x000D2721, 0x00021F2E, 0x00151709, 0x0029001E,
    0x00061A13, 0x002B210C, 0x00170D2F, 0x00230813, 0x000E2C24,
    0x001B180F, 0x0014012D, 0x00031B1D, 0x002B0629, 0x001E2103,
    0x002E0531, 0x00220C1C, 0x0010152B, 0x00052513, 0x0018061A,
    0x00221C05, 0x00130217, 0x002F0E2C, 0x00093114, 0x002A1A08,
    0x00021431, 0x000F301C, 0x000B1711, 0x0005292F, 0x00282601,
    0x0009142B, 0x00322E08, 0x00220F18, 0x00061726, 0x000C2B15,
    0x00300B24, 0x00141303, 0x000C3017, 0x002A1905, 0x0008261F,
    0x00230C18, 0x00132906, 0x000C1530, 0x00312204, 0x001D032A,
    0x00041F26, 0x0021290E, 0x00261205, 0x00122C10, 0x001E1A07,
    0x00150D32, 

    0x000E2225, 0x002A2810, 0x0017081E, 0x00022415, 0x002D0622,         //  6
    0x001F2F0A, 0x002B0319, 0x00252000, 0x00023126, 0x00302907,
    0x001F120C, 0x00170622, 0x00290D15, 0x00092E2A, 0x001E1E09,
    0x0018270F, 0x0029041D, 0x00212408, 0x0031092E, 0x00182706,
    0x000C182A, 0x00152401, 0x00041128, 0x00291707, 0x00160E15,
    0x00013025, 0x002A1304, 0x00052417, 0x002D310A, 0x000A162E,
    0x000F2815, 0x00031A2A, 0x002A0226, 0x001B1E02, 0x00011232,
    0x000D2715, 0x0006192B, 0x002F2B10, 0x00032527, 0x001B0330,
    0x00162C00, 0x001F0526, 0x002E0D16, 0x00252403, 0x00092D2D,
    0x001C0B25, 0x000E2819, 0x00051528, 0x002F1D02, 0x0001281C,
    0x00260E28, 0x00311305, 0x0019300B, 0x000F2513, 0x00091719,
    0x001A2808, 0x00131A0F, 0x00282F02, 0x001D0A20, 0x0030190A,
    0x000E2D32, 0x00002625, 0x001C1F00, 0x0021041B, 0x00110C22,
    0x0015270F, 0x00301D05, 0x001A0029, 0x002D1F0A, 0x00110A1A,
    0x00200322, 0x00021C28, 0x0017270C, 0x0012011D, 0x001A1F07,
    0x00231A10, 0x00052829, 0x00210230, 0x001A1F0A, 0x0010132B,
    0x002F310E, 0x001C0124, 0x00271012, 0x00062B1E, 0x00160F15,
    0x00113100, 0x002F0C1D, 0x0018012E, 0x00051E27, 0x0029091F,
    0x00093114, 

    0x00301107, 0x00061D2D, 0x001E170D, 0x00252C05, 0x000D122E,         //  7
    0x00122210, 0x00180B27, 0x000B1320, 0x001A1C0E, 0x0027012A,
    0x000F231A, 0x002D1D04, 0x0001282E, 0x0021021B, 0x000D1121,
    0x00252F05, 0x00031B25, 0x00111410, 0x00092C19, 0x00250F1F,
    0x002C0513, 0x00210C1C, 0x001B2A0D, 0x0008212D, 0x001F0621,
    0x00261B09, 0x000E2A1F, 0x001E0828, 0x00181A01, 0x00240121,
    0x0028120D, 0x00182E04, 0x00220E19, 0x00142A0C, 0x002C0A1D,
    0x00253208, 0x00290218, 0x00110E23, 0x00231505, 0x00081F17,
    0x002B101F, 0x00041C12, 0x000E292A, 0x001A061C, 0x00131110,
    0x00301D06, 0x00270320, 0x001F300B, 0x00131210, 0x001D0531,
    0x000C1F13, 0x00072A1A, 0x001F0C22, 0x0027082F, 0x00032D27,
    0x0029011E, 0x000B1225, 0x00021F2F, 0x00150417, 0x00082328,
    0x0024130D, 0x002B091D, 0x00171110, 0x0004252E, 0x002C2E0B,
    0x001D0728, 0x0026101F, 0x00032B16, 0x00140D24, 0x001D2F10,
    0x00291605, 0x00102114, 0x00250C30, 0x002D3202, 0x0003112D,
    0x002A0620, 0x0017220B, 0x002E0F1D, 0x00022C12, 0x00250726,
    0x00161D01, 0x0003181A, 0x000F2429, 0x00221B08, 0x002C0822,
    0x000A2431, 0x001C180D, 0x000D2719, 0x002D1302, 0x0017230B,
    0x00220629, 

    0x001A2D03, 0x00110321, 0x002E0E17, 0x00081F28, 0x001B001A,         //  8
    0x002F1B04, 0x00062E2F, 0x002A2609, 0x00140917, 0x00051732,
    0x000A2D14, 0x001D0B1F, 0x0012150F, 0x00321A02, 0x00062331,
    0x002A0B17, 0x0016072C, 0x002D2001, 0x001D0228, 0x00131D0B,
    0x00023131, 0x000E1A24, 0x00300817, 0x00122E05, 0x002D1113,
    0x000A232A, 0x00150312, 0x00300F32, 0x0008211A, 0x00122C10,
    0x0005242C, 0x0031091E, 0x000A182F, 0x00102011, 0x001D0629,
    0x00091B21, 0x00182201, 0x001F082E, 0x000C2F1C, 0x002E280E,
    0x00130A2C, 0x001C3105, 0x0027140C, 0x00061922, 0x00222F0A,
    0x0001262F, 0x00170916, 0x00091A2B, 0x002C2506, 0x00280A1F,
    0x00182309, 0x0024042C, 0x00121C10, 0x002F1404, 0x00151E09,
    0x001C0D14, 0x0032240D, 0x00232B06, 0x002C0F22, 0x001F3003,
    0x00130115, 0x000A2923, 0x00271B07, 0x000D1729, 0x00232003,
    0x000E1319, 0x00082213, 0x0020042D, 0x002B2403, 0x000E1C32,
    0x0004111D, 0x00302C0B, 0x001B0818, 0x00081624, 0x001F2510,
    0x000B2D19, 0x00110A2B, 0x001F1802, 0x000E2416, 0x002B0D20,
    0x000A2A32, 0x001F0B14, 0x00302D0B, 0x0019032D, 0x00011319,
    0x00291D07, 0x00240514, 0x00032E22, 0x001F102D, 0x000F2A15,
    0x0004191B, 

    0x00211510, 0x0001252A, 0x00233109, 0x00150A1F, 0x00282A0B,         //  9
    0x00021723, 0x00230E14, 0x001C041D, 0x00312A03, 0x00201023,
    0x00292106, 0x00160428, 0x0026320A, 0x00190723, 0x00102A13,
    0x001B170B, 0x000B2C1E, 0x00230E15, 0x00072623, 0x00291507,
    0x001A2810, 0x00241203, 0x000A1E27, 0x0028011E, 0x00032830,
    0x001D1504, 0x00231D0C, 0x00022F16, 0x002A1407, 0x00210B26,
    0x00161D06, 0x001E0415, 0x00023023, 0x002E2508, 0x00231014,
    0x0004152C, 0x00132D10, 0x0031120B, 0x00021D28, 0x00181807,
    0x00250121, 0x000A2214, 0x002C0831, 0x00101F17, 0x002E0228,
    0x001B1601, 0x000D211D, 0x00230D13, 0x00052B26, 0x00101617,
    0x00023129, 0x002D1901, 0x000B2B25, 0x00052619, 0x00210921,
    0x000D312D, 0x00061629, 0x0018071D, 0x000F1C12, 0x0003172A,
    0x002F2009, 0x001C0C2F, 0x0006311A, 0x00310F12, 0x00180120,
    0x00012930, 0x002E180E, 0x0016320A, 0x000A1521, 0x00260615,
    0x00082827, 0x0015022C, 0x000D2420, 0x00271A09, 0x00130329,
    0x00301D06, 0x0025130F, 0x00083122, 0x0019032E, 0x00221206,
    0x0014200F, 0x0029051D, 0x00071426, 0x00132104, 0x001F280F,
    0x000D2C24, 0x00150B2B, 0x00311604, 0x00081F11, 0x00270220,
    0x002C0B30, 

    0x000C2124, 0x0018061A, 0x002B1B01, 0x000B1431, 0x00102212,         // 10
    0x0020072B, 0x000A2511, 0x000F1C27, 0x0008152D, 0x00132F0B,
    0x00031B12, 0x002F0F2D, 0x0009261D, 0x00031D2A, 0x002B0D19,
    0x00200126, 0x00302304, 0x00011A2F, 0x000F2E12, 0x0031092A,
    0x0016031B, 0x0005222D, 0x001F2F09, 0x0014160E, 0x00190C19,
    0x00102D21, 0x00290925, 0x000F261D, 0x001B052B, 0x000B1820,
    0x0026290C, 0x000F112D, 0x00291500, 0x0019001C, 0x000D2C25,
    0x00281F05, 0x001D0419, 0x000F2424, 0x002A0713, 0x001F0D30,
    0x000D261A, 0x00011326, 0x001F2C03, 0x00140C1D, 0x000A2A12,
    0x00260F25, 0x002B310C, 0x00120730, 0x00321F03, 0x001C0021,
    0x0022110E, 0x0014071D, 0x00200F15, 0x00190232, 0x002C210E,
    0x00251B00, 0x00130318, 0x001E2708, 0x002A0A31, 0x000B2B17,
    0x0016061F, 0x00251501, 0x00102326, 0x00140617, 0x00202C06,
    0x00290B24, 0x00121D01, 0x001C0E27, 0x0031091A, 0x00232E08,
    0x00191805, 0x00201F0F, 0x002E1200, 0x00022E15, 0x001D0D1D,
    0x00062A31, 0x00160725, 0x00282608, 0x00051B1B, 0x00322E0D,
    0x0000172C, 0x001B2603, 0x000D3121, 0x00260A13, 0x002E0E2F,
    0x0007181E, 0x0022220B, 0x0018041C, 0x00103226, 0x001B1B06,
    0x0013270A, 

    0x0031120E, 0x00270C2D, 0x00082814, 0x001D0322, 0x00322C07,         // 11
    0x0017111C, 0x002C3101, 0x00250B19, 0x00192310, 0x002C0221,
    0x0021081A, 0x000E2C16, 0x001E1700, 0x00241210, 0x00152007,
    0x0006302C, 0x00121310, 0x00190521, 0x00260C18, 0x001F1702,
    0x000C251F, 0x00280F14, 0x002F0622, 0x00091B2B, 0x00262200,
    0x00320314, 0x0006192D, 0x00181202, 0x002F220A, 0x00042E13,
    0x002C0729, 0x0009231A, 0x00222A0F, 0x00061D31, 0x00150E11,
    0x002C0A1F, 0x0009292F, 0x00231707, 0x0006301F, 0x00141F01,
    0x00282A0F, 0x00321A09, 0x0019042A, 0x0025230D, 0x00031B2E,
    0x00170519, 0x00062621, 0x001E1308, 0x0016190F, 0x000A2D2D,
    0x002A2606, 0x00071E2B, 0x00312E0B, 0x00111805, 0x000B2927,
    0x0000111F, 0x002F2D10, 0x00081424, 0x00261F0C, 0x001A1027,
    0x002C250E, 0x00022D14, 0x001E092B, 0x002A1F0B, 0x0005132D,
    0x000C241B, 0x00250314, 0x00062A2B, 0x000F2012, 0x0000252F,
    0x00130F25, 0x00290B18, 0x000B2830, 0x00190424, 0x002B220E,
    0x00221603, 0x000F1F16, 0x002E0E13, 0x001E0828, 0x000C221F,
    0x00120216, 0x002D1029, 0x00231D09, 0x0003191B, 0x001A0028,
    0x00122F02, 0x002A1210, 0x00002930, 0x002E0F13, 0x00240928,
    0x00032C18, 

    0x001E1E05, 0x0005181D, 0x00122E0C, 0x00220E28, 0x00031E17,         // 12
    0x0007182E, 0x001C0122, 0x0013280B, 0x00001129, 0x00271D07,
    0x0006252F, 0x001A0C23, 0x0012210C, 0x002E0330, 0x000B2821,
    0x0028091C, 0x001D1C08, 0x002C280C, 0x00082128, 0x0013320A,
    0x00021A2F, 0x001A2B04, 0x00110A1A, 0x001D2710, 0x00001126,
    0x00212B08, 0x000B201B, 0x001F320F, 0x00120131, 0x00230E18,
    0x00161E05, 0x001C0C22, 0x00131A09, 0x00300827, 0x001F3103,
    0x00002215, 0x001B1A0A, 0x00160C27, 0x002D0216, 0x000A142C,
    0x001B0623, 0x00110F15, 0x00093120, 0x002A1104, 0x00201710,
    0x00302C07, 0x000C1D2C, 0x00240317, 0x00002324, 0x00270B19,
    0x000E1713, 0x001A091F, 0x00022226, 0x00271311, 0x001C061B,
    0x00290B2E, 0x00172006, 0x001F082B, 0x00113202, 0x0007191B,
    0x0021022F, 0x000D111E, 0x002E1704, 0x000A2820, 0x001B1B0F,
    0x002F3008, 0x001F1023, 0x00171605, 0x002C061F, 0x001E1B0C,
    0x002F011C, 0x000F3012, 0x00061D1F, 0x0026140A, 0x00110A2B,
    0x0003301B, 0x001B0021, 0x00092D2D, 0x00151500, 0x0027290B,
    0x00200B24, 0x00062C11, 0x0017072E, 0x00312A0C, 0x000E2517,
    0x00271F08, 0x001C0723, 0x000B1A19, 0x001F2500, 0x0008161E,
    0x0016052F, 

    0x000E2625, 0x0024012A, 0x002E2403, 0x0015081F, 0x0026140F,         // 13
    0x002B2905, 0x000C2014, 0x00300830, 0x001F1903, 0x000B2D1F,
    0x0016140E, 0x00312904, 0x00270827, 0x00012F17, 0x00181903,
    0x00220E15, 0x000D2D24, 0x00031532, 0x0020101B, 0x002E0214,
    0x00230B24, 0x0029140F, 0x00061E2D, 0x002D3006, 0x0017051F,
    0x000F1630, 0x002C0813, 0x00260C28, 0x00011A24, 0x000D261E,
    0x002E130E, 0x00022D2D, 0x0029021C, 0x00072616, 0x000D1521,
    0x0024032C, 0x0031101A, 0x00102E11, 0x00252505, 0x0002211C,
    0x00202C0C, 0x002B092F, 0x00041F18, 0x000D262B, 0x00120725,
    0x001A0C1F, 0x00281500, 0x00102F12, 0x002E0F2A, 0x00202909,
    0x00150431, 0x002C3202, 0x001F0D18, 0x00091C2F, 0x00143007,
    0x0021240C, 0x000E1715, 0x00052819, 0x00300422, 0x00242210,
    0x00132A06, 0x00191C0C, 0x00042F25, 0x00240316, 0x00150F28,
    0x00110732, 0x00021A17, 0x00282E0E, 0x0009272D, 0x00191302,
    0x00042A29, 0x00221706, 0x001D062D, 0x00142B04, 0x00312510,
    0x000C1A26, 0x002A1206, 0x0025230F, 0x00021C1A, 0x00191031,
    0x002C1E07, 0x0011161D, 0x001E2202, 0x000B1321, 0x00210532,
    0x0004151E, 0x00150D2A, 0x002C2D0D, 0x0011012C, 0x00272110,
    0x002C3008, 

    0x001C0B15, 0x00181112, 0x00011B1A, 0x000D3131, 0x001A2109,         // 14
    0x0011052A, 0x00221024, 0x00052F1A, 0x000F2412, 0x002C0F27,
    0x00230515, 0x00091A2C, 0x00101E11, 0x0021101E, 0x0007242E,
    0x00310428, 0x00141F05, 0x002A0712, 0x00172507, 0x00101C2B,
    0x000A291E, 0x0016230A, 0x0020001C, 0x000C1829, 0x00270D16,
    0x001A250B, 0x00071E1D, 0x00142906, 0x002B150C, 0x00192E01,
    0x001F0426, 0x000C2413, 0x00231704, 0x001A0F2F, 0x00282C07,
    0x0013200D, 0x00052829, 0x000B1C22, 0x001D0832, 0x002F1109,
    0x000E1A28, 0x00182702, 0x0024160F, 0x001D031C, 0x002C2E0B,
    0x00022115, 0x00092832, 0x00140A20, 0x001A2004, 0x0004151C,
    0x00081E27, 0x0024250D, 0x00120121, 0x002F2B0F, 0x00031124,
    0x002C0229, 0x000A1D1F, 0x00280C31, 0x0018110A, 0x00011526,
    0x002C0B2A, 0x00270718, 0x00111F2D, 0x00320C11, 0x00202701,
    0x000B2B1D, 0x002D2007, 0x00140226, 0x00210C19, 0x000C1F22,
    0x00280A16, 0x0015240D, 0x002C1024, 0x00011F1A, 0x00210D16,
    0x00170630, 0x001F290B, 0x00120B2A, 0x00300422, 0x000D3112,
    0x0007252A, 0x00250118, 0x00022F25, 0x002A0D14, 0x0013200E,
    0x002F2E05, 0x00082715, 0x00241D09, 0x00190B24, 0x0002111A,
    0x000B1921, 

    0x00302D01, 0x0009272C, 0x00271508, 0x002D0424, 0x00200D13,         // 15
    0x00022C1E, 0x002A1D02, 0x0019160C, 0x0027022D, 0x00120A1C,
    0x001A250A, 0x00053121, 0x001E001A, 0x002C1508, 0x00122C10,
    0x001B130C, 0x000A2A1C, 0x00260D2D, 0x00063021, 0x001D1601,
    0x00320912, 0x00042E31, 0x002B1203, 0x0014290E, 0x00041D23,
    0x00312D02, 0x0022022C, 0x001D1121, 0x00092215, 0x0024092F,
    0x00051F18, 0x00310B29, 0x0015300C, 0x000F1E23, 0x002F0612,
    0x00180C1E, 0x00201400, 0x002B0417, 0x0014180F, 0x0007321F,
    0x00280013, 0x00130D24, 0x00302D08, 0x0006132D, 0x00151C06,
    0x00221128, 0x0031011A, 0x001F1B0D, 0x00290529, 0x000D2E12,
    0x00300C16, 0x00181907, 0x000C142C, 0x00252005, 0x001D091C,
    0x00182601, 0x0023140D, 0x00122F11, 0x001D2A05, 0x000E1E16,
    0x0009261F, 0x001E2D03, 0x0007141C, 0x001A230A, 0x00031822,
    0x00270A2A, 0x001C140C, 0x0005242F, 0x00261210, 0x0012310A,
    0x00310531, 0x00072C1D, 0x000D1813, 0x0028022B, 0x00093222,
    0x002E1601, 0x00041E14, 0x000B2C1D, 0x00201804, 0x00280717,
    0x001B0F11, 0x002E1905, 0x0015092D, 0x001C2908, 0x00061B2B,
    0x00260B26, 0x001E031C, 0x000F172F, 0x00322303, 0x00142B0E,
    0x00220430, 

    0x00041F1B, 0x00130720, 0x001E1D0E, 0x000C2A18, 0x0007232D,         // 16
    0x0030140E, 0x00150628, 0x00092718, 0x001E2007, 0x00012E24,
    0x002D1801, 0x00250D31, 0x00162106, 0x0003272A, 0x00280720,
    0x00231B01, 0x00022226, 0x001F0116, 0x002D120D, 0x000D2029,
    0x00250418, 0x001B0E25, 0x000F2015, 0x0024092D, 0x001D0619,
    0x000B1326, 0x00121910, 0x00033019, 0x002F0529, 0x00160F11,
    0x00102B1F, 0x00271906, 0x00091215, 0x0021092A, 0x0004291A,
    0x000A1C30, 0x0025300A, 0x0001242D, 0x00192904, 0x00230B2B,
    0x000C2319, 0x00001E30, 0x0021061E, 0x000F2516, 0x00280823,
    0x000B2A12, 0x00181605, 0x00073022, 0x00112408, 0x00231030,
    0x001C0624, 0x00012A1A, 0x00290B28, 0x00062814, 0x0010192E,
    0x00082D18, 0x00320527, 0x0003222C, 0x002A091B, 0x0023002F,
    0x0030190B, 0x00151013, 0x002B0431, 0x000D3227, 0x002C0114,
    0x00171E04, 0x000E2E1B, 0x002F0515, 0x001A2800, 0x00021624,
    0x001F1C05, 0x001A0F28, 0x0024210A, 0x00122905, 0x001D110F,
    0x000F241F, 0x001A022D, 0x002C1026, 0x0015240C, 0x00011D2F,
    0x00102B27, 0x0009271E, 0x00221F0F, 0x000D1220, 0x002C061A,
    0x00182501, 0x000B1312, 0x00033022, 0x00210618, 0x00081B28,
    0x0029130B, 

    0x00180E2A, 0x00233005, 0x002B0A28, 0x00161302, 0x001B021C,         // 17
    0x00241B06, 0x000E321F, 0x00210B32, 0x0032120F, 0x000C1C16,
    0x00141028, 0x000E2B12, 0x00300917, 0x000B1D24, 0x00180E14,
    0x000E3230, 0x00300A12, 0x0011181F, 0x00152809, 0x00012D22,
    0x00181A06, 0x0008261D, 0x002C1708, 0x00023120, 0x002E2205,
    0x00162A0C, 0x002A0A32, 0x00261E03, 0x001A2708, 0x000A1424,
    0x002C1D0D, 0x001C0231, 0x00012720, 0x002D2002, 0x001B150E,
    0x002A0124, 0x00121015, 0x002D0926, 0x000F1F1B, 0x00321208,
    0x001D170D, 0x002A2B01, 0x00180F12, 0x00081A29, 0x001B3103,
    0x002C0D2F, 0x00012016, 0x0026072C, 0x002D130F, 0x00052B1E,
    0x00142201, 0x002E1C10, 0x001E300A, 0x0016041F, 0x002D1012,
    0x00201F08, 0x00140D20, 0x001B1603, 0x000A1C24, 0x00122E07,
    0x00190D29, 0x00022423, 0x00242A0D, 0x00141A05, 0x00210E18,
    0x0009292E, 0x00230823, 0x00071B29, 0x002A0D1F, 0x000B212D,
    0x002C001A, 0x00062E12, 0x00160720, 0x00300C30, 0x00021C29,
    0x002A2E07, 0x00250912, 0x00091519, 0x00232F08, 0x001C0D20,
    0x002B0914, 0x00171401, 0x00310331, 0x00033116, 0x0021180C,
    0x00102C30, 0x00291F09, 0x00170F2A, 0x002C2906, 0x001B0A1F,
    0x000D2513, 

    0x002F0016, 0x00072324, 0x00111912, 0x00002730, 0x00292E0B,         // 18
    0x00120A2A, 0x00032413, 0x00291705, 0x00062B22, 0x001B022E,
    0x002A280B, 0x0020061F, 0x0006172D, 0x001D2E03, 0x002B031B,
    0x00201508, 0x0005262B, 0x001A1E04, 0x0022092E, 0x00270513,
    0x002E102B, 0x00112B0D, 0x0020042F, 0x001A0C13, 0x00091A2B,
    0x0021031F, 0x00062614, 0x000D161C, 0x001F082D, 0x00022F17,
    0x00222403, 0x0017101A, 0x0012320A, 0x0026052D, 0x000D2D18,
    0x00162205, 0x001E2A0C, 0x00061A1F, 0x00220212, 0x000B2F27,
    0x00150521, 0x0007252C, 0x00250A19, 0x0030210A, 0x00130320,
    0x0023180C, 0x000F271B, 0x00150B26, 0x001D1E06, 0x000C1818,
    0x00270028, 0x00091321, 0x0011082F, 0x00241802, 0x00042423,
    0x00280132, 0x000C3115, 0x0026270C, 0x002D1111, 0x0004221E,
    0x00200617, 0x00291F00, 0x000B151B, 0x001C072C, 0x0001211F,
    0x0031160B, 0x00111111, 0x001E230E, 0x00143008, 0x00180A16,
    0x00232A0C, 0x0010132B, 0x00281A01, 0x000A2616, 0x0021031B,
    0x0015170D, 0x00102122, 0x00052831, 0x00321B03, 0x00120029,
    0x0004221A, 0x00242D0B, 0x000B1C25, 0x001D2306, 0x00120C23,
    0x002F0128, 0x00071A1C, 0x00240816, 0x0012200E, 0x00011632,
    0x00262B08, 

    0x000E1C2E, 0x001C140B, 0x00210519, 0x00310C1F, 0x00081F23,         // 19
    0x001D1117, 0x002E0426, 0x00181E0B, 0x0013081D, 0x00232202,
    0x0002151A, 0x00191E07, 0x00282611, 0x0014120E, 0x00002227,
    0x000D2B21, 0x00260417, 0x002B130E, 0x000D3025, 0x0006221A,
    0x001E1502, 0x000A1E1C, 0x00260F27, 0x00142D04, 0x000E141A,
    0x002B2007, 0x00181025, 0x00322D0B, 0x00130120, 0x002E0D12,
    0x000E1726, 0x0029072B, 0x000A1C14, 0x001F0D26, 0x0005191E,
    0x00300B2F, 0x00091428, 0x00272102, 0x00190E30, 0x00022717,
    0x002C1C0F, 0x00201106, 0x00102E25, 0x00021531, 0x001F290F,
    0x0006112A, 0x002F2D01, 0x00210220, 0x00032613, 0x00320D2E,
    0x001A2D05, 0x0021260B, 0x0005201C, 0x00302E0F, 0x000D1128,
    0x00192A05, 0x00011A1D, 0x001E0C26, 0x0013032D, 0x00252C09,
    0x000E1330, 0x00073013, 0x002E0C24, 0x00102711, 0x002A2F07,
    0x00190328, 0x00252B05, 0x00031831, 0x0029041D, 0x000D1526,
    0x00301E06, 0x0000241D, 0x001F0924, 0x00192F09, 0x000D1226,
    0x002E2B03, 0x001C0F2B, 0x00210513, 0x000C131D, 0x00282A0E,
    0x001F102E, 0x00071613, 0x0029062A, 0x00150F1A, 0x00262A0E,
    0x00001514, 0x001C2F03, 0x000E262C, 0x0030031D, 0x00203200,
    0x00151021, 

    0x00032A11, 0x002D2402, 0x000A302C, 0x001A1C07, 0x00152C0D,         // 20
    0x00261701, 0x000D282D, 0x00083019, 0x00270E2A, 0x000F2D12,
    0x00300C2C, 0x00083126, 0x00110120, 0x00220A31, 0x002E1D05,
    0x001C170C, 0x00130E29, 0x0008281E, 0x00171B09, 0x00300B32,
    0x00142C0F, 0x002A0223, 0x00032316, 0x0031270C, 0x00240622,
    0x00003030, 0x001E110F, 0x00051C2A, 0x00242202, 0x00082A30,
    0x001D1F08, 0x00042C1E, 0x00312504, 0x00141310, 0x00282807,
    0x001A0313, 0x000E311A, 0x002C0611, 0x00112B1D, 0x00251504,
    0x001A072D, 0x000C221C, 0x002E0114, 0x00161C03, 0x002A071D,
    0x000D2218, 0x001A1B0B, 0x00091531, 0x0028300E, 0x0016071A,
    0x000E1C29, 0x00290A15, 0x00150F2B, 0x001B1B07, 0x0022061A,
    0x002B1510, 0x0011082C, 0x002F2101, 0x0006281A, 0x001A1A0E,
    0x00310A25, 0x00181C07, 0x001F012A, 0x00261017, 0x00051C30,
    0x00150A1B, 0x00091F22, 0x002E0E18, 0x001F2602, 0x00052D2C,
    0x001C0F12, 0x00140230, 0x002E160E, 0x00072114, 0x002A0B2E,
    0x00041E1E, 0x00260817, 0x0014310A, 0x00031D26, 0x001A2506,
    0x00150922, 0x002E1B07, 0x00112F1F, 0x001B2702, 0x000B192E,
    0x002C051F, 0x0021120B, 0x00081C23, 0x001A0D12, 0x00061927,
    0x00290918, 

    0x0023022A, 0x00140F1C, 0x00280726, 0x000D1315, 0x002C0131,         // 21
    0x00022211, 0x0022081F, 0x001A1304, 0x002C1B0D, 0x001F0423,
    0x000B2316, 0x0024130A, 0x002C1B01, 0x00042C1C, 0x00170D16,
    0x0009302E, 0x00320713, 0x001E2100, 0x00230122, 0x00041217,
    0x001C2707, 0x000F182D, 0x001A0811, 0x000B1629, 0x001C1D01,
    0x00130B15, 0x00272409, 0x000E171B, 0x00180E14, 0x002B0523,
    0x0015130D, 0x00230A17, 0x00190123, 0x0008212A, 0x00222C0B,
    0x00001D2B, 0x00211123, 0x00172407, 0x00051B29, 0x00300D22,
    0x0013310D, 0x00041828, 0x00242A09, 0x001B0C23, 0x00072D2C,
    0x00260E14, 0x00140426, 0x002C2307, 0x00101122, 0x00242002,
    0x0000141F, 0x000B3211, 0x002E0224, 0x00032A30, 0x0013260C,
    0x00071E22, 0x001C2D09, 0x00221013, 0x000B1629, 0x00270420,
    0x00122A03, 0x0000221D, 0x00142C0E, 0x000A1821, 0x001B2401,
    0x002C140C, 0x000D3114, 0x001A012A, 0x0011200D, 0x00250721,
    0x000B1A1A, 0x00273203, 0x000F2729, 0x00230521, 0x00131A05,
    0x00182A0D, 0x00082428, 0x00301800, 0x00240D2D, 0x002B0319,
    0x000D2C15, 0x00022432, 0x00210311, 0x00300B16, 0x00041D24,
    0x00172305, 0x00112D31, 0x00260718, 0x002B2B07, 0x000C252E,
    0x00181F0C, 

    0x00102F20, 0x00071913, 0x001F2905, 0x00052022, 0x00200C1B,         // 22
    0x00102A27, 0x00310F13, 0x0006262F, 0x00152008, 0x0004171E,
    0x0013082E, 0x00182A0E, 0x001D0F29, 0x000E2312, 0x00290524,
    0x00242407, 0x000F1A1B, 0x00012B2D, 0x002D160D, 0x000D2F27,
    0x00270A1C, 0x00221F03, 0x00063220, 0x002B1019, 0x00102B2C,
    0x002F001E, 0x00092926, 0x002D072D, 0x001F3006, 0x00112718,
    0x00011D2B, 0x002E3101, 0x000D1831, 0x002B0E1A, 0x00110821,
    0x002F1501, 0x000A2717, 0x002A0A32, 0x001E0012, 0x000A2015,
    0x001C2705, 0x002B0A18, 0x0009122F, 0x00121F10, 0x0031260C,
    0x00221904, 0x00042E1E, 0x001E092B, 0x00072B15, 0x001B032F,
    0x002C290D, 0x00201807, 0x00102218, 0x001F1300, 0x00260D1D,
    0x00310029, 0x000D2318, 0x00150631, 0x00292F07, 0x00051F16,
    0x00200E28, 0x002B0732, 0x0024130A, 0x00300415, 0x000F2D26,
    0x0022062C, 0x00282704, 0x00011B25, 0x00321210, 0x00162A0A,
    0x002B0B27, 0x00081F16, 0x001B1208, 0x00022C1A, 0x001F1012,
    0x002E0231, 0x000D131B, 0x001E0621, 0x00112E11, 0x0006201F,
    0x001D1503, 0x00270E26, 0x00091F1B, 0x000E1329, 0x00252E0A,
    0x001E091D, 0x00320F11, 0x00022125, 0x0014150E, 0x001F061E,
    0x00301206, 

    0x00260A30, 0x001A220A, 0x0031082C, 0x0013160F, 0x002A3103,         // 23
    0x00171A09, 0x001D0621, 0x000B2F18, 0x00230029, 0x002F2C0F,
    0x00282503, 0x00011C21, 0x00310918, 0x0008172D, 0x001E290A,
    0x0005131F, 0x001A1011, 0x00280B23, 0x00142004, 0x00180614,
    0x0009242B, 0x002F130C, 0x00130331, 0x00232508, 0x00031912,
    0x00202005, 0x0016130D, 0x00031B21, 0x00230B12, 0x00071626,
    0x0027031E, 0x00121210, 0x001E2409, 0x00042E15, 0x00181B0F,
    0x001D042D, 0x00142F0C, 0x0003181C, 0x00262D08, 0x0016102E,
    0x0022041E, 0x00101D26, 0x00282D01, 0x001E021B, 0x00011420,
    0x00180B2F, 0x000C2519, 0x002F130F, 0x00281A0A, 0x00140C1C,
    0x00092526, 0x0019072D, 0x00280B21, 0x000C2C13, 0x0006182C,
    0x0017300D, 0x00241403, 0x00011C21, 0x002D0A1D, 0x0018250C,
    0x000D1912, 0x0008321B, 0x00192704, 0x00031E2E, 0x001E0D1D,
    0x00061912, 0x00160F1F, 0x001F081A, 0x000E2D2E, 0x00211601,
    0x0004241E, 0x00170632, 0x0030180F, 0x0026082B, 0x000B2326,
    0x0028300B, 0x001B1F07, 0x00002814, 0x00210F2F, 0x00171A0C,
    0x00310A2B, 0x00133209, 0x001A170E, 0x00292A00, 0x0014022C,
    0x00061814, 0x000E2928, 0x001A001B, 0x00241B03, 0x000A2D27,
    0x00042617, 

    0x002C1D01, 0x000F1223, 0x00012C18, 0x0025051F, 0x000A252E,         // 24
    0x0004122A, 0x00271F0D, 0x002B1606, 0x00110E23, 0x001C0A16,
    0x000D141B, 0x00210530, 0x00113106, 0x00251F0D, 0x00150126,
    0x002E1D02, 0x00112F2A, 0x00210318, 0x00072830, 0x002B1A09,
    0x001F0E21, 0x00012C18, 0x00171B10, 0x001B071F, 0x00290C25,
    0x000F2F2F, 0x00260519, 0x001B2C00, 0x000B2432, 0x002F200B,
    0x001A2A05, 0x00220C2E, 0x000A1E21, 0x00290927, 0x00252905,
    0x000C211E, 0x00230C26, 0x00311D03, 0x000E1320, 0x00072928,
    0x002F150B, 0x00032512, 0x00170822, 0x00261B0A, 0x000E3028,
    0x002D0712, 0x001C1F02, 0x00130023, 0x00023129, 0x00221D03,
    0x00311011, 0x00042E1A, 0x00151E04, 0x002E0425, 0x001B2008,
    0x00280A16, 0x00092627, 0x001F0E11, 0x000F2C2E, 0x001C1401,
    0x0030012B, 0x00230F23, 0x00101A11, 0x00260B19, 0x00142B06,
    0x002F210A, 0x000A2F31, 0x002C1D07, 0x00072316, 0x00130229,
    0x002D0E13, 0x001E2807, 0x000D2F21, 0x00131E01, 0x0005151E,
    0x00160B17, 0x00101724, 0x002A0929, 0x002D2305, 0x000C2C1A,
    0x00240214, 0x00072723, 0x002C062F, 0x0001221F, 0x00201118,
    0x002E250C, 0x00271D04, 0x0009302E, 0x002F0E15, 0x0013042B,
    0x001D160F, 

    0x0006311C, 0x00230229, 0x0015270C, 0x002D1A07, 0x001B0D13,         // 25
    0x00220217, 0x000F2B1D, 0x00002531, 0x00191A04, 0x00082E2B,
    0x002D2108, 0x00062923, 0x00181210, 0x002C0C1D, 0x000A2D16,
    0x001F0A2F, 0x00022613, 0x00301808, 0x000D121F, 0x001B310F,
    0x00110426, 0x00282101, 0x000C2928, 0x00311206, 0x000A2616,
    0x0005161C, 0x002E1E0F, 0x00130F2A, 0x00290115, 0x000F131C,
    0x00160728, 0x00022D17, 0x00311702, 0x0014021B, 0x00061430,
    0x002D1014, 0x00042611, 0x0019022F, 0x0013230E, 0x002A0719,
    0x00193006, 0x000C192C, 0x002D0E16, 0x00072131, 0x00152806,
    0x00221018, 0x00052C2D, 0x00261508, 0x000D281E, 0x001A0516,
    0x0010222B, 0x002A140A, 0x000A1931, 0x0022270F, 0x0002111E,
    0x00102B2F, 0x0030071B, 0x00142006, 0x00260424, 0x000A2917,
    0x0003221E, 0x00152E07, 0x002D0729, 0x00092521, 0x002A002C,
    0x000D1517, 0x00230A27, 0x00180411, 0x00291021, 0x0024310B,
    0x000B1B24, 0x0001141A, 0x0023042C, 0x002B0C15, 0x0020270A,
    0x0031002E, 0x00252C02, 0x00081C11, 0x0014051E, 0x00041426,
    0x001C1F02, 0x000F191C, 0x00220F11, 0x00181C06, 0x000B3023,
    0x00120630, 0x00160C1D, 0x001D140F, 0x00002722, 0x00292009,
    0x00170920, 

    0x00272306, 0x00091814, 0x001C1032, 0x00061F25, 0x000D2E21,         // 26
    0x00302300, 0x00160927, 0x002E1011, 0x0021031C, 0x00261E0B,
    0x00130F13, 0x001D022A, 0x00231A01, 0x0004272E, 0x000E1520,
    0x002A210A, 0x0018061C, 0x00130E29, 0x00252302, 0x00041E2E,
    0x002F0A15, 0x0021101B, 0x0006172C, 0x0025300E, 0x0016052E,
    0x001F2203, 0x00190927, 0x0001281E, 0x00203207, 0x00061723,
    0x002B220C, 0x00240E12, 0x000E252C, 0x001D310D, 0x00171F08,
    0x000F2B22, 0x001E0A19, 0x002B3208, 0x00210F2A, 0x00011A13,
    0x001D0C24, 0x0024011D, 0x00122E04, 0x0020130F, 0x002B031F,
    0x000A1726, 0x002A220D, 0x00170913, 0x002D0E32, 0x00201706,
    0x00062D24, 0x00250114, 0x001C0D1D, 0x00133106, 0x002A052A,
    0x00201702, 0x00191B0C, 0x0004302C, 0x002C1012, 0x00211A09,
    0x0029082D, 0x001D160E, 0x00051F15, 0x001F1303, 0x0019310C,
    0x00011D23, 0x001D2900, 0x0010251C, 0x0004132B, 0x001C2005,
    0x0015082E, 0x0030230D, 0x00192A04, 0x00071C28, 0x001B2D10,
    0x00031222, 0x000D2519, 0x001A0E2B, 0x001F3008, 0x00271031,
    0x002F2A0B, 0x00160B2D, 0x00062D15, 0x00310727, 0x0026160A,
    0x00032113, 0x00222C06, 0x002C0829, 0x00111802, 0x00222B11,
    0x000C112E, 

    0x00132A0B, 0x002E0B19, 0x00202F03, 0x0029071B, 0x0014130E,         // 27
    0x0005172D, 0x001F1C0A, 0x000A3115, 0x0010282E, 0x00031725,
    0x002A081F, 0x000B2F1A, 0x002F220C, 0x00150728, 0x001C0F12,
    0x00241B03, 0x00082A25, 0x00212E0C, 0x002D0016, 0x000A1622,
    0x00172D06, 0x000E2511, 0x001C0320, 0x00121E0A, 0x002A0F23,
    0x000C2D14, 0x00241308, 0x00111A0E, 0x00320B2B, 0x001B1D02,
    0x000B2930, 0x0018061A, 0x00041B24, 0x002E0B15, 0x0021052B,
    0x00291A00, 0x0008162D, 0x00110624, 0x000B291C, 0x00272102,
    0x00092C30, 0x00311E09, 0x00062729, 0x001B0A19, 0x0001252C,
    0x00141D00, 0x001E0521, 0x000B2F1A, 0x00032027, 0x0014260E,
    0x002F081F, 0x00172A01, 0x00032128, 0x00310918, 0x00091E23,
    0x000E2514, 0x00270319, 0x000C131F, 0x00072729, 0x00170C1C,
    0x00122102, 0x000C2B25, 0x002F031F, 0x000E282F, 0x0029101C,
    0x00130513, 0x00250D2D, 0x0031180B, 0x000B2B18, 0x002B0C13,
    0x00102E1E, 0x00260216, 0x000A1122, 0x000F1619, 0x00270830,
    0x00122105, 0x0023190C, 0x002F0320, 0x00012016, 0x000F1712,
    0x00092419, 0x00290122, 0x001E1E04, 0x000C282C, 0x00190E19,
    0x002B0326, 0x000F1A20, 0x00082417, 0x001A0231, 0x00051C1A,
    0x00300725, 

    0x000D1F2C, 0x0018001F, 0x00011B27, 0x00102912, 0x0023042A,         // 28
    0x002A2606, 0x001A0D1A, 0x00260522, 0x002C1202, 0x00162410,
    0x001B2B05, 0x00061232, 0x000F1715, 0x00282807, 0x00013223,
    0x00320418, 0x00101331, 0x00051F1E, 0x00150C2B, 0x001E2909,
    0x00260627, 0x00031C32, 0x002C0B17, 0x00222B04, 0x00021828,
    0x002F0118, 0x00072331, 0x00270622, 0x00082619, 0x00140314,
    0x002D1020, 0x00212F04, 0x0028140A, 0x0009241D, 0x00120F27,
    0x00012D18, 0x0024250C, 0x001C1D05, 0x002E140F, 0x00180321,
    0x00101117, 0x0016160E, 0x00290624, 0x000F1A12, 0x002F320A,
    0x00250D14, 0x00102A2F, 0x0032110B, 0x001B1B03, 0x00240C19,
    0x0009142F, 0x000E1C12, 0x0027112D, 0x001E2C0E, 0x00181409,
    0x00012F32, 0x002E0B26, 0x001C2B03, 0x001F1C0B, 0x00320216,
    0x00002F31, 0x00251110, 0x00180C19, 0x00221A07, 0x00042327,
    0x002D160D, 0x0008301F, 0x00172104, 0x0020012F, 0x00031D24,
    0x00221702, 0x00062731, 0x001F2008, 0x002E320D, 0x0016041F,
    0x002B0F14, 0x00052F28, 0x00150A2E, 0x002B2B02, 0x00180725,
    0x00240D2A, 0x0011310A, 0x0002131D, 0x0023190E, 0x00122201,
    0x00052A2F, 0x001F1308, 0x0031320D, 0x00280F23, 0x00152D05,
    0x001E160F, 

    0x002B1201, 0x0026250D, 0x000A152E, 0x00322109, 0x00170C17,         // 29
    0x000D2F24, 0x0002202F, 0x00132A0E, 0x00081D2B, 0x001F0A18,
    0x00310329, 0x00252009, 0x00190C21, 0x0020011B, 0x000A1E2C,
    0x00172409, 0x00290A13, 0x001B1905, 0x002B2510, 0x000C121C,
    0x002E190E, 0x00183202, 0x0010131E, 0x0008212E, 0x001B0D11,
    0x000F281F, 0x001D1C01, 0x00173010, 0x002B0D2E, 0x001F2C09,
    0x00031626, 0x00111F11, 0x001C002F, 0x00152A07, 0x002C1D0E,
    0x0019021F, 0x00320A13, 0x00151031, 0x00042E28, 0x001F2609,
    0x002C0A2A, 0x0002231C, 0x001A2D02, 0x001F0E31, 0x000B151E,
    0x00180328, 0x00202405, 0x0005161C, 0x0028012C, 0x00113110,
    0x001C2209, 0x002B0425, 0x0005271B, 0x00111903, 0x002D0720,
    0x00210F12, 0x00161F07, 0x00121610, 0x0025082B, 0x000E2623,
    0x001A1506, 0x002C1C0A, 0x00072A2D, 0x00140813, 0x001D2E02,
    0x000F1D32, 0x001B0B15, 0x002B0822, 0x00121210, 0x002F290C,
    0x001A0629, 0x00280F12, 0x00140A25, 0x00001A2C, 0x00222900,
    0x000D2424, 0x001E1C09, 0x000A141A, 0x0021260E, 0x00061E1E,
    0x001D1806, 0x002E2311, 0x00160532, 0x002C0B24, 0x001B2F10,
    0x0027081D, 0x000A1D16, 0x00140A2C, 0x00022213, 0x0023041E,
    0x00092729, 

    0x00033123, 0x00130514, 0x0020101B, 0x001B2C02, 0x00071A1F,         // 30
    0x002D0213, 0x001D1503, 0x002F071E, 0x00231907, 0x000E2F24,
    0x0001151D, 0x00122A0E, 0x00081C2E, 0x002B2E01, 0x0013140E,
    0x00220E2A, 0x000C2F1A, 0x00240226, 0x00022C2F, 0x00120B16,
    0x0007212A, 0x001F0123, 0x0025270B, 0x0031051A, 0x00162F06,
    0x002B082C, 0x0023150B, 0x00011225, 0x00122104, 0x000D1B1D,
    0x0025072B, 0x00092716, 0x00310E22, 0x00041729, 0x00223003,
    0x000B122C, 0x00062825, 0x000E2018, 0x0027051D, 0x00081814,
    0x00233105, 0x000C1D2D, 0x00280016, 0x00062822, 0x002E2106,
    0x00032D18, 0x002C0C25, 0x000D1E12, 0x00082822, 0x002D0829,
    0x0000191E, 0x00202D06, 0x00160F15, 0x0024032B, 0x000A2327,
    0x000F291C, 0x002A012D, 0x00042221, 0x000A3119, 0x002B0D13,
    0x0005201D, 0x00200427, 0x000B2321, 0x00310F17, 0x00240124,
    0x0006131A, 0x00282608, 0x00012C2A, 0x000C231C, 0x00161906,
    0x0008301F, 0x000E1F1A, 0x002D2506, 0x001C0516, 0x000A151C,
    0x00320B11, 0x001A0131, 0x00272D05, 0x00120C26, 0x00300216,
    0x000C2E2E, 0x00041120, 0x00272904, 0x00082015, 0x000E112B,
    0x002E1707, 0x00170122, 0x001E2803, 0x000E1527, 0x002C1B08,
    0x001C0917, 

    0x00220F31, 0x002D1906, 0x00052829, 0x002A0724, 0x00130F30,         // 31
    0x00211E0C, 0x000B2D27, 0x00191116, 0x00052830, 0x00150C13,
    0x00292203, 0x001F1017, 0x002E0827, 0x00042613, 0x001C0620,
    0x002F1804, 0x00072723, 0x0015210A, 0x00311501, 0x00210721,
    0x00282E06, 0x00141015, 0x00001D2B, 0x000D1713, 0x00201026,
    0x00041F15, 0x000C291C, 0x00300229, 0x00270917, 0x001C250F,
    0x002E1306, 0x0018310B, 0x0020091A, 0x000E2212, 0x0029061C,
    0x001D1610, 0x002B2C0B, 0x001A1A01, 0x002D0D11, 0x0010212F,
    0x001B0722, 0x0030130E, 0x00131709, 0x00230A29, 0x00111B10,
    0x001D130C, 0x00150630, 0x00232F08, 0x00190F16, 0x00212402,
    0x0014130D, 0x00300B31, 0x00071F23, 0x001B320E, 0x00281C0A,
    0x00051714, 0x001D2C04, 0x002F120D, 0x00180530, 0x00221402,
    0x0011282A, 0x00160B11, 0x00263203, 0x0012170D, 0x000A2C2B,
    0x002E200B, 0x00150527, 0x00201501, 0x00250E30, 0x001D0416,
    0x002C0A2D, 0x0020130B, 0x00042D21, 0x00110E2F, 0x00282F0A,
    0x00031E29, 0x000F281E, 0x002C1013, 0x0002192B, 0x00252401,
    0x0019140F, 0x00220728, 0x00131B0C, 0x001F031A, 0x00002C27,
    0x0022260E, 0x00051F2E, 0x002F2F0B, 0x0025101B, 0x00072B2C,
    0x00101F11, 

    0x0017011C, 0x000B2E16, 0x00191D0A, 0x000E1512, 0x00263204,         // 32
    0x0002261A, 0x0029092C, 0x00112309, 0x0026011C, 0x002F1E0D,
    0x001A062C, 0x000C3122, 0x00161A05, 0x00250F1B, 0x00112B31,
    0x00011C17, 0x00270411, 0x001E112C, 0x000D1D18, 0x0019260D,
    0x00091730, 0x002F2A08, 0x001B071F, 0x002A2E00, 0x00092522,
    0x00290431, 0x0014190C, 0x001A2F07, 0x00061722, 0x000B2B30,
    0x00140420, 0x00001D2C, 0x00271803, 0x00082932, 0x00160D26,
    0x00112108, 0x0024092F, 0x00140123, 0x00002F2A, 0x00212704,
    0x00150E19, 0x00032B27, 0x0009241C, 0x00183001, 0x0029042C,
    0x0008271B, 0x002A1903, 0x0010211F, 0x002F042D, 0x00041C1A,
    0x000E2B21, 0x00260012, 0x000D2819, 0x002D1300, 0x00130930,
    0x00190E19, 0x00240729, 0x000B261E, 0x00271E07, 0x00022C25,
    0x0030190A, 0x001B0719, 0x002B1031, 0x00011C1D, 0x00182705,
    0x001E0A20, 0x00101A11, 0x00082F18, 0x002A1F0D, 0x000B2522,
    0x00052B13, 0x00261C01, 0x0017012A, 0x002F1910, 0x00232305,
    0x00190618, 0x0014150C, 0x00082122, 0x001D3209, 0x0015091F,
    0x000E2B18, 0x002C2107, 0x000A302F, 0x00310E23, 0x00161602,
    0x002A061E, 0x00130C18, 0x000B1926, 0x001A0414, 0x00150A20,
    0x002F2404, 

    0x00002725, 0x00240B2D, 0x0030061E, 0x0007232A, 0x001D0216,         // 33
    0x00160C20, 0x0031140E, 0x00091A24, 0x001E2E00, 0x000F1127,
    0x0004291F, 0x0023140B, 0x0009242D, 0x001E0111, 0x002C2009,
    0x00170C29, 0x000F311F, 0x002D0913, 0x00032C27, 0x002B021C,
    0x00110C24, 0x00042018, 0x00260E2D, 0x00171A0B, 0x00121310,
    0x001D2C04, 0x00240B19, 0x000F232D, 0x00201111, 0x002C1E01,
    0x00240C1B, 0x00112511, 0x002C1023, 0x001A0215, 0x002F2E05,
    0x00021B20, 0x00092517, 0x0030101B, 0x0025140A, 0x000D1C1F,
    0x002C0312, 0x00271E0B, 0x00201030, 0x002F0817, 0x000C2020,
    0x00220D25, 0x00012B13, 0x001B0A27, 0x000B1611, 0x00283106,
    0x001A0D29, 0x001E2007, 0x00021A2C, 0x0021051E, 0x00082625,
    0x00322009, 0x00033023, 0x00101911, 0x00140A18, 0x001F0120,
    0x0009212D, 0x000F2B15, 0x00072522, 0x0020130E, 0x0026062E,
    0x002B0F14, 0x0004292C, 0x002F001D, 0x00180B25, 0x00131708,
    0x00311028, 0x0010221D, 0x001D0917, 0x00072825, 0x000C111F,
    0x001F0A2F, 0x002B2C02, 0x0022052C, 0x00310E15, 0x00061E2E,
    0x00290426, 0x0002181C, 0x001D0B14, 0x000F2311, 0x00211A0A,
    0x00072831, 0x001C1406, 0x00232510, 0x002B2D00, 0x00061C2F,
    0x0028130C, 

    0x001C1607, 0x00131F10, 0x001F1201, 0x00102923, 0x002D1B08,         // 34
    0x00062B31, 0x00212006, 0x001A0415, 0x0002262E, 0x002C1710,
    0x00140318, 0x00281D06, 0x00320A15, 0x00032E1D, 0x000D1224,
    0x00232805, 0x001B160D, 0x0007212F, 0x00251308, 0x00151B0F,
    0x00233102, 0x001C0511, 0x000E2825, 0x002D001A, 0x0002212E,
    0x00310D20, 0x00071D14, 0x002A0625, 0x0002281E, 0x00190115,
    0x00082F27, 0x001E1509, 0x00042C19, 0x000C1F2A, 0x0022130F,
    0x001D052C, 0x000E3112, 0x001E1906, 0x00062A27, 0x00190C16,
    0x00092E2D, 0x001C1506, 0x00102921, 0x00021A11, 0x001A2E05,
    0x0012150E, 0x00310132, 0x00242509, 0x0016101C, 0x0006262F,
    0x002C0615, 0x00101525, 0x00162F0C, 0x002A1014, 0x00112B06,
    0x0017150F, 0x0029032E, 0x00212302, 0x002E102B, 0x00192F09,
    0x00290E11, 0x00221600, 0x002E0328, 0x00141F08, 0x00053018,
    0x000D2223, 0x001B1204, 0x00221D09, 0x0003262F, 0x00243203,
    0x001A0311, 0x00012932, 0x002B150A, 0x00141E04, 0x0028310F,
    0x00041827, 0x00102612, 0x000B1C1C, 0x001A1704, 0x0012290C,
    0x00241110, 0x00172505, 0x002D002C, 0x00052B20, 0x00290929,
    0x000C3016, 0x00300223, 0x00011E2C, 0x0011071A, 0x001F0D27,
    0x000D3116, 

    0x00072830, 0x00270D1A, 0x0003302B, 0x0029170D, 0x00140619,         // 35
    0x00251012, 0x000D3028, 0x00130E21, 0x0027081A, 0x00212205,
    0x00082F32, 0x001B0F23, 0x0010282A, 0x00181902, 0x002A0730,
    0x00091E16, 0x0030031C, 0x00122500, 0x001F0A1F, 0x000C2928,
    0x00321031, 0x00072415, 0x00201604, 0x000A3029, 0x00180913,
    0x001F2A07, 0x000D142B, 0x00163103, 0x002F1A0A, 0x00130E30,
    0x00262105, 0x0032072E, 0x00160B1F, 0x00251901, 0x0012280A,
    0x002A0E1E, 0x00160A28, 0x002C210D, 0x00120231, 0x00272401,
    0x00320724, 0x0005211A, 0x00160A2A, 0x002C0315, 0x00261128,
    0x001F2308, 0x00051D16, 0x000F2D21, 0x002B1B01, 0x00210A13,
    0x000C221F, 0x00312902, 0x0024031D, 0x0004222E, 0x001F0827,
    0x00091D1F, 0x001C0C16, 0x000D2D1C, 0x00061413, 0x000F2726,
    0x00011B1D, 0x0017092F, 0x000C2D13, 0x001D0C1F, 0x00301703,
    0x00130529, 0x00282C10, 0x000B1821, 0x00120916, 0x002A0E1B,
    0x000C1F26, 0x001F0615, 0x000F2D23, 0x00220C2D, 0x00180319,
    0x002D2007, 0x001D1016, 0x00260224, 0x00012F29, 0x002C071F,
    0x000D1F32, 0x00073123, 0x0022140B, 0x00141D04, 0x001A0F19,
    0x00261F08, 0x0016120F, 0x00092A1F, 0x00281807, 0x0016210E,
    0x0032031E, 

    0x00120822, 0x002C2308, 0x00180215, 0x000B2126, 0x001B0A2E,         // 36
    0x0001281E, 0x002A1602, 0x002F1C0C, 0x000A2B2A, 0x0016120A,
    0x002F0B1E, 0x00002011, 0x00200419, 0x0026230F, 0x00061521,
    0x00162F0B, 0x00220E2D, 0x00042D24, 0x002A0617, 0x00181805,
    0x00011F1A, 0x00280B22, 0x00141C09, 0x0024101E, 0x002A230C,
    0x00041723, 0x0028041B, 0x0023250F, 0x001D0928, 0x00041617,
    0x000C2923, 0x001B1B0E, 0x00072714, 0x002D0425, 0x00032230,
    0x000A2B16, 0x00231503, 0x00012D21, 0x00200F13, 0x000B1B1D,
    0x00141209, 0x00203210, 0x00241804, 0x000B262F, 0x00072B1C,
    0x00150723, 0x002D0B2C, 0x00091319, 0x001D052A, 0x00012E26,
    0x0017130A, 0x00071C31, 0x001C0F11, 0x000C1917, 0x002F2F03,
    0x0026120B, 0x00002828, 0x002C1905, 0x00270332, 0x001B1F08,
    0x00310519, 0x00262206, 0x00042924, 0x002A1C0B, 0x00082630,
    0x00200B1B, 0x00161F0D, 0x0031032E, 0x001D2E0B, 0x0006232B,
    0x002F190F, 0x00261105, 0x00061C1C, 0x0032140E, 0x00032829,
    0x00120822, 0x00072E30, 0x002F140D, 0x00152107, 0x00200D17,
    0x001A1A02, 0x0028101A, 0x00102A15, 0x002F0627, 0x0002271E,
    0x0011042E, 0x00202402, 0x002E0A25, 0x001A1013, 0x00032C2A,
    0x00211A03, 

    0x000A2E28, 0x001E1510, 0x00061C20, 0x00232B09, 0x002E1304,         // 37
    0x0020230F, 0x0018002D, 0x0007251D, 0x001D0614, 0x000F1A25,
    0x001F2C03, 0x000C1727, 0x002E3209, 0x0013102B, 0x001C2A06,
    0x002D0928, 0x00101A12, 0x001A1F0A, 0x0008142C, 0x002D2F11,
    0x0011022A, 0x00192B0F, 0x002F062E, 0x00062C17, 0x0012022C,
    0x001A1E01, 0x00092E32, 0x00111111, 0x00071C1F, 0x002D2D0C,
    0x0015051C, 0x002A1307, 0x0010322B, 0x001F1111, 0x0018091B,
    0x0031180B, 0x001B052D, 0x000D1E1A, 0x002F0825, 0x0019260D,
    0x00032B2D, 0x002E0027, 0x00110C1F, 0x001B1B0F, 0x00301402,
    0x000E2013, 0x001B3106, 0x0027190B, 0x0012290F, 0x002F1F04,
    0x0022011A, 0x00280B24, 0x00132B0D, 0x002B072A, 0x000F261B,
    0x00190030, 0x00112010, 0x00160820, 0x00202B0D, 0x00120F23,
    0x0007312A, 0x001F140E, 0x00121017, 0x001A012B, 0x00101414,
    0x00273106, 0x00001127, 0x00092818, 0x00231504, 0x00180623,
    0x00132C08, 0x00092720, 0x00150A2E, 0x001A3001, 0x000B2314,
    0x0025170A, 0x00191E03, 0x0021091A, 0x0005262E, 0x000B2D13,
    0x0032022A, 0x00042326, 0x001F0C11, 0x00091930, 0x00232E0C,
    0x002C1511, 0x00061A28, 0x000B321B, 0x00230032, 0x000F2516,
    0x002D130C, 

    0x00250B1A, 0x00142901, 0x00300630, 0x00110E1C, 0x00052F2A,         // 38
    0x000C1924, 0x00120D18, 0x00243109, 0x00041430, 0x002A270D,
    0x00250116, 0x0015092F, 0x00051C20, 0x00220514, 0x000E131E,
    0x00022519, 0x00280022, 0x00252803, 0x00140C1D, 0x001F230C,
    0x00241107, 0x0009251C, 0x001E1402, 0x000D1926, 0x002D270E,
    0x00200D15, 0x00310721, 0x00182107, 0x0029012B, 0x001E2404,
    0x00250C2E, 0x00052027, 0x00220216, 0x000C2421, 0x00281C03,
    0x00062F27, 0x00132710, 0x00251306, 0x00073030, 0x00291602,
    0x001D0E13, 0x000D1D16, 0x00272207, 0x00002F25, 0x0021041A,
    0x00290D2E, 0x0003271F, 0x00220225, 0x00170D30, 0x00091715,
    0x0010262C, 0x001A3206, 0x0002201F, 0x001E1509, 0x00081E22,
    0x00220E14, 0x00313107, 0x000A132D, 0x0005221A, 0x00240A13,
    0x002B1804, 0x000B262E, 0x002E0A20, 0x00242E01, 0x0006201E,
    0x001B0725, 0x002D1A0A, 0x000F221F, 0x002B0B29, 0x00031E12,
    0x00240F30, 0x001C0216, 0x002B1F0A, 0x00280726, 0x001F101B,
    0x002E001F, 0x000C2A2A, 0x002A0F11, 0x00101B23, 0x0025081D,
    0x0017170F, 0x00132806, 0x002B0420, 0x001B2101, 0x000C1124,
    0x00172506, 0x001E0D17, 0x0015200B, 0x002A1504, 0x00051D1F,
    0x0018052E, 

    0x00012014, 0x000C1823, 0x001B250D, 0x002A0917, 0x00171E0B,         // 39
    0x00270513, 0x00322206, 0x001B0928, 0x002C1F04, 0x00130E22,
    0x0002211C, 0x001C1210, 0x002B2406, 0x00092C2D, 0x00301F01,
    0x001E180E, 0x00071132, 0x000F2C14, 0x0031052E, 0x00021821,
    0x000E1D25, 0x002C0731, 0x00032E13, 0x00270B20, 0x00162105,
    0x00021327, 0x000B2B1A, 0x0024180D, 0x00003024, 0x000F1413,
    0x000A1A19, 0x00192E00, 0x0030170A, 0x00012A2F, 0x001C130F,
    0x0011001F, 0x002E0B2A, 0x001F230A, 0x00160318, 0x00102020,
    0x0023092B, 0x0006291B, 0x002B0631, 0x0018120B, 0x00092829,
    0x00141D0D, 0x000C1617, 0x002E2302, 0x00052D1C, 0x00260722,
    0x002B1011, 0x000B1917, 0x0030042F, 0x00250D12, 0x00172D02,
    0x00031A2B, 0x00280525, 0x001A280B, 0x002E1B01, 0x000F2D28,
    0x0017061D, 0x001D1D0A, 0x00022A12, 0x00150529, 0x0030180C,
    0x000C2612, 0x00220D32, 0x00142B00, 0x001E0115, 0x000E311C,
    0x002E170C, 0x000B2A27, 0x00051419, 0x00102611, 0x00011A31,
    0x00142E0C, 0x00082117, 0x00170426, 0x001E2B0B, 0x002C1200,
    0x00073231, 0x00221F0C, 0x0002142B, 0x0011301C, 0x00310A14,
    0x0025022F, 0x00002D1D, 0x002F082C, 0x00122A0F, 0x00200D24,
    0x00282F06, 

    0x002E0F1D, 0x0022012B, 0x00043227, 0x001E1507, 0x00082A21,         // 40
    0x00211031, 0x00032E1A, 0x000F1820, 0x00092B12, 0x0018052A,
    0x00312802, 0x000C2E25, 0x0027180C, 0x00190C1B, 0x00130324,
    0x002A300A, 0x00170927, 0x00201B08, 0x0009241A, 0x001B3201,
    0x00290C16, 0x0013280D, 0x00191F07, 0x00210319, 0x000F312F,
    0x00261609, 0x001D092C, 0x00122602, 0x002E0F1D, 0x001B0531,
    0x002C270F, 0x00120823, 0x00260F1B, 0x00140626, 0x002C1F06,
    0x00210F19, 0x00032B14, 0x000A1B23, 0x002A0D12, 0x00012E28,
    0x00311A08, 0x00141310, 0x001F2E00, 0x000F191F, 0x00260C13,
    0x00312D05, 0x001A0628, 0x0011112C, 0x001F1A0E, 0x00182808,
    0x00042128, 0x00211300, 0x00112A23, 0x00062428, 0x002A0216,
    0x000D261D, 0x0013170F, 0x001F0B19, 0x00011121, 0x00270130,
    0x00062416, 0x00230E26, 0x000E161B, 0x00292206, 0x001E102D,
    0x00042D19, 0x00180521, 0x0027130F, 0x00061A2D, 0x00292505,
    0x00160722, 0x00202107, 0x00310C2C, 0x00192C06, 0x00220521,
    0x00271203, 0x001D0C2E, 0x00301707, 0x00002314, 0x000C1D28,
    0x001C031F, 0x002F0F13, 0x00180818, 0x00271A09, 0x00072B29,
    0x00141E0F, 0x000D1122, 0x00271908, 0x001A0417, 0x00072628,
    0x000F1A12, 

    0x00172A0A, 0x00122303, 0x00261110, 0x000E1B1B, 0x002E032A,         // 41
    0x00132601, 0x001A140D, 0x0023022E, 0x00280D16, 0x001E1B0B,
    0x00071531, 0x00211017, 0x0011082A, 0x00012613, 0x00240E2F,
    0x000C2818, 0x0003201F, 0x002C1410, 0x0026072A, 0x00150F12,
    0x00220127, 0x000A161F, 0x0032102B, 0x00081A23, 0x002B0711,
    0x0006241E, 0x00301C0F, 0x00160225, 0x00071F17, 0x00222C08,
    0x00031229, 0x00201E0D, 0x0006292E, 0x000E2213, 0x00192E0B,
    0x000C1932, 0x002B2501, 0x001B062C, 0x000E151B, 0x00202804,
    0x0019021E, 0x000A2424, 0x002E082B, 0x00051F18, 0x001D012F,
    0x00022323, 0x00230E11, 0x002A2007, 0x000A3119, 0x00320032,
    0x00130B1E, 0x001C2F0D, 0x002D081B, 0x00151B06, 0x001D140D,
    0x002E0A31, 0x00252C05, 0x00091F2C, 0x00112A11, 0x00191808,
    0x0032300E, 0x00141F02, 0x0026032F, 0x00083223, 0x00120A16,
    0x00251D04, 0x000E172A, 0x00322F09, 0x000A2126, 0x001B0C18,
    0x00011231, 0x00122F10, 0x0025031D, 0x000D1715, 0x0007222B,
    0x002B1C10, 0x00042819, 0x000E2F22, 0x0022062C, 0x00140B1A,
    0x00292507, 0x000E2C24, 0x0009222D, 0x00212704, 0x001A061F,
    0x002A170C, 0x00222701, 0x00042E29, 0x000B221C, 0x00311302,
    0x001D072D, 

    0x002A0C19, 0x00061D31, 0x00310620, 0x00182D05, 0x00022214,         // 42
    0x002A0824, 0x000A1C1D, 0x00302804, 0x00002027, 0x000E311C,
    0x002C2407, 0x0014011F, 0x002E2004, 0x000A2F21, 0x00201C0F,
    0x00311302, 0x0019022D, 0x00112705, 0x00052D22, 0x000D1F30,
    0x002D2B04, 0x0000221B, 0x001F2F0A, 0x00142800, 0x001A0E16,
    0x00102C2A, 0x00201104, 0x000E2F2F, 0x00270A12, 0x000B1822,
    0x002B2305, 0x0015011F, 0x002E1603, 0x001F0A18, 0x00270520,
    0x00071428, 0x00240D1D, 0x00133209, 0x002F1D0E, 0x0008112A,
    0x0024210C, 0x00110C16, 0x00282B06, 0x0017150F, 0x002B3003,
    0x000A1A1D, 0x000F2917, 0x00160526, 0x00031520, 0x00220E12,
    0x00281E05, 0x000C172E, 0x00002313, 0x00230E2C, 0x000A2E18,
    0x00042120, 0x0019120C, 0x002F0327, 0x00212303, 0x00290824,
    0x000A132C, 0x001F0C1A, 0x00012913, 0x002F1409, 0x0019250D,
    0x002C0127, 0x0002271C, 0x001D0B14, 0x0011051F, 0x00232903,
    0x002F190B, 0x00091D27, 0x001B2702, 0x002D0F23, 0x0015300A,
    0x001A0A28, 0x0011011E, 0x00261305, 0x002C1C0A, 0x001A2D10,
    0x0006122F, 0x00241803, 0x0015001D, 0x002D0D11, 0x00021332,
    0x00102125, 0x0016021A, 0x002C0F12, 0x00200930, 0x00141E0D,
    0x00033021, 

    0x000F1314, 0x001F280C, 0x000B1829, 0x00240B17, 0x001D0F2F,         // 43
    0x00101611, 0x001F3009, 0x00170A2C, 0x00121310, 0x00270623,
    0x00190C14, 0x00042B28, 0x0026190D, 0x001B042B, 0x00151608,
    0x00042C24, 0x00270B15, 0x001E180C, 0x002F101B, 0x00201A08,
    0x0019130F, 0x00120B2D, 0x00290613, 0x00051D31, 0x002E0025,
    0x00251508, 0x00011F19, 0x002B0D1F, 0x00182806, 0x001E062C,
    0x00102E1B, 0x001B0E14, 0x000A2B2A, 0x00031B24, 0x00323007,
    0x0016270D, 0x001E0115, 0x0002222E, 0x00270921, 0x00172D11,
    0x002D062F, 0x00021826, 0x0021101F, 0x0008272D, 0x00140827,
    0x0025120C, 0x002F0B30, 0x00202C01, 0x001A1C0A, 0x000F2629,
    0x00062D17, 0x002C0524, 0x001A290A, 0x00290322, 0x00131D01,
    0x00220728, 0x000F3214, 0x00071A1E, 0x00150F19, 0x00032D13,
    0x000F1C1F, 0x002D2606, 0x001B082A, 0x000C1B21, 0x00210E30,
    0x00092C11, 0x00171F02, 0x0024102E, 0x002B160E, 0x000B2C2B,
    0x0018001B, 0x002A0A16, 0x0004202E, 0x00210611, 0x000B151B,
    0x00312601, 0x0020210E, 0x00171032, 0x00032725, 0x000B1617,
    0x001F0720, 0x00311F0D, 0x00043127, 0x000E1C16, 0x001E2D06,
    0x00300814, 0x0009312C, 0x001C1C07, 0x0010161E, 0x00282606,
    0x00230426, 

    0x001B2200, 0x002C011C, 0x00153008, 0x00051F22, 0x00282B0A,         // 44
    0x00082528, 0x002B0021, 0x00062118, 0x002E1805, 0x00202C0B,
    0x000A1E2F, 0x00221100, 0x000F261D, 0x002A0E15, 0x0008221A,
    0x002C0631, 0x000E251D, 0x0008312A, 0x00150525, 0x00032916,
    0x0027031F, 0x000B2624, 0x001A0F18, 0x0022180C, 0x000C261F,
    0x00162B0E, 0x001E0429, 0x000B1814, 0x00062023, 0x002E140C,
    0x00021C11, 0x00290430, 0x00252509, 0x00181110, 0x00110C2F,
    0x00061E1B, 0x002D1703, 0x000B2A25, 0x001C1A06, 0x0006131C,
    0x00132701, 0x001C310A, 0x000F1C13, 0x0032051B, 0x001B1F09,
    0x00112510, 0x00061721, 0x000C2115, 0x002E032C, 0x0026120E,
    0x001E091E, 0x00152103, 0x000E152A, 0x0007111C, 0x00302710,
    0x001C1609, 0x00270C2D, 0x002C2806, 0x001D062B, 0x0024210B,
    0x00180231, 0x0028180D, 0x00052D1C, 0x00152102, 0x002A0417,
    0x0011191E, 0x002E0725, 0x00072F19, 0x00151C07, 0x00032223,
    0x001F0F12, 0x00103220, 0x00271307, 0x000F2A25, 0x00011C30,
    0x00240717, 0x0007192A, 0x000D3113, 0x002F031C, 0x00242302,
    0x00120C28, 0x00182809, 0x0029061A, 0x0022102D, 0x0007231F,
    0x00181A0B, 0x00250C23, 0x00022916, 0x002D0527, 0x00062D12,
    0x000A1A2D, 

    0x00112B0F, 0x00001524, 0x0021092C, 0x002E1210, 0x0013051E,         // 45
    0x00191A05, 0x00251013, 0x000D2E31, 0x001C041F, 0x00032728,
    0x00150818, 0x0032170F, 0x00073224, 0x001F092E, 0x00132903,
    0x00231B0F, 0x0019110B, 0x00211F01, 0x002A0912, 0x000A232B,
    0x0023150B, 0x002C2D02, 0x00042029, 0x00303006, 0x0007121A,
    0x002A0C2E, 0x00112402, 0x0032320A, 0x00240A31, 0x00132601,
    0x00200F26, 0x00083018, 0x000F161E, 0x001F2102, 0x002B0326,
    0x00262C10, 0x0013082C, 0x00220F18, 0x00310313, 0x000E232B,
    0x002B0A23, 0x00250219, 0x00052232, 0x00221402, 0x00012B25,
    0x002C012C, 0x001D2D04, 0x0028091C, 0x00013022, 0x00131908,
    0x00092B2F, 0x00310E19, 0x0020310D, 0x00251F06, 0x00032C31,
    0x00160024, 0x000D241B, 0x00011811, 0x00112B23, 0x00301500,
    0x00073126, 0x00130E16, 0x00230625, 0x001D110F, 0x0003302C,
    0x00262406, 0x001F130C, 0x000E2829, 0x001B0315, 0x00280930,
    0x00312601, 0x00071A2B, 0x0017240B, 0x002F0214, 0x001B2E05,
    0x00101121, 0x00282908, 0x001D0B22, 0x00131E07, 0x002A0F2B,
    0x00032F13, 0x000C1A30, 0x001C140F, 0x00112B00, 0x0027032A,
    0x0013160F, 0x002E2405, 0x000E1231, 0x00181F0B, 0x001E0A18,
    0x002F0F1F, 

    0x0019072F, 0x00271D06, 0x00092518, 0x001C2A02, 0x000C212F,         // 46
    0x00300A1B, 0x0001272A, 0x00181D01, 0x00230E15, 0x002B1407,
    0x000C2321, 0x0025032C, 0x00191D05, 0x00011412, 0x002F011B,
    0x000B2E27, 0x00021720, 0x00310C2E, 0x00112B18, 0x001D1C05,
    0x00160D32, 0x000F1A11, 0x001E0A1D, 0x0012022C, 0x00172210,
    0x00200622, 0x00031A16, 0x001C1128, 0x0018021B, 0x000C2C15,
    0x002C0721, 0x00161E05, 0x00300A2D, 0x000B2A14, 0x00001821,
    0x001C2307, 0x000C121F, 0x0018280A, 0x00043030, 0x00201E0D,
    0x00181705, 0x000A1129, 0x00292D0F, 0x00160B21, 0x000C1A15,
    0x00240E1A, 0x0017140A, 0x00101D31, 0x00220F13, 0x00182204,
    0x00280125, 0x00041C14, 0x0018052C, 0x00120B21, 0x000B1916,
    0x002D0F13, 0x00211F02, 0x002A0730, 0x001B1018, 0x000B1D13,
    0x00200A1D, 0x002B2804, 0x00091F2E, 0x00312A09, 0x000D1621,
    0x00180914, 0x00041F32, 0x00300D20, 0x00221804, 0x000C2D1D,
    0x0013140E, 0x001C0524, 0x00230D19, 0x0006181E, 0x00290A2C,
    0x0015240E, 0x002D041A, 0x0002142D, 0x00192D0C, 0x000E1818,
    0x0020021F, 0x002E2506, 0x00061F24, 0x002C0B14, 0x0000271C,
    0x001F0826, 0x000A2C1A, 0x00220020, 0x002A3002, 0x000C182A,
    0x00252308, 

    0x00042F15, 0x00320D11, 0x00101928, 0x002A041F, 0x00041714,         // 47
    0x00212D08, 0x0014140D, 0x002C0625, 0x00102911, 0x00061B30,
    0x001D2F0D, 0x00110E1B, 0x002C2C09, 0x000E2422, 0x00270F2A,
    0x001D2006, 0x00250516, 0x00152408, 0x00061328, 0x002B0222,
    0x0002321A, 0x002F0625, 0x000A2915, 0x00241D03, 0x002B140C,
    0x000E2D26, 0x00261E07, 0x0009281F, 0x002B160D, 0x0001222C,
    0x0026190B, 0x00062929, 0x001B130E, 0x00240519, 0x00130E31,
    0x002E310D, 0x00061C29, 0x00251502, 0x00290622, 0x00130D16,
    0x00012C1E, 0x00302411, 0x00111D08, 0x001E042D, 0x002F3205,
    0x0008202A, 0x00042611, 0x00310426, 0x000A2918, 0x002C082B,
    0x001D270F, 0x000D161F, 0x002E2500, 0x00282A0E, 0x001F0728,
    0x0006301E, 0x0018140D, 0x00072620, 0x00152E08, 0x00280129,
    0x0003242F, 0x001A120C, 0x00111A11, 0x0026021C, 0x00150E27,
    0x002D2700, 0x001E021B, 0x00133009, 0x00062113, 0x00261027,
    0x00001E17, 0x002C2805, 0x000A2F31, 0x00112111, 0x001F1D03,
    0x00042D27, 0x000B1A14, 0x00212204, 0x00300624, 0x0009272F,
    0x0028130E, 0x0013081B, 0x00250E2B, 0x00173008, 0x000E192F,
    0x00292003, 0x001B0F13, 0x00031C2D, 0x0013140F, 0x0007271C,
    0x00150227, 

    0x00201122, 0x000A281A, 0x001E0832, 0x0016310A, 0x00260F26,         // 48
    0x001A022D, 0x00081F20, 0x000B301A, 0x00240C29, 0x0030011D,
    0x00171F02, 0x00280727, 0x00081815, 0x00220A2E, 0x00162B0B,
    0x00071A13, 0x000F3030, 0x0028081D, 0x001F2C0E, 0x000C1D14,
    0x00232407, 0x001A150D, 0x0028102D, 0x00012F1F, 0x001B0731,
    0x0007261B, 0x002E0E12, 0x00140A2E, 0x001D2F04, 0x00111211,
    0x001F0C20, 0x0013001B, 0x00292208, 0x00092D28, 0x00191E04,
    0x00270817, 0x001F011C, 0x000F2114, 0x00072528, 0x002C1A07,
    0x001C022D, 0x00210926, 0x00071318, 0x0027280D, 0x001A0D1D,
    0x00101813, 0x0028071F, 0x001B2F06, 0x00141A0D, 0x0003141E,
    0x00112E09, 0x00230C30, 0x00012019, 0x001B1308, 0x000F1B2E,
    0x00322705, 0x00270326, 0x00120B2C, 0x002E1A0F, 0x001E1404,
    0x000F2C20, 0x002E0619, 0x00053029, 0x001C2506, 0x00011818,
    0x000B2C2A, 0x00281C0F, 0x00091523, 0x002C062F, 0x00192B0A,
    0x001F012A, 0x00140B22, 0x0028150D, 0x00180629, 0x0032120A,
    0x00250322, 0x00170D31, 0x00102B1E, 0x00260A12, 0x00152007,
    0x00032E27, 0x001D1E02, 0x000A2917, 0x00210121, 0x002F130D,
    0x00052D18, 0x00150528, 0x00312806, 0x00270824, 0x001C0D13,
    0x002C1F04, 

    0x000D1B2C, 0x0018150D, 0x002D2201, 0x00061C12, 0x000D2917,         // 49
    0x00312506, 0x00281110, 0x001F1903, 0x0019220B, 0x00011517,
    0x000B2A2D, 0x001F120F, 0x0003281E, 0x00131E03, 0x00300319,
    0x001A0C25, 0x002C1402, 0x00042623, 0x00181809, 0x002E0F2F,
    0x0013041F, 0x00062828, 0x00151B05, 0x000F2318, 0x0031120A,
    0x00161801, 0x0021022A, 0x00032319, 0x00270524, 0x00311E09,
    0x000A2730, 0x00223100, 0x00031B24, 0x002F1111, 0x000E2721,
    0x0002172B, 0x00152B0B, 0x00310C2F, 0x00192F0E, 0x000B1319,
    0x0027280B, 0x00162E01, 0x000E1822, 0x00032130, 0x00140625,
    0x002C2C02, 0x0021102C, 0x00092223, 0x00250A2F, 0x001E1F02,
    0x002D1127, 0x00160415, 0x00083229, 0x002B0123, 0x00140D13,
    0x0004201A, 0x0023170A, 0x000D2A16, 0x0001231C, 0x00220525,
    0x00081E14, 0x00151709, 0x001F0F22, 0x002C0931, 0x0023210B,
    0x00110414, 0x001B102D, 0x00222604, 0x00150B18, 0x000D231F,
    0x00301207, 0x00051B14, 0x00222B01, 0x0002241F, 0x000F311B,
    0x00091715, 0x002C250D, 0x001C1300, 0x00061B2C, 0x002C1116,
    0x00190420, 0x0032190C, 0x00051532, 0x00102311, 0x001A0A2A,
    0x00241E07, 0x000D171F, 0x001F230B, 0x0010321A, 0x00051730,
    0x00262A0B, 

    0x002F0317, 0x00012F25, 0x0028061C, 0x00130E23, 0x0020092A,         // 50
    0x0002161D, 0x00120531, 0x00072922, 0x002D082B, 0x00152F07,
    0x00260B20, 0x002F2505, 0x001B0532, 0x0029310E, 0x000E1220,
    0x0000282D, 0x001D1F0F, 0x0023001A, 0x00110B2A, 0x00092217,
    0x00272E00, 0x0022091B, 0x002D0E12, 0x001F0123, 0x00051F29,
    0x0025310F, 0x000B2922, 0x0019130C, 0x000E2B14, 0x00051729,
    0x00160618, 0x002D0B13, 0x0010162D, 0x001C061D, 0x00220D14,
    0x002C2206, 0x00071125, 0x001E1901, 0x0024051F, 0x00120A24,
    0x00051E30, 0x002D0E1B, 0x00220312, 0x002B3006, 0x001F140C,
    0x000C1D19, 0x00002714, 0x00181508, 0x002F001B, 0x000E2C12,
    0x00062422, 0x00271B04, 0x001F140B, 0x000B251D, 0x00252B02,
    0x001D072F, 0x00092F21, 0x001C1202, 0x00290D32, 0x0018310A,
    0x0030092D, 0x00252201, 0x000E2B11, 0x0007151E, 0x00162E03,
    0x002A0C25, 0x0005201C, 0x002F320A, 0x00021B26, 0x0025150F,
    0x00092F2C, 0x00101F19, 0x002E032F, 0x001B0F12, 0x002A092B,
    0x001E1D08, 0x00002C27, 0x0024011B, 0x000B3122, 0x00122609,
    0x00220D29, 0x000E2C14, 0x0026091E, 0x002C3104, 0x0013111B,
    0x00082924, 0x00290931, 0x00011216, 0x002D022A, 0x00192102,
    0x00120A1E, 

    0x00222405, 0x001C1209, 0x0009292E, 0x0024190B, 0x00192E03,         // 51
    0x002A220F, 0x00163209, 0x00240E19, 0x00101E14, 0x00200325,
    0x000F1812, 0x00041D2A, 0x00160E18, 0x000A1625, 0x00252309,
    0x002E0715, 0x00142E05, 0x000D1B27, 0x00312A07, 0x001C1210,
    0x00011624, 0x000F1E2C, 0x00192908, 0x000A2D30, 0x00270C16,
    0x0012061E, 0x002D1B06, 0x001F0932, 0x002B2003, 0x00230F1F,
    0x001B2C07, 0x000B2427, 0x0028200B, 0x00172E03, 0x00092930,
    0x0012031B, 0x00283010, 0x000C1F2D, 0x00012A15, 0x002F2205,
    0x0017150F, 0x00092528, 0x00101C15, 0x00190A2B, 0x00082420,
    0x0031022E, 0x00240C27, 0x0012310E, 0x00051A2A, 0x00290E16,
    0x001A0631, 0x00122D10, 0x0031092C, 0x00181D0F, 0x00021628,
    0x002D0E17, 0x00161D0D, 0x00300129, 0x00122010, 0x000B181E,
    0x00042617, 0x001A0D2A, 0x00290026, 0x000B1D15, 0x0031072D,
    0x0019280E, 0x000A1321, 0x001F0116, 0x00110831, 0x001B2A02,
    0x0029051C, 0x001E0C27, 0x00132709, 0x00081A23, 0x00242304,
    0x00160518, 0x00110F2E, 0x00302007, 0x0017170E, 0x00290730,
    0x00011D1A, 0x001D2401, 0x0017032C, 0x00031B23, 0x001E210A,
    0x00300413, 0x00172E00, 0x001D1A0E, 0x000A2821, 0x00240F12,
    0x00072C27, 

    0x00151D10, 0x002B0B29, 0x00102014, 0x002F0319, 0x000C112F,         // 52
    0x00081D23, 0x002E0028, 0x001B1905, 0x0003262D, 0x0029130C,
    0x0007231D, 0x002C2B08, 0x00230113, 0x001C2D02, 0x00051B2B,
    0x001F0E1C, 0x00081631, 0x00260914, 0x00052521, 0x002A042F,
    0x0017300A, 0x00300615, 0x00041920, 0x002A130F, 0x001B2602,
    0x00021126, 0x00172211, 0x0009151B, 0x00003023, 0x0011032C,
    0x00291A10, 0x0006121C, 0x001F0223, 0x00011A18, 0x00310B27,
    0x00231D08, 0x001B0723, 0x0015140C, 0x00290E1C, 0x0020002C,
    0x001C3209, 0x00260620, 0x002F2C02, 0x0002111C, 0x00272A08,
    0x00151810, 0x001B2000, 0x002C081F, 0x00202205, 0x000A281D,
    0x00231706, 0x00022019, 0x000D1123, 0x00262F06, 0x0013031F,
    0x00282907, 0x000E2324, 0x0005141A, 0x00262A07, 0x001F0625,
    0x002C1305, 0x0013290E, 0x0001191C, 0x00213109, 0x00121119,
    0x00251E07, 0x000F192C, 0x002B2B05, 0x0017220C, 0x002F1024,
    0x00032613, 0x00161706, 0x0027300E, 0x000E121D, 0x00042B31,
    0x002D160F, 0x0009261F, 0x00210813, 0x00042A25, 0x001F1405,
    0x002F2F10, 0x000C1126, 0x00281708, 0x000A2716, 0x00250D2E,
    0x00061627, 0x000F2518, 0x00280B2D, 0x00141E07, 0x0031051A,
    0x000D182F, 

    0x001A011B, 0x00043122, 0x001F1404, 0x00022620, 0x001D2B0D,         // 53
    0x00270A15, 0x0005141B, 0x000F2C11, 0x00320B1F, 0x00162E01,
    0x001E0D2F, 0x00130823, 0x000B1F1B, 0x00311127, 0x00102611,
    0x00160421, 0x002B210D, 0x001A3109, 0x00130F1D, 0x001F1A02,
    0x000D211B, 0x00210B2B, 0x00132404, 0x0023031C, 0x000D1A2D,
    0x00322E09, 0x0024012B, 0x0013260D, 0x002F0D16, 0x001E1D0B,
    0x00152A04, 0x00300931, 0x000F3114, 0x00271409, 0x0015250F,
    0x0004112A, 0x000E2317, 0x002D2C04, 0x00061C28, 0x00112813,
    0x00031224, 0x000B1A18, 0x001F0B32, 0x00121E0F, 0x001D0428,
    0x000B2E18, 0x00041123, 0x000F2B30, 0x0017130C, 0x0030042B,
    0x00140A21, 0x00282A0D, 0x001C062E, 0x00062215, 0x00200B2A,
    0x00081A13, 0x001C0630, 0x00222E0B, 0x00160A2C, 0x00071D13,
    0x000F2F2F, 0x00240422, 0x002F2003, 0x001B0B30, 0x00062520,
    0x001D0527, 0x00012F12, 0x00270B1D, 0x00071629, 0x000D1C16,
    0x00230D1F, 0x00092030, 0x00310825, 0x00200016, 0x00171E0B,
    0x00290B24, 0x001C3002, 0x000F1A29, 0x00260C16, 0x00140420,
    0x0007212D, 0x00120B1C, 0x002D2B0F, 0x001C0620, 0x00152D0C,
    0x002E1F06, 0x0023011E, 0x00021326, 0x001F2A0D, 0x00052F23,
    0x0029140A, 

    0x000C2915, 0x00300931, 0x00141B0A, 0x002A062C, 0x00171800,         // 54
    0x0011212A, 0x00222909, 0x001E072E, 0x000A2114, 0x00250428,
    0x000D1B17, 0x00283005, 0x0018140D, 0x00012830, 0x00210816,
    0x00272D03, 0x000C112C, 0x00021824, 0x002D0217, 0x00072926,
    0x0028140D, 0x000A2712, 0x002E0F27, 0x0016310B, 0x00071F23,
    0x001D0B17, 0x000B1720, 0x001B2C00, 0x0026072F, 0x000C1426,
    0x0004251B, 0x00210F29, 0x00191901, 0x000A282E, 0x001D051E,
    0x002C2E02, 0x00081731, 0x001E0321, 0x00170B19, 0x00272407,
    0x0032072E, 0x00152104, 0x0025290B, 0x00051523, 0x002A2206,
    0x002F092E, 0x00211C0A, 0x00270216, 0x00012526, 0x000C1E13,
    0x001E3109, 0x00071427, 0x002F1C00, 0x00170F1E, 0x002C260B,
    0x00113003, 0x002F101F, 0x00001917, 0x00292701, 0x00320E1B,
    0x001D170A, 0x00092318, 0x00160829, 0x000E1413, 0x00292B0C,
    0x002E1701, 0x00160F17, 0x0021032E, 0x0013260E, 0x001D3103,
    0x002D022B, 0x00112D10, 0x001B1500, 0x0006252A, 0x00252C07,
    0x0013052C, 0x0002131C, 0x00322309, 0x00092E32, 0x001B1803,
    0x002B290B, 0x00190029, 0x00211D04, 0x00021331, 0x000E191A,
    0x001A082B, 0x000B3113, 0x002B1C04, 0x00190717, 0x00120D2C,
    0x00232301, 

    0x0007111E, 0x0025200E, 0x000A2C27, 0x00210E1A, 0x000D3013,         // 55
    0x0030031D, 0x00180E26, 0x002C1D04, 0x00001622, 0x001A2708,
    0x002E1011, 0x0004222C, 0x0023031E, 0x002C1809, 0x001A0D22,
    0x00061C1A, 0x00302407, 0x001C2B0F, 0x00230A2A, 0x00121C06,
    0x00180532, 0x00042D21, 0x001C0817, 0x000F152F, 0x002D0613,
    0x00272A04, 0x00031C28, 0x002B1011, 0x0007201E, 0x00172F06,
    0x00280016, 0x00102111, 0x002E0620, 0x00051D19, 0x00290C25,
    0x00101F15, 0x00240F12, 0x0030300A, 0x000A192C, 0x0021130E,
    0x000E2E1D, 0x001A0F12, 0x002D011F, 0x000F312C, 0x00180E12,
    0x0006281D, 0x00131603, 0x001C300F, 0x002A0F1B, 0x00191902,
    0x002C0C2F, 0x0010271A, 0x00220412, 0x000B2C32, 0x00031718,
    0x0024002B, 0x0014210F, 0x001A0825, 0x000B222A, 0x00130220,
    0x00022A27, 0x002B0F11, 0x001F3007, 0x00031B24, 0x0022022D,
    0x0008221C, 0x000C2925, 0x00321F06, 0x00031322, 0x0029081B,
    0x00171A08, 0x00022318, 0x002A0B1D, 0x000D1B21, 0x002E1013,
    0x000B1918, 0x0022200D, 0x00160123, 0x00280F12, 0x000D1E1E,
    0x0024120F, 0x00052517, 0x00103224, 0x00310D12, 0x00272301,
    0x00052922, 0x00210F11, 0x00102432, 0x0008161D, 0x002E1F0F,
    0x001D062A, 

    0x00103026, 0x002C1604, 0x001B0217, 0x00061E22, 0x00241408,         // 56
    0x00032730, 0x00091A18, 0x00122E0F, 0x0024011C, 0x00102C32,
    0x00081A18, 0x001D0C25, 0x00112B00, 0x00081E2A, 0x000E3212,
    0x00140127, 0x00220B30, 0x0010131D, 0x00092213, 0x0032300C,
    0x001E101C, 0x002B1E01, 0x00241909, 0x0001221E, 0x00202607,
    0x00110F1B, 0x00180831, 0x000F2515, 0x00220523, 0x0031180A,
    0x001D0C2D, 0x00012924, 0x00232F06, 0x00131110, 0x00202C0B,
    0x0019012C, 0x0000241C, 0x00120927, 0x001A1F00, 0x00052A17,
    0x002B0425, 0x00011C29, 0x00092616, 0x001E1901, 0x00230519,
    0x000D1F2A, 0x002D0B22, 0x00092131, 0x00110620, 0x00072D2A,
    0x00240117, 0x00022023, 0x00131908, 0x002B0A20, 0x001C1F0C,
    0x000D1226, 0x002A2B06, 0x00061614, 0x00213209, 0x0025120F,
    0x00171F05, 0x00270631, 0x0010251C, 0x00300D15, 0x00182D09,
    0x00121210, 0x00250731, 0x001A180A, 0x00102C14, 0x00200E2F,
    0x000B2824, 0x0026120E, 0x0015062E, 0x001F3205, 0x00042825,
    0x001A0A2F, 0x002D2D04, 0x0006272B, 0x001F0819, 0x00012C28,
    0x002F0B22, 0x00161906, 0x0023072D, 0x00092A1E, 0x001E0228,
    0x002B0B16, 0x00141A08, 0x00310428, 0x00262D03, 0x00032721,
    0x00171A08, 

    0x00200C13, 0x0000252F, 0x00122A0A, 0x002E082C, 0x00152310,         // 57
    0x00281105, 0x00200623, 0x002B230C, 0x00160C27, 0x00301303,
    0x0022051F, 0x0016250C, 0x00310715, 0x0025101B, 0x001F2606,
    0x002E160B, 0x00031F16, 0x00192901, 0x00280422, 0x0002162E,
    0x000D2518, 0x00140026, 0x000B2A2B, 0x0029120E, 0x001A042D,
    0x00052C24, 0x002E1E0A, 0x001F3205, 0x0005122B, 0x00122B10,
    0x000B1F1D, 0x002D130C, 0x00170727, 0x00091832, 0x00322707,
    0x000C1421, 0x002B1A05, 0x00222911, 0x00290620, 0x00110C31,
    0x001F2304, 0x0026150C, 0x0013082F, 0x00312B0E, 0x00041327,
    0x00282E09, 0x00190315, 0x0022290C, 0x00321404, 0x001D2210,
    0x00161207, 0x00302A0E, 0x00200D28, 0x00173104, 0x0026072D,
    0x0005281A, 0x001F0520, 0x00300D30, 0x000F1C19, 0x002D072D,
    0x000C2E16, 0x00061920, 0x001C1500, 0x000A2029, 0x002A0A22,
    0x001F1D03, 0x0004321F, 0x002C0C19, 0x000A212A, 0x002F0411,
    0x001C1604, 0x00062C29, 0x00301F0A, 0x00111710, 0x002A021B,
    0x00131E0A, 0x001E1120, 0x000F1613, 0x002C1C02, 0x00132409,
    0x001C042F, 0x0007211B, 0x002C130B, 0x00121E0F, 0x00181607,
    0x000B202E, 0x00012F1F, 0x001A1019, 0x001F0814, 0x000D132F,
    0x002A0218, 

    0x0031210C, 0x0019061C, 0x00271027, 0x001F1902, 0x000B2D1E,         // 58
    0x001A0B2A, 0x000F3214, 0x0006152C, 0x001C2809, 0x00052012,
    0x000B3029, 0x00271D07, 0x00011530, 0x000C2E21, 0x00170A2C,
    0x00270626, 0x000A2F1F, 0x002C0E2C, 0x00131B09, 0x00200827,
    0x00262D04, 0x002F0B11, 0x00170F15, 0x00083022, 0x00311B02,
    0x0014140F, 0x00260120, 0x000D161A, 0x002C0927, 0x001A2303,
    0x00280330, 0x00071B18, 0x001C2501, 0x00260D1E, 0x00031F15,
    0x0016062A, 0x001C2E0D, 0x0006122E, 0x000B181A, 0x00303109,
    0x00161111, 0x000C2D23, 0x002A2107, 0x00170E1C, 0x00101B21,
    0x001D2505, 0x0006172D, 0x00151018, 0x00001C29, 0x000C2C25,
    0x0027071E, 0x00051630, 0x000E2419, 0x00081C14, 0x002F1410,
    0x00112201, 0x00161A0B, 0x00082C24, 0x001C2502, 0x0004131E,
    0x00192708, 0x00220126, 0x002C2C0E, 0x00150619, 0x0001272C,
    0x000D1714, 0x00270127, 0x0013280E, 0x00221B01, 0x00013020,
    0x00102417, 0x0023011C, 0x00190D22, 0x0008262F, 0x00221201,
    0x00002429, 0x00260615, 0x000A3131, 0x00190323, 0x0024130E,
    0x000D3015, 0x00282800, 0x001F102A, 0x00032F18, 0x00300924,
    0x001C2B02, 0x0029140D, 0x00072225, 0x0013290F, 0x00251E06,
    0x00092E24, 

    0x00141B03, 0x00051421, 0x000F3116, 0x00081E12, 0x002C0325,         // 59
    0x00011719, 0x00321F01, 0x0025021D, 0x000E1B21, 0x0020082E,
    0x002D0F15, 0x00120124, 0x001C2910, 0x002A1B03, 0x00042117,
    0x0012180F, 0x001D2404, 0x00240213, 0x00052B1A, 0x001B210D,
    0x000A1320, 0x00051B30, 0x00222005, 0x001D0719, 0x000E2428,
    0x00230B17, 0x0009212F, 0x0017270C, 0x00001B14, 0x00210D1F,
    0x00153009, 0x00231013, 0x000E2A2C, 0x002E0211, 0x00113226,
    0x00200B19, 0x002D2002, 0x00130324, 0x0021240E, 0x00021C2B,
    0x001C001E, 0x00061918, 0x00210629, 0x00022714, 0x00250431,
    0x002F0B12, 0x000F2024, 0x002B320B, 0x0023081B, 0x002D0E13,
    0x00131B0A, 0x001B2E02, 0x002C032B, 0x001E0B22, 0x00012E1D,
    0x0022022F, 0x002C1117, 0x00250A12, 0x00140329, 0x0028200E,
    0x00310A2B, 0x00121013, 0x00071E2F, 0x00251309, 0x001D2F05,
    0x00300F1D, 0x0017210B, 0x0007132D, 0x001B0524, 0x00270F13,
    0x00150831, 0x002B1D07, 0x000E2F13, 0x00280917, 0x000C2A26,
    0x0031180E, 0x00170C1D, 0x00292806, 0x00071F1A, 0x00300D2C,
    0x00041820, 0x00180A26, 0x000A1B13, 0x00250431, 0x000D271D,
    0x00220E14, 0x0011002F, 0x00201B09, 0x002E0A2A, 0x0003171E,
    0x001C0D2C, 

    0x0022260E, 0x00260130, 0x002F2306, 0x00160D2E, 0x00232B0D,         // 60
    0x00132608, 0x001E0D31, 0x00172A0E, 0x002C1207, 0x00022E1A,
    0x00192402, 0x000D191C, 0x002F110D, 0x0015052D, 0x00210E1E,
    0x002F2C09, 0x00071332, 0x000D1D22, 0x0031102A, 0x00160915,
    0x002B2608, 0x00102F24, 0x002D031D, 0x0002292E, 0x00281709,
    0x00062D13, 0x001E0E29, 0x002F2F01, 0x00290525, 0x00102819,
    0x00051729, 0x002B0622, 0x0002221C, 0x00191406, 0x00241A0B,
    0x0007272E, 0x000D161D, 0x00270E16, 0x00192B04, 0x002C0A27,
    0x00242806, 0x00110C2E, 0x00301F02, 0x001B310A, 0x0008121A,
    0x00212C03, 0x000A141E, 0x001A002C, 0x00122304, 0x0004282F,
    0x00200520, 0x000A1F18, 0x0015120F, 0x00292605, 0x000D1729,
    0x00192907, 0x000A1D26, 0x0003311F, 0x001F1705, 0x000B2B1A,
    0x00011A22, 0x001B3004, 0x000E231C, 0x002E0524, 0x00111A11,
    0x00062432, 0x00210917, 0x002A2E08, 0x000C181A, 0x002E2005,
    0x000A2728, 0x001E130B, 0x0002192B, 0x00201F04, 0x0013051F,
    0x001B2E08, 0x00051C2C, 0x0011140F, 0x00200728, 0x00142B07,
    0x001D260B, 0x002E011C, 0x00112D0F, 0x002B2305, 0x0016170A,
    0x00051F27, 0x002F081A, 0x000C2521, 0x00183000, 0x00280412,
    0x000E2B17, 

    0x00061225, 0x00192D0A, 0x000C171F, 0x00200817, 0x00051328,         // 61
    0x002A0622, 0x00071913, 0x000B2125, 0x0013052B, 0x00231610,
    0x00290A28, 0x00082B31, 0x00222008, 0x00063127, 0x000C2513,
    0x00180324, 0x00280A18, 0x0015310C, 0x00222302, 0x0000171C,
    0x001E062D, 0x00260E13, 0x001A190B, 0x00121310, 0x00160825,
    0x002C1F04, 0x001A021E, 0x00121410, 0x00081D31, 0x001D1106,
    0x0031200F, 0x00132D03, 0x001F0930, 0x00092B17, 0x00290721,
    0x00171012, 0x00302208, 0x00043031, 0x00110622, 0x00081F1B,
    0x000D1514, 0x00292E0D, 0x0016101D, 0x000D1726, 0x002B1D0E,
    0x00130929, 0x00042916, 0x00281E08, 0x001E180F, 0x00091227,
    0x0026300C, 0x00310C2C, 0x00032B26, 0x00241C0A, 0x00130615,
    0x0031091A, 0x0026220E, 0x0010122D, 0x002E250A, 0x00180D31,
    0x00240416, 0x002B140D, 0x001F092A, 0x00032A15, 0x00190C20,
    0x002B0228, 0x00132902, 0x00021C21, 0x001F0C2F, 0x00182D0E,
    0x0005111F, 0x00312B10, 0x00160324, 0x002A0E18, 0x00072332,
    0x00210F12, 0x00250022, 0x002D2D04, 0x00022214, 0x002A1018,
    0x000C1D30, 0x00231503, 0x00002029, 0x001E0C22, 0x0008122D,
    0x00253110, 0x001B2806, 0x00021515, 0x00231031, 0x0008211C,
    0x002F0929, 

    0x00151F03, 0x002B051B, 0x00011B2B, 0x002D2F01, 0x001B1E0C,         // 62
    0x000E241D, 0x00273006, 0x00200B18, 0x00302C04, 0x0006251E,
    0x00161E0A, 0x001E0216, 0x00101422, 0x0025081A, 0x002C1901,
    0x00021E29, 0x00202806, 0x0010161F, 0x002C012F, 0x00092E25,
    0x00142904, 0x000C1F19, 0x00072529, 0x00323106, 0x00240F21,
    0x000E2A2F, 0x00031819, 0x0022250A, 0x00260822, 0x000D2F17,
    0x001A012B, 0x0026150C, 0x000E1C14, 0x002D0E27, 0x00131F04,
    0x0001292B, 0x00220225, 0x001C1B0C, 0x00261210, 0x002F2A0A,
    0x001B0430, 0x00012325, 0x00230716, 0x0006262D, 0x001D0221,
    0x00272309, 0x00170F30, 0x00300724, 0x000E2C1F, 0x002B0417,
    0x00182201, 0x0010191B, 0x001A0113, 0x0008211F, 0x001F1032,
    0x00062C24, 0x00151900, 0x001B0014, 0x00290821, 0x000E1F11,
    0x00062E27, 0x00132702, 0x000B1D2E, 0x0028160A, 0x00223106,
    0x000C201A, 0x001C1110, 0x0032062A, 0x000E2413, 0x00250026,
    0x00121B01, 0x0022082E, 0x000B251B, 0x001A3106, 0x002E130A,
    0x000F2727, 0x00081E1A, 0x0019092E, 0x000D1820, 0x00240325,
    0x00073212, 0x00140F1F, 0x00290617, 0x00182909, 0x0030021E,
    0x00121B0C, 0x002C0D2B, 0x00150522, 0x002A1A0D, 0x00112707,
    0x001F1710, 

    0x00280B23, 0x00102A14, 0x001E1011, 0x000A2721, 0x00130A30,         // 63
    0x00300F16, 0x0018002D, 0x00011427, 0x001B1C0D, 0x0011102E,
    0x002B0C25, 0x00002F12, 0x00312606, 0x001A0D2A, 0x00132D0B,
    0x001D1310, 0x0030062C, 0x00042016, 0x001B0D12, 0x00281B09,
    0x0021130E, 0x002E0A22, 0x001D0132, 0x00031C1C, 0x00200516,
    0x000A2112, 0x00301028, 0x00142C06, 0x00061F2D, 0x002A0F13,
    0x00012425, 0x00160C1E, 0x0008272C, 0x00213109, 0x001B041D,
    0x000D1618, 0x002B2E00, 0x0014091F, 0x0006242D, 0x00171802,
    0x00210F21, 0x00131A09, 0x002D2C05, 0x00190D12, 0x002F2A00,
    0x0003191C, 0x00103011, 0x00221603, 0x00022513, 0x00150C31,
    0x00061525, 0x00212909, 0x0028092E, 0x002E3203, 0x00101511,
    0x002A2709, 0x00220C2B, 0x00002F1C, 0x00092A29, 0x001F1708,
    0x0032111B, 0x001A0A22, 0x002C0113, 0x0005251E, 0x00151026,
    0x0008182E, 0x00272B0C, 0x00151504, 0x00082F1D, 0x002D0E18,
    0x001B290A, 0x00032015, 0x00270B23, 0x00111C11, 0x0001172D,
    0x00280615, 0x001E3000, 0x002F1210, 0x00152A0B, 0x001C2402,
    0x0032082C, 0x001F2807, 0x00061C2E, 0x000B2E12, 0x00211601,
    0x00032427, 0x000D2C18, 0x001F1F04, 0x000B2A26, 0x001A011F,
    0x0004322E, 

    0x00092317, 0x00220732, 0x00162104, 0x00280227, 0x001F1608,         // 64
    0x00042C11, 0x00242002, 0x000F261F, 0x002E0414, 0x000A291A,
    0x00231600, 0x0017082C, 0x000D181C, 0x00042014, 0x002A002F,
    0x0008291F, 0x000E111A, 0x00252C04, 0x000C2627, 0x0017041D,
    0x0005212B, 0x000F2B13, 0x00291603, 0x0018280B, 0x00130C2B,
    0x00272F01, 0x0019160D, 0x001F0420, 0x002D0B1C, 0x00121903,
    0x00222A08, 0x002E0418, 0x00281802, 0x00041223, 0x00312410,
    0x00250B30, 0x00081E15, 0x001F0F11, 0x000F2C28, 0x002A011B,
    0x000A3012, 0x0004212B, 0x0026041E, 0x00101531, 0x000B1F18,
    0x00240526, 0x001B0B2D, 0x00081D1A, 0x00270628, 0x001D2F05,
    0x00301E0D, 0x000F1121, 0x000A2416, 0x00160D2A, 0x00031D1A,
    0x001A0322, 0x000D1F17, 0x0030130C, 0x00241C03, 0x0015052F,
    0x00042415, 0x00261B06, 0x00102D28, 0x00190D11, 0x00252200,
    0x002F0314, 0x00001E23, 0x00210A30, 0x001A200D, 0x00061927,
    0x00290531, 0x000F161E, 0x002F2C03, 0x001D0328, 0x00232A0C,
    0x00140D1C, 0x000C1923, 0x00032130, 0x002A0C18, 0x00061627,
    0x000E1E1B, 0x0017130D, 0x002E0A24, 0x00102118, 0x002A1032,
    0x001C0514, 0x00260B1D, 0x0007172F, 0x002D0813, 0x00230F19,
    0x00321409, 

    0x00192D0E, 0x00021224, 0x002F1A0C, 0x00072F1C, 0x00101F18,         // 65
    0x002B1024, 0x00091929, 0x0016320A, 0x0027092F, 0x001E2108,
    0x00052D23, 0x002D1F0C, 0x00260520, 0x00203003, 0x00110F24,
    0x00232307, 0x00191C0C, 0x002B0922, 0x0007182D, 0x00313200,
    0x00230F16, 0x00150720, 0x00082E26, 0x00241210, 0x00061E1F,
    0x002D0625, 0x00012830, 0x000E1C13, 0x000A3129, 0x001B2210,
    0x00071232, 0x000D2E26, 0x001C1F0E, 0x0011082E, 0x00152C0B,
    0x000B1826, 0x00192808, 0x002F0623, 0x00041F17, 0x00231407,
    0x00320825, 0x001E0C19, 0x00171B0C, 0x00062F28, 0x002A0E14,
    0x00132C08, 0x0031140E, 0x000D2222, 0x002C2A08, 0x00120E1D,
    0x0025022E, 0x00012E12, 0x002C1A04, 0x001E0425, 0x00262E0E,
    0x002B1805, 0x0008242E, 0x00170925, 0x00102812, 0x00290D1F,
    0x000D3026, 0x001E130E, 0x00081F31, 0x002E0618, 0x000E2C2B,
    0x001D0C1C, 0x00113007, 0x002C0617, 0x000F261F, 0x00241303,
    0x00163108, 0x00200E12, 0x0009232B, 0x0017110F, 0x00051F21,
    0x00312605, 0x001A0229, 0x00262808, 0x0012061F, 0x00202C06,
    0x002C0315, 0x00033029, 0x00251905, 0x001A0020, 0x00042525,
    0x0014300E, 0x002E1306, 0x0017210B, 0x00002F28, 0x00122501,
    0x000D1D2C, 

    0x002B1806, 0x0025041E, 0x000B272A, 0x00190C13, 0x0023042D,         // 66
    0x00132905, 0x001C071B, 0x002C0D15, 0x00031321, 0x00131A10,
    0x001A0129, 0x000F1119, 0x00072730, 0x00171B0F, 0x002D0A17,
    0x00011728, 0x00102F31, 0x001F0211, 0x00130D18, 0x001D240A,
    0x00011430, 0x002D1B0C, 0x001C2207, 0x002C022E, 0x000D1817,
    0x001E2309, 0x00160E1A, 0x00231404, 0x00270118, 0x00320922,
    0x0017170C, 0x0025061C, 0x00022815, 0x00290F1F, 0x00202104,
    0x002C0419, 0x0002122C, 0x00263103, 0x00101A30, 0x0018290C,
    0x000C232E, 0x00142B01, 0x002C1110, 0x00202705, 0x001A0020,
    0x00001A2C, 0x001F2602, 0x00170315, 0x0003122A, 0x001B190F,
    0x000B2717, 0x00200829, 0x0011221C, 0x00191208, 0x00062830,
    0x0013061E, 0x001F1014, 0x002D3109, 0x001D012D, 0x00022217,
    0x002F1801, 0x0017081C, 0x00232707, 0x00021720, 0x0020120F,
    0x00092726, 0x0017190B, 0x00271029, 0x00052A12, 0x0030022C,
    0x000D221B, 0x00011B23, 0x002C0717, 0x00253009, 0x000F1531,
    0x002A0918, 0x00072E13, 0x0022130D, 0x000A1A2B, 0x0019200F,
    0x00270D30, 0x000B231E, 0x00121111, 0x00222C0C, 0x00311502,
    0x00091D2B, 0x000F281F, 0x00210923, 0x001B1910, 0x0027021B,
    0x001F0D22, 

    0x0014092F, 0x000F3118, 0x001D1E00, 0x002C1509, 0x00002E1F,         // 67
    0x0032230F, 0x00061731, 0x00211F07, 0x000C2E2B, 0x00252903,
    0x00300B16, 0x001F240B, 0x00281406, 0x000B2A27, 0x001C031C,
    0x00262501, 0x002F1014, 0x0004201E, 0x002A2B06, 0x000F1C25,
    0x0027031B, 0x000A2C12, 0x00120D2A, 0x0002271C, 0x00223103,
    0x00110A23, 0x002F2C0E, 0x00081F2D, 0x00142709, 0x00022D2B,
    0x00202300, 0x0012102C, 0x002F1906, 0x00180029, 0x00062F13,
    0x000F1B21, 0x001C250E, 0x00140D1D, 0x002B0212, 0x001D1020,
    0x00011815, 0x0028041F, 0x00081E2C, 0x000E1525, 0x002E230B,
    0x0026081D, 0x00083218, 0x002B0C2F, 0x00242D0B, 0x00072025,
    0x002F1500, 0x00140C23, 0x00292C0D, 0x000A172B, 0x00310D18,
    0x00222001, 0x00032B23, 0x000B151B, 0x00271E06, 0x00091128,
    0x00212A0B, 0x0011032C, 0x002A0E24, 0x0014320B, 0x00281C03,
    0x00310130, 0x0003241A, 0x001C1404, 0x000A1D22, 0x001E0A16,
    0x00182C0C, 0x00230C2F, 0x00122704, 0x001B0125, 0x000A1D1D,
    0x001E2401, 0x00150E2E, 0x000E1E25, 0x0030071A, 0x00002F22,
    0x00131501, 0x001E2909, 0x002D062E, 0x00081F1C, 0x00170827,
    0x001D0E12, 0x00250419, 0x000C2D2D, 0x002F1107, 0x0004262A,
    0x000A2B14, 

    0x0031160A, 0x00032428, 0x00290E14, 0x0015072E, 0x000C1B25,         // 68
    0x00261103, 0x00180122, 0x00112610, 0x002E061A, 0x00161026,
    0x000A1C1F, 0x0001312D, 0x00150721, 0x00320D13, 0x00061E2C,
    0x00132D09, 0x00091523, 0x001A0729, 0x0022120D, 0x0007262C,
    0x00190B21, 0x00201F03, 0x00310624, 0x00171115, 0x002A150D,
    0x001B0431, 0x0004191D, 0x00290825, 0x001E0F15, 0x000D1B1E,
    0x002A0B12, 0x00083222, 0x001D1F0D, 0x000C2A1A, 0x00240D2E,
    0x00301401, 0x00210826, 0x000B1F15, 0x00072C2A, 0x00222604,
    0x002E0A27, 0x00123109, 0x0024091A, 0x00042D14, 0x00110E30,
    0x00171F0F, 0x000C1328, 0x00141D08, 0x001F0820, 0x0010291A,
    0x00260332, 0x001B1B07, 0x00041F15, 0x00250121, 0x000D2A12,
    0x00190827, 0x002B1A0D, 0x00110D2A, 0x0016260F, 0x001B0622,
    0x002B1C11, 0x00062D1A, 0x000A2315, 0x001C0A29, 0x000D2113,
    0x00190F20, 0x00122B0F, 0x002B052D, 0x00253009, 0x0010182A,
    0x00281201, 0x0007201F, 0x002F1810, 0x0003112D, 0x00272C0D,
    0x002D0515, 0x0004171F, 0x00292A0B, 0x00172304, 0x00230B13,
    0x002E0128, 0x00061C18, 0x00190D23, 0x000E2814, 0x00272E08,
    0x00011B2F, 0x002B2304, 0x00061516, 0x00151F0D, 0x0029061F,
    0x001C1E03, 

    0x00181210, 0x00240021, 0x00072C1B, 0x0020220D, 0x00102919,         // 69
    0x001E0914, 0x00093028, 0x00281B0C, 0x0002142D, 0x001D2209,
    0x002B0412, 0x00221702, 0x00102119, 0x00242C05, 0x0019120D,
    0x00210430, 0x00282310, 0x000C2F19, 0x00301902, 0x00140515,
    0x00293108, 0x000E1718, 0x00082D2F, 0x00261C06, 0x00062A29,
    0x000C2018, 0x00242501, 0x0018300F, 0x00121605, 0x002D0227,
    0x00042718, 0x00270430, 0x00141507, 0x002D0924, 0x00091E11,
    0x0016270A, 0x00032E30, 0x00261806, 0x0031061B, 0x0015150B,
    0x000A2132, 0x00181B0F, 0x001E2803, 0x00310321, 0x001B1909,
    0x00222B01, 0x002D0223, 0x00042614, 0x00321804, 0x00190F11,
    0x000E2F13, 0x0009251E, 0x002D0E2E, 0x001E3103, 0x0015190B,
    0x00062331, 0x00240219, 0x001D2D04, 0x0031092F, 0x0004301E,
    0x00131402, 0x001F1032, 0x00301706, 0x0025041D, 0x00072D2D,
    0x002C0916, 0x00221908, 0x00062025, 0x00160817, 0x0002241E,
    0x002D0314, 0x000B3126, 0x001E081A, 0x0014290B, 0x00101B21,
    0x00190B29, 0x00233107, 0x0011022C, 0x001E1017, 0x00052632,
    0x000D191E, 0x0029320C, 0x00212205, 0x0003162B, 0x002F031A,
    0x00140F21, 0x0020310A, 0x00190A26, 0x00102A31, 0x00220E19,
    0x00082E25, 

    0x0012280B, 0x000B1B31, 0x001B1302, 0x00300529, 0x00281708,         // 70
    0x0004202F, 0x002F0F1D, 0x00152A01, 0x00220B17, 0x000E2824,
    0x00052C1D, 0x00170D32, 0x0029012A, 0x000C1923, 0x00022718,
    0x002C091E, 0x00111C04, 0x00180D2B, 0x00002920, 0x001E0F32,
    0x00052327, 0x002C120F, 0x001C081F, 0x0013250A, 0x00200021,
    0x002B0C12, 0x000F122C, 0x00300620, 0x00062130, 0x00232C0D,
    0x001B1D06, 0x000F111E, 0x00212C0F, 0x00012529, 0x001E0518,
    0x00280F21, 0x0012021C, 0x001A230D, 0x000E112C, 0x00052F21,
    0x001C0116, 0x002B0F1D, 0x0002132D, 0x000D2127, 0x00290B17,
    0x0008242A, 0x001E101A, 0x000F3030, 0x00270622, 0x00011C2B,
    0x002B0926, 0x00211409, 0x00130629, 0x00022619, 0x00290F25,
    0x002F1307, 0x000F2713, 0x00001E1C, 0x0025170B, 0x000E2216,
    0x00280027, 0x00181F0D, 0x00032723, 0x00161A0A, 0x00201101,
    0x00012826, 0x000E131C, 0x001A2D03, 0x00320E2F, 0x0020290D,
    0x00141C06, 0x00191031, 0x00292308, 0x0023042B, 0x00311304,
    0x000C2412, 0x00021F1B, 0x002E150F, 0x000A1C23, 0x00272D08,
    0x001C1210, 0x0016062E, 0x00120A25, 0x00251310, 0x001C2700,
    0x00111929, 0x00072111, 0x0032011D, 0x00261601, 0x00011C13,
    0x002E042C, 

    0x00272104, 0x002D0916, 0x000F311F, 0x00012512, 0x00141024,         // 71
    0x001A2D06, 0x001F0311, 0x000A1821, 0x002C052F, 0x00131D05,
    0x0030130F, 0x001D2308, 0x00072F14, 0x002E1011, 0x000F2028,
    0x001E1608, 0x00062A26, 0x00240014, 0x002A210E, 0x0011170A,
    0x0023021C, 0x00172801, 0x00021E2C, 0x002E0E14, 0x00081926,
    0x00182E0C, 0x00001C1B, 0x00202908, 0x000B1319, 0x00150C29,
    0x00310716, 0x0009222C, 0x002B1802, 0x001A1015, 0x000E312F,
    0x002E1903, 0x00052C27, 0x002A0A17, 0x001F1D0F, 0x002D2500,
    0x00250C25, 0x000F2312, 0x00273005, 0x0016170D, 0x00052C1F,
    0x00130612, 0x00251E06, 0x0016150C, 0x000C2316, 0x001D2B02,
    0x00071F1B, 0x0018280F, 0x00301805, 0x000E1E13, 0x001B041D,
    0x00082E2A, 0x00200C21, 0x0018052C, 0x000A1224, 0x002E2A07,
    0x00210B2B, 0x000C2C13, 0x002D051B, 0x000F302A, 0x00292010,
    0x00130631, 0x002E1E0D, 0x00250122, 0x000A1A12, 0x000F1328,
    0x00260920, 0x00062E16, 0x000E1711, 0x00001D24, 0x00092F17,
    0x00210E30, 0x001B0725, 0x00252902, 0x0016051D, 0x00110D29,
    0x002C1F03, 0x00042A1A, 0x00312508, 0x000D1D1E, 0x00082F31,
    0x002C0714, 0x00240D18, 0x000B292B, 0x001C240A, 0x000E3023,
    0x001E0B18, 

    0x00032B2B, 0x00150F27, 0x001D1F09, 0x0025022E, 0x00091A1D,         // 72
    0x002A0816, 0x0011272A, 0x00052213, 0x0026310B, 0x001B1029,
    0x000B191A, 0x00260526, 0x00120920, 0x001A2903, 0x00250B2E,
    0x00152E0D, 0x0031081C, 0x000D132D, 0x00193006, 0x00091D24,
    0x00300C13, 0x000D2C2A, 0x0028061A, 0x00223005, 0x00101431,
    0x001E2703, 0x002D0A2A, 0x00120223, 0x00292F10, 0x00191901,
    0x00022622, 0x00262E0A, 0x00140825, 0x00051E1E, 0x0025120C,
    0x00132110, 0x00211508, 0x000B2929, 0x0016071F, 0x0000182E,
    0x00132C08, 0x00061C2A, 0x0020041A, 0x002E0830, 0x001C1C09,
    0x00300D2C, 0x00022925, 0x002A041D, 0x00210B2E, 0x002F120B,
    0x00110124, 0x00240C30, 0x000A3021, 0x0027082D, 0x00142A02,
    0x0024150F, 0x00121B09, 0x002C3000, 0x001D2510, 0x00150E18,
    0x00021C1E, 0x001C1603, 0x0024092F, 0x00061317, 0x001A0C21,
    0x001F2406, 0x00083118, 0x00140B2C, 0x001E240A, 0x00032C1B,
    0x002B2003, 0x001B012B, 0x002E0E1C, 0x001F2701, 0x0018091F,
    0x002C2B09, 0x00131A0E, 0x0007112D, 0x00313011, 0x00012216,
    0x001F032C, 0x000B1822, 0x001A0C13, 0x00280026, 0x0021110E,
    0x00182B06, 0x00051C24, 0x00141405, 0x002A082F, 0x0017110F,
    0x0009181E, 

    0x00201D0E, 0x002A061B, 0x00061613, 0x002E2904, 0x00212F0C,         // 73
    0x000C1D31, 0x002D1502, 0x00210E27, 0x0017091F, 0x00002016,
    0x002A2D01, 0x0006262E, 0x00211D0B, 0x00011819, 0x002A0322,
    0x00081E16, 0x00211900, 0x00032621, 0x002C0D18, 0x001F072F,
    0x0004251F, 0x001C1A08, 0x0014130E, 0x000B2223, 0x0032031D,
    0x00041F12, 0x00240F16, 0x001B2406, 0x00051D2F, 0x002E051D,
    0x00200F11, 0x00101632, 0x001E031A, 0x002F2907, 0x000C2428,
    0x001B0122, 0x00300D31, 0x00071A13, 0x00283205, 0x0021021B,
    0x0032140E, 0x001A0A22, 0x000B2B14, 0x00101120, 0x00232201,
    0x00093119, 0x000E1713, 0x001A2403, 0x000A2C27, 0x00041918,
    0x00172E10, 0x002B2308, 0x00011117, 0x001F190C, 0x00062025,
    0x00320A17, 0x00032330, 0x0027071A, 0x00071928, 0x0011032E,
    0x0028310A, 0x00092525, 0x00131E0D, 0x00312905, 0x000B1A13,
    0x002B0328, 0x0003151E, 0x00281C00, 0x002F1115, 0x00180530,
    0x0022150E, 0x00072A25, 0x0012220C, 0x0026062F, 0x00101414,
    0x0005202A, 0x00280019, 0x000C2621, 0x00211606, 0x00180826,
    0x00252C0E, 0x002B130A, 0x0007312F, 0x00142003, 0x0001171B,
    0x000F242C, 0x002F0320, 0x001F2D0D, 0x0002221A, 0x00300226,
    0x00252608, 

    0x00191300, 0x000B2D25, 0x0010222C, 0x00130A21, 0x00180D18,         // 74
    0x00021123, 0x001C2C09, 0x0012001B, 0x00302506, 0x000F1630,
    0x001E0213, 0x00150C1E, 0x00311210, 0x000B322A, 0x00142306,
    0x001D0F31, 0x00102C12, 0x00270529, 0x0016220C, 0x00122D02,
    0x0025140F, 0x002A0327, 0x0001282F, 0x00190D16, 0x00272B09,
    0x0015072D, 0x000A3220, 0x000F1728, 0x0026120C, 0x000D2815,
    0x00082027, 0x002A3105, 0x00180C13, 0x0007192D, 0x00270F11,
    0x00022F19, 0x00152703, 0x001E061D, 0x000E2225, 0x00181014,
    0x00092631, 0x00241F02, 0x002C180C, 0x00012728, 0x0018130F,
    0x002B0024, 0x001E0931, 0x002E1B0A, 0x00131020, 0x00262007,
    0x001E072C, 0x000F151E, 0x001A0928, 0x00292806, 0x0016001C,
    0x000C2D29, 0x001B1012, 0x000D2922, 0x0023130C, 0x00302104,
    0x00190820, 0x002C1111, 0x00220229, 0x00022E1D, 0x00250E2D,
    0x00182608, 0x00112C10, 0x001C0724, 0x00052729, 0x00123007,
    0x000C1E22, 0x002F0A13, 0x00171A08, 0x00093228, 0x00321806,
    0x00230B23, 0x001C2E02, 0x00121D0C, 0x002A0C31, 0x0009241F,
    0x00131B01, 0x000F271D, 0x001E0E17, 0x002E0629, 0x0023280B,
    0x00290A16, 0x001A0F12, 0x000A1929, 0x00231E02, 0x000D2F15,
    0x00120C32, 

    0x00041B20, 0x00320116, 0x00261206, 0x001D260F, 0x002F0329,         // 75
    0x000F2014, 0x0024270F, 0x0005192C, 0x0027300E, 0x00081222,
    0x002C2B08, 0x0010212C, 0x00192803, 0x00250626, 0x002E140B,
    0x0005281C, 0x002C0B26, 0x001A1507, 0x000C1B1D, 0x002E102B,
    0x000A1F17, 0x00173106, 0x002C081C, 0x00211D03, 0x00071926,
    0x001D120E, 0x002A2202, 0x0030041C, 0x00142D07, 0x001C0A2C,
    0x00230020, 0x00011B18, 0x000E2324, 0x002C2C00, 0x00200520,
    0x00101C15, 0x00230A2A, 0x002A120A, 0x00041E2D, 0x002E2B0B,
    0x00120818, 0x00043026, 0x001D021C, 0x00130D2D, 0x00282D06,
    0x00061E1F, 0x00112A17, 0x00220E11, 0x0000302B, 0x002C0214,
    0x000B291B, 0x00311E00, 0x00052F12, 0x00112232, 0x002E130E,
    0x00211804, 0x002A051D, 0x00171E07, 0x00022F26, 0x001E0D15,
    0x000E2B19, 0x00051931, 0x00172301, 0x001D0B15, 0x000E2023,
    0x002D130C, 0x00210932, 0x000B211A, 0x0024160C, 0x002A0D1E,
    0x00200317, 0x0001252C, 0x0029101F, 0x001C0218, 0x000F2911,
    0x0001231C, 0x00160F2E, 0x002F0514, 0x00052D1A, 0x001C120F,
    0x0030012B, 0x00220A11, 0x00062221, 0x00192C06, 0x000C1323,
    0x00041D2F, 0x0015320A, 0x002E071D, 0x0006122E, 0x001C0522,
    0x002C2910, 

    0x001F082B, 0x00163009, 0x00021E30, 0x000A181A, 0x00283201,         // 76
    0x0007142E, 0x002C0B1E, 0x00140625, 0x001A1E03, 0x00210819,
    0x000C1B24, 0x00230515, 0x0003171B, 0x001D0C12, 0x000E1C22,
    0x00160117, 0x0022210D, 0x00013115, 0x001F0330, 0x00062511,
    0x00220A25, 0x00111721, 0x00062313, 0x000E2E2C, 0x002E0B1F,
    0x00112A11, 0x00011A31, 0x001E0B17, 0x00071F25, 0x002B1810,
    0x00172A02, 0x0032130D, 0x001E062F, 0x0015110A, 0x000A202C,
    0x0031150C, 0x00062324, 0x00132F10, 0x001B1601, 0x00200521,
    0x00260E2B, 0x002A1605, 0x000E2312, 0x00301C09, 0x00200614,
    0x000C162B, 0x00272202, 0x0016041C, 0x000D2524, 0x001B1405,
    0x00240A2F, 0x00081A27, 0x001E0421, 0x00250E16, 0x00091D24,
    0x0001322B, 0x0013250A, 0x002F0930, 0x00101B13, 0x0029012B,
    0x00082622, 0x002B150E, 0x00122C09, 0x002F0426, 0x00081719,
    0x00153104, 0x00011D21, 0x00310014, 0x00152902, 0x00071A2F,
    0x001B2E06, 0x0014140D, 0x00232C01, 0x00061F32, 0x00210825,
    0x002D130A, 0x000B1B27, 0x001F2807, 0x000F1629, 0x00261F04,
    0x00002F24, 0x000D1915, 0x002B1031, 0x00131A0E, 0x0032021D,
    0x00202901, 0x00101527, 0x00252506, 0x00132C0E, 0x00291808,
    0x0009221C, 

    0x0011260D, 0x002B0F26, 0x0023091E, 0x001E290B, 0x00120524,         // 77
    0x00191B0D, 0x001F2C06, 0x00092415, 0x00321030, 0x00022811,
    0x00130E29, 0x002E300A, 0x000A1E32, 0x00272C07, 0x0006252B,
    0x00292E01, 0x000A182D, 0x00310821, 0x00142A05, 0x002B0D1B,
    0x001A2B03, 0x00300131, 0x00201209, 0x00150719, 0x0028160B,
    0x0018012A, 0x00232505, 0x000D2F1F, 0x0025110A, 0x0004262E,
    0x00110D1A, 0x000A1E28, 0x00253010, 0x0005261C, 0x001C0B17,
    0x00262A04, 0x0018031E, 0x002C0D2E, 0x000A2919, 0x00021B13,
    0x00162508, 0x00082E1D, 0x00190B24, 0x00062932, 0x001B0F1A,
    0x00023026, 0x0032120D, 0x001C0B2F, 0x00291909, 0x00052E19,
    0x0017220D, 0x00121210, 0x002A2C09, 0x0015081D, 0x001A2802,
    0x00280215, 0x001F0E20, 0x00051619, 0x00262D01, 0x0019130D,
    0x00141F05, 0x001F0F2A, 0x0026071E, 0x00031C2E, 0x0023290F,
    0x001C102A, 0x00280B11, 0x00102D2C, 0x001E1026, 0x002D0611,
    0x000F2224, 0x0030082A, 0x000C181E, 0x002B0D14, 0x00122704,
    0x00182F0E, 0x0028031F, 0x00042416, 0x002C0721, 0x00150B2D,
    0x001A290B, 0x001F041B, 0x00262602, 0x00043029, 0x001B0B18,
    0x000A2213, 0x002C0D21, 0x001D0217, 0x0000202B, 0x00180A25,
    0x00241404, 

    0x00031D19, 0x000C2C14, 0x00141503, 0x0006232C, 0x00301012,         // 78
    0x0001211B, 0x0029032A, 0x000E1622, 0x00252E09, 0x0017021F,
    0x001E2200, 0x0028140E, 0x001B0420, 0x00121127, 0x00300714,
    0x001F0B1E, 0x00191209, 0x00111F27, 0x00241A0C, 0x00031428,
    0x000D2116, 0x0016190E, 0x00002D29, 0x00241D01, 0x000B2924,
    0x0005201B, 0x00310F15, 0x00130628, 0x001A170E, 0x002E0223,
    0x001F2D07, 0x00290820, 0x00131604, 0x002E0129, 0x000E1C23,
    0x00002E30, 0x001F1808, 0x000D1F12, 0x00250920, 0x00310028,
    0x00101E2F, 0x001F1111, 0x002E0317, 0x00252000, 0x00110720,
    0x00231A11, 0x00142606, 0x00072A21, 0x00101F13, 0x002F0628,
    0x00200E1F, 0x002D2704, 0x0002172E, 0x000E2328, 0x0031110E,
    0x000A192D, 0x00182B0F, 0x000C2128, 0x0021041E, 0x000A282F,
    0x00320A1A, 0x00052412, 0x00103015, 0x00191203, 0x002D2108,
    0x0012031F, 0x00062517, 0x00231705, 0x000A241B, 0x00021D20,
    0x00260E14, 0x00052B1A, 0x00182309, 0x001E0423, 0x00021D29,
    0x00240E19, 0x0009172F, 0x00192C00, 0x0022110D, 0x00091C19,
    0x00312206, 0x00110D20, 0x00081525, 0x00161F0C, 0x0029062D,
    0x00231807, 0x00072F31, 0x000F1C11, 0x0031101B, 0x000D3013,
    0x002D0530, 

    0x00220D1F, 0x0018022D, 0x002D1A0F, 0x00250720, 0x000F2F17,         // 79
    0x00220A32, 0x00152A02, 0x001D1210, 0x00041D19, 0x002C0A2B,
    0x00081A16, 0x000F2B2D, 0x00002718, 0x00222004, 0x0014170E,
    0x000D232F, 0x00022A18, 0x002A0212, 0x0009281C, 0x001E072D,
    0x00263208, 0x002A0C23, 0x0009261D, 0x002E0414, 0x001A112F,
    0x002A2D09, 0x001E0911, 0x00031E30, 0x00272A00, 0x000F1C18,
    0x00072312, 0x001A1031, 0x00022116, 0x0021280D, 0x00281306,
    0x00150813, 0x002F1018, 0x00062726, 0x0013310D, 0x001B140A,
    0x002A2C03, 0x000B1825, 0x00002A2A, 0x0014140B, 0x002A2E0F,
    0x00091129, 0x002C012E, 0x0020091B, 0x00271501, 0x00032C31,
    0x00140216, 0x000C1C23, 0x00270918, 0x001F3006, 0x00051F1A,
    0x00230724, 0x002D2605, 0x00111209, 0x002A0D16, 0x00013125,
    0x001D1A09, 0x00240222, 0x002C0C28, 0x000B271C, 0x001F082F,
    0x000C1A24, 0x00302F09, 0x00180530, 0x002A1210, 0x001C3108,
    0x0016012E, 0x00211B03, 0x002A1210, 0x00083130, 0x002D140A,
    0x000E2613, 0x0030092B, 0x00122110, 0x00290126, 0x000E3230,
    0x00041713, 0x002A082C, 0x00212B10, 0x002F1205, 0x00012D1E,
    0x00131024, 0x0019270C, 0x00270629, 0x001F2A03, 0x00071923,
    0x001B280A, 

    0x00302201, 0x00073124, 0x001D1F08, 0x000A2828, 0x00191305,         // 80
    0x002C190C, 0x0006201E, 0x002F0C27, 0x00122607, 0x000B2F23,
    0x00211012, 0x0031081E, 0x00181309, 0x002C0025, 0x00052D1D,
    0x00261B02, 0x002E1028, 0x001B2E07, 0x00150E24, 0x00301E01,
    0x00051318, 0x0019052E, 0x00102011, 0x001E0B27, 0x00131B06,
    0x0007171E, 0x000E2422, 0x002C3107, 0x0009121D, 0x00160C2C,
    0x00230526, 0x002D2F09, 0x000C1A1B, 0x0018092E, 0x00083121,
    0x0010231C, 0x001D042B, 0x002A1A02, 0x00210B30, 0x0003231B,
    0x00180E14, 0x0022051F, 0x00282206, 0x001B082E, 0x000D271C,
    0x001E1E08, 0x00032417, 0x0017320E, 0x000A1C25, 0x001D1110,
    0x00252109, 0x00062E2A, 0x001C1013, 0x00160430, 0x002B160B,
    0x00130D1F, 0x00032E31, 0x001E1C11, 0x0015062B, 0x002D1F0F,
    0x00121506, 0x00082D31, 0x00171D0B, 0x00001717, 0x00272C0D,
    0x00161310, 0x00031F1C, 0x00200D26, 0x00122901, 0x000C1629,
    0x0032260C, 0x00110725, 0x000C2A1B, 0x00160C1F, 0x00232002,
    0x001C0522, 0x00062E1A, 0x00201B07, 0x0002141E, 0x001D2403,
    0x00240423, 0x00182708, 0x000B1A1A, 0x001B0027, 0x000E2414,
    0x001F1E03, 0x002E0916, 0x0003151F, 0x00162009, 0x002A012D,
    0x00131210, 

    0x000D1730, 0x00260918, 0x00120E13, 0x0029031B, 0x0003242D,         // 81
    0x001F0723, 0x000B3115, 0x0024012C, 0x0019180E, 0x00290631,
    0x00142204, 0x00051C28, 0x00273210, 0x000B2430, 0x00170E15,
    0x001D062C, 0x00081521, 0x000E2114, 0x00240432, 0x0012260F,
    0x000B1B20, 0x00222B0B, 0x00321503, 0x00022F1A, 0x0028280E,
    0x0024062C, 0x00150D16, 0x00210026, 0x001C1910, 0x002F270A,
    0x0003161F, 0x00142A03, 0x00290325, 0x001F0F11, 0x002E1601,
    0x00241C0C, 0x00042C23, 0x00171508, 0x000A2017, 0x002E0722,
    0x000E272D, 0x00051B11, 0x00103019, 0x002D0D15, 0x00061827,
    0x00310423, 0x00241603, 0x00120C20, 0x002E052C, 0x00192806,
    0x0031081E, 0x0012150E, 0x00292901, 0x000D2026, 0x00082B15,
    0x001B2303, 0x00300118, 0x00081722, 0x00272502, 0x000B2A20,
    0x001B091B, 0x002F1014, 0x00202300, 0x002A0426, 0x00130B2B,
    0x00232603, 0x002B012D, 0x00092213, 0x002D0922, 0x00061D19,
    0x00260F15, 0x0001212C, 0x001F1806, 0x002F0316, 0x0004282D,
    0x0013170D, 0x002A0D26, 0x0016280C, 0x002F0A2A, 0x00102C16,
    0x002D0E1C, 0x0013200D, 0x00062F32, 0x00280E11, 0x0024072B,
    0x0005171B, 0x000C2B2F, 0x00230F12, 0x00102628, 0x00250A17,
    0x00012C1D, 

    0x00200425, 0x0017250A, 0x00042A29, 0x00321702, 0x00172D0E,         // 82
    0x00131C07, 0x002B1012, 0x000F2518, 0x001E2C01, 0x0001141B,
    0x0024290B, 0x001C0421, 0x00111805, 0x001F091A, 0x002A1E08,
    0x00112F0F, 0x00222606, 0x00290A19, 0x0001171F, 0x001C3009,
    0x002C092B, 0x00170E15, 0x000D2330, 0x001F0221, 0x00081E29,
    0x00191302, 0x0030290C, 0x0001202F, 0x00112C05, 0x00260929,
    0x000D1E17, 0x0022120F, 0x0007202C, 0x000F2619, 0x00022A28,
    0x001A0132, 0x00320D15, 0x000F2811, 0x0028032B, 0x001B2F04,
    0x0026160A, 0x00300B23, 0x00160130, 0x00201D02, 0x00132A0B,
    0x00190F12, 0x000C2E31, 0x00281F0C, 0x00002B1C, 0x000E1916,
    0x00082428, 0x00200C2E, 0x00021B19, 0x002F0320, 0x00210A2B,
    0x0026190F, 0x000E1126, 0x00182F0A, 0x00210A2D, 0x00041317,
    0x00240027, 0x000D282C, 0x00051221, 0x0010321B, 0x001D1B09,
    0x00041120, 0x000F2E17, 0x00171806, 0x001D2B0B, 0x00220431,
    0x00142F0E, 0x001B0920, 0x00282C0A, 0x000A1D29, 0x001A1013,
    0x00242F05, 0x000B1F31, 0x00260614, 0x000D1321, 0x00191D09,
    0x0003182E, 0x00200925, 0x00321400, 0x00102820, 0x00161F07,
    0x0029300B, 0x001C0526, 0x00311B01, 0x00063221, 0x001B1405,
    0x002B1E0C, 

    0x00052F12, 0x002D1C06, 0x00231021, 0x000F2031, 0x00210A1E,         // 83
    0x00270427, 0x0009212F, 0x00051220, 0x00310925, 0x00101F2A,
    0x002C0C15, 0x00082D2E, 0x002F1111, 0x0002282B, 0x000A1420,
    0x00320225, 0x00041B2A, 0x00152B0D, 0x002F1102, 0x00081F28,
    0x0026001B, 0x00042A25, 0x002A1908, 0x00160A11, 0x002E0F15,
    0x000C2E1C, 0x00061621, 0x00280713, 0x00190E1A, 0x00072322,
    0x001C0231, 0x0031310B, 0x00170C22, 0x001D0715, 0x002B1309,
    0x00112205, 0x00082E1B, 0x00211027, 0x00011D1E, 0x0012130F,
    0x00082926, 0x001E2207, 0x000D2C13, 0x00251020, 0x0001212C,
    0x0029071D, 0x00062616, 0x001B0329, 0x00211404, 0x002A0E12,
    0x00160023, 0x002C2F09, 0x001A2605, 0x00141210, 0x0007321C,
    0x00152707, 0x00001E2F, 0x002B041D, 0x00101A12, 0x0031210B,
    0x00143004, 0x0028160F, 0x001A1F07, 0x002D0812, 0x00082A32,
    0x00301E0E, 0x001F062A, 0x00280C1C, 0x00021228, 0x000E241E,
    0x002E1605, 0x0007272B, 0x00131210, 0x002C071D, 0x000E2424,
    0x00310019, 0x0000151F, 0x001B2401, 0x0007312D, 0x002B0211,
    0x00242A06, 0x000C2413, 0x001D0417, 0x0000191C, 0x002D0B2D,
    0x00091322, 0x0012240F, 0x00170C19, 0x00210331, 0x000A2314,
    0x00130F2A, 

    0x001E0A1A, 0x000D152E, 0x001B0116, 0x00083011, 0x00001319,         // 84
    0x001C2A03, 0x002E1710, 0x00142D06, 0x00201A0D, 0x00170212,
    0x000C241E, 0x001A1B02, 0x00230326, 0x0016200E, 0x00262C03,
    0x00180F13, 0x001D081D, 0x000D202F, 0x00200523, 0x00192D10,
    0x00111605, 0x0021260E, 0x000A121E, 0x000F312C, 0x00232205,
    0x001C0532, 0x002A2408, 0x000F1D2A, 0x00222F01, 0x002D1510,
    0x00131A06, 0x0000271D, 0x00271702, 0x000A2C2A, 0x00211D10,
    0x00160B20, 0x0029062E, 0x001A1901, 0x002D250D, 0x00240830,
    0x00180E17, 0x0003192B, 0x002B061B, 0x000A1328, 0x002F3105,
    0x001F190E, 0x00140A24, 0x002D1B0A, 0x00103021, 0x00052330,
    0x001D1D0D, 0x000A161D, 0x00240725, 0x000C2232, 0x002D150B,
    0x00200621, 0x00280D15, 0x001C2C03, 0x0008272A, 0x00190C23,
    0x00011C2F, 0x001F061A, 0x00092529, 0x00140D25, 0x00250216,
    0x00191304, 0x000A2823, 0x0013210F, 0x00313102, 0x00081B13,
    0x00270126, 0x00190D17, 0x00251F00, 0x00053230, 0x00171806,
    0x001E0D11, 0x00102C2B, 0x002D1A0A, 0x001F0C17, 0x00101F28,
    0x00160820, 0x0029112B, 0x00083126, 0x0014220D, 0x001F2A05,
    0x00230115, 0x00032C2B, 0x002A1F06, 0x000D171D, 0x0026290A,
    0x00300622, 

    0x00092C28, 0x002A2100, 0x0014260C, 0x002F0B26, 0x00291B0B,         // 85
    0x000C2422, 0x00160C29, 0x0024051B, 0x00032731, 0x00292F04,
    0x0025102B, 0x00051518, 0x0012300A, 0x002B071C, 0x000E1931,
    0x00062618, 0x002D3105, 0x0027140A, 0x000A2416, 0x002B0D2D,
    0x00021C19, 0x00300731, 0x001B2000, 0x00270426, 0x00001B18,
    0x00132B0E, 0x00200C23, 0x00170116, 0x0003111E, 0x000C2A2E,
    0x00290626, 0x00210A12, 0x000E1F2F, 0x002E031B, 0x00031625,
    0x0026310B, 0x000D1F14, 0x00042A23, 0x00151407, 0x000E3213,
    0x0031021F, 0x00212D00, 0x00121F10, 0x001C2809, 0x00170218,
    0x0008242F, 0x00231301, 0x000B282B, 0x00180D11, 0x0026061A,
    0x002F2A02, 0x0011102C, 0x00032C14, 0x00280C18, 0x00181B01,
    0x00042D2C, 0x000B2025, 0x00131509, 0x002E101B, 0x00230515,
    0x002A2906, 0x0010111F, 0x002E2D0C, 0x00211802, 0x000E2F1E,
    0x0005232C, 0x002B1908, 0x00230330, 0x001B0E18, 0x0015082D,
    0x00202C0A, 0x00022322, 0x000F151A, 0x00200427, 0x0029290B,
    0x00042122, 0x00270915, 0x00170525, 0x00062A1D, 0x00301503,
    0x00022E1A, 0x001A1C0B, 0x00221404, 0x00300730, 0x00190E20,
    0x000C1C19, 0x002F150B, 0x001D0725, 0x00152E10, 0x0001112C,
    0x00191D07, 

    0x0022130E, 0x0002191C, 0x00250720, 0x00102C2C, 0x00191107,         // 86
    0x0021022E, 0x00063215, 0x002C1E0A, 0x000F1321, 0x001B0713,
    0x000A2025, 0x002E2907, 0x001D0B21, 0x00021228, 0x001F220C,
    0x0025012B, 0x00130D22, 0x00041A28, 0x0016290F, 0x00230320,
    0x00133007, 0x001E0C22, 0x00072C16, 0x0017160A, 0x0031101F,
    0x000B1329, 0x002C2804, 0x0008192C, 0x0030250C, 0x001D1E08,
    0x00160F17, 0x00052423, 0x00192F09, 0x00130E16, 0x001D2506,
    0x0007112D, 0x00300019, 0x001E0D2A, 0x002B071C, 0x00061E2C,
    0x000B2325, 0x0029110E, 0x00051731, 0x00260C26, 0x000E1C20,
    0x00290F12, 0x00042D1E, 0x00300117, 0x00202107, 0x00031A2A,
    0x00140A1F, 0x0022240F, 0x002E1E07, 0x001E0428, 0x0010251E,
    0x00320B12, 0x00240119, 0x001E240E, 0x00031B31, 0x000C2D20,
    0x0015160D, 0x0007222B, 0x00270514, 0x00021E2F, 0x001D1019,
    0x00280911, 0x00102C14, 0x0000161D, 0x000B2824, 0x002C1F05,
    0x0011180E, 0x0028062C, 0x002F2E07, 0x00140A12, 0x00091C19,
    0x002E102E, 0x00133004, 0x00231E0D, 0x000C1131, 0x0025240F,
    0x00110E2E, 0x002C0115, 0x000A2B1D, 0x000F1F12, 0x00022629,
    0x00262F02, 0x00130D30, 0x0005251F, 0x00271A02, 0x002D0018,
    0x00102420, 

    0x00300616, 0x00160F32, 0x001D2905, 0x00041E13, 0x000A161B,         // 87
    0x0031210F, 0x00110D1E, 0x001D1600, 0x0008232C, 0x00300C19,
    0x0013190E, 0x00210130, 0x000D2415, 0x00172D10, 0x00301600,
    0x000B1D15, 0x001A2B09, 0x0020061B, 0x00311202, 0x00091E2B,
    0x0029150C, 0x000D2227, 0x002C0111, 0x0010272E, 0x001F2E06,
    0x00052013, 0x0023041A, 0x001A3210, 0x00110A24, 0x0024051B,
    0x00092E2C, 0x00301301, 0x0023190E, 0x0029062A, 0x00102921,
    0x00221803, 0x0017210F, 0x00112708, 0x00252C11, 0x00201603,
    0x001B0A19, 0x00142806, 0x001E041C, 0x00092F14, 0x00322603,
    0x00140928, 0x001D1F0C, 0x00101632, 0x00092B24, 0x0027120B,
    0x000D3115, 0x001A0230, 0x00091423, 0x00152E0D, 0x0006182F,
    0x001A2904, 0x000F112A, 0x002C3006, 0x00170927, 0x00200311,
    0x00301D03, 0x001C0A26, 0x00182B09, 0x000C1323, 0x00312805,
    0x00130321, 0x001B0D29, 0x002F1E01, 0x00211110, 0x00063028,
    0x001D0F1E, 0x000C2615, 0x00051B20, 0x001C0E2F, 0x00242702,
    0x000D171F, 0x001B0229, 0x0003261B, 0x002C1806, 0x001C0424,
    0x00172008, 0x00042721, 0x00240A2C, 0x002A1609, 0x00160324,
    0x002C190E, 0x001F041B, 0x000B2B14, 0x00210A27, 0x0008162F,
    0x001C3106, 

    0x00051F2A, 0x000C2511, 0x00280224, 0x002D0B2A, 0x001F2E02,         // 88
    0x00260626, 0x00022B30, 0x002A2610, 0x00170427, 0x00202E0A,
    0x00002A1F, 0x002A1403, 0x00061B29, 0x0027081E, 0x00120E2E,
    0x00072725, 0x0029091F, 0x00002130, 0x000F2F13, 0x001D0E18,
    0x00052B1E, 0x00181A04, 0x0023112A, 0x00041C1B, 0x002A0623,
    0x00180C30, 0x000E1B20, 0x00291402, 0x00012331, 0x002B1705,
    0x000F2013, 0x001C0120, 0x000A2B30, 0x00011D1D, 0x002E0B13,
    0x000C2E27, 0x00280931, 0x000A1220, 0x00011A26, 0x0012032F,
    0x002F2E0B, 0x00031D2B, 0x002D1024, 0x0017210A, 0x0020062E,
    0x00011819, 0x00253005, 0x00190E14, 0x002A0620, 0x001C2504,
    0x00310C26, 0x0000191A, 0x002B2703, 0x00210E14, 0x0026081C,
    0x002A1E0A, 0x00041523, 0x0009201D, 0x00250E14, 0x00102523,
    0x0005322E, 0x00240F16, 0x0012001D, 0x002A240F, 0x00061B2D,
    0x0021310B, 0x00092216, 0x0017062F, 0x0028250A, 0x00130A19,
    0x00320032, 0x00251302, 0x0019290C, 0x002D0325, 0x00011F15,
    0x00122C0A, 0x00311410, 0x00200922, 0x000F2913, 0x000A2F17,
    0x0031082A, 0x001F190F, 0x00133001, 0x001D0F18, 0x00052C1E,
    0x001A2307, 0x000F132D, 0x00321D05, 0x00182210, 0x0013290B,
    0x00290C23, 

    0x001A2C01, 0x0021101B, 0x0013300B, 0x00061917, 0x000E221F,         // 89
    0x001A120C, 0x00141A06, 0x00220917, 0x000C1C21, 0x00271104,
    0x000E1F2A, 0x0016051B, 0x002F310D, 0x001A2008, 0x00210419,
    0x002D3007, 0x0015140E, 0x00231B04, 0x002C0226, 0x00132608,
    0x00260530, 0x00300913, 0x000B3017, 0x001C2301, 0x00121310,
    0x002F2507, 0x00092A16, 0x001D0828, 0x00142C0B, 0x00200C1D,
    0x0006272A, 0x0028160F, 0x00150818, 0x001F2208, 0x0018120C,
    0x00041B1C, 0x001D0514, 0x00303006, 0x001A200E, 0x00290E1D,
    0x000C2314, 0x00230920, 0x00101911, 0x00062C17, 0x002A1407,
    0x000C2923, 0x002E032C, 0x00051D1C, 0x0013220D, 0x0007172E,
    0x00162C10, 0x00251E0B, 0x0011062B, 0x00042220, 0x000C312C,
    0x001D0218, 0x00152C0F, 0x002F062F, 0x001A2A00, 0x0029130C,
    0x000A181A, 0x002D1F07, 0x00032D32, 0x001F1701, 0x00170719,
    0x00260F24, 0x002D1606, 0x00042D1C, 0x000C1323, 0x001A1B0D,
    0x00012E13, 0x00102226, 0x0008161B, 0x00203007, 0x0016072B,
    0x00260D1A, 0x00072230, 0x00181C00, 0x002A0D2C, 0x0000141E,
    0x00271D06, 0x0007111A, 0x000D2227, 0x002F0832, 0x00091C14,
    0x00240628, 0x00003117, 0x00280824, 0x0006112C, 0x0024021D,
    0x000F1A14, 

    0x002B0521, 0x0009152C, 0x00311D07, 0x00170430, 0x002B0E13,         // 90
    0x0008282A, 0x00300024, 0x0004301B, 0x002D150E, 0x0007282E,
    0x001C0F16, 0x00240B11, 0x000A2523, 0x00031331, 0x000F1914,
    0x0006222B, 0x001E1012, 0x000B2B2D, 0x00190C1B, 0x00081623,
    0x00201C0F, 0x00012820, 0x00140D25, 0x0028032E, 0x0021170B,
    0x00022F2A, 0x0025011B, 0x002D110E, 0x000C1E23, 0x00300317,
    0x0017300A, 0x00110F24, 0x002F2504, 0x000C3227, 0x002C022E,
    0x00232A00, 0x00102625, 0x00061619, 0x00210A2A, 0x00152A02,
    0x0007142E, 0x00183105, 0x00290527, 0x00210C31, 0x000F1F1F,
    0x001C110E, 0x00162409, 0x001F0B26, 0x002C2F00, 0x00230018,
    0x000E1129, 0x001E0A1E, 0x002D2906, 0x00191211, 0x00311B01,
    0x00110D27, 0x00222407, 0x000D1716, 0x00001D2B, 0x00140A1F,
    0x00210228, 0x0017270E, 0x00101220, 0x00300B27, 0x000E2114,
    0x0001272A, 0x00121D0E, 0x001D022D, 0x00232904, 0x002B0729,
    0x00201E08, 0x002C0E1F, 0x0013092E, 0x00291D10, 0x000A1120,
    0x002C2704, 0x001E0523, 0x0011310E, 0x00240127, 0x0015230A,
    0x00102D2E, 0x00190422, 0x00212A0C, 0x00271504, 0x0012260F,
    0x002C0C20, 0x00142002, 0x001C180E, 0x000D2D19, 0x002D2408,
    0x00021328 
};

#else // HALFTONE_SIZE

#error HALFTONE_SIZE must be 91 because no C support for 23.

#undef HALFTONE_MMX

#endif // HALFTONE_SIZE

#endif // defined(HALFTONE_MMX)
#endif // defined(_X86_)

const BYTE identityTranslate[256] = { 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

#define SPECIAL_COLORS

// Halftone a solid color into a packed DIB, using an 8x8 halftone matrix,
// using the 216-color halftone color palette. This method assumes we've
// already checked that the color is not anywhere in the palette, so it does
// need to be halftoned.

VOID
HalftoneColorRef_216(
    COLORREF color,     // color to halftone
    UNALIGNED VOID *dib // packed 8 bpp DIB buffer with 8 colors
    )
{
    ASSERT(dib != NULL);
    
    UINT    r, g, b;
    
    r = GetRValue(color);
    g = GetGValue(color);
    b = GetBValue(color);

    ULONG   rQuo, gQuo, bQuo;
    ULONG   rRem, gRem, bRem;

    DIV_51(r, rQuo, rRem);
    DIV_51(g, gQuo, gRem);
    DIV_51(b, bQuo, bRem);
    
    UNALIGNED BITMAPINFOHEADER *bmih = (UNALIGNED BITMAPINFOHEADER *)dib;
    
    bmih->biSize          = sizeof(BITMAPINFOHEADER);
    bmih->biWidth         = 8;
    bmih->biHeight        = 8;
    bmih->biPlanes        = 1;
    bmih->biBitCount      = 8;
    bmih->biCompression   = BI_RGB;
    bmih->biSizeImage     = 0;
    bmih->biXPelsPerMeter = 0;
    bmih->biYPelsPerMeter = 0;
    bmih->biClrUsed       = 8;
    bmih->biClrImportant  = 0;

    INT i;

    // Generate all 8 required colors, based on the quotient values.
    // The index bit format is: BGR

    UNALIGNED RGBQUAD *bmiColors = (UNALIGNED RGBQUAD *)(bmih + 1);
    
    r = Mult36LUT[rQuo];      // 36 * rQuo
    g = Mult6plus40LUT[gQuo]; //  6 * gQuo + 40 (halftone base)
    b = bQuo;                 //      bQuo

    ULONG rNext = rRem ? 36 : 0;
    ULONG gNext = gRem ?  6 : 0;
    ULONG bNext = bRem ?  1 : 0;
    
    for (i = 0; i < 8; i++)
    {
        // Get the palette entry in HTColorTable by computing the index:

        PALETTEENTRY *palEntry = HTColorPalette.palPalEntry +
                                 r + ((i & 1) ? rNext : 0) +
                                 g + ((i & 2) ? gNext : 0) +
                                 b + ((i & 4) ? bNext : 0);

        bmiColors[i].rgbRed   = palEntry->peRed;
        bmiColors[i].rgbGreen = palEntry->peGreen;
        bmiColors[i].rgbBlue  = palEntry->peBlue;
        
        bmiColors[i].rgbReserved = 0;
    }
    
    BYTE *buffer = (BYTE *)(bmiColors + 8);

    for (i = 0; i < 64; i++)
    {
        ULONG halftoneValue = HT_216_8x8[i];

        // MUST do >, not >= so that a remainder of 0 works correctly

        *buffer++ = ((rRem > halftoneValue) << 0) |
                    ((gRem > halftoneValue) << 1) |
                    ((bRem > halftoneValue) << 2);
    }
}

/**************************************************************************\
*
* Operation Description:
*
*   HalftoneToScreen: Halftone from 32bpp ARGB, to the screen.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use PaletteMap, X, and Y.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   The naming of the HalftoneToScreen operations works as follows:
*     HalftoneToScreen_<src>_<dst>_<palette>
*
*   At the time of writing, <src> is always sRGB, <dst> is always 8 (for
*   8bpp), and <palette> is either 16 (VGA palette) or 216 (standard
*   halftone palette).
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   10/29/1999 DCurtis
*       Rewrote to use Daniel Chou's halftoning patterns.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

#pragma optimize ("t", on)            

// Halftone to 8bpp, using the 216-color halftone palette

VOID FASTCALL
ScanOperation::HalftoneToScreen_sRGB_8_216(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
    ASSERT((s != NULL) && (d != NULL));
    ASSERT(s != d);
    ASSERT(otherParams);
    
    if (count == 0)
    {
        return;
    }
    
    INT orgX = RemainderI(otherParams->X, HALFTONE_SIZE);
    INT orgY = RemainderI(otherParams->Y, HALFTONE_SIZE);
    INT htStartRow = orgY*HALFTONE_SIZE;

    // Bug #360060: Some times it's possible the PaletteMap may be NULL
    // if we are in the process of a display mode change, say 32 to 8bpp.  In 
    // these cases we just assume an identity palette map to avoid AVing.
    // This means we may render improperly but we expect this to occur
    // only briefly before a new WM_PAINT occurs.

    const BYTE *pTranslate = otherParams->PaletteMap ?
        otherParams->PaletteMap->GetTranslate() : &identityTranslate[0];

#if defined(_X86_) && defined (HALFTONE_MMX)
    if (OSInfo::HasMMX)
    {
        // Multiply by multApproxDiv51 and divide by 65536. We will use this
        // to divide numbers in the range [0,305] (255+50), and for these
        // values, the "approximation" always returns the correct value.
    
        static ULONGLONG multApproxDiv51 = 0x0000050605060506;

        // Multiplier for palette indicies:
    
        static ULONGLONG multForPalIndex = 0x0000002400060001;

        __asm
        {
            movq        mm3, multForPalIndex
            movq        mm2, multApproxDiv51
            pxor        mm7, mm7                // mm7 = 0

            mov         edi, d                  // edi = d

            mov         edx, htStartRow
            mov         eax, orgX
            lea         ebx, HT_SuperCell_Packed
            add         edx, eax
            shl         edx, 2
            add         ebx, edx                // ebx = start in dither table            
            mov         edx, HALFTONE_SIZE
            sub         edx, eax                // edx = HALFTONE_SIZE - orgX

            mov         esi, s                  // esi = s

outer_loop:
            
            mov         ecx, count
            cmp         ecx, edx
            jb          setup_inner_loop

            mov         ecx, edx

setup_inner_loop:

            sub         count, ecx

inner_loop:

            // [johnstep] The following does not currently support
            //            GDIP_DO_HALFTONE_GAMMA, which will be necessary if
            //            reenabled in the C code; see the C code below.
            
            movd        mm0, [esi]              // mm0 = 0 | 0 | AR | GB

#if defined(SPECIAL_COLORS)
            xor         eax, eax
            mov         al, [esi + 0]
            shr         al, 2
            xor         al, [esi + 1]
            shr         al, 2
            xor         al, [esi + 2]
            shr         al, 1                   // eax = hashKey

check_special:
            
            lea         edx, VgaColorHash
            shl         eax, 2
            add  