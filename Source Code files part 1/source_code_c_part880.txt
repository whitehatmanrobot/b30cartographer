				); 

					//
					//   Compute the external address and place
					//   it back in the variable.
					//
					Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 ActualSize = 
							((Space == NULL) ? Size : (*Space));
						REGISTER SBIT32 Difference = 
							(ActualSize - SpaceUsed);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) Address);

							ZeroMemory( & Array[ SpaceUsed ],Difference ); 
							} 
						}	
					}
				}
			else
				{ Failure( "Resize requested on unallocated memory" ); }
			}
		else
			{ Failure( "Allocation size must be positive" ); }
		}
	else
		{ Address = New( NewSize,Space,Zero ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the reallocation process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Resize failed to complete" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the guard words.                                         */
    /*                                                                  */
    /*   We need to reset the guard words just before we delete a       */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::ResetGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   Write guard words over the allocated space as
	//   the allocation is about to be freed.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ (((int*) Header)[ (Count / GuardSize) ]) = GuardValue; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Set the guard words.                                           */
    /*                                                                  */
    /*   We need to set the guard words just after an allocation so     */
    /*   we can check them later.                                       */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize) 
				&& 
			(Size >= 0) 
			)
		{
		REGISTER int Count;

		//
		//   We know that the entire allocation should be
		//   set to the guard value so check that it has
		//   not been overwritten.
		//
		for ( Count=0;Count < TotalSize;Count += GuardSize )
			{ 
			if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
				{ Failure( "Guard words have been damaged" ); }
			}

		//
		//   Write the header information.
		//
		Header -> Size = Size;
		}
	else
		{ Failure( "Guard word area is too small or unaligned" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Test the guard words.                                          */
    /*                                                                  */
    /*   We need to test the guard words a various times to ensure      */
    /*   are still valid.                                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::TestGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before testing the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Header -> Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Header -> Size >= 0) 
			)
		{
		REGISTER int Count;
		REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
		REGISTER int EndIndex = ((Header -> Size + GuardMask) & ~GuardMask);
		REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
		REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
		REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

		//
		//   Test the guard word just before the allocation
		//   to see if it has been overwritten.
		//
		if ( Header -> StartGuard != GuardValue )
			{ Failure( "Leading guard word has been damaged" ); }

		//
		//   Test the guard bytes just after the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=Header -> Size;(Count & GuardMask) != 0;Count ++ )
			{
			REGISTER int ByteIndex = (Count & GuardMask);

			//
			//   Test each byte up to the next word boundary.
			//
			if 
					( 
					Trailer -> MidGuard[ ByteIndex ] 
						!= 
					((char*) & GuardValue)[ ByteIndex ]
					)
				{ Failure( "Trailing guard byte has been damaged" ); }
			}

		//
		//   Test the guard words following the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
			{ 
			if ( Trailer -> EndGuard[ (Count / GuardSize) ] != GuardValue )
				{ Failure( "Trailing guard word has been damaged" ); }
			}
		}
	else
		{ Failure( "Guard information has been damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory Trunction.                                              */
    /*                                                                  */
    /*   We truncate the heap and make sure that this does not          */
    /*   corrupt the heap in some way.                                  */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Truncate( int MaxFreeSpace )
	{
	REGISTER bool Result;

	//
	//   We truncate the heap and release all available
	//   memory regardless of what the caller requested.
	//
	Result = ROCKALL::Truncate( 0 );

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap truncation failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unmodified guard words.                                        */
    /*                                                                  */
    /*   We need to inspect the guard words to ensure they have not     */
    /*   changed after being freed.                                     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   We know that the entire allocation should be
	//   set to the guard value so check that it has
	//   not been overwritten.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ 
		if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
			{ Failure( "Guard words on unallocated memory have been damaged" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the guard words.                                        */
    /*                                                                  */
    /*   We need to update the guard words after a resize so we can     */
    /*   check them later.                                              */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Size >= 0) 
			)
		{
		//
		//   We only copy the smaller of the new size 
		//   and the old size.  So check just the
		//   correct number of guard words.
		//
		if ( Header -> Size > Size )
			{
			REGISTER int Count;
			REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
			REGISTER int EndIndex = ((Size + GuardMask) & ~GuardMask);
			REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
			REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
			REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

			//
			//   Update the guard bytes just after the 
			//   allocation.
			//
			for ( Count=Size;(Count & GuardMask) != 0;Count ++ )
				{
				REGISTER int ByteIndex = (Count & GuardMask);

				Trailer -> MidGuard[ ByteIndex ] =
					((char*) & GuardValue)[ ByteIndex ];
				}

			//
			//   Write guard words over part of the space 
			//   as the allocation is being shrunk.
			//
			for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
				{ Trailer -> EndGuard[ (Count / GuardSize) ] = GuardValue; }

			//
			//   Update the header information.
			//
			Header -> Size = Size; 

			//
			//   We know that the entire allocation should 
			//   be set to the guard value so check that it 
			//   has not been overwritten.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{
			//
			//   We know that the entire allocation should be
			//   set to the guard value so check that it has
			//   not been overwritten.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Update the header information.
			//
			Header -> Size = Size; 
			}
		}
	else
		{ Failure( "Guard word information area is damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Check( void *Address,int *Space )
    {
	AUTO bool Result;
	AUTO int TotalSize;
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   Extract information about the memory allocation.
	//
	Result = 
		(
		ROCKALL::Check
			( 
			((void*) Header),
			& TotalSize 
			)
		);

	//
	//   If we managed to extract the information then
	//   check the guard words for good measure.
	//
	if ( Result )
		{
		//
		//   If we are about to return the actual 
		//   amount of spce available then we must 
		//   update the size of the guard area.
		//
		if ( Space == NULL )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{ 
			//
			//   Compute the amount of available space.
			//   
			(*Space) = (TotalSize - sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			UpdateGuardWords( Header,(*Space),TotalSize );
			}
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the verification process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Heap check failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Walk( bool *Active,void **Address,int *Space )
    {
	AUTO DEBUG_HEADER *Header =
		(
		((*Address) == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) (*Address))
			: ComputeHeaderAddress( (*Address) )
		);

	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Active,((VOID**) & Header),Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ TestGuardWords( Header,(*Space) ); }
		else
			{ UnmodifiedGuardWords( Header,(*Space) ); }

		//
		//   Compute the new heap address.
		//
		(*Address) = ComputeDataAddress( Header );

		//
		//   Compute the amount of available space.
		//   
		(*Space) -= sizeof(DEBUG_GUARD);

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::~DEBUG_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the its lifetime.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Destructor failed to complete" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\rockall.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The interface default constructor creates a null heap for      */
    /*   internal use by selected classes.                              */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL( void )
	{
	//
	//   A heap constructed by this constructor should
	//   never be used.  Hence, we zero key pointers to
	//   ensure grave disorder will result if anyone tries.
	//
	Array = NULL;
	Caches = NULL;
	Find = NULL;
	Heap = NULL;
	NewPage = NULL;

	GlobalDelete = True;
	GuardWord = GuardValue;
	NumberOfCaches = 0;
	TotalSize = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe 
		)
	{
	TRY
		{
		REGISTER int AlignMask = ((int) (NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Find = NULL;
		Heap = NULL;
		NewPage = NULL;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			((GlobalDelete) ? 0 : sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) NewArea( ((SBIT32) AlignMask),TotalSize,False ));

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the caches.
				//
				//   The first step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((BOOLEAN) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the global find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC ROCKALL Rockall;

						//
						//   Select the global find table 
						//   and call the constructor.
						//
						Find = ((FIND*) GlobalFind);

						PLACEMENT_NEW( Find,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((ROCKALL*) & Rockall),
							((BOOLEAN) True),
							((BOOLEAN) (GlobalDelete || ThreadSafe))
							);
						}
					else
						{
						//
						//   A global find has table already
						//   exists so just use it.
						//
						Find = ((FIND*) GlobalFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}
				else
					{
					Find = (FIND*) NewMemory;
					NewMemory += sizeof(FIND);

					//
					//   We create a local find hash table
					//   if we are do not need to provide
					//   a single heap image.
					//
					PLACEMENT_NEW( Find,FIND ) 
						( 
						((SBIT32) FindSize),
						((SBIT32) FindCacheSize),
						((SBIT32) FindCacheThreshold),
						((ROCKALL*) this),
						((BOOLEAN) True),
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((FIND*) Find),
					((SBIT32*) NewPageSizes),
					((ROCKALL*) this),
					((SBIT32) Size3),
					((BOOLEAN) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((FIND*) Find),
					((NEW_PAGE*) NewPage),
					((ROCKALL*) this),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					ThreadSafe
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   the area back to the operating system.                         */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Details( ((VOID*) Address),((SBIT32*) Space) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   The default is to ask the operating system for the             */
    /*   allocation granularity.                                        */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER LONG Address = ((LONG) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Check( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Check( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::~ROCKALL( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the find hash table destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the global find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( Find,FIND ); }

				Spinlock.ReleaseLock();
				}
			else
				{ PLACEMENT_DELETE( Find,FIND ); }


			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Deallocate the heap structures.
			//
			DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			NewPage = NULL;
			Heap = NULL;
			Find = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_

#ifdef ROCKALL_DIRECTUSER
    //
    // DirectUser does not use virtuals for the API
    //

#define RAPI
#else
#define RAPI virtual
#endif


//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef NO_DEFAULT_HEAP
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		RAPI bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		RAPI bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		RAPI bool KnownArea( void *Address );

		RAPI bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		RAPI bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		RAPI void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		RAPI void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		RAPI bool Check
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		RAPI void DeleteAll( bool Recycle = true );

		RAPI void LockAll( void );

		RAPI bool Truncate( int MaxFreeSpace = 0 );

		RAPI void UnlockAll( void );

		RAPI bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		RAPI void DeleteArea( void *Memory,int Size,bool User );

		RAPI int NaturalSize( void );

		RAPI void *NewArea( int AlignMask,int Size,bool User );

        RAPI ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		RAPI void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\align.hpp ===
#ifndef _ALIGN_HPP_
#define _ALIGN_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Alignment of structures to cache line boundaries.              */
    /*                                                                  */
    /*   This class aligns data structures to cache line boundaries.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class ALIGN
    {
        //
        //   Private data.
        //
        TYPE                          *Aligned;
        CHAR                          *Allocated;

    public:
        //
        //   Public functions.
        //
        ALIGN( VOID );

        ~ALIGN( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE *operator&( VOID )
			{ return Aligned; }

	private:
        //
        //   Disabled operations.
        //
        ALIGN( CONST ALIGN & Copy );

        VOID operator=( CONST ALIGN & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */        
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::ALIGN( VOID )
    {
    REGISTER CHAR *Address;

	//
	//   Allocate space for the data structure.
	//
	Allocated = new CHAR[ (CacheLineSize + sizeof(TYPE)) ];

	//
	//   Call the constructor to initialize the structure.
	//
    Address = ((CHAR*) ((((LONG) Allocated) + CacheLineMask) & ~CacheLineMask));

    Aligned = PLACEMENT_NEW( Address,TYPE );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the memory allocation.  This call is not thread safe   */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::~ALIGN( VOID )
    { 
	//
	//   Call the destructor for the allocated type.
	//
    PLACEMENT_DELETE( Aligned,TYPE );

	//
	//   Delete the data structure.
	//
	delete [] Allocated; 
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\environment.hpp ===
#ifndef _ENVIRONMENT_HPP_
#define _ENVIRONMENT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Environment configuration values.                              */
    /*                                                                  */
    /*   This class provides a information about the environment.       */
    /*   The information can be accessed repeatedly with very little    */
    /*   cost as the data is slaved in static memory.                   */
    /*                                                                  */
    /********************************************************************/

class ENVIRONMENT : public ASSEMBLY
    {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		//
		//   Private structures.
		//
		typedef struct
			{
			CHAR					  *Name;
			SBIT32                    SizeOfName;
			CHAR                      *Value;
			SBIT32                    SizeOfValue;
			} 
		VARIABLE;

#endif
        //
        //   Private data.
        //
        STATIC SBIT32		          Activations;

		STATIC SBIT32                 AllocationGranularity;
        STATIC SBIT16                 NumberOfProcessors;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		STATIC CHAR                   *ProgramName;
		STATIC CHAR                   *ProgramPath;
#endif
		STATIC SBIT32                 SizeOfMemory;
		STATIC SBIT32                 SizeOfPage;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC SBIT32                 MaxVariables;
		STATIC SBIT32                 VariablesUsed;
		STATIC VARIABLE               *Variables;
#endif

    public:
        //
        //   Public functions.
        //
        ENVIRONMENT( VOID );
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC CONST CHAR *ReadEnvironmentVariable( CONST CHAR *Name );
#endif

        ~ENVIRONMENT( VOID );

		//
		//   Public inline functions.
		//
		STATIC INLINE  SBIT32 AllocationSize(VOID ) 
			{ return AllocationGranularity; };
	
		STATIC INLINE SBIT32 CacheAlignSize( SBIT32 Size )
			{ return ((Size + CacheLineMask) & ~CacheLineMask); }

		STATIC INLINE CONST CHAR *DirectorySeperator( VOID ) 
			{ return "\\"; };

        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return NumberOfProcessors; }

		STATIC INLINE SBIT32 MemorySize( VOID ) 
			{ return SizeOfMemory; };

		STATIC INLINE SBIT32 PageSize( VOID ) 
			{ return SizeOfPage; };
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC INLINE CONST CHAR *ProgramFileName( VOID ) 
			{ return ((CONST CHAR*) ProgramName); };

		STATIC INLINE CONST CHAR *ProgramFilePath( VOID ) 
			{ return ((CONST CHAR*) ProgramPath); };
#endif

	private:
        //
        //   Disabled operations.
        //
        ENVIRONMENT( CONST ENVIRONMENT & Copy );

        VOID operator=( CONST ENVIRONMENT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\environment.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The enviroment class slaves various information to speed       */
    /*   up access to it.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 EnvironmentCacheSize	  = 16;
CONST SBIT32 SizeOfName				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

SBIT32 ENVIRONMENT::Activations = 0;
SBIT32 ENVIRONMENT::AllocationGranularity = 0;
SBIT16 ENVIRONMENT::NumberOfProcessors = 0;
SBIT32 ENVIRONMENT::SizeOfMemory = 0;
SBIT32 ENVIRONMENT::SizeOfPage = 0;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

CHAR *ENVIRONMENT::ProgramName = NULL;
CHAR *ENVIRONMENT::ProgramPath = NULL;
SBIT32 ENVIRONMENT::MaxVariables = 0;
SBIT32 ENVIRONMENT::VariablesUsed = 0;
ENVIRONMENT::VARIABLE *ENVIRONMENT::Variables = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new environment and initialize it if needed.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::ENVIRONMENT( VOID )
    {
    if ( AtomicIncrement( & Activations ) == 1 )
        {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		AUTO CHAR ProgramFullName[ SizeOfName ];
#endif
		AUTO MEMORYSTATUS MemoryStatus;
		AUTO SYSTEM_INFO SystemInformation;

		//
		//   Initialize the class members to reasonable default values.
		//
		GetSystemInfo( & SystemInformation );

		GlobalMemoryStatus( & MemoryStatus );

		AllocationGranularity = 
			((SBIT32) SystemInformation.dwAllocationGranularity);
		NumberOfProcessors = 
			((SBIT16) SystemInformation.dwNumberOfProcessors);
		SizeOfMemory = 
			((SBIT32) MemoryStatus.dwTotalPhys);
		SizeOfPage = 
			((SBIT32) SystemInformation.dwPageSize);
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		//
		//   Slave interesting values like the program name and path variable.
		//
		ProgramName = NULL;
		ProgramPath = NULL;

		MaxVariables = 0;
		VariablesUsed = 0;
		Variables = NULL;

		//
		//   Get the complete file name for the current program.
		//
		if ( GetModuleFileName( NULL,ProgramFullName,SizeOfName ) > 0 )
			{
			REGISTER SBIT16 Count = (SBIT16) strlen( (char*) ProgramFullName );
			REGISTER CHAR *Characters = & ProgramFullName[ Count ];

			//
			//   Scan backwards looking for the first directory seperator.  
			//   There is guaranteed to be at least one.
			//
			for 
				( 
				/* void */;
				((Count > 0) && ((*Characters) != (*DirectorySeperator())));
				Count --, Characters -- 
				);

			(*(Characters ++)) = '\0';

			//
			//   Allocate space for the directory path and copy the  
			//   path into the newly allocated area.
			//
			ProgramPath = new CHAR [ (strlen( ((char*) ProgramFullName) )+1) ];

			if ( ProgramPath != NULL )
				{
				(VOID) strcpy
					( 
					((char*) ProgramPath),
					((char*) ProgramFullName)
					); 
				}

			//
			//   Scan the program name backwards looking for a '.'.
			//
			for 
				( 
				Count = (SBIT16) strlen( (char*) Characters );
				((Count > 0) && (Characters[ Count ] != '.'));
				Count -- 
				);

			//
			//   Remove any trailing suffix from the program name 
			//   (i.e. '*.EXE').
			//
			if ( Count > 0 )
				{ Characters[ Count ] = '\0'; }

			//
			//   Allocate space for the program name and copy the name 
			//   into the newly allocated area.
			//
			ProgramName = new CHAR [ (strlen( ((char*) Characters) )+1) ];

			if ( ProgramName != NULL )
				{
				(void) strcpy
					( 
					((char*) ProgramName),
					((char*) Characters) 
					);
				}
			}
#endif
		}
	}
#ifndef DISABLE_ENVIRONMENT_VARIABLES

    /********************************************************************/
    /*                                                                  */
    /*   Read an environment variable.                                  */
    /*                                                                  */
    /*   When we read an environment value we want to make sure that    */
    /*   it never changes and gets slaved in memory.  This routine      */
    /*   implements this functionality.                                 */
    /*                                                                  */
    /********************************************************************/

CONST CHAR *ENVIRONMENT::ReadEnvironmentVariable( CONST CHAR *Name )
	{
	if ( Activations > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 SizeOfName = (SBIT32) strlen( (char*) Name );
		REGISTER VARIABLE *Variable;
		STATIC SPINLOCK Spinlock;

		//
		//   The environment variables can only be scanned by one CPU at 
		//   a time because a second CPU might reallocate the storage 
		//   and cause the first CPU to fail.
		//
		Spinlock.ClaimLock();

		//
		//   Examine all existing environment variables looking for a 
		//   match. If a match is found return it to the caller.
		//
		for 
				( 
				Count = VariablesUsed, Variable = Variables;
				Count > 0; 
				Count --, Variable ++ 
				)
			{
			if 
					( 
					(SizeOfName == Variable -> SizeOfName) 
						&& 
					(strcmp( (char*) Name,(char*) Variable -> Name ) == 0) 
					)
				{
				Spinlock.ReleaseLock();

				return (Variable -> Value);
				}
			}

		//
		//  If we have filled up our array so we need to make it bigger.
		//  So lets check for this now.
		//
		if ( VariablesUsed >= MaxVariables )
			{
			REGISTER VARIABLE *PreviousAllocation = Variables;

			if ( MaxVariables > 0 )
				{
				Variables = 
					(
					(VARIABLE*) realloc
						( 
						(VOID*) Variables,
						((MaxVariables *= ExpandStore) * sizeof(VARIABLE)) 
						)
					);
				}
			else
				{ Variables = new VARIABLE [ EnvironmentCacheSize ]; }

			//
			//   Lets make sure we were successful.  If not we restore 
			//   the previous pointer as it is still valid.
			//
			if ( Variables == NULL )
				{
				Variables = PreviousAllocation;

				Failure( "Expand memory in ReadEnvironmentVariable" );
				}
			}

		//
		//  We know that we have enough memory to allocate another element and 
		//  that we are the only CPU in this section of code so just add the 
		//  new variable.
		//
		Variable = & Variables[ VariablesUsed ++ ];

		Variable -> SizeOfName = 
			(SBIT32) strlen( (char*) Name );
		Variable -> SizeOfValue = 
			(SBIT32) GetEnvironmentVariable( (char*) Name,"",0 );

		Variable -> Name = new CHAR [ (Variable -> SizeOfName + 1) ];
		(VOID) strcpy( (char*) Variable -> Name,(char*) Name );

		if ( Variable -> SizeOfValue > 0 )
			{
			Variable -> Value = new CHAR [ (Variable -> SizeOfValue + 1) ];

			(VOID) GetEnvironmentVariable
				( 
				(char*) Name,
				(char*) Variable -> Value,
				(int) (Variable -> SizeOfValue + 1)
				);
			}
		else
			{ Variable -> Value = NULL; }

		Spinlock.ReleaseLock();

		return (Variable -> Value);
		}
	else
		{ return NULL; }
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an environment.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::~ENVIRONMENT( VOID )
	{
    if ( AtomicDecrement( & Activations ) == 0 )
		{
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		REGISTER SBIT32 Count;

		//
		//   Delete all of the environment variable names
		//   and values.
		//
		for ( Count = 0;Count < VariablesUsed;Count ++ )
			{
			REGISTER VARIABLE *Variable = & Variables[ Count ];

			delete [] Variable -> Name;

			if ( Variable -> Value != NULL )
				{ delete [] Variable -> Value; }
			}


		//
		//   Delete the environment array.
		//
		delete [] Variables;
		Variables = NULL;

		//
		//   Delete the program name and path.
		//
		if ( ProgramPath != NULL )
			{
			delete [] ProgramPath;
			ProgramPath = NULL;
			}

		if ( ProgramName != NULL )
			{
			delete [] ProgramName;
			ProgramName = NULL;
			}
#endif
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\features.hpp ===
#ifndef _FEATURES_HPP_
#define _FEATURES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Active project list.	 							            */
    /*                                                                  */
    /*   The active project list contains all of the projects that      */
    /*   are currently selected.                                        */
    /*                                                                  */
    /********************************************************************/

#define ROCKALL_II					  1

    /********************************************************************/
    /*                                                                  */
    /*   Active fetaure lists.	 							            */
    /*                                                                  */
    /*   The active features list contain all of the features that      */
    /*   are currently selected for each project.                       */
    /*                                                                  */
    /********************************************************************/

#ifdef PIPELINE_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_II
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_HEAP_STATISTICS        1
#endif
#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_GLOBAL_NEW			  1
#endif

#ifdef WEB_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_DIRECTUSER
    //
    // DirectUser REQUIRES specific options:
    // No virtual's in API
    // Can not use non-standard assembly
    //

#undef ENABLE_NON_STANDARD_ASSEMBLY
#endif


    /********************************************************************/
    /*                                                                  */
    /*   The complete feature list.							            */
    /*                                                                  */
    /*   The code supports a significant number of optional features    */
    /*   which are listed in this file.  Any feature can be activated   */
    /*   by copying the approriate setting.  Please be sure to keep     */
    /*   all the flags up to date and leave at list one copy of each    */
    /*   flag below.                                                    */
    /*                                                                  */
    /********************************************************************/

#ifdef ACTIVATE_ALL_OPTIONS
	//
	//   Standard options for all code.
	//
#define ASSEMBLY_X86				  1
#define DEBUGGING                     1

#define DISABLE_GLOBAL_NEW			  1
#define DISABLE_PRECOMPILED_HEADERS	  1
#define DISABLE_STRUCTURED_EXCEPTIONS 1

	//
	//   Standard options for the library code.
	//
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#define ENABLE_RECURSIVE_LOCKS		  1

#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_STRING_LOCKS		  1

	//
	//   Rockall specific options.
	//
#define ENABLE_ALLOCATION_STATISTICS  1
#define ENABLE_HEAP_STATISTICS        1

	//
	//   Pipeline Server specific options.
	//
#define ENABLE_BUFFER_LOCK			  1
#define ENABLE_ZERO_WRITE_BUFFER	  1

#define PRINT_ACTIVE_PACKETS		  1

	//
	//   Pipeline Server demo specific options.
	//
#define ENABLE_DATABASE				  1
#define ENABLE_READING				  1
#define ENABLE_TRANSACTIONS			  1
#define ENABLE_WRITING				  1

	//
	//   Web Server specific options.
	//
#define DISABLE_ASYNC_IO			  1
#define DISABLE_BUFFER_COPY			  1
#define DISABLE_WEB_LOCKS			  1
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\assembly.hpp ===
#ifndef _ASSEMBLY_HPP_
#define _ASSEMBLY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The assembly constants indicate the location of the thread     */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

#define PcTeb                         0x18
#define IDTeb                         0x24

#ifdef WINDOWS_95
CONST SBIT32 TebSlot				  = 0x88;
#else
CONST SBIT32 TebSlot				  = 0xE10;
#endif

#ifndef ASSEMBLY_PREFETCH_SUPPORT
#define prefetcht0					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x08
#define prefetcht1					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x10
#define prefetcht2					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x18
#define prefetchnta					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x00
#endif

#pragma warning( disable : 4035 )

    /********************************************************************/
    /*                                                                  */
    /*   Assembly language for ultra high performance.                  */
    /*                                                                  */
    /*   We have coded a few functions in assembly language for         */
    /*   ultra high performance.                                        */
    /*                                                                  */
    /********************************************************************/

class ASSEMBLY
    {
    public:
        //
        //   Public inline functions.
        //
		ASSEMBLY( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 AtomicAdd
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		eax,Value					// Load the value.
				lock	xadd dword ptr[ecx],eax		// Increment the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchangeAdd
					( 
					((LPLONG) Address),
					((LONG) Value) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicCompareExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		edx,NewValue				// Load the new value.
				mov		eax,Value					// Load the value.
				lock	cmpxchg	dword ptr[ecx],edx	// Update the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedCompareExchange
					( 
					((VOID**) Address),
					((VOID*) NewValue),
					((VOID*) Value)
					)
				);
#endif
			}
#ifdef ASSEMBLY_X86

		STATIC INLINE SBIT64 AtomicCompareExchange64
				( 
				VOLATILE SBIT64		  *Address,
				SBIT64				  NewValue,
				SBIT64				  Value 
				)
			{
			__asm
				{
				mov		esi, Address				// Load the adrress.
				mov		ebx, dword ptr NewValue[0]	// Load the new value.
				mov		ecx, dword ptr NewValue[4]	// Load the new value.
				mov		eax, dword ptr Value[0]		// Load the value.
				mov		edx, dword ptr Value[4]		// Load the value.
				lock	cmpxchg8b [esi]				// Update the value.
				}
			}
#endif

		STATIC INLINE SBIT32 AtomicDecrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,-1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Decrement value.
				dec		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedDecrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 AtomicExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,NewValue				// Load the value.
				lock	xchg dword ptr[ecx],eax		// Exchange new value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchange
					( 
					((LONG*) Address),
					((LONG) NewValue) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicIncrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Increment value.
				inc		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedIncrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 GetThreadId( VOID )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,fs:[PcTeb]				// Load TEB base address.
				mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
				}
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
			}

		STATIC INLINE VOID PrefetchL1( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht0	[eax]					// Prefetch into the L1.
#else
				prefetcht0							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL2( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht1	[eax]					// Prefetch into the L2.
#else
				prefetcht1							// Prefetch into the L2.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL3( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht2	[eax]					// Prefetch into the L3.
#else
				prefetcht2							// Prefetch into the L3.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchNta( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetchnta	[eax]					// Prefetch into the L1.
#else
				prefetchnta							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE SBIT32 GetFeatureMask( VOID )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		eax,1						// Load CPUID feature ID.
				cpuid								// Get the CPU infomation.
				mov		eax,edx						// Feature mask return.
				}
#else
			return 0;
#endif
			}

#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
		STATIC INLINE VOID *GetTlsAddress( SBIT32 TlsOffset )
			{
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				}
			}
#endif
#endif

		STATIC INLINE VOID *GetTlsValue( SBIT32 TlsIndex,SBIT32 TlsOffset )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		eax,[eax]					// Load TLS value.
				}
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
			}

		STATIC INLINE VOID SetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset,
				VOID				  *NewPointer 
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		edx,NewPointer				// Load new TLS value.
				mov		[eax],edx					// Store new TLS value.
				}
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
			}

		~ASSEMBLY( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        ASSEMBLY( CONST ASSEMBLY & Copy );

        VOID operator=( CONST ASSEMBLY & Copy );
    };

#pragma warning( default : 4035 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\common.hpp ===
#ifndef _COMMON_HPP_
#define _COMMON_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A collection of common functions.                              */
    /*                                                                  */
    /*   This class contains common functions that are needed           */
    /*   throughout the application.                                    */
    /*                                                                  */
    /********************************************************************/

class COMMON : public ASSEMBLY
    {
    public:
        //
        //   Public functions.
        //
		COMMON( VOID )
			{ /* void */ }

		STATIC BOOLEAN ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift );

		STATIC SBIT32 ForceToPowerOfTwo( SBIT32 Value );

		STATIC CHAR *LowerCase( CHAR *Text );

		STATIC CHAR *LowerCase( CHAR *Text,SBIT32 Size );

		STATIC BOOLEAN PowerOfTwo( SBIT32 Value );
#ifndef DISABLE_ATOMIC_FLAGS

		STATIC VOID SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC VOID UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC CHAR *UpperCase( CHAR *Text );

		STATIC CHAR *UpperCase( CHAR *Text,SBIT32 Size );
#endif

		~COMMON( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        COMMON( CONST COMMON & Copy );

        VOID operator=( CONST COMMON & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\common.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Common.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Convert a divisor to a shift.                                  */
    /*                                                                  */
    /*   We know that we can convert any divide operation into a        */
    /*   shift when the divisor is a power of two.  This function       */
    /*   figures out whether we can do this and what the how far        */
    /*   we would need to shift.                               .        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift )
	{
	if ( Divisor > 0 )
		{
		REGISTER SBIT32 Count;

		for ( Count=0;(Divisor & 1) == 0;Count ++ )
			{ Divisor >>= 1; }

		if (Divisor == 1)
			{
			(*Shift) = Count;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Force to the next power of two.                                */
    /*                                                                  */
    /*   We know that we can do certain optimizations if certain        */
    /*   values are a power of two.  Here we force the issue by         */
    /*   rounding up the value to the next power of two.                */
    /*                                                                  */
    /********************************************************************/

SBIT32 COMMON::ForceToPowerOfTwo( SBIT32 Value )
	{
	//
	//   We ensure the value is positive if not we 
	//   simply return the identity value.
	//
	if ( Value > 1 )
		{
		//
		//   We only have to compute the next power of
		//   two if the value is not already a power
		//   of two.
		//
		if ( ! PowerOfTwo( Value ) )
			{
			REGISTER SBIT32 Count;

			for ( Count=0;Value > 0;Count ++ )
				{ Value >>= 1; }

			return (1 << Count);
			}
		else
			{ return Value; }
		}
	else
		{ return 1; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert all characters to lower case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to lower case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Ensure value is a power of two.                                */
    /*                                                                  */
    /*   We need to ensure that certain values are an exact power       */
    /*   of two.  If this is true then the value will be positive       */
    /*   and only 1 bit will be set.  So we shift right until we        */
    /*   find the first bit on and then the value should be one.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::PowerOfTwo( SBIT32 Value )
	{ return ((Value & (Value-1)) == 0); }
#ifndef DISABLE_ATOMIC_FLAGS

    /********************************************************************/
    /*                                                                  */
    /*   Atomically set flags.                                          */
    /*                                                                  */
    /*   We need to atomically set some flags to prevent them being     */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags |= NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Atomically unset flags.                                        */
    /*                                                                  */
    /*   We need to atomically unset some flags to prevent them being   */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags &= ~NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert all characters to upper case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to upper case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\global.hpp ===
#ifndef _GLOBAL_HPP_
#define _GLOBAL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#pragma warning(disable:4505)       // unreferenced local function has been removed

#include "Features.hpp"
#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The standard macros.                                           */
    /*                                                                  */
    /*   The following are standard macros used by various              */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

#define FIELDOFFSET( Type,Field )	  ((SBIT16) & (((Type *)0) -> Field))
#define TO_DO( Message ) message ( "---- To do ---->>>> " Message )

#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#define TRY							  try
#else
#define TRY							  __try
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The standard constants.                                        */
    /*                                                                  */
    /*   The following are standard constants used by various           */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

	//
	//   The hardware cache line size.
	//
CONST SBIT32 CacheLineSize			  = 32;
CONST SBIT32 CacheLineMask			  = (CacheLineSize - 1);
CONST SBIT32 NoAlignment			  = 1;

	//
	//   The end of a linked list.
	//
CONST INT EndOfList					  = -1;

	//
	//   The boolean constants.
	//
CONST BOOLEAN False					  = 0;
CONST BOOLEAN True					  = 1;

	//
	//   Various misc constants.
	//
CONST INT DebugBufferSize			  = 8192;
CONST INT ExpandStore				  = 2;
CONST INT MaxCpus					  = 32;
CONST INT NoFlags					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... );

VOID Failure( char *Message );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\global.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Debug printing.                                                */
    /*                                                                  */
    /*   We sometimes need to print message during debugging. We        */
    /*   do this using the following 'printf' like function.            */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... )
	{
	AUTO CHAR Buffer[ DebugBufferSize ];
#ifdef ENABLE_DEBUG_FILE
	STATIC FILE *DebugFile = NULL;
#endif


	//
	//   Start of variable arguments.
	//
	va_list Arguments;

	va_start(Arguments, Format);

	//
	//   Format the string to be printed.
	//
	(VOID) _vsnprintf( Buffer,(DebugBufferSize-1),Format,Arguments );

	//
	//   Force null termination.
	//
	Buffer[ (DebugBufferSize-1) ] = '\0';

#ifdef ENABLE_DEBUG_FILE
	//
	//   Write to the debug file.
	//
	if ( DebugFile == NULL )
		{
		if ( (DebugFile = fopen( "C:\\DebugFile.TXT","a" )) == NULL )
			{ Failure( "Debug file could not be opened" ); }
		}

	fputs( Buffer,DebugFile );

	fflush( DebugFile );
#else
	//
	//   Write the string to the debug file.
	//
	OutputDebugString( Buffer );
#endif

	//
	//   End of variable arguments.
	//
	va_end( Arguments );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Software failure.                                              */
    /*                                                                  */
    /*   We know that when this function is called the application      */
    /*   has failed so we simply try to cleanly exit in the vain        */
    /*   hope that the failure can be caught and corrected.             */
    /*                                                                  */
    /********************************************************************/

VOID Failure( char *Message )
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	throw ((TEXT) Message);
#else
	RaiseException( 1,0,1,((CONST DWORD*) Message) );
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\list.hpp ===
#ifndef _LIST_HPP_
#define _LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A generic linked list.                                         */
    /*                                                                  */
    /*   There are a significant number of situations where objects     */
    /*   need to be linked together.  The objects may be of the same    */
    /*   or diffrent types so the class specified here is intended      */
    /*   to be used as base class so as to make supporting this easy.   */
    /*                                                                  */
    /********************************************************************/

class LIST
    {
		//
		//   Private data.
		//
 		LIST						  *Backward;
 		LIST						  *Forward;
#ifdef DEBUGGING
		LIST						  *Head;
#endif

   public:
        //
        //   Public functions.
        //
        LIST( VOID );

		VOID Delete( LIST *HeadOfList );

		VOID Insert( LIST *HeadOfList );

		VOID InsertBefore( LIST *HeadOfList,LIST *NewList );

		VOID InsertAfter( LIST *HeadOfList,LIST *NewList );

		VOID Reset( VOID );

        ~LIST( VOID );

		//
		//   Public line functions.
		//
		INLINE BOOLEAN StartOfList( VOID )
			{ return (Backward == NULL); }

		INLINE LIST *First( VOID )
			{ return Forward; }

		INLINE LIST *Last( VOID )
			{ return Backward; }

		INLINE LIST *Next( VOID )
			{ return Forward; }

		INLINE LIST *Previous( VOID )
			{ return Backward; }

		INLINE BOOLEAN EndOfList( VOID )
			{ return (Forward == NULL); }

	private:
        //
        //   Disabled operations.
        //
        LIST( CONST LIST & Copy );

        VOID operator=( CONST LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\librarypch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\librarypch.hpp ===
#ifndef _LIBRARY_PCH_HPP_
#define _LIBRARY_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Align.hpp"
#include "Assembly.hpp"
#include "Common.hpp"
#include "Environment.hpp"
#include "Global.hpp"
#include "List.hpp"
#include "Lock.hpp"
#include "New.hpp"
#include "Prefetch.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Standard.hpp"
#include "System.hpp"
#include "Tls.hpp"

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\list.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new linked list element.                              */
    /*                                                                  */
    /********************************************************************/

LIST::LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an element.                                             */
    /*                                                                  */
    /*   Delete the current element.                                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Delete( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == HeadOfList )
		{
#endif
		//
		//   Relink the forward chain.
		//
		if ( Forward != NULL )
			{ Forward -> Backward = Backward; }
		else
			{ HeadOfList -> Backward = Backward; }

		//
		//   Relink the backward chain.
		//
		if ( Backward != NULL )
			{ Backward -> Forward = Forward; }
		else
			{ HeadOfList -> Forward = Forward; }

		//
		//   Reset the list elements.
		//
		Forward = NULL;
		Backward = NULL;
#ifdef DEBUGGING
		Head = NULL;
		}
	else
		{ Failure( "No active linked list element in Delete" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a list element at the head of the list.                 */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Insert( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == NULL )
		{
#endif
		//
		//   Insert the new element at the front of the list.
		//
		if ( (Forward = HeadOfList -> Forward) == NULL )
			{ 
			HeadOfList -> Forward = this;
			HeadOfList -> Backward = this; 
			}
		else
			{ 
			HeadOfList -> Forward -> Backward = this; 
			HeadOfList -> Forward = this;
			}

		//
		//   Set the other pointers as needed.
		//
		Backward = NULL;
#ifdef DEBUGGING
		Head = HeadOfList;
		}
	else
		{ Failure( "List element already in use in Insert" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a new list element before the current element.          */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertBefore( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a previous element we must
				//   make it point at the new element.  If
				//   not we are the first element in the 
				//   list so update the head.
				//
				if ( Backward != NULL )
					{ Backward -> Forward = NewList; }
				else
					{ HeadOfList -> Forward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Backward = Backward;
				NewList -> Forward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Backward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertBefore" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertBefore" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert an element.                                             */
    /*                                                                  */
    /*   Insert a new list element after the current element.           */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertAfter( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a next element we must
				//   make it point at the new element.  If
				//   not we are the last element in the 
				//   list so update the head.
				//
				if ( Forward != NULL )
					{ Forward -> Backward = NewList; }
				else
					{ HeadOfList -> Backward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Forward = Forward;
				NewList -> Backward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Forward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertAfter" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertAfter" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset a list element.                                          */
    /*                                                                  */
    /*   Reset a list element without any questions.                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Reset( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a linked list element.                                 */
    /*                                                                  */
    /********************************************************************/

LIST::~LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\new.hpp ===
#ifndef _NEW_HPP_
#define _NEW_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())
#ifndef DISABLE_GLOBAL_NEW

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation operator.                                */
    /*                                                                  */
    /*   The memory allocation operator 'new' is overloaded to          */
    /*   provide a consistent interface.                                */
    /*                                                                  */
    /********************************************************************/

INLINE VOID *operator new( size_t Size )
    {
    REGISTER VOID *Store = malloc( Size );

    if ( Store == NULL )
        { Failure( "Out of system memory" ); }

    return Store;
    }

    /********************************************************************/
    /*                                                                  */
    /*   The memory deallocation operator.                              */
    /*                                                                  */
    /*   The memory deallocation operator releases allocated memory.    */
    /*                                                                  */
    /********************************************************************/

INLINE VOID operator delete( VOID *Store )
    { free( Store ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\lock.hpp ===
#ifndef _LOCKS_HPP_
#define _LOCKS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Full lock structure.                                           */
    /*                                                                  */
    /*   This class provides an full locking mechanism for a            */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class FULL_LOCK
    {
        //
        //   Private data.
        //
		SHARELOCK                     ShareLock;

    public:
        //
        //   Public inline functions.
        //
        FULL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) ShareLock.ClaimExclusiveLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) ShareLock.ClaimShareLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) ShareLock.ReleaseExclusiveLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) ShareLock.ReleaseShareLock(); }

        ~FULL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        FULL_LOCK( CONST FULL_LOCK & Copy );

        VOID operator=( CONST FULL_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   No lock structure.                                             */
    /*                                                                  */
    /*   This class provides a default locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class NO_LOCK
    {
    public:
        //
        //   Public inline functions.
        //
        NO_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ /* void */ }

        INLINE VOID ClaimSharedLock( VOID )
			{ /* void */ }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ /* void */ }

		INLINE VOID ReleaseSharedLock( VOID )
 			{ /* void */ }

        ~NO_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        NO_LOCK( CONST NO_LOCK & Copy );

        VOID operator=( CONST NO_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Partial lock structure.                                        */
    /*                                                                  */
    /*   This class provides a partial locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class PARTIAL_LOCK
    {
        //
        // Private structures.
        //
		SPINLOCK                      Spinlock;

    public:
        //
        //   Public inline functions.
        //
        PARTIAL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

        ~PARTIAL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PARTIAL_LOCK( CONST PARTIAL_LOCK & Copy );

        VOID operator=( CONST PARTIAL_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\prefetch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Prefetch.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PREFETCH::Active =
	(
	(BOOLEAN) IsProcessorFeaturePresent
		( 
		PF_XMMI_INSTRUCTIONS_AVAILABLE
		)
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\prefetch.hpp ===
#ifndef _PREFETCH_HPP_
#define _PREFETCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here are used to compute whether       */
    /*   the prefetch functionality is available on the current         */
    /*   processor.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 PrefetchFeatureMask	  = (1 << 24);

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch a cache line.				                            */
    /*                                                                  */
    /*   Support of data prefetch on the Pentium III or better.         */
    /*                                                                  */
    /********************************************************************/

class PREFETCH : public ASSEMBLY
    {
#ifdef ASSEMBLY_X86
        //
        //   Staic private data.
        //
        STATIC BOOLEAN		          Active;

#endif
    public:
        //
        //   Public inline functions.
        //
        PREFETCH( VOID )
			{ /* void */ }

		STATIC INLINE VOID L1( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L2( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L3( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID Nta( CHAR *Address,SBIT32 Size );

        ~PREFETCH( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PREFETCH( CONST PREFETCH & Copy );

        VOID operator=( CONST PREFETCH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L1( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL1( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L2.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L2 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L2( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL2( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L3.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L3 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L3( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL3( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::Nta( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchNta( Address ); }
		}
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\spinlock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::SPINLOCK( SBIT32 NewMaxSpins,SBIT32 NewMaxUsers )
    {
	//
	//   Set the initial state.
	//
	MaxSpins = NewMaxSpins;
	MaxUsers = NewMaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;
#endif
    Spinlock = LockOpen;
    Waiting = 0;

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (Semaphore = CreateSemaphore( NULL,0,NewMaxUsers,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for SPINLOCK" ); }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for the spinlock.                                         */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SPINLOCK::WaitForLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER SBIT32 Sleeps = 0;
    REGISTER SBIT32 Spins = 0;
    REGISTER SBIT32 Waits = 0;

#endif
    do
        {
        REGISTER SBIT32 Count;
        
		//
		//   If there are already more threads waiting 
		//   than the number of CPUs then the odds of 
		//   getting the lock by spinning are slim, when 
		//   there is only one CPU the chance is zero, so 
		//   just bypass this step.
		//
		if ( (Cpus > 1) && (Cpus > Waiting) )
			{
			//
			//   Wait by spinning and repeatedly testing the
			//   spinlock.  We exit when the lock becomes free 
			//   or the spin limit is exceeded.
			//
			for 
				( 
					Count = MaxSpins;
					(Count > 0) && (Spinlock != LockOpen);
					Count -- 
				);
#ifdef ENABLE_LOCK_STATISTICS

			//
			//   Update the statistics.
			//
			Spins += (MaxSpins - Count);
			Waits ++;
#endif
			}
		else
			{ Count = 0; }

		//
		//   We have exhusted our spin count so it is time to
		//   sleep waiting for the lock to clear.
		//
        if ( Count == 0 )
            {
            //
            //   The lock is still closed so lets go to sleep on 
            //   a semaphore.  However, we must first increment
            //   the waiting count and test the lock one last time
            //   to make sure it is still busy and there is someone
            //   to wake us up later.
            //
            (VOID) AtomicIncrement( & Waiting );

            if ( ! ClaimSpinlock( & Spinlock ) )
                {
                if 
                        ( 
                        WaitForSingleObject( Semaphore, Sleep ) 
                            != 
                        WAIT_OBJECT_0 
                        )
                    {
#ifdef ENABLE_LOCK_STATISTICS
					//
					//   Count the number of times we have  
					//   timed out on this lock.
					//
					(VOID) AtomicIncrement( & TotalTimeouts );

#endif
					return False; 
					}
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
                Sleeps ++;
#endif
                }
            else
                {
                //
                //   Lucky - got the lock on the last attempt.
                //   Hence, lets decrement the sleep count and
                //   exit.
                // 
                (VOID) AtomicDecrement( & Waiting );
                
                break; 
                } 
            }
        }
    while ( ! ClaimSpinlock( & Spinlock ) );
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    TotalSleeps += Sleeps;
    TotalSpins += Spins;
    TotalWaits += Waits;
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::~SPINLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Spinlock: \t%8d locks, %d timouts, "
		"%8d locks per wait, %8d spins per wait, %8d waits per sleep.\n",
		TotalLocks,
		TotalTimeouts,
		(TotalLocks / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);

#endif
	//
	//   Close the semaphore handle.
	//
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for SPINLOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\system.hpp ===
#ifndef _SYSTEM_HPP_
#define _SYSTEM_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard system include files.                             */
    /*                                                                  */
    /*   The standard system include files contain various definitions  */
    /*   used throughout the system.                                    */
    /*                                                                  */
    /********************************************************************/

#include <conio.h>
#include <iostream.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <new.h>
#include <process.h>
#include <time.h>
#include <winsock2.h>
#include <windows.h>

    /********************************************************************/
    /*                                                                  */
    /*   Automatically set the debugging flag if needed.                */
    /*                                                                  */
    /*   There are various standards for enabling dedugging code.       */
    /*   Here we translate on to the standard used in this              */
    /*   application.                                                   */
    /*                                                                  */
    /********************************************************************/

#ifdef _M_IX86
#define ASSEMBLY_X86				  1
#endif

#ifdef _DEBUG
#define DEBUGGING                     1
#endif
#ifndef ALL_COMPLAINTS

    /********************************************************************/
    /*                                                                  */
    /*   Automatically disable anoying warnings.                        */
    /*                                                                  */
    /*   Some of the VC compiler warning are not very helpful so        */
    /*   we disable them here.                                          */
    /*                                                                  */
    /********************************************************************/

#pragma warning( disable : 4100 )
#pragma warning( disable : 4121 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4511 )
#pragma warning( disable : 4512 )
#pragma warning( disable : 4514 )
#pragma warning( disable : 4701 )
#pragma warning( disable : 4702 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4710 )
#pragma warning( disable : 4711 )
#pragma warning( disable : 4800 )
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\sharelock.hpp ===
#ifndef _SHARELOCK_HPP_
#define _SHARELOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Sharelock and Semaphore locking.                               */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  A lock can be obtained in         */
    /*   either exclusive mode or shared mode.  If the lock is not      */
    /*   available the caller waits by spinning or if that fails        */
    /*   by sleeping.                                                   */
    /*                                                                  */
    /********************************************************************/

class SHARELOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32                        MaxSpins;
		SBIT32                        MaxUsers;

        VOLATILE SBIT32               Exclusive;
        VOLATILE SBIT32               TotalUsers;

#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalExclusiveLocks;
        VOLATILE SBIT32               TotalShareLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SHARELOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE VOID ChangeExclusiveLockToSharedLock( VOID );

        INLINE BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimShareLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseExclusiveLock( VOID );

        INLINE VOID ReleaseShareLock( VOID );

        BOOLEAN UpdateMaxSpins( SBIT32 NewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 NewMaxUsers );

        ~SHARELOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 ActiveUsers( VOID ) 
			{ return (SBIT32) TotalUsers; }

    private:
        //
        //   Private functions.
        //
		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN SleepWaitingForLock( SBIT32 Sleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 Sleep );

        BOOLEAN WaitForShareLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SHARELOCK( CONST SHARELOCK & Copy );

        VOID operator=( CONST SHARELOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Change an exclusive lock to a shared lock.                     */
    /*                                                                  */
    /*   Downgrade the existing exclusive lock to a shared lock.        */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ChangeExclusiveLockToSharedLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Simply decrement the exclusive count.
		//   This allows the lock to be shared.
		//
		(VOID) AtomicDecrement( & Exclusive );
#ifdef ENABLE_RECURSIVE_LOCKS
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Change a shared lock to an exclusive lock.                     */
    /*                                                                  */
    /*   Upgrade the existing shared lock to an exclusive lock.         */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ChangeSharedLockToExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif		
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared.
		//
		(VOID) AtomicIncrement( & Exclusive );

		//
		//   If the total number of users is one then
		//   we have the lock exclusively otherwise we
		//   may need to wait.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim an exclusive lock.                                       */
    /*                                                                  */
    /*   Claim an exclusive lock if available else wait or exit.        */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.
		//
		(VOID) AtomicIncrement( & Exclusive );
		(VOID) AtomicIncrement( & TotalUsers );

		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a shared lock.                                           */
    /*                                                                  */
    /*   Claim a shared lock if available else wait or exit.            */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimShareLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
		(VOID) AtomicIncrement( & TotalUsers );

		if ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif

	return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release an exclusive lock.                                     */
    /*                                                                  */
    /*   Release an exclusive lock and if needed wakeup any sleepers.   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseExclusiveLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Release an exclusive lock.
		//
#ifdef DEBUGGING
		if
				(
				(AtomicDecrement( & TotalUsers ) < 0)
					||
				(AtomicDecrement( & Exclusive ) < 0)
				)
			{ Failure( "Negative lock count in ReleaseExclusiveLock" ); }
#else
			AtomicDecrement( & TotalUsers );
			AtomicDecrement( & Exclusive );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock.                                         */
    /*                                                                  */
    /*   Release a shared lock and if needed wakeup any sleepers.       */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseShareLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
#endif
#ifdef DEBUGGING
		//
		//   Release a shared lock.
		//
		if ( AtomicDecrement( & TotalUsers ) < 0 )
			{ Failure( "Negative lock count in ReleaseShareLock" ); }
#else
		AtomicDecrement( & TotalUsers );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\sharelock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The Windows NT kernel requires a maximum wakeup count when     */
    /*   creating a semaphore.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxShareLockUsers		  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::SHARELOCK( SBIT32 NewMaxSpins, SBIT32 NewMaxUsers )
    {
	//
	//   Check the configurable values.
	//
	if ( NewMaxSpins > 0 )
		{ MaxSpins = NewMaxSpins; }
	else
		{ Failure( "Maximum spins invalid in constructor for SHARELOCK" ); }

	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{ MaxUsers = NewMaxUsers; }
	else
		{ Failure( "Maximum share invalid in constructor for SHARELOCK" ); }

	//
	//   Set the initial state.
	//
	Exclusive = 0;
	TotalUsers = 0;
#ifdef ENABLE_RECURSIVE_LOCKS

	Owner = NULL;
	Recursive = 0;
#endif
    Waiting = 0;

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (Semaphore = CreateSemaphore( NULL,0,MaxShareLockUsers,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for SHARELOCK" ); }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the statistics.
	//
    TotalExclusiveLocks = 0;
    TotalShareLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Sleep waiting for the lock.                                    */
    /*                                                                  */
    /*   We have decided it is time to sleep waiting for the lock       */
    /*   to become free.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::SleepWaitingForLock( SBIT32 Sleep )
    {
	//
	//   We have been spinning waiting for the lock but it
	//   has not become free.  Hence, it is now time to 
	//   give up and sleep for a while.
	//
	(VOID) AtomicIncrement( & Waiting );

	//
	//   Just before we go to sleep we do one final check
	//   to make sure that the lock is still busy and that
	//   there is someone to wake us up when it becomes free.
	//
	if ( TotalUsers > 0 )
		{
#ifdef ENABLE_LOCK_STATISTICS
		//
		//   Count the number of times we have slept on this lock.
		//
		(VOID) AtomicIncrement( & TotalSleeps );

#endif
		//
		//   When we sleep we awoken when the lock becomes free
		//   or when we timeout.  If we timeout we simply exit
		//   after decrementing various counters.
		//
		if 
				( 
				WaitForSingleObject( Semaphore, Sleep ) 
					!= 
				WAIT_OBJECT_0 
				)
			{ 
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have timed out 
			//   on this lock.
			//
			(VOID) AtomicIncrement( & TotalTimeouts );

#endif
			return False; 
			}
		}
	else
		{
		//
		//   Lucky - the lock was just freed so lets
		//   decrement the sleep count and exit without
		//   sleeping.
		// 
		(VOID) AtomicDecrement( & Waiting );
		}
	
	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the spin limit.                                         */
    /*                                                                  */
    /*   Update the maximum number of spins while waiting for the lock. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxSpins( SBIT32 NewMaxSpins )
    {
	if ( NewMaxSpins > 0 )
		{ 
		MaxSpins = NewMaxSpins; 

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the sharing limit.                                      */
    /*                                                                  */
    /*   Update the maximum number of users that can share the lock.    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxUsers( SBIT32 NewMaxUsers )
    {
	//
	//   We need to Verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{
		ClaimExclusiveLock();

		//
		//   Update the maximum number of users.
		//
		MaxUsers = NewMaxUsers;
		
		ReleaseExclusiveLock();

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for an exclusive lock.                                    */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForExclusiveLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( TotalUsers != 1 )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) && (TotalUsers > 0);
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(VOID) AtomicDecrement( & Exclusive );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(VOID) AtomicIncrement( & Exclusive );
				}
			}
		else
			{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(VOID) AtomicDecrement( & Exclusive );

			return False; 
			} 
		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for a shared lock.                                        */
    /*                                                                  */
    /*   Wait for the lock to become free and then claim it.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForShareLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) 
							&& 
						((Exclusive > 0) || (TotalUsers >= MaxUsers));
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }
				}
			}
		else
			{ return False; }

		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::~SHARELOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Sharelock: \t%8d exclusive, %8d shared, %8d timeouts, " 
		"%8d locks per wait, %8d spins per wait, %8d waits per sleep.\n",
		TotalExclusiveLocks,
		TotalShareLocks,
		TotalTimeouts,
		((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);
#endif
	//
	//   Close the semaphore handle.
	//
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for SHARELOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\standard.hpp ===
#ifndef _STANDARD_HPP_
#define _STANDARD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard data types.                                       */
    /*                                                                  */
    /*   The standard data types should be used in preference to the    */
    /*   data types defined in the C++ language.  This is to allow      */
    /*   for easier porting.  If no suitable standard type exists       */
    /*   then one should be created and documented here.                */
    /*                                                                  */
    /********************************************************************/

#define AUTO                          auto
#define CONST						  const
#define CONSTANT                      const
#define EXTERN                        extern
#define GLOBAL                        extern
#define INLINE                        __forceinline
#define LOCAL                         auto
#define REGISTER                      register
#define STATIC                        static
#define VIRTUAL                       virtual
#define VOLATILE                      volatile

    /********************************************************************/
    /*                                                                  */
    /*   The standard C++ types.                                        */
    /*                                                                  */
    /*   The C++ standard reserves various lower case keywords.  This   */
    /*   system uses a similar standard.  All upper case words are      */
    /*   either constants or types.  All words begining with a single   */
    /*   upper case letter are variables.                               */
    /*                                                                  */
    /********************************************************************/

typedef unsigned char                 BOOLEAN;

typedef char                          CHAR;
typedef short int                     SHORT;
typedef int                           INT;
typedef long int                      LONG;

typedef signed char                   SCHAR;
typedef signed short int              SSHORT;
typedef signed int                    SINT;
typedef signed long int               SLONG;

typedef unsigned char                 UCHAR;
typedef unsigned short int            USHORT;
typedef unsigned int                  UINT;
typedef unsigned long int             ULONG;

typedef void                          *POINTER;
typedef unsigned char                 *TEXT;

    /********************************************************************/
    /*                                                                  */
    /*   The optional standard types.                                   */
    /*                                                                  */
    /*   Some of the standard types are specified in other headers.     */
    /*   We need to be careful not to redefine these specifications     */
    /*   if they already exist.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef CDECL
#define	CDECL						  _cdecl
#endif

#ifndef VOID
#define	VOID						  void
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The fixed length types.                                        */
    /*                                                                  */
    /*   The above types are intended to shadow the standard C++ types  */
    /*   built into the language.  However, these types don't assure    */
    /*   any level of accuracy.  Each of following types is defined     */
    /*   to provide a minimum level of precision.                       */
    /*                                                                  */
    /********************************************************************/

typedef unsigned __int8               BIT8;
typedef unsigned __int16              BIT16;
typedef unsigned __int32              BIT32;
typedef unsigned __int64              BIT64;

typedef signed __int8                 SBIT8;
typedef signed __int16                SBIT16;
typedef signed __int32                SBIT32;
typedef signed __int64                SBIT64;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\spinlock.hpp ===
#ifndef _SPINLOCK_HPP_
#define _SPINLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The spinlock constants indicate when the lock is open and      */
    /*   when it is closed.                                             */
    /*                                                                  */
    /********************************************************************/

CONST LONG LockClosed				  = 1;
CONST LONG LockOpen					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Spinlock and Semaphore locking.                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  When a lock is taken a memory     */
    /*   location is exchanged.  All other threads that want this       */
    /*   lock wait by spinning and sometimes sleeping on a semaphore    */
    /*   until it becomes free again.  The only other choice is not     */
    /*   to wait at all and move on to do something else.  This         */
    /*   module should normally be used in conjunction with cache       */
    /*   aligned memory in minimize cache line misses.                  */
    /*                                                                  */
    /********************************************************************/

class SPINLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32						  MaxSpins;
		SBIT32						  MaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Spinlock;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SPINLOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseLock( VOID );

        ~SPINLOCK( VOID );

    private:
        //
        //   Private functions.
        //
        INLINE BOOLEAN ClaimSpinlock( VOLATILE SBIT32 *Spinlock );

		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN WaitForLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SPINLOCK( CONST SPINLOCK & Copy );

        VOID operator=( CONST SPINLOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   A guaranteed atomic exchange.                                  */
    /*                                                                  */
    /*   An attempt is made to claim the spinlock.  This action is      */
    /*   guaranteed to be atomic.                                       */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimSpinlock( VOLATILE SBIT32 *Spinlock )
    {
    return 
		(
		AtomicCompareExchange( Spinlock,LockClosed,LockOpen ) 
			== 
		LockOpen
		); 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the spinlock.                                            */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Claim the spinlock.
		//
		if ( ! ClaimSpinlock( & Spinlock ) )
			{
			//
			//   We have to wait.  If we are not 
			//   allowed to sleep or we have timed
			//   out then exit.
			//
			if ( (Sleep == 0) || (! WaitForLock( Sleep )) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
#ifdef DEBUGGING

		//
		//   Release the spinlock.
		//
		if ( AtomicExchange( & Spinlock, LockOpen ) == LockClosed )
			{
#else
			(VOID) AtomicExchange( & Spinlock, LockOpen );
#endif

			//
			//   Wakeup anyone who is asleep waiting.
			//
			if ( Waiting > 0 )
				{ WakeAllSleepers(); }
#ifdef DEBUGGING
			}
		else
			{ Failure( "Spinlock released by not held in ReleaseLock" ); } 
#endif
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\stack.hpp ===
#ifndef _STACK_HPP_
#define _STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the stack.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 StackSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Stacks and stack management.                                   */
    /*                                                                  */
    /*   This class provides general purpose stacks along with some     */
    /*   basic management.  The stacks are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a stack at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class STACK : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Top;

        VECTOR<TYPE>                  Stack;

    public:
        //
        //   Public functions.
        //
        STACK( SBIT32 NewMaxSize = StackSize );

        BOOLEAN MultiplePopStack
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        BOOLEAN MultiplePopStackReversed
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        VOID MultiplePushStack
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        VOID MultiplePushStackReversed
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        BOOLEAN PeekStack( TYPE *Data );

        BOOLEAN PopStack( TYPE *Data );

        VOID PushStack( CONST TYPE & Data );

        BOOLEAN ReadStack( SBIT32 Index, TYPE *Data );

        VOID ReverseStack( VOID );

        BOOLEAN UpdateStack
            ( 
            CONST SBIT32				  Index, 
            CONST TYPE					  & Data 
            );

        ~STACK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 SizeOfStack( VOID ) 
			{ return Top; }

	private:
        //
        //   Disabled operations.
        //
        STACK( CONST STACK & Copy );

        VOID operator=( CONST STACK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new stack and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::STACK( SBIT32 NewMaxSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Top = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for STACK" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack.                            */
    /*                                                                  */
    /*   We remove multiple items from a stack and check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStack
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = ((*Size) - 1);Count >= 0;Count -- )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack in reverse order.           */
    /*                                                                  */
    /*   We remove multiple items from a stack in reverse order and     */
    /*   check to make sure that the stack is not empty.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStackReversed
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = 0;Count < (*Size);Count ++ )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack.                                 */
    /*                                                                  */
    /*   We add multiple items to a stack and check to make sure that   */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStack
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements.
	//
    for ( Count = 0;Count < Size;Count ++ )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack in reverse order.                */
    /*                                                                  */
    /*   We add multiple items to a stack in reverse order and check    */
    /*   to make sure that the stack has not overflowed.  If the stack  */
    /*   has overflowed we double its size.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStackReversed
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements in reverse order.
	//
    for ( Count = (Size-1);Count >= 0;Count -- )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek at the top of stack.                                      */
    /*                                                                  */
    /*   We return the top of stack with a pop but check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PeekStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the stack is not empty return a copy
	//   of the top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ (Top - 1) ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from a stack.                             */
    /*                                                                  */
    /*   We remove a single item from a stack and check to make sure    */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PopStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

    //
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the
	//   top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ -- Top ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to a stack.                                  */
    /*                                                                  */
    /*   We add a single item to a stack and check to make sure that    */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::PushStack
		( 
		CONST TYPE					  & Data
		)
    {    
	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is full then expand it.
	//
    while ( Top >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push a new element.
	//
    Stack[ Top ++ ] = Data;

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Read a stack value.                                            */
    /*                                                                  */
    /*   We return a single item from the stack but check to make       */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::ReadStack
        ( 
        SBIT32                        Index, 
        TYPE                          *Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the element exists then return a copy of
	//   it to the caller.
	//
    if ( Index < Top )
		{ 
		(*Data) = Stack[ Index ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Reverse the stack.                                             */
    /*                                                                  */
    /*   We reverse the order of the stack to make effectively          */
    /*   make it a queue.                .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::ReverseStack( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 MidPoint = (Top / 2);

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Swap all elements around the mid point.
	//
	for ( Count=0;Count < MidPoint;Count ++ )
		{
		REGISTER TYPE *Low = & Stack[ Count ];
		REGISTER TYPE *High = & Stack[ (Top - Count - 1) ];
		REGISTER TYPE Temp = (*Low);

		(*Low) = (*High);
		(*High) = Temp;
		}

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update a stack value.                                          */
    /*                                                                  */
    /*   We update a single item on the stack but check to make         */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::UpdateStack
        ( 
        CONST SBIT32				  Index, 
        CONST TYPE					  & Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the element exists then update it.
	//
    if ( Index < Top )
		{ 
		Stack[ Index ] = Data;

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::~STACK( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\library\tls.hpp ===
#ifndef _THREAD_LOCAL_STORE_HPP_
#define _THREAD_LOCAL_STORE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The environment constants indicate the state of thread         */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoTLSMemory			  = -1;
CONST SBIT32 NoTLSStructure			  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Thread local store.                                            */
    /*                                                                  */
    /*   A wide range of applications use threads.  It is often very    */
    /*   valuable to be able to have some private per thread data.      */
    /*   This functionality is supported by the following class.        */
    /*                                                                  */
    /********************************************************************/

class THREAD_LOCAL_STORE : public ASSEMBLY
    {
        //
        //   Private data.
        //
		BOOLEAN						  Active;

		SBIT32						  TlsIndex;
		SBIT32						  TlsOffset;

    public:
        //
        //   Public functions.
        //
        THREAD_LOCAL_STORE( VOID )
			{
			if ( Active = ((TlsIndex = TlsAlloc()) != NoTLSMemory) )
				{ TlsOffset = ((TlsIndex * sizeof(void*)) + TebSlot); }
			else
				{ Failure( "No TLS available" ); }
			}

		INLINE BOOLEAN Available( VOID )
			{ return Active; }
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY

		INLINE VOID *GetAddress( VOID )
			{ return (GetTlsAddress( TlsOffset )); }
#endif
#endif

		INLINE VOID *GetPointer( VOID )
			{ return (GetTlsValue( TlsIndex,TlsOffset )); }

		INLINE VOID SetPointer( VOID *NewPointer )
			{ SetTlsValue( TlsIndex,TlsOffset,NewPointer ); }

        ~THREAD_LOCAL_STORE( VOID )
			{
			Active = False;

			if ( TlsIndex != NoTLSMemory )
				{ 
				if ( ! TlsFree( TlsIndex ) )
					{ Failure( "Unable to free TLS memory" ); }
				}
			}

	private:
        //
        //   Disabled operations.
        //
        THREAD_LOCAL_STORE( CONST THREAD_LOCAL_STORE & Copy );

        VOID operator=( CONST THREAD_LOCAL_STORE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\buffer.inl ===
/***************************************************************************\
*
* File: Buffer.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Buffer_inl__INCLUDED)
#define SERVICES__Buffer_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DCBmpBuffer *
DCBmpBufferCache::Get()
{
    return static_cast<DCBmpBuffer *> (Pop());
}


//------------------------------------------------------------------------------
inline void        
DCBmpBufferCache::Release(DCBmpBuffer * pbufBmp)
{
    Push(pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline GpBmpBuffer *
GpBmpBufferCache::Get()
{
    return static_cast<GpBmpBuffer *> (Pop());
}


//------------------------------------------------------------------------------
inline void        
GpBmpBufferCache::Release(GpBmpBuffer * pbufBmp)
{
    Push(pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class TrxBuffer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxSurface * 
TrxBuffer::GetSurface(int idxSurface) const
{
    AssertMsg((idxSurface < m_cSurfaces) && (idxSurface >= 0), "Ensure valid index");

    return m_rgpsur[idxSurface];
}


//------------------------------------------------------------------------------
inline SIZE        
TrxBuffer::GetSize() const
{
    return m_sizePxl;
}


//------------------------------------------------------------------------------
inline BOOL        
TrxBuffer::GetInUse() const
{
    return m_fInUse;
}


//------------------------------------------------------------------------------
inline void        
TrxBuffer::SetInUse(BOOL fInUse)
{
    m_fInUse = fInUse;
}


/***************************************************************************\
*****************************************************************************
*
* class BufferManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline HRESULT
BufferManager::GetSharedBuffer(const RECT * prcInvalid, DCBmpBuffer ** ppbuf)
{
    UNREFERENCED_PARAMETER(prcInvalid);
    AssertWritePtr(ppbuf);
    AssertMsg(!m_bufDCBmpShared.InUse(), "Only should setup buffering once per subtree");

    *ppbuf = &m_bufDCBmpShared;

    return S_OK;
}


//------------------------------------------------------------------------------
inline HRESULT
BufferManager::GetSharedBuffer(const RECT * prcInvalid, GpBmpBuffer ** ppbuf)
{
    UNREFERENCED_PARAMETER(prcInvalid);
    AssertWritePtr(ppbuf);
    AssertMsg((m_pbufGpBmpShared == NULL) || !m_pbufGpBmpShared->InUse(), 
            "Only should setup buffering once per subtree");

    if (m_pbufGpBmpShared == NULL) {
        m_pbufGpBmpShared = ProcessNew(GpBmpBuffer);
        if (m_pbufGpBmpShared == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    AssertMsg(m_pbufGpBmpShared != NULL, "Must be properly allocated");
    *ppbuf = m_pbufGpBmpShared;

    return S_OK;
}


//------------------------------------------------------------------------------
inline void
BufferManager::ReleaseSharedBuffer(BmpBuffer * pbuf)
{
    AssertMsg(!pbuf->InUse(), "Buffer should no longer be in use when released");

    if ((pbuf != &m_bufDCBmpShared) &&
        (pbuf != m_pbufGpBmpShared)) {

        AssertMsg(0, "Unknown shared buffer");
    }
    
}


#endif // SERVICES__Buffer_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\buffer.cpp ===
/***************************************************************************\
*
* File: Buffer.cpp
*
* Description:
* Buffer.cpp implementats objects used in buffering operations, including 
* double buffering, DX-Transforms, etc.  These objects are maintained by a 
* central BufferManager that is available process-wide.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Buffer.h"

#include "FastDib.h"
#include "GdiCache.h"
#include "OSAL.h"
#include "ResourceManager.h"
#include "Surface.h"
#include "Context.h"

#define DEBUG_COPYTOCLIPBOARD   0   // Copy buffer to clipboard
#define DEBUG_DUMPREGION        0   // Dump regions

#if DEBUG_DUMPREGION

#define DUMP_REGION(name, rgn)
    DumpRegion(name, rgn)

void
DumpRegion(LPCTSTR pszName, HRGN hrgn)
{
    RECT rc;
    int nType = GetRgnBox(hrgn, &rc);
    switch (nType)
    {
    case NULLREGION:
        Trace("Null region %s = 0x%p\n", pszName, hrgn);
        break;

    case SIMPLEREGION:
        Trace("Simple region %s = 0x%p (%d,%d)-(%d,%d)\n", pszName, hrgn, rc.left, rc.top, rc.right, rc.bottom);
        break;

    case COMPLEXREGION:
        Trace("Complex region %s = 0x%p (%d,%d)-(%d,%d)\n", pszName, hrgn, rc.left, rc.top, rc.right, rc.bottom);
        break;

    default:
        Trace("Illegal region %s = 0x%p\n", pszName, hrgn);
    }
}

#else

#define DUMP_REGION(name, rgn) ((void) 0)

#endif


/***************************************************************************\
*****************************************************************************
*
* class BufferManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BufferManager::BufferManager()
{
#if ENABLE_DUMPCACHESTATS
    m_cacheDCBmpCached.SetName("DCBmpCached");
    m_cacheGpBmpCached.SetName("GpBmpCached");
#endif
}


//------------------------------------------------------------------------------
BufferManager::~BufferManager()
{
    if (m_pbufGpBmpShared != NULL) {
        ProcessDelete(GpBmpBuffer, m_pbufGpBmpShared);
        m_pbufGpBmpShared = NULL;
    }

    AssertMsg(m_pbufTrx == NULL, "Ensure all buffers have been destroyed");
}


//------------------------------------------------------------------------------
void        
BufferManager::Destroy()
{
    RemoveAllTrxBuffers();

    m_cacheDCBmpCached.Destroy();
    m_cacheGpBmpCached.Destroy();
}


/***************************************************************************\
*
* BufferManager::BeginTransition
*
* BeginTransition() finds a TrxBuffer to be used for a new Transition.  If
* no cached, correct-format TrxBuffers are available, a new TrxBuffer is
* created.  When the caller is finished with the buffer, it should be
* returned with EndTransition().
*
\***************************************************************************/

HRESULT
BufferManager::BeginTransition(
    IN  SIZE sizePxl,               // Minimum size of each buffer, in pixels
    IN  int cSurfaces,              // Number of buffers
    IN  BOOL fExactSize,            // Buffer size must be an exact match
    OUT TrxBuffer ** ppbuf)         // Transition Buffer
{
    AssertMsg((sizePxl.cx > 0) && (sizePxl.cy > 0) && (sizePxl.cx < 2000) && (sizePxl.cy < 2000),
            "Ensure reasonable buffer size");
    AssertMsg((cSurfaces > 0) && (cSurfaces <= 3), "Ensure reasonable number of buffers");
    AssertWritePtr(ppbuf);
    HRESULT hr;
    *ppbuf = NULL;

    //
    // Part 1: Check if an existing buffer is large enough / the correct size.
    //

    if (m_pbufTrx != NULL) {
        SIZE sizeExistPxl = m_pbufTrx->GetSize();

        if (fExactSize) {
            if ((sizePxl.cx != sizeExistPxl.cx) || (sizePxl.cy != sizeExistPxl.cy)) {
                ClientDelete(TrxBuffer, m_pbufTrx);
                m_pbufTrx = NULL;
            }
        } else {
            if ((sizePxl.cx > sizeExistPxl.cx) || (sizePxl.cy > sizeExistPxl.cy)) {
                ClientDelete(TrxBuffer, m_pbufTrx);
                m_pbufTrx = NULL;
            }
        }
    }

    //
    // Part 2: Create a new buffer, if needed
    //

    if (m_pbufTrx == NULL) {
        hr = TrxBuffer::Build(sizePxl, cSurfaces, &m_pbufTrx);
        if (FAILED(hr)) {
            return hr;
        }
    }

    AssertMsg(!m_pbufTrx->GetInUse(), "Ensure the buffer isn't already in use");
    m_pbufTrx->SetInUse(TRUE);

    *ppbuf = m_pbufTrx;
    return S_OK;
}


/***************************************************************************\
*
* BufferManager::EndTransition
*
* EndTransition() is called to return a TrxBuffer to the BufferManager
* after use.
*
\***************************************************************************/

void        
BufferManager::EndTransition(
    IN  TrxBuffer * pbufTrx,        // TrxBuffer being returned
    IN  BOOL fCache)                // Add the buffer to the available cache
{
    AssertMsg(m_pbufTrx->GetInUse(), "Ensure the buffer was being used");
    AssertMsg(m_pbufTrx == pbufTrx, "Ensure correct buffer");

    pbufTrx->SetInUse(FALSE);

    if (!fCache) {
        //
        // For now, since DxXForm's must always be the correct size, there 
        // isn't much point in caching them and we can reclaim the memory.  If 
        // this changes, reinvestigate caching them.
        //

        ClientDelete(TrxBuffer, m_pbufTrx);
        m_pbufTrx = NULL;
    }
}


/***************************************************************************\
*
* BufferManager::FlushTrxBuffers
*
* FlushTrxBuffers() is called when all TrxBuffers must be forceably released, 
* for example when DXTX shuts down.
*
\***************************************************************************/

void        
BufferManager::FlushTrxBuffers()
{
    RemoveAllTrxBuffers();
}


/***************************************************************************\
*
* BufferManager::RemoveAllTrxBuffers
*
* RemoveAllTrxBuffers() cleans up all resources associated with all
* TrxBuffers.
*
\***************************************************************************/

void        
BufferManager::RemoveAllTrxBuffers()
{
    if (m_pbufTrx != NULL) {
        AssertMsg(!m_pbufTrx->GetInUse(), "Buffer should not be in use");
        ClientDelete(TrxBuffer, m_pbufTrx);
        m_pbufTrx = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT     
BufferManager::GetCachedBuffer(DuSurface::EType type, BmpBuffer ** ppbuf)
{
    AssertWritePtr(ppbuf);

    switch (type)
    {
    case DuSurface::stDC:
        if ((*ppbuf = m_cacheDCBmpCached.Get()) == NULL) {
            return E_OUTOFMEMORY;
        }
        break;

    case DuSurface::stGdiPlus:
        if ((*ppbuf = m_cacheGpBmpCached.Get()) == NULL) {
            return E_OUTOFMEMORY;
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
        return E_NOTIMPL;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
void        
BufferManager::ReleaseCachedBuffer(BmpBuffer * pbuf)
{
    AssertReadPtr(pbuf);

    switch (pbuf->GetType())
    {
    case DuSurface::stDC:
        m_cacheDCBmpCached.Release(static_cast<DCBmpBuffer*>(pbuf));
        break;

    case DuSurface::stGdiPlus:
        m_cacheGpBmpCached.Release(static_cast<GpBmpBuffer*>(pbuf));
        break;

    default:
        AssertMsg(0, "Unknown surface type");
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DCBmpBuffer::DCBmpBuffer
*
* DCBmpBuffer() fully initializes a new DCBmpBuffer object.
*
\***************************************************************************/

DCBmpBuffer::DCBmpBuffer()
{

}


/***************************************************************************\
*
* DCBmpBuffer::~DCBmpBuffer
*
* ~DCBmpBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

DCBmpBuffer::~DCBmpBuffer()
{
    EndDraw(FALSE);
    FreeBitmap();
}


/***************************************************************************\
*
* DCBmpBuffer::BeginDraw
*
* BeginDraw() sets up the DCBmpBuffer to begin a drawing cycle.  The final
* destination HDC and size are passed in, and a new "temporary" HDC is
* returned out.
*
\***************************************************************************/

HRESULT
DCBmpBuffer::BeginDraw(
    IN  DuSurface * psrfDraw,       // Final destination Surface
    IN  const RECT * prcInvalid,    // Invalid area of destination
    IN  UINT nCmd,                  // How the buffer is to be used
    OUT DuSurface ** ppsrfBuffer)   // Surface of buffer or NULL if not needed
{
    AssertMsg(prcInvalid != NULL, "Must specify a valid area");
    AssertWritePtr(ppsrfBuffer);
    *ppsrfBuffer = NULL;

    HDC hdcDraw = CastHDC(psrfDraw);


    //
    // Ensure not in the middle of drawing.
    //
    EndDraw(FALSE);

    //
    // Determine the size of the area to draw and ensure that the buffer is 
    // large enough.
    //
    SIZE sizeBmp;
    sizeBmp.cx     = prcInvalid->right - prcInvalid->left;
    sizeBmp.cy     = prcInvalid->bottom - prcInvalid->top;

    if ((sizeBmp.cx == 0) || (sizeBmp.cy == 0)) {
        //
        // Nothing to draw / buffer, so just let drawing occur in the given
        // buffer.  Signal this by returning NULL so that the caller knows
        // not to create extra, unnecessary data.
        //

        AssertMsg(!m_fChangeOrg, "Ensure valid state");
        AssertMsg(m_hdcDraw == NULL, "Ensure valid state");

        return S_OK;
    }

    if ((sizeBmp.cx > m_sizeBmp.cx) || (sizeBmp.cy > m_sizeBmp.cy)) {
        //
        // When allocating a new bitmap, make it large enough to consume the
        // existing bitmap.  This helps avoid swapping between two different
        // bitmaps.
        //
        // TODO: Need to add code into the BufferManager that maintains multiple
        // bitmaps of different sizes so that we don't get many rarely-used, 
        // giant bitmaps.
        //

        if (!AllocBitmap(hdcDraw, 
                max(sizeBmp.cx, m_sizeBmp.cx), 
                max(sizeBmp.cy, m_sizeBmp.cy))) {

            return DU_E_OUTOFGDIRESOURCES;
        }
    }

    AssertMsg((prcInvalid->right >= prcInvalid->left) && 
            (prcInvalid->bottom >= prcInvalid->top), "Check normalized");

    //
    // Setup the drawing
    //
    m_hdcBitmap = CreateCompatibleDC(hdcDraw);
    if (m_hdcBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

    if (SupportXForm()) {
        m_nOldGfxMode = SetGraphicsMode(m_hdcBitmap, GM_ADVANCED);
    }
    m_hbmpOld       = (HBITMAP) SelectObject(m_hdcBitmap, m_hbmpBuffer);

    HPALETTE hpal   = (HPALETTE) GetCurrentObject(hdcDraw, OBJ_PAL);
    if (hpal != NULL) {
        m_hpalOld   = SelectPalette(m_hdcBitmap, hpal, FALSE);
    } else {
        m_hpalOld   = NULL;
    }

    m_hdcDraw       = hdcDraw;
    m_ptDraw.x      = prcInvalid->left;
    m_ptDraw.y      = prcInvalid->top;
    m_sizeDraw.cx   = prcInvalid->right - prcInvalid->left;
    m_sizeDraw.cy   = prcInvalid->bottom - prcInvalid->top;
    m_nCmd          = nCmd;

    if ((m_ptDraw.x != 0) || (m_ptDraw.y != 0)) {
        /*
         * The buffer size is minimized to the painting area, so we need to
         * setup some stuff to "fake" GDI and do the right thing:
         * 1. Change the brush origin so that it the end result appears 
         *    consistent
         * 2. Change the window origin so that the drawing is in the upper
         *    left corner.
         *
         * We will set this back when we are done drawing.
         */

        POINT ptBrushOrg;
        GetBrushOrgEx(m_hdcBitmap, &ptBrushOrg);
        SetBrushOrgEx(m_hdcBitmap, 
                ptBrushOrg.x - m_ptDraw.x, ptBrushOrg.y - m_ptDraw.y, 
                &m_ptOldBrushOrg);

        m_fChangeOrg = TRUE;
    } else {
        m_fChangeOrg = FALSE;
    }

    OS()->PushXForm(m_hdcBitmap, &m_xfOldBitmap);
    OS()->PushXForm(m_hdcDraw, &m_xfOldDraw);
    m_fChangeXF     = TRUE;
    m_fClip         = FALSE;

#if DEBUG_COPYTOCLIPBOARD
#if DBG
    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeBmp.cx;
    rcFill.bottom   = m_sizeBmp.cy;
    FillRect(m_hdcBitmap, &rcFill, GetStdColorBrushI(SC_Plum));
#endif // DBG
#endif // DEBUG_COPYTOCLIPBOARD


    //
    // Setup the buffer as necessary
    //

    if (m_nCmd == BmpBuffer::dcCopyBkgnd) {
        //
        // Copy the destination to the buffer to be used as a background.
        //

        BitBlt(m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, 
                m_hdcDraw, m_ptDraw.x, m_ptDraw.y, SRCCOPY);
    }


    //
    // Clip drawing in the buffer to the actual used part of the buffer.  Since
    // this is the only part that will be copied over, we don't want to draw 
    // outside of this area since it slows down performance.
    //

    GdiCache * pgc = GetGdiCache();

    HRGN hrgnClip = pgc->GetTempRgn();
    if (hrgnClip != NULL) {
        SetRectRgn(hrgnClip, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy);
        ExtSelectClipRgn(m_hdcBitmap, hrgnClip, RGN_COPY);


        //
        // If the destination surface had a clipping region, we need to 
        // propagate it over to the buffer.
        //

        HRGN hrgnDraw = pgc->GetTempRgn();
        if (hrgnDraw != NULL) {
            if (GetClipRgn(m_hdcDraw, hrgnDraw) == 1) {

                OffsetRgn(hrgnDraw, -m_ptDraw.x, -m_ptDraw.y);
                ExtSelectClipRgn(m_hdcBitmap, hrgnDraw, RGN_AND);
            }

            pgc->ReleaseTempRgn(hrgnDraw);
        }
        pgc->ReleaseTempRgn(hrgnClip);
    }


    //
    // Create a new Surface to contain the buffer.
    //

    return DuDCSurface::Build(m_hdcBitmap, (DuDCSurface **) ppsrfBuffer);
}


/***************************************************************************\
*
* DCBmpBuffer::Fill
*
* TOOD:
*
\***************************************************************************/

void        
DCBmpBuffer::Fill(COLORREF cr)
{
    HBRUSH hbr = CreateSolidBrush(cr);

    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeDraw.cx;
    rcFill.bottom   = m_sizeDraw.cy;
    
    FillRect(m_hdcBitmap, &rcFill, hbr);

    DeleteObject(hbr);
}


/***************************************************************************\
*
* DCBmpBuffer::PreEndDraw
*
* PreEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is prepared to be
* copied to the final destination.  The called MUST also call EndDraw()
* to properly end the drawing cycle.
*
\***************************************************************************/

void        
DCBmpBuffer::PreEndDraw(
    IN  BOOL fCommit)               // Copy to final destination
{
    //
    // Resource the destination and buffer surfaces back to where they started.
    // This is important because they will be changed during the drawing.
    //

    if (m_fChangeXF) {
        OS()->PopXForm(m_hdcBitmap, &m_xfOldBitmap);
        OS()->PopXForm(m_hdcDraw, &m_xfOldDraw);
        m_fChangeXF = FALSE;
    }

    if (m_fChangeOrg) {
        SetBrushOrgEx(m_hdcBitmap, m_ptOldBrushOrg.x, m_ptOldBrushOrg.y, NULL);
        m_fChangeOrg = FALSE;
    }

    if ((fCommit) && (m_hdcDraw != NULL)) {
        //
        // Setup any clipping region needed to limit the buffer to an area
        // in the destination surface.
        //

        if (m_fClip) {
            AssertMsg(m_hrgnDrawClip != NULL, "Must have valid region");
            AssertMsg(m_hrgnDrawOld == NULL, "Ensure no outstanding region");

            m_hrgnDrawOld = GetGdiCache()->GetTempRgn();
            if (m_hrgnDrawOld != NULL) {
                DUMP_REGION("m_hrgnDrawOld", m_hrgnDrawOld);
                if (GetClipRgn(m_hdcDraw, m_hrgnDrawOld) <= 0) {
                    GetGdiCache()->ReleaseTempRgn(m_hrgnDrawOld);
                    m_hrgnDrawOld = NULL;
                }

                DUMP_REGION("m_hrgnDrawClip", m_hrgnDrawClip);
                ExtSelectClipRgn(m_hdcDraw, m_hrgnDrawClip, RGN_COPY);
            }
        }
    }
}



/***************************************************************************\
*
* DCBmpBuffer::EndDraw
*
* EndDraw() presents a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is copied to the 
* final destination.  The caller MUST first call PreEndDraw() to properly 
* setup any state needed to end the drawing cycle.
*
\***************************************************************************/

void        
DCBmpBuffer::EndDraw(
    IN  BOOL fCommit,               // Copy to final destination
    IN  BYTE bAlphaLevel,           // General alpha level
    IN  BYTE bAlphaFormat)          // Pixel alpha format
{
    if ((fCommit) && (m_hdcDraw != NULL)) {
        //
        // Copy the bits over
        //

        if (bAlphaLevel == BLEND_OPAQUE) {
            BitBlt(m_hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, SRCCOPY);
        } else {
            BLENDFUNCTION bf;
            bf.AlphaFormat  = bAlphaFormat;
            bf.BlendFlags   = 0;
            bf.BlendOp      = AC_SRC_OVER;
            bf.SourceConstantAlpha = bAlphaLevel;

            AlphaBlend(m_hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, bf);
        }
    }
}


/***************************************************************************\
*
* DCBmpBuffer::PostEndDraw
*
* PostEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  After this function finishes, the buffer is ready to be used
* again.  
*
\***************************************************************************/

void        
DCBmpBuffer::PostEndDraw()
{
    if (m_hdcDraw != NULL) {
        //
        // Cleanup the temporary clipping region.  This is VERY important to
        // do so that the destination surface can continued to be drawn on.
        // (For example, more Gadget siblings...)
        //

        if (m_fClip) {
            //
            // NOTE: m_hrgnDrawOld may be NULL if there was no previous clipping 
            // region.
            //

            ExtSelectClipRgn(m_hdcDraw, m_hrgnDrawOld, RGN_COPY);
            if (m_hrgnDrawOld != NULL) {
                GetGdiCache()->ReleaseTempRgn(m_hrgnDrawOld);
                m_hrgnDrawOld = NULL;
            }
        }
    }


    //
    // Cleanup the clipping region
    //

    if (m_fClip) {
        AssertMsg(m_hrgnDrawClip != NULL, "Must have a valid region");
        GetGdiCache()->ReleaseTempRgn(m_hrgnDrawClip);
        m_hrgnDrawClip = NULL;
        m_fClip = FALSE;
    }
    AssertMsg(m_hrgnDrawClip == NULL, "Should no longer have a clipping region");


    //
    // Cleanup associated resources
    //

    if (m_hdcBitmap != NULL) {
        if (m_hpalOld != NULL) {
            SelectPalette(m_hdcBitmap, m_hpalOld, TRUE);
            m_hpalOld = NULL;
        }

        SelectObject(m_hdcBitmap, m_hbmpOld);
        if (SupportXForm()) {
            SetGraphicsMode(m_hdcBitmap, m_nOldGfxMode);
        }
        DeleteDC(m_hdcBitmap);
        m_hdcBitmap = NULL;

#if DEBUG_COPYTOCLIPBOARD
#if DBG

        if (OpenClipboard(NULL)) {
            EmptyClipboard();
            HBITMAP hbmpCopy = (HBITMAP) CopyImage(m_hbmpBuffer, IMAGE_BITMAP, 0, 0, 0);

            HDC hdc = GetGdiCache()->GetCompatibleDC();
            HBITMAP hbmpOld = (HBITMAP) SelectObject(hdc, hbmpCopy);

            // Outline the actual drawn area
            RECT rcDraw;
            rcDraw.left     = 0;
            rcDraw.top      = 0;
            rcDraw.right    = m_sizeDraw.cx;
            rcDraw.bottom   = m_sizeDraw.cy;
            GdDrawOutlineRect(hdc, &rcDraw, GetStdColorBrushI(SC_Crimson), 1);

            SelectObject(hdc, hbmpOld);
            GetGdiCache()->ReleaseCompatibleDC(hdc);

            SetClipboardData(CF_BITMAP, hbmpCopy);
            CloseClipboard();
        }

#endif // DBG
#endif // DEBUG_COPYTOCLIPBOARD
    }

    m_hdcDraw   = NULL;
    m_hbmpOld   = NULL;

    if (GetContext()->GetPerfMode() == IGPM_SIZE) {
        FreeBitmap();
    }
}


//------------------------------------------------------------------------------
void        
DCBmpBuffer::SetupClipRgn()
{
    AssertMsg(!m_fClip, "Only should setup clip region once per cycle");
    AssertMsg(m_hrgnDrawClip == NULL, "Should not already have a clip region");

    m_hrgnDrawClip = GetGdiCache()->GetTempRgn();
    if (m_hrgnDrawClip == NULL) {
        return;
    }

    
    //
    // NOTE: GetClipRgn() does NOT return the standard region return values.
    //

    if (GetClipRgn(m_hdcBitmap, m_hrgnDrawClip) == 1) {
        DUMP_REGION("m_hrgnDrawClip", m_hrgnDrawClip);

        OffsetRgn(m_hrgnDrawClip, m_ptDraw.x, m_ptDraw.y);
        m_fClip = TRUE;
    } else {
        GetGdiCache()->ReleaseTempRgn(m_hrgnDrawClip);
        m_hrgnDrawClip = NULL;
    }
}


/***************************************************************************\
*
* DCBmpBuffer::InUse
*
* InUse() returns if the DCBmpBuffer is currently in a draw cycle started from
* BeginDraw().
*
\***************************************************************************/

BOOL        
DCBmpBuffer::InUse() const
{
    return m_hdcDraw != NULL;
}


/***************************************************************************\
*
* DCBmpBuffer::AllocBitmap
*
* AllocBitmap() allocates the internal bitmap buffer that is used to 
* temporarily draw into.  This bitmap will be compatible with the final
* destination surface.
*
\***************************************************************************/

BOOL        
DCBmpBuffer::AllocBitmap(
    IN  HDC hdcDraw,                // Final destination HDC
    IN  int cx,                     // Width of new bitmap
    IN  int cy)                     // Height of new bitmap
{
    FreeBitmap();

    //
    // When allocating a bitmap, round up to a multiple of 16 x 16.  This helps
    // to reduce unnecessary reallocations because we grew by one or two pixels.
    //

    cx = ((cx + 15) / 16) * 16;
    cy = ((cy + 15) / 16) * 16;


    //
    // Allocate the bitmap
    //

#if 0
    m_hbmpBuffer = CreateCompatibleBitmap(hdcDraw, cx, cy);
#else
    m_hbmpBuffer = ResourceManager::RequestCreateCompatibleBitmap(hdcDraw, cx, cy);
#endif
    if (m_hbmpBuffer == NULL) {
        return FALSE;
    }

    m_sizeBmp.cx = cx;
    m_sizeBmp.cy = cy;
    return TRUE;
}


/***************************************************************************\
*
* DCBmpBuffer::FreeBitmap
*
* FreeBitmap() cleans up allocated resources.
*
\***************************************************************************/

void
DCBmpBuffer::FreeBitmap()
{
    if (m_hbmpBuffer != NULL) {
        DeleteObject(m_hbmpBuffer);
        m_hbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GpBmpBuffer::GpBmpBuffer
*
* GpBmpBuffer() fully initializes a new GpBmpBuffer object.
*
\***************************************************************************/

GpBmpBuffer::GpBmpBuffer()
{

}


/***************************************************************************\
*
* GpBmpBuffer::~GpBmpBuffer
*
* ~GpBmpBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

GpBmpBuffer::~GpBmpBuffer()
{
    EndDraw(FALSE);
    FreeBitmap();
}


/***************************************************************************\
*
* GpBmpBuffer::BeginDraw
*
* BeginDraw() sets up the GpBmpBuffer to begin a drawing cycle.  The final
* destination HDC and size are passed in, and a new "temporary" HDC is
* returned out.
*
\***************************************************************************/

HRESULT
GpBmpBuffer::BeginDraw(
    IN  DuSurface * psrfDraw,       // Final destination Surface
    IN  const RECT * prcInvalid,    // Invalid area of destination
    IN  UINT nCmd,                  // How the buffer is to be used
    OUT DuSurface ** ppsrfBuffer)   // Surface of buffer or NULL if not needed
{
    AssertMsg(prcInvalid != NULL, "Must specify a valid area");
    AssertWritePtr(ppsrfBuffer);
    *ppsrfBuffer = NULL;

    Gdiplus::Graphics * pgpgrDraw = CastGraphics(psrfDraw);

    if (!ResourceManager::IsInitGdiPlus()) {
        return DU_E_NOTINITIALIZED;
    }


    //
    // Ensure not in the middle of drawing.
    //
    EndDraw(FALSE);

    //
    // Determine the size of the area to draw and ensure that the buffer is 
    // large enough.
    //
    SIZE sizeBmp;
    sizeBmp.cx     = prcInvalid->right - prcInvalid->left;
    sizeBmp.cy     = prcInvalid->bottom - prcInvalid->top;

    if ((sizeBmp.cx == 0) || (sizeBmp.cy == 0)) {
        //
        // Nothing to draw / buffer, so just let drawing occur in the given
        // buffer.  Signal this by returning NULL so that the caller knows
        // not to create extra, unnecessary data.
        //

        AssertMsg(!m_fChangeOrg, "Ensure valid state");
        AssertMsg(m_pgpgrDraw == NULL, "Ensure valid state");

        return S_OK;
    }

    if ((sizeBmp.cx > m_sizeBmp.cx) || (sizeBmp.cy > m_sizeBmp.cy)) {
        //
        // When allocating a new bitmap, make it large enough to consume the
        // existing bitmap.  This helps avoid swapping between two different
        // bitmaps.
        //
        // TODO: Need to add code into the BufferManager that maintains multiple
        // bitmaps of different sizes so that we don't get many rarely-used, 
        // giant bitmaps.
        //

        if (!AllocBitmap(pgpgrDraw, 
                max(sizeBmp.cx, m_sizeBmp.cx), 
                max(sizeBmp.cy, m_sizeBmp.cy))) {

            return DU_E_OUTOFGDIRESOURCES;
        }
    }

    AssertMsg((prcInvalid->right >= prcInvalid->left) && 
            (prcInvalid->bottom >= prcInvalid->top), "Check normalized");

    //
    // Setup the drawing
    //
#if ENABLE_USEFASTDIB

    HDC hdcTemp     = GetGdiCache()->GetTempDC();
    m_hdcBitmap     = CreateCompatibleDC(hdcTemp);
    GetGdiCache()->ReleaseTempDC(hdcTemp);
    if (m_hdcBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

    m_hbmpOld       = (HBITMAP) SelectObject(m_hdcBitmap, m_hbmpBuffer);

    m_pgpgrBitmap = new Gdiplus::Graphics(m_hdcBitmap);
    if (m_pgpgrBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

#else

    m_pgpgrBitmap = new Gdiplus::Graphics(m_pgpbmpBuffer);
    if (m_pgpgrBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

#endif

#if 0
    m_pgpgrBitmap->SetAlphaLevel(pgpgrDraw->GetAlphaLevel());
#endif

    m_pgpgrBitmap->SetCompositingMode(pgpgrDraw->GetCompositingMode());
    m_pgpgrBitmap->SetCompositingQuality(pgpgrDraw->GetCompositingQuality());
    m_pgpgrBitmap->SetInterpolationMode(pgpgrDraw->GetInterpolationMode());
    m_pgpgrBitmap->SetSmoothingMode(pgpgrDraw->GetSmoothingMode());
    m_pgpgrBitmap->SetPixelOffsetMode(pgpgrDraw->GetPixelOffsetMode());

    m_pgpgrBitmap->SetTextContrast(pgpgrDraw->GetTextContrast());
    m_pgpgrBitmap->SetTextRenderingHint(pgpgrDraw->GetTextRenderingHint());


    m_pgpgrDraw     = pgpgrDraw;
    m_ptDraw.x      = prcInvalid->left;
    m_ptDraw.y      = prcInvalid->top;
    m_sizeDraw.cx   = prcInvalid->right - prcInvalid->left;
    m_sizeDraw.cy   = prcInvalid->bottom - prcInvalid->top;
    m_nCmd          = nCmd;

    m_fChangeOrg    = FALSE;

    m_pgpgrBitmap->GetTransform(&m_gpmatOldBitmap);
    m_pgpgrDraw->GetTransform(&m_gpmatOldDraw);

    m_fChangeXF     = TRUE;
    m_fClip         = FALSE;


    //
    // Setup the buffer as necessary
    //

    if (m_nCmd == BmpBuffer::dcCopyBkgnd) {
        //
        // Copy the destination to the buffer to be used as a background.
        //

        // TODO: This is not supported because GDI+ can't BLT from one 
        // Graphics directly to another.
    }


    //
    // Clip drawing in the buffer to the actual used part of the buffer.  Since
    // this is the only part that will be copied over, we don't want to draw 
    // outside of this area since it slows down performance.
    //


    Gdiplus::RectF rc(0.0f, 0.0f, (float) m_sizeDraw.cx + 1.0f, (float) m_sizeDraw.cy + 1.0f);
    m_pgpgrBitmap->SetClip(rc);

    if (!m_pgpgrDraw->IsClipEmpty()) {
        //
        // Destination surface has a clipping region, so we need to propagate
        // it over to the buffer.
        //

        Gdiplus::Region gprgn;
        m_pgpgrDraw->GetClip(&gprgn);
        gprgn.Translate(-m_ptDraw.x, -m_ptDraw.y);
        m_pgpgrBitmap->SetClip(&gprgn, Gdiplus::CombineModeIntersect);
    }


    //
    // Create a new Surface to contain the buffer.
    //

    return DuGpSurface::Build(m_pgpgrBitmap, (DuGpSurface **) ppsrfBuffer);
}


/***************************************************************************\
*
* GpBmpBuffer::Fill
*
* TOOD:
*
\***************************************************************************/

void        
GpBmpBuffer::Fill(COLORREF cr)
{
    //
    // Determine packing
    //

    HBRUSH hbr = CreateSolidBrush(cr);

    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeDraw.cx;
    rcFill.bottom   = m_sizeDraw.cy;
    
    FillRect(m_hdcBitmap, &rcFill, hbr);

    DeleteObject(hbr);
}


/***************************************************************************\
*
* GpBmpBuffer::PreEndDraw
*
* PreEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is prepared to be
* copied to the final destination.  The called MUST also call EndDraw()
* to properly end the drawing cycle.
*
\***************************************************************************/

void        
GpBmpBuffer::PreEndDraw(
    IN  BOOL fCommit)               // Copy to final destination
{
    //
    // Resource the destination and buffer surfaces back to where they started.
    // This is important because they will be changed during the drawing.
    //

    if (m_fChangeXF) {
        m_pgpgrDraw->SetTransform(&m_gpmatOldDraw);
        m_pgpgrBitmap->SetTransform(&m_gpmatOldBitmap);
        m_fChangeXF = FALSE;
    }

    Assert(!m_fChangeOrg);

    if ((fCommit) && (m_pgpgrDraw != NULL)) {
        //
        // Setup any clipping region needed to limit the buffer to an area
        // in the destination surface.
        //

        if (m_fClip) {
            AssertMsg(m_pgprgnDrawClip != NULL, "Must have valid region");
            AssertMsg(m_pgprgnDrawOld == NULL, "Ensure no outstanding region");

            m_pgprgnDrawOld = new Gdiplus::Region;
            if (m_pgprgnDrawOld != NULL) {
                m_pgpgrDraw->GetClip(m_pgprgnDrawOld);
                m_pgpgrDraw->SetClip(m_pgprgnDrawClip);
            }
        }
    }
}



/***************************************************************************\
*
* GpBmpBuffer::EndDraw
*
* EndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is copied to the 
* final destination.  After this function finishes, the GpBmpBuffer is ready
* be used again.  The called MUST first call PreEndDraw() to properly setup
* any state needed to end the drawing cycle.
*
\***************************************************************************/

void        
GpBmpBuffer::EndDraw(
    IN  BOOL fCommit,               // Copy to final destination
    IN  BYTE bAlphaLevel,           // General alpha level
    IN  BYTE bAlphaFormat)          // Pixel alpha format
{
    UNREFERENCED_PARAMETER(bAlphaFormat);

    if ((fCommit) && (m_pgpgrDraw != NULL)) {
        //
        // Copy the bits over
        //

#if ENABLE_USEFASTDIB

        HDC hdcDraw = m_pgpgrDraw->GetHDC();

        if (bAlphaLevel == BLEND_OPAQUE) {
            BitBlt(hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, SRCCOPY);
        } else {
            BLENDFUNCTION bf;
            bf.AlphaFormat  = bAlphaFormat;
            bf.BlendFlags   = 0;
            bf.BlendOp      = AC_SRC_OVER;
            bf.SourceConstantAlpha = bAlphaLevel;

            AlphaBlend(hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, bf);
        }

        m_pgpgrDraw->ReleaseHDC(hdcDraw);

#else

        if (bAlphaLevel == BLEND_OPAQUE) {
            m_pgpgrDraw->DrawImage(m_pgpbmpBuffer, m_ptDraw.x, m_ptDraw.y, 
                    0, 0, m_sizeDraw.cx, m_sizeDraw.cy, Gdiplus::UnitPixel);
        } else {
            // TODO: Need to alpha-blend using GDI+
        }

#endif
    }
}


/***************************************************************************\
*
* GpBmpBuffer::PostEndDraw
*
* PostEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  After this function finishes, the buffer is ready to be used
* again.  
*
\***************************************************************************/

void        
GpBmpBuffer::PostEndDraw()
{
    if (m_pgpgrDraw != NULL) {
        //
        // Cleanup the temporary clipping region.  This is VERY important to
        // do so that the destination surface can continued to be drawn on.
        // (For example, more Gadget siblings...)
        //

        if (m_fClip) {
            m_pgpgrDraw->SetClip(m_pgprgnDrawOld);
            if (m_pgprgnDrawOld != NULL) {
                delete m_pgprgnDrawOld;
                m_pgprgnDrawOld = NULL;
            }
        }
    }


    //
    // Cleanup the clipping region
    //

    if (m_fClip) {
        AssertMsg(m_pgprgnDrawClip!= NULL, "Must have a valid region");
        delete m_pgprgnDrawClip;
        m_pgprgnDrawClip = NULL;
        m_fClip = FALSE;
    }
    AssertMsg(m_pgprgnDrawClip == NULL, "Should no longer have a clipping region");


    //
    // Cleanup associated resources
    //

    if (m_pgpgrBitmap != NULL) {
        delete m_pgpgrBitmap;
        m_pgpgrBitmap = NULL;
    }

    if (m_hdcBitmap != NULL) {
        SelectObject(m_hdcBitmap, m_hbmpOld);
        DeleteDC(m_hdcBitmap);
        m_hdcBitmap = NULL;
    }

    m_pgpgrDraw = NULL;
    
    if (GetContext()->GetPerfMode() == IGPM_SIZE) {
        FreeBitmap();
    }
}


//------------------------------------------------------------------------------
void        
GpBmpBuffer::SetupClipRgn()
{
    AssertMsg(!m_fClip, "Only should setup clip region once per cycle");
    AssertMsg(m_pgprgnDrawClip == NULL, "Should not already have a clip region");

    m_pgprgnDrawClip = new Gdiplus::Region;
    if (m_pgprgnDrawClip == NULL) {
        return;
    }

    m_pgpgrBitmap->GetClip(m_pgprgnDrawClip);
    m_pgprgnDrawClip->Translate(m_ptDraw.x, m_ptDraw.y);
    m_fClip = TRUE;
}


/***************************************************************************\
*
* GpBmpBuffer::InUse
*
* InUse() returns if the GpBmpBuffer is currently in a draw cycle started from
* BeginDraw().
*
\***************************************************************************/

BOOL        
GpBmpBuffer::InUse() const
{
    return m_pgpgrDraw != NULL;
}


/***************************************************************************\
*
* GpBmpBuffer::AllocBitmap
*
* AllocBitmap() allocates the internal bitmap buffer that is used to 
* temporarily draw into.  This bitmap will be compatible with the final
* destination surface.
*
\***************************************************************************/

BOOL        
GpBmpBuffer::AllocBitmap(
    IN  Gdiplus::Graphics * pgpgr,  // Final destination Graphics
    IN  int cx,                     // Width of new bitmap
    IN  int cy)                     // Height of new bitmap
{
    FreeBitmap();

    Assert(ResourceManager::IsInitGdiPlus());

    //
    // When allocating a bitmap, round up to a multiple of 16 x 16.  This helps
    // to reduce unnecessary reallocations because we grew by one or two pixels.
    //

    cx = ((cx + 15) / 16) * 16;
    cy = ((cy + 15) / 16) * 16;


    //
    // Allocate the bitmap
    //

#if ENABLE_USEFASTDIB

    UNREFERENCED_PARAMETER(pgpgr);

    HPALETTE hpal   = NULL;
    HDC hdcTemp     = GetGdiCache()->GetTempDC();

    ZeroMemory(&m_bmih, sizeof(m_bmih));
    m_bmih.biSize   = sizeof(m_bmih);
    m_hbmpBuffer    = CreateCompatibleDIB(hdcTemp, hpal, cx, cy, &m_pvBits, &m_bmih);
    GetGdiCache()->ReleaseTempDC(hdcTemp);

    if (m_hbmpBuffer == NULL) {
        return FALSE;
    }

#else
    
    m_pgpbmpBuffer = new Gdiplus::Bitmap(cx, cy, pgpgr);
    if (m_pgpbmpBuffer == NULL) {
        return FALSE;
    }

#endif

    m_sizeBmp.cx = cx;
    m_sizeBmp.cy = cy;
    return TRUE;
}


/***************************************************************************\
*
* GpBmpBuffer::FreeBitmap
*
* FreeBitmap() cleans up allocated resources.
*
\***************************************************************************/

void
GpBmpBuffer::FreeBitmap()
{
#if ENABLE_USEFASTDIB

    if (m_hbmpBuffer != NULL) {
        DeleteObject(m_hbmpBuffer);
        m_hbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }

#else

    if (m_pgpbmpBuffer != NULL) {
        delete m_pgpbmpBuffer;
        m_pgpbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }

#endif
}


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void *
DCBmpBufferCache::Build()
{
    return ClientNew(DCBmpBuffer);
}


//------------------------------------------------------------------------------
void        
DCBmpBufferCache::DestroyObject(void * pObj)
{
    DCBmpBuffer * pbufBmp = reinterpret_cast<DCBmpBuffer *>(pObj);
    ClientDelete(DCBmpBuffer, pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void *
GpBmpBufferCache::Build()
{
    return ClientNew(GpBmpBuffer);
}


//------------------------------------------------------------------------------
void        
GpBmpBufferCache::DestroyObject(void * pObj)
{
    GpBmpBuffer * pbufBmp = reinterpret_cast<GpBmpBuffer *>(pObj);
    ClientDelete(GpBmpBuffer, pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class TrxBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* TrxBuffer::TrxBuffer
*
* TrxBuffer() constructs a new TrxBuffer object.  To create new, initialized
* TrxBuffer's, call the Build() function instead.
*
\***************************************************************************/

TrxBuffer::TrxBuffer()
{
    ZeroMemory(m_rgpsur, sizeof(m_rgpsur));
}


/***************************************************************************\
*
* TrxBuffer::~TrxBuffer
*
* ~TrxBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

TrxBuffer::~TrxBuffer()
{
    RemoveAllSurfaces();
}


/***************************************************************************\
*
* TrxBuffer::Build
*
* Build() fully initializes a new TrxBuffer object that contains several
* DxSurfaces of a common size.  These buffers are used to provide both
* input and output buffers for DirectX Transforms.
*
\***************************************************************************/

HRESULT
TrxBuffer::Build(
    IN  SIZE sizePxl,               // Size of each surface in pixels
    IN  int cSurfaces,              // Number of surfaces
    OUT TrxBuffer ** ppbufNew)      // New buffer
{
    HRESULT hr;
    TrxBuffer * pbuf = ClientNew(TrxBuffer);
    if (pbuf == NULL) {
        return E_OUTOFMEMORY;
    }

    pbuf->m_cSurfaces   = cSurfaces;
    pbuf->m_sizePxl     = sizePxl;

    for (int idx = 0; idx < cSurfaces; idx++) {
        hr = pbuf->BuildSurface(idx);
        if (FAILED(hr)) {
            ClientDelete(TrxBuffer, pbuf);
            return hr;
        }
    }

    *ppbufNew = pbuf;
    return S_OK;
}


/***************************************************************************\
*
* TrxBuffer::BuildSurface
*
* BuildSurface() internally builds a new DxSurface and assigns it in the 
* specified slot.
*
\***************************************************************************/

HRESULT
TrxBuffer::BuildSurface(
    IN  int idxSurface)             // Surface slot
{
    AssertMsg((idxSurface < m_cSurfaces) && (idxSurface >= 0), "Ensure valid index");
    AssertMsg((m_sizePxl.cx <= 4000) && (m_sizePxl.cx >= 0) &&
            (m_sizePxl.cy <= 4000) && (m_sizePxl.cy >= 0), "Ensure reasonable size");
    AssertMsg(m_rgpsur[idxSurface] == NULL, "Ensure not already created");
    HRESULT hr;
    
    DxSurface * psurNew = ClientNew(DxSurface);
    if (psurNew == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = psurNew->Create(m_sizePxl);
    if (FAILED(hr)) {
        ClientDelete(DxSurface, psurNew);
        return hr;
    }

    m_rgpsur[idxSurface] = psurNew;
    return S_OK;
}


/***************************************************************************\
*
* TrxBuffer::RemoveAllSurfaces
*
* RemoveAllSurfaces() destroys all DxSurfaces owned by the TrxBuffer.
*
\***************************************************************************/

void        
TrxBuffer::RemoveAllSurfaces()
{
    for (int idx = 0; idx < MAX_Surfaces; idx++) {
        if (m_rgpsur != NULL) {
            ClientDelete(DxSurface, m_rgpsur[idx]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\buffer.h ===
/***************************************************************************\
*
* File: Buffer.h
*
* Description:
* Buffer.h contains definitions of objects used in buffering operations, 
* including double buffering, DX-Transforms, etc.  These objects are 
* maintained by a central BufferManager that is available process-wide.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Buffer_h__INCLUDED)
#define SERVICES__Buffer_h__INCLUDED
#pragma once

#include "DxManager.h"
#include "GdiCache.h"
#include "Surface.h"

#define ENABLE_USEFASTDIB           1

class DuSurface;

/***************************************************************************\
*
* class BmpBuffer
*
* BmpBuffer abstracts out drawing using a double buffer by ensuring the 
* buffer is properly setup and is used internally inside the BufferManager 
* to manage resources.  This class provides a foundation for all bitmap 
* buffers.
*
\***************************************************************************/

class BmpBuffer
{
// Construction
public:
    virtual ~BmpBuffer() { };

            enum EDrawCmd
            {
                dcNone      = 0,        // No special processing
                dcCopyBkgnd = 1,        // Copy the destination as a background
            };

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer) PURE;
    virtual void        Fill(COLORREF cr) PURE;
    virtual void        PreEndDraw(BOOL fCommit) PURE;
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0) PURE;
    virtual void        PostEndDraw() PURE;
    virtual void        SetupClipRgn() PURE;
    virtual BOOL        InUse() const PURE;
    virtual DuSurface::EType
                        GetType() const PURE;

// Data
protected:
            SIZE        m_sizeBmp;
            POINT       m_ptDraw;
            SIZE        m_sizeDraw;
            UINT        m_nCmd;
            BOOL        m_fChangeOrg:1;
            BOOL        m_fChangeXF:1;
            BOOL        m_fClip:1;
};


/***************************************************************************\
*
* class DCBmpBuffer
*
* DCBmpBuffer implements a double-buffer for GDI.
*
\***************************************************************************/

class DCBmpBuffer : public BmpBuffer
{
// Construction
public:
            DCBmpBuffer();
    virtual ~DCBmpBuffer();

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer);
    virtual void        Fill(COLORREF cr);
    virtual void        PreEndDraw(BOOL fCommit);
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0);
    virtual void        PostEndDraw();
    virtual void        SetupClipRgn();
    virtual BOOL        InUse() const;
    virtual DuSurface::EType
                        GetType() const { return DuSurface::stDC; }

// Implementation
protected:
            BOOL        AllocBitmap(HDC hdcDraw, int cx, int cy);
            void        FreeBitmap();

// Data
protected:
            HBITMAP     m_hbmpBuffer;
            HBITMAP     m_hbmpOld;
            HPALETTE    m_hpalOld;
            HDC         m_hdcDraw;
            HDC         m_hdcBitmap;
            HRGN        m_hrgnDrawClip;
            HRGN        m_hrgnDrawOld;

            POINT       m_ptOldBrushOrg;
            int         m_nOldGfxMode;
            XFORM       m_xfOldDraw;
            XFORM       m_xfOldBitmap;
};


/***************************************************************************\
*
* class GpBmpBuffer
*
* GpBmpBuffer implements a double-buffer for GDI.
*
\***************************************************************************/

class GpBmpBuffer : public BmpBuffer
{
// Construction
public:
            GpBmpBuffer();
    virtual ~GpBmpBuffer();

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer);
    virtual void        Fill(COLORREF cr);
    virtual void        PreEndDraw(BOOL fCommit);
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0);
    virtual void        PostEndDraw();
    virtual void        SetupClipRgn();
    virtual BOOL        InUse() const;
    virtual DuSurface::EType
                        GetType() const { return DuSurface::stGdiPlus; }

// Implementation
protected:
            BOOL        AllocBitmap(Gdiplus::Graphics * pgpgr, int cx, int cy);
            void        FreeBitmap();

// Data
protected:
#if ENABLE_USEFASTDIB
    HBITMAP             m_hbmpBuffer;
    HBITMAP             m_hbmpOld;
    HDC                 m_hdcBitmap;
    BITMAPINFOHEADER    m_bmih;
    void *              m_pvBits;
#else
    Gdiplus::Bitmap *   m_pgpbmpBuffer;
#endif
    Gdiplus::Graphics * m_pgpgrBitmap;
    Gdiplus::Graphics * m_pgpgrDraw;
    Gdiplus::Region *   m_pgprgnDrawClip;
    Gdiplus::Region *   m_pgprgnDrawOld;

    Gdiplus::Matrix     m_gpmatOldDraw;
    Gdiplus::Matrix     m_gpmatOldBitmap;
};


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
* DCBmpBufferCache implements a DCBmpBuffer cache.
*
*****************************************************************************
\***************************************************************************/

class DCBmpBufferCache : public ObjectCache
{
public:
    inline  DCBmpBuffer*  Get();
    inline  void        Release(DCBmpBuffer * pbufBmp);

protected:
    virtual void *      Build();
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
* GpBmpBufferCache implements a GpBmpBuffer cache.
*
*****************************************************************************
\***************************************************************************/

class GpBmpBufferCache : public ObjectCache
{
public:
    inline  GpBmpBuffer*  Get();
    inline  void        Release(GpBmpBuffer * pbufBmp);

protected:
    virtual void *      Build();
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*
* class TrxBuffer
*
* TrxBuffer maintains a set of DxSurfaces that are used by Transitions.  The
* BufferManager will internally build these objects, as needed, for 
* Transitions.  All of the surfaces in the buffer will be the same size, as
* this is standard for Transitions.
*
\***************************************************************************/

class TrxBuffer
{
// Construction
public:
            TrxBuffer();
            ~TrxBuffer();
    static  HRESULT     Build(SIZE sizePxl, int cSurfaces, TrxBuffer ** ppbufNew);

// Operations
public:
    inline  DxSurface * GetSurface(int idxSurface) const;
    inline  SIZE        GetSize() const;

    inline  BOOL        GetInUse() const;
    inline  void        SetInUse(BOOL fInUse);

// Implementation
protected:
            HRESULT     BuildSurface(int idxSurface);
            void        RemoveAllSurfaces();

// Data
protected:
    enum {
        MAX_Surfaces = 3                // All DxTx only use 2 In and 1 Out at most
    };

    SIZE        m_sizePxl;              // Size (in pixels) of each surface
    int         m_cSurfaces;            // Number of surfaces
    DxSurface * m_rgpsur[MAX_Surfaces]; // Collection of DX surfaces
    BOOL        m_fInUse;               // Buffer is being used
};


/***************************************************************************\
*
* class BufferManager
*
* BufferManager maintains a collection of buffers of various types across 
* the entire process (including multiple threads).
*
\***************************************************************************/

class BufferManager
{
// Construction
public:
            BufferManager();
            ~BufferManager();
            void        Destroy();

// Operations
public:
    //
    // TODO: Change the implementation of these functions so that they are
    // reentrant (multi-threaded friendly).
    //

    inline  HRESULT     GetSharedBuffer(const RECT * prcInvalid, DCBmpBuffer ** ppbuf);
    inline  HRESULT     GetSharedBuffer(const RECT * prcInvalid, GpBmpBuffer ** ppbuf);
    inline  void        ReleaseSharedBuffer(BmpBuffer * pbuf);

            HRESULT     GetCachedBuffer(DuSurface::EType type, BmpBuffer ** ppbuf);
            void        ReleaseCachedBuffer(BmpBuffer * pbuf);

            HRESULT     BeginTransition(SIZE sizePxl, int cSurfaces, BOOL fExactSize, TrxBuffer ** ppbuf);
            void        EndTransition(TrxBuffer * pbufTrx, BOOL fCache);
            
            void        FlushTrxBuffers();

// Implementation
protected:
            void        RemoveAllTrxBuffers();

// Data
protected:
            //
            // TODO: Change these to be dynamically allocated and maintained across
            // multiple threads, automatically freeing resources after not used
            // for a specified timeout (perhaps 10 minutes).
            //

            // Bitmaps used by double-buffering
            DCBmpBuffer      m_bufDCBmpShared;
            GpBmpBuffer *    m_pbufGpBmpShared;
            DCBmpBufferCache m_cacheDCBmpCached;    // Cached buffers (long ownership)
            GpBmpBufferCache m_cacheGpBmpCached;    // Cached buffers (long ownership)

            // Surfaces used by Transitions
            TrxBuffer *     m_pbufTrx;
};

#include "Buffer.inl"

#endif // SERVICES__Buffer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\commanager.cpp ===
/***************************************************************************\
*
* File: ComManager.cpp
*
* Description:
* ComManager.cpp implements the process-wide COM manager used for all COM, OLE
* and Automation operations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "ComManager.h"

int                     ComManager::s_cRefs = 0;
CritLock                ComManager::s_lock;

HINSTANCE               ComManager::s_hDllCOM = NULL;
CoInitializeExProc      ComManager::s_pfnCoInit = NULL;
CoUninitializeProc      ComManager::s_pfnCoUninit = NULL;
CoCreateInstanceProc    ComManager::s_pfnCreate = NULL;
OleInitializeProc       ComManager::s_pfnOleInit = NULL;
OleUninitializeProc     ComManager::s_pfnOleUninit = NULL;
RegisterDragDropProc    ComManager::s_pfnRegisterDragDrop = NULL;
RevokeDragDropProc      ComManager::s_pfnRevokeDragDrop = NULL;
ReleaseStgMediumProc    ComManager::s_pfnReleaseStgMedium = NULL;

HINSTANCE               ComManager::s_hDllAuto = NULL;
SysAllocStringProc      ComManager::s_pfnAllocString = NULL;
SysFreeStringProc       ComManager::s_pfnFreeString = NULL;
VariantInitProc         ComManager::s_pfnVariantInit = NULL;
VariantClearProc        ComManager::s_pfnVariantClear = NULL;


//------------------------------------------------------------------------------
ComManager::ComManager()
{
    m_fInitCOM = FALSE;
    m_fInitOLE = FALSE;

    s_lock.Enter();

    s_cRefs++;

    s_lock.Leave();
}


//------------------------------------------------------------------------------
ComManager::~ComManager()
{
    s_lock.Enter();

    if ((s_pfnOleUninit != NULL) && m_fInitOLE) {
        (s_pfnOleUninit)();
    }

    if ((s_pfnCoUninit != NULL) && m_fInitCOM) {
        (s_pfnCoUninit)();
    }

    AssertMsg(s_cRefs > 0, "Must have at least one outstanding reference");
    if (--s_cRefs == 0) {
        if (s_hDllAuto != NULL) {
            FreeLibrary(s_hDllAuto);
            s_hDllAuto = NULL;
        }

        if (s_hDllCOM != NULL) {
            FreeLibrary(s_hDllCOM);
            s_hDllCOM  = NULL;
        }

        s_pfnCoInit         = NULL;
        s_pfnCoUninit       = NULL;
        s_pfnCreate         = NULL;

        s_pfnOleInit        = NULL;
        s_pfnOleUninit      = NULL;
        s_pfnRegisterDragDrop = NULL;
        s_pfnRevokeDragDrop = NULL;
        s_pfnReleaseStgMedium = NULL;

        s_pfnAllocString    = NULL;
        s_pfnFreeString     = NULL;
        s_pfnVariantInit    = NULL;
        s_pfnVariantClear   = NULL;
    }

    s_lock.Leave();
}


//------------------------------------------------------------------------------
BOOL
ComManager::Init(UINT nMask)
{
    BOOL fSuccess = TRUE;

    s_lock.Enter();

    if (TestFlag(nMask, sAuto)) {
        // OLE-Automation need COM.
        SetFlag(nMask, sCOM);
    }

    if (TestFlag(nMask, sCOM | sOLE)) {
        //
        // Load the DLL
        //

        if (s_hDllCOM == NULL) {
            s_hDllCOM = LoadLibrary(_T("ole32.dll"));
            if (s_hDllCOM == NULL) {
                fSuccess = FALSE;
                goto errorexit;
            }

            s_pfnCoInit         = (CoInitializeExProc)  GetProcAddress(s_hDllCOM, _T("CoInitializeEx"));
            s_pfnCoUninit       = (CoUninitializeProc)  GetProcAddress(s_hDllCOM, _T("CoUninitialize"));
            s_pfnCreate         = (CoCreateInstanceProc)GetProcAddress(s_hDllCOM, _T("CoCreateInstance"));

            s_pfnOleInit        = (OleInitializeProc)   GetProcAddress(s_hDllCOM, _T("OleInitialize"));
            s_pfnOleUninit      = (OleUninitializeProc) GetProcAddress(s_hDllCOM, _T("OleUninitialize"));

            s_pfnRegisterDragDrop = (RegisterDragDropProc) GetProcAddress(s_hDllCOM, _T("RegisterDragDrop"));
            s_pfnRevokeDragDrop = (RevokeDragDropProc)  GetProcAddress(s_hDllCOM, _T("RevokeDragDrop"));
            s_pfnReleaseStgMedium = (ReleaseStgMediumProc) GetProcAddress(s_hDllCOM, _T("ReleaseStgMedium"));

            if ((s_pfnCoInit == NULL) || (s_pfnCoUninit == NULL) || (s_pfnCreate == NULL) || 
                (s_pfnOleInit == NULL) || (s_pfnOleUninit == NULL) ||
                (s_pfnRegisterDragDrop == NULL) || (s_pfnRevokeDragDrop == NULL) || 
                (s_pfnReleaseStgMedium == NULL)) {

                fSuccess = FALSE;
                goto errorexit;
            }
        }


        //
        // Start COM / OLE
        //

        if (TestFlag(nMask, sCOM) && (!m_fInitCOM)) {
            // UI threads can not be free-threaded, so use apartment.
            HRESULT hr = (s_pfnCoInit)(NULL, COINIT_APARTMENTTHREADED);
            if (FAILED(hr)) {
                fSuccess = FALSE;
                goto errorexit;
            }

            m_fInitCOM = TRUE;
        }

        if (TestFlag(nMask, sOLE) && (!m_fInitOLE)) {
            HRESULT hr = (s_pfnOleInit)(NULL);
            if (FAILED(hr)) {
                fSuccess = FALSE;
                goto errorexit;
            }

            m_fInitOLE = TRUE;
        }
    }

    if (TestFlag(nMask, sAuto) && (s_hDllAuto == NULL)) {
        s_hDllAuto = LoadLibrary(_T("oleaut32.dll"));
        if (s_hDllAuto == NULL) {
            fSuccess = FALSE;
            goto errorexit;
        }

        s_pfnAllocString    = (SysAllocStringProc)  GetProcAddress(s_hDllAuto, _T("SysAllocString"));
        s_pfnFreeString     = (SysFreeStringProc)   GetProcAddress(s_hDllAuto, _T("SysFreeString"));
        s_pfnVariantInit    = (VariantInitProc)     GetProcAddress(s_hDllAuto, _T("VariantInit"));
        s_pfnVariantClear   = (VariantClearProc)    GetProcAddress(s_hDllAuto, _T("VariantClear"));

        if ((s_pfnAllocString == NULL) || (s_pfnFreeString == NULL) || 
                (s_pfnVariantInit == NULL) || (s_pfnVariantClear == NULL)) {

            fSuccess = FALSE;
            goto errorexit;
        }
    }

errorexit:
    s_lock.Leave();

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL    
ComManager::IsInit(UINT nMask) const
{
    if (TestFlag(nMask, sCOM) && (s_hDllCOM != NULL) && m_fInitCOM) {
        return TRUE;
    }

    if (TestFlag(nMask, sOLE) && (s_hDllCOM != NULL) && m_fInitOLE) {
        return TRUE;
    }

    if (TestFlag(nMask, sAuto) && (s_hDllAuto != NULL)) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\commanager.h ===
/***************************************************************************\
*
* File: ComManager.h
*
* Description:
* ComManager.h defines the process-wide COM manager used for all COM, OLE
* and Automation operations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ComManager_h__INCLUDED)
#define SERVICES__ComManager_h__INCLUDED
#pragma once

/***************************************************************************\
*
* class ComManager
*
* ComManager manages COM services including COM, OLE, and Automation.  This 
* class is designed to be "per-thread", automatically shared data across 
* multiple threads.
* 
* NOTE: This manager is delay-loads DLL's to manage performance and work on
* down-level platforms.
*
\***************************************************************************/

typedef HRESULT (WINAPI * CoInitializeExProc)(void * pvReserved, DWORD dwCoInit);
typedef void    (WINAPI * CoUninitializeProc)();
typedef HRESULT (WINAPI * CoCreateInstanceProc)(REFCLSID rclsid, LPUNKNOWN punkOuter,
        DWORD dwClsContext, REFIID ridd, LPVOID * ppv);

typedef HRESULT (WINAPI * OleInitializeProc)(LPVOID * pvReserved);
typedef void    (WINAPI * OleUninitializeProc)();
typedef HRESULT (WINAPI * RegisterDragDropProc)(HWND hwnd, IDropTarget * pDropTarget);
typedef HRESULT (WINAPI * RevokeDragDropProc)(HWND hwnd);
typedef void    (WINAPI * ReleaseStgMediumProc)(STGMEDIUM * pstg);

typedef BSTR    (WINAPI * SysAllocStringProc)(const OLECHAR * psz);
typedef HRESULT (WINAPI * SysFreeStringProc)(BSTR bstr);
typedef HRESULT (WINAPI * VariantInitProc)(VARIANTARG * pvarg); 
typedef HRESULT (WINAPI * VariantClearProc)(VARIANTARG * pvarg);

class ComManager
{
// Construction
public:
                ComManager();
                ~ComManager();

// Operations
public:
    enum EServices
    {
        sCOM    = 0x00000001,       // COM
        sAuto   = 0x00000002,       // OLE-Automation
        sOLE    = 0x00000004,       // OLE2
    };

    BOOL        Init(UINT nMask);

    BOOL        IsInit(UINT nMask) const;

    HRESULT     CreateInstance(REFCLSID rclsid, IUnknown * punkOuter, REFIID riid, void ** ppv);

    BSTR        SysAllocString(const OLECHAR * psz);
    HRESULT     SysFreeString(BSTR bstr);
    HRESULT     VariantInit(VARIANTARG * pvarg); 
    HRESULT     VariantClear(VARIANTARG * pvarg);

    HRESULT     RegisterDragDrop(HWND hwnd, IDropTarget * pDropTarget);
    HRESULT     RevokeDragDrop(HWND hwnd);
    void        ReleaseStgMedium(STGMEDIUM * pstg);

// Data
protected:
    //
    // Shared data that is process wide- only need to load the DLL's once.
    //

    static  int                     s_cRefs;
    static  CritLock                s_lock;

    static  HINSTANCE               s_hDllCOM;      // Core "COM" / OLE
    static  CoInitializeExProc      s_pfnCoInit;
    static  CoUninitializeProc      s_pfnCoUninit;
    static  CoCreateInstanceProc    s_pfnCreate;
    static  OleInitializeProc       s_pfnOleInit;
    static  OleUninitializeProc     s_pfnOleUninit;
    static  RegisterDragDropProc    s_pfnRegisterDragDrop;
    static  RevokeDragDropProc      s_pfnRevokeDragDrop;
    static  ReleaseStgMediumProc    s_pfnReleaseStgMedium;

    static  HINSTANCE               s_hDllAuto;     // OLE-automation
    static  SysAllocStringProc      s_pfnAllocString;
    static  SysFreeStringProc       s_pfnFreeString;
    static  VariantInitProc         s_pfnVariantInit;
    static  VariantClearProc        s_pfnVariantClear;


    //
    // Specific data that is "per-thread"- need to initialize COM / OLE on each
    // thread.
    //

            BOOL                    m_fInitCOM:1;
            BOOL                    m_fInitOLE:1;
};

#include "ComManager.inl"

#endif // SERVICES__ComManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\commanager.inl ===
#if !defined(SERVICES__ComManager_inl__INCLUDED)
#define SERVICES__ComManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline HRESULT
ComManager::CreateInstance(REFCLSID rclsid, IUnknown * punkOuter, REFIID riid, void ** ppv)
{
    AssertMsg(IsInit(sCOM), "Must be successfully initialized before calling");
    return (s_pfnCreate)(rclsid, punkOuter, CLSCTX_INPROC, riid, ppv);
}


//------------------------------------------------------------------------------
inline BSTR
ComManager::SysAllocString(const OLECHAR * psz)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnAllocString)(psz);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::SysFreeString(BSTR bstr)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnFreeString)(bstr);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::VariantInit(VARIANTARG * pvarg)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnVariantInit)(pvarg);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::VariantClear(VARIANTARG * pvarg)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnVariantClear)(pvarg);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::RegisterDragDrop(HWND hwnd, IDropTarget * pDropTarget)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    return (s_pfnRegisterDragDrop)(hwnd, pDropTarget);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::RevokeDragDrop(HWND hwnd)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    return (s_pfnRevokeDragDrop)(hwnd);
}


//------------------------------------------------------------------------------
inline void
ComManager::ReleaseStgMedium(STGMEDIUM * pstg)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    (s_pfnReleaseStgMedium)(pstg);
}


#endif // SERVICES__ComManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\context.h ===
/***************************************************************************\
*
* File: Context.h
*
* Description:
* This file declares the main Context used by the ResourceManager to manage
* independent "work contexts".
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Context_h__INCLUDED)
#define SERVICES__Context_h__INCLUDED
#pragma once

class Context;
class SubContext;
class ContextPackBuilder;

#if DBG
class Thread;
#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* Context defines a pool of threads that can shared objects between the 
* threads.  Inside DirectUser, only one thread is allowed to execute within 
* the context at a time UNLESS IT IS AN "NL" function.  By dividing the
* process into independent Context's, threads that are mostly unrelated can
* operate without colliding over shared locks.
*
* Context objects are not created until the application explicitly calls
* InitGadgets().  They can also be destroyed if the application calls
* ::DeleteHandle() on the HDCONTEXT.  This means that a thread may or may not
* have a Context, though usually it will.
*
*****************************************************************************
\***************************************************************************/

class Context : public BaseObject
{
public:
            Context();
            ~Context();
    static  HRESULT     Build(INITGADGET * pInit, DUserHeap * pHeap, Context ** ppctxNew);
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();
public:
            void        xwPreDestroyNL();

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htContext; }
    virtual UINT        GetHandleMask() const { return 0; }

// Operations
public:
    enum ESlot {
        slCore          = 0,            // Core
        slMotion,                       // Motions
        slCOUNT,                        // Number of sub-contexts
    };

    inline  void        MarkOrphaned();
    inline  BOOL        IsOrphanedNL() const;

    inline  void        Enter();        // Take shared Context lock
    inline  void        Leave();        // Release shared Context lock
    inline  void        Leave(BOOL fOldEnableDefer, BOOL * pfPending);

#if DBG_CHECK_CALLBACKS
    inline  void        BeginCallback();
    inline  void        EndCallback();
#endif    

    inline  void        BeginReadOnly();
    inline  void        EndReadOnly();
    inline  BOOL        IsReadOnly() const;
    inline  UINT        GetThreadMode() const;
    inline  UINT        GetPerfMode() const;

    inline  DUserHeap * GetHeap() const;
    inline  SubContext* GetSC(ESlot slot) const;
            void        AddCurrentThread();

    inline  BOOL        IsEnableDefer() const;
    inline  void        EnableDefer(BOOL fEnable, BOOL * pfOld);
    inline  void        MarkPending();

            DWORD       xwOnIdleNL();       // Idle time processing


#if DBG_CHECK_CALLBACKS
            int         m_cLiveObjects;     // Live objects outstanding
            int         m_cTotalObjects;    // Total objects allocated
#endif

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
#if DBG
            Thread *    m_DEBUG_pthrLock; // DEBUG: Thread that locked Context
            DWORD       m_DEBUG_tidLock;// Thread ID of thread that locks
#endif // DBG
            long        m_cEnterLock;   // Count of outstanding Enter()'s
#if DBG_CHECK_CALLBACKS
            int         m_cLiveCallbacks; // Outstanding callbacks
#endif            
            CritLock    m_lock;         // Shared access lock
            DUserHeap * m_pHeap;        // Initialized heap
            UINT        m_cReadOnly;    // Count of pending "read-only" operations
            BOOL        m_fPending;     // Deferred callbacks are pending (GIVE THIS A FULL BOOL)
            BOOL        m_fEnableDefer:1; // Enabled deferred messages
            BOOL        m_fPreDestroy:1;// Have pre-destroyed the Context
            BOOL        m_fOrphaned:1;  // Context has been orphaned
            UINT        m_nThreadMode;  // Threading model for Context
            UINT        m_nPerfMode;    // Performance model

            SubContext* m_rgSCs[slCOUNT];   // Sub-context information
};


/***************************************************************************\
*****************************************************************************
*
* SubContext defines a "extensibility" mechanism that allows individual
* projects in DirectUser to provide additional data to store on the context.
* To use this, the project must add a new slot in Context, derive a class
* from SubContext that is created per Context instance, and derive a class
* from ContextPackBuilder to register the extension.
*
*****************************************************************************
\***************************************************************************/

class SubContext
{
// Construction
public:
    virtual ~SubContext() { }
    virtual HRESULT     Create(INITGADGET * pInit) { UNREFERENCED_PARAMETER(pInit); return S_OK; }
    virtual void        xwPreDestroyNL() PURE;

// Operations
public:
    inline  void        SetParent(Context * pParent);

    virtual DWORD       xwOnIdleNL() { return INFINITE; }

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
            Context *   m_pParent;
};


/***************************************************************************\
*****************************************************************************
*
* ContextPackBuilder registers an SubContext "extension" to be created 
* whenever a new Context is created.  The constructor is expected to set the
* slot corresponding to the ESlot value.
*
*****************************************************************************
\***************************************************************************/

class ContextPackBuilder
{
// Construction
public:

// Operations
public:
    virtual SubContext* New(Context * pContext) PURE;
    static  inline ContextPackBuilder *
                        GetBuilder(Context::ESlot slot);

// Data
protected:
    static  ContextPackBuilder * 
                        s_rgBuilders[Context::slCOUNT];
};


#define IMPLEMENT_SUBCONTEXT(id, obj)                       \
    class obj##Builder : public ContextPackBuilder          \
    {                                                       \
    public:                                                 \
        virtual SubContext * New(Context * pParent)         \
        {                                                   \
            SubContext * psc = ProcessNew(obj);             \
            if (psc != NULL) {                              \
                psc->SetParent(pParent);                    \
            }                                               \
            return psc;                                     \
        }                                                   \
    } g_##obj##B                                            \

#define PREINIT_SUBCONTEXT(obj)                             \
    class obj##Builder;                                     \
    extern obj##Builder g_##obj##B                          \

#define INIT_SUBCONTEXT(obj)                                \
    (ContextPackBuilder *) &g_##obj##B                      \
    


inline  Context *   GetContext();
inline  BOOL        IsInitContext();

/***************************************************************************\
*****************************************************************************
*
* ContextLock provides a convenient mechanism of locking the Context and
* automatically unlocking when finished.  Because ContextLock perform 
* additional Context-specific actions, it is important to use a ContextLock 
* to lock a Context instead of using an ObjectLock.
*
*****************************************************************************
\***************************************************************************/

class ContextLock
{
public:
    enum EnableDefer
    {
        edNone  = FALSE,        // Enabled deferred messages
        edDefer = TRUE,         // Don't enable deferred messages
    };

    inline  ContextLock();
    inline  ~ContextLock();

            BOOL    LockNL(ContextLock::EnableDefer ed, Context * pctxThread = GetContext());

// Data (public access)
            Context *   pctx;
            BOOL        fOldDeferred;
};


class ReadOnlyLock
{
public:
    inline  ReadOnlyLock(Context * pctxThread = GetContext());
    inline  ~ReadOnlyLock();

    Context *   pctx;
};


#if DBG_CHECK_CALLBACKS

#define BEGIN_CALLBACK()                \
    __try {                             \
        if (!IsInitThread()) {          \
            AlwaysPromptInvalid("DirectUser has been uninitialized before processing a callback (1)"); \
        }                               \
        GetContext()->BeginCallback();  \
        

#define END_CALLBACK()                  \
    } __finally {                       \
        GetContext()->EndCallback();    \
        if (!IsInitThread()) {          \
            AlwaysPromptInvalid("DirectUser has been uninitialized while processing a Message (2)"); \
        }                               \
    }

#endif // DBG_CHECK_CALLBACKS

#include "Context.inl"

#endif // SERVICES__Context_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\context.cpp ===
/***************************************************************************\
*
* File: Context.cpp
*
* Description:
* This file implements the main Context used by the ResourceManager to manage
* independent "work contexts".
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Context.h"

#include "Thread.h"
#include "ResourceManager.h"

#if !USE_DYNAMICTLS
__declspec(thread) Context * t_pContext;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Context
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Context::Context()
{
    //
    // Immediately attach this Context to the Thread object.  This is required
    // because creation of the Context may need the Thread (for example, to
    // create the Parking Container).  If something fails during Context 
    // creation or later, the new Thread will be unlocked, destroying this new
    // Context with it.
    //
    
    GetThread()->SetContext(this);

#if DBG
    m_DEBUG_pthrLock = NULL;
#endif // DBG
}


//------------------------------------------------------------------------------
Context::~Context()
{
#if DBG_CHECK_CALLBACKS
    if (m_cLiveCallbacks > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Can not destroy a Context while inside a callback");
    }
#endif    

    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    //
    // First, tear down the sub-contexts since they may rely on shared resources
    // such as the heap.
    //
    // NOTE: We need to destroy the SubContext's in multiple stages so that they
    // can refer to each other during destruction.  This provides an opportunity
    // for any callbacks to occur during the "pre-destroy" stage.  We 
    // temporarily need to increment the lock count while we pre-destroy the 
    // SubContext's because they may callback.  During these callbacks, the 
    // application may call API's to cleanup objects in the Context.
    //

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSCs[idx] != NULL) {
            ProcessDelete(SubContext, m_rgSCs[idx]);
            m_rgSCs[idx] = NULL;
        }
    }


#if DBG_CHECK_CALLBACKS
    if (m_cLiveObjects > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Outstanding DirectUser objects after Context shutdown");
    }
#endif    


    //
    // Tear down low-level resources (such as the heap)
    //

    if (m_pHeap != NULL) {
        DestroyContextHeap(m_pHeap);
    }


    //
    // Finally, detach this Context from the Thread.  This must be done here
    // since the Context is created in Context::Build() and must be fully
    // detached from the Thread if any stage of construction fails.
    //

    GetThread()->SetContext(NULL);
}


/***************************************************************************\
*
* Context::xwDestroy
*
* xwDestroy() is called to finally delete the object.
*
\***************************************************************************/

void        
Context::xwDestroy()
{
    ProcessDelete(Context, this);
}


/***************************************************************************\
*
* Context::xwPreDestroyNL
*
* xwPreDestroyNL() is called by a Thread when the Context is about to be 
* destroyed, but before the SubTreads have been destroyed.
*
\***************************************************************************/

void
Context::xwPreDestroyNL()
{
    AssertMsg(m_cRef == 0, "Locks must initially be at 0 to be destroyed");
    m_cRef++;

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSCs[idx] != NULL) {
            m_rgSCs[idx]->xwPreDestroyNL();
        }
    }

    m_cRef--;
    AssertMsg(m_cRef == 0, "Locks should be 0 after callbacks");
}


/***************************************************************************\
*
* Context::Build
*
* Build() creates a new, fully initialized Context instance.
*
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
* <error>   E_OUTOFMEMORY</>
* <error>   E_NOTIMPL</>
* <error>   E_INVALIDARG</>
*
\***************************************************************************/

HRESULT
Context::Build(
    IN  INITGADGET * pInit,             // Context description
    IN  DUserHeap * pHeap,              // Context heap to use
    OUT Context ** ppctxNew)            // Newly created Context
{
#if USE_DYNAMICTLS
    AssertMsg(!IsInitContext(), "Only call on uninitialized Context's");
#else
    AssertMsg(t_pContext == NULL, "Only call on uninitialized Context's");
#endif

    Context * pContext  = NULL;
    HRESULT hr          = E_INVALIDARG;

    //
    // Create a new Context and initialize low-level resources that other
    // initialization requires (such as a heap).
    //

    pContext = ProcessNew(Context);
    if (pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    AssertMsg(pHeap != NULL, "Must specify a valid heap");
    pContext->m_pHeap       = pHeap;
    pContext->m_nThreadMode = pInit->nThreadMode;
    pContext->m_nPerfMode   = pInit->nPerfMode;
    if ((pContext->m_nPerfMode == IGPM_BLEND) && IsRemoteSession()) {
        //
        // For "blend" models, if we are running as a TS session, optimize for
        // size.
        //

        pContext->m_nPerfMode = IGPM_SIZE;
    }

    BOOL fThreadSafe;
    switch (pInit->nThreadMode)
    {
    case IGTM_SINGLE:
    case IGTM_SEPARATE:
        fThreadSafe = FALSE;
        break;

    default:
        fThreadSafe = TRUE;
    }

    pContext->m_lock.SetThreadSafe(fThreadSafe);


    //
    // Initialize each of the sub-contexts.  These can safely use the heap
    // which has already been initialized.  We need to grab a ContextLock 
    // during this since we may make callbacks during construction of a 
    // Context.
    //

#if !USE_DYNAMICTLS
    t_pContext = pContext;  // SubContext's may need to grab the Context
#endif
    {
        ContextLock cl;
        Verify(cl.LockNL(ContextLock::edDefer, pContext));

        for (int idx = 0; idx < slCOUNT; idx++) {
            ContextPackBuilder * pBuilder = ContextPackBuilder::GetBuilder((Context::ESlot) idx);
            AssertMsg(pBuilder != NULL, "Builder not initialized using INIT_SUBCONTEXT");
            pContext->m_rgSCs[idx] = pBuilder->New(pContext);
            if (pContext->m_rgSCs[idx] == NULL) {
                hr = E_OUTOFMEMORY;
                goto ErrorExit;
            }

            hr = pContext->m_rgSCs[idx]->Create(pInit);
            if (FAILED(hr)) {
#if !USE_DYNAMICTLS
                t_pContext = NULL;
#endif
                goto ErrorExit;
            }
        }
    }

    AssertMsg(pContext != NULL, "Ensure Context is valid");

    *ppctxNew = pContext;
    return S_OK;

ErrorExit:
    AssertMsg(FAILED(hr), "Must specify failure");


    //
    // Something went wrong while creating a new context, so need to tear it 
    // down.
    //
    // NOTE: We CAN NOT use xwUnlock() or xwDeleteHandle(), since these are
    // intercepted and would go through the ResourceManager.  Instead, we need
    // bump down the ref count, pre-destroy the Context, and delete it.
    //

    if (pContext != NULL) {
        VerifyMsg(--pContext->m_cRef == 0, "Should only have initial reference");
        pContext->xwPreDestroyNL();

        ProcessDelete(Context, pContext);
    }
    *ppctxNew = NULL;

    return hr;
}


/***************************************************************************\
*
* Context::xwDeleteHandle
*
* xwDeleteHandle() is called from ::DeleteHandle() to destroy an object and 
* free its associated resources.  This function must be called on the same 
* thread as originally created the Context so that the corresponding Thread 
* object can also be destroyed.
*
\***************************************************************************/

BOOL
Context::xwDeleteHandle()
{
#if DBG
    AssertMsg(IsInitThread(), "Thread must be initialized to destroy the Context");
    Context * pctxThread = GetThread()->GetContext();
    AssertMsg(pctxThread == this, "Thread currently running on should match the Context being destroyed");
#endif // DBG


#if DBG_CHECK_CALLBACKS
    if (m_cLiveCallbacks > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Can not DeleteHandle(Context) while inside a callback");
    }
#endif    

    //
    // We have NOT taken a ContextLock when calling DeleteHandle() on the 
    // Context.  Therefore, we are actually an NL function, but the virtual
    // function can't be renamed.
    //

    ResourceManager::xwNotifyThreadDestroyNL();

    return FALSE;
}


/***************************************************************************\
*
* Context::AddCurrentThread
*
* AddCurrentThread() sets the current thread to use the specified Context.
* 
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
\***************************************************************************/

void        
Context::AddCurrentThread()
{
#if USE_DYNAMICTLS
    AssertMsg(!IsInitContext(), "Ensure Context is not already set");
#else
    AssertMsg(t_pContext == NULL, "Ensure Context is not already set");
#endif

    GetThread()->SetContext(this);
}


/***************************************************************************\
*
* Context::xwOnIdleNL
*
* xwOnIdleNL() cycles through all of the SubContext's, giving each an 
* opportunity to perform any idle-time processing.  This is time when there 
* are no more messages to process.  Each SubContext can also return a 
* "delay" count that specifies how long it will have before more processing.
* 
\***************************************************************************/

DWORD
Context::xwOnIdleNL()
{
    DWORD dwTimeOut = INFINITE;
    AssertMsg(dwTimeOut == 0xFFFFFFFF, "Ensure largest delay");

    for (int idx = 0; idx < slCOUNT; idx++) {
        DWORD dwNewTimeOut = m_rgSCs[idx]->xwOnIdleNL();
        if (dwNewTimeOut < dwTimeOut) {
            dwTimeOut = dwNewTimeOut;
        }
    }

    return dwTimeOut;
}


#if DBG

//------------------------------------------------------------------------------
void
Context::DEBUG_AssertValid() const
{
    if (IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        AssertMsg(0, "API layer let an Orphaned Context in");
    }
    
    if (m_DEBUG_tidLock != 0) {
        Assert(m_DEBUG_pthrLock != NULL);
    }

    Assert(m_pHeap != NULL);

    for (int idx = 0; idx < slCOUNT; idx++) {
        AssertInstance(m_rgSCs[idx]);
    }
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ContextPackBuilder
*
*****************************************************************************
\***************************************************************************/

PREINIT_SUBCONTEXT(CoreSC);
PREINIT_SUBCONTEXT(MotionSC);

ContextPackBuilder * ContextPackBuilder::s_rgBuilders[Context::slCOUNT] =
{
    INIT_SUBCONTEXT(CoreSC),
    INIT_SUBCONTEXT(MotionSC),
};


/***************************************************************************\
*****************************************************************************
*
* class SubContext
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void
SubContext::DEBUG_AssertValid() const
{
    // Don't use AssertInstance since it would be recursive.
    Assert(m_pParent != NULL);
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ContextLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL
ContextLock::LockNL(ContextLock::EnableDefer ed, Context * pctxThread)
{
    AssertMsg(pctx == NULL, "Can only Lock() once");
    AssertMsg(pctxThread != NULL, "Must specify a valid Context to lock");


    //
    // Check if the Context has been orphaned __before__ entering the lock so 
    // that we access as few members as possible.
    //
    
    if (pctxThread->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        return FALSE;
    }

    pctx = pctxThread;
    pctx->Enter();
    pctx->EnableDefer(ed, &fOldDeferred);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\dxmanager.h ===
/***************************************************************************\
*
* File: DxManager.h
*
* Description:
* DxManager.h defines the process-wide DirectX manager used for all 
* DirectDraw, Direct3D, and DirectX Transforms services.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__DXManager_h__INCLUDED)
#define SERVICES__DXManager_h__INCLUDED
#pragma once

#pragma comment(lib, "dxguid.lib")  // Include DirectX GUID's

struct IDirectDraw;
struct IDXTransformFactory;
struct IDXSurfaceFactory;
struct IDXSurface;

typedef HRESULT (WINAPI * DirectDrawCreateProc)(GUID * pguid, IDirectDraw ** ppDD, IUnknown * punkOuter);
typedef HRESULT (WINAPI * DirectDrawCreateExProc)(GUID * pguid, void ** ppvDD, REFIID iid, IUnknown * punkOuter);

class DxSurface;

/***************************************************************************\
*
* class DxManager
*
* DxManager maintains interaction with DirectX technologies including:
* - DirectDraw
* - Direct3D
* - DirectTransforms
*
* By using this class instead of directly accessing DX, bettern coordination
* is maintained throughout SERVICES.
*
* NOTE: This manager is delay-loads DLL's to manage performance and work on
* down-level platforms.
*
\***************************************************************************/

class DxManager
{
// Construction
public:
            DxManager();
            ~DxManager();

// Operations
public:
            HRESULT     Init(GUID * pguidDriver = NULL);
            void        Uninit();
    inline  BOOL        IsInit() const;

            HRESULT     InitDxTx();
            void        UninitDxTx();
    inline  BOOL        IsDxTxInit() const;

    inline  IDXTransformFactory *   GetTransformFactory() const;
    inline  IDXSurfaceFactory *     GetSurfaceFactory() const;

            HRESULT     BuildSurface(SIZE sizePxl, IDirectDrawSurface7 * pddSurfNew);
            HRESULT     BuildDxSurface(SIZE sizePxl, REFGUID guidFormat, IDXSurface ** ppdxSurfNew);

// Data
protected:
    // DirectDraw
    UINT                    m_cDDrawRef;
    HINSTANCE               m_hDllDxDraw;   // DirectDraw DLL
    DirectDrawCreateProc    m_pfnCreate;
    DirectDrawCreateExProc  m_pfnCreateEx;
    IDirectDraw *           m_pDD;
    IDirectDraw7 *          m_pDD7;

    // DX Transforms
    UINT                    m_cDxTxRef;
    IDXTransformFactory *   m_pdxXformFac;
    IDXSurfaceFactory   *   m_pdxSurfFac;
};


/***************************************************************************\
*
* class DxSurface
*
* DxSurface maintains a single DXTX Surface.
*
\***************************************************************************/

class DxSurface
{
// Construction
public:
            DxSurface();
            ~DxSurface();
            HRESULT     Create(SIZE sizePxl);

// Operations
public:
    inline  IDXSurface* GetSurface() const;
            BOOL        CopyDC(HDC hdcSrc, const RECT & rcCrop);
            BOOL        CopyBitmap(HBITMAP hbmpSrc, const RECT * prcCrop);
    inline  SIZE        GetSize() const;

// Implementation
protected:
            BOOL        FixAlpha();

// Data
protected:
    IDXSurface *    m_pdxSurface;
    SIZE            m_sizePxl;      // (Cached) size of surface in pixels
    GUID            m_guidFormat;   // (Cached) format of the surface
    DXSAMPLEFORMATENUM  m_sf;       // Sample Format
};

#include "DxManager.inl"

#endif // SERVICES__DXManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\fastdib.cpp ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include "stdafx.h"
#include <Services.h>

#include "FastDib.h"

static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY
CreateCompatibleDIB(
    IN  HDC hdc, 
    IN  HPALETTE hpal, 
    IN  ULONG ulWidth, 
    IN  ULONG ulHeight,
    OUT PVOID *ppvBits, 
    OUT BITMAPINFOHEADER * pbmih)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        Trace("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    ZeroMemory(aj, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;


        if (pbmih != NULL) {
            DWORD cbSize = min(pbmih->biSize, pbmi->bmiHeader.biSize);
            CopyMemory(pbmih, &pbmi->bmiHeader, cbSize);
            pbmih->biSize = cbSize;
        }
        

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

        if ( !hbmRet )
        {
            Trace("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        Trace("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        Trace("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        Trace("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = (HBITMAP) GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;

        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                Trace("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            Trace("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        Trace("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                Trace("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((BYTE *) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        Trace("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        Trace("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        Trace("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = (HBITMAP) GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        Trace("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        Trace("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            Trace("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ((hpalSurf = CreatePalette(ppal)) != NULL)
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            Trace("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        Trace("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\dxmanager.inl ===
/***************************************************************************\
*
* File: DxManager.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__DxManager_inl__INCLUDED)
#define SERVICES__DxManager_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DxManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL        
DxManager::IsInit() const
{
    return m_hDllDxDraw != NULL;
}


//------------------------------------------------------------------------------
inline BOOL        
DxManager::IsDxTxInit() const
{
    return m_pdxXformFac != NULL;
}


//------------------------------------------------------------------------------
inline IDXTransformFactory *   
DxManager::GetTransformFactory() const
{
    AssertMsg(IsDxTxInit(), "DxTx must first be initialized");
    AssertMsg(m_pdxXformFac != NULL, "Should have valid TxF");

    return m_pdxXformFac;
}


//------------------------------------------------------------------------------
inline IDXSurfaceFactory *     
DxManager::GetSurfaceFactory() const
{
    AssertMsg(IsDxTxInit(), "DxTx must first be initialized");
    AssertMsg(m_pdxSurfFac != NULL, "Should have valid SxF");

    return m_pdxSurfFac;
}


/***************************************************************************\
*****************************************************************************
*
* class DxSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  IDXSurface *    
DxSurface::GetSurface() const
{
    Assert(m_pdxSurface != NULL);
    return m_pdxSurface;
}


//------------------------------------------------------------------------------
inline SIZE
DxSurface::GetSize() const
{
    return m_sizePxl;
}


#endif // SERVICES__DxManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\dxmanager.cpp ===
/***************************************************************************\
*
* File: DxManager.cpp
*
* Description:
* DxManager.cpp implements the process-wide DirectX manager used for all 
* DirectDraw, Direct3D, and DirectX Transforms services.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "DxManager.h"

#include "GdiCache.h"
#include "Buffer.h"
#include "ResourceManager.h"

/***************************************************************************\
*****************************************************************************
*
* class DxManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxManager::DxManager()
{
    m_cDDrawRef = 0;
    m_cDxTxRef  = 0;
}


//------------------------------------------------------------------------------
DxManager::~DxManager()
{
#if DBG
    if (m_hDllDxDraw != NULL) {
        Trace("DUser Warning: Application did not call UninitGadgetComponent() to\n");
        Trace("    deinitialize properly\n");
    }
#endif // DBG
}


/***************************************************************************\
*
* DxManager::Init
*
* Init() initializes the DxManager by loading COM and core DirectX services.
*
\***************************************************************************/

HRESULT    
DxManager::Init(GUID * pguidDriver)
{
    if (m_hDllDxDraw == NULL) {
        //
        // Normal DirectDraw does not need COM to be initialized.
        //

        m_hDllDxDraw = LoadLibrary("ddraw.dll");
        if (m_hDllDxDraw == NULL) {
            return DU_E_GENERIC;
        }
    
        //
        // Load the functions.
        //
        // NOTE: On older versions of DirectDraw, DirectDrawCreateEx() doesn't
        // exist.  We need to specifically check this.
        //

        m_pfnCreate     = (DirectDrawCreateProc)    GetProcAddress(m_hDllDxDraw, _T("DirectDrawCreate"));
        m_pfnCreateEx   = (DirectDrawCreateExProc)  GetProcAddress(m_hDllDxDraw, _T("DirectDrawCreateEx"));

        if (m_pfnCreate == NULL) {
            goto errorexit;
        }

        //
        // First, try creating the most advance interface.
        //
        HRESULT hr;

        if (m_pfnCreateEx != NULL) {
            hr = (m_pfnCreateEx)(pguidDriver, (void **) &m_pDD7, IID_IDirectDraw7, NULL);
            if (SUCCEEDED(hr)) {
                AssertReadPtr(m_pDD7);

                m_pDD7->SetCooperativeLevel(NULL, DDSCL_NORMAL);

                //
                // Try to get an IDirectDraw interface as well.
                //

                m_pDD7->QueryInterface(IID_IDirectDraw, (void **) &m_pDD);


                {
                    HRESULT hRet;
                    DDSURFACEDESC2 ddsd;
                    IDirectDrawSurface7 * pDD;

                    ZeroMemory(&ddsd, sizeof(ddsd));
                    ddsd.dwSize = sizeof(ddsd);
                    ddsd.dwFlags = DDSD_CAPS;
                    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
                    hRet = m_pDD7->CreateSurface(&ddsd, &pDD, NULL);
                    if (hRet == DD_OK)
                        pDD->Release();                        
                }

            } else {
                //
                // Explicitly set to NULL
                //

                m_pDD7 = NULL;
            }
        }

        //
        // If can't create advanced interface, go for backup
        //

        if (m_pDD7 == NULL) {
            AssertReadPtr(m_pfnCreate);
            hr = (m_pfnCreate)(pguidDriver, &m_pDD, NULL);
            if (SUCCEEDED(hr)) {
                m_pDD->SetCooperativeLevel(NULL, DDSCL_NORMAL);
            } else {
                //
                // Unable to initialize DirectDraw, so need to bail.
                //

                goto errorexit;
            }
        }
    }

    m_cDDrawRef++;
    return S_OK;

errorexit:
    Uninit();
    return DU_E_GENERIC;
}


//------------------------------------------------------------------------------
void    
DxManager::Uninit()
{
    if (m_cDDrawRef <= 0) {
        return;
    }

    m_cDDrawRef--;
    if (m_cDDrawRef <= 0) {
        //
        // Can't call Release() on the IDirectDraw interfaces here b/c we are 
        // shutting down and their v-tbl's are messed up.  Bummer.
        //

        SafeRelease(m_pDD7);
        SafeRelease(m_pDD);

        if (m_hDllDxDraw != NULL) {
            FreeLibrary(m_hDllDxDraw);
            m_hDllDxDraw  = NULL;
        }

        m_pfnCreate     = NULL;
        m_pfnCreateEx   = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DxManager::InitDxTx()
{
    AssertMsg(IsInit(), "DxManager must be first initialized");

    if (m_pdxXformFac == NULL) {
        //
        // DxTx needs COM to be initialized first.
        //
        if (!GetComManager()->Init(ComManager::sCOM)) {
            return DU_E_GENERIC;
        }

        // Build and initialize a Transform Factory
        HRESULT hr;
        hr = GetComManager()->CreateInstance(CLSID_DXTransformFactory, NULL, 
                IID_IDXTransformFactory, (void **)&m_pdxXformFac);
        if (FAILED(hr) || (m_pdxXformFac == NULL)) {
            goto Error;
        }

        hr = m_pdxXformFac->SetService(SID_SDirectDraw, m_pDD, FALSE);
        if (FAILED(hr)) {
            goto Error;
        }

        // Build a Surface Factory
        hr = m_pdxXformFac->QueryService(SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, 
                (void **)&m_pdxSurfFac);
        if (FAILED(hr) || (m_pdxSurfFac  == NULL)) {
            goto Error;
        }
    }

    m_cDxTxRef++;
    return S_OK;

Error:
    SafeRelease(m_pdxSurfFac);
    SafeRelease(m_pdxXformFac);
    return DU_E_GENERIC;
}


//------------------------------------------------------------------------------
void 
DxManager::UninitDxTx()
{
    if (m_cDxTxRef <= 0) {
        return;
    }

    m_cDxTxRef--;
    if (m_cDxTxRef <= 0) {
        GetBufferManager()->FlushTrxBuffers();

        SafeRelease(m_pdxSurfFac);
        SafeRelease(m_pdxXformFac);
    }
}


//------------------------------------------------------------------------------
HRESULT
DxManager::BuildSurface(SIZE sizePxl, IDirectDrawSurface7 * pddSurfNew)
{
    AssertMsg(IsInit(), "DxManager must be first initialized");
    AssertMsg(m_pDD7 != NULL, "Must have DX7");

#if 0
    HDC hdc = GetGdiCache()->GetTempDC();
    int nBitDepth = GetDeviceCaps(hdc, BITSPIXEL);
#endif

    DDSURFACEDESC2 ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize         = sizeof(ddsd);
    ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.dwWidth        = sizePxl.cx;
    ddsd.dwHeight       = sizePxl.cy;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

#if 0
    GetGdiCache()->ReleaseTempDC(hdc);
#endif

    // TODO: Want to optimize where this surface is being created

    return m_pDD7->CreateSurface(&ddsd, &pddSurfNew, NULL);
}


//------------------------------------------------------------------------------
HRESULT
DxManager::BuildDxSurface(SIZE sizePxl, REFGUID guidFormat, IDXSurface ** ppdxSurfNew)
{
    AssertWritePtr(ppdxSurfNew);

    CDXDBnds bnds;
    bnds.SetXYSize(sizePxl.cx, sizePxl.cy);

    HRESULT hr = GetSurfaceFactory()->CreateSurface(m_pDD, NULL, 
            &guidFormat, &bnds, 0, NULL, IID_IDXSurface, (void**)ppdxSurfNew);
    if (FAILED(hr)) {
        return hr;
    }
    AssertMsg(*ppdxSurfNew != NULL, "Ensure valid surface");

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class DxSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxSurface::DxSurface()
{
    m_pdxSurface    = NULL;
    m_sizePxl.cx    = 0;
    m_sizePxl.cy    = 0;
}


//------------------------------------------------------------------------------
DxSurface::~DxSurface()
{
    SafeRelease(m_pdxSurface);
}


/***************************************************************************\
*
* DxSurface::Create
*
* Create() initializes a new instance of DxSurface.
*
\***************************************************************************/

HRESULT
DxSurface::Create(SIZE sizePxl)
{
    HRESULT hr;

    //
    // Build the surface
    //

#if 0
    m_guidFormat    = DDPF_ARGB32;
    m_sf            = DXPF_ARGB32;
#elif 0
    m_guidFormat    = DDPF_PMARGB32
    m_sf            = DXPF_PMARGB32
#elif 1
    m_guidFormat    = DDPF_RGB565;
    m_sf            = DXPF_RGB565;
#elif 0
    m_guidFormat    = DDPF_RGB555;
    m_sf            = DXPF_RGB555;
#elif 0
    m_guidFormat    = DDPF_ARGB4444;
    m_sf            = DXPF_ARGB4444;
#endif

    hr = GetDxManager()->BuildDxSurface(sizePxl, m_guidFormat, &m_pdxSurface);
    if (FAILED(hr)) {
        return hr;
    }

    DXPMSAMPLE sam;
    sam.Red     = 0xC0;
    sam.Green   = 0x00;
    sam.Blue    = 0x00;
    sam.Alpha   = 0xFF;

    DXFillSurface(m_pdxSurface, sam, FALSE);

    m_sizePxl.cx  = sizePxl.cx;
    m_sizePxl.cy  = sizePxl.cy;

    return S_OK;
}


/***************************************************************************\
*
* DxSurface::CopyDC
*
* CopyDC() copies a given HDC into the DxSurface, converting properly from 
* the GDI object into the Dx object.
*
\***************************************************************************/

BOOL        
DxSurface::CopyDC(
        IN  HDC hdcSrc,                 // HDC to copy bits from 
        IN  const RECT & rcCrop)        // Area to copy
{
    HRESULT hr;

    // Check parameters
    if (m_pdxSurface == NULL) {
        return FALSE;
    }
    if (hdcSrc == NULL) {
        return FALSE;
    }

    //
    // Copy the bitmap to the surface
    //
    BOOL fSuccess = FALSE;
    IDXDCLock * pdxLock = NULL;

#if 0
    {
        DXPMSAMPLE sam;
        sam.Red     = 0x00;
        sam.Green   = 0x00;
        sam.Blue    = 0x00;
        sam.Alpha   = 0xFF;

        DXFillSurface(m_pdxSurface, sam, FALSE);
    }
#endif

    pdxLock = NULL;
    hr = m_pdxSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (FAILED(hr) || (pdxLock == NULL)) {
        goto Cleanup;
    }

    {
        HDC hdcSurface = pdxLock->GetDC();
        BitBlt(hdcSurface, 0, 0, rcCrop.right - rcCrop.left, rcCrop.bottom - rcCrop.top, 
                hdcSrc, rcCrop.left, rcCrop.top, SRCCOPY);
    }

    pdxLock->Release();

    fSuccess = FixAlpha();

Cleanup:
    return fSuccess;
}


/***************************************************************************\
*
* DxSurface::CopyBitmap
*
* CopyBitmap() copies a given HBITMAP into the DxSurface, converting 
* properly from the GDI object into the Dx object.
*
\***************************************************************************/

BOOL            
DxSurface::CopyBitmap(
        IN  HBITMAP hbmpSrc,            // Bitmap to copy from
        IN  const RECT * prcCrop)       // Optional cropping area
{
    HRESULT hr;

    // Check parameters
    if (m_pdxSurface == NULL) {
        return FALSE;
    }
    if (hbmpSrc == NULL) {
        return FALSE;
    }


    //
    // Determine the area to copy
    //

    BITMAP bmpInfo;
    if (GetObject(hbmpSrc, sizeof(bmpInfo), &bmpInfo) == 0) {
        return FALSE;
    }

    POINT ptSrcOffset;
    SIZE sizeBmp;

    ptSrcOffset.x   = 0;
    ptSrcOffset.y   = 0;
    sizeBmp.cx      = bmpInfo.bmWidth;
    sizeBmp.cy      = bmpInfo.bmHeight;

    if (prcCrop != NULL) {
        SIZE sizeCrop;
        sizeCrop.cx = prcCrop->right - prcCrop->left;
        sizeCrop.cy = prcCrop->bottom - prcCrop->top;

        ptSrcOffset.x   = prcCrop->left;
        ptSrcOffset.y   = prcCrop->top;
        sizeBmp.cx      = min(sizeBmp.cx, sizeCrop.cx);
        sizeBmp.cy      = min(sizeBmp.cy, sizeCrop.cy);
    }


    //
    // Copy the bitmap to the surface
    //
    BOOL fSuccess = FALSE;
    HDC hdcBitmap = NULL;
    IDXDCLock * pdxLock = NULL;

    hdcBitmap = GetGdiCache()->GetCompatibleDC();
    if (hdcBitmap == NULL) {
        goto Cleanup;
    }

#if 0
    {
        DXPMSAMPLE sam;
        sam.Red     = 0x00;
        sam.Green   = 0x00;
        sam.Blue    = 0x00;
        sam.Alpha   = 0xFF;

        DXFillSurface(m_pdxSurface, sam, FALSE);
    }
#endif
    hr = m_pdxSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (FAILED(hr) || (pdxLock == NULL)) {
        goto Cleanup;
    }

    {
        HDC hdcSurface = pdxLock->GetDC();
        HBITMAP hbmpOld = (HBITMAP) SelectObject(hdcBitmap, hbmpSrc);
        BitBlt(hdcSurface, 0, 0, sizeBmp.cx, sizeBmp.cy, 
                hdcBitmap, ptSrcOffset.x, ptSrcOffset.y, SRCCOPY);
        SelectObject(hdcBitmap, hbmpOld);
    }

    pdxLock->Release();

    fSuccess = FixAlpha();

Cleanup:
    if (hdcBitmap != NULL) {
        GetGdiCache()->ReleaseCompatibleDC(hdcBitmap);
    }

    return fSuccess;
}


/***************************************************************************\
*
* DxSurface::FixAlpha
*
* FixAlpha() fixes the alpha values in a surface.  This usually needs to be 
* done after copying a GDI HBITMAP to a DXSurface, depending on the format.
*
\***************************************************************************/

BOOL
DxSurface::FixAlpha()
{
    IDXARGBReadWritePtr * pRW;

    HRESULT hr = m_pdxSurface->LockSurface(NULL, INFINITE, DXLOCKF_READWRITE,
            __uuidof(IDXARGBReadWritePtr), (void **)&pRW, NULL);
    if (FAILED(hr)) {
        return FALSE;
    }

    BOOL fSuccess = FALSE;

    if (!TestFlag(m_sf, DXPF_TRANSLUCENCY)) {
        //
        // Sample doesn't have any alpha, so okay
        //

        fSuccess = TRUE;
    } else if (m_sf == DXPF_ARGB32) {
        //
        // Format is 8:8:8:8 with alpha in MSB.  
        // Need to use Unpack() to get bits.
        // Each pixel is 32 bits.
        //

        DXSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->Unpack(NULL, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }
        }  

        fSuccess = TRUE;
    } else if (m_sf == DXPF_PMARGB32) {
        //
        // Format is 8:8:8:8 with alpha in MSB.  
        // Need to use UnpackPremult() to get bits.
        // Each pixel is 32 bits
        //

        DXPMSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->UnpackPremult(NULL, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }
        }  

        fSuccess = TRUE;
    } else if (m_sf == DXPF_ARGB4444) {
        //
        // Format is 4:4:4:4 with alpha in MSN.  
        // Need to use Unpack() to get bits.
        // Each pixel is 16 bits
        //

        int cb  = m_sizePxl.cx * sizeof(DXSAMPLE);
        DXSAMPLE * rgam = (DXSAMPLE *) _alloca(cb);
        DXSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->Unpack(rgam, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }

            pRW->PackAndMove(rgam, m_sizePxl.cx);
        }  

        fSuccess = TRUE;
    }

    pRW->Release();

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\context.inl ===
/***************************************************************************\
*
* File: Context.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Context_inl__INCLUDED)
#define SERVICES__Context_inl__INCLUDED
#pragma once

#include "Thread.h"

#if !USE_DYNAMICTLS
extern __declspec(thread) Context * t_pContext;
#endif

/***************************************************************************\
*****************************************************************************
*
* class Context
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Context * 
GetContext()
{
#if USE_DYNAMICTLS
    Assert(IsInitThread());
    
    Context * pContext = GetThread()->GetContext();
#else
    Context * pContext = t_pContext;
#endif
    AssertMsg(pContext != NULL, "Using uninitialized Context");
    return pContext;
}


//------------------------------------------------------------------------------
__forceinline Context * 
RawGetContext()
{
#if USE_DYNAMICTLS
    Thread * pthr = RawGetThread();
    if (pthr != NULL) {
        return pthr->GetContext();
    } else {
        return (Context *) pthr;
    }
#else
    return t_pContext;
#endif
}


//------------------------------------------------------------------------------
inline BOOL        
IsInitContext()
{
#if USE_DYNAMICTLS
    Thread * pthr = RawGetThread();
    return (pthr != NULL) && (pthr->GetContext() != NULL);
#else
    return t_pContext != NULL;
#endif
}


//------------------------------------------------------------------------------
inline Context * 
CastContext(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htContext)) {
        return (Context *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const Context * 
CastContext(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htContext)) {
        return (const Context *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline void
Context::MarkOrphaned()
{
    // NOTE: A Context may be orphaned multiple times from different threads.
    m_fOrphaned = TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
Context::IsOrphanedNL() const
{
    return m_fOrphaned;
}


//------------------------------------------------------------------------------
inline void   
Context::Enter()
{
    AssertMsg(m_cRef > 0, "Context must be valid to be locked");
    m_lock.Enter();
    Lock();
    if (m_cEnterLock++ == 0) {
        //
        // Just entered, so no deferred callbacks yet.
        // 
        m_fPending = FALSE;
    }

#if DBG
    if (m_cEnterLock > 30) {
        Trace("WARNING: DUser: m_cEnterLock is getting high (%d) for Context 0x%p.\n", m_cEnterLock, this);
        Trace("                Probably have an Enter() without an matching Leave().\n");
    }
#endif

#if DBG
    m_DEBUG_pthrLock    = IsInitThread() ? GetThread() : (Thread *) (void *) 0x12345678;
    m_DEBUG_tidLock     = GetCurrentThreadId();
#endif // DBG
}


//------------------------------------------------------------------------------
inline void   
Context::Leave()
{
#if DBG
    m_DEBUG_pthrLock    = NULL;
    m_DEBUG_tidLock     = 0;
#endif // DBG

    AssertMsg(m_cEnterLock > 0, "Must have a matching Enter() for every Leave()");
    --m_cEnterLock;

    AssertMsg(m_cRef > 0, "Context should still be valid when unlocked");
    if (xwUnlock()) {
        //
        // Only can access the object if it is still valid after being 
        // xwUnlock()'d.
        //

        m_lock.Leave();
    }
}


//------------------------------------------------------------------------------
inline void   
Context::Leave(BOOL fOldEnableDefer, BOOL * pfPending)
{
#if DBG
    m_DEBUG_pthrLock    = NULL;
    m_DEBUG_tidLock     = 0;
#endif // DBG

    AssertMsg(m_cEnterLock > 0, "Must have a matching Enter() for every Leave()");
    *pfPending      = (--m_cEnterLock == 0) && m_fPending && m_fEnableDefer;  // Must --m_cEnterLock first
    m_fEnableDefer  = fOldEnableDefer;

    AssertMsg(m_cRef > 0, "Context should still be valid when unlocked");
    if (xwUnlock()) {
        //
        // Only can access the object if it is still valid after being 
        // xwUnlock()'d.
        //

        m_lock.Leave();
    }
}


//------------------------------------------------------------------------------
inline DUserHeap * 
Context::GetHeap() const
{
    AssertMsg(m_pHeap != NULL, "Heap should be specified for Context");
    return m_pHeap;
}


//------------------------------------------------------------------------------
inline SubContext *
Context::GetSC(ESlot slot) const
{
    return m_rgSCs[slot];
}


#if DBG_CHECK_CALLBACKS

//------------------------------------------------------------------------------
inline void
Context::BeginCallback()
{
    m_cLiveCallbacks++;
}


//------------------------------------------------------------------------------
inline void        
Context::EndCallback()
{
    Assert(m_cLiveCallbacks > 0);
    m_cLiveCallbacks--;
}

#endif // DBG_CHECK_CALLBACKS


//------------------------------------------------------------------------------
inline void
Context::BeginReadOnly()
{
    AssertMsg(m_cEnterLock > 0, "Must have Enter()'d the context before making read-only");
    m_cReadOnly++;
}


//------------------------------------------------------------------------------
inline void        
Context::EndReadOnly()
{
    Assert(m_cEnterLock > 0);
    m_cReadOnly--;
}


//------------------------------------------------------------------------------
inline BOOL        
Context::IsReadOnly() const
{
    return m_cReadOnly;
}


//------------------------------------------------------------------------------
inline UINT
Context::GetThreadMode() const
{
    return m_nThreadMode;
}


//------------------------------------------------------------------------------
inline UINT
Context::GetPerfMode() const
{
    return m_nPerfMode;
}


//------------------------------------------------------------------------------
inline BOOL
Context::IsEnableDefer() const
{
    return m_fEnableDefer;
}


//------------------------------------------------------------------------------
__forceinline void
Context::EnableDefer(BOOL fEnable, BOOL * pfOld)
{
    if (pfOld != NULL) {
        *pfOld = m_fEnableDefer;
    }

    m_fEnableDefer = fEnable;
}


//------------------------------------------------------------------------------
inline void
Context::MarkPending()
{
    AssertMsg(m_fEnableDefer, "Deferred callbacks must be enabled");
    m_fPending = TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class SubContext
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
SubContext::SetParent(Context * pParent)
{
    AssertMsg(m_pParent == NULL, "Must set only once");
    m_pParent = pParent;
}


/***************************************************************************\
*****************************************************************************
*
* class ContextPackBuilder
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline ContextPackBuilder *
ContextPackBuilder::GetBuilder(Context::ESlot slot)
{
    AssertMsg(s_rgBuilders[slot] != NULL, "Build must be defined");
    return s_rgBuilders[slot];
}


/***************************************************************************\
*****************************************************************************
*
* Various lock helpers
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
ContextLock::ContextLock()
{
    pctx = NULL;
}


//------------------------------------------------------------------------------
inline  
ContextLock::~ContextLock()
{
    if (pctx != NULL) {
        //
        // Leaving the lock, so notify the Thread and give it a chance to do 
        // anything it needed afterwards.
        //

        BOOL fPending;
        pctx->Leave(fOldDeferred, &fPending);

        if (fPending) {
            GetThread()->xwLeftContextLockNL();
        }
    }
}


//------------------------------------------------------------------------------
inline  
ReadOnlyLock::ReadOnlyLock(Context * pctxThread)
{
    pctx = pctxThread;
    pctx->BeginReadOnly();
}


//------------------------------------------------------------------------------
inline  
ReadOnlyLock::~ReadOnlyLock()
{
    pctx->EndReadOnly();
}


#endif // SERVICES__Context_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\fastdib.h ===
/******************************Module*Header*******************************\
* Module Name: fastdib.h
*
* CreateCompatibleDIB definitions.
*
* Created: 02-Feb-1996 19:30:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

/*
This application draws a spinning RGB color cube into a bitmap and
copies this bitmap to the display window, demonstrating the use
of optimized DIBs with OpenGL.  Note that pressing any of the number
keys from 2-9 while the app is running will set a zoom factor which
will cause the app to shrink the bitmap and to use StretchBlt to copy
the bitmap to the display.

The FastDIB API functions are implemented in fastdib.c.  It is
merely an interface layer to existing Win32 functions.  It goal is
to encapsulate some of the complexity of determing formats, initializing
color tables, etc.

Note that use of optimized DIBs on palettized (i.e., 8bpp) display devices
on OpenGL/95 version 1.0 is broken.  If running on Win95, the following
line in timecube.c should be commented out:

    #define _COMPATIBLE_DIB_FIX_

------------------------------------------------------------------------------

CreateCompatibleDIB
-------------------

HBITMAP APIENTRY CreateCompatibleDIB(hdc, hpal, ulWidth, ulHeight, ppvBits)
HDC hdc;
HPALETTE hpal;
ULONG ulWidth;
ULONG ulHeight;
PVOID *ppvBits;

Create a DIB section bitmap with an optimized format with respect to the
specified display DC.  Optimized in this case means that the bitmap format
(and palette, if applicable) are matched to the display and will ensure
the highest possible Blt performance.

Parameters

    hdc

        Specifies display DC used to determine format.  If hpal is NULL,
        this hdc is used to retrieve the system palette entries with which
        the DIB color table is initialized (on palettized display devices
        only).

    hpal

        Optional palette that, if specified, is used to initialize the DIB
        color table.  If NULL, the system palette is used.  Ignored for
        non-palettized display devices.

    ulWidth

        Specifies the width of the bitmap.

    ulHeight

        Specifies the height of the bitmap.

    ppvBits

        Returns a pointer to the DIB section bits with which the application
        can draw directly into the bitmap.

Return Value

    The return value is the handle to the bitmap created.  If the function
    fails, the return value is NULL.

------------------------------------------------------------------------------

UpdateDIBColorTable
-------------------

BOOL APIENTRY UpdateDIBColorTable(hdcMem, hdc, hpal)
HDC hdcMem;
HDC hdc;
HPALETTE hpal;

Synchronize the color table of DIB bitmap selected into the specified
memory DC with either the current system palette or the optionally
specified logical palette.

This function need only be invoked on palettized display devices.

Parameters

    hdcMem

        Specified the memory DC into which the DIB of interest is selected.

    hdc

        Specifies the display DC for which the DIB is formatted.  If hpal
        is NULL this hdc is used to retrieve the system palette entries
        with which the DIB color table is initialized (on palettized display
        devices only).

    hpal

        Optional palette that, if specified, is used to initialize the DIB
        color table.  If NULL, the system palette is used.  Ignored for
        non-palettized display devices.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.

Comments

    Typically, this function is called only if the logical palette in the
    display DC changes.  For OpenGL apps, the logical palette is set only
    once for RGB modes, which implies that this function normally does not
    need to be used with RGB modes.  Color index modes, however, may change
    the logical palette at any time.  If that happens, then the application
    should invoke this function after the new palette has been realized.

------------------------------------------------------------------------------

GetCompatibleDIBInfo
--------------------

BOOL APIENTRY GetCompatibleDIBInfo(hbm, ppvBase, plStride)
HBITMAP hbm;
PVOID *ppvBase;
LONG *plStride;

Returns information about the specified DIB section that allows the
application to compute the address of a desired (x, y) pixel within
the bitmap.

Parameters

    hbm

        Specifies the DIB section bitmap of interest.

    ppvBase

        Returns a pointer to the origin of the bitmap.  If the DIB
        is top-down, then this is the same as the ppvBits returned
        by the intial call to CreateCompatibleDIB.  The default,
        however, is bottom-up.

    plStride

        Returns the stride or pitch of the bitmap (i.e., the difference
        in address between two vertically adjacent pixels).  If the bitmap
        is top-down, this value is positive; if the bitmap is bottom-up,
        this value is negative.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.

Comments

    The ppvBase and plStride value returned will allow the application to
    compute the address any given pixel (x, y) in the bitmap as follows:

    PIXEL *ppix;

    ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));

------------------------------------------------------------------------------

GetDIBTranslationVector
-----------------------

BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
HDC hdcMem;
HPALETTE hpal;
BYTE *pbVector;

Returns the translation vector that maps colors in the specified palette,
hpal, to the DIB selected into the specified DC, hdcMem.  This information
is needed so that applications that draw directly into the DIB can translate
the logical color indices into physical bitmap indices.

This function should only be invoked on palettized display devices.

Parameters

    hdcMem

        Specified the memory DC into which the DIB of interest is selected.

    hpal

        Specifies the logical palette which will be mapped to the DIB.

    pbVector

        Points to a buffer into which the translation vector will be copied.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.


Comments

    This function does not try to validate the buffer size.  It is up to
    the application to allocate enough memory for the call.  The amount of
    memory required in bytes equal in value to the number of entries
    in the logical palette:

        bufferSize = GetPaletteEntries(hpal, 0, 1, NULL) * sizeof(BYTE);

*/

#ifndef SERVICES__FastDib_h__INCLUDED
#define SERVICES__FastDib_h__INCLUDED

HBITMAP APIENTRY CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, PVOID *ppvBits, BITMAPINFOHEADER * pbmih = NULL);
BOOL APIENTRY UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);
BOOL APIENTRY GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride);
BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);

#endif //SERVICES__FastDib_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\gdicache.cpp ===
/***************************************************************************\
*
* File: GdiCache.cpp
*
* Description:
* GdiCache.cpp implements the process-wide GDI cache that manages cached and
* temporary GDI objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "GdiCache.h"

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void
ObjectCache::Destroy()
{
    //
    // Remove all temporary regions.  These MUST all be released by this point.
    //
    AssertMsg(m_arAll.GetSize() == m_arFree.GetSize(), "All objects should be free");

#if ENABLE_DUMPCACHESTATS
    AutoTrace("%s ObjectCache statistics: %d items\n", m_szName, m_arAll.GetSize());
#endif // ENABLE_DUMPCACHESTATS

    int cObjs = m_arAll.GetSize();
    for (int idx = 0; idx < cObjs; idx++) {
        DestroyObject(m_arAll[idx]);
    }
    m_arAll.RemoveAll();
    m_arFree.RemoveAll();
}


//------------------------------------------------------------------------------
void *
ObjectCache::Pop()
{
    void * pObj;

    //
    // Check if any objects are already freed.
    //

    if (!m_arFree.IsEmpty()) {
        int idxObj = m_arFree.GetSize() - 1;
        pObj = m_arFree[idxObj];
        Verify(m_arFree.RemoveAt(idxObj));

        goto Exit;
    }


    //
    // No cached regions, so create a new one.
    //

    pObj = Build();
    if (pObj == NULL) {
        AssertMsg(0, "Could not create a new object- something is probably wrong");
        goto Exit;
    }

    {
        int idxAdd = m_arAll.Add(pObj);
        if (idxAdd == -1) {
            AssertMsg(0, "Could not add object to array- something is probably wrong");
            DestroyObject(pObj);
            pObj = NULL;
            goto Exit;
        }
    }

Exit:
    return pObj;
}


//------------------------------------------------------------------------------
void        
ObjectCache::Push(void * pObj)
{
#if DBG
    //
    // Ensure this object was previously given out, but is not currently listed 
    // as free.
    //

    {
        BOOL fValid;
        int cItems, idx;

        fValid = FALSE;
        cItems = m_arAll.GetSize();
        for (idx = 0; idx < cItems; idx++) {
            if (m_arAll[idx] == pObj) {
                fValid = TRUE;
                break;
            }
        }

        AssertMsg(fValid, "Object not in list of all temporary regions");

        cItems = m_arFree.GetSize();
        for (idx = 0; idx < cItems; idx++) {
            AssertMsg(m_arFree[idx] != pObj, "Object must not be free object list");
        }
    }

#endif // DBG

    //
    // Add this object to the list of free objects.
    //

    if (m_arFree.GetSize() < m_cMaxFree) {
        VerifyMsg(m_arFree.Add(pObj) >= 0, "Should be able to add object to list");
    } else {
        DestroyObject(pObj);
    }
}


/***************************************************************************\
*****************************************************************************
*
* class GdiCache
*
*****************************************************************************
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\gdicache.inl ===
/***************************************************************************\
*
* File: GdiCache.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__GdiCache_inl__INCLUDED)
#define SERVICES__GdiCache_inl__INCLUDED
#pragma once

#include "OSAL.h"

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
ObjectCache::ObjectCache()
{
#if ENABLE_DUMPCACHESTATS
    m_szName[0] = '\0';
#endif // ENABLE_DUMPCACHESTATS

    m_cMaxFree = IsRemoteSession() ? 2 : 4;
}


//------------------------------------------------------------------------------
inline
ObjectCache::~ObjectCache()
{
    AssertMsg(m_arAll.IsEmpty(), "Must have already free'd Context memory");
    AssertMsg(m_arFree.IsEmpty(), "Must have already free'd Context memory");
}


#if ENABLE_DUMPCACHESTATS

//------------------------------------------------------------------------------
inline void
ObjectCache::SetName(LPCSTR pszName)
{
    strcpy(m_szName, pszName);
}

#endif // ENABLE_DUMPCACHESTATS


/***************************************************************************\
*****************************************************************************
*
* GdiObjectCacheT<>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline T
GdiObjectCacheT<T>::Get()
{
    return static_cast<T> (Pop());
}


//------------------------------------------------------------------------------
template <class T>
inline void        
GdiObjectCacheT<T>::Release(T hObj)
{
    Push(hObj);
}


//------------------------------------------------------------------------------
template <class T>
void
GdiObjectCacheT<T>::DestroyObject(void * pObj)
{
#if DBG
    SetLastError(0);
    BOOL fSuccess = ::DeleteObject((HGDIOBJ) pObj);
    if (!fSuccess) {
        DWORD dwErr = GetLastError();
        Trace("LastError: %d (0x%p)\n", dwErr, dwErr);
    }
    AssertMsg(fSuccess, "Ensure successfully deleted");
#else // DBG
    ::DeleteObject((HGDIOBJ) pObj);
#endif // DBG
}


/***************************************************************************\
*****************************************************************************
*
* class GdiCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
GdiCache::GdiCache()
{
#if ENABLE_DUMPCACHESTATS
    m_gocTempRgn.SetName("TempRgn");
    m_gocDisplayDC.SetName("DisplayDC");
    m_gocCompatDC.SetName("CompatDC");
#endif // ENABLE_DUMPCACHESTATS
}


//------------------------------------------------------------------------------
inline 
GdiCache::~GdiCache()
{

}


//------------------------------------------------------------------------------
inline void        
GdiCache::Destroy()
{
    m_gocTempRgn.Destroy();
    m_gocDisplayDC.Destroy();
    m_gocCompatDC.Destroy();
}


//------------------------------------------------------------------------------
inline HRGN        
GdiCache::GetTempRgn()
{
    return m_gocTempRgn.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseTempRgn(HRGN hrgn)
{
    m_gocTempRgn.Release(hrgn);
}


//------------------------------------------------------------------------------
inline HDC         
GdiCache::GetTempDC()
{
    return m_gocDisplayDC.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseTempDC(HDC hdc)
{
    m_gocDisplayDC.Release(hdc);
}


//------------------------------------------------------------------------------
inline HDC         
GdiCache::GetCompatibleDC()
{
    return m_gocCompatDC.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseCompatibleDC(HDC hdc)
{
    m_gocCompatDC.Release(hdc);
}


#endif // SERVICES__GdiCache_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\gdicache.h ===
/***************************************************************************\
*
* File: GdiCache.h
*
* Description:
* GdiCache.h defines the process-wide GDI cache that manages cached and
* temporary GDI objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__GdiCache_h__INCLUDED)
#define SERVICES__GdiCache_h__INCLUDED
#pragma once

#define ENABLE_DUMPCACHESTATS       0   // Dump ObjectCache statistics

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
* ObjectCache declares a standard container used to cache temporary objects.  
* As new objects are requested, objects will be returned from the free list 
* of cached objects.  If this list is empty, new objects will be created.  
* When an object is released, it is added to the free list, ready to be used 
* again.
*
*****************************************************************************
\***************************************************************************/

class ObjectCache
{
// Construction
public:
    inline  ObjectCache();
    inline  ~ObjectCache();
            void        Destroy();

// Operations
public:
#if ENABLE_DUMPCACHESTATS
    inline  void        SetName(LPCSTR pszName);
#endif

// Implementation
protected:
            void *      Pop();
            void        Push(void * pObj);

    virtual void *      Build() PURE;
    virtual void        DestroyObject(void * pObj) PURE;

// Data
private:
            GArrayF<void *>
                        m_arAll;        // Collection of all temporary objects
            GArrayF<void *>
                        m_arFree;       // Indicies of available temporary objects
            int         m_cMaxFree;     // Maximum number of free objects

#if ENABLE_DUMPCACHESTATS
            char        m_szName[256];
#endif
};


/***************************************************************************\
*****************************************************************************
*
* class GdiObjectCacheT
*
* GdiObjectCacheT implements an ObjectCache for GDI objects.  To use this
* class, derive from GdiObjectCacheT and provide a Build() function to 
* create new object instance.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GdiObjectCacheT : public ObjectCache
{
public:
    inline  T           Get();
    inline  void        Release(T hObj);

protected:
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*****************************************************************************
*
* Specific implementations of GdiObjectCacheT<>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class RgnCache : public GdiObjectCacheT<HRGN>
{
protected:
    virtual void *      Build()
    {
        return ::CreateRectRgn(0, 0, 0, 0);
    }
};


//------------------------------------------------------------------------------
class DisplayDCCache : public GdiObjectCacheT<HDC>
{
protected:
    virtual void *      Build()
    {
        return CreateDC("DISPLAY", NULL, NULL, NULL);
    }
};


//------------------------------------------------------------------------------
class CompatibleDCCache : public GdiObjectCacheT<HDC>
{
protected:
    virtual void *      Build()
    {
        HDC hdcDesk = ::GetDC(NULL);
        HDC hdc = ::CreateCompatibleDC(hdcDesk);
        ::ReleaseDC(NULL, hdcDesk);

        return hdc;
    }
};


/***************************************************************************\
*****************************************************************************
*
* class GdiCache 
* 
* GdiCache caches frequently used GDI objects.  By abstracting out how these
* objects are created and maintained, the large number of temporary objects
* used in DirectUser can be easily tweaked for performance and memory tuning.
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class GdiCache
{
// Construction
public:
    inline  GdiCache();
    inline  ~GdiCache();
    inline  void        Destroy();

// Operations
public:
    inline  HRGN        GetTempRgn();
    inline  void        ReleaseTempRgn(HRGN hrgn);

    inline  HDC         GetTempDC();
    inline  void        ReleaseTempDC(HDC hdc);

    inline  HDC         GetCompatibleDC();
    inline  void        ReleaseCompatibleDC(HDC hdc);

// Data
private:
    RgnCache            m_gocTempRgn;   // Temporary regions
    DisplayDCCache      m_gocDisplayDC; // Display DC's
    CompatibleDCCache   m_gocCompatDC;  // Compatible DC's
};

#include "GdiCache.inl"

#endif // SERVICES__GdiCache_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\globals.h ===
#if !defined(SERVICES__Globals_h__INCLUDED)
#define SERVICES__Globals_h__INCLUDED
#pragma once

extern  HINSTANCE   g_hDll;
#if USE_DYNAMICTLS
extern  DWORD       g_tlsThread;    // TLS Slot for Thread data
#endif

#if ENABLE_MPH
extern  MESSAGEPUMPHOOK
                    g_mphReal;
#endif

class GdiCache;
class BufferManager;
class ComManager;
class TicketManager;

inline  GdiCache *      GetGdiCache();
inline  BufferManager * GetBufferManager();
inline  ComManager *    GetComManager();
        DuTicketManager * GetTicketManager();

#include "Globals.inl"

#endif // SERVICES__Globals_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\globals.inl ===
#if !defined(SERVICES__Globals_inl__INCLUDED)
#define SERVICES__Globals_inl__INCLUDED
#pragma once

#include "Thread.h"

//------------------------------------------------------------------------------
inline GdiCache * 
GetGdiCache()
{
    return GetThread()->GetGdiCache();
}


//------------------------------------------------------------------------------
inline BufferManager * 
GetBufferManager()
{
    return GetThread()->GetBufferManager();
}


//------------------------------------------------------------------------------
inline ComManager * 
GetComManager()
{
    return GetThread()->GetComManager();
}


#endif // SERVICES__Globals_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\hook.h ===
#if !defined(SERVICES__Hook_h__INCLUDED)
#define SERVICES__Hook_h__INCLUDED
#pragma once

#if ENABLE_MPH

BOOL        InitMPH();
BOOL        UninitMPH();

BOOL        CALLBACK DUserInitHook(DWORD dwCmd, void* pvParam);

#endif // ENABLE_MPH

#endif // SERVICES__Hook_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\globals.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Globals.h"

#include "GdiCache.h"
#include "Thread.h"
#include "Context.h"
#include "TicketManager.h"

//
// The order that the global variables are declared here is VERY important 
// because it determines their destruction order during shutdown.
// Variables declared first will be destroyed AFTER all of the variables 
// declared after them.
//
// Thread objects are very low-level and should be at the top of this list.  
// This helps to ensure that new Thread objects are not accidentally created
// during shutdown.
//


HINSTANCE   g_hDll      = NULL;
#if USE_DYNAMICTLS
DWORD       g_tlsThread = (DWORD) -1;   // TLS Slot for Thread data
#endif


#if ENABLE_MPH

//
// Setup the MPH to point to the original USER functions.  If a MPH is
// installed, these will be replaced to point to the real implementations.
//

MESSAGEPUMPHOOK 
            g_mphReal = 
{
    sizeof(g_mphReal),
    NULL,
    NULL,
    NULL,
    NULL,
};

#endif // ENABLE_MPH


DuTicketManager g_TicketManager;


//------------------------------------------------------------------------------
DuTicketManager *
GetTicketManager()
{
    return &g_TicketManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\hook.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Hook.h"

#if ENABLE_MPH

typedef BOOL (WINAPI * RegisterMPHProc)(INITMESSAGEPUMPHOOK pfnInitMPH);
typedef BOOL (WINAPI * UnregisterMPHProc)();

//------------------------------------------------------------------------------
// Forward declarations of implementation functions declared in other modules.
//
BOOL CALLBACK MphProcessMessage(MSG * pmsg, HWND hwnd, 
        UINT wMsgFilterMin, UINT wMsgFilterMax, UINT flags, BOOL fGetMessage);
BOOL CALLBACK MphWaitMessageEx(UINT fsWakeMask, DWORD dwTimeOut);


//------------------------------------------------------------------------------
BOOL InitMPH()
{
    BOOL fSuccess = FALSE;

    HINSTANCE hinst = LoadLibrary("user32.dll");
    if (hinst != NULL) {
        RegisterMPHProc pfnInit = (RegisterMPHProc) GetProcAddress(hinst, "RegisterMessagePumpHook");
        if (pfnInit != NULL) {
            fSuccess = (pfnInit)(DUserInitHook);
        }
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL UninitMPH()
{
    BOOL fSuccess = FALSE;

    HINSTANCE hinst = LoadLibrary("user32.dll");
    if (hinst != NULL) {
        UnregisterMPHProc pfnUninit = (UnregisterMPHProc) GetProcAddress(hinst, "UnregisterMessagePumpHook");
        AssertMsg(pfnUninit != NULL, "Must have Uninit function");
        if (pfnUninit != NULL) {
            fSuccess = (pfnUninit)();
        }
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL CALLBACK DUserInitHook(DWORD dwCmd, void* pvParam)
{
    BOOL fSuccess = FALSE;

    switch (dwCmd)
    {
    case UIAH_INITIALIZE:
        {
            //
            // Setting up the hooks:
            // - Copy the "real" functions over so that DUser can call them later
            // - Replace the functions that DUser needs to override
            //

            MESSAGEPUMPHOOK * pmphReal = reinterpret_cast<MESSAGEPUMPHOOK *>(pvParam);
            if ((pmphReal == NULL) || (pmphReal->cbSize < sizeof(MESSAGEPUMPHOOK))) {
                break;
            }

            CopyMemory(&g_mphReal, pmphReal, pmphReal->cbSize);

            pmphReal->cbSize            = sizeof(MESSAGEPUMPHOOK);
            pmphReal->pfnInternalGetMessage
                                        = MphProcessMessage;
            pmphReal->pfnWaitMessageEx  = MphWaitMessageEx;

            fSuccess = TRUE;
        }
        break;

    case UIAH_UNINITIALIZE:
        //
        // When uninitializing, NULL our function pointers.
        //

        ZeroMemory(&g_mphReal, sizeof(g_mphReal));
        fSuccess = TRUE;

        break;

    default:
        Trace("DUSER: Unknown dwCmd: %d\n", dwCmd);
    }

    return fSuccess;
}

#endif // ENABLE_MPH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\osal.h ===
/***************************************************************************\
*
* File: OSAL.h
*
* Description:
* OSAL.h defines the process-wide Operating System Abstraction Layer that
* allows DirectUser to run on different platforms.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__OSAL_h__INCLUDED)
#define SERVICES__OSAL_h__INCLUDED
#pragma once

/***************************************************************************\
*
* class OS
*
* OS abstracts out differences between various OS's including:
* - Unicode / ANSI
* - Platform implementation differences
* - Version specific bugs
*
\***************************************************************************/

class OSAL
{
// Construction
public:
    virtual ~OSAL() { };

    static  HRESULT     Init();

// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat) PURE;

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int) PURE;
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *) PURE;
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *) PURE;
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE) PURE;
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE) PURE;

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld) PURE;
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld) PURE;
    virtual void        RotateDC(HDC hdc, float flRotationRad) PURE;
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY) PURE;
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY) PURE;
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxf) PURE;
    virtual void        SetIdentityTransform(HDC hdc) PURE;

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock() PURE;

// Implementation
protected:
    static inline 
            BOOL        IsWin98orWin2000(OSVERSIONINFO * povi);
    static inline 
            BOOL        IsWhistler(OSVERSIONINFO * povi);
};

inline  BOOL    SupportUnicode();
inline  BOOL    SupportXForm();
inline  BOOL    SupportQInputAvailable();
inline  BOOL    IsRemoteSession();

        LONG    WINAPI StdExceptionFilter(PEXCEPTION_POINTERS pei);

#include "OSAL.inl"

#endif // SERVICES__OSAL_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\resourcemanager.cpp ===
/***************************************************************************\
*
* File: ResourceManager.cpp
*
* Description:
* This file implements the ResourceManager used to setup and maintain all 
* Thread, Contexts, and other resources used by and with DirectUser.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "ResourceManager.h"

#include "Thread.h"
#include "Context.h"
#include "OSAL.h"
#include "Hook.h"

#include <Delayimp.h>               // For error handling & advanced features

static const GUID guidCreateBuffer  = { 0xd2139559, 0x458b, 0x4ba8, { 0x82, 0x28, 0x34, 0xd7, 0x57, 0x3d, 0xa, 0x8 } };     // {D2139559-458B-4ba8-8228-34D7573D0A08}
static const GUID guidInitGdiplus   = { 0x49f9b12e, 0x846b, 0x4973, { 0xab, 0xfb, 0x7b, 0xe3, 0x4b, 0x52, 0x31, 0xfe } };   // {49F9B12E-846B-4973-ABFB-7BE34B5231FE}


/***************************************************************************\
*****************************************************************************
*
* class ResourceManager
*
*****************************************************************************
\***************************************************************************/

#if DBG
static  BOOL    g_fAlreadyShutdown  = FALSE;
#endif // DBG

long        ResourceManager::s_fInit            = FALSE;
HANDLE      ResourceManager::s_hthSRT           = NULL;
DWORD       ResourceManager::s_dwSRTID          = 0;
HANDLE      ResourceManager::s_hevReady         = NULL;
HGADGET     ResourceManager::s_hgadMsg          = NULL;
MSGID       ResourceManager::s_idCreateBuffer   = 0;
MSGID       ResourceManager::s_idInitGdiplus    = 0;
RMData *    ResourceManager::s_pData            = NULL;
CritLock    ResourceManager::s_lockContext;
CritLock    ResourceManager::s_lockComponent;
Thread *    ResourceManager::s_pthrSRT          = NULL;
GList<Thread> 
            ResourceManager::s_lstAppThreads;
int         ResourceManager::s_cAppThreads      = 0;
GList<ComponentFactory>
            ResourceManager::s_lstComponents;
BOOL        ResourceManager::s_fInitGdiPlus     = FALSE;
ULONG_PTR   ResourceManager::s_gplToken = 0;
Gdiplus::GdiplusStartupOutput 
            ResourceManager::s_gpgso;

#if DBG_CHECK_CALLBACKS
int         ResourceManager::s_cTotalAppThreads = 0;
BOOL        ResourceManager::s_fBadMphInit      = FALSE;
#endif


BEGIN_STRUCT(GMSG_CREATEBUFFER, EventMsg)
    IN  HDC         hdc;            // DC to be compatible with
    IN  SIZE        sizePxl;     // Size of bitmap
    OUT HBITMAP     hbmpNew;        // Allocated bitmap
END_STRUCT(GMSG_CREATEBUFFER)


/***************************************************************************\
*
* ResourceManager::Create
*
* Create() is called when DUser.DLL is loaded to initialize low-level
* services in DirectUser.  
* 
* NOTE: It is very important to keep this function small and to 
* delay-initialize to help keep starting costs low.
*
* NOTE: This function is automatically synchronized because it is called
* in PROCESS_ATTACH in DllMain().  Therefore, only one thread will ever be
* in this function at one time.
*
\***************************************************************************/

HRESULT
ResourceManager::Create()
{
    AssertMsg(!g_fAlreadyShutdown, "Ensure shutdown has not already occurred");

#if USE_DYNAMICTLS
    g_tlsThread = TlsAlloc();
    if (g_tlsThread == (DWORD) -1) {
        return E_OUTOFMEMORY;
    }
#endif

    if (InterlockedCompareExchange(&s_fInit, TRUE, FALSE) == TRUE) {
        return S_OK;
    }

    
    //
    // Initialize low-level resources (such as the heap).  This must be 
    // carefully done since many objects have not been constructed yet.
    //

    s_hthSRT    = NULL;
    s_fInit     = FALSE;
    s_hevReady  = NULL;

    HRESULT hr = OSAL::Init();
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Create global services / managers
    //

    s_pData = ProcessNew(RMData);
    if (s_pData == NULL) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


/***************************************************************************\
*
* ResourceManager::xwDestroy
*
* xwDestroy() is called when DUser.DLL is unloaded to perform final clean-up
* in DirectUser.
*
* NOTE: This function is automatically synchronized because it is called
* in PROCESS_ATTACH in DllMain().  Therefore, only one thread will ever be
* in this function at one time.
* 
\***************************************************************************/

void
ResourceManager::xwDestroy()
{
    AssertMsg(!g_fAlreadyShutdown, "Ensure shutdown has not already occurred");

#if DBG
    g_fAlreadyShutdown = TRUE;
#endif // DBG

    //
    // Check if there are any remaining Contexts.  Unfortunately, we CAN NOT
    // perform any cleanup work since we are in User mode and are limited by
    // what we can do while inside the "Loader Lock" in DllMain().  We can not
    // clean up any objects because these may cause deadlocks, such as freeing
    // another library.  We also must be very cautious about waiting on 
    // anything, since we can easily get into a deadlock.
    //
    // This is a serious application error.  The application MUST call 
    // ::DeleteHandle() on the Context before the thread exits.
    //

    if (s_cAppThreads != 0) {
        OutputDebugString("ERROR: Not all DirectUser Contexts were destroyed before EndProcess().\n");
        PromptInvalid("Not all DirectUser Contexts were destroyed before EndProcess().");

        while (!s_lstAppThreads.IsEmpty()) {
            Thread * pthr = s_lstAppThreads.UnlinkHead();
            pthr->MarkOrphaned();
            pthr->GetContext()->MarkOrphaned();
        }
        s_cAppThreads = 0;
    } else {
        //
        // If there are no leaked application threads, there should no longer be
        // any SRT, since it should be cleaned up when the last application 
        // thread is cleaned up.
        //
        
        AssertMsg(s_pthrSRT == NULL, "Destruction should reset s_pthrSRT");
        AssertMsg(s_lstAppThreads.IsEmpty(), "Should not have any threads");
    }

    ForceSetContextHeap(NULL);
#if USE_DYNAMICTLS
    Verify(TlsSetValue(g_tlsThread, NULL));
#else
    t_pContext  = NULL;
    t_pThread   = NULL;
#endif


    //
    // Clean up remaining resources.
    // NOTE: This can NOT use the Context heaps (via new / delete) because they
    // have already been destroyed.
    //

    ProcessDelete(RMData, s_pData);
    s_pData = NULL;

    if (s_hevReady != NULL) {
        CloseHandle(s_hevReady);
        s_hevReady = NULL;
    }


    //
    // Because they are global variables, we need to manually unlink all of the
    // Component Factories so that they don't get deleted.
    //

    s_lstComponents.UnlinkAll();

#if USE_DYNAMICTLS
    Verify(TlsFree(g_tlsThread));
    g_tlsThread = (DWORD) -1;  // TLS slot no longer valid
#endif
}


/***************************************************************************\
*
* ResourceManager::ResetSharedThread
*
* ResetSharedThread() cleans up SRT data.
*
\***************************************************************************/

void
ResourceManager::ResetSharedThread()
{
    //
    // Access to the SRT is normally serialized through DirectUser's queues.
    // In the case where the data is directly being cleaned up, we need to
    // guarantee that only one thread is accessing this data.  This should
    // always be true since it will either be the SRT properly shutting down
    // or the main application's thread that is cleaning up dangling Contexts.
    //
    
    AssertMsg(s_cAppThreads == 0, "Must not have any outstanding application threads");
    
    s_dwSRTID = 0;

    if (s_hgadMsg != NULL) {
        ::DeleteHandle(s_hgadMsg);
        s_hgadMsg = NULL;
    }
    
    s_pthrSRT = NULL;

    //
    // NOTE: It is important not to call DeleteHandle() on the SRT's Context
    // here since this function may be called by the application thread which
    // is already cleaning up the Context.
    //
}


/***************************************************************************\
*
* ResourceManager::SharedThreadProc
*
* SharedThreadProc() provides a "Shared Resource Thread" that is processes
* requests from other DirectUser threads.  The SRT is created in the first
* call to InitContextNL().
*
* NOTE: The SRT is ONLY created when SEPARATE or MULTIPLE threading models
* are used.  The SRT is NOT created for SINGLE threading model.
*
\***************************************************************************/

unsigned __stdcall 
ResourceManager::SharedThreadProc(
    IN  void * pvArg)
{
    UNREFERENCED_PARAMETER(pvArg);

    AssertMsg(s_dwSRTID == 0, "SRT should not already be initialized");
    s_dwSRTID = GetCurrentThreadId();

    Context * pctx;
    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_SEPARATE;
    ig.nMsgMode     = IGMM_ADVANCED;
    HRESULT hr      = InitContextNL(&ig, TRUE /* SRT */, &pctx);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Setup a Gadget to receive custom requests to execute on this thread.
    // Each of these requests uses a registered message.
    //

    if (((s_idCreateBuffer = RegisterGadgetMessage(&guidCreateBuffer)) == 0) ||
        ((s_idInitGdiplus = RegisterGadgetMessage(&guidInitGdiplus)) == 0) ||
        ((s_hgadMsg = CreateGadget(NULL, GC_MESSAGE, SharedEventProc, NULL)) == 0)) {

        hr = GetLastError();
        goto Exit;
    }


    //
    // The SRT is fully initialized and can start processing messages.  Signal 
    // the calling thread and start the message loop.
    //
    // NOTE: See MSDN docs for PostThreadMessage() that explain why we need the
    // extra PeekMessage() in the beginning to force User to create a queue for
    // us.
    //
    
    MSG msg;
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    Verify(SetEvent(s_hevReady));


    BOOL fQuit = FALSE;
    while ((!fQuit) && GetMessageEx(&msg, NULL, 0, 0)) {
        AssertMsg(IsMultiThreaded(), "Must remain multi-threaded if using SRT");

        if (msg.message == WM_QUIT) {
            fQuit = TRUE;
        }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    //
    // Uninitialize GDI+
    //
    // If GDI+ has been initialized on any thread, we need to uninitialize it
    // when the SRT is going away.
    //

    if (IsInitGdiPlus()) {
        (s_gpgso.NotificationUnhook)(s_gplToken);
    }


    hr = S_OK;

Exit:    
    //
    // The SRT is going away:
    // - Clean up remaining SRT data
    // - Destroy the SRT's Context
    //

    ResetSharedThread();
    DeleteHandle(pctx->GetHandle());

    return hr;
}


/***************************************************************************\
*
* ResourceManager::SharedEventProc
*
* SharedEventProc() processes LPC requests sent to the SRT.
*
* NOTE: The SRT is ONLY created when SEPARATE or MULTIPLE threading models
* are used.  The SRT is NOT created for SINGLE threading model.
*
\***************************************************************************/

HRESULT
ResourceManager::SharedEventProc(
    IN  HGADGET hgadCur,
    IN  void * pvCur,
    IN  EventMsg * pMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    UNREFERENCED_PARAMETER(pvCur);

    AssertMsg(IsMultiThreaded(), "Must remain multi-threaded if using SRT");

    if (pMsg->nMsg == s_idCreateBuffer) {
        //
        // Create a new bitmap
        //

        GMSG_CREATEBUFFER * pmsgCB = (GMSG_CREATEBUFFER *) pMsg;
        pmsgCB->hbmpNew = CreateCompatibleBitmap(pmsgCB->hdc, 
                pmsgCB->sizePxl.cx, pmsgCB->sizePxl.cy);

#if DBG
        if (pmsgCB->hbmpNew == NULL) {
            Trace("CreateCompatibleBitmap failed: LastError = %d\n", GetLastError());
        }
#endif // DBG
        return DU_S_COMPLETE;
    } else if (pMsg->nMsg == s_idInitGdiplus) {
        //
        // Initialize GDI+
        //

        (s_gpgso.NotificationHook)(&s_gplToken);

        return DU_S_COMPLETE;
    }

    return DU_S_NOTHANDLED;
}


/***************************************************************************\
*
* ResourceManager::InitContextNL
*
* InitContextNL() initializes a thread into either a new or existing 
* DirectUser Context.  The Context is valid in the Thread until it is 
* explicitely destroyed with ::DeleteHandle() or the thread exits.
*
* NOTE: It is VERY important that the first time this function is called is
* NOT in DllMain() because we need to initialize the SRT.  DllMain() 
* serializes access across all threads, so we will deadlock.  After the first
* Context is successfully created, additional Contexts can be created inside
* DllMain().
*
* <error>   DU_E_GENERIC</>
* <error>   E_OUTOFMEMORY</>
* <error>   E_NOTIMPL</>
* <error>   E_INVALIDARG</>
* <error>   DU_E_THREADINGALREADYSET</>
*
\***************************************************************************/

HRESULT
ResourceManager::InitContextNL(
    IN  INITGADGET * pInit,             // Context description
    IN  BOOL fSharedThread,             // Context is for the shared thread
    OUT Context ** ppctxNew)            // New context
{
    HRESULT hr  = DU_E_GENERIC;
    *ppctxNew   = NULL;

#if DBG_CHECK_CALLBACKS
    BOOL fInitMPH = FALSE;
#endif


    //
    // Can not initialize inside DllMain()
    //

    if (OS()->IsInsideLoaderLock()) {
        PromptInvalid("Can not initialize DirectUser inside DllMain()");
        return E_INVALIDARG;
    }


    //
    // If Context is already initialized, increment the number of times this
    // THREAD has been initialized.  We need to remember each thread 
    // individually.  Since we only lock individual threads, we don't need to
    // worry about synchronization yet.
    //

    if (IsInitContext()) {
        Thread * pthrExist = GetThread();
        AssertInstance(pthrExist);  // Initialized Context must already initialize Thread

        pthrExist->Lock();
        *ppctxNew = pthrExist->GetContext();
        return S_OK;
    }

    
    //
    // Before initializing the new Context, ensure that the Shared Resource 
    // Thread has been created.  We want to create the shared thread Context 
    // before creating this thread's Context so that as soon as we return, 
    // everything is valid.
    //
    // If we are initializing the Shared Resource Thread, don't take the lock.
    // This is because we are already inside the lock in InitContextNL() on 
    // another thread waiting for the SRT to initialize.
    //

    if (fSharedThread) {
        AssertMsg(s_pthrSRT == NULL, "Only should initialize a single SRT");
    } else {
        s_lockContext.Enter();
    }

#if DBG
    int DEBUG_cOldAppThreads = s_cAppThreads;
#endif

    if (pInit->nThreadMode != IGTM_NONE) {
        //
        // Setup the threading model.  By default, we start in multi-threading
        // model.  We can only change to single threaded if no threads are 
        // already initialized.
        //

        BOOL fAlreadyInit = (!s_lstAppThreads.IsEmpty()) && (s_pthrSRT == NULL);

        switch (pInit->nThreadMode)
        {
        case IGTM_SINGLE:
            if (fAlreadyInit) {
                hr = DU_E_THREADINGALREADYSET;
                goto RawErrorExit;
            } else {
                g_fThreadSafe = FALSE;
            }
            break;

        case IGTM_SEPARATE:
        case IGTM_MULTIPLE:
            if (!g_fThreadSafe) {
                hr = DU_E_THREADINGALREADYSET;
                goto RawErrorExit;
            }
            break;

        default:
            AssertMsg(0, "Unknown threading model");
            hr = E_INVALIDARG;
            goto RawErrorExit;
        }
    }


    if (IsMultiThreaded() && (!fSharedThread)) {
        hr = InitSharedThread();
        if (FAILED(hr)) {
            goto RawErrorExit;
        }
    }

    {
        DUserHeap * pHeapNew    = NULL;
        Context * pctxShare     = NULL;
        Context * pctxNew       = NULL;
        Context * pctxActual    = NULL;
        Thread * pthrNew        = NULL;
#if ENABLE_MPH
        BOOL fDanglingMPH       = FALSE;
#endif


        //
        // If the Context being created is separate, then it can't be shared.
        //

        if ((pInit->nThreadMode == IGTM_SEPARATE) && (pInit->hctxShare != NULL)) {
            PromptInvalid("Can not use IGTM_SEPARATE for shared Contexts");
            hr = E_INVALIDARG;
            goto RawErrorExit;
        }


        //
        // Initialize low-level resources (such as the heap).  If a Context is 
        // specified to share resources with, use the existing one.  If no Context 
        // is specified, need to create new resources.
        //
        // NOTE: If this is running on the main thread, the heap will already have
        // been created.
        //

        BOOL fThreadSafe;
        switch (pInit->nThreadMode)
        {
        case IGTM_SINGLE:
        case IGTM_SEPARATE:
            fThreadSafe = FALSE;
            break;

        default:
            fThreadSafe = TRUE;
        }

        DUserHeap::EHeap idHeap;
#ifdef _DEBUG

        idHeap = DUserHeap::idCrtDbgHeap;

#else // _DEBUG

        switch (pInit->nPerfMode)
        {
        case IGPM_SPEED:
#ifdef _X86_
            idHeap = DUserHeap::idRockAllHeap;
#else
            idHeap = DUserHeap::idNtHeap;
#endif
            break;

        case IGPM_BLEND:
            if (IsRemoteSession()) {
                idHeap = DUserHeap::idProcessHeap;
            } else {
#ifdef _X86_
                idHeap = DUserHeap::idRockAllHeap;
#else
                idHeap = DUserHeap::idNtHeap;
#endif
            }
            break;
            
        case IGPM_SIZE:
        default:            
            idHeap = DUserHeap::idProcessHeap;
            break;
        }

#endif // _DEBUG

        if (pInit->hctxShare != NULL) {
            BaseObject * pObj = BaseObject::ValidateHandle(pInit->hctxShare);
            if (pObj != NULL) {
                //
                // Note: We need to manually enter the Context here- can not use
                // a ContextLock object because the thread is not initialized yet.
                //

                pctxShare = CastContext(pObj);
                if (pctxShare == NULL) {
                    hr = E_INVALIDARG;
                    goto ErrorExit;
                }

                BOOL fError = FALSE;
                pctxShare->Enter();

                if (pctxShare->GetThreadMode() == IGTM_SEPARATE) {
                    PromptInvalid("Can not share with an IGTM_SEPARATE Context");
                    hr = E_INVALIDARG;
                    fError = TRUE;
                } else {
                    pctxShare->Lock();
                    DUserHeap * pHeapExist = pctxShare->GetHeap();
                    DUserHeap * pHeapTemp;  // Use temp b/c don't destroy if failure
                    VerifyMsgHR(CreateContextHeap(pHeapExist, fThreadSafe, idHeap, &pHeapTemp), "Always should be able to copy the heap");
                    VerifyMsg(pHeapTemp == pHeapExist, "Ensure heaps match");
                }

                pctxShare->Leave();

                if (fError) {
                    Assert(FAILED(hr));
                    goto ErrorExit;
                }
            }
        } else {
            if (FAILED(CreateContextHeap(NULL, fThreadSafe, idHeap, &pHeapNew))) {
                hr = E_OUTOFMEMORY;
                goto ErrorExit;
            }
        }

      
#if ENABLE_MPH
        //
        // Setup the WindowManagerHooks.  We do this BEFORE setting up the 
        // thread, since the MPH's will always be "uninit" in the Thread's
        // destructor.  However, until the thread is successfully setup, the
        // MPH's are dangling and need to be cleaned up manually.
        //

        if (pInit->nMsgMode == IGMM_STANDARD) {
            if (!InitMPH()) {
                hr = DU_E_CANNOTUSESTANDARDMESSAGING;
                goto ErrorExit;
            }
            fDanglingMPH = TRUE;

#if DBG_CHECK_CALLBACKS
            s_fBadMphInit = TRUE;
            fInitMPH = TRUE;
#endif            
        }
#endif


        //
        // Initialize the Thread
        //

        AssertMsg(!IsInitThread(), "Thread should not already be initialized");

        hr = Thread::Build(fSharedThread, &pthrNew);
        if (FAILED(hr)) {
            goto ErrorExit;
        }
        
        if (fSharedThread) {
            Assert(s_pthrSRT == NULL);
            s_pthrSRT = pthrNew;
        } else {
            s_lstAppThreads.Add(pthrNew);
            s_cAppThreads++;

#if DBG_CHECK_CALLBACKS
            s_cTotalAppThreads++;
#endif
        }
        
#if ENABLE_MPH
        fDanglingMPH = FALSE;
#endif


        //
        // Initialize the actual Context.
        //
        // NOTE: pHeapNew will only be initialized if we are building a new 
        // Context.  If we are linking into an existing Context, we do not
        // create a _new_ Context heap.
        //

        if (pctxShare == NULL) {
            AssertMsg(pHeapNew != NULL, "Must create a new heap for a new Context");

            hr = Context::Build(pInit, pHeapNew, &pctxNew);
            if (FAILED(hr)) {
                goto ErrorExit;
            }
            pctxActual = pctxNew;
        } else {
            //
            // Linking this thread to a shared Context, so just use the existing 
            // Context.  We have already Lock()'d the Context earlier.
            //

            AssertMsg(pHeapNew == NULL, "Should not create a new heap for existing Context");

            pctxShare->AddCurrentThread();
            pctxActual = pctxShare;
        }

        AssertMsg(fSharedThread || ((s_cAppThreads - DEBUG_cOldAppThreads) == 1), 
                "Should have created a single new app threads on success");
        
#if DBG_CHECK_CALLBACKS
        s_fBadMphInit = FALSE;
#endif

        if (!fSharedThread) {
            s_lockContext.Leave();

            //
            // NOTE: Can no longer goto ErrorExit or RawErrorExit for cleanup 
            // because we have left s_lockContext.
            //
        }
        *ppctxNew = pctxActual;

        return S_OK;

ErrorExit:
        //
        // NOTE: Do NOT destroy pctxNew on failure, since it was already 
        // attached to the newly created Thread object.  When this Thread is
        // unlocked (destroyed), it will also destroy the Context.
        //
        // If we try and unlock the Context here, it will be unlocked twice.
        // See Context::Context() for more information.
        //
        
        if (pthrNew != NULL) {
            xwDoThreadDestroyNL(pthrNew);
            pthrNew = NULL;
        }

        AssertMsg(DEBUG_cOldAppThreads == s_cAppThreads, 
                "Should have same number of app threads on failure");

#if ENABLE_MPH
        if (fDanglingMPH) {
#if DBG_CHECK_CALLBACKS
            if (UninitMPH()) {
                s_fBadMphInit = FALSE;
            }
#else // DBG_CHECK_CALLBACKS
            UninitMPH();
#endif // DBG_CHECK_CALLBACKS
        }
#endif // ENABLE_MPH

        if (pHeapNew != NULL) {
            DestroyContextHeap(pHeapNew);
            pHeapNew = NULL;
        }
    }

RawErrorExit:

#if DBG_CHECK_CALLBACKS
    if (fInitMPH) {
        if (s_fBadMphInit) {
            AlwaysPromptInvalid("Unsuccessfully uninitialized MPH on Context creation failure");
        }
    }
#endif // DBG_CHECK_CALLBACKS
    
    if (!fSharedThread) {
        s_lockContext.Leave();
    }

    AssertMsg(FAILED(hr), "ErrorExit requires a failure code");
    return hr;
}


/***************************************************************************\
*
* ResourceManager::InitComponentNL
*
* InitComponentNL() initializes an optional DirectUser component to be shared
* across all Contexts.  The component is valid until either it is explicitely
* uninitialized with UninitComponent() or the process ends.
*
* NOTE: InitComponentNL() doesn't actually synchronize on a Context, but needs
* a context to be initialized so that the threading model is determined.
*
* <error>   DU_E_GENERIC</>
* <error>   DU_E_CANNOTLOADGDIPLUS</>
*
\***************************************************************************/

HRESULT
ResourceManager::InitComponentNL(
    IN  UINT nOptionalComponent)        // Optional component to load
{
    //
    // NOTE: Initializing and unintializaing Components CAN NOT use the 
    // s_lockContext since they may destroy Threads.  This will call
    // xwNotifyThreadDestroyNL() to cleanup the thread's Context and would 
    // create a deadlock.  Therefore, we must be very careful when 
    // initializing and uninitializing components because Contexts may be 
    // created and destroyed in the middle of this.
    //

    HRESULT hr;

    AssertMsg(IsInitContext(), "Context must be initialized to determine threading model");

    s_lockComponent.Enter();

    switch (nOptionalComponent)
    {
    case IGC_DXTRANSFORM:
        hr = s_pData->manDX.Init();
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = s_pData->manDX.InitDxTx();
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = S_OK;
        break;

    case IGC_GDIPLUS:
        if (s_fInitGdiPlus) {
            hr = S_OK;  // GDI+ is already loaded
        } else {
            //
            // GDI+ has not already been loaded, so safely load and initialize 
            // it.
            //

            hr = DU_E_CANNOTLOADGDIPLUS;  // Assume failure unless pass all tests
            Gdiplus::GdiplusStartupInput gpgsi(NULL, TRUE);
            if (Gdiplus::GdiplusStartup(&s_gplToken, &gpgsi, &s_gpgso) == Gdiplus::Ok) {
                s_fInitGdiPlus = TRUE;
                RequestInitGdiplus();
                hr = S_OK;
            }
        }
        break;

    default:
        {
            hr = E_NOTIMPL;
            ComponentFactory * pfac = s_lstComponents.GetHead();
            while (pfac != NULL) {
                hr = pfac->Init(nOptionalComponent);
                if (hr != E_NOTIMPL) {
                    break;
                }

                pfac = pfac->GetNext();
            }
        }
    }

Exit:
    s_lockComponent.Leave();
    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitComponentNL
*
* UninitComponentNL() frees up resources associated with a previously 
* initialized optional component.
*
\***************************************************************************/

HRESULT
ResourceManager::UninitComponentNL(
    IN  UINT nOptionalComponent)        // Optional component to unload
{
    //
    // NOTE: See warning in InitComponent() about locks and re-entrancy issues.
    //

    HRESULT hr;
    s_lockComponent.Enter();

    switch (nOptionalComponent)
    {
    case IGC_DXTRANSFORM:
        s_pData->manDX.UninitDxTx();
        s_pData->manDX.Uninit();

        hr = S_OK;
        break;

    case IGC_GDIPLUS:
        //
        // GDI+ can not be uninitialized by the application.  Since various
        // DirectUser objects create and cache GDI+ objects, we have to 
        // postpone uninitializing GDI+ until all of the Contexts have been
        // destroyed.
        //

        hr = S_OK;
        break;

    default:
        {
            hr = E_NOTIMPL;
            ComponentFactory * pfac = s_lstComponents.GetHead();
            while (pfac != NULL) {
                hr = pfac->Init(nOptionalComponent);
                if (hr != E_NOTIMPL) {
                    break;
                }

                pfac = pfac->GetNext();
            }
        }
    }

    s_lockComponent.Leave();

    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitAllComponentsNL
*
* UninitAllComponentsNL() uninitializes all dynamically initialized 
* components and other global services.  This is called when all application
* threads have been destroyed and DirectUser is shutting down.  
*
* NOTE: This may or may not happen inside DllMain().
*
\***************************************************************************/

void        
ResourceManager::UninitAllComponentsNL()
{
    s_lockComponent.Enter();

    s_pData->manDX.Uninit();

    if (IsInitGdiPlus()) {
        if (!IsMultiThreaded()) {
            //
            // GDI+ has been initialized, but we are running in single 
            // threaded mode, so we need to uninitialize GDI+ here 
            // because there is no SRT.
            //

            (s_gpgso.NotificationUnhook)(s_gplToken);
        }

        Gdiplus::GdiplusShutdown(s_gplToken);
    }

    s_lockComponent.Leave();
}


/***************************************************************************\
*
* ResourceManager::RegisterComponentFactory
*
* RegisterComponentFactory() adds a ComponentFactory to the list of 
* factories queried when a dynamic component needs to be initialized.
*
\***************************************************************************/

void
ResourceManager::RegisterComponentFactory(
    IN  ComponentFactory * pfac)
{
    s_lstComponents.Add(pfac);
}


/***************************************************************************\
*
* ResourceManager::InitSharedThread
*
* InitSharedThread() ensures that the SRT for the process has been 
* initialized.  If it has not already been initialized, the SRT will be
* created and initialized.  The SRT is valid until the process shuts down.
*
* NOTE: It is VERY important that the SRT is NOT initialized while processing
* DllMain() because it creates a new thread and blocks until the thread is
* ready to process requests.  DllMain() serializes access across all threads,
* so we will deadlock.
*
\***************************************************************************/

HRESULT
ResourceManager::InitSharedThread()
{
    AssertMsg(IsMultiThreaded(), "Only initialize when multi-threaded");

    if (s_hthSRT != NULL) {
        return S_OK;
    }

    //
    // TODO: Need to LoadLibrary() to keep the SRT from going away underneath
    // us.  We also need to FreeLibrary(), but can not do this inside DllMain().
    // Also need to modify all exit paths to properly FreeLibrary() after this.


    //
    // Create a thread to handle these requests.  Wait until an event has been
    // signaled that the thread is ready to start receiving events.  We need to 
    // do this to ensure that the msgid's have been properly setup.
    //
    // This function is already called inside the lock, so we don't need to take
    // it again.
    //

    HRESULT hr;
    HINSTANCE hinstLoad = NULL;

    AssertMsg(s_hthSRT == NULL, "Ensure Thread is not already initialized");

    if (s_hevReady == NULL) {
        s_hevReady = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (s_hevReady == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    AssertMsg(WaitForSingleObject(s_hevReady, 0) == WAIT_TIMEOUT, "Event was not Reset() after used last");

    //
    // Start the Thread.  DirectUser uses the CRT, so we use _beginthreadex().
    //

    hinstLoad = LoadLibrary("DUser.dll");
    AssertMsg(hinstLoad == g_hDll, "Must load the same DLL");
    
    unsigned thrdaddr;
    s_hthSRT = (HANDLE) _beginthreadex(NULL, 0, SharedThreadProc, NULL, 0, &thrdaddr);
    if (s_hthSRT == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    HANDLE rgh[2];
    rgh[0]  = s_hevReady;
    rgh[1]  = s_hthSRT;

    switch (WaitForMultipleObjects(_countof(rgh), rgh, FALSE, INFINITE))
    {
    case WAIT_OBJECT_0:
        //
        // SRT is now properly setup and ready to process requests.
        //
        hr = S_OK;
        break;
        
    case WAIT_OBJECT_0 + 1:
        //
        // SRT thread was successfully created, but it failed to setup.
        //

        {
            DWORD dwExitCode;
            Verify(GetExitCodeThread(s_hthSRT, &dwExitCode));
            hr = (HRESULT) dwExitCode;


            //
            // NOTE: Calling UninitSharedThread() will clean up both the 
            // dangling thread handle and DLL hinstances.
            //

            UninitSharedThread(TRUE /* Aborting */);
        }
        
        break;

    default:
        AssertMsg(0, "Unknown return code");
        hr = E_FAIL;
    }

    ResetEvent(s_hevReady);  // Clean up the event for the next user / next time

    //
    // TODO: May need to change to have a message loop in 
    // MsgWaitForMultipleObjects() so that we can process UI requests while this
    // thread is being created.  It may actually be important if this thread 
    // creates objects that may signal other objects in other threads and could
    // potentially dead-lock.
    //

    hinstLoad = NULL;

Exit:
    //
    // Need to FreeLibrary() on any errors.
    //
    
    if (hinstLoad != NULL) {
        FreeLibrary(hinstLoad);
    }
    
    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitSharedThread
*
* UninitSharedThread() uninitializes the SRT and is called when all 
* application threads have been uninitialized.
*
\***************************************************************************/

void
ResourceManager::UninitSharedThread(
    IN  BOOL fAbortInit)                // Aborting SRT thread initialization
{
    AssertMsg(IsMultiThreaded(), "Only initialize when multi-threaded");

    //    
    // When destroying the SRT, we need to wait until the SRT has properly 
    // cleaned up.  Because we are waiting, we need to worry about dead-locks.
    // Practically, this means that we can not be inside DllMain(), because
    // the Loader Lock will be a problem when the SRT tries to unload any
    // dynamically loaded DLL's.
    //
    // To ensure against this, we check that the caller doesn't call 
    // DeleteHandle() inside the Loader Lock.  We will still allow it (and 
    // dead-lock the app), but we Prompt and notify the developer that their
    // application is busted and needs to properly call DeleteHandle() before
    // entering the Loader Lock.
    //

    AssertMsg(s_dwSRTID != 0, "Must have valid SRT Thread ID");

    if (!fAbortInit) {
        Verify(PostThreadMessage(s_dwSRTID, WM_QUIT, 0, 0));
        WaitForSingleObject(s_hthSRT, INFINITE);
    }

    FreeLibrary(g_hDll);
    
    CloseHandle(s_hthSRT);
    s_hthSRT = NULL;
}


/***************************************************************************\
*
* ResourceManager::xwNotifyThreadDestroyNL
*
* xwNotifyThreadDestroyNL() is called by DllMain when a thread has been 
* destroyed.  This provides DirectUser an opportunity to clean up resources
* associated with the Thread before all Thread's are cleaned up at the end
* of the application.
*
\***************************************************************************/

void        
ResourceManager::xwNotifyThreadDestroyNL()
{
    Thread * pthrDestroy = RawGetThread();
    if (pthrDestroy != NULL) {
        BOOL fValid = pthrDestroy->Unlock();
        if (!fValid) {
            //
            // The Thread has finally been unlocked, so we can start its 
            // destruction
            //

            BOOL fSRT = pthrDestroy->IsSRT();
            if (!fSRT) {
                s_lockContext.Enter();
            }

            xwDoThreadDestroyNL(pthrDestroy);

            if (!fSRT) {
                s_lockContext.Leave();
            }
        }
    }
}


/***************************************************************************\
*
* ResourceManager::xwDoThreadDestroyNL
*
* xwDoThreadDestroyNL() provides the heart of thread destruction.  This may
* be called in several situations:
* - When DirectUser notices a thread has been destroyed in DllMain()
* - When the application calls DeleteHandle() on a Context.
* - When DirectUser is destroying the ResourceManager in DllMain() and is
*   destroying any outstanding threads.
*
\***************************************************************************/

void        
ResourceManager::xwDoThreadDestroyNL(
    IN  Thread * pthrDestroy)           // Thread to destroy
{
    //
    // Can not uninitialize inside DllMain(), but we can't just return.  
    // Instead, the process is very likely to dead-lock.
    //

    if (OS()->IsInsideLoaderLock()) {
        PromptInvalid("Can not uninitialize DirectUser inside DllMain()");
    }

    
    BOOL fSRT = pthrDestroy->IsSRT();

    //
    // Destroy the Thread object and reset the t_pThread pointer.  As each is 
    // extracted, set the current Thread and Context pointers so that the 
    // cleanup code can reference these.  When finished, set t_pThread and 
    // t_pContext to NULL since there is no Thread or Context for this thread.
    //

#if USE_DYNAMICTLS
    Verify(TlsSetValue(g_tlsThread, pthrDestroy));
    Context * pContext = pthrDestroy->GetContext();
    if (pContext != NULL) {
        ForceSetContextHeap(pContext->GetHeap());
    }
#else
    t_pThread   = pthrDestroy;
    t_pContext  = pthrDestroy->GetContext();
    if (t_pContext != NULL) {
        ForceSetContextHeap(t_pContext->GetHeap());
    }
#endif

    if (fSRT) {
        ResetSharedThread();
    } else {
        s_lstAppThreads.Unlink(pthrDestroy);
    }
    
    ProcessDelete(Thread, pthrDestroy);     // This is the "xw" function

    ForceSetContextHeap(NULL);
#if USE_DYNAMICTLS
    pContext = NULL;
    Verify(TlsSetValue(g_tlsThread, NULL));
#else
    t_pContext  = NULL;
    t_pThread   = NULL;
#endif


    //
    // Clean-up when there are no longer any application threads:
    // - Destroy the SRT
    // - Destroy global services / managers
    //

    if (!fSRT) {
        if (--s_cAppThreads == 0) {
            if (IsMultiThreaded()) {
                UninitSharedThread(FALSE /* Proper shutdown */);
            } else {
                AssertMsg(s_hthSRT == NULL, "Should never have initialized SRT for single-threaded");
            }

            UninitAllComponentsNL();
        }
    } 
}


//------------------------------------------------------------------------------
HBITMAP     
ResourceManager::RequestCreateCompatibleBitmap(
    IN  HDC hdc, 
    IN  int cxPxl, 
    IN  int cyPxl)
{
    if (IsMultiThreaded()) {
        GMSG_CREATEBUFFER msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = s_idCreateBuffer;
        msg.hgadMsg     = s_hgadMsg;

        msg.hdc         = hdc;
        msg.sizePxl.cx  = cxPxl;
        msg.sizePxl.cy  = cyPxl;
        msg.hbmpNew     = NULL;

        if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
            return msg.hbmpNew;
        }

        OutputDebugString("ERROR: RequestCreateCompatibleBitmap failed\n");
        return NULL;
    } else {
        return CreateCompatibleBitmap(hdc, cxPxl, cyPxl);
    }
}


//------------------------------------------------------------------------------
void
ResourceManager::RequestInitGdiplus()
{
    AssertMsg(s_fInitGdiPlus, "Only should call when GDI+ is just initialized");

    if (IsMultiThreaded()) {
        EventMsg msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = s_idInitGdiplus;
        msg.hgadMsg     = s_hgadMsg;

        if (DUserSendEvent(&msg, 0) != DU_S_COMPLETE) {
            OutputDebugString("ERROR: RequestInitGdiplus failed\n");
        }
    } else {
        (s_gpgso.NotificationHook)(&s_gplToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\osal.inl ===
/***************************************************************************\
*
* File: OSAL.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__OSAL_inl__INCLUDED)
#define SERVICES__OSAL_inl__INCLUDED
#pragma once

struct OSInfo
{
    BOOL    fUnicode;               // Unicode support is available
    BOOL    fXForm;                 // GDI X-Forms are avaialble
    BOOL    fQInputAvailableFlag;   // MWMO_INPUTAVAILABLE is available
};

extern  OSInfo  g_OSI;
extern  OSAL *  g_pOS;

//------------------------------------------------------------------------------
inline OSAL * 
OS()
{
    AssertMsg(g_pOS != NULL, "OSAL must be initialized by now");
    return g_pOS;
}


//------------------------------------------------------------------------------
inline BOOL
SupportUnicode()
{
    return g_OSI.fUnicode;
}


//------------------------------------------------------------------------------
inline BOOL
SupportXForm()
{
    return g_OSI.fXForm;
}


//------------------------------------------------------------------------------
inline BOOL
SupportQInputAvailable()
{
    return g_OSI.fQInputAvailableFlag;
}


//------------------------------------------------------------------------------
inline BOOL        
OSAL::IsWin98orWin2000(OSVERSIONINFO * povi)
{
    return povi->dwMajorVersion >= 5;
}


//------------------------------------------------------------------------------
inline BOOL        
OSAL::IsWhistler(OSVERSIONINFO * povi)
{
    return (povi->dwMajorVersion >= 5) && (povi->dwMinorVersion >= 1);
}


//------------------------------------------------------------------------------
inline BOOL
IsRemoteSession()
{
    return GetSystemMetrics(SM_REMOTESESSION);
}

#endif // SERVICES__OSAL_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Public_h__INCLUDED)
#define SERVICES__Public_h__INCLUDED

#include "ComManager.h"
#include "Context.h"
#include "DxManager.h"
#include "Buffer.h"
#include "GdiCache.h"
#include "Surface.h"
#include "OSAL.h"
#include "Thread.h"
#include "ResourceManager.h"
#include "TicketManager.h"
#include "Globals.h"
#include "Hook.h"

#endif // SERVICES__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\resourcemanager.inl ===
/***************************************************************************\
*
* File: ResourceManager.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ResourceManager_inl__INCLUDED)
#define SERVICES__ResourceManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline RMData *    
ResourceManager::GetData()
{
    AssertMsg(s_pData != NULL, "Data must be initialized before using");
    return s_pData;
}


//------------------------------------------------------------------------------
inline DxManager *     
GetDxManager()
{
    return &(ResourceManager::GetData()->manDX);
}


#endif // SERVICES__ResourceManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\resourcemanager.h ===
/***************************************************************************\
*
* File: ResourceManager.h
*
* Description:
* This file declares the ResourceManager used to setup and maintain all 
* Thread, Contexts, and other resources used by and with DirectUser.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ResourceManager_h__INCLUDED)
#define SERVICES__ResourceManager_h__INCLUDED
#pragma once

#include "ComManager.h"
#include "DxManager.h"

struct RMData
{
    DxManager   manDX;
};


class ComponentFactory : public ListNodeT<ComponentFactory>
{
public:
    virtual HRESULT     Init(UINT nComponent) PURE;
};

/***************************************************************************\
*
* ResourceManager manages all shared resources within DirectUser, including
* initializing Threads and Contexts.
*
\***************************************************************************/

class ResourceManager
{
// Construction
public:
    static  HRESULT     Create();
    static  void        xwDestroy();

// Operations
public:
    static  HRESULT     InitContextNL(INITGADGET * pInit, BOOL fSharedThread, Context ** ppctxNew);
    static  HRESULT     InitComponentNL(UINT nOptionalComponent);
    static  HRESULT     UninitComponentNL(UINT nOptionalComponent);
    static  void        UninitAllComponentsNL();
    static  void        RegisterComponentFactory(ComponentFactory * pfac);
    inline static  
            BOOL        IsInitGdiPlus() { return s_fInitGdiPlus; }

    static  void        xwNotifyThreadDestroyNL();

    static  RMData *    GetData();

    static  HBITMAP     RequestCreateCompatibleBitmap(HDC hdc, int cxPxl, int cyPxl);
    static  void        RequestInitGdiplus();

// Implementation
protected:
    static  HRESULT     InitSharedThread();
    static  void        UninitSharedThread(BOOL fAbortInit);
    static  void        ResetSharedThread();
    static  unsigned __stdcall 
                        SharedThreadProc(void * pvArg);
    static  HRESULT CALLBACK 
                        SharedEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pMsg);
    static  void        xwDoThreadDestroyNL(Thread * pthrDestroy);

// Data
protected:
    static  long        s_fInit;        // RM has been initialized
    static  HANDLE      s_hthSRT;       // Shared Resource Thread
    static  DWORD       s_dwSRTID;      // Thread ID of SRT
    static  HANDLE      s_hevReady;     // SRT has been initialized
    static  HGADGET     s_hgadMsg;
    static  RMData *    s_pData;        // Dynamic RM data
    static  CritLock    s_lockContext;  // Context creation / destruction
    static  CritLock    s_lockComponent;// Component creation / destruction
    static  Thread *    s_pthrSRT;      // SRT thread
    static  GList<Thread> s_lstAppThreads; 
                                        // Set of non-SRT DU-enabled threads
    static  int         s_cAppThreads;  // Non-SRT thread count

#if DBG_CHECK_CALLBACKS
    static  int         s_cTotalAppThreads;
                                        // Number of application threads created during lifetime
    static  BOOL        s_fBadMphInit;  // Initialization of MPH failed
#endif

    // Requests
    static  MSGID       s_idCreateBuffer; // Create a new bitmap buffer
    static  MSGID       s_idInitGdiplus;  // Initialize GDI+

    // Optional Components
    static  GList<ComponentFactory>
                        s_lstComponents; // Dynamic component initializers
    static  BOOL        s_fInitGdiPlus; // GDI+ is initialized
    static  ULONG_PTR   s_gplToken;
    static  Gdiplus::GdiplusStartupOutput 
                        s_gpgso;
};

inline  DxManager *     GetDxManager();

#include "ResourceManager.inl"

#endif // SERVICES__ResourceManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\services.h ===
/***************************************************************************\
*
* File: Services.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Services_h__INCLUDED)
#define SERVICES__Services_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#include <DUser.h>

#include <DUserBaseP.h>
#include "TicketManager.h"

#include "Globals.h"

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Services Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // SERVICES__Services_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\osal.cpp ===
/***************************************************************************\
*
* File: OSAL.cpp
*
* Description:
* OSAL.cpp implements the process-wide Operating System Abstraction Layer
* that allows DirectUser to run on different platforms.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "OSAL.h"

#define ENABLE_WINNT        1

/***************************************************************************\
*****************************************************************************
*
* Define OSAL's for different operating systems.
*
*****************************************************************************
\***************************************************************************/

#if ENABLE_WINNT

//------------------------------------------------------------------------------
class WinNT : public OSAL
{
// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int);
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *);
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *);
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE);
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld);
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld);
    virtual void        RotateDC(HDC hdc, float flRotationRad);
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY);
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY);
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxfOld);
    virtual void        SetIdentityTransform(HDC hdc);

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock();
};

#endif


//------------------------------------------------------------------------------
class Win9x : public OSAL
{
// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int);
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *);
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *);
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE);
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld);
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld);
    virtual void        RotateDC(HDC hdc, float flRotationRad);
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY);
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY);
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxfOld);
    virtual void        SetIdentityTransform(HDC hdc);

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock();
};


/***************************************************************************\
*****************************************************************************
*
* String Conversion Macros
*
* These macros are extensions of the normal ATLCONV that are designed to
* take the length of the string as a parameter instead of computing it.
* This gives better performance, and gives parity on platforms when the
* string has embedded '\0's.
*
*****************************************************************************
\***************************************************************************/

#ifdef _CONVERSION_USES_THREAD_LOCALE
	#define W2AN(lpw, cch) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (cch+1)*2,\
			ATLW2AHELPER((LPSTR) alloca(_convert), _lpw, _convert, _acp)))
#else
	#define W2AN(lpw, cch) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (cch+1)*2,\
			ATLW2AHELPER((LPSTR) alloca(_convert), _lpw, _convert)))
#endif


/***************************************************************************\
*****************************************************************************
*
* class OSAL
*
*****************************************************************************
\***************************************************************************/

OSAL *      g_pOS = NULL;
OSInfo      g_OSI;
PTOP_LEVEL_EXCEPTION_FILTER g_pfnRtlUnhandledExceptionFilter = NULL;
PRTL_IS_THREAD_WITHIN_LOADER_CALLOUT g_pfnRtlIsThreadWithinLoaderCallout = NULL;

class OSALCleanup
{
public:
    ~OSALCleanup()
    {
        ProcessDelete(OSAL, g_pOS);
        g_pOS = NULL;
    };
} g_OSALCleanup;


//------------------------------------------------------------------------------
HRESULT
OSAL::Init()
{
    AssertMsg(g_pOS == NULL, "Only init one time");

    OSVERSIONINFO ovi;
    ZeroMemory(&ovi, sizeof(ovi));
    ovi.dwOSVersionInfoSize = sizeof(ovi);

    VerifyMsg(GetVersionEx(&ovi), "Must always be able to get the version");

    g_OSI.fQInputAvailableFlag = IsWin98orWin2000(&ovi);

#if ENABLE_WINNT
    if (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        //
        // Running on Win9x, so don't have UNICODE
        //

        g_OSI.fUnicode  = FALSE;
        g_OSI.fXForm    = FALSE;
        g_pOS           = ProcessNew(Win9x);
    } else if (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        //
        // Running on NT, so have UNICODE
        //

        g_OSI.fUnicode  = TRUE;
        g_OSI.fXForm    = TRUE;
        g_pOS           = ProcessNew(WinNT);

        HINSTANCE hinst = LoadLibrary("ntdll.dll");
        if (hinst != NULL) {
            g_pfnRtlUnhandledExceptionFilter = (PTOP_LEVEL_EXCEPTION_FILTER)
                    GetProcAddress(hinst, "RtlUnhandledExceptionFilter");
            g_pfnRtlIsThreadWithinLoaderCallout =
                    (PRTL_IS_THREAD_WITHIN_LOADER_CALLOUT)GetProcAddress(hinst, "RtlIsThreadWithinLoaderCallout");
        }
    } else {
        AssertMsg(0, "Unsupported OS");
        return E_NOTIMPL;
    }
#else  // ENABLE_WINNT
    g_OSI.fUnicode  = FALSE;
    g_OSI.fXForm    = FALSE;
    g_pOS           = ProcessNew(Win9x);
#endif  // ENABLE_WINNT

    return g_pOS != NULL ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
LONG WINAPI
StdExceptionFilter(PEXCEPTION_POINTERS pei)
{
    AutoTrace("ERROR: Unhandled exception during callback.\n");
    AutoTrace("ERROR: This is not a problem with DirectUser.\n");

    //
    // Output Exception information
    //

    LONG nResult;

    if (g_pfnRtlUnhandledExceptionFilter != NULL) {
        nResult = (g_pfnRtlUnhandledExceptionFilter)(pei);
    } else {
        AutoTrace(" *** enter .exr %p for the exception record\n", pei->ExceptionRecord);
        AutoTrace(" *** enter .cxr %p for the context\n", pei->ContextRecord);

        nResult = EXCEPTION_CONTINUE_SEARCH;
    }

    if (nResult == EXCEPTION_CONTINUE_SEARCH) {
        return UnhandledExceptionFilter(pei);
    } else {
        return nResult;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class WinNT
*
*****************************************************************************
\***************************************************************************/

#if ENABLE_WINNT

//------------------------------------------------------------------------------
int
WinNT::DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    return ::DrawTextW(hDC, lpString, nCount, lpRect, uFormat);
}


//------------------------------------------------------------------------------
BOOL
WinNT::TextOut(HDC hdc, int x, int y, LPCWSTR psz, int cch)
{
    return ::TextOutW(hdc, x, y, psz, cch);
}


//------------------------------------------------------------------------------
BOOL
WinNT::ExtTextOut(HDC hdc, int x, int y, UINT fuOptions, const RECT * prc, LPCWSTR psz, int cch, const int * pDx)
{
    return ::ExtTextOutW(hdc, x, y, fuOptions, prc, psz, cch, pDx);
}


//------------------------------------------------------------------------------
HFONT
WinNT::CreateFontIndirect(CONST LOGFONTW * plf)
{
    return ::CreateFontIndirectW(plf);
}


//------------------------------------------------------------------------------
BOOL
WinNT::GetTextExtentPoint32(HDC hdc, LPCWSTR psz, int cch, LPSIZE psize)
{
    return ::GetTextExtentPoint32W(hdc, psz, cch, psize);
}


//------------------------------------------------------------------------------
BOOL
WinNT::GetTextExtentExPoint(HDC hdc, LPCWSTR psz, int cch, int nMax,
        LPINT pnFit, LPINT apDx, LPSIZE psize)
{
    return ::GetTextExtentExPointW(hdc, psz, cch, nMax, pnFit, apDx, psize);
}


//------------------------------------------------------------------------------
void
WinNT::PushXForm(HDC hdc, XFORM * pxfOld)
{
    ::GetWorldTransform(hdc, pxfOld);
}


//------------------------------------------------------------------------------
void
WinNT::PopXForm(HDC hdc, const XFORM * pxfOld)
{
    ::SetWorldTransform(hdc, pxfOld);
}


//------------------------------------------------------------------------------
void
WinNT::RotateDC(HDC hdc, float flRotationRad)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    float flCos     = (float) cos(flRotationRad);
    float flSin     = (float) sin(flRotationRad);

    XFORM xf;
    xf.eM11 = flCos;
    xf.eM12 = flSin;
    xf.eM21 = - flSin;
    xf.eM22 = flCos;
    xf.eDx  = 0;
    xf.eDy  = 0;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void
WinNT::ScaleDC(HDC hdc, float flScaleX, float flScaleY)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    XFORM xf;
    xf.eM11 = flScaleX;
    xf.eM12 = 0;
    xf.eM21 = 0;
    xf.eM22 = flScaleY;
    xf.eDx  = 0;
    xf.eDy  = 0;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void
WinNT::TranslateDC(HDC hdc, float flOffsetX, float flOffsetY)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    XFORM xf;
    xf.eM11 = 1.0;
    xf.eM12 = 0;
    xf.eM21 = 0;
    xf.eM22 = 1.0;
    xf.eDx  = flOffsetX;
    xf.eDy  = flOffsetY;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void
WinNT::SetWorldTransform(HDC hdc, const XFORM * pxf)
{
    ::SetWorldTransform(hdc, pxf);
}


//------------------------------------------------------------------------------
void
WinNT::SetIdentityTransform(HDC hdc)
{
    ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
}


//------------------------------------------------------------------------------
BOOL
WinNT::IsInsideLoaderLock()
{
    if (g_pfnRtlIsThreadWithinLoaderCallout != NULL) {
        return (*g_pfnRtlIsThreadWithinLoaderCallout)() ? TRUE : FALSE;
    } else {
        PRTL_CRITICAL_SECTION pCS;
        /*
         * If we failed to find this export, then fallback to our bogus, XP
         * behavior where we explicitly check the loader lock.
         */
        pCS = reinterpret_cast<PRTL_CRITICAL_SECTION>(NtCurrentPeb()->LoaderLock);
        return (HandleToUlong(pCS->OwningThread) == GetCurrentThreadId());
    }
}


#endif  // ENABLE_WINNT


/***************************************************************************\
*****************************************************************************
*
* class Win9x
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
int
Win9x::DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    USES_CONVERSION;
    return ::DrawTextA(hDC, W2AN(lpString, nCount), nCount, lpRect, uFormat);
}


//------------------------------------------------------------------------------
BOOL
Win9x::TextOut(HDC hdc, int x, int y, LPCWSTR psz, int cch)
{
    return ::TextOutW(hdc, x, y, psz, cch);
}


//------------------------------------------------------------------------------
BOOL
Win9x::ExtTextOut(HDC hdc, int x, int y, UINT fuOptions, const RECT * prc, LPCWSTR psz, int cch, const int * pDx)
{
    return ::ExtTextOutW(hdc, x, y, fuOptions, prc, psz, cch, pDx);
}


//------------------------------------------------------------------------------
HFONT
Win9x::CreateFontIndirect(CONST LOGFONTW * plf)
{
    USES_CONVERSION;

    LOGFONT lf;
    lf.lfHeight         = plf->lfHeight;
    lf.lfWidth          = plf->lfWidth;
    lf.lfEscapement     = plf->lfEscapement;
    lf.lfOrientation    = plf->lfOrientation;
    lf.lfWeight         = plf->lfWeight;
    lf.lfItalic         = plf->lfItalic;
    lf.lfUnderline      = plf->lfUnderline;
    lf.lfStrikeOut      = plf->lfStrikeOut;
    lf.lfCharSet        = plf->lfCharSet;
    lf.lfOutPrecision   = plf->lfOutPrecision;
    lf.lfClipPrecision  = plf->lfClipPrecision;
    lf.lfQuality        = plf->lfQuality;
    lf.lfPitchAndFamily = plf->lfPitchAndFamily;
    AtlW2AHelper(lf.lfFaceName, plf->lfFaceName, lstrlenW(plf->lfFaceName) + 1);

    return ::CreateFontIndirectA(&lf);
}


//------------------------------------------------------------------------------
BOOL
Win9x::GetTextExtentPoint32(HDC hdc, LPCWSTR psz, int cch, LPSIZE psize)
{
    USES_CONVERSION;
    return ::GetTextExtentPoint32A(hdc, W2AN(psz, cch), cch, psize);
}


//------------------------------------------------------------------------------
BOOL
Win9x::GetTextExtentExPoint(HDC hdc, LPCWSTR psz, int cch, int nMax,
        LPINT pnFit, LPINT apDx, LPSIZE psize)
{
    USES_CONVERSION;
    return ::GetTextExtentExPointA(hdc, W2AN(psz, cch), cch, nMax, pnFit, apDx, psize);
}


//------------------------------------------------------------------------------
void
Win9x::PushXForm(HDC hdc, XFORM * pxfOld)
{
    POINT pt;
    ::GetWindowOrgEx(hdc, &pt);
    pxfOld->eM11    = 1.0f;
    pxfOld->eM12    = 0.0f;
    pxfOld->eM21    = 0.0f;
    pxfOld->eM22    = 1.0f;
    pxfOld->eDx     = (float) pt.x;
    pxfOld->eDy     = (float) pt.y;
}


//------------------------------------------------------------------------------
void
Win9x::PopXForm(HDC hdc, const XFORM * pxfOld)
{
    POINT pt;
    pt.x    = (long) pxfOld->eDx;
    pt.y    = (long) pxfOld->eDy;
    ::SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
}


//------------------------------------------------------------------------------
void
Win9x::RotateDC(HDC hdc, float flRotationRad)
{
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(flRotationRad);
}


//------------------------------------------------------------------------------
void
Win9x::ScaleDC(HDC hdc, float flScaleX, float flScaleY)
{
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(flScaleX);
    UNREFERENCED_PARAMETER(flScaleY);
}


//------------------------------------------------------------------------------
void
Win9x::TranslateDC(HDC hdc, float flOffsetX, float flOffsetY)
{
    ::OffsetWindowOrgEx(hdc, -(int) flOffsetX, -(int) flOffsetY, NULL);
}


//------------------------------------------------------------------------------
void
Win9x::SetWorldTransform(HDC hdc, const XFORM * pxf)
{
    ::SetWindowOrgEx(hdc, -(int) pxf->eDx, -(int) pxf->eDy, NULL);
}


//------------------------------------------------------------------------------
void
Win9x::SetIdentityTransform(HDC hdc)
{
    ::SetWindowOrgEx(hdc, 0, 0, NULL);
}


//------------------------------------------------------------------------------
BOOL
Win9x::IsInsideLoaderLock()
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\stdafx.h ===
#if !defined(SERVICES__StdAfx_h__INCLUDED)
#define SERVICES__StdAfx_h__INCLUDED
#pragma once

#include "CommonStdAfx.h"
#include <atlconv.h>            // String conversion routines

#endif // SERVICES__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\surface.inl ===
#if !defined(SERVICES__Surface_inl__INCLUDED)
#define SERVICES__Surface_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline DuSurface::EType
DuSurface::GetSurfaceType(UINT nSurfaceType)
{
    AssertMsg(stDC == GSURFACE_HDC, "ID's must match");
    return (EType) nSurfaceType;
}


//------------------------------------------------------------------------------
inline UINT
DuSurface::GetSurfaceType(DuSurface::EType type)
{
    AssertMsg(stDC == GSURFACE_HDC, "ID's must match");
    return (UINT) type;
}


//------------------------------------------------------------------------------
inline HDC
DuDCSurface::GetHDC()
{
    return m_hdc;
}


//------------------------------------------------------------------------------
inline Gdiplus::Graphics *
DuGpSurface::GetGraphics()
{
    return m_pgpgr;
}


//------------------------------------------------------------------------------
inline
HDC
CastHDC(DuSurface * psrf)
{
    AssertMsg(psrf->GetType() == DuSurface::stDC, "Must be an HDC surface");
    return ((DuDCSurface *) psrf)->GetHDC();
}


//------------------------------------------------------------------------------
inline
Gdiplus::Graphics *
CastGraphics(DuSurface * psrf)
{
    AssertMsg(psrf->GetType() == DuSurface::stGdiPlus, "Must be a GDI+ surface");
    return ((DuGpSurface *) psrf)->GetGraphics();
}


#endif // SERVICES__Surface_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\surface.h ===
#if !defined(SERVICES__Surface_h__INCLUDED)
#define SERVICES__Surface_h__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* Pure Virtual Base Classes
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuSurface
{
public:
    virtual void        Destroy() PURE;

    enum EType
    {
        stDC        = GSURFACE_HDC,
        stGdiPlus   = GSURFACE_GPGRAPHICS
    };

    virtual EType       GetType() const PURE;
    virtual void        SetIdentityTransform() PURE;
    virtual void        SetWorldTransform(const XFORM * pxf) PURE;
    virtual void *      Save() PURE;
    virtual void        Restore(void * pvState) PURE;

    inline static DuSurface::EType       
                        GetSurfaceType(UINT nSurfaceType);
    inline static UINT  GetSurfaceType(DuSurface::EType type);
};


//------------------------------------------------------------------------------
class DuRegion
{
public:
    virtual void        Destroy() PURE;

    virtual DuSurface::EType
                        GetType() const PURE;
};


/***************************************************************************\
*****************************************************************************
*
* GDI (Win32) Specific Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuDCSurface : public DuSurface
{
public:
    enum ESource
    {
        srcTempDC,
        srcCompatibleDC
    };
            
    static  HRESULT     Build(ESource src, DuDCSurface ** ppsrfNew);
    static  HRESULT     Build(HDC hdc, DuDCSurface ** ppsrfNew);
    virtual void        Destroy();

    inline  HDC         GetHDC();

    virtual EType       GetType() const { return DuSurface::stDC; }
    virtual void        SetIdentityTransform();
    virtual void        SetWorldTransform(const XFORM * pxf);
    virtual void *      Save();
    virtual void        Restore(void * pvState);
    
protected:
            HDC         m_hdc;
            BOOL        m_fTempDC:1;
            BOOL        m_fCompatibleDC:1;
};


/***************************************************************************\
*****************************************************************************
*
* GDI+ Specific Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuGpSurface : public DuSurface
{
public:
    static  HRESULT     Build(Gdiplus::Graphics * pgpgr, DuGpSurface ** ppsrfNew);
    virtual void        Destroy();

    inline  Gdiplus::Graphics *
                        GetGraphics();

    virtual EType       GetType() const { return DuSurface::stGdiPlus; }
    virtual void        SetIdentityTransform();
    virtual void        SetWorldTransform(const XFORM * pxf);
    virtual void *      Save();
    virtual void        Restore(void * pvState);
    
protected:
            Gdiplus::Graphics *
                        m_pgpgr;
};


#include "Surface.inl"

#endif // SERVICES__Surface_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\surface.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Surface.h"

#include "GdiCache.h"
#include "OSAL.h"
#include "ResourceManager.h"

/***************************************************************************\
*****************************************************************************
*
* class DuDCSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuDCSurface::Build(
    IN  DuDCSurface::ESource src,
    OUT DuDCSurface ** ppsrfNew)
{
    DuDCSurface * psrfNew = ClientNew(DuDCSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    switch (src)
    {
    case srcTempDC:
        psrfNew->m_hdc = GetGdiCache()->GetTempDC();
        psrfNew->m_fTempDC = TRUE;
        break;

    case srcCompatibleDC:
        psrfNew->m_hdc = GetGdiCache()->GetCompatibleDC();
        psrfNew->m_fCompatibleDC = TRUE;
        break;

    default:
        AssertMsg(0, "Unknown DC Source");
    }

    if (psrfNew->m_hdc == NULL) {
        ClientDelete(DuDCSurface, psrfNew);
        return DU_E_OUTOFGDIRESOURCES;
    }

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuDCSurface::Build(
    IN  HDC hdc,
    OUT DuDCSurface ** ppsrfNew)
{
    Assert(hdc != NULL);

    DuDCSurface * psrfNew = ClientNew(DuDCSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    psrfNew->m_hdc = hdc;

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
DuDCSurface::Destroy()
{
    if (m_hdc != NULL) {
        if (m_fTempDC) {
            GetGdiCache()->ReleaseTempDC(m_hdc);
        } else if (m_fCompatibleDC) {
            GetGdiCache()->ReleaseCompatibleDC(m_hdc);
        }
    }

    ClientDelete(DuDCSurface, this);
}


//------------------------------------------------------------------------------
void
DuDCSurface::SetIdentityTransform()
{
    OS()->SetIdentityTransform(m_hdc);
}


//------------------------------------------------------------------------------
void
DuDCSurface::SetWorldTransform(const XFORM * pxf)
{
    OS()->SetWorldTransform(m_hdc, pxf);
}


//------------------------------------------------------------------------------
void *
DuDCSurface::Save()
{
    return IntToPtr(SaveDC(m_hdc));
}


//------------------------------------------------------------------------------
void
DuDCSurface::Restore(void * pvState)
{
    RestoreDC(m_hdc, PtrToInt(pvState));
}


/***************************************************************************\
*****************************************************************************
*
* class DuGpSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuGpSurface::Build(
    IN  Gdiplus::Graphics * pgpgr,
    OUT DuGpSurface ** ppsrfNew)
{
    Assert(pgpgr != NULL);

    DuGpSurface * psrfNew = ClientNew(DuGpSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    psrfNew->m_pgpgr = pgpgr;


    //
    // Initialize common settings on the GDI+ surface
    //

    pgpgr->SetSmoothingMode(Gdiplus::SmoothingModeHighSpeed);
    pgpgr->SetPixelOffsetMode(Gdiplus::PixelOffsetModeHighSpeed);
    pgpgr->SetCompositingQuality(Gdiplus::CompositingQualityHighSpeed);

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
DuGpSurface::Destroy()
{
    ClientDelete(DuGpSurface, this);
}


//------------------------------------------------------------------------------
void
DuGpSurface::SetIdentityTransform()
{
    m_pgpgr->ResetTransform();
}


//------------------------------------------------------------------------------
void
DuGpSurface::SetWorldTransform(const XFORM * pxf)
{
    Gdiplus::Matrix mat(pxf->eM11, pxf->eM12, pxf->eM21, pxf->eM22, pxf->eDx, pxf->eDy);
    m_pgpgr->SetTransform(&mat);
}


//------------------------------------------------------------------------------
void *
DuGpSurface::Save()
{
    return ULongToPtr(m_pgpgr->Save());
}


//------------------------------------------------------------------------------
void
DuGpSurface::Restore(void * pvState)
{
    m_pgpgr->Restore(static_cast<Gdiplus::GraphicsState>(PtrToUlong(pvState)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\ticketmanager.cpp ===
/***************************************************************************\
*
* File: TicketManager.cpp
*
* Description:
*
* This file contains the implementation of relevant classes, structs, and 
* types for the DUser Ticket Manager.
*
* The following classes are defined for public use:
*
*   DuTicketManager
*       A facility which can assign a unique "ticket" to a BaseObject.
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "TicketManager.h"

#define INIT_OUT_PARAM(p,v) if(p != NULL) *p = v
#define VALIDATE_REQUIRED_OUT_PARAM(p) if(p == NULL) return E_POINTER;
#define VALIDATE_IN_PARAM_NOT_VALUE(p,v) if(p == v) return E_INVALIDARG;

//------------------------------------------------------------------------------
DuTicketManager::DuTicketManager()
{
    Assert(sizeof(DuTicket) == sizeof(DWORD));

    m_idxFreeStackTop = -1;
    m_idxFreeStackBottom = -1;
}


//------------------------------------------------------------------------------
DuTicketManager::~DuTicketManager()
{
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Add(
    IN BaseObject * pObject,
    OUT DWORD * pdwTicket)
{
    HRESULT hr = S_OK;
    int idxFree = 0;

    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    //
    INIT_OUT_PARAM(pdwTicket, 0);
    VALIDATE_REQUIRED_OUT_PARAM(pdwTicket);
    VALIDATE_IN_PARAM_NOT_VALUE(pObject, NULL);

    m_crit.Enter();

    //
    // Scan to make sure the object isn't already in the array.
    // This is too expensive to do outside of DEBUG builds.
    //
    Assert(FAILED(Find(pObject, idxFree)));

    hr = PopFree(idxFree);
    if (SUCCEEDED(hr)) {
        DuTicket ticket;

        m_arTicketData[idxFree].pObject = pObject;

        ticket.Unused = 0;
        ticket.Uniqueness = m_arTicketData[idxFree].cUniqueness;
        ticket.Type = pObject->GetHandleType();
        ticket.Index = idxFree;

        *pdwTicket = DuTicket::CastToDWORD(ticket);
    }
    
    m_crit.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Remove(
    IN DWORD dwTicket,
    OUT OPTIONAL BaseObject ** ppObject)
{
    HRESULT hr = S_OK;
    
    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    //
    INIT_OUT_PARAM(ppObject, NULL);
    VALIDATE_IN_PARAM_NOT_VALUE(dwTicket, 0);

    m_crit.Enter();

    hr = Lookup(dwTicket, ppObject);
    if (SUCCEEDED(hr)) {
        DuTicket ticket = DuTicket::CastFromDWORD(dwTicket);

        //
        // Clear out the object at this index just in case.
        //
        m_arTicketData[ticket.Index].pObject = NULL;
        
        //
        // Increment the uniqueness to invalidate any outstanding tickets.
        //
        m_arTicketData[ticket.Index].cUniqueness++;
        if (m_arTicketData[ticket.Index].cUniqueness == 0) {
            m_arTicketData[ticket.Index].cUniqueness = 1;
        }

        //
        // Push this index back onto the free stack.
        //
        PushFree(ticket.Index);
    }

    m_crit.Leave();

    return(hr);
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Lookup(
    IN DWORD dwTicket,
    OUT OPTIONAL BaseObject ** ppObject)
{
    HRESULT hr = S_OK;
    DuTicket ticket = DuTicket::CastFromDWORD(dwTicket);
    
    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    // - Check for manifest errors in the ticket
    //
    INIT_OUT_PARAM(ppObject, NULL);
    VALIDATE_IN_PARAM_NOT_VALUE(dwTicket, 0);
    if (ticket.Unused != 0 ||
        ticket.Uniqueness == 0 ||
        ticket.Index >= WORD(m_arTicketData.GetSize())) {
        return E_INVALIDARG;
    }
    
    m_crit.Enter();

    //
    // Look up the information in the tables and see if the
    // ticket still looks valid.
    //
    if (m_arTicketData[ticket.Index].cUniqueness == ticket.Uniqueness) {
        if (ppObject != NULL && m_arTicketData[ticket.Index].pObject != NULL) {
            if (ticket.Type == BYTE(m_arTicketData[ticket.Index].pObject->GetHandleType())) {
                *ppObject = m_arTicketData[ticket.Index].pObject;
            }
        }
    } else {
        //
        // It seems like the ticket has gone stale.
        //
        hr = DU_E_NOTFOUND;
    }

    m_crit.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Expand()
{
    //
    // We only need to resize our internal arrays when the free stack is empty.
    //
    Assert(m_idxFreeStackBottom == -1 && m_idxFreeStackTop == -1);

    //
    // Get the old size of the array, and calculate a new size.
    // Note that we limit how big the table can grow.
    //
    int cOldSize = m_arTicketData.GetSize();
    int cNewSize;
    if (cOldSize > 0) {
        if (cOldSize < USHRT_MAX) {
            cNewSize = min(cOldSize * 2, USHRT_MAX);
        } else {
            return E_OUTOFMEMORY;
        }
    } else {
        cNewSize = 16;
    }

    //
    // Resize the array of objects.  The contents of the new items will
    // be set to NULL;
    //
    if (m_arTicketData.SetSize(cNewSize)) {
        //
        // Initialize the new data.
        //
        for (int i = cOldSize; i < cNewSize; i++) {
            m_arTicketData[i].pObject = NULL;
            m_arTicketData[i].cUniqueness = 1;
            m_arTicketData[i].idxFree = WORD(i);
        }

        m_idxFreeStackBottom = cOldSize;
        m_idxFreeStackTop = cNewSize - 1;
    } else {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::PushFree(int idxFree)
{
    if (m_idxFreeStackBottom == -1 && m_idxFreeStackTop == -1) {
        Assert(m_arTicketData.GetSize() > 0);

        m_idxFreeStackBottom = 0;
        m_idxFreeStackTop = 0;
        m_arTicketData[0].idxFree = WORD(idxFree);
    } else {
        int iNewTop = (m_idxFreeStackTop + 1) % m_arTicketData.GetSize();
        
        AssertMsg(iNewTop != m_idxFreeStackBottom, "Probably more pushes than pops!");

        m_arTicketData[iNewTop].idxFree = WORD(idxFree);
        m_idxFreeStackTop = iNewTop;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
HRESULT
DuTicketManager::PopFree(int & idxFree)
{
    HRESULT hr = S_OK;

    //
    // Resize our arrays if our stack of available slots is empty.
    //
    if (m_idxFreeStackBottom == -1 || m_idxFreeStackTop == -1) {
        hr = Expand();
        Assert(SUCCEEDED(hr));

        if (FAILED(hr)) {
            return hr;
        }
    }

    Assert(m_idxFreeStackBottom >=0 && m_idxFreeStackTop >=0 );

    //
    // Take the available slot from the bottom of the stack.
    //
    idxFree = m_arTicketData[m_idxFreeStackBottom].idxFree;

    //
    // Increment the bottom of the stack.  If the stack is now empty,
    // indicate so by setting the top and bottom to -1.
    //
    if (m_idxFreeStackBottom == m_idxFreeStackTop) {
        m_idxFreeStackBottom = -1;
        m_idxFreeStackTop = -1;
    } else {
        m_idxFreeStackBottom = (m_idxFreeStackBottom + 1) % m_arTicketData.GetSize();
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Find(BaseObject * pObject, int & iFound)
{
    HRESULT hr = DU_E_NOTFOUND;

    iFound = -1;

    //
    // Note: This is a brute-force find.  It does a linear search for the
    // specified pointer.  This is very, very slow so don't use it unless
    // you absolutely have to.  The BaseObject itself should remember what
    // its ticket is so it doesn't have to search.
    //
    for (int i = 0; i < m_arTicketData.GetSize(); i++) {
        if (m_arTicketData[i].pObject == pObject) {
            hr = S_OK;
            iFound = i;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\thread.cpp ===
/***************************************************************************\
*
* File: Thread.cpp
*
* Description:
* This file implements the main Thread that is maintained by the 
* ResourceManager to store per-thread information.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Thread.h"

#include "Context.h"

#if !USE_DYNAMICTLS
__declspec(thread) Thread * t_pThread;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Thread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Thread::~Thread()
{
    m_fStartDestroy = TRUE;

    //
    // NOTE: The Thread object may be destroyed on its own thread or on another
    // thread.  Therefore, t_pThread may or may not be == this.
    //

    //
    // Notify the Context that one less thread is using it.  Want to do near
    // the end since the Context heap may be destroyed after calling this.
    // This means that (new / delete) will no longer be valid.
    //
    // Need to call Context::xwUnlock() directly because 
    // Context::DeleteObject() will call the ResourceManager to destroy the 
    // Thread (which is where we already are.)
    //

    //
    // NOTE: We can only destroy the SubThread's when the Thread has a Context.
    // This is because destruction of the SubThread's is an "xw" function that
    // requires a Context.  This unfortunately means that if we were unable
    // to create the Context, we're going to leak the SubTread's, but there is
    // little we can do about it.
    //

    m_poolReturn.Destroy();
    
    if (m_pContext != NULL) {
        if (m_pContext->xwUnlockNL(xwContextFinalUnlockProc, this)) {
            xwDestroySubThreads();
        }

        m_pContext = NULL;
    }


    //
    // Cleanup cached GDI objects
    //

    if (hrgnClip != NULL) {
        DeleteObject(hrgnClip);
    }


    //
    // NOTE: When m_lstReturn's destructor is called, it will check that all 
    // memory has been returned.  It is possible this may not be empty if memory
    // was returned after we emptied m_lstReturn in xwDestroySubThreads().  This
    // is an application error since the memory wasn't allocated using
    // SGM_RECEIVECONTEXT.
    //
    // This is actually a serious application problem, since T2 is still using 
    // memory owned by T1 when T1 is being destroyed.  Unfortunately, DirectUser
    // can not really do that much about it since the application is using DUser
    // in an invalid manner and there are significant performance costs and 
    // design complications by changing this.
    //
}


//------------------------------------------------------------------------------
void        
Thread::xwDestroySubThreads()
{
    if (m_fDestroySubThreads) {
        return;
    }
    m_fDestroySubThreads = TRUE;

    //
    // Notify the sub-threads that the Thread and (potentially) the Context
    // are being destroyed.  This gives them an opportunity to perform any
    // necessary callbacks to the application.
    //

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSTs[idx] != NULL) {
            ProcessDelete(SubThread, m_rgSTs[idx]);
            m_rgSTs[idx] = NULL;
        }
    }

    //
    // Destroy any other objects that may depend on the Context (and the 
    // Context heap).
    //

    m_GdiCache.Destroy();
    m_manBuffer.Destroy();
    m_heapTemp.Destroy();


    //
    // Clean up any outstanding returned memory.  We need to keep track of all
    // the memory this Thread gives out since we can not go away until it has
    // all returned.  If we were to go away before then, the heap would be 
    // destroyed and the other Thread would be using bad data.
    //
    // Therefore, we will make an attempt to get all of the memory back.  If
    // it takes longer than one minute, we'll have to bail.
    //
    
    int cAttempts = 60 * 1000;  // Wait a maximum of 60 seconds
    while ((m_cMemAlloc > 0) && (cAttempts-- > 0)) {
        while (!m_lstReturn.IsEmptyNL()) {
            ReturnAllMemoryNL();
        }

        if (m_cMemAlloc > 0) {
            Sleep(1);
        }
    }
    m_poolReturn.Destroy();
}


//------------------------------------------------------------------------------
void CALLBACK 
Thread::xwContextFinalUnlockProc(BaseObject * pobj, void * pvData)
{
    Thread * pthr = reinterpret_cast<Thread *> (pvData);
    Context * pctx = static_cast<Context *> (pobj);

    pctx->xwPreDestroyNL();
    pthr->xwDestroySubThreads();
}


//------------------------------------------------------------------------------
HRESULT
Thread::Build(
    IN  BOOL fSRT,                      // Thread is an SRT
    OUT Thread ** ppthrNew)             // Newly created thread
{
    //
    // Check if this Thread is already initialized
    //
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
    if (pThread != NULL) {
        *ppthrNew = pThread;
#else
    Thread * pThread = t_pThread;
    if (pThread != NULL) {
        *ppthrNew = pThread;
#endif
        return S_OK;
    }


    HRESULT hr = E_INVALIDARG;

    //
    // Create a new Thread
    //

    pThread = ProcessNew(Thread);
    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    pThread->hrgnClip = CreateRectRgn(0, 0, 0, 0);
    if (pThread->hrgnClip == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }
    pThread->m_fSRT = fSRT;


    //
    // Initialize each of the sub-contexts.  These can safely use the heap
    // which has already been initialized.
    //

    {
        for (int idx = 0; idx < slCOUNT; idx++) {
            ThreadPackBuilder * pBuilder = ThreadPackBuilder::GetBuilder((Thread::ESlot) idx);
            AssertMsg(pBuilder != NULL, "Builder not initialized using INIT_SUBTHREAD");
            SubThread * pST = pBuilder->New(pThread);
            pThread->m_rgSTs[idx] = pST;
            if ((pThread->m_rgSTs[idx] == NULL) || 
                FAILED(hr = pThread->m_rgSTs[idx]->Create())) {

                goto ErrorExit;
            }
        }
    }

    AssertMsg(pThread != NULL, "Ensure Thread is valid");
#if USE_DYNAMICTLS
    AssertMsg(TlsGetValue(g_tlsThread) == NULL, "Ensure TLS is still empty");
    Verify(TlsSetValue(g_tlsThread, pThread));
#else
    AssertMsg(t_pThread == NULL, "Ensure TLS is still empty");
    t_pThread   = pThread;
#endif
    *ppthrNew   = pThread;

    return S_OK;

ErrorExit:
    //
    // An error occurred while initializing the thread, so need to tear down
    // the object.
    //

    if (pThread != NULL) {
        if (pThread->hrgnClip != NULL) {
            DeleteObject(pThread->hrgnClip);
        }

        if (pThread != NULL) {
            ProcessDelete(Thread, pThread);
        }
    }

    *ppthrNew = NULL;
    return hr;
}


//------------------------------------------------------------------------------
ReturnMem *
Thread::AllocMemoryNL(
    IN  int cbSize)                     // Size of allocating, including ReturnMem
{
    AssertMsg(cbSize >= sizeof(ReturnMem), 
            "Allocation must be at least sizeof(ReturnMem)");
    AssertMsg(!m_fDestroySubThreads, "Must be before subtreads start destruction");

    //
    // Before allocating memory from our pool, return memory back to the pool if
    // the pool is already empty.  Only do this if the pool is empty.  
    // Otherwise, the effort is unnecessary and just slows things down.
    //

    if (m_poolReturn.IsEmpty()) {
        ReturnAllMemoryNL();
    }


    //
    // Now, allocate the memory.  Allocate from our pool if it is within the 
    // pool size.
    //

    ReturnMem * prMem;
    if (cbSize <= POOLBLOCK_SIZE) {
        cbSize = POOLBLOCK_SIZE;
        prMem = m_poolReturn.New();
    } else {
        prMem = reinterpret_cast<ReturnMem *> (ContextAlloc(GetContext()->GetHeap(), cbSize));
    }

    if (prMem != NULL) {
        prMem->cbSize = cbSize;
        m_cMemAlloc++;
    }
    return prMem;
}


//------------------------------------------------------------------------------
void
Thread::ReturnAllMemoryNL()
{
    //
    // Check if any memory has been returned.  If so, we need to add it back 
    // into the pool if it is the right size.  Only need to ExtractNL() once.  
    // If we loop, we unnecessarily hit the S-List memory, causing more 
    // slow-downs.
    //
    // As we return the memory, we decrement the number of outstanding 
    // allocations to keep track of how many are remaining.
    //

    ReturnMem * pNode = m_lstReturn.ExtractNL();
    while (pNode != NULL) {
        ReturnMem * pNext = pNode->pNext;
        if (pNode->cbSize == POOLBLOCK_SIZE) {
            PoolMem * pPoolMem = static_cast<PoolMem *> (pNode);
            m_poolReturn.Delete(pPoolMem);
        } else {
            ContextFree(GetContext()->GetHeap(), pNode);
        }

        AssertMsg(m_cMemAlloc > 0, "Must have a remaining memory allocation");
        m_cMemAlloc--;
        
        pNode = pNext;
    }
}


#if DBG

//------------------------------------------------------------------------------
void
Thread::DEBUG_AssertValid() const
{
    Assert(hrgnClip != NULL);
    AssertInstance(m_pContext);

    for (int idx = 0; idx < slCOUNT; idx++) {
        AssertInstance(m_rgSTs[idx]);
    }

    if (!m_fStartDestroy) {
        Assert(m_cRef > 0);
        Assert(!m_fDestroySubThreads);
    }
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class SubThread
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void
SubThread::DEBUG_AssertValid() const
{
    // Don't use AssertInstance since it would be recursive.
    Assert(m_pParent != NULL);
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ThreadPackBuilder
*
*****************************************************************************
\***************************************************************************/

PREINIT_SUBTHREAD(CoreST);

ThreadPackBuilder * ThreadPackBuilder::s_rgBuilders[Thread::slCOUNT] =
{
    INIT_SUBTHREAD(CoreST),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\thread.inl ===
/***************************************************************************\
*
* File: Thread.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Thread_inl__INCLUDED)
#define SERVICES__Thread_inl__INCLUDED
#pragma once

#if USE_DYNAMICTLS
extern  DWORD           g_tlsThread;    // TLS Slot for Thread data
#else
extern __declspec(thread) Thread * t_pThread;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Thread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Thread * 
GetThread()
{
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
#else
    Thread * pThread = t_pThread;
#endif
    AssertMsg(pThread != NULL, "Thread must already be initialized");
    return pThread;
}


//------------------------------------------------------------------------------
inline Thread * 
RawGetThread()
{
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
#else
    Thread * pThread = t_pThread;
#endif
    // Don't check if pThread == NULL
    return pThread;
}


//------------------------------------------------------------------------------
inline BOOL
IsInitThread()
{
#if USE_DYNAMICTLS
    return TlsGetValue(g_tlsThread) != NULL;
#else
    return t_pThread != NULL;
#endif
}


//------------------------------------------------------------------------------
inline  
Thread::Thread()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline BOOL        
Thread::IsSRT() const
{
    return m_fSRT;
}


//------------------------------------------------------------------------------
inline void
Thread::Lock()
{
    AssertMsg(m_cRef > 0, "Must have a valid reference");
    m_cRef++;
}


//------------------------------------------------------------------------------
inline BOOL
Thread::Unlock()
{
    AssertMsg(m_cRef > 0, "Must have a valid reference");
    return --m_cRef != 0;
}


//------------------------------------------------------------------------------
inline void
Thread::MarkOrphaned()
{
    AssertMsg(!m_fOrphaned, "Thread should only be orphaned once");
    m_fOrphaned = TRUE;
}


//------------------------------------------------------------------------------
inline GdiCache *  
Thread::GetGdiCache() const
{
    return const_cast<GdiCache *> (&m_GdiCache);
}


//------------------------------------------------------------------------------
inline BufferManager *
Thread::GetBufferManager() const
{
    return const_cast<BufferManager *> (&m_manBuffer);
}


//------------------------------------------------------------------------------
inline ComManager *    
Thread::GetComManager() const
{
    return const_cast<ComManager *> (&m_manCOM);
}


//------------------------------------------------------------------------------
inline Context *   
Thread::GetContext() const
{
    return m_pContext;
}


//------------------------------------------------------------------------------
inline void        
Thread::SetContext(Context * pContext)
{
    AssertMsg(((pContext == NULL) && (m_pContext != NULL)) ||
            ((pContext != NULL) && (m_pContext == NULL)) ||
            ((pContext == NULL) && (m_pContext == NULL)), 
            "Must reset Context before changing to a new Context");

    m_pContext = pContext;
}


//------------------------------------------------------------------------------
inline SubThread *
Thread::GetST(ESlot slot) const
{
    return m_rgSTs[slot];
}


//------------------------------------------------------------------------------
inline void        
Thread::xwLeftContextLockNL()
{
    for (int idx = 0; idx < slCOUNT; idx++) {
        m_rgSTs[idx]->xwLeftContextLockNL();
    }
}


//------------------------------------------------------------------------------
inline TempHeap *
Thread::GetTempHeap() const
{
    return const_cast<TempHeap *> (&m_heapTemp);
}


//------------------------------------------------------------------------------
inline void
Thread::ReturnMemoryNL(ReturnMem * prMem)
{
    prMem->pNext = NULL;

    AssertMsg(!m_fDestroySubThreads, 
            "All memory should be returned before the thread gets destroyed");

    m_lstReturn.AddHeadNL(prMem);
}


/***************************************************************************\
*****************************************************************************
*
* class SubThread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
SubThread::SetParent(Thread * pParent)
{
    AssertMsg(m_pParent == NULL, "Must set only once");
    m_pParent = pParent;
}


/***************************************************************************\
*****************************************************************************
*
* class ThreadPackBuilder
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline ThreadPackBuilder *
ThreadPackBuilder::GetBuilder(Thread::ESlot slot)
{
    AssertMsg(s_rgBuilders[slot] != NULL, "Build must be defined");
    return s_rgBuilders[slot];
}


#endif // SERVICES__Thread_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\thread.h ===
/***************************************************************************\
*
* File: Thread.h
*
* Description:
* This file declares the main Thread that is maintained by the 
* ResourceManager to store per-thread information.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Thread_h__INCLUDED)
#define SERVICES__Thread_h__INCLUDED
#pragma once

#include "GdiCache.h"
#include "Buffer.h"
#include "ComManager.h"

class Context;
class Thread;
class SubThread;
class ThreadPackBuilder;

struct ReturnMem
{
    ReturnMem * pNext;
    int         cbSize;
};

const POOLBLOCK_SIZE = 128;

/***************************************************************************\
*****************************************************************************
*
* Thread provides a mechanism to store per-thread information.  This object
* is only used by its own thread and should not be directly accessed from
* other threads.  This object is created when a thread is registered with
* the ResourceManager to create a Context.
*
*****************************************************************************
\***************************************************************************/

#pragma warning(disable:4324)  // structure was padded due to __declspec(align())

class Thread : public ListNodeT<Thread>
{
// Construction
public:
    inline  Thread();
            ~Thread();
    static  HRESULT     Build(BOOL fSRT, Thread ** ppthrNew);

// Operations
public:
    enum ESlot {
        slCore          = 0,            // Core
        slCOUNT                         // Number of sub-contexts
    };

    inline  BOOL        IsSRT() const;
    inline  void        Lock();
    inline  BOOL        Unlock();

    inline  void        MarkOrphaned();

    inline  GdiCache *  GetGdiCache() const;
    inline  BufferManager *
                        GetBufferManager() const;
    inline  ComManager* GetComManager() const;
    inline  Context *   GetContext() const;
    inline  void        SetContext(Context * pContext);
    inline  SubThread * GetST(ESlot slot) const;

    inline  void        xwLeftContextLockNL();
    inline  TempHeap *  GetTempHeap() const;

            ReturnMem * AllocMemoryNL(int cbSize);
    inline  void        ReturnMemoryNL(ReturnMem * prMem);

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
public:
            HRGN        hrgnClip;

protected:
            void        xwDestroySubThreads();
    static  void CALLBACK xwContextFinalUnlockProc(BaseObject * pobj, void * pvData);

            void        ReturnAllMemoryNL();

            struct PoolMem : public ReturnMem
            {
                BYTE        rgbData[POOLBLOCK_SIZE - sizeof(ReturnMem)];
            };
            AllocPoolNL<PoolMem, 512>
                        m_poolReturn;   // Pool of reserved memory

            GdiCache    m_GdiCache;
            BufferManager m_manBuffer;
            ComManager  m_manCOM;
            Context *   m_pContext;     // Current Context for this Thread
            TempHeap    m_heapTemp;     // Temporary heap
            GInterlockedList<ReturnMem> 
                        m_lstReturn;    // Returned memory list

            SubThread*  m_rgSTs[slCOUNT]; // Sub-context information

            UINT        m_cRef;         // Outstanding references on this Thread
            UINT        m_cMemAlloc;    // Outstanding ReturnMem allocations
            BOOL        m_fSRT:1;       // Thread is an SRT
            BOOL        m_fStartDestroy:1;      // Thread has started destruction
            BOOL        m_fDestroySubThreads:1; // Sub-threads have been destroyed
            BOOL        m_fOrphaned:1;  // Thread was orphaned
};

#pragma warning(default:4324)  // structure was padded due to __declspec(align())

/***************************************************************************\
*****************************************************************************
*
* SubThread defines a "extensibility" mechanism that allows individual
* projects in DirectUser to provide additional data to store on the thread.
* To use this, the project must add a new slot in Thread, derive a class
* from SubThread that is created per Thread instance, and derive a class
* from ThreadPackBuilder to register the extension.
*
*****************************************************************************
\***************************************************************************/

class SubThread
{
// Construction
public:
    virtual ~SubThread() { }
    virtual HRESULT     Create() { return S_OK; }

// Operations
public:
    inline  Thread *    GetParent() const { return m_pParent; }
    inline  void        SetParent(Thread * pParent);
    virtual void        xwLeftContextLockNL() { }

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
            Thread *   m_pParent;
};


/***************************************************************************\
*****************************************************************************
*
* ThreadPackBuilder registers an SubThread "extension" to be created 
* whenever a new Thread is created.  The constructor is expected to set the
* slot corresponding to the ESlot value.
*
*****************************************************************************
\***************************************************************************/

class ThreadPackBuilder
{
// Construction
public:

// Operations
public:
    virtual SubThread*  New(Thread * pThread) PURE;
    static  inline ThreadPackBuilder *
                        GetBuilder(Thread::ESlot slot);

// Data
protected:
    static  ThreadPackBuilder * 
                        s_rgBuilders[Thread::slCOUNT];
};


#define IMPLEMENT_SUBTHREAD(id, obj)                        \
    class obj##Builder : public ThreadPackBuilder           \
    {                                                       \
    public:                                                 \
        virtual SubThread * New(Thread * pParent)           \
        {                                                   \
            SubThread * psc = ProcessNew(obj);              \
            if (psc != NULL) {                              \
                psc->SetParent(pParent);                    \
            }                                               \
            return psc;                                     \
        }                                                   \
    } g_##obj##B                                            \

#define PREINIT_SUBTHREAD(obj)                              \
    class obj##Builder;                                     \
    extern obj##Builder g_##obj##B                          \

#define INIT_SUBTHREAD(obj)                                 \
    (ThreadPackBuilder *) &g_##obj##B                       \


inline  Thread *    GetThread();
inline  BOOL        IsInitThread();

#include "Thread.inl"

#endif // SERVICES__Thread_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\ticketmanager.inl ===
/***************************************************************************\
*
* File: TicketManager.inl
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(SERVICES__TicketManager_inl__INCLUDED)
#define SERVICES__TicketManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
DuTicket &
DuTicket::CastFromDWORD(
    DWORD & dw)
{
    return *(reinterpret_cast<DuTicket*>(&dw));
}

//------------------------------------------------------------------------------
DWORD &
DuTicket::CastToDWORD(
    DuTicket & ticket)
{
    return *(reinterpret_cast<DWORD*>(&ticket));
}

#endif // SERVICES__TicketManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\services\ticketmanager.h ===
/***************************************************************************\
*
* File: TicketManager.h
*
* Description:
*
* This file contains the definition of relevant classes, structs, and types
* for the DUser Ticket Manager.
*
* The following classes are defined for public use:
*
*   TicketManager
*       A facility which can assign a unique "ticket" to a BaseObject.
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__TicketManager_h__INCLUDED)
#define SERVICES__TicketManager_h__INCLUDED
#pragma once


/***************************************************************************\
*
* DuTicket
*
* Tickets are created to give an external identity to a gadget.  However,
* this identity is not necessarily permanent, and may have a limited 
* lifetime.  External apps should not hold on to these temporary tickets
* for long periods of time because they will eventually expire.
*
* One primary consumer of these tickets is the ActiveAccessibility APIs.
* Because of this, we must work within some constraints:
* - Tickets must be 32-bits in size.
* - Tickets can't be negative, so the upper bit must be clear.
* - Tickets can't be zero.
*
* A description of the fields in a ticket follow:
*
* Unused:
* As explained above, the upper bit can not be used, and must be 0.
*
* Type:
* We encode the actual type of the BaseObject so that we can further
* validate uses of the ticket.
*
* Uniqueness:
* We encode a uniqueness value that is essentially an ever-increasing number
* to provide some temporal distance between subsequent uses of the same
* index.  The uniqueness can never be 0 - to satisfy the requirement that
* the ticket itself can never be 0.
*
* Index
* The actual BaseObject is stored in a table in the TicketManager.  This
* index is stored here.
*
\***************************************************************************/
struct DuTicket
{
    DWORD Index : 16;
    DWORD Uniqueness : 8;
    DWORD Type : 7;
    DWORD Unused : 1;

    inline static DuTicket & CastFromDWORD(DWORD & dw);
    inline static DWORD & CastToDWORD(DuTicket & ticket);
};


/***************************************************************************\
*
* DuTicketData
*
* The DuTicketData structure is used to store the data inside the ticket
* manager. A brief description of the fields follows:
*
* pObject
* A pointer to the actual BaseObject associated with a given ticket.
*
* dwExpirationTick
* How many ticks until the ticket is invalidated.
*
* idxFree
* This is actually a logically separate array that contains a "free stack"
* to make inserting into the ticket manager quick.
*
* cUniqueness
* The uniqueness value for this entry in the ticket manager.  Tickets must
* have a matching uniqueness in order for them to actually access the 
* object.
*
\***************************************************************************/

struct DuTicketData
{
    BaseObject * pObject;
    WORD idxFree;
    BYTE cUniqueness;
};

//
// Note: This class is only defined this way because its the only way I
// could get the debugger extensions to recognize the symbol name.
//
class DuTicketDataArray : public GArrayF<DuTicketData, ProcessHeap>
{
public:
};

/***************************************************************************\
*
* DuTicketManager
*
* The DuTicketManager class provides a mechanism by which a relatively
* permanent "ticket" can be assigned to a given BaseObject.  This "ticket"
* can be used later to safely access the BaseObject.  If the BaseObject has
* been destroyed, an error will be returned but the system will not fault.
*
* This is especially important when you must pass the identity of a DUser
* object to an outside program.  It would be unsafe to pass the raw pointer
* since doing so may require an unsafe dereference when the outside program
* attempts to extract information about the object.
*
* This is a one-way mapping only.  The TicketManager class can correctly
* return the BaseObject assigned to a given ticket.  However, to find the
* ticket associated with a BaseObject is an expensive operation and is
* best stored on the BaseObject itself.
*
\***************************************************************************/

class DuTicketManager
{
// Construction
public:
                        DuTicketManager();
                        ~DuTicketManager();
                        SUPPRESS(DuTicketManager);

// Operations
public:
            HRESULT     Add(IN BaseObject * pObject, OUT DWORD * pdwTicket);
            HRESULT     Remove(IN DWORD dwTicket, OUT OPTIONAL BaseObject ** ppObject);
            HRESULT     Lookup(IN DWORD dwTicket, OUT OPTIONAL BaseObject ** ppObject);

// Implementation
protected:
            HRESULT     Expand();
            HRESULT     PushFree(int idxFree);
            HRESULT     PopFree(int & idxFree);
            HRESULT     Find(BaseObject * pObject, int & iFound);

// Data
private:
            DuTicketDataArray 
                        m_arTicketData;
            int         m_idxFreeStackTop;
            int         m_idxFreeStackBottom;
            CritLock    m_crit;
};

#include "TicketManager.inl"

#endif // SERVICES__TicketManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\dwpex.cpp ===
#include "stdafx.h"
#include "WinAPI.h"
#include "DwpEx.h"

/***************************************************************************\
*****************************************************************************
*
* DefWindowProcEx Extensions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
struct ExtraInfo
{
    HWND            hwnd;           // For easy reference
    WNDPROC         pfnOldWndProc;  // Original wndproc before subclassing
    HWndContainer * pconOwner;      // Gadget container for this window
};


//------------------------------------------------------------------------------
ExtraInfo *
RawGetExtraInfo(HWND hwnd)
{
    return (ExtraInfo *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


LRESULT ExtraInfoWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);


/***************************************************************************\
*
* GetExtraInfo
*
* GetExtraInfo() returns an ExtraInfo block for a given window.  If the
* window does not already have an EI block, a new one is allocated, attached
* to the window and subclassed.
*
\***************************************************************************/

ExtraInfo *
GetExtraInfo(HWND hwnd)
{
    if (!ValidateHWnd(hwnd)) {
        return NULL;
    }

    // First, check if the info already exists
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei != NULL) {
        return pei;
    }

    pei = ProcessNew(ExtraInfo);
    if (pei != NULL) {
        pei->hwnd           = hwnd;
        pei->pfnOldWndProc  = (WNDPROC) GetWindowLongPtr(hwnd, GWLP_WNDPROC);
        pei->pconOwner      = NULL;

        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LONG_PTR) pei);
        SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR) ExtraInfoWndProc);
    }

    return pei;
}


/***************************************************************************\
*
* RemoveExtraInfo
*
* RemoveExtraInfo() cleans up any objects allocated in a HWND's ExtraInfo data
* block.
*
\***************************************************************************/

void
RemoveExtraInfo(HWND hwnd)
{
    if (!ValidateHWnd(hwnd)) {
        return;
    }

    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return;
    }

    if (pei->pconOwner != NULL) {
        pei->pconOwner->xwUnlock();
    }

    SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR) pei->pfnOldWndProc);
    SetWindowLongPtrW(hwnd, GWLP_USERDATA, NULL);

    ProcessDelete(ExtraInfo, pei);
}


//---------------------------------------------------------------------------
void
DestroyContainer(ExtraInfo * pei)
{
    if (pei->pconOwner != NULL) {
        pei->pconOwner->xwUnlock();
        pei->pconOwner = NULL;
    }
}


/***************************************************************************\
*
* ExtraInfoWndProc
*
* ExtraInfoWndProc() provides a TEMPORARY mechanism of adding ExtraInfo into
* an HWND.  Eventually, this should be moved into DefWindowProc().
*
\***************************************************************************/

LRESULT
ExtraInfoWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // Check if the window has ExtraInfo (without allocating any if it
    // doesn't).  If we don't "own" it, just pass on to DefWindowProc().
    //
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return DefWindowProc(hwnd, nMsg, wParam, lParam);
    }


    //
    // This window has ExtraInfo, so handle as necessary.
    //
    // Also, grab any info that we will need to call the original windowproc
    // later.
    //

    WNDPROC pfnOldWndProc = pei->pfnOldWndProc;

    switch (nMsg)
    {
    case WM_NCDESTROY:
        //
        // This is the last message that we will get, so need to clean-up now.
        // We need to be very careful since we will detatch ourself from the
        // window.
        //

        RemoveExtraInfo(hwnd);
        break;

    default:
        if (pei->pconOwner != NULL) {
            LRESULT r;
            if (pei->pconOwner->xdHandleMessage(nMsg, wParam, lParam, &r, 0)) {
                return r;
            }
        }
    }

    return CallWindowProc(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
}


//**************************************************************************************************
//
// Public Functions
//
//**************************************************************************************************

/***************************************************************************\
*
* GdGetContainer (Public)
*
* GdGetContainer() returns the associated Gadget Container for a given
* window.  If the window does not yet have a gadget container, NULL is
* returned.
*
\***************************************************************************/

HWndContainer *
GdGetContainer(HWND hwnd)
{
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return NULL;
    }

    return pei->pconOwner;
}


/***************************************************************************\
*
* GdCreateHwndRootGadget (Public)
*
* GdCreateHwndRootGadget() creates a new RootGadget for an existing HWND.  If
* the HWND already has a gadget or container, this function will destroy
* the previous container and gadget and create new instances.
*
\***************************************************************************/

HRESULT
GdCreateHwndRootGadget(
    IN  HWND hwndContainer,             // Window to be hosted inside
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)       // New Gadget
{
    HRESULT hr;

    ExtraInfo * pei = GetExtraInfo(hwndContainer);
    if (pei == NULL) {
        return NULL;
    }

    DestroyContainer(pei);

    //
    // Build a new container and top gadget
    //

    HWndContainer * pconNew;
    hr = HWndContainer::Build(pei->hwnd, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    DuRootGadget * pgadNew;
    hr = DuRootGadget::Build(pconNew, FALSE, pci, &pgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    pgadNew->SetFill(GetStdColorBrushI(SC_White));

    pei->pconOwner = pconNew;
    *ppgadNew = pgadNew;
    return S_OK;
}


//------------------------------------------------------------------------------
BOOL
GdForwardMessage(DuVisual * pgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr)
{
    DuContainer * pcon = pgadRoot->GetContainer();
    return pcon->xdHandleMessage(nMsg, wParam, lParam, pr, DuContainer::mfForward);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\apistubs.cpp ===
/***************************************************************************\
*
* File: ApiStubs.cpp
*
* Description:
* ApiStubs.cpp exposes all public DirectUser API's in the Win32 world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#include "stdafx.h"
#include "WinAPI.h"

#include "DwpEx.h"


#define DUSER_API
#pragma warning(disable: 4296)      // expression is always false


//
// Undefine the macros declared in ObjectAPI because they will be redefined 
// here for the WinAPI handle-based API's.
//

#undef BEGIN_API
#undef END_API
#undef BEGIN_API_NOLOCK
#undef END_API_NOLOCK
#undef BEGIN_API_NOCONTEXT
#undef END_API_NOCONTEXT

#undef CHECK_MODIFY

#undef VALIDATE_GADGETCONTEXT
#undef VALIDATE_VALUE
#undef VALIDATE_HWND
#undef VALIDATE_REGION
#undef VALIDATE_OBJECT
#undef VALIDATE_EVENTGADGET
#undef VALIDATE_EVENTGADGET_NOCONTEXT
#undef VALIDATE_VISUAL
#undef VALIDATE_ROOTGADGET
#undef VALIDATE_VISUAL_OR_NULL
#undef VALIDATE_TRANSITION

#undef VALIDATE_FLAGS
#undef VALIDATE_RANGE
#undef VALIDATE_CODE_PTR
#undef VALIDATE_CODE_PTR_OR_NULL
#undef VALIDATE_READ_PTR
#undef VALIDATE_READ_PTR_
#undef VALIDATE_READ_PTR_OR_NULL_
#undef VALIDATE_READ_STRUCT
#undef VALIDATE_WRITE_PTR
#undef VALIDATE_WRITE_PTR_
#undef VALIDATE_WRITE_PTR_OR_NULL_
#undef VALIDATE_WRITE_STRUCT
#undef VALIDATE_STRING_PTR
#undef VALIDATE_STRINGA_PTR
#undef VALIDATE_STRINGW_PTR


//
// SET_RETURN is a convenient macro that converts from DirectUser error 
// conditions and sets up the return value.
//
// NOTE: This MUST be a macro (and not an inline function) because we CANNOT
// evaluate success unless hr was actually successful.  Unfortunately with 
// function calls, success would need to be evaluated to call the function.
//

#define SET_RETURN(hr, success)     \
    do {                            \
        if (SUCCEEDED(hr)) {        \
            retval = success;       \
        } else {                    \
            SetError(hr);           \
        }                           \
    } while (0)                     \



template <class T>
inline void SetError(T dwErr)
{
    SetLastError((DWORD) dwErr);
}


//
// API Entry / Exit setup rountines
//

#define BEGIN_RECV(type, value, defermsg)       \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \
                                                \
    if (!IsInitContext()) {                     \
        PromptInvalid("Must initialize Context before using thread"); \
        SetError(DU_E_NOCONTEXT);               \
        goto rawErrorExit;                      \
    }                                           \
                                                \
    {                                           \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg)) {             \
            SetError(E_INVALIDARG);             \
            goto ErrorExit;                     \
        }                                       \
        Context * pctxThread  = cl.pctx;        \
        AssertInstance(pctxThread);            \
        UNREFERENCED_PARAMETER(pctxThread);     \

#define END_RECV()                              \
        goto ErrorExit;                         \
ErrorExit:                                      \
        /* Unlocks the Context here */          \
        ;                                       \
    }                                           \
rawErrorExit:                                   \
    return retval;


#define BEGIN_RECV_NOLOCK(type, value)          \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \
                                                \
    if (!IsInitContext()) {                     \
        PromptInvalid("Must initialize Context before using thread"); \
        SetError(DU_E_NOCONTEXT);               \
        goto rawErrorExit;                      \
    }                                           \
                                                \
    {                                           \
        Context * pctxThread  = ::GetContext(); \
        AssertInstance(pctxThread);            \


#define END_RECV_NOLOCK()                       \
        goto ErrorExit;                         \
ErrorExit:                                      \
        ;                                       \
    }                                           \
rawErrorExit:                                   \
    return retval;



#define BEGIN_RECV_NOCONTEXT(type, value)       \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \


#define END_RECV_NOCONTEXT()                    \
    goto ErrorExit;                             \
ErrorExit:                                      \
    return retval;



#define CHECK_MODIFY()                          \
    if (pctxThread->IsReadOnly()) {             \
        PromptInvalid("Can not call modifying function while in read-only state / callback"); \
        SetError(DU_E_READONLYCONTEXT);         \
        goto ErrorExit;                         \
    }                                           \


//
// Individual parameter validation rountines
//

#define VALIDATE_GADGETCONTEXT(gad)                         \
    {                                                       \
        Context * pctxGad = (p##gad)->GetContext();         \
        if (pctxThread != pctxGad) {                        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            SetError(DU_E_INVALIDCONTEXT);                  \
            goto ErrorExit;                                 \
        }                                                   \
    }


#define VALIDATE_VALUE(x, v)                                \
    if (x != v) {                                           \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_HWND(wnd)                                  \
    if ((h##wnd == NULL) || (!IsWindow(h##wnd))) {          \
        PromptInvalid("Handle is not a valid Window");             \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_REGION(rgn)                                \
    if (h##rgn == NULL) {                                   \
        PromptInvalid("Handle is not a valid region");             \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_OBJECT(obj)                                \
    {                                                       \
        p##obj = BaseObject::ValidateHandle(h##obj);        \
        if (p##obj == NULL) {                               \
            PromptInvalid("Handle is not a valid object"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_EVENTGADGET(gad)                            \
    {                                                       \
        p##gad = ValidateBaseGadget(h##gad);                \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(gad)                         \
    }

#define VALIDATE_EVENTGADGET_NOCONTEXT(gad)                  \
    {                                                       \
        p##gad = ValidateBaseGadget(h##gad);                \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VISUAL(gad)                                \
    {                                                       \
        p##gad = ValidateVisual(h##gad);                    \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(gad)                         \
    }

#define VALIDATE_ROOTGADGET(gad)                            \
    {                                                       \
        {                                                   \
            DuVisual * pgadTemp = ValidateVisual(h##gad);   \
            if (pgadTemp == NULL) {                         \
                PromptInvalid("Handle is not a valid Gadget"); \
                SetError(E_INVALIDARG);                     \
                goto ErrorExit;                             \
            }                                               \
            if (!pgadTemp->IsRoot()) {                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(gadTemp)                 \
            p##gad = (DuRootGadget *) pgadTemp;             \
        }                                                   \
    }

#define VALIDATE_VISUAL_OR_NULL(gad)                        \
    {                                                       \
        if (h##gad == NULL) {                               \
            p##gad = NULL;                                  \
        } else {                                            \
            p##gad = ValidateVisual(h##gad);                \
            if (p##gad == NULL) {                           \
                PromptInvalid("Handle is not a valid Gadget");     \
                SetError(E_INVALIDARG);                     \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(gad)                     \
        }                                                   \
    }

#define VALIDATE_TRANSITION(trx)                            \
    {                                                       \
        BaseObject * pbase##trx = BaseObject::ValidateHandle(h##trx);   \
        p##trx = CastTransition(pbase##trx);                \
        if (p##trx == NULL) {                               \
            PromptInvalid("Handle is not a valid Transition");     \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_FLAGS(f, m)                                \
    if ((f & m) != f) {                                     \
        PromptInvalid("Specified flags are invalid");      \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_RANGE(i, a, b)                             \
    if (((i) < (a)) || ((i) > (b))) {                       \
        PromptInvalid("Value is outside expected range");  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR(p)                                \
    if ((p == NULL) || IsBadCode(p)) {                      \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR_OR_NULL(p)                        \
    if ((p != NULL) && IsBadCode((FARPROC) p)) {            \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR(p)                                \
    if ((p == NULL) || IsBadRead(p, sizeof(char *))) {      \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_(p, b)                            \
    if ((p == NULL) || IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL_(p, b)                    \
    if ((p != NULL) && IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));          \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_STRUCT(p, s)                          \
    if ((p == NULL) || IsBadRead(p, sizeof(s))) {           \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_WRITE_PTR(p)                               \
    if ((p == NULL) || IsBadWrite(p, sizeof(char *))) {     \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_(p, b)                           \
    if ((p == NULL) || IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_OR_NULL_(p, b)                   \
    if ((p != NULL) && IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_STRUCT(p, s)                         \
    if ((p == NULL) || IsBadWrite(p, sizeof(s))) {          \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_STRING_PTR(p, cch)                         \
    if ((p == NULL) || IsBadString(p, cch)) {               \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGA_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringA(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGW_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringW(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \


/***************************************************************************\
*****************************************************************************
*
* DirectUser CORE API
*
* InitGadgets() initializes a DirectUser Context.  The Context is valid in
* the Thread until it is explicitely destroyed with ::DeleteHandle() or the
* thread exits.
*
* NOTE: It is VERY important that the first time this function is called is
* NOT in DllMain() because we need to initialize the SRT.  DllMain()
* serializes access across all threads, so we will deadlock.  After the first
* Context is successfully created, additional Contexts can be created inside
* DllMain().
*
* <package name="Core"/>
*
*****************************************************************************
\***************************************************************************/

DUSER_API HDCONTEXT WINAPI
InitGadgets(
    IN  INITGADGET * pInit)
{
    Context * pctxNew;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HDCONTEXT, NULL);
    VALIDATE_READ_STRUCT(pInit, INITGADGET);
    VALIDATE_RANGE(pInit->nThreadMode, IGTM_MIN, IGTM_MAX);
    VALIDATE_RANGE(pInit->nMsgMode, IGMM_MIN, IGMM_MAX);
    VALIDATE_RANGE(pInit->nPerfMode, IGPM_MIN, IGPM_MAX);

    hr = ResourceManager::InitContextNL(pInit, FALSE, &pctxNew);
    SET_RETURN(hr, (HDCONTEXT) GetHandle(pctxNew));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* InitGadgetComponent (API)
*
* InitGadgetComponent() initializes optional DirectUser/Gadget components
* that are not initialized by default.  It is usually best to call this
* function separately for each optional component to track individual
* failures when initializing.
*
* <return type="BOOL">      Components were successfully initialized.</>
* <see type="function">     CreateTransition</>
* <see type="function">     UninitializeGadgetComponent</>
*
\***************************************************************************/
DUSER_API BOOL WINAPI
InitGadgetComponent(
    IN  UINT nOptionalComponent)    // Optional component ID
{
    HRESULT hr;

    //
    // InitComponentNL() doesn't actually synchronize on a Context, but needs
    // a context to be initialized so that the threading model is determined.
    //

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_RANGE(nOptionalComponent, IGC_MIN, IGC_MAX);
    CHECK_MODIFY();

    hr = ResourceManager::InitComponentNL(nOptionalComponent);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* UninitGadgetComponent (API)
*
* UninitGadgetComponent() shuts down and cleans up optional DirectUser/Gadget
* components that were previously initialized.
*
* <return type="BOOL">      Components were successfully uninitialized.</>
* <see type="function">     InitGadgetComponent</>
*
\***************************************************************************/
DUSER_API BOOL WINAPI
UninitGadgetComponent(
    IN  UINT nOptionalComponent)    // Optional component
{
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nOptionalComponent, IGC_MIN, IGC_MAX);
    CHECK_MODIFY();

    hr = ResourceManager::UninitComponentNL(nOptionalComponent);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* DeleteHandle (API)
*
* DeleteHandle() deletes any DirectUser handle by destroying the object and
* cleaning up associated resources.  After calling, the specified handle is
* no longer valid.  It may be used again later by another object.
*
* It is very important that only valid handles are given to ::DeleteHandle().
* Passing invalid handles (including previously deleted handles) will crash
* DirectUser.
*
* <return type="BOOL">      Object was successfully deleted.</>
* <see type="function">     CreateGadget</>
* <see type="function">     CreateTransition</>
* <see type="function">     CreateAction</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
DeleteHandle(
    IN  HANDLE h)                   // Handle to delete
{
    BEGIN_RECV_NOLOCK(BOOL, FALSE);
    BaseObject * pobj = BaseObject::ValidateHandle(h);
    if (pobj != NULL) {
        if (pobj->GetHandleType() == htContext) {
            //
            // When destroying a Context, we can't lock it or it won't get
            // destroyed.  This is okay since the ResourceManager serialize
            // the requests when it locks the thread-list.
            //

            pobj->xwDeleteHandle();
            retval = TRUE;
        } else {
            //
            // When destroying a normal object, lock the Context that the 
            // object resides in.
            //

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer, pctxThread)) {
                ObjectLock ol(pobj);
                CHECK_MODIFY();

                pobj->xwDeleteHandle();
                retval = TRUE;
            }
        }
    }

    //
    // NOTE: The object may not be deleted yet if there are any outstanding
    // locks against it.  If it is a Gadget, it may be locked by one of the
    // message queues.
    //

    END_RECV_NOLOCK();
}


/***************************************************************************\
*
* DUserDeleteGadget (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserDeleteGadget(
    IN  DUser::Gadget * pg)
{
    BEGIN_RECV_NOLOCK(HRESULT, E_INVALIDARG);

    MsgObject * pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("Must specify a valid Gadget to delete");
        return E_INVALIDARG;
    }

    {
        //
        // When destroying a normal object, lock the Context that the 
        // object resides in.
        //

        ContextLock cl;
        if (cl.LockNL(ContextLock::edDefer, pctxThread)) {
            ObjectLock ol(pmo);
            CHECK_MODIFY();

            pmo->xwDeleteHandle();
            retval = S_OK;
        }
    }

    //
    // NOTE: The object may not be deleted yet if there are any outstanding
    // locks against it.  If it is a Gadget, it may be locked by one of the
    // message queues.
    //

    END_RECV_NOLOCK();
}


/***************************************************************************\
*
* IsStartDelete (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsStartDelete(
    IN  HANDLE hobj, 
    IN  BOOL * pfStarted)
{
    BaseObject * pobj;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_WRITE_PTR(pfStarted);
    VALIDATE_OBJECT(obj);

    *pfStarted = pobj->IsStartDelete();
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* GetContext (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API HDCONTEXT WINAPI
GetContext(
    IN HANDLE h)
{
    BEGIN_RECV_NOCONTEXT(HDCONTEXT, NULL);

    // TODO: Totally rewrite this nonsense.
    {
        DuEventGadget * pgad;
        HGADGET hgad = (HGADGET) h;
        VALIDATE_EVENTGADGET_NOCONTEXT(gad);
        if (pgad != NULL) {
            retval = (HDCONTEXT) GetHandle(pgad->GetContext());
        }
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* IsInsideContext (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsInsideContext(HANDLE h)
{
    BOOL fInside = FALSE;

    if ((h != NULL) && IsInitThread()) {
        __try
        {
            DuEventGadget * pgad = ValidateBaseGadget((HGADGET) h);
            if (pgad != NULL) {
                Context * pctxThread = GetContext();
                fInside = (pctxThread == pgad->GetContext());
            } else if (BaseObject::ValidateHandle(h) != NULL) {
                fInside = TRUE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            fInside = FALSE;
        }
    }

    return fInside;
}


/***************************************************************************\
*
* CreateGadget (API)
*
* CreateGadget() creates a new Gadget of a given type.  Depending on the
* specific flags, different Gadgets will actually be instantiated.  Once a
* Gadget of a specific type has been created, it can not be changed into a
* different type without being deleted and recreated.
*
* <param name="nFlags">
*       Specifies both what type of Gadget to created and any creation-time
*       properties of that Gadget
*       <table item="Value" desc="Action">
*           GC_HWNDHOST     Creates a top-level Gadget that can host a
*                           GadgetTree inside the client area of a given
*                           HWND.  hParent must be a valid HWND.
*           GC_NCHOST       Creates a top-level Gadget that can host a
*                           GadgetTree inside the non-client area of a given
*                           HWND.  hParent must be a valid HWND.
*           GC_DXHOST       Creates a top-level Gadget that can host a
*                           GadgetTree inside a DXSurface.  hParent must be
*                           an LPCRECT specifying the area of the surface
*                           the tree will be displayed on.
*           GC_COMPLEX      Creates a sub-level Gadget that is optimized for
*                           a complex subtree below it containing many other
*                           Gadgets.  More expensive than a Simple Gadget,
*                           Complex Gadgets provide optimized region management
*                           and are more equivalent to HWND's in both
*                           functionality and design.  hParent must specify a
*                           valid HGADGET.
*           GC_SIMPLE       Creates a sub-level Gadget that is optimized for
*                           a simple subtree below it containing a few Gadgets.
*                           Simple Gadgets are cheaper to create and often use
*                           than Complex Gadgets if optimized region management
*                           is not needed.  hParent must specify a valid
*                           HGADGET.
*           GC_DETACHED     Creates a Gadget not integrated into a given Gadget
*                           tree.  Since they are separated from a tree,
*                           operations must be explicitely forwarded to
*                           Detached Gadgets during processing.  hParent is
*                           ignored.
*           GC_MESSAGE      Creates a message-only Gadget that can receive and
*                           send messages, but does not participate in any
*                           visual or interactive manner.  hParent is ignored.
*       </table>
* </param>
*
* <return type="HGADGET">   Returns a handle to the newly created Gadget
*                           or NULL if the creation failed.</>
* <see type="function">     DeleteHandle</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
CreateGadget(
    IN  HANDLE hParent,             // Handle to parent
    IN  UINT nFlags,                // Creation flags
    IN  GADGETPROC pfnProc,         // Pointer to the Gadget procedure
    IN  void * pvGadgetData)        // User data associated with this Gadget
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edDefer);

    HRESULT hr;
    CREATE_INFO ci;
    ci.pfnProc  = pfnProc;
    ci.pvData   = pvGadgetData;

    switch (nFlags & GC_TYPE)
    {
    case GC_HWNDHOST:
        {
            HWND hwndContainer = (HWND) hParent;
            VALIDATE_HWND(wndContainer);

            DuRootGadget * pgadRoot;
            hr = GdCreateHwndRootGadget(hwndContainer, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_NCHOST:
        {
            HWND hwndContainer = (HWND) hParent;
            VALIDATE_HWND(wndContainer);

            DuRootGadget * pgadRoot;
            hr = GdCreateNcRootGadget(hwndContainer, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_DXHOST:
        {
            const RECT * prcContainerRect = (const RECT *) hParent;
            VALIDATE_READ_PTR_(prcContainerRect, sizeof(RECT));

            DuRootGadget * pgadRoot;
            hr = GdCreateDxRootGadget(prcContainerRect, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_COMPLEX:
        PromptInvalid("Complex Gadgets are not yet implemented");
        SetError(E_NOTIMPL);
        break;

    case GC_SIMPLE:
        {
            DuVisual * pgadParent;
            HGADGET hgadParent = (HGADGET) hParent;
            VALIDATE_VISUAL_OR_NULL(gadParent);

            if (pgadParent == NULL) {
                pgadParent = GetCoreSC()->pconPark->GetRoot();
                if (pgadParent == NULL) {
                    //
                    // The Parking Gadget has already been destroyed, so can not
                    // create a new child.
                    //

                    SetError(E_INVALIDARG);
                    goto ErrorExit;
                }
            }

            DuVisual * pgadChild;
            hr = pgadParent->AddChild(&ci, &pgadChild);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadChild));
        }
        break;

    case GC_DETACHED:
        PromptInvalid("Detached Gadgets are not yet implemented");
        SetError(E_NOTIMPL);
        break;

    case GC_MESSAGE:
        {
            VALIDATE_VALUE(hParent, NULL);
            VALIDATE_CODE_PTR(pfnProc);    // MsgGadget's must have a GadgetProc

            DuListener * pgadNew;
            hr = DuListener::Build(&ci, &pgadNew);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadNew));
        }
        break;

    default:
        PromptInvalid("Invalid Gadget type");
        SetError(E_INVALIDARG);
    }

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetFocus (API)
*
* GetGadgetFocus() returns the Gadget with current keyboard focus or NULL
* if no Gadget currently has focus.
*
* <return type="HGADGET">   Gadget with keyboard focus.</>
* <see type="function">     SetGadgetFocus</>
* <see type="message">      GM_CHANGESTATE</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
GetGadgetFocus()
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);

    retval = (HGADGET) GetHandle(DuRootGadget::GetFocus());

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetFocus (API)
*
* SetGadgetFocus() moves keyboard focus to the specified Gadget.  Both the
* current Gadget with keyboard focus and the Gadget being specified will be
* sent a GM_CHANGESTATE message with nCode=GSTATE_KEYBOARDFOCUS notifying of 
* the focus change.
*
* <return type="BOOL">      Focus was successfully moved.</>
* <see type="function">     GetGadgetFocus</>
* <see type="message">      GM_CHANGESTATE</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFocus(
    IN  HGADGET hgadFocus)          // Gadget to receive focus.
{
    DuVisual * pgadFocus;
    DuRootGadget * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadFocus);
    CHECK_MODIFY();

    //
    // TODO: Do we need to only allow the app to change focus if on the same
    // thread?  USER does this.
    //

    pgadRoot = pgadFocus->GetRoot();
    if (pgadRoot != NULL) {
        retval = pgadRoot->xdSetKeyboardFocus(pgadFocus);
    }

    END_RECV();
}


/***************************************************************************\
*
* IsGadgetParentChainStyle (API)
*
* IsGadgetParentChainStyle() checks if a Gadget parent change has the
* specified style bits set.
*
* <return type="BOOL">      Gadget was successfully checked.</>
* <see type="function">     GetGadgetStyle</>
* <see type="function">     SetGadgetStyle</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsGadgetParentChainStyle(
    IN  HGADGET hgad,               // Gadget to check visibility
    IN  UINT nStyle,                // Style bits to check
    OUT BOOL * pfChain,             // Chain state
    IN  UINT nFlags)                // Optional flags
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_VALUE(nFlags, 0);
    VALIDATE_FLAGS(nStyle, GS_VALID);
    VALIDATE_WRITE_PTR_(pfChain, sizeof(BOOL));
    CHECK_MODIFY();

    *pfChain = pgad->IsParentChainStyle(nStyle);
    retval = TRUE;

    END_RECV();
}



/***************************************************************************\
*
* SetGadgetFillI (API)
*
* SetGadgetFillI() specifies an optional brush to fill the Gadget's
* background with when drawing.  The background will be filled before the
* Gadget is given the GM_PAINT message to draw.
*
* <return type="BOOL">      Fill was successfully set.</>
* <see type="function">     UtilDrawBlendRect</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFillI(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  HBRUSH hbrFill,             // Brush to fill with or NULL to remove
    IN  BYTE bAlpha,                // Alpha level to apply brush
    IN  int w,                      // Optional width of brush when
                                    // alpha-blending or 0 for default
    IN  int h)                      // Optional height of brush when
                                    // alpha-blending or 0 for default
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->SetFill(hbrFill, bAlpha, w, h);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetFillF (API)
*
* SetGadgetFillF() specifies an optional brush to fill the Gadget's
* background with when drawing.  The background will be filled before the
* Gadget is given the GM_PAINT message to draw.
*
* <return type="BOOL">      Fill was successfully set.</>
* <see type="function">     UtilDrawBlendRect</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFillF(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  Gdiplus::Brush * pgpbr)     // Brush to fill with or NULL to remove
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->SetFill(pgpbr);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetScale (API)
*
* GetGadgetScale() returns the Gadget's scaling factor.  If the Gadget is
* not scaled, the factors will be X=1.0, Y=1.0.
*
* <return type="BOOL">      Successfully returned scaling factor</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetScale(
    IN  HGADGET hgad,               // Gadget to check
    OUT float * pflX,               // Horizontal scaling factor
    OUT float * pflY)               // Vertical scaling factor
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflX, sizeof(float));
    VALIDATE_WRITE_PTR_(pflY, sizeof(float));

    pgad->GetScale(pflX, pflY);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetScale (API)
*
* SetGadgetScale() changes the specified Gadget's scaling factor.  Scaling
* is determined from the upper-left corner of the Gadget and is applied
* dynamically during painting and hit-testing.  The Gadget's logical
* rectangle set by SetGadgetRect() does not change.
*
* When scaling is applied to a Gadget, the entire subtree of that Gadget is
* scaled.  To remove any scaling factor, use X=1.0, Y=1.0.
*
* <return type="BOOL">      Successfully changed scaling factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetScale(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  float flX,                  // New horizontal scaling factor
    IN  float flY)                  // New vertical scaling factor
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetScale(flX, flY);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetRotation (API)
*
* GetGadgetRotation() returns the Gadget's rotation factor in radians.  If
* a Gadget is not rotated, the factor will be 0.0.
*
* <return type="BOOL">      Successfully returned rotation factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetRotation(
    IN  HGADGET hgad,               // Gadget to check
    OUT float * pflRotationRad)     // Rotation factor in radians
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflRotationRad, sizeof(float));

    *pflRotationRad = pgad->GetRotation();
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetRotation (API)
*
* SetGadgetRotation() changes the specified Gadget's rotation factor in
* radians.  Scaling is determined from the upper-left corner of the Gadget
* and is applied dynamically during painting and hit-testing.  The Gadget's
* logical rectangle set by SetGadgetRect() does not change.
*
* When rotation is applied to a Gadget, the entire subtree of that Gadget is
* rotated.  To remove any rotation factor, use 0.0.
*
* <return type="BOOL">      Successfully changed scaling factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetRotation(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  float flRotationRad)        // New rotation factor in radians
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetRotation(flRotationRad);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetCenterPoint(HGADGET hgad, float * pflX, float * pflY)
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflX, sizeof(float));
    VALIDATE_WRITE_PTR_(pflY, sizeof(float));

    pgad->GetCenterPoint(pflX, pflY);
    retval = TRUE;

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetCenterPoint(HGADGET hgadChange, float flX, float flY)
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetCenterPoint(flX, flY);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetBufferInfo(
    IN  HGADGET hgad,               // Gadget to check
    OUT BUFFER_INFO * pbi)          // Buffer information
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_STRUCT(pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pbi->nMask, GBIM_VALID);

    if (!pgad->IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        SetError(DU_E_NOTBUFFERED);
        goto ErrorExit;
    }

    hr = pgad->GetBufferInfo(pbi);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
SetGadgetBufferInfo(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  const BUFFER_INFO * pbi)    // Buffer information
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    VALIDATE_READ_STRUCT(pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pbi->nMask, GBIM_VALID);

    if (!pgadChange->IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        SetError(DU_E_NOTBUFFERED);
        goto ErrorExit;
    }

    hr = pgadChange->SetBufferInfo(pbi);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetRgn(
    IN  HGADGET hgad,               // Gadget to get region of
    IN  UINT nRgnType,              // Type of region
    OUT HRGN hrgn,                  // Specified region
    IN  UINT nFlags)                // Modifying flags
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_RANGE(nRgnType, GRT_MIN, GRT_MAX);
    VALIDATE_REGION(rgn);
    
    hr = pgad->GetRgn(nRgnType, hrgn, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetRootInfo(
    IN  HGADGET hgadRoot,           // RootGadget to modify
    IN  ROOT_INFO * pri)      // Information
{
    DuRootGadget * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_ROOTGADGET(gadRoot);
    VALIDATE_WRITE_STRUCT(pri, ROOT_INFO);
    VALIDATE_FLAGS(pri->nMask, GRIM_VALID);

    pgadRoot->GetInfo(pri);
    retval = TRUE;

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetRootInfo(
    IN  HGADGET hgadRoot,           // RootGadget to modify
    IN  const ROOT_INFO * pri)      // Information
{
    DuRootGadget * pgadRoot;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_ROOTGADGET(gadRoot);
    VALIDATE_READ_STRUCT(pri, ROOT_INFO);
    VALIDATE_FLAGS(pri->nMask, GRIM_VALID);
    VALIDATE_FLAGS(pri->nOptions, GRIO_VALID);
    VALIDATE_RANGE(pri->nSurface, GSURFACE_MIN, GSURFACE_MAX);
    VALIDATE_RANGE(pri->nDropTarget, GRIDT_MIN, GRIDT_MAX);

    hr = pgadRoot->SetInfo(pri);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API HRESULT WINAPI
DUserSendMethod(
    IN  MethodMsg * pmsg)               // Message to send
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    MsgObject * pmo;
    UINT nResult;
    HRESULT hr;
    UINT hm;

    //
    // Validation for DUserSendMethod() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //
    // The Caller must be initialized, but we WON'T take the context-lock.
    // TODO: Investigate whether we should actually do this because it may
    // allow us to take off the lock on the DUserHeap.
    //
    // NOTE: This code has been HIGHLY optimized so that in-context Send 
    // messages will be as fast as possible.
    //

    nResult = DU_S_NOTHANDLED;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg >= GM_EVENT)) {
        PromptInvalid("Invalid parameters to SendGadgetMethod()");
        hr = E_INVALIDARG;
        goto Exit;
    }

    pmo = reinterpret_cast<MsgObject *>(hgadMsg);
    hm  = pmo->GetHandleMask();
    if (!TestFlag(hm, hmMsgObject)) {
        PromptInvalid("Object is not a valid Gadget");
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (TestFlag(hm, hmEventGadget)) {
        DuEventGadget * pgadMsg = static_cast<DuEventGadget *>(pmo);
        pctxSend    = RawGetContext();
        pctxGad     = pgadMsg->GetContext();
        AssertMsg(pctxGad != NULL, "Fully created DuEventGadget must have a Context");

        if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
            PromptInvalid("Illegally using an orphaned Context");
            hr = E_INVALIDARG;
            goto Exit;
        }

        if (pctxSend == pctxGad) {
            pmo->InvokeMethod(pmsg);
            hr = S_OK;
            goto Exit;
        } else {
            hr = GetCoreSC(pctxSend)->xwSendMethodNL(GetCoreSC(pctxGad), pmsg, pmo);
        }
    } else {
        //
        // For non-BaseGadgets, use the current context.  This means that we can 
        // invoke directly.
        //

        pmo->InvokeMethod(pmsg);
        hr = S_OK;
    }

Exit:
    return hr;
}


/***************************************************************************\
*
* SendGadgetEvent (API)
*
* SendGadgetEvent() sends a message to the specified Gadget.  The function
* calls the Gadget procedure and does not return until the Gadget has
* processed the message.
*
* <param name="pmsg">
*       Several members of the GMSG must be previously filled to correctly send
*       the message to the specified Gadget.
*       <table item="Field" desc="Description">
*           cbSize          Size of the message being sent in bytes.
*           nMsg            ID of the message.
*           hgadMsg         Gadget that the message is being sent to.
*           result          Default result value.
*       </table>
* </param>
*
* <param nane="nFlags">
*       Specifies optional flags to modify how the message is sent to the Gadget.
*       <table item="Value" desc="Action">
*           SGM_BUBBLE      The message will be fully routed and bubbled inside
*                           the Gadget Tree.  If this flag is not specified, the
*                           message will only be sent directly to the Gadget and
*                           any attached Message Handlers.
*       </table>
* </param>
*
* <return type="UINT">
*       Return value specifying how message was handled:
*       <table item="Value" desc="Action">
*           GPR_COMPLETE    The message was completely handled by a Gadget
*                           in the processing loop.
*           GPR_PARTIAL     The message was partially handled by one or
*                           more Gadget in the processing loop, but was never
*                           completely handled.
*           GPR_NOTHANDLED  The message was never handled by any Gadgets in
*                           the processing loop.
*       </table>
* </return>
*
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserSendEvent(
    IN  EventMsg * pmsg,          // Message to send
    IN  UINT nFlags)                // Optional flags to modifying sending
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    DuEventGadget * pgad;
    HRESULT nResult;
    UINT hm;

    //
    // Validation for SendGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //
    // The Caller must be initialized, but we WON'T take the context-lock.
    // TODO: Investigate whether we should actually do this because it may
    // allow us to take off the lock on the DUserHeap.
    //
    // NOTE: This code has been HIGHLY optimized so that in-context Send 
    // messages will be as fast as possible.
    //

    nResult = E_INVALIDARG;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg < GM_EVENT)) {
        PromptInvalid("Invalid parameters to SendGadgetEvent()");
        goto Error;
    }

    pgad    = reinterpret_cast<DuEventGadget *>(hgadMsg);
    hm      = pgad->GetHandleMask();
    if (!TestFlag(hm, hmEventGadget)) {
        PromptInvalid("Object is not a valid BaseGadget");
        goto Error;
    }

    pctxSend    = RawGetContext();
    pctxGad     = pgad->GetContext();
    AssertMsg(pctxGad != NULL, "Fully created DuEventGadget must have a Context");

    if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        goto Error;
    }

    if (pctxSend == pctxGad) {
        const GPCB & cb = pgad->GetCallback();
        if (TestFlag(nFlags, SGM_FULL) && TestFlag(hm, hmVisual)) {
            nResult = cb.xwInvokeFull((const DuVisual *) pgad, pmsg, 0);
        } else {
            nResult = cb.xwInvokeDirect(pgad, pmsg, 0);
        }
    } else {
        nResult = GetCoreSC(pctxSend)->xwSendEventNL(GetCoreSC(pctxGad), pmsg, pgad, nFlags);
    }

    return nResult;

Error:
    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
DUSER_API HRESULT WINAPI
DUserPostMethod(
    IN  MethodMsg * pmsg)               // Message to post
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    MsgObject * pmo;
    UINT nResult;
    HRESULT hr;
    UINT hm;

    //
    // Validation for PostGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    nResult = DU_S_NOTHANDLED;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg >= GM_EVENT)) {
        PromptInvalid("Invalid parameters to DUserPostMethod()");
        hr = E_INVALIDARG;
        goto Exit;
    }

    pmo = reinterpret_cast<MsgObject *>(hgadMsg);
    hm  = pmo->GetHandleMask();
    if (!TestFlag(hm, hmMsgObject)) {
        PromptInvalid("Object is not a valid Gadget");
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (TestFlag(hm, hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        pctxSend    = RawGetContext();
        pctxGad     = pgad->GetContext();
        AssertMsg(pctxGad != NULL, "Fully created Gadgets must have a Context");
    } else {
        //
        // For non-BaseGadgets, use the current context.
        //

        pctxSend = pctxGad = GetContext();
        if (pctxGad == NULL) {
            PromptInvalid("Must initialize Context before using thread");
            hr = DU_E_NOCONTEXT;
            goto Exit;
        }
    }

    if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = GetCoreSC(pctxSend)->PostMethodNL(GetCoreSC(pctxGad), pmsg, pmo);

Exit:
    return hr;
}


/***************************************************************************\
*
* DUserPostEvent (API)
*
* DUserPostEvent() posts a message to the specified Gadget.  The function
* calls the Gadget procedure and returns after the message has bee successfully
* posted to the owning messsage queue.
*
* <param name="pmsg">
*       Several members of the GMSG must be previously filled to correctly send
*       the message to the specified Gadget.
*       <table item="Field" desc="Description">
*           cbSize          Size of the message being sent in bytes.
*           nMsg            ID of the message.
*           hgadMsg         Gadget that the message is being sent to.
*           result          Default result value.
*       </table>
* </param>
*
* <param nane="nFlags">
*       Specifies optional flags to modify how the message is sent to the Gadget.
*       <table item="Value" desc="Action">
*           SGM_BUBBLE      The message will be fully routed and bubbled inside
*                           the Gadget Tree.  If this flag is not specified, the
*                           message will only be sent directly to the Gadget and
*                           any attached Message Handlers.
*       </table>
* </param>
*
* <return type="BOOL">
*       Message was successfully posted to the destination Gadget's queue.
* </return>
*
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserPostEvent(
    IN  EventMsg * pmsg,          // Message to post
    IN  UINT nFlags)                // Optional flags modifiying posting
{
    Context * pctxGad;
    HGADGET hgad;
    DuEventGadget * pgad;
    HRESULT hr;

    //
    // Validation for PostGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    VALIDATE_READ_PTR_(pmsg, pmsg->cbSize);
    VALIDATE_FLAGS(nFlags, SGM_VALID);

    if (pmsg->nMsg < GM_EVENT) {
        PromptInvalid("Can not post private messages");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    if (!IsInitContext()) {
        PromptInvalid("Must initialize Context before using thread");
        SetError(DU_E_NOCONTEXT);
        goto ErrorExit;
    }

    hgad = pmsg->hgadMsg;
    VALIDATE_EVENTGADGET_NOCONTEXT(gad);
    pctxGad = pgad->GetContext();

    if (pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        goto ErrorExit;
    }

    hr = GetCoreSC()->PostEventNL(GetCoreSC(pctxGad), pmsg, pgad, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
FireGadgetMessages(
    IN  FGM_INFO * rgFGM,           // Collection of messsages to fire
    IN  int cMsgs,                  // Number of messages
    IN  UINT idQueue)               // Queue to send messages
{
    Context * pctxGad, * pctxCheck;
    HGADGET hgad;
    DuEventGadget * pgad;
    HRESULT hr;
    int idx;

    //
    // Validation for FireGadgetMessages() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    if (cMsgs <= 0) {
        PromptInvalid("Must specify a valid number of messages to process.");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    hgad = rgFGM[0].pmsg->hgadMsg;
    VALIDATE_EVENTGADGET_NOCONTEXT(gad);
    pctxGad = pgad->GetContext();

    for (idx = 0; idx < cMsgs; idx++) {
        FGM_INFO & fgm = rgFGM[idx];

        EventMsg * pmsg = fgm.pmsg;
        VALIDATE_READ_PTR_(pmsg, pmsg->cbSize);
        VALIDATE_FLAGS(fgm.nFlags, SGM_VALID);
        if (pmsg->nMsg <= 0) {
            PromptInvalid("Can not post private messages");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }

        if (TestFlag(fgm.nFlags, SGM_RECEIVECONTEXT)) {
            PromptInvalid("Can not use SGM_RECEIVECONTEXT with FireGadgetMessage");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }

        hgad = pmsg->hgadMsg;
        VALIDATE_EVENTGADGET_NOCONTEXT(gad);
        pctxCheck = pgad->GetContext();
        if (pctxCheck != pctxGad) {
            PromptInvalid("All Gadgets must be inside the same Context");
            SetError(DU_E_INVALIDCONTEXT);
            goto ErrorExit;
        }


        //
        // Store the validated Gadget back so that it doesn't need to be 
        // revalidated.
        //

        fgm.pvReserved = pgad;
    }

    hr = GetCoreSC()->xwFireMessagesNL(GetCoreSC(pctxGad), rgFGM, cMsgs, idQueue);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* GetMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetMessageExA(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, PM_REMOVE, CoreSC::smGetMsg | CoreSC::smAnsi);
    }

    END_RECV_NOCONTEXT();
}


DUSER_API BOOL WINAPI
GetMessageExW(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, PM_REMOVE, CoreSC::smGetMsg);
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* PeekMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
PeekMessageExA(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax,
    IN  UINT wRemoveMsg)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, wRemoveMsg, CoreSC::smAnsi);
    }

    END_RECV_NOCONTEXT();
}


DUSER_API BOOL WINAPI
PeekMessageExW(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax,
    IN  UINT wRemoveMsg)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, wRemoveMsg, 0);
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* WaitMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
WaitMessageEx()
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = WaitMessage();
    } else {
        AssertInstance(pctxThread);
        GetCoreSC(pctxThread)->WaitMessage();
        retval = TRUE;
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* RegisterGadgetMessage (API)
*
* RegisterGadgetMessage() defines a new private Gadget message that is
* guaranteed to be unique throughout the process.  This MSGID can be used
* when calling SendGadgetEvent or PostGadgetEvent.  The MSGID is only
* valid for the lifetime of the process.
*
* <remarks>
* Multiple calls to RegisterGadgetMessage() with the same ID will produce
* the same MSGID.
*
* RegisterGadgetMessage() differs in use from RegisterWindowMessage() in
* that Gadgets are encouraged to use RegisterGadgetMessage() for all
* private messages.  This helps with version compatibility problems where
* newer Gadget control implementations may use additional message and could
* potentially overrun any static MSGID assignments.
*
* The MSGID's returned from RegisterGadgetMessage() and
* RegisterGadgetMessageString() are guaranteed to not conflict with each
* other.  However, RegisterGadgetMessage() is the preferred mechanism for
* registering private messages because of the reduced likelihood of
* ID conflicts.
* </remarks>
*
* <return type="MSGID">     ID of new message or 0 if failed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API MSGID WINAPI
RegisterGadgetMessage(
    IN  const GUID * pguid)         // Unique GUID of message to register
{
    HRESULT hr;
    MSGID msgid;

    BEGIN_RECV_NOCONTEXT(MSGID, PRID_Unused);

    hr = DuEventPool::RegisterMessage(pguid, ptGlobal, &msgid);
    SET_RETURN(hr, msgid);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* RegisterGadgetMessageString (API)
*
* RegisterGadgetMessageString() defines a new private Gadget message that is
* guaranteed to be unique throughout the process.  This MSGID can be used
* when calling SendGadgetEvent() or PostGadgetEvent().  The MSGID is only
* valid for the lifetime of the process.
*
* <remarks>
* See RegisterGadgetMessage() for more information about MSGID's.
* </remarks>
*
* <return type="MSGID">     ID of new message or 0 if failed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API MSGID WINAPI
RegisterGadgetMessageString(
    IN  LPCWSTR pszName)            // Unique string ID of message to register
{
    HRESULT hr;
    MSGID msgid;

    BEGIN_RECV_NOCONTEXT(MSGID, PRID_Unused);
    VALIDATE_STRINGW_PTR(pszName, 128);

    hr = DuEventPool::RegisterMessage(pszName, ptGlobal, &msgid);
    SET_RETURN(hr, msgid);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* UnregisterGadgetMessage (API)
*
* UnregisterGadgetMessage() decreases the reference count of a private
* message by one.  When the reference count reaches 0, resources allocated
* to store information about that private message are released, and the
* MSGID is no longer valid.
*
* <return type="BOOL">      Message was successfully unregistered.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
UnregisterGadgetMessage(
    IN  const GUID * pguid)         // Unique GUID of message to unregister
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    hr = DuEventPool::UnregisterMessage(pguid, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* UnregisterGadgetMessageString (API)
*
* UnregisterGadgetMessageString() decreases the reference count of a private
* message by one.  When the reference count reaches 0, resources allocated
* to store information about that private message are released, and the
* MSGID is no longer valid.
*
* <return type="BOOL">      Message was successfully unregistered.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
UnregisterGadgetMessageString(
    IN  LPCWSTR pszName)            // Unique string ID of message to register
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    VALIDATE_STRINGW_PTR(pszName, 128);

    hr = DuEventPool::UnregisterMessage(pszName, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
FindGadgetMessages(
    IN  const GUID ** rgpguid,      // GUID's of messages to find
    OUT MSGID * rgnMsg,             // MSGID's of corresponding to messages
    IN  int cMsgs)                  // Number of messages
{
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_RANGE(cMsgs, 1, 1000); // Ensure don't have an excessive number of lookups

    hr = DuEventPool::FindMessages(rgpguid, rgnMsg, cMsgs, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* AddGadgetMessageHandler (API)
*
* AddGadgetMessageHandler() adds a given Gadget to the list of message
* handlers for another Gadget.  Messages that are sent directly to hgadMsg
* will also be sent to hgadHandler as an GMF_EVENT.
*
* <remarks>
* A message handler can be any Gadget.  Once registered, hgadHandler will
* receive all messages sent to hgadMsg with a corresponding MSGID.  Any
* valid public or private message can be listened it.  If nMsg==0, all
* messages will be sent to hgadHandler.
*
* A single hgadHandler may be registered multiple times to handle different
* messages from hgadMsg.
* </remarks>
*
* <return type="BOOL">      Handler was successfully added.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
AddGadgetMessageHandler(
    IN  HGADGET hgadMsg,            // Gadget to attach to
    IN  MSGID nMsg,                 // Message to watch for
    IN  HGADGET hgadHandler)        // Gadget to notify
{
    DuEventGadget * pgadMsg;
    DuEventGadget * pgadHandler;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadMsg);
    VALIDATE_EVENTGADGET(gadHandler);
    if (((nMsg < PRID_GlobalMin) && (nMsg > 0)) || (nMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    hr = pgadMsg->AddMessageHandler(nMsg, pgadHandler);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* RemoveGadgetMessageHandler (API)
*
* RemoveGadgetMessageHandler() removes the specified hgadHandler from the
* list of message handlers attached to hgadMsg.  Only the first hgadHandler
* with a corresponding nMsg will be removed.
*
* <return type="BOOL">      Handler was successfully removed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
RemoveGadgetMessageHandler(
    IN  HGADGET hgadMsg,            // Gadget to detach from
    IN  MSGID nMsg,                 // Message being watched for
    IN  HGADGET hgadHandler)        // Gadget being notified
{
    DuEventGadget * pgadMsg;
    DuEventGadget * pgadHandler;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadMsg);
    VALIDATE_EVENTGADGET(gadHandler);
    if (((nMsg < PRID_GlobalMin) && (nMsg > 0)) || (nMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    hr = pgadMsg->RemoveMessageHandler(nMsg, pgadHandler);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetStyle (API)
*
* GetGadgetStyle() returns the current style of the given Gadget.
*
* <remarks>
* For a list of Gadget styles, see SetGadgetStyle().
* </remarks>
*
* <return type="UINT">      Current style of Gadget.</>
* <see type="function">     SetGadgetStyle</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API UINT WINAPI
GetGadgetStyle(
    IN  HGADGET hgad)               // Handle of Gadget
{
    DuVisual * pgad;

    BEGIN_RECV(UINT, 0, ContextLock::edNone);
    VALIDATE_VISUAL(gad);

    retval = pgad->GetStyle();

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetStyle (API)
*
* SetGadgetStyle() changes the current style of the given Gadget.  Only the
* styles specified by nMask are actually changed.  If multiple style changes
* are requested, but any changes fail, the successfully change styles will
* not be reverted back.
*
* <param name="nNewStyle">
*       nNewStyle can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GS_RELATIVE     The position of the Gadget is internally stored
*                           relative to parent.  This is the preferred style
*                           if the Gadget will be moved more frequently,
*                           such as when scrolling.
*           GS_VISIBLE      The Gadget is visible.
*           GS_ENABLED      The Gadget can receive input.
*           GS_BUFFERED     Drawing of the Gadget is double-buffered.
*           GS_ALLOWSUBCLASS Gadget supports being subclassed.
*           GS_WANTFOCUS    Gadget can receive keyboard focus.
*           GS_CLIPINSIDE   Drawing of this Gadget will be clipped inside
*                           the Gadget.
*           GS_CLIPSIBLINGS Drawing of this Gadget will exclude any area of
*                           overlapping siblings that are higher in z-order.
*           GS_OPAQUE       HINT: Support for composited drawing is
*                           unnecessary.
*           GS_ZEROORIGIN   Set the origin to (0,0)
*       </table>
* </param>
*
* <return type="BOOL">      All style changes were successful.</>
* <see type="function">     GetGadgetStyle</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetStyle(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  UINT nNewStyle,             // New style
    IN  UINT nMask)                 // Style bits to change
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    VALIDATE_FLAGS(nNewStyle, GS_VALID);
    VALIDATE_FLAGS(nMask, GS_VALID);
    CHECK_MODIFY();

    hr = pgadChange->xdSetStyle(nNewStyle, nMask);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API PRID WINAPI  
RegisterGadgetProperty(
    IN  const GUID * pguid)         // Unique GUID of message to register
{
    HRESULT hr;
    PRID prid;

    BEGIN_RECV_NOCONTEXT(PRID, PRID_Unused);

    hr = DuVisual::RegisterPropertyNL(pguid, ptGlobal, &prid);
    SET_RETURN(hr, prid);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
UnregisterGadgetProperty(
    const GUID * pguid)
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    hr = DuVisual::UnregisterPropertyNL(pguid, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetProperty(HGADGET hgad, PRID id, void ** ppvValue)
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(ppvValue, sizeof(ppvValue));
    CHECK_MODIFY();

    hr = pgad->GetProperty(id, ppvValue);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
SetGadgetProperty(HGADGET hgad, PRID id, void * pvValue)
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    hr = pgad->SetProperty(id, pvValue);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
RemoveGadgetProperty(HGADGET hgad, PRID id)
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    pgad->RemoveProperty(id, FALSE /* Can't free memory for Global property*/);
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
EnumGadgets(HGADGET hgadEnum, GADGETENUMPROC pfnProc, void * pvData, UINT nFlags)
{
    DuVisual * pgadEnum;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_FLAGS(nFlags, GENUM_VALID);
    VALIDATE_VISUAL(gadEnum);
    VALIDATE_CODE_PTR(pfnProc);
    CHECK_MODIFY();

    hr = pgadEnum->xwEnumGadgets(pfnProc, pvData, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetSize (API)
*
* GetGadgetSize() is a high-performance mechanism of retreiving the Gadget's
* logical size.
*
* <return type="BOOL">      Successfully returned size in logical pixels.</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetSize(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT SIZE * psizeLogicalPxl)     // Size in logical pixels
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(psizeLogicalPxl, sizeof(SIZE));

    pgad->GetSize(psizeLogicalPxl);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetRect (API)
*
* GetGadgetRect() is a flexible mechanism of retreiving the Gadget's
* logical rectangle or actual bounding box.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           SGR_CLIENT      Coordinates are relative to the Gadget itself.
*           SGR_PARENT      Coordinates are relative to the Gadget's parent.
*           SGR_CONTAINER   Coordinates are relative to the Gadget's root
*                           container.
*           SGR_DESKTOP     Coordinates are relative to the Windows desktop.
*           SGR_ACTUAL      Return the bounding rectangle of the Gadget.  If
*                           this flag is specified, a bounding box is
*                           computed from all transformations applied from
*                           the root to the Gadget itself.  If this flag is
*                           not specified, the rectangle returned will be in
*                           logical coordinates.
*       </table>
* </param>
*
* <return type="BOOL">      Rectangle was successfully retreived.</>
* <see type="function">     SetGadgetRect</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetRect(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT RECT * prcPxl,              // Rectangle in specified pixels
    IN  UINT nFlags)                // Rectangle to retrieve
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_FLAGS(nFlags, SGR_VALID_GET);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(prcPxl, sizeof(RECT));

    if (TestFlag(nFlags, SGR_ACTUAL)) {
        AssertMsg(0, "TODO: Not Implemented");
    } else {
        pgad->GetLogRect(prcPxl, nFlags);
        retval = TRUE;
    }

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetRect (API)
*
* SetGadgetRect() changes the size or position of a given Gadget.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           SGR_MOVE        Move to Gadget to a new location specified by
*                           x, y.
*           SGR_SIZE        Change the Gadget's size to width w and height h.
*           SGR_CLIENT      Coordinates are relative to the Gadget itself.
*           SGR_PARENT      Coordinates are relative to the Gadget's parent.
*           SGR_CONTAINER   Coordinates are relative to the Gadget's root
*                           container.
*           SGR_DESKTOP     Coordinates are relative to the Windows desktop.
*           SGR_OFFSET      Coordinates are relative to the Gadget's current
*                           location.
*           SGR_ACTUAL      Return the bounding rectangle of the Gadget.  If
*                           this flag is specified, a bounding box is
*                           computed from all transformations applied from
*                           the root to the Gadget itself.  If this flag is
*                           not specified, the rectangle returned will be in
*                           logical coordinates.
*       </table>
* </param>
*
* <return type="BOOL">      Rectangle was successfully retreived.</>
* <see type="function">     SetGadgetRect</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetRect(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  int x,                      // New horizontal position
    IN  int y,                      // New vertical position
    IN  int w,                      // New width
    IN  int h,                      // New height
    IN  UINT nFlags)                // Flags specifying what to change
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_FLAGS(nFlags, SGR_VALID_SET);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    if (pgadChange->IsRoot()) {
        if (TestFlag(nFlags, SGR_MOVE)) {
            PromptInvalid("Can not move a RootGadget");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }
    }


    //
    // Ensure that size is non-negative
    //

    if (TestFlag(nFlags, SGR_SIZE)) {
        if (w < 0) {
            w = 0;
        }
        if (h < 0) {
            h = 0;
        }
    }

    if (TestFlag(nFlags, SGR_ACTUAL)) {
//        AssertMsg(0, "TODO: Not Implemented");
        ClearFlag(nFlags, SGR_ACTUAL);
        hr = pgadChange->xdSetLogRect(x, y, w, h, nFlags);
    } else {
        hr = pgadChange->xdSetLogRect(x, y, w, h, nFlags);
    }
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* FindGadgetFromPoint (API)
*
* FindGadgetFromPoint() determines which Gadget a contains the specified
* point.
*
* <return type="HGADGET">   Gadget containing point or NULL for none.</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
FindGadgetFromPoint(
    IN  HGADGET hgad,               // Gadget to search from
    IN  POINT ptContainerPxl,       // Point to search from in container pixels
    IN  UINT nStyle,                // Required style flags
    OUT POINT * pptClientPxl)       // Optional translated point in client pixels.
{
    DuVisual * pgad;

    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);
    VALIDATE_FLAGS(nStyle, GS_VALID);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_OR_NULL_(pptClientPxl, sizeof(POINT));

    retval = (HGADGET) GetHandle(pgad->FindFromPoint(ptContainerPxl, nStyle, pptClientPxl));

    END_RECV();
}


/***************************************************************************\
*
* MapGadgetPoints (API)
*
* MapGadgetPoints() converts a set of points in client-pixels relative to 
* one Gadget into points in client-pixels relative to another Gadget.
*
* <return type="HGADGET">   Gadget containing point or NULL for none.</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
MapGadgetPoints(
    IN  HGADGET hgadFrom, 
    IN  HGADGET hgadTo, 
    IN OUT POINT * rgptClientPxl, 
    IN  int cPts)
{
    DuVisual * pgadFrom, * pgadTo;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gadFrom);
    VALIDATE_VISUAL(gadTo);
    VALIDATE_WRITE_PTR_(rgptClientPxl, sizeof(POINT) * cPts);

    if (pgadFrom->GetRoot() != pgadTo->GetRoot()) {
        PromptInvalid("Must be in the same tree");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    DuVisual::MapPoints(pgadFrom, pgadTo, rgptClientPxl, cPts);
    retval = TRUE;

    END_RECV();
}



/***************************************************************************\
*
* SetGadgetOrder (API)
*
* SetGadgetOrder() changes the Gadget's z-order relative to its siblings.
* The parent of the Gadget is not changed.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GORDER_ANY      The order does not matter.
*           GORDER_BEFORE   Move this gadget in-front of sibling hgadOther.
*           GORDER_BEHIND   Move this gadget behind sibling hgadOther.
*           GORDER_TOP      Move this gadget to front of sibling z-order.
*           GORDER_BOTTOM   Move this gadget to bottom of sibling z-order.
*           GORDER_FORWARD  Move this gadget forward in sibling z-order.
*           GORDER_BACKWARD Move this gadget backward in sibling z-order.
*       </table>
* </param>
*
* <return type="BOOL">      Gadget z-order was successfully changed.</>
* <see type="function">     SetGadgetParent</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetOrder(
    IN  HGADGET hgadMove,           // Gadget to be moved
    IN  HGADGET hgadOther,          // Gadget to moved relative to
    IN  UINT nCmd)                  // Type of move
{
    DuVisual * pgadMove;
    DuVisual * pgadOther;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL(gadMove);
    VALIDATE_VISUAL_OR_NULL(gadOther);
    CHECK_MODIFY();

    hr = pgadMove->xdSetOrder(pgadOther, nCmd);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetParent (API)
*
* SetGadgetParent() changes the Gadget's parent.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GORDER_ANY      The order does not matter.
*           GORDER_BEFORE   Move this gadget in-front of sibling hgadOther.
*           GORDER_BEHIND   Move this gadget behind sibling hgadOther.
*           GORDER_TOP      Move this gadget to front of sibling z-order.
*           GORDER_BOTTOM   Move this gadget to bottom of sibling z-order.
*           GORDER_FORWARD  Move this gadget forward in sibling z-order.
*           GORDER_BACKWARD Move this gadget backward in sibling z-order.
*       </table>
* </param>
*
* <return type="BOOL">      Gadget parent and z-order were successfully changed.</>
* <see type="function">     SetGadgetOrder</>
* <see type="function">     GetGadget</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetParent(
    IN  HGADGET hgadMove,           // Gadget to be moved
    IN  HGADGET hgadParent,         // New parent
    IN  HGADGET hgadOther,          // Gadget to moved relative to
    IN  UINT nCmd)                  // Type of move
{
    DuVisual * pgadMove;
    DuVisual * pgadParent;
    DuVisual * pgadOther;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL(gadMove);
    VALIDATE_VISUAL_OR_NULL(gadParent);
    VALIDATE_VISUAL_OR_NULL(gadOther);
    CHECK_MODIFY();

    if (pgadMove->IsRoot()) {
        PromptInvalid("Can not change a RootGadget's parent");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    //
    // Check that can become a child of the specified parent
    //

    if ((!pgadMove->IsRelative()) && pgadParent->IsRelative()) {
        PromptInvalid("Can not set non-relative child to a relative parent");
        SetError(DU_E_BADCOORDINATEMAP);
        goto ErrorExit;
    }

    //
    // DuVisual::xdSetParent() handles if pgadParent is NULL and will move to the
    // parking window.
    //

    hr = pgadMove->xdSetParent(pgadParent, pgadOther, nCmd);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadget (API)
*
* GetGadget() retrieves the Gadget that has the specified relationship to
* the specified Gadget.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GG_PARENT       Return the parent of the specified Gadget.
*           GG_NEXT         Return the next sibling behind the specified
*                           Gadget.
*           GG_PREV         Return the previous sibling before the
*                           specified Gadget.
*           GG_TOPCHILD     Return the Gadget's top z-ordered child.
*           GG_BOTTOMCHILD  Return the Gadget's bottom z-ordered child.
*       </table>
* </param>
*
* <return type="BOOL">      Related Gadget or NULL for none.</>
* <see type="function">     SetGadgetOrder</>
* <see type="function">     SetGadgetParent</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
GetGadget(
    IN  HGADGET hgad,               // Handle of Gadget
    IN  UINT nCmd)                  // Relationship
{
    DuVisual * pgad;

    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_RANGE(nCmd, GG_MIN, GG_MAX);

    retval = (HGADGET) GetHandle(pgad->GetGadget(nCmd));

    END_RECV();
}


/***************************************************************************\
*
* InvalidateGadget (API)
*
* InvalidateGadget() marks a Gadget to be repainted during the next painting
* cycle.
*
* <return type="BOOL">      Gadget was successfully invalidated.</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
InvalidateGadget(
    IN  HGADGET hgad)               // Gadget to repaint
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    pgad->Invalidate();
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API UINT WINAPI
GetGadgetMessageFilter(HGADGET hgad, void * pvCookie)
{
    DuEventGadget * pgad;

    BEGIN_RECV(UINT, 0, ContextLock::edNone);
    VALIDATE_EVENTGADGET(gad);
    VALIDATE_VALUE(pvCookie, NULL);

    retval = (pgad->GetFilter() & GMFI_VALID);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetMessageFilter(HGADGET hgadChange, void * pvCookie, UINT nNewFilter, UINT nMask)
{
    DuEventGadget * pgadChange;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadChange);
    VALIDATE_FLAGS(nNewFilter, GMFI_VALID);
    VALIDATE_VALUE(pvCookie, NULL);
    CHECK_MODIFY();

    pgadChange->SetFilter(nNewFilter, nMask);
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr)
{
    DuVisual * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadRoot);
    VALIDATE_WRITE_PTR(pr);
    CHECK_MODIFY();

    retval = GdForwardMessage(pgadRoot, nMsg, wParam, lParam, pr);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
DrawGadgetTree(HGADGET hgadDraw, HDC hdcDraw, const RECT * prcDraw, UINT nFlags)
{
    DuVisual * pgadDraw;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadDraw);
    VALIDATE_READ_PTR_OR_NULL_(prcDraw, sizeof(RECT));
    VALIDATE_FLAGS(nFlags, GDRAW_VALID);

    retval = GdxrDrawGadgetTree(pgadDraw, hdcDraw, prcDraw, nFlags);

    END_RECV();
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser GADGET API
*
* <package name="Msg"/>
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DUserRegisterGuts
*
* DUserRegisterGuts() registers the implementation of a MsgClass.
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterGuts(
    IN OUT DUser::MessageClassGuts * pmcInfo) // Class information
{
    MsgClass * pmcNew;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassGuts);

    hr = GetClassLibrary()->RegisterGutsNL(pmcInfo, &pmcNew);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcNew));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserRegisterStub
*
* DUserRegisterStub() registers a Stub for a MsgClass
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterStub(
    IN OUT DUser::MessageClassStub * pmcInfo) // Class information
{
    MsgClass * pmcFind;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassStub);

    hr = GetClassLibrary()->RegisterStubNL(pmcInfo, &pmcFind);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserRegisterSuper
*
* DUserRegisterSuper() registers a Super for a MsgClass
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo) // Class information
{
    MsgClass * pmcFind;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassSuper);

    hr = GetClassLibrary()->RegisterSuperNL(pmcInfo, &pmcFind);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserFindClass
*
* DUserFindClass() finds a previously registered Gadget Class
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserFindClass(
    IN  LPCWSTR pszName, 
    IN  DWORD nVersion)
{
    const MsgClass * pmcFind = NULL;
    ATOM atom;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_VALUE(nVersion, 1);        // Currently, all classes are version 1

    atom = FindAtomW(pszName);
    if (atom == 0) {
        hr = DU_E_NOTFOUND;
    } else {
        pmcFind = GetClassLibrary()->FindClass(atom);
        hr = S_OK;
    }
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserBuildGadget
*
* DUserBuildGadget() creates a fully initialized Gadget using the specified
* MsgClass.
* 
\***************************************************************************/

DUSER_API DUser::Gadget * WINAPI  
DUserBuildGadget(
    IN  HCLASS hcl,                     // Class to construct
    IN  DUser::Gadget::ConstructInfo * pciData) // Construction data
{
    MsgClass * pmc = ValidateMsgClass(hcl);
    if (pmc == NULL) {
        return NULL;
    }

    MsgObject * pmoNew;
    HRESULT hr = pmc->xwBuildObject(&pmoNew, pciData);
    if (FAILED(hr)) {
        return NULL;
    }

    return pmoNew->GetGadget();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
DUserInstanceOf(DUser::Gadget * pg, HCLASS hclTest)
{
    MsgObject * pmo;
    MsgClass * pmcTest;

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("The specified Gadget is invalid");
        goto Error;
    }

    pmcTest = ValidateMsgClass(hclTest);
    if (pmcTest == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->InstanceOf(pmcTest);

Error:
    SetError(E_INVALIDARG);
    return FALSE;
}


//------------------------------------------------------------------------------
DUSER_API DUser::Gadget * WINAPI
DUserCastClass(DUser::Gadget * pg, HCLASS hclTest)
{
    MsgObject * pmo;
    MsgClass * pmcTest;

    //
    // A NULL MsgObject is a valid input, so return NULL.
    //

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        return NULL;
    }


    //
    // The HCLASS must be valid.
    //

    pmcTest = ValidateMsgClass(hclTest);
    if (pmcTest == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->CastClass(pmcTest);

Error:
    SetError(E_INVALIDARG);
    return NULL;
}


//------------------------------------------------------------------------------
DUSER_API DUser::Gadget * WINAPI
DUserCastDirect(HGADGET hgad)
{
    return MsgObject::CastGadget(hgad);
}


//------------------------------------------------------------------------------
DUSER_API HGADGET WINAPI
DUserCastHandle(DUser::Gadget * pg)
{
    return MsgObject::CastHandle(pg);
}


//------------------------------------------------------------------------------
DUSER_API void * WINAPI
DUserGetGutsData(DUser::Gadget * pg, HCLASS hclData)
{
    MsgObject * pmo;
    MsgClass * pmcData;

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("The specified Gadget is invalid");
        goto Error;
    }

    pmcData = ValidateMsgClass(hclData);
    if (pmcData == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->GetGutsData(pmcData);

Error:
    SetError(E_INVALIDARG);
    return NULL;
}



/***************************************************************************\
*****************************************************************************
*
* DirectUser GADGET API
*
* <package name="Lava"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
AttachWndProcA(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdAttachWndProc(hwnd, pfn, pvThis, TRUE);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdAttachWndProc(hwnd, pfn, pvThis, FALSE);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdDetachWndProc(hwnd, pfn, pvThis);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser MOTION API
*
* <package name="Motion"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API HTRANSITION WINAPI
CreateTransition(const GTX_TRXDESC * ptx)
{
    BEGIN_RECV(HTRANSITION, NULL, ContextLock::edDefer);
    VALIDATE_READ_PTR_(ptx, sizeof(GTX_TRXDESC));
    CHECK_MODIFY();

    retval = (HTRANSITION) GetHandle(GdCreateTransition(ptx));

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
PlayTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));
    VALIDATE_FLAGS(pgx->nFlags, GTX_EXEC_VALID);

    retval = ptrx->Play(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetTransitionInterface(HTRANSITION htrx, IUnknown ** ppUnk)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_TRANSITION(trx);
    VALIDATE_WRITE_PTR(ppUnk);

    retval = ptrx->GetInterface(ppUnk);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BeginTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));

    retval = ptrx->Begin(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
PrintTransition(HTRANSITION htrx, float fProgress)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);

    retval = ptrx->Print(fProgress);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
EndTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));

    retval = ptrx->End(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API HACTION WINAPI
CreateAction(const GMA_ACTION * pma)
{
    BEGIN_RECV(HACTION, NULL, ContextLock::edNone);
    VALIDATE_READ_STRUCT(pma, GMA_ACTION);

    retval = GdCreateAction(pma);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetActionTimeslice(DWORD * pdwTimeslice)
{
    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_WRITE_PTR(pdwTimeslice);

    *pdwTimeslice = GetMotionSC()->GetTimeslice();
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetActionTimeslice(DWORD dwTimeslice)
{
    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);

    GetMotionSC()->SetTimeslice(dwTimeslice);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser UTIL API
*
* <package name="Util"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API COLORREF WINAPI
GetStdColorI(UINT c)
{
    BEGIN_RECV_NOCONTEXT(COLORREF, RGB(0, 0, 0));
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetColorI();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Color WINAPI
GetStdColorF(UINT c)
{
    BEGIN_RECV_NOCONTEXT(Gdiplus::Color, Gdiplus::Color((Gdiplus::ARGB) Gdiplus::Color::Black));
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetColorF();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API HBRUSH WINAPI
GetStdColorBrushI(UINT c)
{
    BEGIN_RECV(HBRUSH, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetBrushI(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Brush * WINAPI
GetStdColorBrushF(UINT c)
{
    BEGIN_RECV(Gdiplus::Brush *, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetBrushF(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API HPEN WINAPI
GetStdColorPenI(UINT c)
{
    BEGIN_RECV(HPEN, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetPenI(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Pen * WINAPI
GetStdColorPenF(UINT c)
{
    BEGIN_RECV(Gdiplus::Pen *, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetPenF(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API LPCWSTR WINAPI
GetStdColorName(UINT c)
{
    BEGIN_RECV_NOCONTEXT(LPCWSTR, NULL);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetName();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API UINT WINAPI
FindStdColor(LPCWSTR pszName)
{
    BEGIN_RECV_NOCONTEXT(UINT, SC_Black);
    VALIDATE_STRINGW_PTR(pszName, 50);

    retval = GdFindStdColor(pszName);

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API HPALETTE WINAPI
GetStdPalette()
{
    BEGIN_RECV_NOCONTEXT(HPALETTE, NULL);

    retval = GdGetStdPalette();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilSetBackground(HGADGET hgadChange, HBRUSH hbrBack)
{
    BOOL fSuccess = FALSE;

    if (SetGadgetFillI(hgadChange, hbrBack, BLEND_OPAQUE, 0, 0)) {
        UINT nStyle = hbrBack != NULL ? GS_OPAQUE : 0;
        fSuccess = SetGadgetStyle(hgadChange, nStyle, GS_OPAQUE);
    }

    return fSuccess;
}


//---------------------------------------------------------------------------
DUSER_API HFONT WINAPI
UtilBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice)
{
    return GdBuildFont(pszName, idxDeciSize, nFlags, hdcDevice);
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush)
{
    return GdDrawBlendRect(hdcDest, prcDest, hbrFill, bAlpha, wBrush, hBrush);
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness)
{
    return GdDrawOutlineRect(hdc, prcPxl, hbrDraw, nThickness);
}


//---------------------------------------------------------------------------
DUSER_API COLORREF WINAPI
UtilGetColor(HBITMAP hbmp, POINT * pptPxl)
{
    return GdGetColor(hbmp, pptPxl);
}


/***************************************************************************\
*
* GetGadgetTicket
*
* The GetGadgetTicket function returns the ticket that can be used to 
* identify the specified gadget.
*
* <param name="hgad">
*     A handle to the gadget to retrieve the ticket for.
* </param>
*
* <return type="DWORD">
*     If the function succeeds, the return value is a 32-bit ticket that
*     can be used to identify the specified gadget.
*     If the function fails, the return value is zero.
* </return>
*
* <remarks>
*     Tickets are created to give an external identity to a gadget.  A
*     is guaranteed to be 32 bits on all platforms.  If no ticket is
*     currently associated with this gadget, one is allocated.
* </remarks>
*
* <see type="function">LookupGadgetTicket</>
*
\***************************************************************************/

DUSER_API DWORD WINAPI
GetGadgetTicket(
    IN  HGADGET hgad)               // Handle of Gadget
{
    DuVisual * pgad;
    DWORD dwTicket;
    HRESULT hr;

    BEGIN_RECV(DWORD, 0, ContextLock::edNone);
    VALIDATE_VISUAL(gad);

    hr = pgad->GetTicket(&dwTicket);
    SET_RETURN(hr, dwTicket);

    END_RECV();
}


/***************************************************************************\
*
* LookupGadgetTicket
*
* The LookupGadgetTicket function returns the gadget that is associated with
* the specified ticket.
*
* <param name="dwTicket">
*     A ticket that has been associated with a gadget via the
*     GetGadgetTicket function.
* </param>
*
* <return type="HGADGET">
*     If the function succeeds, the return value is a handle to the gadget
*     associated with the ticket.
*     If the function fails, the return value is NULL.
* </return>
*
* <see type="function">GetGadgetTicket</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
LookupGadgetTicket(
    IN  DWORD dwTicket)             // Ticket
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);

    retval = DuVisual::LookupTicket(dwTicket);

    END_RECV();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\dwpex.h ===
#if !defined(WINAPI__DWPEx_h__INCLUDED)
#define WINAPI__DWPEx_h__INCLUDED
#pragma once

class HWndContainer;
class DuRootGadget;
class Gadget;

HWndContainer * GdGetContainer(HWND hwnd);
HRESULT     GdCreateHwndRootGadget(HWND hwndContainer, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
HRESULT     GdCreateNcRootGadget(HWND hwndContainer, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
HRESULT     GdCreateDxRootGadget(const RECT * prcContainerPxl, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
BOOL        GdForwardMessage(DuVisual * pgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr);


#endif // WINAPI__DWPEx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\public.h ===
#if !defined(WINAPI__Public_h__INCLUDED)
#define WINAPI__Public_h__INCLUDED

#endif // WINAPI__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WinAPI.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\stdafx.h ===
#if !defined(WINAPI__StdAfx_h__INCLUDED)
#define WINAPI__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // WINAPI__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\commonstdafx.h ===
#if !defined(INC__CommonStdAfx_h__INCLUDED)
#define INC__CommonStdAfx_h__INCLUDED

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500		// TODO: Remove this when updated headers are available
#endif

#define ENABLE_MSGTABLE_API 1   // Enable MsgTable based API's
#define ENABLE_MPH          1   // Enable Whistler MPH's
#define DUSER_INCLUDE_SLIST 1   // Include S-List functions inside DUser project

#define DBG_CHECK_CALLBACKS DBG // Extra validation for checking callbacks
#define DBG_STORE_NAMES     0   // Extra validation to store names

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <nt.h>                 // S-List definitions in ntrtl.h
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <winuserp.h>           // User privates

// COM Header Files
#include <ObjBase.h>            // CoCreateInstance, IUnknown
#include <DDraw.h>              // DirectDraw
#include <oleidl.h>             // OLE2 Interfaces

#include <AtlBase.h>            // CComPtr
#include <AtlConv.h>            // String conversion routines


// Related services
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)


// TODO: Move DxXForms out
#pragma warning(push, 3)

#include <dxtrans.h>
#include <dxterror.h>
#include <dxbounds.h>
#include <dxhelper.h>

#pragma warning(pop)


// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <tchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

#if DBG
#include <memory.h>             // Debug memory routines
#endif // DBG

// Gadgets Header Files
#include <AutoUtil.h>           // External debugging support

#endif // INC__CommonStdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserbasep.h ===
#if !defined(INC__DUserBaseP_h__INCLUDED)
#define INC__DUserBaseP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Base\Public.h"

#endif // INC__DUserBaseP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserctrlp.h ===
#if !defined(INC__DUserCtrlP_h__INCLUDED)
#define INC__DUserCtrlP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Ctrl\Public.h"

#endif // INC__DUserCtrlP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\winapi\winapi.h ===
/***************************************************************************\
*
* File: WinAPI.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(WINAPI__WinAPI_h__INCLUDED)
#define WINAPI__WinAPI_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserLavaP.h>
#include <DUserMotionP.h>
#include <DUserCtrlP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/WinAPI Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // WINAPI__WinAPI_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\dusercorep.h ===
#if !defined(INC__DUserCoreP_h__INCLUDED)
#define INC__DUserCoreP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Core\Public.h"

#endif // INC__DUserCoreP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\autoutil.h ===
/***************************************************************************\
*
* File: AutoUtil.h
*
* Description:
* AutoUtil.h defines routinues common to most projects, including
* - Macros
* - Disabling known compiler warnings
* - Debugging / Assert
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__AutoUtil_h__INCLUDED)
#define INC__AutoUtil_h__INCLUDED


//
// Ensure that DBG is defined for DEBUG builds.  This is used throughout
// DirectUser for DEBUG-only code, but is only defined (by default) in the
// NT-BUILD environment.  If we are compiling using the DSP's, we need to 
// ensure that it is defined.
//

#ifdef _DEBUG
#ifndef DBG
#define DBG 1
#endif // !DBG
#endif // !_DEBUG

#include <crtdbg.h>
#include <BaseTyps.h>

#ifdef DUSER_EXPORTS
#define AUTOUTIL_API
#else  // DUSER_EXPORTS
#define AUTOUTIL_API __declspec(dllimport)
#endif // DUSER_EXPORTS


/***************************************************************************\
*
* Macros
*
\***************************************************************************/

#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)
#define _countof(x) (sizeof(x) / sizeof(x[0]))


/***************************************************************************\
*
* Warnings
*
\***************************************************************************/

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for Trace/Assert
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting

#pragma warning(disable: 4204)  // initialize structures with non-constant members
#pragma warning(disable: 4221)  // initialize structures using address of automatic variable 

// warnings caused by normal optimizations
#if DBG
#else // DBG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in release version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif // DBG

#define UNREFERENCED_MSG_PARAMETERS(uMsg, wParam, lParam, bHandled)\
    UNREFERENCED_PARAMETER(uMsg); \
    UNREFERENCED_PARAMETER(wParam); \
    UNREFERENCED_PARAMETER(lParam); \
    UNREFERENCED_PARAMETER(bHandled)



/***************************************************************************\
*
* Debugging
*
\***************************************************************************/

#undef INTERFACE
#define INTERFACE IDebug
DECLARE_INTERFACE(IDebug)
{
    STDMETHOD_(BOOL, AssertFailedLine)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum) PURE;
    STDMETHOD_(BOOL, IsValidAddress)(THIS_ const void * lp, UINT nBytes, BOOL bReadWrite) PURE;
    STDMETHOD_(void, BuildStack)(THIS_ HGLOBAL * phStackData, UINT * pcCSEntries) PURE;
    STDMETHOD_(BOOL, Prompt)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle) PURE;
};

EXTERN_C AUTOUTIL_API IDebug * WINAPI GetDebug();
EXTERN_C AUTOUTIL_API void _cdecl AutoTrace(const char * pszFormat, ...);

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->lpVtbl->AssertFailedLine(p, a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->lpVtbl->IsValidAddress(p, a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->lpVtbl->BuildStack(p, a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->lpVtbl->Prompt(p, a, b, c, d)
#else
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->AssertFailedLine(a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->IsValidAddress(a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->BuildStack(a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->Prompt(a, b, c, d)
#endif

// Define AutoDebugBreak

#ifndef AutoDebugBreak
#define AutoDebugBreak() _CrtDbgBreak()
#endif

// Undefine previous definitions

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef Assert
#undef Assert
#endif

#ifdef AssertMsg
#undef AssertMsg
#endif

#ifdef Verify
#undef Verify
#endif

#ifdef VerifyMsg
#undef VerifyMsg
#endif

#ifdef AssertHR
#undef AssertHR
#endif

#ifdef AssertMsgHR
#undef AssertMsgHR
#endif

#ifdef VerifyHR
#undef VerifyHR
#endif

#ifdef VerifyMsgHR
#undef VerifyMsgHR
#endif

#ifdef Trace
#undef Trace
#endif


// Define Assert, Verify, etc.

#if DBG

// AutoDebug functions that are only available in DEBUG builds

#define Assert(f) \
    do \
    { \
    if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertMsg(f, comment) \
    do \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertHR(f) \
    do \
    { \
    if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertMsgHR(f, comment) \
    do \
    { \
        if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define Verify(f)               Assert((f))
#define VerifyMsg(f, comment)   AssertMsg((f), comment)
#define VerifyHR(f)             AssertHR((f))
#define VerifyMsgHR(f, comment) AssertMsgHR((f), comment)
#define DEBUG_ONLY(f)           (f)

#define ASSERT(f)               Assert((f))

#define Trace                   AutoTrace

#define AssertReadPtr(p) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), FALSE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertReadPtrSize(p, s) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, s, FALSE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertWritePtr(p) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), TRUE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertWritePtrSize(p, s) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, s, TRUE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertIndex(idx, nMax) \
    AssertMsg((idx < nMax) && (idx >= 0), "Check pointer is not NULL")

#define AssertHWND(hwnd) \
    AssertMsg(IsWindow(hwnd), "Check valid window")

#define AssertHandle(h) \
    AssertMsg(h != NULL, "Check valid handle")

#define AssertInstance(p) \
    do \
    { \
        AssertWritePtr(p); \
        p->DEBUG_AssertValid(); \
    } while (0)

#define AssertString(s) \
    do \
    { \
        Assert(s != NULL); \
    } while (0)

#else // DBG

#define Assert(f)                   ((void) 0)
#define AssertMsg(f, comment)       ((void) 0)
#define Verify(f)                   ((void)(f))
#define VerifyMsg(f, comment)       ((void)(f, comment))
#define AssertHR(f)                 ((void) 0)
#define AssertMsgHR(f, comment)     ((void) 0)
#define VerifyHR(f)                 ((void)(f))
#define VerifyMsgHR(f, comment)     ((void)(f, comment))
#define DEBUG_ONLY(f)               ((void) 0)

#define ASSERT(f)                   ((void) 0)

#define Trace               1 ? (void) 0 : AutoTrace

#define AssertReadPtr(p)            ((void) 0)
#define AssertReadPtrSize(p, s)     ((void) 0)
#define AssertWritePtr(p)           ((void) 0)
#define AssertWritePtrSize(p, s)    ((void) 0)
#define AssertIndex(idx, nMax)      ((void) 0)
#define AssertHWND(hwnd)            ((void) 0)
#define AssertHandle(h)             ((void) 0)
#define AssertInstance(p)           ((void) 0)
#define AssertString(s)             ((void) 0)

#endif // DBG


#if DBG_CHECK_CALLBACKS

#define AlwaysPromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Msg Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#endif // DBG_CHECK_CALLBACKS


#define CHECK_VALID_READ_PTR(p) \
    do \
    { \
        AssertReadPtr(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)

#define CHECK_VALID_WRITE_PTR(p) \
    do \
    { \
        AssertWritePtr(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)

#define SUPPRESS(ClassName) \
private: \
ClassName(const ClassName & copy); \
ClassName & operator=(const ClassName & rhs); \
public:

#endif // INC__AutoUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duser.cs ===
//-----------------------------------------------------------------------------
//
// DirectUser COM+ API
//
// Copyright (C) 2000 by Microsoft Corporation
// 
//-----------------------------------------------------------------------------

namespace DUser
{
using System;
using System.Runtime.InteropServices;

public class Common
{
    public enum StructFormat
    {
        Ansi = 1,
        Unicode = 2,
        Auto = 3,
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class INITGADGET
    {
        public  uint        cbSize;
        public  uint        nThreadMode;
        public  uint        nMsgMode;
        public  int         hctxShare;
    }

    [dllimport("DUser.dll", EntryPoint="InitGadgets", SetLastError=true)]
    public static extern bool InitGadgets(INITGADGET ig);

    [dllimport("DUserCP.dll", EntryPoint="InitBridge", SetLastError=true)]
    public static extern bool InitBridge();

    [dllimport("kernel32.dll", EntryPoint="GetLastError")]
    public static extern uint GetLastError();

    public static void Init()
    {
        //
        // Initialize DUser
        //

        INITGADGET ig = new INITGADGET();
        ig.cbSize       = 12;
        ig.nThreadMode  = 1;
        ig.nMsgMode     = 2;
        ig.hctxShare    = 0;
        if (!InitGadgets(ig)) {
            throw new DUserException(GetLastError(), "Unable to initialized DUser");
        }

        if (!InitBridge()) {
            throw new DUserException(GetLastError(), "Unable to initialized DUser Bridge");
        }


        //
        // Initialize all of the DUser classes
        //

        BaseGadget.InitBaseGadget();
        MsgGadget.InitMsgGadget();
        Extension.InitExtension();
        DropTarget.InitDropTarget();
        Visual.InitVisual();
        Root.InitRoot();
    }

    public const int gmEvent            = 32768;
    public const int gmDestroy          = gmEvent + 1;
    public const int gmPaint            = gmEvent + 2;
    public const int gmInput            = gmEvent + 3;
    public const int gmChangeState      = gmEvent + 4;
    public const int gmChangeRect       = gmEvent + 5;
    public const int gmChangeStyle      = gmEvent + 6;
    public const int gmQuery            = gmEvent + 7;
    public const int gmSyncAdaptor      = gmEvent + 8;

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class Msg
    {
        public  uint        cbSize;
        public  int         nMsg;
        public  int         hgadMsg;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class EventMsg : Msg
    {
		public  uint        nMsgFlags;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class MethodMsg : Msg
    {

    }

    [dllimport("DUser.dll", EntryPoint="FindGadgetClass", SetLastError=true)]
    public static extern int FindGadgetClass([marshal(UnmanagedType.LPWStr)] string sName, uint nVersion);

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class ContructInfo
    {
    }

    public const uint gprFailed     = 0xFFFFFFFF;
    public const uint gprNotHandled = 0;
    public const uint gprComplete   = 1;
    public const uint gprPartial    = 2;

    public delegate uint GadgetEventProc(Common.EventMsg pmsg);
    public delegate void GadgetMethodProc(Common.MethodMsg pmsg);

    [dllimport("DUser.dll", EntryPoint="BuildGadget", SetLastError=true)]
    public static extern int BuildGadget(int hClass, ContructInfo ci);

    [dllimport("DUserCP.dll", EntryPoint="BuildBridgeGadget", SetLastError=true)]
    public static extern int BuildBridgeGadget(int hClass, ContructInfo ci, 
            GadgetEventProc pfnEvent, GadgetMethodProc pfnMethod);

    [dllimport("DUser.dll", EntryPoint="CastGadgetDirect", SetLastError=true)]
    public static extern int CastGadgetDirect(int hgad);

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class POINT
    {
		public  int     x;
        public  int     y;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class SIZE
    {
		public  int     cx;
        public  int     cy;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class RECT
    {
		public  int     left;
        public  int     top;
        public  int     right;
        public  int     bottom;
    }

    [dllimport("DUser.dll", EntryPoint="GetStdColorBrushI")]
    public static extern int GetStdColorBrush(int idColor);
};


public class Gadget
{
    public int pgad;

    protected int h(Gadget g)
    {
        return g != null ? g.pgad : 0;
    }

    protected bool s(uint hr)
    {
        return (hr & 0x80000000) == 0;
    }

    protected bool f(uint hr)
    {
        return (hr & 0x80000000) != 0;
    }

    public virtual uint OnEvent(Common.EventMsg pmsg)
    {
        return 0;
    }

    protected uint RawEventProc(Common.EventMsg pmsg)
    {
        return OnEvent(pmsg);
    }

    public virtual void OnMethod(Common.MethodMsg pmsg)
    {

    }

    protected void RawMethodProc(Common.MethodMsg pmsg)
    {
        OnMethod(pmsg);
    }
};


class DUserException : System.SystemException
{
    public DUserException(uint error)
    {
        this.error = error;
    }

    public DUserException(uint error, string sReason) : base(sReason)
    {
        this.error = error;
    }

    public uint error;
};

//---------------------------------------------------------------------------
//
// Stub class BaseGadget
//

class BaseGadget : Gadget
{
    private static int idBaseGadget;

    public static void InitBaseGadget()
    {
        idBaseGadget = Common.FindGadgetClass("BaseGadgetBridge", 1);
        if (idBaseGadget == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered BaseGadget");
        }
    }

    [dllimport("DUserCP.dll")]
    public static extern uint SBaseGadgetOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SBaseGadgetOnEvent(pmsg);
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetOnEvent", SetLastError=true)]
    public static extern uint BaseGadgetOnEvent(Common.EventMsg pmsg);

    [dllimport("DUser.dll", EntryPoint="BaseGadgetGetFilter", SetLastError=true)]
    public static extern uint BaseGadgetGetFilter([@out] uint pnFilter);

    public const uint gmfiPaint             = 0x00000001;
    public const uint gmfiInputKeyboard     = 0x00000002;
    public const uint gmfiInputMouse        = 0x00000004;
    public const uint gmfiInputMouseMove    = 0x00000008;
    public const uint gmfiChangeState       = 0x00000010;
    public const uint gmfiChangeRect        = 0x00000020;
    public const uint gmfiChangeStyle       = 0x00000040;
    public const uint gmfiAll               = 0xFFFFFFFF;

    public void GetFilter(ref uint nFilter)
    {
        uint hr = BaseGadgetGetFilter(nFilter);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetSetFilter", SetLastError=true)]
    public static extern uint BaseGadgetSetFilter(uint nNewFilter, uint nMask);

    public void SetFilter(uint nNewFilter, uint nMask)
    {
        uint hr = BaseGadgetSetFilter(nNewFilter, nMask);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetAddHandler", SetLastError=true)]
    public static extern uint BaseGadgetAddHandler(int nMsg, int pgbHandler);

    public void AddHandler(int nMsg, BaseGadget vb)
    {
        uint hr = BaseGadgetAddHandler(nMsg, h(vb));
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetRemoveHandler", SetLastError=true)]
    public static extern uint BaseGadgetRemoveHandler(int nMsg, int pgbHandler);

    public void RemoveHandler(int nMsg, BaseGadget vb)
    {
        uint hr = BaseGadgetRemoveHandler(nMsg, h(vb));
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }
}


//---------------------------------------------------------------------------
//
// Stub class MsgGadget
//

class MsgGadget : BaseGadget
{
    private static int idMsgGadget;

    public static void InitMsgGadget()
    {
        idMsgGadget = Common.FindGadgetClass("MsgGadgetBridge", 1);
        if (idMsgGadget == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered MsgGadget");
        }
    }

    [dllimport("DUserCP.dll")]
    protected static extern uint SMsgGadgetOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SMsgGadgetOnEvent(pmsg);
    }
}


//---------------------------------------------------------------------------
//
// Stub class Extension
//

class Extension : MsgGadget
{
    private static int idExtension;

    public static void InitExtension()
    {
        idExtension = Common.FindGadgetClass("ExtensionBridge", 1);
        if (idExtension == 0) {
            throw new System.SystemException("Unable to find registered Extension");
        }
    }

    [dllimport("DUser.dll", EntryPoint="ExtensionOnRemoveExisting", SetLastError=true)]
    public static extern int ExtensionOnRemoveExisting();

    [dllimport("DUser.dll", EntryPoint="ExtensionOnDestroySubject", SetLastError=true)]
    public static extern int ExtensionOnDestroySubject();

    [dllimport("DUser.dll", EntryPoint="ExtensionOnAsyncDestroy", SetLastError=true)]
    public static extern int ExtensionOnAsyncDestroy();

}


//---------------------------------------------------------------------------
//
// Stub class DropTarget
//

class DropTarget : Extension
{
    private static int idDropTarget;

    public static void InitDropTarget()
    {
        idDropTarget = Common.FindGadgetClass("DropTargetBridge", 1);
        if (idDropTarget == 0) {
            throw new System.SystemException("Unable to find registered DropTarget");
        }
    }

}


//---------------------------------------------------------------------------
//
// Stub class Visual
//

class Visual : BaseGadget
{
    private static int idVisual;

    public static void InitVisual()
    {
        idVisual = Common.FindGadgetClass("VisualBridge", 1);
        if (idVisual == 0) {
            throw new System.SystemException("Unable to find registered Visual");
        }
    }

    public class VisualCI : Common.ContructInfo
    {
        public  int         pgadParent;
    };

    public Visual(Visual vParent)
    {
        CommonBuild(vParent.pgad, idVisual);
    }

    public Visual(Visual vParent, int idClass)
    {
        CommonBuild(vParent.pgad, idClass);
    }

    public Visual(HGadget gadParent)
    {
        CommonBuild(Common.CastGadgetDirect(gadParent.hgad), idVisual);
    }

    public Visual(HGadget gadParent, int idClass)
    {
        CommonBuild(Common.CastGadgetDirect(gadParent.hgad), idClass);
    }

    protected Visual(int pgv)
    {
        this.pgad = pgv;
    }

    private void CommonBuild(int pgadParent, int idClass)
    {
        VisualCI ci = new VisualCI();
        ci.pgadParent = pgadParent;
        int pgvThis = Common.BuildBridgeGadget(idClass, ci,
                new Common.GadgetEventProc(this.RawEventProc), new Common.GadgetMethodProc(this.RawMethodProc));
        //int pgvThis = Common.BuildGadget(idClass, ci);
        if (pgvThis != 0) {
            this.pgad = pgvThis;
        } else {
            throw new DUserException(Common.GetLastError(), "Unable to create new Visual");
        }
    }

    [dllimport("DUserCP.dll")]
    public static extern uint SVisualOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SVisualOnEvent(pmsg);
    }

    public enum EOrder
    {
        voAny           = 0,
        voBefore        = 1,
        voBehind        = 2,
        voTop           = 3,
        voBottom        = 4,
    };

    [dllimport("DUser.dll", EntryPoint="VisualSetOrder", SetLastError=true)]
    public static extern uint VisualSetOrder(int pgvThis, int pgvOther, uint nCmd);

    public void SetOrder(Visual vOther, EOrder o)
    {
        uint hr = VisualSetOrder(this.pgad, h(vOther), (uint) o);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetParent", SetLastError=true)]
    public static extern uint VisualSetParent(int pgvThis, int pgvParent, int pgvOther, uint nCmd);

    public void SetParent(Visual vParent, Visual vOther, uint nCmd)
    {
        uint hr = VisualSetParent(this.pgad, h(vParent), h(vOther), nCmd);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    public enum EGadget
    {
        vgParent        = 0,
        vgNext          = 1,
        vgPrev          = 2,
        vgTopChild      = 3,
        vgBottomChild   = 4,
        vgRoot          = 5,
    };

    [dllimport("DUser.dll", EntryPoint="VisualGetGadget", SetLastError=true)]
    public static extern uint VisualGetGadget(int pgvThis, uint nCmd, [@out] int ppgv);

    public Visual GetGadget(EGadget nCmd)
    {
        int pgv = 0;
        uint hr = VisualGetGadget(this.pgad, (uint) nCmd, pgv);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return new Visual(pgv);
    }

    public const uint gsRelative        = 0x00000001;
    public const uint gsVisible         = 0x00000002;
    public const uint gsEnabled         = 0x00000004;
    public const uint gsBuffered        = 0x00000008;
    public const uint gsAllowSubClass   = 0x00000010;
    public const uint gsKeyboardFocus   = 0x00000020;
    public const uint gsMouseFocus      = 0x00000040;
    public const uint gsClipInside      = 0x00000080;
    public const uint gsClipSiblings    = 0x00000100;
    public const uint gsHRedraw         = 0x00000200;
    public const uint gsVRedraw         = 0x00000400;
    public const uint gsOpaque          = 0x00000800;
    public const uint gsZeroOrigin      = 0x00001000;
    public const uint gsCustomHitTest   = 0x00002000;
    public const uint gsAdaptor         = 0x00004000;
    public const uint gsCached          = 0x00008000;

    [dllimport("DUser.dll", EntryPoint="VisualGetStyle", SetLastError=true)]
    public static extern uint VisualGetStyle(int pgvThis, [@out] uint pnStyle);

    public uint GetStyle()
    {
        uint nStyle = 0;
        uint hr = VisualGetStyle(this.pgad, nStyle);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return nStyle;
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetStyle", SetLastError=true)]
    public static extern uint VisualSetStyle(int pgvThis, uint nNewStyle, uint nMask);

    public void SetStyle(uint nNewStyle, uint nMask)
    {
        uint hr = VisualSetStyle(this.pgad, nNewStyle, nMask);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetKeyboardFocus", SetLastError=true)]
    public static extern uint VisualSetKeyboardFocus(int pgvThis);

    public void SetKeyboardFocus()
    {
        uint hr = VisualSetKeyboardFocus(this.pgad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualIsParentChainStyle", SetLastError=true)]
    public static extern uint VisualIsParentChainStyle(int pgvThis, uint nStyle, [@out] int pfResult, uint nFlags);

    [dllimport("DUser.dll", EntryPoint="VisualGetProperty", SetLastError=true)]
    public static extern uint VisualGetProperty(int pgvThis, int id, [@out] int ppvValue);

    public int GetProperty(int id)
    {
        int pvValue = 0;
        uint hr = VisualGetProperty(this.pgad, id, pvValue);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return pvValue;
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetProperty", SetLastError=true)]
    public static extern uint VisualSetProperty(int pgvThis, int id, int pvValue);

    public void SetProperty(int id, int pvValue)
    {
        uint hr = VisualSetProperty(this.pgad, id, pvValue);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualRemoveProperty", SetLastError=true)]
    public static extern uint VisualRemoveProperty(int pgvThis, int id);

    public void RemoveProperty(int id)
    {
        uint hr = VisualRemoveProperty(this.pgad, id);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualInvalidate", SetLastError=true)]
    public static extern uint VisualInvalidate(int pgvThis);

    public void Invalidate()
    {
        uint hr = VisualInvalidate(this.pgad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetFillI", SetLastError=true)]
    public static extern uint VisualSetFillI(int pgvThis, int hbrFill, byte bAlpha, int w, int h);

    public void SetFill(int hbrFill, byte bAlpha)
    {
        uint hr = VisualSetFillI(this.pgad, hbrFill, bAlpha, 0, 0);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetScale", SetLastError=true)]
    public static extern uint VisualGetScale(int pgvThis, [@out] float pflX, [@out] float pflY);

    public void GetScale(ref float flX, ref float flY)
    {
        uint hr = VisualGetScale(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetScale", SetLastError=true)]
    public static extern uint VisualSetScale(int pgvThis, float flX, float flY);

    public void VisualSetScale(float flX, float flY)
    {
        uint hr = VisualSetScale(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetRotation", SetLastError=true)]
    public static extern uint VisualGetRotation(int pgvThis, [@out] float pflRotationRad);

    public void GetRotation(ref float flRotationRad)
    {
        uint hr = VisualGetRotation(this.pgad, flRotationRad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetRotation", SetLastError=true)]
    public static extern uint VisualSetRotation(int pgvThis, float flRotationRad);

    public void SetRotation(float flRotationRad)
    {
        uint hr = VisualSetRotation(this.pgad, flRotationRad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetCenterPoint", SetLastError=true)]
    public static extern uint VisualGetCenterPoint(int pgvThis, [@out] float pflX, [@out] float pflY);

    public void GetCenterPoint(ref float flX, ref float flY)
    {
        uint hr = VisualGetCenterPoint(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetCenterPoint", SetLastError=true)]
    public static extern uint VisualSetCenterPoint(int pgvThis, float flX, float flY);

    public void SetCenterPoint(float flX, float flY)
    {
        uint hr = VisualSetCenterPoint(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=Common.StructFormat.Auto)]
    public class BUFFER_INFO
    {
        public  uint        cbSize;
        public  uint        nMask;
        public  uint        nStyle;
        public  byte        bAlpha;
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetBufferInfo", SetLastError=true)]
    public static extern uint VisualGetBufferInfo(int pgvThis, [@out] BUFFER_INFO pbi);

    [dllimport("DUser.dll", EntryPoint="VisualSetBufferInfo", SetLastError=true)]
    public static extern uint VisualSetBufferInfo(int pgvThis, BUFFER_INFO pbi);

    [dllimport("DUser.dll", EntryPoint="VisualGetSize", SetLastError=true)]
    public static extern uint VisualGetSize(int pgvThis, [@out] Common.SIZE psizeLogicalPxl);


    public const uint sgrMove       = 0x00000001;
    public const uint sgrSize       = 0x00000002;
    public const uint sgrClient     = 0x00000004;
    public const uint sgrParent     = 0x00000008;

    [dllimport("DUser.dll", EntryPoint="VisualGetRect", SetLastError=true)]
    public static extern uint VisualGetRect(int pgvThis, uint nFlags, [@out] Common.RECT prcPxl);

    public void GetRect(uint nFlags, ref Common.RECT rcPxl)
    {
        uint hr = VisualGetRect(this.pgad, nFlags, rcPxl);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetRect", SetLastError=true)]
    public static extern uint VisualSetRect(int pgvThis, uint nFlags, Common.RECT prcPxl);

    public void SetRect(uint nFlags, Common.RECT rc)
    {
        uint hr = VisualSetRect(this.pgad, nFlags, rc);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    public void SetRect(uint nFlags, int x, int y, int w, int h)
    {
        Common.RECT rc = new Common.RECT();
        rc.left = x;
        rc.top = y;
        rc.right = x + w;
        rc.bottom = y + h;
        uint hr = VisualSetRect(this.pgad, nFlags, rc);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualMapPoints", SetLastError=true)]
    public static extern uint VisualMapPoints(int pgvThis, Visual pgvTo, [@out] Common.POINT rgptClientPxl, int cPts);
}


//---------------------------------------------------------------------------
//
// Stub class Root
//

class Root : Visual
{
    private static int idRoot;

    public static void InitRoot()
    {
        idRoot = Common.FindGadgetClass("RootBridge", 1);
        if (idRoot == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered Root");
        }
    }

    public Root(Visual vParent) : base(vParent, idRoot)
    {

    }

    [dllimport("DUserCP.dll")]
    public static extern uint SRootOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SRootOnEvent(pmsg);
    }

    [dllimport("DUser.dll", EntryPoint="RootGetFocus", SetLastError=true)]
    public static extern uint RootGetFocus(int pgvThis, [@out] int ppgvFocus);

    public Visual GetFocus()
    {
        int pgvFocus = 0;
        uint hr = RootGetFocus(this.pgad, pgvFocus);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return new Visual(pgvFocus);
    }

    [dllimport("DUser.dll", EntryPoint="RootFindFromPoint", SetLastError=true)]
    public static extern uint RootFindFromPoint(int pgvThis, Common.POINT ptContainerPxl, uint nFlags, [@out] Common.POINT pptClientPxl, [@out] int ppgvFound);

    public void FindFromPoint(Common.POINT ptContainerPxl, uint nFlags, ref Common.POINT ptClientPxl, ref Visual vFound)
    {
        int pgvFound = 0;
        uint hr = RootFindFromPoint(this.pgad, ptContainerPxl, nFlags, ptClientPxl, pgvFound);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        vFound = new Visual(pgvFound);
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=Common.StructFormat.Auto)]
    public class ROOT_INFO
    {
        public  uint        cbSize;
        public  uint        nMask;
        public  uint        nOptions;
        public  uint        nSurface;
        public  uint        nDropTarget;
        public  int         pal;
    }

    [dllimport("DUser.dll", EntryPoint="RootGetRootInfo", SetLastError=true)]
    public static extern uint RootGetRootInfo(int pgvThis, ROOT_INFO pri);

    public void GetRootInfo(ref ROOT_INFO ri)
    {
        uint hr = RootGetRootInfo(this.pgad, ri);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="RootSetRootInfo", SetLastError=true)]
    public static extern uint RootSetRootInfo(int pgvThis, ROOT_INFO pri);

    public void SetRootInfo(ROOT_INFO ri)
    {
        uint hr = RootSetRootInfo(this.pgad, ri);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\dusermsgp.h ===
#if !defined(INC__DUserMsgP_h__INCLUDED)
#define INC__DUserMsgP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Msg\Public.h"

#endif // INC__DUserMsgP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserobjectapip.h ===
#if !defined(INC__DUserGIDLP_h__INCLUDED)
#define INC__DUserGIDLP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\ObjectAPI\Public.h"

#endif // INC__DUserGIDLP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\dusermotionp.h ===
#if !defined(INC__DUserMotionP_h__INCLUDED)
#define INC__DUserMotionP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Motion\Public.h"

#endif // INC__DUserMotionP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserservicesp.h ===
#if !defined(INC__DUserServicesP_h__INCLUDED)
#define INC__DUserServicesP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Services\Public.h"

#endif // INC__DUserServicesP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserlavap.h ===
#if !defined(INC__DUserLavaP_h__INCLUDED)
#define INC__DUserLavaP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Lava\Public.h"

#endif // INC__DUserLavaP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\dusergadget.cs ===
namespace DUser
{
using System;
using System.Runtime.InteropServices;

public class HGadget
{
    public int hgad;

    public HGadget(int hwnd)
    {
        int hgad = CreateGadget(hwnd, gcHwndHost, new GADGETPROC(this.RawGadgetProc), 0);
        if (hgad != 0)
        {
            this.hgad = hgad;
        }
        else
        {
            uint error = Common.GetLastError();
            throw new System.SystemException("Unable to create new HGadget");
        }
    }

    public HGadget(HGadget gadParent)
    {
        int hgad = CreateGadget(gadParent.hgad, gcSimple, 
                new GADGETPROC(this.RawGadgetProc), 0);
        if (hgad != 0)
        {
            this.hgad = hgad;
        }
        else
        {
            uint error = Common.GetLastError();
            throw new System.SystemException("Unable to create new HGadget");
        }
    }

    public static uint gprFailed        = 0xFFFFFFFF;
    public static uint gprNotHandled    = 0;
    public static uint gprComplete      = 1;
    public static uint gprPartial       = 2;

    public delegate uint GADGETPROC(int hgadCur, int pvCur, Common.EventMsg pmsg);

    public static uint gcHwndHost   = 0x00000001;
    public static uint gcSimple     = 0x00000005;

    [dllimport("duser.dll", EntryPoint="CreateGadget", SetLastError=true)]
    public static extern int CreateGadget(int hParent, uint nFlags, GADGETPROC pfn, int pvData);

    [dllimport("user32.dll")]
    public static extern int MessageBox(int h, string m, string c, int type);

    public virtual uint GadgetProc(Common.EventMsg pmsg)
    {
/*
        switch (pmsg.nMsg)
        {
        case Common.gmInput:
            MessageBox(0, "gmInput", "Gadget::GadgetProc()", 0);
            break;

        case Common.gmChangeState:
            MessageBox(0, "gmChangeState", "Gadget::GadgetProc()", 0);
            break;
        }
*/
        return gprNotHandled;
    }

    [dllimport("kernel32.dll", EntryPoint="OutputDebugString")]
    public static extern void OutputDebugString(string s);

    private uint RawGadgetProc(int hgadCur, int pvCur, Common.EventMsg pmsg)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        sb.Append("hgad: ");
        sb.Append(pmsg.hgadMsg);
        sb.Append("  MSG: ");
        sb.Append(pmsg.nMsg);
        sb.Append('\n');
        OutputDebugString(sb.ToString());

        return this.GadgetProc(pmsg);
    }

    public static uint gmfiPaint            = 0x00000001;
    public static uint gmfiInputKeyboard    = 0x00000002;
    public static uint gmfiInputMouse       = 0x00000004;
    public static uint gmfiInputMouseMove   = 0x00000008;
    public static uint gmfiChangeState      = 0x00000010;
    public static uint gmfiChangeRect       = 0x00000020;
    public static uint gmfiChangeStyle      = 0x00000040;
    public static uint gmfiAll              = 0xFFFFFFFF;

    [dllimport("duser.dll", EntryPoint="SetGadgetMessageFilter")]
    public static extern bool SetGadgetMessageFilter(int hgadChange, int pvCookie, uint nNewFilter, uint nMask);

    public void SetMessageFilter(uint nNewFilter, uint nMask)
    {
        SetGadgetMessageFilter(this.hgad, 0, nNewFilter, nMask);
    }

    public const uint gsRelative        = 0x00000001;
    public const uint gsVisible         = 0x00000002;
    public const uint gsEnabled         = 0x00000004;
    public const uint gsBuffered        = 0x00000008;
    public const uint gsAllowSubClass   = 0x00000010;
    public const uint gsKeyboardFocus   = 0x00000020;
    public const uint gsMouseFocus      = 0x00000040;
    public const uint gsClipInside      = 0x00000080;
    public const uint gsClipSiblings    = 0x00000100;
    public const uint gsHRedraw         = 0x00000200;
    public const uint gsVRedraw         = 0x00000400;
    public const uint gsOpaque          = 0x00000800;
    public const uint gsZeroOrigin      = 0x00001000;
    public const uint gsCustomHitTest   = 0x00002000;
    public const uint gsAdaptor         = 0x00004000;
    public const uint gsCached          = 0x00008000;

    [dllimport("duser.dll", EntryPoint="SetGadgetStyle")]
    public static extern bool SetGadgetStyle(int hgadChange, uint nNewStyle, uint nMask);

    public bool SetStyle(uint nNewStyle, uint nMask)
    {
        return SetGadgetStyle(this.hgad, nNewStyle, nMask);
    }

    [dllimport("duser.dll", EntryPoint="SetGadgetFillI")]
    public static extern bool SetGadgetFill(int hgadChange, int hbr, byte bAlpha, int w, int h);

    public bool SetFill(int hbr)
    {
        return SetGadgetFill(this.hgad, hbr, 255, 0, 0);
    }

    public const uint sgrMove       = 0x00000001;
    public const uint sgrSize       = 0x00000002;
    public const uint sgrClient     = 0x00000004;
    public const uint sgrParent     = 0x00000008;
    
    [dllimport("duser.dll", EntryPoint="SetGadgetRect", SetLastError=true)]
    public static extern bool SetGadgetRect(int hgadChange, int x, int y, int w, int h, uint nFlags);

    public bool SetRect(int x, int y, int w, int h, uint nFlags)
    {
        return SetGadgetRect(this.hgad, x, y, w, h, nFlags);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserwinapip.h ===
#if !defined(INC__DUserWinAPIP_h__INCLUDED)
#define INC__DUserWinAPIP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\WinAPI\Public.h"

#endif // INC__DUserWinAPIP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\renderutil.h ===
#if !defined(DUSER__RenderUtil_h__INCLUDED)
#define DUSER__RenderUtil_h__INCLUDED
#pragma once

#include "..\..\Util\RenderUtil\Public.h"

#endif // DUSER__RenderUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\slist.h ===
#if !defined(INC__SList_h__INCLUDED)
#define INC__SList_h__INCLUDED
#pragma once

#if !defined(FASTCALL)
    #if defined(_X86_)
        #define FASTCALL    _fastcall
    #else // defined(_X86_)
        #define FASTCALL
    #endif // defined(_X86_)
#endif // !defined(FASTCALL)

#define _NTSLIST_DIRECT_
#include <ntslist.h>

#endif // INC__SList_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\duserx.h ===
#if !defined(DUSER__DUserX_h__INCLUDED)
#define DUSER__DUserX_h__INCLUDED
#pragma once

#include "..\..\Util\DUserX\Public.h"

#endif // DUSER__DUserX_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\rockall.hpp ===
#if !defined(INC__RockAll_hpp__INCLUDED)
#define INC__RockAll_hpp__INCLUDED
#pragma once

#include "..\Engine\RockAll\Interface\RockAll.hpp"

#endif // INC__RockAll_hpp__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\dxtransguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\icecap.h ===
//-----------------------------------------------------------------------------
//
//  File: Icecap.h
//  Copyright (C) 1997-1998 Microsoft Corporation
//  All rights reserved.
//
//  This header file is part of IceCAP {{rmj}}.{{rmm}}.{{rup}}.  It is
//  MICROSOFT CONFIDENTIAL, and should not be distributed except under NDA.
//
//-----------------------------------------------------------------------------

// ICECAP.H
// interface to the Datalocality APIs

#ifndef __ICECAP_H__
#define __ICECAP_H__

#ifndef DONTUSEICECAPLIB
#pragma comment(lib, "IceCAP.lib")
#endif	// USEICECAPLIB

#ifdef __cplusplus
extern "C" {
#endif

// Defines for Levels and Id's
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_FIBERLEVEL 4
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

// Start/Stop Api's
int _declspec(dllimport) _stdcall StopProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall StartProfile(int nLevel, unsigned long dwId);

// Suspend/Resume Api's
int _declspec(dllimport) _stdcall SuspendProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall ResumeProfile(int nLevel, unsigned long dwId);

// Mark Api's
int _declspec(dllimport) _stdcall MarkProfile(long lMarker);
int _declspec(dllimport) _stdcall CommentMarkProfile(long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall CommentMarkAtProfile(__int64 dnTimestamp, long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall DlpMarkProfile(long lMarker0, long lMarker1);

// Named Profiling Elements Api's
int _declspec(dllimport) _stdcall NameProfile(const char *pszName, int nLevel, unsigned long dwId);

// Security Api's
// NOTE: please contact ICAPSUP before using this function
int _declspec(dllimport) _stdcall ClearProcessSecurityAcl(int fImpersonatingUser);

// xxxProfile return codes
#define PROFILE_OK 0						// xxxProfile call successful
#define PROFILE_ERROR_NOT_YET_IMPLEMENTED 1 // api or level,id combination not supported yet
#define PROFILE_ERROR_MODE_NEVER 2		// mode was never when called
#define PROFILE_ERROR_LEVEL_NOEXIST 3	// level doesn't exist
#define PROFILE_ERROR_ID_NOEXIST 4		// id doesn't exist
#define PROFILE_ERROR_NO_WMI_UPDATE 5	// failed to update the WMI (pagefault collection) state

// MarkProfile return codes
#define MARK_OK					0	// Mark was taken successfully
#define MARK_ERROR_MODE_NEVER	1	// Profiling was never when MarkProfile called
#define MARK_ERROR_MODE_OFF		2	// Profiling was off when MarkProfile called
#define MARK_ERROR_MARKER_RESERVED	3	// Mark value passed is a reserved value
#define MARK_TEXTTOOLONG		4	// Comment text was truncated
#define MARK_ERROR_OUTOFMEMORY	6	// no memory was available in which to record the event

// NameProfile return codes
#define NAME_OK						0	// Name was registered sucessfullly
#define NAME_ERROR_TEXTTRUNCATED	1	// The name text was too long and was therefore truncated
#define NAME_ERROR_REDEFINITION		2	// The given profile element has already been named
#define NAME_ERROR_LEVEL_NOEXIST	3	// level doesn't exist
#define NAME_ERROR_ID_NOEXIST 		4	// id doesn't exist
#define NAME_ERROR_INVALID_NAME		5	// name does not meet the specification's requirements
#define NAME_ERROR_OUTOFMEMORY		6	// no memory was available in which to record the event
#define NAME_ERROR_NO_SUPPORT		7	// the given operation is not supported

// Icecap 3.x Compatibility defines
#define StartCAP() StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define StopCAP() StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define SuspendCAP() SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define ResumeCAP() ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)

#define StartCAPAll() StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define StopCAPAll() StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define SuspendCAPAll() SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define ResumeCAPAll() ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)

#define MarkCAP(mark) MarkProfile(mark)

#define AllowCAP() 

// DataLocality 1.x Compatibility defines
#define StartDLP() StartCAP()
#define StopDLP() StopCAP()
#define MarkDLP(mark) MarkCAP(mark)

//
// USER DEFINED COUNTER HELPERS AND TYPES
//

// COUNTER_FUNCTION_PROLOGE and EPILOGE
//
// These functions are supplied to protect the state of registers
// that the IceCAP collection probes rely on.  We did everything we
// could to eliminate instructions during collection.  Your mission,
// if you choose to accept it, is the same.
//
#define COUNTER_FUNCTION_PROLOGE	_asm push ecx _asm push ebx _asm push ebp
#define COUNTER_FUNCTION_EPILOGE	_asm pop ebp _asm pop ebx _asm pop ecx _asm ret

#ifndef USER_COUNTER_INFO_DEFINED
#define USER_COUNTER_INFO_DEFINED

// CONSTS AND ENUMS
//

// UserCounterType
//
// These enumerations describe how the counter works.
//
// MonotonicallyIncreasing	--	This describes a counter that will increment
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks the
//								number of memory allocations.  Each allocation
//								increments the number by one.
//
// MonotonicallyDecreasint	--	This describes a counter that will decrement
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks a limited
//								resource.  Each use of the resource decrements
//								the number by one.
//
// RandomIncreasing --			This describes a counter that will increase for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be the total memory
//								allocated.  Each allocation would add it's size
//								to the counter, but each allocation being potentially
//								different, causes the counter to go up by a random
//								amount each time.
//
// RandomDecreasing --			This describes a coutner that will decrease for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be a limited resource
//								that can be used in bunches.  Each use fo the
//								the resource would cause the number to descrease
//								by a random amount.
//
// Random --					This number can either go up, or go down.  An
//								example would be the total amount of available
//								memory, which can either go up (as memory is
//								free'd), or go down (as memory is allocated).
//
enum UserCounterType
{
	MonotonicallyIncreasing,
	MonotonicallyDecreasing,
	RandomIncreasing,
	RandomDecreasing,
	Random
};

// TYPEDEFS
//

typedef signed __int64	COUNTER, *PCOUNTER;

///////////////////////////////////////////////////////////////
// USERCOUNTERINFO
//
// This structure descibes a user defined counter so that
// IceCAP can use it during profiling runs.
//
// History:  9-21-98 BarryNo Created
//
///////////////////////////////////////////////////////////////
typedef struct _USERCOUNTERINFO
{
	unsigned long dwSize;			// Size of this structure (for version control)
	char  szCounterFuncName[32];	// Name of the function
	enum UserCounterType	ct;		// Describes the type of number we will be collecting
	char szName[32];				// Name of user counter
	int bSynchronized;				// Is this counter synchronized

} USERCOUNTERINFO, *PUSERCOUNTERINFO;

#endif  // USER_COUNTER_INFO_DEFINED

#ifdef __cplusplus
}
#endif

#endif // __ICECAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\util\renderutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  AutoUtil.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\smgadget.h ===
#if !defined(CTRL__SmGadget_h__INCLUDED)
#define CTRL__SmGadget_h__INCLUDED
#pragma once

#include <SmObject.h>

namespace Gdiplus
{
    class Graphics;
};

/***************************************************************************\
*
* class SmGadget
*
* SmGadget provides a core implementation of a simple gadget and is used as
* as base for all of the simple gadget controls in DUser.
*
\***************************************************************************/

class SmGadget
{
// Construction
protected:
            SmGadget();
    virtual ~SmGadget();
            BOOL        PostBuild();

public:

// Operations
public:
    __declspec(property(get=RawGetHandle)) HGADGET h;
            HGADGET     RawGetHandle() const { return m_hgad; }

    virtual HRESULT     GadgetProc(EventMsg * pmsg);
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR) 
                                {  UNREFERENCED_PARAMETER(hdc);  UNREFERENCED_PARAMETER(pmsgR);  }
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void        OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR) 
                                {  UNREFERENCED_PARAMETER(pgpgr);  UNREFERENCED_PARAMETER(pmsgR);  }
#endif // GADGET_ENABLE_GDIPLUS

            void        Invalidate();

// Data
protected:
    HGADGET m_hgad;
};


#define GBEGIN_COM_MAP(x)                           \
    STDMETHODIMP                                    \
    QueryInterface(REFIID riid, void ** ppv)        \
    {                                               \
        if (ppv == NULL) {                          \
            return E_POINTER;                       \
        }                                           \
        if (IsEqualIID(riid, __uuidof(IUnknown)) || \

#define GCOM_INTERFACE_ENTRY(x)                     \
            IsEqualIID(riid, __uuidof(x))) {        \
                                                    \
            x * p = (x *) this;                     \
            p->AddRef();                            \
            *ppv = p;                               \
            return S_OK;                            \
        }                                           \
                                                    \
        if (                                        \

#define GEND_COM_MAP()                              \
            0) { }                                  \
        return E_NOINTERFACE;                       \
    }                                               \



/***************************************************************************\
*
* class SmGadgetFull
*
* SmGadgetFull is a "Mix-in" (see Design Patterns) class designed for 
* providing SmGadget's with a standard COM-class implementation.  Creation
* of SmGadget instances should derive from this class at the point of 
* creation.
*
\***************************************************************************/

template <class base, class iface>
class SmGadgetFull : public base
{
public:
    static SmGadgetFull<base, iface> *
    Build(HGADGET hgadParent, REFIID riid = __uuidof(IUnknown), void ** ppvUnk = NULL)
    {
        return CommonBuild(new SmGadgetFull<base, iface>, hgadParent, riid, ppvUnk);
    }

    static SmGadgetFull<base, iface> *
    CommonBuild(SmGadgetFull<base, iface> * pgadNew, HGADGET hgadParent, REFIID riid, void ** ppvUnk)
    {
        if (pgadNew == NULL) {
            return NULL;
        }
        pgadNew->m_cRef = 1;

        HGADGET hgad = CreateGadget(hgadParent, GC_SIMPLE, SmGadgetFull<base, iface>::RawGadgetProc, pgadNew);
        if (hgad == NULL) {
            pgadNew->Release();
            return NULL;
        }

        pgadNew->m_hgad = hgad;

        if (!pgadNew->PostBuild()) {
            // Delete from parent and destroy

            ::DeleteHandle(hgad);
            pgadNew->Release();
            return NULL;
        }

        if (ppvUnk != NULL) {
            pgadNew->QueryInterface(riid, ppvUnk);
        }

        return pgadNew;
    }

// Implementation
protected:
    inline 
    SmGadgetFull()
    {
    }

    static HRESULT CALLBACK 
    RawGadgetProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
    {
        UNREFERENCED_PARAMETER(hgadCur);
        AssertReadPtrSize(pmsg, pmsg->cbSize);

        SmGadgetFull<base, iface> * p = (SmGadgetFull<base, iface> *) pvCur;
        AssertMsg(hgadCur == p->m_hgad, "Ensure correct gadget");

        if (p->m_hgad == pmsg->hgadMsg) {
            switch (pmsg->nMsg)
            {
            case GM_DESTROY:
                {
                    GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
                    if (pmsgD->nCode == GDESTROY_FINAL) {
                        //
                        // When getting a GM_DESTROY message, Release() and return 
                        // immediately.  The base class should put its cleanup code in
                        // its destructor.
                        //

                        p->Release();
                        return DU_S_PARTIAL; 
                    }
                }
                break;

            case GM_QUERY:
                {
                    GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                    if (pmsgQ->nCode == GQUERY_INTERFACE) {
                        GMSG_QUERYINTERFACE * pmsgQI = (GMSG_QUERYINTERFACE *) pmsg;
                        pmsgQI->punk = (iface *) p;
                        return DU_S_COMPLETE;
                    }
                }
                break;
            }
        }

        return p->GadgetProc(pmsg);
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return ++m_cRef;
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        ULONG ul = --m_cRef;
        if (ul == 0) {
            delete this;
        }
        return ul;
    }


    STDMETHODIMP_(HGADGET)
    GetHandle() const
    {
        return m_hgad;
    }

// Data
protected:
    ULONG   m_cRef;
};

#include "SmGadget.inl"

#endif // CTRL__SmGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\smgadget.inl ===
#if !defined(INC__SmGadget_inl__INCLUDED)
#define INC__SmGadget_inl__INCLUDED

//------------------------------------------------------------------------------
inline
SmGadget::SmGadget()
{
    m_hgad = NULL;
}


//------------------------------------------------------------------------------
inline
SmGadget::~SmGadget()
{

}


//------------------------------------------------------------------------------
inline BOOL 
SmGadget::PostBuild()
{
    return TRUE;
}


//------------------------------------------------------------------------------
inline HRESULT
SmGadget::GadgetProc(EventMsg * pmsg)
{
    if (pmsg->hgadMsg == m_hgad) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;

#ifdef GADGET_ENABLE_GDIPLUS
                    case GSURFACE_GPGRAPHICS:
                        {
                            GMSG_PAINTRENDERF * pmsgR = (GMSG_PAINTRENDERF *) pmsgPaint;
                            OnDraw(pmsgR->pgpgr, pmsgR);
                        }
                        break;
#endif // GADGET_ENABLE_GDIPLUS
                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;
        }
    }

    return DU_S_NOTHANDLED;
}


//------------------------------------------------------------------------------
inline void
SmGadget::Invalidate()
{
    InvalidateGadget(m_hgad);
}


#endif // INC__SmGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\util\renderutil\stdafx.h ===
#if !defined(RENDERUTIL__StdAfx_h__INCLUDED)
#define RENDERUTIL__StdAfx_h__INCLUDED
#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // Only compile for NT5
#endif

// Windows
#include <windows.h>
#include <objbase.h>            // CoCreateInstance, IUnknown

#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)

// CRT
#include <math.h>

// DirectUser
#include <AutoUtil.h>

#endif // !defined(RENDERUTIL__StdAfx_h__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\util\renderutil\public.h ===
#if !defined(RENDERUTIL__Public_h__INCLUDED)
#define RENDERUTIL__Public_h__INCLUDED
#pragma once


namespace DUser
{

namespace RenderUtil
{

enum EBorderAlignment
{
    baOutside,
    baCenter,
    baInside
};


void ComputeBorder(Gdiplus::Pen * pgppen, const Gdiplus::RectF * prcGadgetPxl,
        EBorderAlignment ba, Gdiplus::RectF * prcBorderPxl);
void ComputeRoundRect(const Gdiplus::RectF * prc, const Gdiplus::SizeF sizeCorner,
        Gdiplus::GraphicsPath * pgppath);

void DrawRoundRect(Gdiplus::Graphics * pgpgr, Gdiplus::Pen * pgppenBorder,
        const Gdiplus::RectF & rc, const Gdiplus::SizeF sizeCorner, EBorderAlignment ba = baCenter);
void FillRoundRect(Gdiplus::Graphics * pgpgr, Gdiplus::Brush * pgpbrFill,
        const Gdiplus::RectF & rc, const Gdiplus::SizeF sizeCorner);


} // namespace DUser
} // namespace RenderUtil

#endif // RENDERUTIL__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\inc\smobject.h ===
#if !defined(CTRL__SmObject_h__INCLUDED)
#define CTRL__SmObject_h__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class SmObjectT
*
* SmObjectT defines a common implementation class for building COM objects.
* To create a new object type
* - Define an interface
* - Create a class that implements that interface except the COM functions
* - Derive a class from SmObjectT that provides a Build() function to create
*   new instances.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface>
class SmObjectT : public base
{
// Operations
public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)
    {
        if (ppv == NULL) {
            return E_POINTER;
        }

        int idx = 0;
        while (1) {
            if (IsEqualIID(riid, *base::s_rgpIID[idx])) {
                AddRef();
                iface * p = (iface *) this;
                *ppv = p;
                return S_OK;
            }

            idx++;

            if (base::s_rgpIID[idx] == NULL) {
                break;
            }
        }

        return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return ++m_cRef;
    }

    STDMETHOD_(ULONG, Release)()
    {
        ULONG ul = --m_cRef;
        if (ul == 0) {
            delete this;
        }
        return ul;
    }


// Data
protected:
    ULONG       m_cRef;
};

#endif // CTRL__SmObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sources.inc ===
# Common 'sources' file for gdiplus

# [agodfrey] Guard against multiple inclusion. When I fixed this file to
# add to C_DEFINES instead of stomping on it, I found that multiple inclusion
# caused C_DEFINES to be duplicated.

# For release build, turn this on. It disables things like Monitor tracking.
GP_RELEASE_BUILD=1

!ifndef GDIPROOT_SOURCES
GDIPROOT_SOURCES=moo

!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

GDIPIMG=$(GDIPROOT)\engine\imaging

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
MSC_WARNING_LEVEL=/W3

# GP_ICECAP:
#   0: Normal GDI+ build
#   1: IceCAP-enabled build. This means you can run gppick.bat on our binary.
#      You should be able to keep this set permanently.
#   2: IceCAP-enabled build, plus we link to ICECAP.DLL. Use this during
#      profiling work if you want to call the IceCAP API's.

!ifndef GP_ICECAP
GP_ICECAP=0
!endif

!if $(GP_ICECAP) > 0
NTBBT=1

!if $(GP_ICECAP) > 1
INCLUDES=$(INCLUDES);$(ICECAP)\Include
!endif

!endif

# PROFILE_MEMORY_USAGE
#   Enables logging of memory usage for our IceCAP user counter
#   See gdiplus\tools\memcounter\memcounter.cpp

!ifndef PROFILE_MEMORY_USAGE
PROFILE_MEMORY_USAGE=0
!endif

# The "monitors" are a performance measurement tool, designed to be
# lightweight enough to leave enabled all the time during development.
# They're currently disabled in preparation for shipping V1.

# GP_ENABLE_MONITORS=1

!ifdef GP_ENABLE_MONITORS
C_DEFINES=$(C_DEFINES) -DGP_ENABLE_MONITORS
!endif

!if $(PROFILE_MEMORY_USAGE)
# There's trouble with "cross-jumping" (a compiler optimization which replaces
# "call foo; ret" with "jmp foo" if possible.)
# First, if a non-instrumented app calls GdipFree, which cross-jumps to
# GpFree, which cross-jumps to LocalFree, IceCAP screws up and thinks that
# LocalFree calls loads of other GDI+ exports.
#
# Second, my -EXCLUDE:GpMalloc trick (which folds allocation information
# into the caller's exclusive count) doesn't work when GdipAlloc cross-jumps
# to GpMalloc.
#
# So, we want to disable cross-jumping. The only way I know is to disable
# most optimizations. So, don't do performance testing on this build! Ignore
# IceCAP's performance data if you use this switch!

MSC_OPTIMIZATION=/Odib1

!endif

!ifndef HW_ACCELERATION_SUPPORT
HW_ACCELERATION_SUPPORT=0
!endif

C_DEFINES=$(C_DEFINES) -DHW_ACCELERATION_SUPPORT=$(HW_ACCELERATION_SUPPORT) -DGP_ICECAP=$(GP_ICECAP) -DPROFILE_MEMORY_USAGE=$(PROFILE_MEMORY_USAGE)

!ifndef GDIPPRIVATEBUILD
GDIPPRIVATEBUILD=0
!endif

C_DEFINES=$(C_DEFINES) -DGDIPPRIVATEBUILD=$(GDIPPRIVATEBUILD) -DUSERNAME=\"$(USERNAME)\"

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\util\renderutil\roundrect.cpp ===
#include "stdafx.h"
#include "RenderUtil.h"

namespace DUser
{

namespace RenderUtil
{

//------------------------------------------------------------------------------
void
ComputeBorder(
    IN  Gdiplus::Pen * pgppen,
    IN  const Gdiplus::RectF * prcGadgetPxl,
    IN  EBorderAlignment ba,
    OUT Gdiplus::RectF * prcBorderPxl)
{
    float flPenThickness    = pgppen->GetWidth();

    BOOL fEven = fabs(fmod(flPenThickness, 2.0f)) < 0.0001f;

    float flOffset, flSize;

    switch (ba) {
    case baOutside:
        flOffset    = (flPenThickness + (fEven ? 0.0f : 1.0f)) / 2.0f + (fEven ? 0.5f : 0.0f);
        flSize      = flPenThickness;
        break;

    case baCenter:
        flOffset    = (fEven ? 0.5f : 0.0f);
        flSize      = (fEven ? 1.0f : 0.0f);
        break;

    case baInside:
        // Inside is opposite of outside
        flOffset    = -((flPenThickness + (fEven ? 0.0f : 1.0f)) / 2.0f + (fEven ? 0.5f : 0.0f));
        flSize      = -flPenThickness;
        break;

    default:
        AssertMsg(0, "Unknown alignment");
        return;
    }

    prcBorderPxl->X         = prcGadgetPxl->X - flOffset;
    prcBorderPxl->Y         = prcGadgetPxl->Y - flOffset;
    prcBorderPxl->Width     = prcGadgetPxl->Width + flSize;
    prcBorderPxl->Height    = prcGadgetPxl->Height + flSize;
}


//------------------------------------------------------------------------------
void
ComputeRoundRect(
    IN  const Gdiplus::RectF * prc,
    IN  const Gdiplus::SizeF sizeCorner,
    IN OUT Gdiplus::GraphicsPath * pgppath)
{
    float W     = (prc->Width > (sizeCorner.Width * 2)) ? sizeCorner.Width : prc->Width / 2.0f;
    float H     = (prc->Height > (sizeCorner.Height * 2)) ? sizeCorner.Width : prc->Height / 2.0f;
    float W2    = W * 2.0f;
    float H2    = H * 2.0f;

    float LX1   = prc->X;
    float LY1   = prc->Y;
    float LX2   = prc->X + prc->Width;
    float LY2   = prc->Y + prc->Height;

    float RX1   = prc->X + W;
    float RY1   = prc->Y + H;
    float RX2   = prc->X + prc->Width - W;
    float RY2   = prc->Y + prc->Height - H;

    pgppath->AddLine(RX1, LY1, RX2, LY1);
    pgppath->AddArc(RX2-W, RY1-H, W2, H2, 270.0f, 90.0f);

    pgppath->AddLine(LX2, RY1, LX2, RY2);
    pgppath->AddArc(RX2-W, RY2-H, W2, H2, 0.0f, 90.0f);

    pgppath->AddLine(RX2, LY2, RX1, LY2);
    pgppath->AddArc(RX1-W, RY2-H, W2, H2, 90.0f, 90.0f);

    pgppath->AddLine(LX1, RY2, LX1, RY1);
    pgppath->AddArc(RX1-W, RY1-H, W2, H2, 180.0f, 90.0f);

    pgppath->CloseFigure();

}


//------------------------------------------------------------------------------
void
DrawRoundRect(
    IN  Gdiplus::Graphics * pgpgr,
    IN  Gdiplus::Pen * pgppenBorder,
    IN  const Gdiplus::RectF & rc,
    IN  const Gdiplus::SizeF sizeCorner,
    IN  EBorderAlignment ba)
{
    Assert(pgppenBorder != NULL);

    Gdiplus::RectF rcUse;
    ComputeBorder(pgppenBorder, &rc, ba, &rcUse);

    Gdiplus::GraphicsPath gppath;
    ComputeRoundRect(&rcUse, sizeCorner, &gppath);
    pgpgr->DrawPath(pgppenBorder, &gppath);
}


//------------------------------------------------------------------------------
void
FillRoundRect(
    IN  Gdiplus::Graphics * pgpgr,
    IN  Gdiplus::Brush * pgpbrFill,
    IN  const Gdiplus::RectF & rc,
    IN  const Gdiplus::SizeF sizeCorner)
{
    Assert(pgpbrFill != NULL);

    Gdiplus::GraphicsPath gppath;
    ComputeRoundRect(&rc, sizeCorner, &gppath);
    pgpgr->FillPath(pgpbrFill, &gppath);
}


} // namespace DUser

} // namespace RenderUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\ddiplus.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   ddiplus.hpp
*
* Abstract:
*
*   Contains the interface definition for the high-level GDI+ device
*   driver interface.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*                                 
*   03/11/1999 agodfrey
*       Changed the DDI model. For this version, I'm not using COM, and
*       we'll use the result to decide whether we should be using COM.
\**************************************************************************/

#ifndef _DDIPLUS_HPP
#define _DDIPLUS_HPP

// !! shift this to dpflat.hpp ?? 
// !! do we want to bother with namespaces for driver, they may link to
//    other stuff in GDI, and hence name clashes.

class EpPaletteMap;

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>

class DpOutputSpan;
class DpClipRegion;
class DpContext;
struct DpBrush;
struct DpPen;
class DpBitmap;
class DpDriver;
class DpRegion;
class DpDevice;
class EpScan;
class DpPath;
class DpCustomLineCap;
struct DpImageAttributes;
class DpCachedBitmap;

#define WINGDIPAPI __stdcall

// The naming convention is Dpc<function><object> for Driver callbacks
DpPath* WINGDIPAPI 
DpcCreateWidenedPath(
        const DpPath* path, 
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect,
        BOOL regionToPath
        );
    
VOID WINGDIPAPI 
DpcDeletePath(
        DpPath* path
        );

DpPath* WINGDIPAPI
DpcClonePath(
        DpPath* path
        );

VOID WINGDIPAPI
DpcTransformPath(
        DpPath* path,
        GpMatrix* transform
        );

#include "dpregion.hpp"

// Hack: DpContext depends on GpRegion
#include "..\Entry\object.hpp"
#include "..\Entry\region.hpp"
// EndHack

#include "dpbitmap.hpp"
#include "dpbrush.hpp"
#include "dpcontext.hpp"
#include "dpdriver.hpp"
#include "dppath.hpp"
#include "dpcustomlinecap.hpp"
#include "dppen.hpp"
#include "dpscan.hpp"
#include "dppathiterator.hpp"
#include "dpimageattributes.hpp"
#include "dpcachedbitmap.hpp"

#endif // !_DDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\dppath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpPath.cpp
*
* Abstract:
*
*   DpPath engine function implementation
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a widen path from an existing path, pen and context.  The context
*   provides the world to transform matrix, and surface dpiX, dpiY
*
* Arguments:
*
*   path, context, pen
*
* Return Value:
*
*   DpPath* - widened path
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/
DpPath*
GpPath::DriverCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen,
    DpContext* context,
    BOOL removeSelfIntersect,
    BOOL regionToPath
    )
{
    const GpPath* gpPath = GpPath::GetPath(path);
    const GpPen* gpPen = GpPen::GetPen(pen);
    
    ASSERT(gpPath->IsValid());
    ASSERT(gpPen->IsValid());
    
    GpPath* widenPath;
    
    GpMatrix IdMatrix;
    
    // We don't flatten by default.  Depending on the device, it may be
    // more efficient to send bezier paths (postscript for instance).
    
    DWORD widenFlags = WidenDontFlatten;
    
    if(removeSelfIntersect)
    {
         widenFlags |= WidenRemoveSelfIntersects;
    }
    
    if(!regionToPath)
    {
         widenFlags |= WidenEmitDoubleInset;
    }
    
    widenPath = gpPath->GetWidenedPath(
        gpPen,
        context ? 
          &(context->WorldToDevice) : 
          &IdMatrix,
        context->GetDpiX(),
        context->GetDpiY(),
        widenFlags
    );
    
    if (widenPath)
       return (DpPath*) widenPath;
    else
       return NULL;
}

VOID
GpPath::DriverDeletePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    delete gpPath;
}

DpPath*
GpPath::DriverClonePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    return (DpPath*)(gpPath->Clone());
}

VOID
GpPath::DriverTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    gpPath->Transform(matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*  + Fixed a problem in ShrinkToSize that caused elements to potentially
*    be lost.
*  8/16/2000 bhouse
*  + Changed cpacity growth to be exponential
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   count             - initial count
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize,
    UINT count
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));
    ASSERT(count <= allocSize);

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = count;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpMemcpy(InitialAllocation,DataBuffer,Count * eltSize);
        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*   exactSize   - no exponential growth, just add required amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements, BOOL exactSize)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    UINT capacityIncrement = newCount - Capacity;
    
    if (!exactSize)
    {
        capacityIncrement = max(capacityIncrement,
                                min(max(Capacity, kMinCapacityGrowth),
                                    kMaxCapacityGrowth));
    };

    UINT newCapacity = Capacity + capacityIncrement;

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(newCapacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, newCapacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed"));

        // Aid in tracking down memory failure cases not handled properly
#if 0
        ASSERT(FALSE);
#endif
        return OutOfMemory;
    }

    Capacity = newCapacity;
    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Cannot be used if there is an initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::DetachData(UINT eltSize)
{
    if(DataBuffer == NULL) 
    {
        return NULL;
    }
    
    void *data = DataBuffer;
    
    if(DataBuffer == InitialAllocation)
    {
        data = GpMalloc(Count*eltSize);

        if (data)
        {
            GpMemcpy(data, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        DataBuffer = NULL;
        Capacity = 0;
    }
    
    Count = 0;
    
    return data;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements
    )
{
    ASSERT(newElements>0 && index<=Count);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    // NOTE: assume T is a shallow data type, i.e.
    //  it doesn't contain nested references.
    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        (Count - index) * eltSize
        );

    void *newSpace = static_cast<BYTE *>(DataBuffer) + index * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0 && index<=Count);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemmove(
            static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
            static_cast<BYTE *>(DataBuffer) + index * eltSize,
            (Count - index) * eltSize
            );
        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + index * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Deletes multiple items from the array starting at the index'th position.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to delete the elements.
*   numElements - number of elements to delete
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    

GpStatus DynArrayImpl::DeleteMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT numElements
    )
{
    ASSERT(numElements>0 && (index+numElements)<=Count);

    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        static_cast<BYTE *>(DataBuffer) + (index + numElements) * eltSize,
        (Count - (index + numElements)) * eltSize
        );
    Count -= numElements;

    ShrinkToSize(eltSize);

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
*   06/10/1999 t-wehunt
*       Added AddXXAt, DeletXXAt, and InsertAt methods.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
*   06/10/1999 t-wehunt
*   + AddXXAt, DeletXXAt, and InsertAt methods shift elements around in memory 
*     to keep the array contiguous.
*   + CAUTION: This could cause a big performance hit if the array is very large. 
*     Use care when calling these methods!!!
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

#include "dynArrayImpl.hpp"

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - the initial count
    //

    DynArray(
        T *initialAllocation, 
        UINT allocSize,
        UINT count = 0):
        DynArrayImpl(initialAllocation, allocSize, count)
    {
    }

    // Constructor (no initial allocation)
    //

    DynArray(void):
        DynArrayImpl(NULL, 0, 0)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    UINT GetCapacity() const
    {
        return Capacity;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }

    // Add a new element to the array at position index.
    // index'th element moves index + 1.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus InsertAt(INT index, const T& newItem)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, 1, &newItem);
    }
    
    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Insert multiple items starting at index'th element.
    // index'th element moves index + n, etc...
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus AddMultipleAt(INT index, const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, n, newItems);
    }
    
    // Another variation of AddMultipleAt above.
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) shift the old data over just as AddMultipleAt
    //  (2) reserve the space for additional elements
    //  (3) increase the Count by the number of additional elements
    //  (4) return a pointer to the first new elements
    // CAUTION! could cause a big performance hit if the array is large!

    T *AddMultipleAt(INT index, INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultipleAt(sizeof(T), index, n));
    }

    // Deletes n items from the array starting at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(INT index, INT n)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, n);
    }

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus DeleteAt(INT index)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, 1);
    }

    // Detach the data buffer from the dynamic array
    // Cannot be used if there is an initial allocation

    T *DetachData()
    {
        return static_cast<T *>(DynArrayImpl::DetachData(sizeof(T)));
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    VOID ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        DataBuffer = dynarr->DetachData();
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
        
        ASSERT(Count <= Capacity);
    }

    VOID SetCount(UINT count)
    {
        ASSERT(Count <= Capacity);
        
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements, BOOL exact = FALSE)
    {
        return Grow(sizeof(T), newElements, exact);
    }
};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array;
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements. Such a declaration can be used on the stack or in another
// object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //

    DynArrayIA(void):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, 0)
    {
    }

    DynArrayIA(T * initialAllocationBuffer, UINT initialAllocationSize, UINT count = 0) :
        DynArray<T>(initialAllocationBuffer, initialAllocationSize, count)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\driverprint.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains the GDI virtual driver that takes DDI calls and leverages
*   existing GDI calls wherever possible to improve performance.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\Render\scan.hpp"
#include "..\entry\device.hpp"
#include "..\entry\metafile.hpp"

#include "..\fondrv\tt\ttfd\fontddi.h"

#include "..\entry\graphics.hpp"
#include "..\entry\regiontopath.hpp"


// font stuff

#define _NO_DDRAWINT_NO_COM

// This is to use GpGlyphPath

extern "C" {
#include "..\fondrv\tt\ttfd\fdsem.h"
#include "..\fondrv\tt\ttfd\mapfile.h"
};

#include "..\entry\intMap.hpp"
#include "..\entry\fontface.hpp"
#include "..\entry\facerealization.hpp"
#include "..\entry\fontfile.hpp"
#include "..\entry\fontable.hpp"
#include "..\entry\FontLinking.hpp"
#include "..\entry\family.hpp"
#include "..\entry\font.hpp"

#include <ole2.h>
#include <objidl.h>
#include <winerror.h>
#include <tchar.h>

//#define NO_PS_CLIPPING 1
//#define DO_PS_COALESING 1

//
// Structures necessary for (postscript) escape clipping setup

/* Types for postscript written to metafiles */
#define CLIP_SAVE       0
#define CLIP_RESTORE    1
#define CLIP_INCLUSIVE  2
#define CLIP_EXCLUSIVE  3

#define RENDER_NODISPLAY 0
#define RENDER_OPEN      1
#define RENDER_CLOSED    2

#define FILL_ALTERNATE   1          // == ALTERNATE
#define FILL_WINDING     2          // == WINDING

#pragma pack(2)

/* Win16 structures for escapes. */
struct POINT16
    {
    SHORT x;
    SHORT y;
    };

struct LOGPEN16
    {
    WORD        lopnStyle;
    POINT16     lopnWidth;
    COLORREF    lopnColor;
    };

struct LOGBRUSH16
    {
    WORD        lbStyle;
    COLORREF    lbColor;
    SHORT       lbHatch;
    };

struct PathInfo16
    {
    WORD       RenderMode;
    BYTE       FillMode;
    BYTE       BkMode;
    LOGPEN16   Pen;
    LOGBRUSH16 Brush;
    DWORD      BkColor;
    };

#pragma pack()

/**************************************************************************\
*
* Function Description:
*
*   MemoryStream class.  Wrap an IStream* around an existing chunk of memory
*
*
* History:
*
*   6/14/1999 ericvan
*       Created it.
*
\**************************************************************************/

class MemoryStream : public IStream
{
public:

    LPBYTE memory;
    LPBYTE position;
    DWORD size;
    DWORD count;

    MemoryStream(LPBYTE memoryPtr, DWORD memorySize)
    {
       memory = memoryPtr;
       position = memory;
       size = memorySize;
       count = 1;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
                /* [in] */ REFIID riid,
                /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
    {
        return STG_E_UNIMPLEMENTEDFUNCTION;
    };

    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    {
       InterlockedIncrement((LPLONG)&count);
       return count;
    };

    virtual ULONG STDMETHODCALLTYPE Release( void)
    {
       InterlockedDecrement((LPLONG)&count);
       if (!count)
       {
           delete this;
           return 0;
       }
       else
           return count;
    };


    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead)
    {
       if (!pv)
          return STG_E_INVALIDPOINTER;

       DWORD readBytes = cb;

       if ((ULONG)cb > (ULONG)(memory+size-position))
           // !!! IA64 - it's theoretically possible that memory and position
           // more than maxint apart and then this arithmetic breaks down.
           // We need to verify that this is not possible.
           readBytes = (DWORD)(memory+size-position);

       if (!readBytes)
       {
          if (pcbRead)
             *pcbRead = 0;

          return S_OK;
       }

       memcpy((LPVOID) pv, (LPVOID) position, readBytes);
       position += readBytes;

       if (pcbRead)
           *pcbRead += readBytes;

       return S_OK;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
    {
       return STG_E_WRITEFAULT;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek(
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition)
    {
       switch (dwOrigin)
       {
       case STREAM_SEEK_SET:
          position = memory+dlibMove.QuadPart;
          break;

       case STREAM_SEEK_CUR:
          position = position+dlibMove.QuadPart;
          break;

       case STREAM_SEEK_END:
          if (dlibMove.QuadPart<0) dlibMove.QuadPart = -dlibMove.QuadPart;
          position = memory+size-dlibMove.QuadPart;
          break;

       default:
          return STG_E_INVALIDPARAMETER;
       }

       if (position>memory+size)
       {
           position = memory+size;
           return S_FALSE;
       }

       if (position<0)
       {
           position = 0;
           return S_FALSE;
       }

       return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE SetSize(
            /* [in] */ ULARGE_INTEGER libNewSize)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo(
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Commit(
            /* [in] */ DWORD grfCommitFlags)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Revert( void)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }


    virtual HRESULT STDMETHODCALLTYPE LockRegion(
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Stat(
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }
};

/**************************************************************************\
*
* Function Description:
*
*   GDI+ Printer callback
*
* Arguments:
*
*   [IN] GDIPPRINTDATA block
*
* Return Value:
*
*   status
*
* History:
*
*   6/14/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef DCR_REMOVE_OLD_186091
GpStatus
__stdcall
GdipDecodePrinterCallback(DWORD size,
                          LPVOID emfBlock,
                          SURFOBJ* surfObj,
                          HDC hdc,
                          RECTL* bandClip,
                          SIZEL* bandSize
                          )
{
#ifdef DCR_DISABLE_OLD_186091
    WARNING(("DCR: Using disabled functionality 186091"));
    return NotImplemented;
#else
   INT numBits = 4;

   if (!emfBlock || size == 0 || !surfObj || hdc == NULL || !bandClip ||!bandSize)
   {
      return InvalidParameter;
   }

   FPUStateSaver fpuState;

   // create Graphics and draw Metafile into it.

   GpMetafile* metafile;
   GpGraphics* graphics;

   // use banding information to create a temporary pseudo-HDC surface
   graphics = GpGraphics::GetFromHdcSurf(hdc, surfObj, bandClip);

   if (CheckValid(graphics))
   {
      {
         GpLock lockGraphics(graphics->GetObjectLock());

         // wrap memory block in stream object
         MemoryStream *emfStream = new MemoryStream((LPBYTE)emfBlock, size);

         // create metafile
         metafile = new GpMetafile((IStream *)emfStream);

         if (metafile)
         {
            // play metafile into the printer graphics DC
            // !! destination point - relative to band or surface origin (0,0) ??
            graphics->DrawImage(metafile,
                                GpPointF(0.0, 0.0));

            metafile->Dispose();
         }

         emfStream->Release();
      }

      delete graphics;
   }

   return Ok;
#endif
}
#endif

BOOL
DriverPrint::SetupBrush(
        DpBrush*            brush,
        DpContext*          context,
        DpBitmap*           surface
    )
{
    GpBrush *gpBrush = GpBrush::GetBrush(brush);

    if (IsSolid = gpBrush->IsSolid())
    {
        ASSERT(gpBrush->GetBrushType() == BrushTypeSolidColor);
        if (((GpSolidFill *)gpBrush)->GetColor().GetAlpha() == 0)
        {
            // yes, this did come up... hey it's a cheap test.
            return TRUE;
        }
        SolidColor = gpBrush->ToCOLORREF();
    }

    IsOpaque = (context->CompositingMode == CompositingModeSourceCopy) ||
                gpBrush->IsOpaque(TRUE);

    // Currently only DriverPS uses this
    //IsNearConstant = gpBrush->IsNearConstant(&MinAlpha, &MaxAlpha);
    IsNearConstant = FALSE;

    if (!IsOpaque &&
        (brush->Type == BrushTypeTextureFill))
    {
        GpTexture *textureBrush;
        DpTransparency transparency;

        textureBrush = static_cast<GpTexture*>(GpBrush::GetBrush(brush));

        GpBitmap* bitmap = textureBrush->GetBitmap();

        Is01Bitmap = ((bitmap != NULL) &&
                      (bitmap->GetTransparencyHint(&transparency) == Ok) &&
                      (transparency == TransparencySimple));
    }
    else
    {
        Is01Bitmap = FALSE;
    }

    return FALSE;
}

VOID
DriverPrint::RestoreBrush(
        DpBrush *             brush,
        DpContext *           context,
        DpBitmap *            surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   GDI driver class constructor.
*
* Arguments:
*
*   [IN] device - Associated device
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DriverPrint::DriverPrint(
    GpPrinterDevice *device
    )
{
    IsLockable = FALSE;
    SetValid(TRUE);
    Device = (GpDevice*)device;
    Uniqueness = -1;
    ImageCache = NULL;

    IsPathClip = FALSE;

    REAL dpix = TOREAL(GetDeviceCaps(device->DeviceHdc, LOGPIXELSX));
    REAL dpiy = TOREAL(GetDeviceCaps(device->DeviceHdc, LOGPIXELSY));
    if (dpix > PostscriptImagemaskDPICap)
        PostscriptScalerX = GpCeiling(dpix / PostscriptImagemaskDPICap);
    else
        PostscriptScalerX = 1;

    if (dpiy > PostscriptImagemaskDPICap)
        PostscriptScalerY = GpCeiling(dpiy / PostscriptImagemaskDPICap);
    else
        PostscriptScalerY = 1;

#ifdef DBG
    OutputText("GDI+ PrintDriver Created\n");
#endif
}

/**************************************************************************\
*
* Function Description:
*
*   GDI driver class destructor.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

DriverPrint::~DriverPrint(
    VOID
    )
{
   if (ImageCache)
       delete ImageCache;
}

/**************************************************************************\
*
* Function Description:
*
*   Computes band size and saves original clipping bounds
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   11/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::SetupPrintBanding(
           DpContext* context,
           GpRect* drawBoundsCap,
           GpRect* drawBoundsDev
           )
{
    // determine band size from MAX_BAND_ALLOC
    NumBands = GpCeiling((REAL)(drawBoundsCap->Width *
                                drawBoundsCap->Height *
                                sizeof(ARGB)) / (REAL)MAX_BAND_ALLOC);

    BandHeightCap = GpCeiling((REAL)drawBoundsCap->Height / (REAL)NumBands);
    BandHeightDev = BandHeightCap * ScaleY;

    // Band bounds for capped DPI rendering
    BandBoundsCap.X      = drawBoundsCap->X;
    BandBoundsCap.Y      = drawBoundsCap->Y;
    BandBoundsCap.Width  = drawBoundsCap->Width;
    BandBoundsCap.Height = BandHeightCap;

    // Band bounds for device DPI rendering
    BandBoundsDev.X      = drawBoundsDev->X;
    BandBoundsDev.Y      = drawBoundsDev->Y;
    BandBoundsDev.Width  = drawBoundsDev->Width;
    BandBoundsDev.Height = BandHeightDev;

    ASSERT(NumBands >= 1 && BandHeightCap >= 1 && BandHeightDev >= 1);

    context->VisibleClip.StartBanding();

    // Tweak the original capped and device bounds to force
    // DpOutputClipRegion in our rendering pipeline.  This is necessary since
    // we clip to each band.
    drawBoundsCap->Y--; drawBoundsCap->Height += 2;
    drawBoundsCap->X--; drawBoundsCap->Width += 2;

    drawBoundsDev->Y--; drawBoundsDev->Height += 2;
    drawBoundsDev->X--; drawBoundsDev->Width += 2;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Computes band size and sets up clipping bounds
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   11/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID DriverPrint::EndPrintBanding(
           DpContext* context
           )
{
    // restore state of clip region
    context->VisibleClip.EndBanding();
}

/**************************************************************************\
*
* Function Description:
*
*   Helper function for SetupEscapeClipping (see return value section)
*
* Arguments:
*
*   points - array of POINTs
*   types - array of BYTE types
*
* Return Value:
*
*   1 if the points indicate a clockwise described rectangle, 2 if
*   counterclockwise and 0 if not a rectangle
*
* History:
*
*   10/10/2000 ericvan
*       Created it.
*
\**************************************************************************/

INT isSimpleRect(DynPointArray &points, DynByteArray &types)
{
    if (points.GetCount() != 4)
    {
        return 0;
    }

    //specified in clockwise order
    if (points[0].Y == points[1].Y && points[2].Y == points[3].Y &&
        points[0].X == points[3].X && points[1].X == points[2].X &&
        types[0] == PathPointTypeStart &&
        types[1] == PathPointTypeLine &&
        types[2] == PathPointTypeLine &&
        types[3] == (PathPointTypeLine | PathPointTypeCloseSubpath))
        return 1;

    //specified in counterclockwise order
    if (points[0].X == points[1].X && points[2].X == points[3].X &&
        points[0].Y == points[3].Y && points[1].Y == points[2].Y &&
        types[0] == PathPointTypeStart &&
        types[1] == PathPointTypeLine &&
        types[2] == PathPointTypeLine &&
        types[3] == (PathPointTypeLine | PathPointTypeCloseSubpath))
        return 2;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Setup clipping to a given arbitrary path.  On Win98 the path must already
*   be flattened.  The points are specified in POINT units (not floating point),
*   consistent with output of RegionToPath.
*
*   The path can contain subpaths.  For Win9x, we coalesce the subpaths into
*   a single path to avoid poor performance on GDI.  The path is ANDed into
*   any existing postscript clip paths.
*
* Arguments:
*
*   HDC - hdc to send escapes to.
*   points - array of POINTs
*   types - array of BYTE types
*
*   CLIP_SAVE
*   BEGIN_PATH
*   Render path using GDI (use NULL pen + brush to ensure nothings drawn)
*   END_PATH
*   CLIP_RESTORE
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   3/3/2000 ericvan
*       Created it.
*
\**************************************************************************/
VOID
DriverPrint::SetupEscapeClipping(
        HDC                 hdc,
        DynPointArray&      points,
        DynByteArray&       types,
        GpFillMode          fillMode
        )
{
    PathInfo16 pi;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = (fillMode == FillModeAlternate) ?
                            FILL_ALTERNATE : FILL_WINDING;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    ASSERT((fillMode == FillModeAlternate) || (fillMode == FillModeWinding));

    GpPoint* pointPtr = points.GetDataBuffer();
    BYTE* typePtr = types.GetDataBuffer();
    GpPoint* freeThisPtr = NULL;

    INT count = points.GetCount();

    // We are partially visible, so we expect something!
    ASSERT(count > 0);
    if (count <= 1)
    {
        return;
    }

    // There is a bug on some printers (eg. hplj8550) where they incorrectly
    // cache simple clipping regions.  To work around this we take simple
    // clipping regions and make them complex.
    GpPoint simplerect[5];
    BYTE simpletypes[] = {
        PathPointTypeStart,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine | PathPointTypeCloseSubpath};

    if (isSimpleRect(points, types)>0)
    {
        //inserting a new point between the third and fourth points which is
        //between the two of them
        simplerect[0] = points[0];
        simplerect[1] = points[1];
        simplerect[2] = points[2];
        simplerect[4] = points[3];
        //we take the average of the two last points to make a point inbetween
        //them.  This works whether the rectangle is specified clockwise or
        //counterclockwise
        simplerect[3].X = (points[2].X + points[3].X) / 2;
        simplerect[3].Y = (points[2].Y + points[3].Y) / 2;
        count = 5;
        pointPtr = simplerect;
        typePtr = simpletypes;
    }

    INT subCount;
    BYTE curType;

    // save original clip
    WORD clipMode = CLIP_SAVE;
    Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);

    // send path to PS printer as an escape
    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);

    // !! Notice the lack of error checking when we call GDI...

    // Win95 and WinNT are subtly different in processing postscript escapes.
    if (Globals::IsNt)
    {
       BYTE lastType = 0;

       ::BeginPath(hdc);

       INT startIndex;
       while (count-- > 0)
       {
           switch ((curType = *typePtr++) & PathPointTypePathTypeMask)
           {
           case PathPointTypeStart:
               ::MoveToEx(hdc, pointPtr->X, pointPtr->Y, NULL);
               pointPtr++;
               ASSERT(count > 0);      // no illformed paths please...
               lastType = *typePtr & PathPointTypePathTypeMask;
               subCount = 0;
               break;

           case PathPointTypeLine:
               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeLine;
               }
               else
               {
                   subCount++;
               }
               break;

           case PathPointTypeBezier:
               if (lastType == PathPointTypeLine)
               {
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeBezier;
               }
               else
               {
                   subCount++;
               }
               break;
           }

           if (curType & PathPointTypeCloseSubpath)
           {
               ASSERT(subCount > 0);

               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
               }
               else
               {
                   ASSERT(lastType == PathPointTypeLine);
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
               }

               pointPtr += subCount;
               subCount = 0;

               ::CloseFigure(hdc);
           }
       }

       ::EndPath(hdc);
       ::StrokePath(hdc);
    }
    else
    {
        while (count-- > 0)
        {
            curType = *typePtr++;
            ASSERT((curType & PathPointTypePathTypeMask) != PathPointTypeBezier);

            if ((curType & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                subCount = 1;
            }
            else
            {
                subCount ++;
            }

            if (curType & PathPointTypeCloseSubpath)
            {
                ASSERT(subCount > 0);

                if (subCount == 4)
                {
                    // Win98 postscript drivers are known for recognizing
                    // rectangle polygons at driver level and converting them
                    // to rectfill or rectclip calls.  Unfortunately, there is
                    // a bug that they don't preserve the orientation and so
                    // when winding fill is used, the fill is bad.

                    // We fix this by hacking it into a path of five points.
                    GpPoint rectPts[5];

                    rectPts[0].X = pointPtr[0].X;
                    rectPts[0].Y = pointPtr[0].Y;
                    rectPts[1].X = (pointPtr[0].X + pointPtr[1].X)/2;
                    rectPts[1].Y = (pointPtr[0].Y + pointPtr[1].Y)/2;
                    rectPts[2].X = pointPtr[1].X;
                    rectPts[2].Y = pointPtr[1].Y;
                    rectPts[3].X = pointPtr[2].X;
                    rectPts[3].Y = pointPtr[2].Y;
                    rectPts[4].X = pointPtr[3].X;
                    rectPts[4].Y = pointPtr[3].Y;

                    ::Polygon(hdc, (POINT*)&rectPts[0], 5);
                }
                else
                {
                    ::Polygon(hdc, (POINT*)pointPtr, subCount);
                }

                pointPtr += subCount;
                subCount = 0;

                // send END_PATH, BEGIN_PATH escapes
                if (count > 0)
                {
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }
            }
        }
    }

    // we should end on a closed subpath
    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);

    // end the path and set up for clipping
    // NT driver ignoes the high WORD - always uses eoclip, but according to
    // Win31 documentation it should be set to the fillmode.
    DWORD inclusiveMode = CLIP_INCLUSIVE | pi.FillMode <<16;
    Escape(hdc, CLIP_TO_PATH, sizeof(inclusiveMode), (LPSTR)&inclusiveMode, NULL);

#if 0
    SelectObject(hdc, oldhPen);
    SelectObject(hdc, oldhBrush);
    SetPolyFillMode(hdc, oldFillMode);
#endif

#ifdef DBG
    OutputText("GDI+ End Setup Escape Clipping");
#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Setup simple path clipping.  On Win98 the path must already
*   be flattened.  The points are specified in POINT units (not floating point),
*   consistent with output of RegionToPath.
*
*   This differs from SetupEscapeClipping() in following way.  The API can
*   be called multiple times, each time specifying a new path, which is ORed
*   into the previous path.  On Win98, no coalescing of the subpath is done.
*
* Arguments:
*
*   HDC - hdc to send escapes to.
*   points - array of POINTs
*   types - array of BYTE types
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   5/22/2000 ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::SimpleEscapeClipping(
        HDC                 hdc,
        DynPointArray&      points,
        DynByteArray&       types,
        GpFillMode          fillMode,
        DWORD               flags
        )
{
#ifdef NO_PS_CLIPPING
    return;
#endif
    PathInfo16 pi;
    WORD clipMode;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = (fillMode == FillModeAlternate) ?
                            FILL_ALTERNATE : FILL_WINDING;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    ASSERT((fillMode == FillModeAlternate) || (fillMode == FillModeWinding));

#ifdef DBG
    OutputText("GDI+ Setup Simple Escape Clipping");
#endif

    GpPoint* pointPtr = points.GetDataBuffer();
    BYTE* typePtr = types.GetDataBuffer();
    GpPoint* freeThisPtr = NULL;

    INT count = points.GetCount();
    INT subCount = 0;

    BYTE curType;

    // we are partially visible, so we expect something!
    ASSERT(count > 0);
    if (count <= 1)
    {
        return;
    }

    // Win95 and WinNT are subtly different in processing postscript escapes.
    if (Globals::IsNt)
    {
       BYTE lastType = 0;

       INT startIndex;
       while (count-- > 0)
       {
           switch ((curType = *typePtr++) & PathPointTypePathTypeMask)
           {
           case PathPointTypeStart:
               ::MoveToEx(hdc, pointPtr->X, pointPtr->Y, NULL);
               pointPtr++;
               ASSERT(count > 0);      // no illformed paths please...
               lastType = *typePtr & PathPointTypePathTypeMask;
               subCount = 0;
               break;

           case PathPointTypeLine:
               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeLine;
               }
               else
               {
                   subCount++;
               }
               break;

           case PathPointTypeBezier:
               if (lastType == PathPointTypeLine)
               {
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeBezier;
               }
               else
               {
                   subCount++;
               }
               break;
           }

           if (curType & PathPointTypeCloseSubpath)
           {
               ASSERT(subCount > 0);

               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
               }
               else
               {
                   ASSERT(lastType == PathPointTypeLine);
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
               }

               pointPtr += subCount;
               subCount = 0;

               ::CloseFigure(hdc);
           }
       }

    }
    else
    {
        // Win98 equivalent code

        // !! Win98 doesn't support bezier points in postscript clipping

        while (count-- > 0)
        {
            curType = *typePtr++;
            ASSERT((curType & PathPointTypePathTypeMask) != PathPointTypeBezier);

            if ((curType & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                subCount = 1;
            }
            else
            {
                subCount ++;
            }

            if (curType & PathPointTypeCloseSubpath)
            {
                ASSERT(subCount > 0);

                ::Polygon(hdc, (POINT*)pointPtr, subCount);

                pointPtr += subCount;
                subCount = 0;

                // send END_PATH, BEGIN_PATH escapes
                if (count > 0)
                {
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }
            }
        }
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Setups up postscript clipping path given GlyphPos (outline of glyph
*   characters).
*
* Arguments:
*
*
* Return Value:
*
*   status
*
* History:
*
*   3/20/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::SetupGlyphPathClipping(
    HDC                hdc,
    DpContext *        context,
    const GpGlyphPos * glyphPathPos,
    INT                glyphCount
)
{
    ASSERT(hdc != NULL);
    ASSERT(glyphCount > 0);
    ASSERT(glyphPathPos != NULL);

    DynByteArray flattenTypes;
    DynPointFArray flattenPoints;

    GpPointF *pointsPtr;
    BYTE *typesPtr;
    INT count;

    REAL m[6];

    PathInfo16 pi;
    DWORD clipMode;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = FILL_ALTERNATE;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    GpGlyphPos *curGlyph = const_cast<GpGlyphPos*>(&glyphPathPos[0]);

    if (glyphCount > 0)
    {
        // save original clip
        // NT driver ignoes the high WORD - always uses eoclip, but according to
        // Win31 documentation it should be set to the fillmode.
        clipMode = CLIP_SAVE;
        Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);


        if (Globals::IsNt)
        {
            // send path to PS printer as an escape
            Escape(hdc, BEGIN_PATH, 0, NULL, NULL);

            ::BeginPath(hdc);
        }
    }

    for (INT pos=0; pos<glyphCount; pos++, curGlyph++)
    {

        // get path for glyph character
        GpGlyphPath *glyphPath = (GpGlyphPath*)curGlyph->GetPath();

        if ((glyphPath != NULL) && glyphPath->IsValid() && !glyphPath->IsEmpty())
        {
            // !! Perf improvement.  Avoid copying this point array somehow.

            GpPath path(glyphPath->points,
                        glyphPath->types,
                        glyphPath->pointCount,
                        FillModeAlternate);         // !! Is this right?

            ASSERT(path.IsValid());
            if (path.IsValid())
            {
                // create transform to translate path to correct position
                GpMatrix matrix;

                BOOL doFlatten = !Globals::IsNt && path.HasCurve();

                if (doFlatten)
                {
                    // This makes a Flattened copy of the points... (stored
                    // independent of the original points)

                    path.Flatten(&flattenTypes, &flattenPoints, &matrix);

                    pointsPtr = flattenPoints.GetDataBuffer();
                    typesPtr = flattenTypes.GetDataBuffer();
                    count = flattenPoints.GetCount();
                }
                else
                {
                    pointsPtr = const_cast<GpPointF*>(path.GetPathPoints());
                    typesPtr = const_cast<BYTE*>(path.GetPathTypes());
                    count = path.GetPointCount();
                }

                DynPointArray points;
                DynByteArray types(typesPtr, count, count);

                POINT * transformedPointsPtr = (POINT *) points.AddMultiple(count);

                // !!! bhouse This call can fail yet it returns void
                if(!transformedPointsPtr)
                    return;

                // translate to proper position in device space.
                matrix.Translate(TOREAL(curGlyph->GetLeft()),
                                 TOREAL(curGlyph->GetTop()),
                                 MatrixOrderAppend);

                // path is already in device space, but relative to bounding
                // box of glyph character.
                matrix.Transform(pointsPtr,
                                 transformedPointsPtr,
                                 count);

                // send path to PS printer as an escape
                if (!Globals::IsNt)
                {
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }


                SimpleEscapeClipping(hdc,
                                     points,
                                     types,
                                     FillModeAlternate,
                                     0);
                if (!Globals::IsNt)
                {
                    // we should end on a closed subpath
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                }

                GlyphClipping = TRUE;
            }
        }

    }

    if (glyphCount > 0)
    {
        if (Globals::IsNt)
        {
            ::EndPath(hdc);
            ::StrokePath(hdc);

            // we should end on a closed subpath
            Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
        }


        // end the path and set up for clipping
        // NT driver ignoes the high WORD - always uses eoclip, but according to
        // Win31 documentation it should be set to the fillmode.
        DWORD inclusiveMode = CLIP_INCLUSIVE | pi.FillMode<<16;
        Escape(hdc, CLIP_TO_PATH, sizeof(inclusiveMode), (LPSTR)&inclusiveMode, NULL);

    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore postscript escape clipping.  For use with simple and complex
*   clipping.
*
* Arguments:
*
* HDC             - printer HDC to send escapes to
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   3/3/2000 ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestoreEscapeClipping(
        HDC                 hdc
        )
{
     WORD clipMode = CLIP_RESTORE;
     Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Setup clipping.  If the printer (PS and apparently some PCL printers)
*   support escape clippings, then use them.  Otherwise, revert to GDI
*   to do our clipping.  NOTE:  This is only necessary for cases where
*   GDI is doing the rendering.
*
* Arguments:
*
* HDC             - printer HDC to send escapes to
* clipRegion      - clip region to send
* drawBounds      - bounding box for drawing region
* IsClip [OUT]    - whether was necessary to send clip region
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan - Created it.
*   1/25/2k ericvan - Switch on escape clipping or GDI clipping
*
\**************************************************************************/

VOID
DriverPrint::SetupClipping(
    HDC                 hdc,
    DpContext *         context,
    const GpRect *      drawBounds,
    BOOL &              isClip,
    BOOL &              usePathClipping, // ignored here
    BOOL                forceClipping
    )
{
    // the visible clip is at device resolution so there is no benefit to using paths here.
    ASSERT(usePathClipping == FALSE);

    DpClipRegion *      clipRegion = &(context->VisibleClip);

    isClip = FALSE;

    if (UseClipEscapes)
    {
        if (forceClipping ||
            (clipRegion->GetRectVisibility(drawBounds->X,
                                         drawBounds->Y,
                                         drawBounds->GetRight(),
                                         drawBounds->GetBottom())
          != DpRegion::TotallyVisible))
        {
            // If it is a simple region, we draw it directly.

            if (Uniqueness != clipRegion->GetUniqueness())
            {
                RegionToPath convertRegion;

                if (convertRegion.ConvertRegionToPath(clipRegion,
                                              ClipPoints,
                                              ClipTypes) == FALSE)
                {
                    ClipPoints.Reset();
                    ClipTypes.Reset();
                    UseClipEscapes = FALSE;
                    goto UseGDIClipping;
                }

                Uniqueness = clipRegion->GetUniqueness();
            }

            SetupEscapeClipping(hdc, ClipPoints, ClipTypes);

            isClip = TRUE;
        }
    }
    else
    {
UseGDIClipping:
        DpDriver::SetupClipping(hdc, context, drawBounds, isClip,
                                usePathClipping, forceClipping);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore clipping
*
* Arguments:
*
*   dstHdc - destination printer device
*   surface - surface
*   drawBounds - rectangular section of surface to paint
*
* Return Value:
*
*   status
*
* History:
*
*   11/30/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestoreClipping(
    HDC  hdc,
    BOOL isClip,
    BOOL usePathClipping
    )
{
   if (isClip)
   {
       if (UseClipEscapes)
       {
           RestoreEscapeClipping(hdc);
       }
       else
       {
           DpDriver::RestoreClipping(hdc, isClip, usePathClipping);
       }
   }
}

/**************************************************************************\
*
* Function Description:
*
*   Setup Path Clipping.  This routine ANDs the given path into the
*   the current clip region.
*
* Arguments:
*
* HDC             - printer HDC
* clipPath        - path to clip
* IsClip [OUT]    - whether was necessary to send clip region
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   8/17/2k ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::SetupPathClipping(
        HDC                 hdc,
        DpContext *         context,
        const DpPath*       clipPath
        )
{
    ASSERT(IsPathClip == FALSE);

    if (UseClipEscapes)
    {
        BOOL doFlatten = !Globals::IsNt && clipPath->HasCurve();

        GpPointF *pointsPtr;
        BYTE *typesPtr;
        INT count;

        DynByteArray flattenTypes;
        DynPointFArray flattenPoints;

        if (doFlatten)
        {
            // This makes a Flattened copy of the points... (stored independent
            // of original points.

            clipPath->Flatten(
                            &flattenTypes,
                            &flattenPoints,
                            &(context->WorldToDevice));

            pointsPtr = flattenPoints.GetDataBuffer();
            typesPtr = flattenTypes.GetDataBuffer();
            count = flattenPoints.GetCount();
        }
        else
        {
            pointsPtr = const_cast<GpPointF*>(clipPath->GetPathPoints());
            typesPtr = const_cast<BYTE*>(clipPath->GetPathTypes());
            count = clipPath->GetPointCount();
        }

        DynPointArray points;
        DynByteArray types(typesPtr, count, count);

        POINT * transformedPointsPtr = (POINT *) points.AddMultiple(count);

        // !!! bhouse This call can fail yet it returns void
        if(!transformedPointsPtr)
            return;

        if (doFlatten || context->WorldToDevice.IsIdentity())
        {
            GpMatrix idMatrix;

            idMatrix.Transform(pointsPtr, transformedPointsPtr, count);
        }
        else
        {
            // We transform the points here to avoid an extra potentially
            // large memory alloc (not flattened, we can't transform in place)

            context->WorldToDevice.Transform(pointsPtr, transformedPointsPtr, count);
        }

        SetupEscapeClipping(hdc, points, types, clipPath->GetFillMode());

        IsPathClip = TRUE;
    }
    else
    {
        ::SaveDC(hdc);

        // Windows98 ExtCreateRegion has a 64kb limit, so we can't use
        // Region->GetHRgn() to create the HRGN.  Incidentlly there is
        // also an NT4 SPx bug where ExtCreateRegion fails sometimes.
        // Instead we use SelectClipPath()

        ConvertPathToGdi gdiPath(clipPath,
                                 &(context->WorldToDevice),
                                 0);

        if (gdiPath.IsValid())
        {
            gdiPath.AndClip(hdc);
        }

        IsPathClip = TRUE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore Path Clipping.  This routine restore clip region to original
*   representation.
*
* Arguments:
*
* HDC             - printer HDC
* clipPath        - path to clip
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   8/17/2k ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestorePathClipping(HDC hdc)
{
    DriverPrint::RestoreClipping(hdc, IsPathClip, FALSE);

    IsPathClip = FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a rectangular region with a pen.  Sets the clipping appropriately
*   as path INTERSECT visible clip.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::PrivateFillRect(
                DpContext *context,
                DpBitmap *surface,
                const GpRect *drawBounds,
                const DpPath *outlinePath,
                const DpBrush *brush
                )
{
    GpStatus status = Ok;
    ASSERT(outlinePath != NULL);

    // Optimization for LinearGradientBrush fills.  We rasterize to a small
    // DIB and send that to the printer.  For horizontal and vertical gradients
    // in particular, this results in significant savings.

    GpMatrix savedmatrix;

    GpBrush *gpBrush = GpBrush::GetBrush(brush);
    GpSpecialGradientType gradientType;

    if (IsOpaque &&
        ((gradientType = gpBrush->GetSpecialGradientType(&context->WorldToDevice))
         != GradientTypeNotSpecial))
    {
        GpRect       bitmapBounds = *drawBounds;
        GpBitmap *   gpBitmap = NULL;

        switch (gradientType)
        {
        case GradientTypeHorizontal:
            bitmapBounds.Width = 1;
            break;

        case GradientTypeVertical:
            bitmapBounds.Height = 1;
            break;

        case GradientTypePathTwoStep:
        case GradientTypeDiagonal:
            bitmapBounds.Width = min(drawBounds->Width, 256);
            bitmapBounds.Height = min(drawBounds->Height, 256);
            break;

        case GradientTypePathComplex:
            // send the whole drawBounds for now.
            break;

        default:
            ASSERT(0);
            break;
        }

        HDC hdc = context->GetHdc(surface);

        if (hdc != NULL)
        {
            // Transform the destination drawBounds rectangle to
            // bitmapBounds size.
            bitmapBounds.X = 0;
            bitmapBounds.Y = 0;

            RectF destRect(0.0f,
                           0.0f,
                           TOREAL(bitmapBounds.Width),
                           TOREAL(bitmapBounds.Height));
            RectF srcRect(TOREAL(drawBounds->X),
                          TOREAL(drawBounds->Y),
                          TOREAL(drawBounds->Width),
                          TOREAL(drawBounds->Height));

            GpMatrix transform;
            transform.InferAffineMatrix(destRect, srcRect);

            GpMatrix::MultiplyMatrix(transform,
                                     context->WorldToDevice,
                                     transform);

            status = GpBitmap::CreateBitmapAndFillWithBrush(
                             context->FilterType,
                             &transform,
                             &bitmapBounds,
                             gpBrush,
                             &gpBitmap);

            if ((status == Ok) && (gpBitmap != NULL))
            {
                GpRect & srcRect = bitmapBounds;
                PixelFormatID lockFormat = PixelFormat32bppARGB;
                BitmapData bmpDataSrc;

                // Lock the bits.
                if (gpBitmap->LockBits(NULL,
                                       IMGLOCK_READ,
                                       lockFormat,
                                       &bmpDataSrc) == Ok)
                {
                    DpBitmap driverSurface;

                    // Fake up a DpBitmap for the driver call.
                    // We do this because the GpBitmap doesn't maintain the
                    // DpBitmap as a driver surface - instead it uses a
                    // GpMemoryBitmap.
                    gpBitmap->InitializeSurfaceForGdipBitmap(
                        &driverSurface,
                        bmpDataSrc.Width,
                        bmpDataSrc.Height
                    );

                    driverSurface.Bits         = (BYTE*)bmpDataSrc.Scan0;

                    driverSurface.Width        = bmpDataSrc.Width;
                    driverSurface.Height       = bmpDataSrc.Height;
                    driverSurface.Delta        = bmpDataSrc.Stride;

                    // Pixel format to match the lockbits above.

                    driverSurface.PixelFormat  = lockFormat;

                    driverSurface.NumBytes     = bmpDataSrc.Width  *
                                                 bmpDataSrc.Height * 3;

                    // Must be transparent to get here.
                    driverSurface.SurfaceTransparency = TransparencyOpaque;

                    ConvertBitmapToGdi  gdiBitmap(hdc,
                                                  &driverSurface,
                                                  &srcRect,
                                                  IsPrinting);

                    status = GenericError;

                    if (gdiBitmap.IsValid())
                    {
                        BOOL        isClip;
                        BOOL        usePathClipping = FALSE;

                        // Clip to visible region
                        SetupClipping(hdc, context, drawBounds, isClip, usePathClipping, FALSE);

                        // Clip to outline path (fill shape)
                        SetupPathClipping(hdc, context, outlinePath);

                        // Destination points in POINT co-ordinates
                        POINT destPoints[3];
                        destPoints[0].x = drawBounds->X;
                        destPoints[0].y = drawBounds->Y;
                        destPoints[1].x = drawBounds->X + drawBounds->Width;
                        destPoints[1].y = drawBounds->Y;
                        destPoints[2].x = drawBounds->X;
                        destPoints[2].y = drawBounds->Y + drawBounds->Height;

                        // Perform StretchDIBits of bitmap
                        status = gdiBitmap.StretchBlt(hdc, destPoints) ? Ok : GenericError;

                        // restore clipping from outline of shape
                        RestorePathClipping(hdc);

                        // restore from visible clip region
                        RestoreClipping(hdc, isClip, usePathClipping);
                    }

                    gpBitmap->UnlockBits(&bmpDataSrc);
                }

                gpBitmap->Dispose();

                context->ReleaseHdc(hdc);

                return status;
            }

            context->ReleaseHdc(hdc);
        }
    }

    BOOL SetVisibleClip;
    DWORD options = 0;

    BOOL AdjustWorldTransform = FALSE;

    switch (DriverType)
    {
    case DriverPCL:
        if (IsSolid)
        {
            options = ScanDeviceBounds;
            if (!IsOpaque)
            {
                options |= ScanDeviceAlpha;
            }
        }
        else
        {
            if (Is01Bitmap)
            {
                // rasterize at 32bpp
                options = ScanCappedBounds | ScanCapped32bpp;
            }
            else if (IsOpaque)
            {
                // rasterize at 24bpp
                options = ScanCappedBounds;
            }
            else
            {
                // rasterize 24bpp @ cap dpi & 1bpp @ device api
                options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;
            }
        }
        SetVisibleClip = IsOpaque || Is01Bitmap;
        break;

    case DriverPostscript:
        SetVisibleClip = !IsSolid;

        if (IsSolid)
        {
            options = ScanDeviceBounds;
            if (!IsOpaque)
            {
                options |= ScanDeviceAlpha;
            }

            if (PostscriptScalerX != 1 || PostscriptScalerY != 1)
            {
                AdjustWorldTransform = TRUE;
                savedmatrix = context->WorldToDevice;
            }
        }
        else
        {
            // For postscript we currently only support 0-1 alpha or complete
            // opaque.
            if (Is01Bitmap)
            {
                options |= ScanCappedBounds | ScanCapped32bpp;
            }
            else if (IsOpaque)
            {
                options |= ScanCappedBounds;
            }
            else
            {
                options |= ScanCappedBounds | ScanCappedOver | ScanDeviceZeroOut;
            }
        }
        break;

    default:
        ASSERT(FALSE);
        return NotImplemented;
    }

    EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;
    REAL w2dDev[6];
    REAL w2dCap[6];

    // To avoid round off errors causing
    GpRect roundedBounds;

    INT oldScaleX = ScaleX;
    INT oldScaleY = ScaleY;

    // For texture brush, rasterize at the texture image DPI.
    if (brush->Type == BrushTypeTextureFill)
    {
        GpTexture *gpBrush = (GpTexture*)GpBrush::GetBrush(brush);
        ASSERT(gpBrush != NULL);

        GpBitmap *gpBitmap = gpBrush->GetBitmap();

        if (gpBitmap != NULL)
        {
            REAL dpiX, dpiY;

            gpBitmap->GetResolution(&dpiX, &dpiY);

            ScaleX = GpFloor(surface->GetDpiX()/dpiX);
            ScaleY = GpFloor(surface->GetDpiY()/dpiY);

            // don't rasterize at a dpi higher than the destination surface
            if (ScaleX < 1) ScaleX = 1;
            if (ScaleY < 1) ScaleY = 1;
        }
    }

    if ((ScaleX == 1) && (ScaleY == 1))
    {
        roundedBounds.X = drawBounds->X;
        roundedBounds.Y = drawBounds->Y;
        roundedBounds.Width = drawBounds->Width;
        roundedBounds.Height = drawBounds->Height;
    }
    else
    {
        // round X,Y to multiple of ScaleX,Y
        roundedBounds.X = (drawBounds->X / ScaleX) * ScaleX;
        roundedBounds.Y = (drawBounds->Y / ScaleY) * ScaleY;

        // adjust width and height to compensate for smaller X,Y.
        roundedBounds.Width = drawBounds->Width + (drawBounds->X % ScaleX);
        roundedBounds.Height = drawBounds->Height + (drawBounds->Y % ScaleY);

        // round width, height to multiple of ScaleX,Y
        roundedBounds.Width += (ScaleX - (roundedBounds.Width % ScaleX));
        roundedBounds.Height += (ScaleY - (roundedBounds.Height % ScaleY));
    }

    // DrawBounds in Capped Space
    GpRect boundsCap(roundedBounds.X / ScaleX,
                     roundedBounds.Y / ScaleY,
                     roundedBounds.Width / ScaleX,
                     roundedBounds.Height / ScaleY);
    GpRect& boundsDev = roundedBounds;

    if (AdjustWorldTransform)
    {
        boundsDev.X = GpCeiling((REAL)boundsDev.X / PostscriptScalerX);
        boundsDev.Y = GpCeiling((REAL)boundsDev.Y / PostscriptScalerY);
        boundsDev.Width = GpCeiling((REAL)boundsDev.Width / PostscriptScalerX);
        boundsDev.Height = GpCeiling((REAL)boundsDev.Height / PostscriptScalerY);
        context->WorldToDevice.Scale(1.0f/PostscriptScalerX,
            1.0f/PostscriptScalerY,
            MatrixOrderAppend);
    }

    context->WorldToDevice.GetMatrix(&w2dDev[0]);
    context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                 1.0f/TOREAL(ScaleY),
                                 MatrixOrderAppend);
    context->WorldToDevice.GetMatrix(&w2dCap[0]);
    context->InverseOk = FALSE;

    // Infer a rectangle in world space which under the w2dCap transform
    // covers our bounding box.

    GpPointF dstPts[2];

    dstPts[0].X = TOREAL(boundsCap.X);
    dstPts[0].Y = TOREAL(boundsCap.Y);
    dstPts[1].X = TOREAL(boundsCap.X + boundsCap.Width);
    dstPts[1].Y = TOREAL(boundsCap.Y + boundsCap.Height);

    GpMatrix matrix;
    context->GetDeviceToWorld(&matrix);
    matrix.Transform(&dstPts[0], 2);

    GpRectF rectCap;
    rectCap.X = dstPts[0].X;
    rectCap.Y = dstPts[0].Y;
    rectCap.Width = dstPts[1].X - dstPts[0].X;
    rectCap.Height = dstPts[1].Y - dstPts[0].Y;

    // Reorient destination rectangle in the event that it has flipped by
    // World to Device transform.
    if (rectCap.Width < 0)
    {
        rectCap.X += rectCap.Width;
        rectCap.Width = -rectCap.Width;
    }

    if (rectCap.Height < 0)
    {
        rectCap.Y += rectCap.Height;
        rectCap.Height = -rectCap.Height;
    }

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    HDC hdc = context->GetHdc(surface);

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);

        if (status == Ok)
        {
            BOOL isClip = FALSE;
            BOOL usePathClipping = FALSE;

            if (SetVisibleClip)
            {
                DriverPrint::SetupClipping(hdc, context, drawBounds,
                                           isClip, usePathClipping, FALSE);
            }

            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                if (options & ScanCappedFlags)
                {
                    context->VisibleClip.DisableComplexClipping(BandBoundsCap);

                    // Render at capped DPI
                    context->InverseOk = FALSE;
                    context->WorldToDevice.SetMatrix(&w2dCap[0]);
                    scanPrint->SetRenderMode(FALSE, &BandBoundsCap);

                    status = DpDriver::FillRects(context,
                                                 surface,
                                                 &boundsCap,
                                                 1,
                                                 &rectCap,
                                                 brush);
                    context->VisibleClip.ReEnableComplexClipping();
                }

                context->InverseOk = FALSE;
                context->WorldToDevice.SetMatrix(&w2dDev[0]);

                if (status != Ok)
                    break;

                if (options & ScanDeviceFlags)
                {
                    context->VisibleClip.SetBandBounds(BandBoundsDev);
                    scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                    status = DpDriver::FillPath(context,
                                                surface,
                                                &boundsDev,
                                                outlinePath,
                                                brush);
                }

                if (status == Ok)
                {
                    status = OutputBufferDIB(hdc,
                                             context,
                                             surface,
                                             &BandBoundsCap,
                                             &BandBoundsDev,
                                             const_cast<DpPath*>(outlinePath));

                    if (status != Ok)
                        break;
                }
                else
                    break;

                BandBoundsCap.Y += BandHeightCap;
                BandBoundsDev.Y += BandHeightDev;
            }

            if (SetVisibleClip)
            {
                DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
            }

            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }
    else
    {
        context->InverseOk = FALSE;
        context->WorldToDevice.SetMatrix(&w2dDev[0]);
    }

    EndPrintBanding(context);

    if (AdjustWorldTransform)
    {
        context->InverseOk = FALSE;
        context->WorldToDevice = savedmatrix;
    }

    ScaleX = oldScaleX;
    ScaleY = oldScaleY;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled paths.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            HDC         hdc     = context->GetHdc(surface);

            if (hdc != NULL)
            {
                BOOL success = FALSE;

                ConvertPathToGdi gdiPath(path,
                                         &context->WorldToDevice,
                                         convertFlags,
                                         drawBounds);

                if (gdiPath.IsValid())
                {
                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiPath.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);
                }
                else
                {
                    // Path is too complicated to use GDI printing with FillPath
                    // semantics.  Instead we AND the outline path into the clip
                    // path and do a PatBlt.

                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    // clip to the visible region
                    SetupClipping(hdc, context, drawBounds, isClip, usePathClipping);

                    // clip to the outline path
                    SetupPathClipping(hdc, context, path);

                    HBRUSH oldHbr = (HBRUSH)SelectObject(hdc, hBrush);

                    // PatBlt the destination hdc with outline clip path
                    success = (BOOL)PatBlt(hdc,
                                           drawBounds->X,
                                           drawBounds->Y,
                                           drawBounds->Width,
                                           drawBounds->Height,
                                           PATCOPY);

                    SelectObject(hdc, oldHbr);

                    // restore clipping from outline path
                    RestorePathClipping(hdc);

                    // restore clipping from visible region
                    RestoreClipping(hdc, isClip, usePathClipping);
                }

                context->ReleaseHdc(hdc);

                if (success)
                {
                    status = Ok;
                    goto Exit;
                }
            }
        }
    }

    status = PrivateFillRect(context,
                             surface,
                             drawBounds,
                             path,
                             brush);

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled rectangles.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects,
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    ASSERT(numRects > 0);

    ASSERT(context->WorldToDevice.IsTranslateScale());

    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            ConvertRectFToGdi gdiRects(rects, numRects, &context->WorldToDevice);

            if (gdiRects.IsValid())
            {
                HDC         hdc     = context->GetHdc(surface);

                if (hdc != NULL)
                {
                    BOOL        isClip;
                    BOOL        success;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiRects.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);

                    context->ReleaseHdc(hdc);

                    if (success)
                    {
                        status = Ok;
                        goto Exit;
                    }
                }
            }
        }
    }

    // Setting the rectangles to a path is somewhat problematic because their
    // intersection may not be interpreted properly.  Also, this should result
    // in fewer bits being sent and more computation.  Here we just set each
    // rectangle as the drawBounds and no outline path to clip.
    {
        PointF pts[4];
        BYTE types[4] = {
            PathPointTypeStart,
            PathPointTypeLine,
            PathPointTypeLine,
            PathPointTypeLine | PathPointTypeCloseSubpath
        };

        pts[0].X = rects->X;
        pts[0].Y = rects->Y;
        pts[1].X = rects->X + rects->Width;
        pts[1].Y = rects->Y;
        pts[2].X = rects->X + rects->Width;
        pts[2].Y = rects->Y + rects->Height;
        pts[3].X = rects->X;
        pts[3].Y = rects->Y + rects->Height;

        GpPath rectPath(&pts[0],
                        &types[0],
                        4,
                        FillModeWinding);

        if (rectPath.IsValid())
        {
            while (numRects > 0)
            {
                GpRectF rectf = *rects;

                context->WorldToDevice.TransformRect(rectf);

                GpRect rect(GpRound(rectf.X), GpRound(rectf.Y),
                            GpRound(rectf.Width), GpRound(rectf.Height));

                status = PrivateFillRect(context,
                                         surface,
                                         (GpRect *)&rect,
                                         &rectPath,
                                         brush);

                if (--numRects)
                {
                    rects++;
                    // !! Safer and more efficient way to do this?
                    GpPointF* pathPts = const_cast<GpPointF*>(rectPath.GetPathPoints());

                    pathPts[0].X = rects->X;
                    pathPts[0].Y = rects->Y;
                    pathPts[1].X = rects->X + rects->Width;
                    pathPts[1].Y = rects->Y;
                    pathPts[2].X = rects->X + rects->Width;
                    pathPts[2].Y = rects->Y + rects->Height;
                    pathPts[3].X = rects->X;
                    pathPts[3].Y = rects->Y + rects->Height;
                }
            }
        }
    }

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled regions.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            ConvertRegionToGdi gdiRegion(region);

            if (gdiRegion.IsValid())
            {
                HDC         hdc     = context->GetHdc(surface);

                if (hdc != NULL)
                {
                    BOOL        isClip;
                    BOOL        success;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiRegion.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);

                    context->ReleaseHdc(hdc);

                    if (success)
                    {
                        status = Ok;
                        goto Exit;
                    }
                }
            }
        }
    }

    {
        // convert region to path
        RegionToPath convertRegion;

        DynPointArray points;
        DynByteArray types;

        if (convertRegion.ConvertRegionToPath(const_cast<DpRegion*>(region),
                                              points,
                                              types) == FALSE)
        {
            status = GenericError;
            goto Exit1;
        }

        {
            // unfortunately to create path, our points must be floating point,
            // so we allocate and convert

            GpPointF *pointFArray;
            GpPoint *pointArray = points.GetDataBuffer();
            INT numPoints = points.GetCount();

            pointFArray = (GpPointF*) GpMalloc(numPoints * sizeof(GpPointF));

            if (pointFArray == NULL)
            {
                status = OutOfMemory;
                goto Exit12;
            }

            {
                for (INT i=0; i<numPoints; i++)
                {
                    pointFArray[i].X = TOREAL(pointArray[i].X);
                    pointFArray[i].Y = TOREAL(pointArray[i].Y);
                }

                // !! We compute path from region in device space to ensure
                // our output is high quality. Perhaps add an option here
                // dependent on the QualityMode to convert in world space and
                // then transform to device space.

                // This is not a high frequency API so I don't care too much
                // about perf, but perhaps it could be improved by reworking
                // where this transform occurs.

                GpMatrix deviceToWorld;
                context->GetDeviceToWorld(&deviceToWorld);
                deviceToWorld.Transform(pointFArray, numPoints);

                // !! What's the fillMode?
                // !! Create a DpPath, do we require the knowledge of the inheritance anywhere?
                {
                    GpPath path(pointFArray,
                                types.GetDataBuffer(),
                                numPoints);

                    if (path.IsValid())
                    {
                        GpRect newBounds;

                        path.GetBounds(&newBounds,
                                       &context->WorldToDevice);

                        status = FillPath(context,
                                          surface,
                                          &newBounds,
                                          (DpPath*)&path,
                                          brush);
                    }
                }

                GpFree(pointFArray);
            }

Exit12:
            ;
        } // pointFArray

Exit1:
        ;
    } // RegionToPath

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Strokes paths.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    if (SetupBrush(const_cast<DpBrush*>(pen->Brush), context, surface))
        return Ok;

    GpStatus status;

    // GDI doesn't seem to support HPENs which PATTERN type HBRUSHes
    if (IsOpaque && IsSolid)
    {
        DWORD convertFlags = IsPrinting |
                     ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH hBrush = GetBrush(pen->Brush, convertFlags);

        if (hBrush)
        {
            HDC         hdc = context->GetHdc(surface);
            BOOL        success = FALSE;

            if (hdc != NULL)
            {
                // Handle non compound pen case
                if ((pen->PenAlignment == PenAlignmentCenter) &&
                    (pen->CompoundCount == 0))
                {
                    ConvertPenToGdi gdiPen(hdc,
                                           pen,
                                           &context->WorldToDevice,
                                           context->GetDpiX(),
                                           convertFlags,
                                           const_cast<LOGBRUSH*>(CachedBrush.GetGdiBrushInfo()));

                    if (gdiPen.IsValid())
                    {
                        ConvertPathToGdi gdiPath(path,
                                                 &context->WorldToDevice,
                                                 convertFlags,
                                                 drawBounds);

                        if (gdiPath.IsValid())
                        {
                            BOOL        isClip, success = FALSE;
                            BOOL        usePathClipping = FALSE;

                            SetupClipping(hdc,
                                          context,
                                          drawBounds,
                                          isClip,
                                          usePathClipping,
                                          FALSE);

                            success = gdiPath.Draw(hdc, gdiPen.GetGdiPen());

                            RestoreClipping(hdc,
                                            isClip,
                                            usePathClipping);
                        }
                    }
                }

                context->ReleaseHdc(hdc);

                if (success)
                {
                    status = Ok;
                    goto Exit;
                }
            }
        }
    }

    // get the widened path, then fill path with pen's interal brush
    //
    // also the bitmap can be quite hugh for a simple path

    {
        GpRect newBounds;
        GpMatrix identity;
        GpMatrix savedMatrix = context->WorldToDevice;

        DpBrush *brush = const_cast<DpBrush*>(pen->Brush);
        GpMatrix savedBrushTransform = brush->Xform;

        // Widening the path transforms the points
        DpPath* newPath = path->CreateWidenedPath(
            pen,
            context,
            DriverType == DriverPostscript,
            pen->PenAlignment != PenAlignmentInset
        );

        if (!newPath || !newPath->IsValid())
        {
             status = OutOfMemory;
             goto Exit1;
        }

        // The path is in device space, which is convenient because the World
        // to device is an identity transform.  However, because W2D is I, the
        // brush transform is composed improperly and so device to texture
        // map results in wrong size textures.
        GpMatrix::MultiplyMatrix(brush->Xform,
                                 savedBrushTransform,
                                 savedMatrix);


        {
            HDC hdc = NULL;

            if(pen->PenAlignment == PenAlignmentInset)
            {
                hdc = context->GetHdc(surface);
                if(hdc != NULL)
                {
                    SetupPathClipping(hdc, context, path);
                }
            }

            // The widened path is already transformed to the device coordinates.
            // Hence, use the identity matrix for the context. 05/23/00 -- ikkof
            // Set up the state for the FillPath after setting up the path
            // clipping for the inset pen if necessary.

            newPath->GetBounds(&newBounds);
            context->InverseOk = FALSE;
            context->WorldToDevice = identity;

            status = FillPath(context, surface, &newBounds, newPath, brush);

            context->InverseOk = FALSE;
            context->WorldToDevice = savedMatrix;

            if(pen->PenAlignment == PenAlignmentInset)
            {
                if(hdc != NULL)
                {
                    RestorePathClipping(hdc);
                    context->ReleaseHdc(hdc);
                }
            }
        }


        brush->Xform = savedBrushTransform;

        newPath->DeletePath();

Exit1:
        ;
    }

Exit:
    RestoreBrush(const_cast<DpBrush*>(pen->Brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draw the image at the specified location
*
* Arguments:
*
*   [IN]  context    - The drawing context
*   [IN]  surface    - The surface to draw to
*   [IN]  drawBounds - The bounds of the object being drawn
*   [IN]  srcSurface - The image to draw
*   [IN]  mapMode    - The map mode
*   [IN]  numPoints  - The number of points in dstPoints
*   [IN]  dstPoints  - Where to draw the image
*   [IN]  srcRect    - The portion of the image to draw
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   10/28/1999 ericvan
*
\**************************************************************************/

GpStatus
DriverPrint::DrawImage(
    DpContext *          context,
    DpBitmap *           srcSurface,
    DpBitmap *           dstSurface,
    const GpRect *       drawBounds,
    DpImageAttributes    imageAttributes,
    INT                  numPoints,
    const GpPointF *     dstPoints,
    const GpRectF *      srcRect,
    DriverDrawImageFlags flags
    )
{
    GpStatus status = GenericError;
    ASSERT(numPoints == 3);

    if (context->CompositingMode == CompositingModeSourceCopy)
    {
        IsOpaque = TRUE;
        Is01Bitmap = FALSE;
    }
    else if (srcSurface->SurfaceTransparency == TransparencySimple)
    {
        Is01Bitmap = TRUE;
        IsNearConstant = FALSE;
        IsOpaque = FALSE;
    }
    else if ((srcSurface->SurfaceTransparency == TransparencyUnknown) ||
             (srcSurface->SurfaceTransparency == TransparencyComplex))
    {
        // PCL driver doesn't treat 0-1 bitmaps any different.
        if (DriverType == DriverPostscript)
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = TRUE;
        }
        else
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = FALSE;
        }
    }
    else if (srcSurface->SurfaceTransparency == TransparencyNearConstant)
    {
        if (DriverType == DriverPostscript)
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = TRUE;
        }
#if 0
        // Disable IsNearConstant right now
        if (DriverType == DriverPostscript)
        {
            IsNearConstant = TRUE;
            IsOpaque = FALSE;
            Is01Bitmap = FALSE;
            MinAlpha = srcSurface->MinAlpha;
            MaxAlpha = srcSurface->MaxAlpha;
            ASSERT(MinAlpha <= MaxAlpha);
        }
#endif
        else
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = FALSE;
        }
    }
    else
    {
        // TransparencyOpaque || TransparencyNoAlpha
        IsOpaque = TRUE;
        IsNearConstant = FALSE;
        Is01Bitmap = FALSE;
    }
    IsSolid = FALSE;

    BOOL tryPassthrough = (srcSurface->CompressedData != NULL) &&
                          (srcSurface->CompressedData->buffer != NULL);
    if (IsOpaque || tryPassthrough)
    {
        // Scale/translated stretched opaque image, use GDI.

        if (context->WorldToDevice.IsTranslateScale() &&
            (numPoints == 3) &&
            (REALABS(dstPoints[0].X - dstPoints[2].X) < REAL_EPSILON) &&
            (REALABS(dstPoints[0].Y - dstPoints[1].Y) < REAL_EPSILON) &&
            (dstPoints[1].X > dstPoints[0].X) &&
            (dstPoints[2].Y > dstPoints[0].Y))
        {
            CachedBackground back;

            HDC hdc = context->GetHdc(dstSurface);

            // Ack, this is just before the Office M1 release, and we want
            // blts when printing to have half-decent performance.  So we
            // convert to a straight GDI StretchBlt.  But we only want to
            // do this for printers (so that we get bilinear stretches to
            // the screen), but DriverPrint is also used for the screen.  So
            // we hack a check here on the DC.

            BOOL    success = FALSE;
            POINT   gdiPoints[3];
            context->WorldToDevice.Transform(dstPoints, gdiPoints, 3);

            // Make sure there is no flipping
            if ((gdiPoints[1].x > gdiPoints[0].x) &&
                (gdiPoints[2].y > gdiPoints[0].y))
            {
                DWORD       convertFlags = IsPrinting |
                             ((DriverType == DriverPostscript) ? IsPostscript : 0) |
                             ((!IsOpaque && tryPassthrough) ? IsPassthroughOnly : 0);

                GpRect rect(GpRound(srcRect->X),
                            GpRound(srcRect->Y),
                            GpRound(srcRect->Width),
                            GpRound(srcRect->Height));

                ConvertBitmapToGdi  gdiBitmap(hdc,
                                              srcSurface,
                                              &rect,
                                              convertFlags);

                if (gdiBitmap.IsValid())
                {
                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    DriverPrint::SetupClipping(hdc, context, drawBounds,
                                               isClip, usePathClipping, FALSE);

                    success = gdiBitmap.StretchBlt(hdc, gdiPoints);

                    DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
                }
            }

            if (success)
            {
                context->ReleaseHdc(hdc);

                return Ok;
            }

            context->ReleaseHdc(hdc);
        }
    }

    // We only process remaining code path if pixel format is >= 32bpp.
    if (GetPixelFormatSize(srcSurface->PixelFormat) != 32)
    {
        return GenericError;
    }

    // Setup ScanDIB class correctly by specifying proper flags
    BOOL SetVisibleClip;
    DWORD options = 0;

    switch (DriverType)
    {
    case DriverPCL:
        if (Is01Bitmap)
        {
            // rasterize @ 32bpp
            // Due to filtering, we want to blend with WHITENESS, only very
            // transparent portions are cut.
            options = ScanCappedBounds | ScanCapped32bppOver;
        }
        else if (IsOpaque)
        {
            // rasterize @ 24bpp
            options = ScanCappedBounds;
        }
        else
        {
            options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;
        }

        SetVisibleClip = IsOpaque || Is01Bitmap;
        break;

    case DriverPostscript:
        if (Is01Bitmap)
        {
            // rasterize @ 32bpp (this 0-1 bitmaps or complex alpha)
            options = ScanCappedBounds | ScanCapped32bppOver;
        }
        else if (IsOpaque || IsNearConstant)
        {
            // rasterize @ 24bpp
            options = ScanCappedBounds;
        }
        else
        {
            ASSERT(FALSE);
        }
        SetVisibleClip = TRUE;
        break;

    default:
        ASSERT(FALSE);

        return NotImplemented;
    }

    EpScanDIB *scanPrint = (EpScanDIB*) dstSurface->Scan;
    REAL w2dDev[6];
    REAL w2dCap[6];

    // If there is alpha blending or 0-1 bitmap,
    // it REALLY REALLY helps that the capped DPI divides the device DPI,
    // otherwise it's hard to find every other one to output!

    ASSERT(srcSurface->DpiX != 0 && srcSurface->DpiY != 0);
    ASSERT(dstSurface->DpiY != 0 && dstSurface->DpiY != 0);

    REAL srcDpiX = srcSurface->GetDpiX();
    REAL srcDpiY = srcSurface->GetDpiY();

    INT oldScaleX = ScaleX;
    INT oldScaleY = ScaleY;

    // !!! what if context->GetDpiX has a different value than the surface?
    ScaleX = GpFloor(dstSurface->GetDpiX()/srcDpiX);
    ScaleY = GpFloor(dstSurface->GetDpiY()/srcDpiY);

    // don't rasterize at a dpi higher than the device.
    if (ScaleX < 1) ScaleX = 1;
    if (ScaleY < 1) ScaleY = 1;

    // Some images have incorrect DPI information, to combat this, we check
    // for a lower threshold on the image DPI, DEF_RES/4 seems reasonable.  If
    // the DPI is lower then we assume it's not accurate and rasterize at
    // the default capped dpi for this device.  If the DPI is above DEF_RES/4
    // then the image should at least look reasonable.
    if (srcDpiX < TOREAL((DEFAULT_RESOLUTION/4)))
    {
        ScaleX = oldScaleX;
    }

    if (srcDpiY < TOREAL((DEFAULT_RESOLUTION/4)))
    {
        ScaleY = oldScaleY;
    }

    // To avoid rounding errors with the underlying DpDriver code, we
    // compute the destination bounds in capped device space.
    context->WorldToDevice.GetMatrix(&w2dDev[0]);
    context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                 1.0f/TOREAL(ScaleY), MatrixOrderAppend);
    context->WorldToDevice.GetMatrix(&w2dCap[0]);
    context->InverseOk = FALSE;

    GpMatrix xForm;
    xForm.InferAffineMatrix(&dstPoints[0], *srcRect);
    xForm.Append(context->WorldToDevice);       // includes 1/ScaleX,Y

    GpPointF corners[4];

    corners[0].Y = max(srcRect->Y, 0);
    corners[1].Y = min(srcRect->Y + srcRect->Height,
                       srcSurface->Height);
    corners[0].X = max(srcRect->X, 0);
    corners[1].X = min(srcRect->X + srcRect->Width,
                       srcSurface->Width);
    corners[2].X = corners[0].X;
    corners[2].Y = corners[1].Y;
    corners[3].X = corners[1].X;
    corners[3].Y = corners[0].Y;

    xForm.Transform(&corners[0], 4);

    GpPointF topLeft, bottomRight;
    topLeft.X = min(min(corners[0].X, corners[1].X), min(corners[2].X, corners[3].X));
    topLeft.Y = min(min(corners[0].Y, corners[1].Y), min(corners[2].Y, corners[3].Y));
    bottomRight.X = max(max(corners[0].X, corners[1].X), max(corners[2].X, corners[3].X));
    bottomRight.Y = max(max(corners[0].Y, corners[1].Y), max(corners[2].Y, corners[3].Y));

    // Use same rounding convention as DpDriver::DrawImage
    GpRect boundsCap;

    boundsCap.X = GpFix4Ceiling(GpRealToFix4(topLeft.X));
    boundsCap.Y = GpFix4Ceiling(GpRealToFix4(topLeft.Y));
    boundsCap.Width = GpFix4Ceiling(GpRealToFix4(bottomRight.X)) - boundsCap.X;
    boundsCap.Height = GpFix4Ceiling(GpRealToFix4(bottomRight.Y)) - boundsCap.Y;

    // DrawBounds in device space
    GpRect boundsDev(boundsCap.X * ScaleX,
                     boundsCap.Y * ScaleY,
                     boundsCap.Width * ScaleX,
                     boundsCap.Height * ScaleY);

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    // Setup outline path for clipping in world space
    PointF clipPoints[4];
    BYTE clipTypes[4] = {
        PathPointTypeStart,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine | PathPointTypeCloseSubpath
    };

    clipPoints[0] = dstPoints[0];
    clipPoints[1] = dstPoints[1];
    clipPoints[3] = dstPoints[2];

    clipPoints[2].X = clipPoints[1].X + (clipPoints[3].X - clipPoints[0].X);
    clipPoints[2].Y = clipPoints[1].Y + (clipPoints[3].Y - clipPoints[0].Y);

    GpPath clipPath(&clipPoints[0],
                    &clipTypes[0],
                    4,
                    FillModeWinding);

    HDC hdc = NULL;

    if (clipPath.IsValid())
    {
        hdc = context->GetHdc(dstSurface);
    }

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);
        if (status == Ok)
        {
            BOOL isClip = FALSE;
            BOOL usePathClipping = FALSE;

            // Set the visible clip unless it is captured in our mask
            if (SetVisibleClip)
            {
                DriverPrint::SetupClipping(hdc,
                                           context,
                                           drawBounds,
                                           isClip,
                                           usePathClipping,
                                           FALSE);
            }

            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                // Render a square rectangle without any clipping
               scanPrint->SetRenderMode(FALSE, &BandBoundsCap);
               context->InverseOk = FALSE;
               context->WorldToDevice.SetMatrix(&w2dCap[0]);
               context->VisibleClip.DisableComplexClipping(BandBoundsCap);

               status = DpDriver::DrawImage(context, srcSurface, dstSurface,
                                            &boundsCap, imageAttributes, numPoints,
                                            dstPoints, srcRect, flags);

               context->InverseOk = FALSE;
               context->WorldToDevice.SetMatrix(&w2dDev[0]);
               context->VisibleClip.ReEnableComplexClipping();

               if (status != Ok)
                   break;

               if (options & ScanDeviceFlags)
               {
                   context->VisibleClip.SetBandBounds(BandBoundsDev);

                   // Render the original path band at device DPI
                   // outputPath is already transformed into device space
                   scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                   status = DpDriver::DrawImage(context, srcSurface, dstSurface,
                                                &boundsDev, imageAttributes, numPoints,
                                                dstPoints, srcRect, flags);
               }

               if (status == Ok)
               {
                   status = OutputBufferDIB(hdc,
                                            context,
                                            dstSurface,
                                            &BandBoundsCap,
                                            &BandBoundsDev,
                                            &clipPath);
                   if (status != Ok)
                       break;
               }
               else
                   break;

               BandBoundsCap.Y += BandHeightCap;
               BandBoundsDev.Y += BandHeightDev;

               // next band is last band
               if (Band == (NumBands - 2))
               {
#if 0
                   // only blit out the remaining part of draw bounds
                   BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                   BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                   ASSERT(BandBoundsCap.Height <= BandHeightCap);
                   ASSERT(BandBoundsDev.Height <= BandHeightDev);
                   ASSERT(BandBoundsCap.Height > 0);
                   ASSERT(BandBoundsDev.Height > 0);
#endif
               }
            }

            if (SetVisibleClip)
            {
                DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
            }

            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }
    else
    {
        context->InverseOk = FALSE;
        context->WorldToDevice.SetMatrix(&w2dDev[0]);
    }

    EndPrintBanding(context);

    ScaleX = oldScaleX;
    ScaleY = oldScaleY;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws text at a position.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] text       - the typeset text to be drawn
*   [IN] font       - the font to use
*   [IN] fgBrush    - the brush to use for the text
*   [IN] bgBrush    - the brush to use for the background (default = NULL)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   5/22/2k ericvan
*
\**************************************************************************/

GpStatus
DriverPrint::DrawGlyphs
(
    DrawGlyphData *drawGlyphData
)
{
    GpStatus status = GenericError;

    //  Choose appropriate brush behaviour
    switch(drawGlyphData->brush->Type)
    {
    case BrushTypeSolidColor:
        // pass bitmap GlyphPos to SolidText API
        status = SolidText(drawGlyphData->context,
                           drawGlyphData->surface,
                           drawGlyphData->drawBounds,
                           drawGlyphData->brush->SolidColor,
                           drawGlyphData->faceRealization,
                           drawGlyphData->glyphPos,
                           drawGlyphData->count,
                           drawGlyphData->glyphs,
                           drawGlyphData->glyphOrigins,
                           TextRenderingHintSingleBitPerPixelGridFit,
                           drawGlyphData->rightToLeft);
        break;

    case BrushTypeTextureFill:
    case BrushTypeHatchFill:
    case BrushTypePathGradient:
    case BrushTypeLinearGradient:
        // pass path GlyphPos to BrushText API if PostScript (for clipping)
        // otherwise pass bitmap GlyphPos to compose bitmaps
        status = BrushText(drawGlyphData->context,
                           drawGlyphData->surface,
                           drawGlyphData->drawBounds,
                           drawGlyphData->brush,
                           drawGlyphData->glyphPos,
                           drawGlyphData->glyphPathPos,
                           drawGlyphData->count,
                           TextRenderingHintSingleBitPerPixelGridFit);
        break;

    default:
        ASSERT(FALSE);          // Unknown brush type
        break;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Solid Text
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   12/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::SolidText(
        DpContext* context,
        DpBitmap* surface,
        const GpRect* drawBounds,
        GpColor color,
        const GpFaceRealization *faceRealization,
        const GpGlyphPos *glyphPos,
        INT count,
        const UINT16 *glyphs,
        const PointF *glyphOrigins,
        GpTextRenderingHint textMode,
        BOOL rightToLeft
        )
{
    ASSERT(textMode == TextRenderingHintSingleBitPerPixelGridFit);

    GpStatus status = GenericError;

    IsSolid = TRUE;
    SolidColor = color.ToCOLORREF();

    IsOpaque = color.IsOpaque() ||
               (context->CompositingMode == CompositingModeSourceCopy);

    Is01Bitmap = FALSE;

    INT angle;  // Passed from GetTextOutputHdc to GdiText

    HDC gdiHdc = NULL;

    // Try punt to GDI.
    gdiHdc = context->GetTextOutputHdc(faceRealization,
                                       color,
                                       surface,
                                       &angle);

    GpMatrix savedmatrix;
    BOOL AdjustWorldTransform = FALSE;

    if (gdiHdc)
    {
        BOOL isClip;
        BOOL usePathClipping = FALSE;

        BOOL bUseClipEscapes;

        // Win9x and ME PS driver on HP's printer there is a bug to cause
        // we need to use GDI clip region to set up the clip path
        if (DriverType == DriverPostscript)
        {
            if (!Globals::IsNt)
            {
                bUseClipEscapes = UseClipEscapes;
                UseClipEscapes = FALSE;
            }

            if (PostscriptScalerX != 1 || PostscriptScalerY != 1)
            {
                AdjustWorldTransform = TRUE;
                savedmatrix = context->WorldToDevice;
            }
        }

        DriverPrint::SetupClipping(gdiHdc,
                                   context,
                                   drawBounds,
                                   isClip,
                                   usePathClipping,
                                   FALSE);

        status = DpDriver::GdiText(gdiHdc,
                                   angle,
                                   glyphs,
                                   glyphOrigins,
                                   count,
                                   rightToLeft);

        DriverPrint::RestoreClipping(gdiHdc, isClip, usePathClipping);

        if (DriverType == DriverPostscript && !Globals::IsNt)
            UseClipEscapes = bUseClipEscapes;

        context->ReleaseTextOutputHdc(gdiHdc);

        if (status == Ok)
        {
            return Ok;
        }
    }

    EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;

    // only used for computing band sizes
    GpRect boundsCap(drawBounds->X, drawBounds->Y,
                     drawBounds->Width, drawBounds->Height);
    GpRect boundsDev = *drawBounds;

    if (AdjustWorldTransform)
    {
        boundsDev.X = GpCeiling((REAL)boundsDev.X / PostscriptScalerX);
        boundsDev.Y = GpCeiling((REAL)boundsDev.Y / PostscriptScalerY);
        boundsDev.Width = GpCeiling((REAL)boundsDev.Width / PostscriptScalerX);
        boundsDev.Height = GpCeiling((REAL)boundsDev.Height / PostscriptScalerY);
        context->WorldToDevice.Scale(1.0f/PostscriptScalerX,
            1.0f/PostscriptScalerY,
            MatrixOrderAppend);
    }

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    DWORD options;

    // works for DriverPCL and DriverPostscript
    if (IsOpaque)
    {
        options = ScanDeviceBounds;
    }
    else
    {
        options = ScanDeviceBounds | ScanDeviceAlpha;
    }

    HDC hdc = context->GetHdc(surface);

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);

        if (status == Ok)
        {
            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                context->VisibleClip.SetBandBounds(BandBoundsDev);

                // Render the solid text at device DPI, this generates
                // an alpha channel with only the alpha bits.

                scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                status = DpDriver::SolidText(context, surface, &boundsDev,
                                             color, glyphPos, count,
                                             TextRenderingHintSingleBitPerPixelGridFit,
                                             rightToLeft);
                if (status == Ok)
                {
                    // Don't set clip path here since it is captured in the mask
                    status = OutputBufferDIB(hdc,
                                             context,
                                             surface,
                                             &BandBoundsCap,
                                             &BandBoundsDev,
                                             NULL);
                    if (status != Ok)
                        break;
                }
                else
                    break;

                BandBoundsCap.Y += BandHeightCap;
                BandBoundsDev.Y += BandHeightDev;

     #if 0
                // next band is last band
                if (Band == (NumBands - 2))
                {
                    // only blit out the remaining part of draw bounds
                    BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                    BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                    ASSERT(BandBoundsCap.Height <= BandHeightCap);
                    ASSERT(BandBoundsDev.Height <= BandHeightDev);
                }
     #endif
            }
            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }

    EndPrintBanding(context);

    if (AdjustWorldTransform)
    {
        context->InverseOk = FALSE;
        context->WorldToDevice = savedmatrix;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Brush Text
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::BrushText(
        DpContext*          context,
        DpBitmap*           surface,
        const GpRect*       drawBounds,
        const DpBrush*      brush,
        const GpGlyphPos*   glyphPos,
        const GpGlyphPos*   glyphPathPos,
        INT                 count,
        GpTextRenderingHint textMode
        )
{
   ASSERT(textMode == TextRenderingHintSingleBitPerPixelGridFit);

   // !! Perf. Do context->GetHdc() once at beginning and then not again.

   if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
       return Ok;

   INT oldScaleX = -1;
   INT oldScaleY = -1;

   Is01Bitmap = FALSE;

   GpStatus status = GenericError;

   BOOL SetVisibleClip;
   DWORD options;

   switch (DriverType)
   {
   case DriverPCL:
       SetVisibleClip = FALSE;
       // to ensure we always use mask (XOR-AND-XOR) on PCL, we set ScanDeviceAlpha

       options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;

       IsOpaque = FALSE;

       break;

   case DriverPostscript:
      SetVisibleClip = TRUE;
      options = ScanCappedBounds | ScanDeviceZeroOut;
      if (!IsOpaque)
      {
          IsOpaque = TRUE;
      //    options |= ScanCappedOver;
      }
      break;

   default:
       ASSERT(FALSE);
       status = NotImplemented;
       goto Exit;
   }

   {
       EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;
       REAL w2dDev[6];
       REAL w2dCap[6];

       // To avoid round off errors causing
       GpRect roundedBounds;

       if ((ScaleX == 1) && (ScaleY == 1))
       {
           roundedBounds.X = drawBounds->X;
           roundedBounds.Y = drawBounds->Y;
           roundedBounds.Width = drawBounds->Width;
           roundedBounds.Height = drawBounds->Height;
       }
       else
       {
           // round X,Y to multiple of ScaleX,Y
           roundedBounds.X = (drawBounds->X / ScaleX) * ScaleX;
           roundedBounds.Y = (drawBounds->Y / ScaleY) * ScaleY;

           // adjust width and height to compensate for smaller X,Y.
           roundedBounds.Width = drawBounds->Width + (drawBounds->X % ScaleX);
           roundedBounds.Height = drawBounds->Height + (drawBounds->Y % ScaleY);

           // round width, height to multiple of ScaleX,Y
           roundedBounds.Width += (ScaleX - (roundedBounds.Width % ScaleX));
           roundedBounds.Height += (ScaleY - (roundedBounds.Height % ScaleY));
       }

       // DrawBounds in Capped Space
       GpRect boundsCap(roundedBounds.X / ScaleX,
                        roundedBounds.Y / ScaleY,
                        roundedBounds.Width / ScaleX,
                        roundedBounds.Height / ScaleY);

       if (boundsCap.Width == 0 || boundsCap.Height == 0)
       {
            oldScaleX = ScaleX;
            oldScaleY = ScaleY;

            ScaleX = 1;
            ScaleY = 1;

            boundsCap.X = roundedBounds.X;
            boundsCap.Y = roundedBounds.Y;
            boundsCap.Width = roundedBounds.Width;
            boundsCap.Height = roundedBounds.Height;
       }

       // DrawBounds in Device Space
       GpRect& boundsDev = roundedBounds;

       // Infer a rectangle in world space which under the w2dCap transform
       // covers our bounding box.

       GpPointF dstPts[4];

       dstPts[0].X = TOREAL(roundedBounds.X);
       dstPts[0].Y = TOREAL(roundedBounds.Y);
       dstPts[1].X = TOREAL(roundedBounds.X + roundedBounds.Width);
       dstPts[1].Y = TOREAL(roundedBounds.Y);
       dstPts[2].X = TOREAL(roundedBounds.X);
       dstPts[2].Y = TOREAL(roundedBounds.Y + roundedBounds.Height);
       dstPts[3].X = TOREAL(roundedBounds.X + roundedBounds.Width);
       dstPts[3].Y = TOREAL(roundedBounds.Y + roundedBounds.Height);

       GpMatrix matrix;
       context->GetDeviceToWorld(&matrix);
       matrix.Transform(&dstPts[0], 4);

       GpRectF rectCap;
       rectCap.X = min(min(dstPts[0].X, dstPts[1].X),
                       min(dstPts[2].X, dstPts[3].X));
       rectCap.Y = min(min(dstPts[0].Y, dstPts[1].Y),
                       min(dstPts[2].Y, dstPts[3].Y));
       rectCap.Width = max(max(dstPts[0].X, dstPts[1].X),
                           max(dstPts[2].X, dstPts[3].X)) - rectCap.X;
       rectCap.Height = max(max(dstPts[0].Y, dstPts[1].Y),
                            max(dstPts[2].Y, dstPts[3].Y)) - rectCap.Y;

       SetupPrintBanding(context, &boundsCap, &boundsDev);

       context->WorldToDevice.GetMatrix(&w2dDev[0]);
       context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                    1.0f/TOREAL(ScaleY),
                                    MatrixOrderAppend);
       context->WorldToDevice.GetMatrix(&w2dCap[0]);
       context->InverseOk = FALSE;

       HDC hdc = context->GetHdc(surface);;

       if (hdc != NULL)
       {
           status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                               &BandBoundsDev,
                                               options,
                                               ScaleX,
                                               ScaleY);

           GlyphClipping = FALSE;
           if (status == Ok)
           {
               BOOL isClip = FALSE;
               BOOL usePathClipping = FALSE;

               // Set the visible clip unless it is captured in our mask
               if (SetVisibleClip)
               {
                   DriverPrint::SetupClipping(hdc, context, drawBounds,
                                              isClip, usePathClipping, FALSE);
               }

               // !! This should be shifted into postscript driver
               if (DriverType == DriverPostscript)
               {
                   DriverPrint::SetupGlyphPathClipping(hdc,
                                                       context,
                                                       glyphPathPos,
                                                       count);
               }

               ASSERT(NumBands > 0);
               for (Band = 0; Band<NumBands; Band++)
               {
                   // Render a square rectangle without any clipping
                   scanPrint->SetRenderMode(FALSE, &BandBoundsCap);
                   context->InverseOk = FALSE;
                   context->WorldToDevice.SetMatrix(&w2dCap[0]);
                   context->VisibleClip.DisableComplexClipping(BandBoundsCap);

                   status = DpDriver::FillRects(context,
                                                surface,
                                                &boundsCap,
                                                1,
                                                &rectCap,
                                                brush);

                   context->InverseOk = FALSE;
                   context->WorldToDevice.SetMatrix(&w2dDev[0]);
                   context->VisibleClip.ReEnableComplexClipping();

                   if (status != Ok)
                       break;

                   context->VisibleClip.SetBandBounds(BandBoundsDev);

                   // Render the original path band at device DPI
                   scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                   status = DpDriver::BrushText(context, surface, &boundsDev,
                                                brush, glyphPos, count,
                                                TextRenderingHintSingleBitPerPixelGridFit);

                   if (status == Ok)
                   {
                       status = OutputBufferDIB(hdc,
                                                context,
                                                surface,
                                                &BandBoundsCap,
                                                &BandBoundsDev,
                                                NULL);

                       if (status != Ok)
                           break;
                   }

                   BandBoundsCap.Y += BandHeightCap;
                   BandBoundsDev.Y += BandHeightDev;

#if 0
                   // next band is last band
                   if (Band == (NumBands - 2))
                   {
                       // only blit out the remaining part of draw bounds
                      BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                      BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                      ASSERT(BandBoundsCap.Height <= BandHeightCap);
                      ASSERT(BandBoundsDev.Height <= BandHeightDev);
                   }
#endif
               }

               // End scope of clipping for individual glyph characters
               if ((DriverType == DriverPostscript) &&
                   (GlyphClipping))
               {
                   DriverPrint::RestoreEscapeClipping(hdc);
               }

               if (SetVisibleClip)
               {
                   DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
               }

               scanPrint->DestroyBufferDIB();
           }

           context->ReleaseHdc(hdc);
       }
       else
       {
           context->InverseOk = FALSE;
           context->WorldToDevice.SetMatrix(&w2dDev[0]);
       }

       EndPrintBanding(context);
   }

Exit:

   if (oldScaleX != -1)
   {
       ScaleX = oldScaleX;
       ScaleY = oldScaleY;
   }

   RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*
*  8/16/2000 bhouse
*  + Changed to growth mechanics to be exponential
*
\**************************************************************************/

class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - initial number of elements

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT count = 0);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements
    // exactSize         - no exponential growth

    GpStatus Grow(UINT eltSize, UINT newElements, BOOL exactSize = FALSE);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Add new, uninitialized elements, and return a pointer to them.
    // All data from index on is shift towards the end of the array to make room.
    // index       - index from which to insert the new elements.
    // eltSize     - size of each element
    // newElements - number of new elements
    // CAUTION! could cause a big performance hit if the array is large!

    void *AddMultipleAt(UINT eltSize, UINT index, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // All data from index on is shift towards the end of the array to make room.
    // eltSize     - size of each element
    // index       - index from which to insert the new elements.
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus AddMultipleAt(UINT eltSize, UINT index, UINT newElements, const void *newData);

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(UINT eltSize, UINT index, UINT numElements);
    
    // Detach the data buffer from the dynamic array.
    // Cannot be used if there is an initial allocation.

    void *DetachData(UINT eltSize);

    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    enum {
        kMinCapacityGrowth = 16,
        kMaxCapacityGrowth = 8092
    };

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\endcap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

GpEndCapCreator::GpEndCapCreator(
    GpPath *path, 
    DpPen *pen, 
    GpMatrix *m,
    REAL dpi_x, 
    REAL dpi_y,
    bool antialias
)
{
    Path = path;
    Pen = pen;
    if(m) {XForm = *m;}
    XForm.Prepend(pen->Xform);
    DpiX = dpi_x;
    DpiY = dpi_y;
    Antialias = antialias;
    
    StartCap = NULL;
    EndCap = NULL;
    
    switch(Pen->StartCap)
    {
        case LineCapCustom:
        StartCap = static_cast<GpCustomLineCap*>(Pen->CustomStartCap);
        break;
        
        case LineCapArrowAnchor:
        StartCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        StartCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        StartCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;
        
        case LineCapSquareAnchor:
        StartCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
    
    switch(Pen->EndCap)
    {
        case LineCapCustom:
        EndCap = static_cast<GpCustomLineCap*>(Pen->CustomEndCap);
        break;
        
        case LineCapArrowAnchor:
        EndCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        EndCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        EndCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;

        case LineCapSquareAnchor:
        EndCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
}

GpEndCapCreator::~GpEndCapCreator()
{
    // If we allocated memory for temporary custom caps, then 
    // throw that memory away.
    
    if(Pen->StartCap != LineCapCustom)
    {
        delete StartCap;
        StartCap = NULL;
    }
    
    if(Pen->EndCap != LineCapCustom)
    {
        delete EndCap;
        EndCap = NULL;
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing an ArrowAnchor.
*    This is an equilateral triangle with edge equal to 2. This means
*    that the scaling will create a 2xStrokeWidth cap edge length.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceArrowAnchor()
{
    // the square root of 3
    
    const REAL root3 = 1.732050808f;
    
    // Anti-clockwise definition of an equilateral triangle of side length 2.0f
    // with a vertex on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[3] = {
        GpPointF(0.0f, 0.0f),
        GpPointF(-1.0f, -root3),
        GpPointF(1.0f, -root3)
    };
    
    GpPath arrowAnchor(FillModeWinding);
    arrowAnchor.AddPolygon(points, 3);
    
    // Create the custom line cap. If it fails it will return NULL.
    GpCustomLineCap *cap = new GpCustomLineCap(&arrowAnchor, NULL);
    cap->SetBaseInset(1.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a DiamondAnchor.
*    This is a square centered on the end point of the path with it's 
*    diagonal along the axis of the spine.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceDiamondAnchor()
{
    // Anti-clockwise definition of a square of diagonal size 2.0f
    // with the center on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[4] = {
        GpPointF(0.0f, 1.0f),
        GpPointF(-1.0f, 0.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(1.0f, 0.0f)
    };
    
    GpPath diamondAnchor(FillModeWinding);
    diamondAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&diamondAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a SquareAnchor.
*    This is a square that has a 2 unit long diagonal and is centered on 
*    the end point of the path.
*
* Revision History:
*
*   10/17/2000 peterost
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceSquareAnchor()
{    
    const REAL halfRoot2 = 0.7071068f;
    
    const GpPointF points[4] = {
        GpPointF(-halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, halfRoot2),
        GpPointF(-halfRoot2, halfRoot2)
    };
    
    GpPath squareAnchor(FillModeWinding);
    squareAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&squareAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a RoundAnchor.
*    This is a circle centered on the end point of the path.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceRoundAnchor()
{
    // Create the custom line cap. If it fails it will return NULL.
    
    GpPath roundAnchor(FillModeWinding);
    roundAnchor.AddEllipse(-1.0f, -1.0f, 2.0f, 2.0f);
    GpCustomLineCap *cap = new GpCustomLineCap(&roundAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}


/**************************************************************************\
*
* Function Description:
*
*   ComputeCapGradient.
*
*   Compute the correct gradient for a line cap of a given length.
*   Work out the direction of the cap from the list of input 
*   points in the path and the length of the cap.
*   Simply put, the direction is the line segment formed by 
*   the end point of the path and the first intersection along the 
*   path with a circle of length "length" and centered at the 
*   first point of the path.
*
* Arguments:
*
*    GpIterator<GpPointF> &pointIterator,
*    BYTE *types,
*    IN  REAL lengthSquared,            length of the cap squared.
*    IN  baseInset,                     amount to draw into the shape.
*    OUT GpVector2D *grad,              output gradient vector
*
*
* Revision History:
*
*   08/23/00 asecchia
*       Created it
*
\**************************************************************************/

void GpEndCapCreator::ComputeCapGradient(
    GpIterator<GpPointF> &pointIterator, 
    BYTE *types,
    IN  REAL lengthSquared,
    IN  REAL baseInset,
    OUT GpVector2D *grad
)
{
    // Start at the beginning of the iterator (end of the list of
    // points if isStartCap is FALSE)
    
    GpPointF *endPoint = pointIterator.CurrentItem();
    GpPointF *curPoint = endPoint;
    INT index;
    bool intersectionFound = false;
    bool priorDeletion = false;
    
    while(!pointIterator.IsDone())
    {
        curPoint = pointIterator.CurrentItem();
        if(lengthSquared < distance_squared(*curPoint, *endPoint))
        {
            intersectionFound = true;
            break;
        }
        
        // Mark this point for deletion by the trimming algorithm.
        
        index = pointIterator.CurrentIndex();
        
        // Check to see if anyone already deleted this segment.
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        priorDeletion = (types[index] & PathPointTypeInternalUse) ==
            PathPointTypeInternalUse;
        
        types[index] |= PathPointTypeInternalUse;
        
        pointIterator.Next();
    }
    
    // Now we have the segment that intersects the base of the arrow.
    // or the last segment.
    
    pointIterator.Prev();
    
    // if we couldn't get the Prev, then we were at the beginning.
    #if DBG
    if(pointIterator.IsDone())
    {
        ONCE(WARNING(("not enough points in array")));
    }
    #endif
    
    // If the intersection was not found we have marked the entire subpath
    // for deletion.
    
    if(intersectionFound && !priorDeletion)
    {
        // We overagressively marked this point for deletion,
        // instead of deleting this point, we're going to move it.
        // Note: we may have found an intersection point in a segment
        // that has already been marked for deletion. Checking priorDeletion
        // here ensures that we don't incorrectly undelete this point.
        
        index = pointIterator.CurrentIndex();
        
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        types[index] &= ~PathPointTypeInternalUse;
    }
    
    GpPointF *prevPoint = pointIterator.CurrentItem();
    GpPointF intersectionPoint;
    
    if(!intersect_circle_line(
        *endPoint,           // center
        lengthSquared,       // radius^2
        *curPoint,           // P0
        *prevPoint,          // P1
        &intersectionPoint
    ))
    {
        // If there is no intersection, then the line segment is likely too 
        // short, so just take the previous point as the intersection.
        // This is our best guess and in this case will give us the slope from
        // the start to end point as the cap direction.
        
        intersectionPoint.X = prevPoint->X;
        intersectionPoint.Y = prevPoint->Y;
    }
    
    // Compute the gradient - and normalize the vector.
    
    *grad = intersectionPoint - *endPoint;
    grad->Normalize();
    
    // Update the point in the path directly.
    GpVector2D v = *prevPoint - intersectionPoint;
    
    *prevPoint = intersectionPoint + (v*(1.0f-baseInset));
}

/**************************************************************************\
*
* Function Description:
*
*   This creates a path containing all the custom end caps for all
*   the open subpaths in the input path.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    caps  -- this is where we put the caps we generate
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/
GpStatus
GpEndCapCreator::CreateCapPath(GpPath **caps)
{
    // Validate our input data.
    
    ASSERT(Pen != NULL);
    ASSERT(Path != NULL);
    ASSERT(caps != NULL);
    ASSERT(*caps == NULL);
    
    // Create our cap path.
    
    *caps = new GpPath(FillModeWinding);
    if(caps==NULL) 
    { 
        return OutOfMemory; 
    }
    
    // Create a path points iterator because our GpPath doesn't know how
    // to iterate over its own data *sigh*
    
    GpPathPointIterator pathIterator(
        const_cast<GpPointF*>(Path->GetPathPoints()),
        const_cast<BYTE*>(Path->GetPathTypes()),
        Path->GetPointCount()
    );
    
    GpSubpathIterator subpathIterator(&pathIterator);
    
    // Loop through all the available subpaths.
    
    while(!subpathIterator.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = subpathIterator.CurrentIndex();
        GpPointF *points = subpathIterator.CurrentItem();
        BYTE *types = subpathIterator.CurrentType();
        subpathIterator.Next();
        INT elementCount = subpathIterator.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pathIterator.Prev();
        
        bool isClosed = 
            ((*(pathIterator.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath);
            
        pathIterator.Next();
        
        // only want to add end caps if this is an open subpath.
        
        if(!isClosed)
        {
            GpPath *startCap = NULL;
            GpPath *endCap = NULL;
        
            // Create the cap using the points and types
            
            GetCapsForSubpath(
                &startCap,
                &endCap,                
                points,
                types,
                elementCount
            );
            
            // Add the cap to our caps path.
            
            (*caps)->AddPath(startCap, FALSE);
            (*caps)->AddPath(endCap, FALSE);
            
            // Clean up the temporary caps for the next iteration.
            
            delete startCap;
            delete endCap;
        }
    }
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    This takes a pen and sets it up to match the internal Pen, but modified
*    to support stroking the StrokeCap. E.g. the caps are removed to avoid
*    recursive compound capping etc.
*
* Arguments:
*
*   [OUT]    pen       -- this is where we put the pen we generate
*   [IN]     customCap -- input custom cap.
*
* Created:
*
*   10/09/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

VOID GpEndCapCreator::PrepareDpPenForCustomCap(
    DpPen* pen,
    const GpCustomLineCap* customCap
    ) const
{
    ASSERT(pen);

    *pen = *Pen;
    
    pen->StartCap = LineCapFlat;
    pen->EndCap = LineCapFlat;
    pen->Join = LineJoinMiter;
    pen->MiterLimit = 10;
    pen->PenAlignment = PenAlignmentCenter;
    pen->DashStyle = DashStyleSolid;
    pen->DashCap = LineCapFlat;
    pen->DashCount = 0;
    pen->DashOffset = 0;
    pen->DashArray = NULL;
    pen->CompoundCount = 0;
    pen->CompoundArray = NULL;
    pen->CustomEndCap = NULL;
    pen->CustomStartCap = NULL;

    GpLineCap startCap, endCap;
    GpLineJoin lineJoin;

    if(customCap)
    {
        REAL widthScale;

        customCap->GetStrokeCaps(&startCap, &endCap);
        customCap->GetStrokeJoin(&lineJoin);
        customCap->GetWidthScale(&widthScale);

        pen->Width *= widthScale;
        pen->StartCap = startCap;
        pen->EndCap = endCap;
        pen->Join = lineJoin;
    }
}

GpStatus
GpEndCapCreator::SetCustomFillCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;

    startCapPoints->Reset(FALSE);
    startCapTypes->Reset(FALSE);
    endCapPoints->Reset(FALSE);
    endCapTypes->Reset(FALSE);

    INT count;
    GpPointF tangent;
    GpPointF* points;
    BYTE* types;
    REAL width, widthScale;
    
    // Get minimum line width based on the transform currently in effect.
    REAL majorR, minorR, unitScale;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    unitScale = min(majorR, minorR);

    if(customStartCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customStartCap->GetFillPointCount();
        
        if(count > 0)
        {            
            points = startCapPoints->AddMultiple(count);
            types = startCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                startCapPoints->Reset(FALSE);
                startCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customStartCap->GetWidthScale(&widthScale);
                width = Pen->Width*widthScale;
                
                REAL length = customStartCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customStartCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);

                // Compute the gradient of the cap.
    
                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointIterator,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient           // OUT parameters
                );
                
                tangent.X = -gradient.X;
                tangent.Y = -gradient.Y;

                // Move start point left or right to account for inset
                // pens, if needed.
                GpPointF start;
                switch (Pen->PenAlignment)
                {
                    case PenAlignmentLeft:
                        start.X = startPoint.X + (gradient.Y * width / 2);
                        start.Y = startPoint.Y - (gradient.X * width / 2);
                        break;
                    case PenAlignmentRight:
                        start.X = startPoint.X - (gradient.Y * width / 2);
                        start.Y = startPoint.Y + (gradient.X * width / 2);
                        break;
                    default:
                        start.X = startPoint.X;
                        start.Y = startPoint.Y;
                        break;
                }
                
                customStartCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    start, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }

    if(status == Ok && customEndCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customEndCap->GetFillPointCount();

        if(count > 0)
        {

            points = endCapPoints->AddMultiple(count);
            types = endCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                endCapPoints->Reset(FALSE);
                endCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customEndCap->GetWidthScale(&widthScale);

                width = Pen->Width*widthScale;
                
                REAL length = customEndCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customEndCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);
                
                // Compute the gradient of the cap.

                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                GpReverseIterator<GpPointF> pointReverse(&pointIterator);
                pointReverse.SeekFirst();
    
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointReverse,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient            // OUT parameters
                );
                
                tangent.X = - gradient.X;
                tangent.Y = - gradient.Y;
                
                // Move end point left or right to account for inset
                // pens, if needed.
                GpPointF end;
                switch (Pen->PenAlignment)
                {
                    case PenAlignmentLeft:
                        end.X = endPoint.X - (gradient.Y * width / 2);
                        end.Y = endPoint.Y + (gradient.X * width / 2);
                        break;
                    case PenAlignmentRight:
                        end.X = endPoint.X + (gradient.Y * width / 2);
                        end.Y = endPoint.Y - (gradient.X * width / 2);
                        break;
                    default:
                        end.X = endPoint.X;
                        end.Y = endPoint.Y;
                        break;
                }
                customEndCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    end, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }
    
    return status;
}

GpStatus
GpEndCapCreator::SetCustomStrokeCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;
        
    GpPointF* points = NULL;
    BYTE* types = NULL;

    INT count;
    GpPointF tangent;

    INT startCount = 0;
    INT endCount = 0;

    if(customStartCap)
    {
        startCount = customStartCap->GetStrokePointCount();
    }

    if(customEndCap)
    {
        endCount = customEndCap->GetStrokePointCount();
    }

    INT maxCount = max(startCount, endCount);

    if(maxCount <= 0)
    {
        return Ok;
    }

    points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
    types = (BYTE*) GpMalloc(maxCount);

    if(!points || !types)
    {
        GpFree(points);
        GpFree(types);

        return OutOfMemory;
    }

    DpPen pen;
    GpPointF* widenedPts;
    INT widenedCount;
    REAL widthScale, width;
    

    if(customStartCap && startCount > 0)
    {
        startCapPoints->Reset(FALSE);
        startCapTypes->Reset(FALSE);
        
        customStartCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customStartCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customStartCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointIterator, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameters
        );
        
        tangent.X = -gradient.X;
        tangent.Y = -gradient.Y;

        customStartCap->GetTransformedStrokeCap(
            points, 
            types, 
            startCount,
            startPoint, 
            tangent, 
            width, 
            width   
        );

        PrepareDpPenForCustomCap(&pen, customStartCap);

        GpPath path(points, types, startCount, FillModeWinding);
        
        if(path.IsValid())
        {        
            GpPath resultPath(FillModeWinding);
            GpPathWidener widener(
                &path,
                &pen, 
                &XForm, 
                FALSE
            );
            widener.Widen(&resultPath);
            resultPath.Detach(startCapPoints, startCapTypes);
        }
    }

    if(customEndCap && endCount > 0)
    {
        endCapPoints->Reset(FALSE);
        endCapTypes->Reset(FALSE);
        
        customEndCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customEndCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customEndCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        GpReverseIterator<GpPointF> pointReverse(&pointIterator);
        pointReverse.SeekFirst();
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointReverse, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameter
        );
        
        tangent.X = - gradient.X;
        tangent.Y = - gradient.Y;
        
        customEndCap->GetTransformedStrokeCap(
            points, 
            types, 
            endCount,
            endPoint, 
            tangent, 
            width, 
            width
        );

        PrepareDpPenForCustomCap(&pen, customEndCap);
        
        GpPath path(points, types, endCount, FillModeWinding);
        
        if(path.IsValid())
        {
            GpPath resultPath(FillModeWinding);
            GpPathWidener widener(
                &path,
                &pen, 
                &XForm, 
                FALSE
            );
            widener.Widen(&resultPath);
            resultPath.Detach(endCapPoints, endCapTypes);
       }
    }

    GpFree(points);
    GpFree(types);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   This creates and returns two GpPaths containing the start and end cap.
*   The two caps are correctly positioned and scaled.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    startCapPath, endCapPath
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/

GpStatus
GpEndCapCreator::GetCapsForSubpath(
    GpPath **startCapPath,
    GpPath **endCapPath,
    GpPointF *centerPoints,
    BYTE *centerTypes,
    INT centerCount
    )
{
    // Validate our input parameters.
    
    ASSERT(startCapPath != NULL);
    ASSERT(endCapPath != NULL);
    ASSERT(*startCapPath == NULL);
    ASSERT(*endCapPath == NULL);

    DynPointFArray startCapPoints;
    DynPointFArray endCapPoints;
    DynByteArray startCapTypes;
    DynByteArray endCapTypes; 
    
    GpPointF startPoint, endPoint;

    startPoint = *(centerPoints);
    endPoint = *(centerPoints + centerCount - 1);
    
    GpStatus status = Ok;

    if(StartCap || EndCap)
    {
        status = SetCustomFillCaps(
            StartCap, 
            EndCap,
            startPoint, 
            endPoint, 
            centerPoints,
            centerTypes,
            centerCount,
            &startCapPoints,
            &endCapPoints,
            &startCapTypes,
            &endCapTypes
        );

        if(status == Ok)
        {
            status = SetCustomStrokeCaps(
                StartCap, 
                EndCap,
                startPoint, 
                endPoint, 
                centerPoints,
                centerTypes,
                centerCount,
                &startCapPoints,
                &endCapPoints,
                &startCapTypes,
                &endCapTypes
            );
        }
    }

    if(startCapPoints.GetCount() > 0)
    {
        *startCapPath = new GpPath(
            startCapPoints.GetDataBuffer(),
            startCapTypes.GetDataBuffer(),
            startCapPoints.GetCount()
        );
        
        if(*startCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(endCapPoints.GetCount() > 0)
    {
        *endCapPath = new GpPath(
            endCapPoints.GetDataBuffer(),
            endCapTypes.GetDataBuffer(),
            endCapPoints.GetCount()
        );
        
        if(*endCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(status != Ok)
    {
        delete *startCapPath;
        delete *endCapPath;
        *startCapPath = NULL;
        *endCapPath = NULL;
        status = OutOfMemory;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\dppath.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpPath
*
* Abstract:
*
*   A DDI-level path object. Corresponds to a GpPath object.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPPATH_HPP
#define _DPPATH_HPP

//--------------------------------------------------------------------------
// Represent a path
//--------------------------------------------------------------------------

enum WidenFlags
{
    WidenIsAntiAliased          = 0x00000001,
    WidenDontFlatten            = 0x00000002,
    WidenRemoveSelfIntersects   = 0x00000004,
    WidenEmitDoubleInset        = 0x00000008,  // disable region to path
};

class DpPath : public GpObject
{
public:

    enum DpPathFlags        // !!! Rename and move?
    {
        PossiblyNonConvex   = 0x00,
        Convex              = 0x01,
        ConvexRectangle     = 0x03      // Used for Rectangle and Oval.
    };

    ~DpPath() {}

    // Start/end a subpath

    virtual VOID StartFigure()
    {
        IsSubpathActive = FALSE;
        UpdateUid();
    }

    virtual GpStatus CloseFigure();
    virtual GpStatus CloseFigures();

    BOOL HasCurve() const
    {
        return HasBezier;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPath);
    }

    BOOL IsConvex() const
    {
        return ((Flags & Convex) != 0);
    }

    INT GetSubpathCount() const
    {
        return SubpathCount;
    }

    virtual GpStatus Flatten(
                DynByteArray* flattenTypes,
                DynPointFArray* flattenPoints,
                const GpMatrix* matrix) const = 0;

    virtual const DpPath*
    GetFlattenedPath(
        GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL,
        BOOL isAntiAliased = TRUE,
        REAL dpiX = 0,
        REAL dpiY = 0,
        BOOL regionToPath = TRUE
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    
    VOID
    Offset(
        REAL dx,
        REAL dy
        );

    GpFillMode GetFillMode() const
    {
        return FillMode;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        if (FillMode != fillMode)
        {
            FillMode = fillMode;
            UpdateUid();
        }
    }

    // Get path data

    INT GetPointCount() const
    {
        return Points.GetCount();
    }

    const GpPointF* GetPathPoints() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Points.GetDataBuffer();
    }

    const BYTE* GetPathTypes() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Types.GetDataBuffer();
    }

    static BOOL
    ValidatePathTypes(
        const BYTE* types,
        INT count,
        INT* subpathCount,
        BOOL* hasBezier
        );

    GpStatus GetPathData(GpPathData* pathData);

    GpStatus SetPathData(const GpPathData* pathData);

    virtual ObjectType GetObjectType() const { return ObjectTypePath; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual DpPath*
    CreateWidenedPath(
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect = FALSE,
        BOOL regionToPath = TRUE
        ) const
    {
        return DpcCreateWidenedPath(
            this, 
            pen, 
            context, 
            removeSelfIntersect,
            regionToPath
        );
    }

    virtual VOID
    DeletePath()
    {
        DpcDeletePath(this);
    }

    virtual DpPath*
    ClonePath()
    {
        return DpcClonePath(this);
    }

    virtual VOID
    Transform(
        GpMatrix* matrix
    )
    {
        DpcTransformPath(this, matrix);
    }
    
    // Debug only.
    
    #if DBG
    void DpPath::DisplayPath() {
        INT size = GetPointCount();
    
        const GpPointF *points = GetPathPoints();
        const BYTE *types = GetPathTypes();
    
        for(int i=0; i<size; i++)
        {
            if((types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                WARNING(("Move"));
            }
            if(types[i] & PathPointTypeCloseSubpath)
            {
                WARNING(("Close"));
            }
            WARNING(("points[%d].X = %ff;", i, points[i].X));
            WARNING(("points[%d].Y = %ff;", i, points[i].Y));
        }
    }
    #endif
    
    class SubpathInfo
    {
    public:
        INT StartIndex;
        INT Count;
        BOOL IsClosed;
    };

protected: // GDI+ INTERNAL

    DpPath()
    {
        InitDefaultState(FillModeAlternate);
        SetValid(TRUE);
    }

    DpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    DpPath(const DpPath *path);

    virtual VOID InitDefaultState(GpFillMode fillMode);

    virtual VOID GetSubpathInformation(
        DynArray<SubpathInfo> **info
    ) const = 0;

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPath : ObjectTagInvalid);
    }

protected:

    BOOL HasBezier;         // does path have Bezier segments?
    DynArrayIA<BYTE, 16> Types;
    DynArrayIA<GpPointF, 16> Points;
    GpFillMode FillMode;
    DpPathFlags Flags;
    BOOL IsSubpathActive;   // whether there is an active subpath
    INT SubpathCount;       // number of subpaths
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\flatddi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatddi.cpp
*
* Abstract:
*
*   Flat GDI+ DDI API wrappers
*
* Revision History:
*
*   1/14/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

DpPath*
WINGDIPAPI
DpcCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen, 
    DpContext* context,
    BOOL removeSelfIntersect,
    BOOL regionToPath
    )
{
    ASSERT(path && pen);
    
    // context can be NULL
    return GpPath::DriverCreateWidenedPath(
        path, 
        pen, 
        context, 
        removeSelfIntersect,
        regionToPath
    );
}

VOID
WINGDIPAPI
DpcDeletePath(
    DpPath* path
    )
{
    ASSERT(path);
    
    GpPath::DriverDeletePath(path);
}

DpPath*
WINGDIPAPI
DpcClonePath(
    DpPath* path
    )
{
    ASSERT(path);

    return GpPath::DriverClonePath(path);
}

VOID
WINGDIPAPI
DpcTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    ASSERT(path);   // matrix can be NULL.

    GpPath::DriverTransformPath(path, matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\geometry.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GEOMETRY_HPP
#define _GEOMETRY_HPP


// return the square of the distance between point 1 and point 2.

inline REAL distance_squared(const GpPointF &p1, const GpPointF &p2)
{
    return ((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y));
}

// return the dot product of two points treated as 2-vectors.

inline double dot_product(const GpPointF &a, const GpPointF &b)
{
    return (a.X*b.X + a.Y*b.Y);
}

// Return the intersection of a line specified by p0-p1 along the
// y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
// Only returns intersections between p0 and p1 (inclusive).

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
);

// Return the intersection of a line p0-p1 with the line r0-r1
// The return value

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
);


INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
);

// Return true if point is inside the polygon defined by poly and count.
// Use the FillModeAlternate (even-odd) rule.

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
);

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector);


class GpVector2D : public GpPointF
{
    public:
    GpVector2D()
    {
        X = Y = 0.0f;
    }

    GpVector2D(IN const PointF &point)
    {
        X = point.X;
        Y = point.Y;
    } 
    
    GpVector2D(IN const GpVector2D &vec)
    {
        X = vec.X;
        Y = vec.Y;
    } 

    GpVector2D(IN REAL x, IN REAL y)
    {
        X = x;
        Y = y;
    }

    // Scale.
    
    GpVector2D operator*(REAL k)
    {
        return GpVector2D(X*k, Y*k);
    }
    
    // Dot Product
    
    REAL operator*(IN const GpVector2D &V)
    {
        return (X*V.X+Y*V.Y);
    }
    
   
    VOID operator+=(IN const GpVector2D &V)
    {
        X += V.X;
        Y += V.Y;
    } 
    
    VOID operator-=(IN const GpVector2D &V)
    {
        X -= V.X;
        Y -= V.Y;
    } 
        
    VOID operator*=(IN const REAL k)
    {
        X *= k;
        Y *= k;
    } 

    // Length or Vector Norm of the Vector.
    
    REAL Norm()
    {
        double length = (double)X*X+(double)Y*Y;
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            return 0.0f;
        }
        else
        {
            return (REAL)length;
        }
    }
    
    // Unitize the vector. If it is degenerate, return 0.0f
    
    REAL Normalize()
    {
        double length = (double)X*X+(double)Y*Y;
        
        if( length < 0.0 )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        else
        {
            X /= (REAL)length;
            Y /= (REAL)length;
            return (REAL)length;
        }
    }
    
    friend REAL Determinant(GpVector2D &a, GpVector2D &b);
};
    
inline REAL Determinant(GpVector2D &a, GpVector2D &b)
{
    return (a.X*b.Y-a.Y*b.X);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\path.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
*   06/16/1999 t-wehunt
*       Added RemoveSelfIntersections().
*
\**************************************************************************/

#ifndef _PATH_HPP
#define _PATH_HPP

// This is used by the widener as an internal flag and as a deletion mask for
// the endcap placement code. These two usages do not overlap.

const INT PathPointTypeInternalUse  = 0x40;

/*
// PathPointType is defined in GdiplusEnums.h.
// Internally, we can use 0x40 for the internal use.

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};
*/

class GpGlyphPath;

inline BOOL IsStartType(BYTE type)
{
    return ((type & PathPointTypePathTypeMask) == 
               PathPointTypeStart);
}

inline BOOL IsClosedType(BYTE type)
{
    return ((type & PathPointTypeCloseSubpath) == 
               PathPointTypeCloseSubpath);
}

inline BOOL IsDashType(BYTE type)
{
    return ((type & PathPointTypeDashMode) == 
               PathPointTypeDashMode);
}

class GpPath : public DpPath
{
friend class GpGraphics;
friend class GpPathGradient;

public:

    // Path constructors

    GpPath(GpFillMode fillMode = FillModeAlternate)
    {
        InitDefaultState(fillMode);
        SetValid(TRUE);
    }

    GpPath(const GpPointF* points,
           const BYTE* types,
           INT count,
           GpFillMode fillMode = FillModeAlternate);

    GpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    GpPath(HRGN hRgn);              // create a path from a GDI region handle
    GpPath(const DpRegion* region); // create a path from a GDI+ region

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    GpPath* Clone() const
    {
        ASSERT(IsValid())

        GpPath* path = new GpPath(this);

        CheckValid(path);
        return path;
    }

    GpStatus Detach(DynPointFArray *points, DynByteArray *types)
    {
        points->ReplaceWith(&Points);
        types->ReplaceWith(&Types);

        InitDefaultState(FillMode);
        return Ok;
    }

    
    GpStatus Reset(GpFillMode fillMode = FillModeAlternate)
    {

        // !!! bhouse We should allow reseting invalid paths

        ASSERT(IsValid());

        InitDefaultState(fillMode);
        return Ok;
    }

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    REAL GetSharpestAngle() const
    {

        if(!(CacheFlags & kSharpestAngleValid))
            CalcSharpestAngle();

        return SharpestAngle;
    }

    // Set a marker at the current location.

    GpStatus SetMarker();

    // Clear all markers.

    GpStatus ClearMarkers();

    // Add lines to the path object

    GpStatus AddLine(const GpPointF& pt1, const GpPointF& pt2)
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return AddLines(points, 2);
    }

    GpStatus AddLine(REAL x1, REAL y1, REAL x2, REAL y2)
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return AddLines(points, 2);
    }

    GpStatus AddLines(const GpPointF* points, INT count);

    // Add an arc to the path object

    GpStatus AddArc(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddArc(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddArc(rect, startAngle, sweepAngle);
    }

    // Add Bezier curves to the path object

    GpStatus AddBezier(const GpPointF& pt1, const GpPointF& pt2,
                       const GpPointF& pt3, const GpPointF& pt4);
    GpStatus AddBezier(REAL x1, REAL y1, REAL x2, REAL y2,
                       REAL x3, REAL y3, REAL x4, REAL y4);
    GpStatus AddBeziers(const GpPointF* points, INT count);

    // Add cardinal splines to the path object

    GpStatus AddCurve(const GpPointF* points, INT count);
    GpStatus AddCurve(const GpPointF* points, INT count, REAL tension,
                      INT offset, INT numberOfSegments);
    GpStatus AddClosedCurve(const GpPointF* points, INT count);
    GpStatus AddClosedCurve(const GpPointF* points, INT count, REAL tension);

    // Add closed shapes to the path object

    GpStatus AddRects(const GpRectF* rects, INT count);
    GpStatus AddRects(const RECT* rects, INT count);
    GpStatus AddPolygon(const GpPointF* points, INT count);
    GpStatus AddEllipse(const GpRectF& rect);
    GpStatus AddPie(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddRect(const GpRectF& rect)
    {
        return AddRects(&rect, 1);
    }

    GpStatus AddEllipse(REAL x, REAL y, REAL width, REAL height)
    {
        GpRectF rect(x, y, width, height);
        return AddEllipse(rect);
    }

    GpStatus AddPie(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddPie(rect, startAngle, sweepAngle);
    }

    // Add a path to the path object

    GpStatus AddPath(const GpPointF* points, const BYTE* types, INT count,
                        BOOL connect);
    GpStatus AddPath(const GpPath* path, BOOL connect);

    // Reverse the direction of a path.

    GpStatus Reverse();

    GpStatus GetLastPoint(GpPointF* point);


    // Used by the widener.
    
    GpStatus AddWidenPoint(const GpPointF &point);

    // used by font

    GpStatus MoveTo(const GpPointF point);
    GpStatus AddPoints(const GpPointF* points, ULONG count, PathPointType type);
    GpStatus AddGlyphPath(GpGlyphPath *glyphPath, REAL x, REAL y, const GpMatrix * matrix = 0);

    GpStatus AddString(
        const WCHAR          *string,
        INT                   length,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  emSize,
        const RectF          *layoutRect,
        const GpStringFormat *format
    );

    // Get the flatten data.

    virtual GpStatus Flatten(
                DynByteArray* flattenTypes,
                DynPointFArray* flattenPoints,
                const GpMatrix* matrix) const;


    // Flatten this path.
    
    GpStatus Flatten(GpMatrix* matrix = NULL);

    // Get the morph and flatten data.

    GpStatus WarpAndFlatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );

    // Morph and flatten itself.

    GpStatus WarpAndFlattenSelf(
        GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );                  // Morph to the flatten points.

    // Widen the path object

    GpPath*
    GetWidenedPath(
        const GpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
        ) const;

    GpStatus
    WidenSelf(
        GpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
        );

    // Get the flattened path.

    virtual const DpPath *
    GetFlattenedPath(
        GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL,
        BOOL isAntiAliased = TRUE,
        REAL dpiX = 0,
        REAL dpiY = 0,
        BOOL regionToPath = TRUE
        ) const;

    // Dreate a dashed path. (override)

    GpPath*
    CreateDashedPath(
        const GpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f
        ) const;

    GpPath*
    CreateDashedPath(
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f
        ) const;

    // Get the open and closed portion of the current path.

    GpPath* GetOpenPath();
    GpPath* GetClosedPath();

    // Determine if the path is empty, i.e. with no points

    BOOL IsEmpty() const
    {
        return GetPointCount() == 0;
    }

    BOOL IsRectangle() const;

    // Determine if path consists of a single polygon/polyline.

    BOOL IsPolygon() const
    {
        return (SubpathCount == 1) && !HasBezier;
    }

    // Return true if the two objects represent identical paths

    BOOL IsEqual(const GpPath* path) const;

    // Transform the path by the specified matrix

    VOID Transform(GpMatrix * matrix);

    VOID SetHasBezier(BOOL _hasBezier)  { HasBezier = _hasBezier; }

    // Hit testing

    GpStatus IsVisible(
        GpPointF* point,
        BOOL* isVisible,
        GpMatrix* matrix = NULL);

    GpStatus IsOutlineVisible(GpPointF* point, BOOL* isVisible, GpPen* pen,
                    GpMatrix* matrix = NULL, REAL dpiX = 0, REAL dpiY = 0);

// This code is not used at present and is contributing to our DLL size, so 
// it's removed from compilation. We're keeping this code because we want to 
// revisit it in V2

#if 0
    // Path reconstruction

    GpPath*
    GetCombinedPath(const GpPath* path, CombineMode combineMode,
        BOOL closeAllSubpaths = FALSE);
#endif

    // DDI entry point handlers for DpPath

    static GpPath* GetPath(const DpPath* path)
    {
        return (GpPath*)(path);
    }

    static DpPath* DriverCreateWidenedPath(
        const DpPath* path,
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect,
        BOOL regionToPath
    );
    
    static VOID DriverDeletePath(DpPath* path);

    static DpPath* DriverClonePath(DpPath* path);

    static VOID DriverTransformPath(DpPath* path, GpMatrix* matrix);

    // Remove self intersections from the path.
    GpStatus RemoveSelfIntersections();
    
    // Used for a mark-sweep point deletion algorithm in the path.
    
    VOID EraseMarkedSegments();
    
    virtual VOID GetSubpathInformation(DynArray<SubpathInfo> **info) const;

protected:

    VOID ComputeSubpathInformationCache() const;

    GpPath(const GpPath* path);

    GpPath* GetWidenedPathWithDpPen(
        const DpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
    ) const;

    GpPath* GetWidenedPathWithDpPenStandard(
        const DpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased,
        BOOL insetPen = FALSE
    ) const;

    BYTE*
    AddPointHelper(
        const GpPointF* points,
        INT count,
        BOOL addClosedFigure
        );

    GpPath*
    GetOpenOrClosedPath(BOOL openPath);

    static GpPointF*
    ConvertSplineToBezierPoints(
        const GpPointF* points,
        INT count,
        INT offset,
        INT numberOfSegments,
        REAL tension,
        INT* bezierCount
        );

    static INT
    GetArcPoints(
        GpPointF* points,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    VOID InitDefaultState(GpFillMode fillMode);

    VOID ResetCacheBounds() const
    {
        CacheFlags = (kCacheBoundsValid | kSharpestAngleValid);
        SharpestAngle = 2;
        CacheBounds.X = 0;
        CacheBounds.Y = 0;
        CacheBounds.Width = 0;
        CacheBounds.Height = 0;
    }

    VOID InvalidateCache() const
    {
        CacheFlags = 0;
    }

    VOID UpdateCacheBounds() const
    {
        if(!(CacheFlags & kCacheBoundsValid))
            CalcCacheBounds();
    }

    VOID CalcCacheBounds() const;
    VOID CalcSharpestAngle() const;

    VOID
    AdjustDashArrayForCaps(
        GpLineCap dashCap,
        REAL dashUnit,
        REAL *dashArray,
        INT dashCount
        ) const;

    REAL
    GetDashCapInsetLength(
        GpLineCap dashCap,
        REAL dashUnit
        ) const;


    // Data Members:
    protected:

    GpLockable Lockable;    // object lock

    enum {
        kCacheBoundsValid = 1,
        kSharpestAngleValid = 2,
        kSubpathInfoValid = 4
    };

    mutable ULONG CacheFlags;
    mutable GpRectF CacheBounds;
    mutable REAL SharpestAngle;
    
    mutable DynArrayIA<SubpathInfo, 16> SubpathInfoCache;
};

class GpPathIterator : public DpPathIterator
{
public:
    GpPathIterator(GpPath* path) : DpPathIterator(path)
    {
    }

    virtual INT GetCount()
    {
        if(IsValid())
            return Count;
        else
            return 0;
    }

    virtual INT GetSubpathCount()
    {
        if(IsValid())
            return SubpathCount;
        else
            return 0;
    }

    // This iterator is not used for the extended path.

    virtual BOOL IsValid() {return (DpPathIterator::IsValid() && !ExtendedPath);}

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

protected:

    GpLockable Lockable;
};

#endif // !_PATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\pathwidener.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.cpp
*
* Abstract:
*
*   Implementation of the GpPathWidener class
*
* Revision History:
*
*   11/23/99 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"

// 4*(REALSQRT(2.0) - 1)/3
#define U_CIR ((REAL)(0.552284749))

GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );


/**************************************************************************\
*
* Function Description:
*
*   This calculates the major and minor radius of an oval
*   when the unit cricle is transformed by the given matrix.
*   For further details, see ikkof's notes on Pen Transform.
*
* Arguments:
*
*   [OUT] majorR - the major radius.
*   [OUT] minorR - the minor radius.
*   [IN] matrix - the matrix to transform the unit circle.
*
* Return Value:
*
*   Status
*
*   01/28/00 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GetMajorAndMinorAxis(REAL* majorR, REAL* minorR, const GpMatrix* matrix)
{
    if(matrix == NULL)
    {
        // Regard this as an identity matrix.
        *majorR = 1;
        *minorR = 1;
        return Ok;
    }

    REAL m11 = matrix->GetM11();
    REAL m12 = matrix->GetM12();
    REAL m21 = matrix->GetM21();
    REAL m22 = matrix->GetM22();

    REAL d1 = ((m11*m11 + m12*m12) - (m21*m21 + m22*m22))/2;
    REAL d2 = m11*m21 + m12*m22;
    REAL D = d1*d1 + d2*d2;
    if(D > 0)
        D = REALSQRT(D);

    REAL r0 = (m11*m11 + m12*m12 + m21*m21 + m22*m22)/2;

    REAL r1 = REALSQRT(r0 + D);
    REAL r2 = REALSQRT(r0 - D);
    
    // They should be positive numbers.  Prevent the floating
    // point underflow.

    if(r1 <= CPLX_EPSILON)
        r1 = CPLX_EPSILON;
    if(r2 <= CPLX_EPSILON)
        r2 = CPLX_EPSILON;

    *majorR = r1;
    *minorR = r2;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for the GpPathWidener.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpPathWidener::GpPathWidener(
    GpPath *path,
    const DpPen* pen,
    GpMatrix *matrix,
    BOOL doubleCaps
    )
{
    // Must call flatten with an appropriate flatten tolerance before widening.
    
    ASSERT(!path->HasCurve());
    
    Path = path;
    Pen = pen;
    DoubleCaps = doubleCaps && Pen->CompoundCount == 0;
    StrokeWidth = Pen->Width;

    // Set to identity.
    
    XForm.Reset();
    
    if(matrix)
    {
        XForm = *matrix;    // Otherwise XForm remains Identity.
    }

    // Apply the pen transform too.
    
    if(!(Pen->Xform.IsIdentity()))
    {
        XForm.Prepend(Pen->Xform);
    }
    
    // Compute the unit scale.
    
    REAL majorR, minorR;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    REAL unitScale = min(majorR, minorR);

    // Set minimum width to 1.0 (plus a bit for possible precision errors), 
    // so that narrow width pens don't end up leaving gaps in the line.
    // This is the minimum allowable width in device pixels
    
    REAL minDeviceWidth = 1.000001f; 
    
    if(DoubleCaps)
    {
        // Double Caps require wider minimum pens.
        
        minDeviceWidth *= 2.0f;
        
        // Dashes smaller than a pixel are dropping out entirely in inset 
        // pen because of the rasterizer pixel level clipping that is taking
        // place. We increase the minimum width of dashed lines making them
        // roughly 4.0f. This also helps address the weird moire aliasing 
        // effects with the really small dash-dot round lines.
        
        if(Pen->DashStyle != DashStyleSolid)
        {
            minDeviceWidth *= 2.0f;
        }
    }
    
    REAL minWorldWidth = minDeviceWidth/unitScale;
    
    // StrokeWidth is in World coordinates - compare against the minimum
    // world stroke width.
    
    if(StrokeWidth < minWorldWidth)
    {
        StrokeWidth = minWorldWidth;
    }
    
    SetValid(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the Normal vectors for a single subpath. It reuses the 
*   normalArray input DynArray's memory allocation for the values.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID GpPathWidener::ComputeSubpathNormals(
    DynArray<GpVector2D> *normalArray,
    const INT count,
    const BOOL isClosed,
    const GpPointF *points
)
{
    // parameter validation.
    
    ASSERT(points != NULL);
    ASSERT(normalArray != NULL);
    
    // Set the count to zero, but don't free the memory.
    // Then update the count to store enough normals for this subpath, and
    // allocate the memory if required.
    
    normalArray->Reset(FALSE);
    GpVector2D *normals = normalArray->AddMultiple(count);
    
    // Allocation failure or no points.
    
    if(normals == NULL)
    {
        return;
    }
    
    // For each point in the subpath
    // Compute the normal at this point.
    
    INT ptIndex;
    for(ptIndex = 0; ptIndex < count; ptIndex++)
    {
        // Work out the previous point relative to ptIndex
        
        INT ptIndexPrev = ptIndex-1;
        
        // If this is the first point, we need to decide how to process 
        // previous based on the closed status of the path. If it's closed,
        // wrap, otherwise the normal at the first point is meaningless.
        
        if(ptIndexPrev < 0)
        {
            if(isClosed)
            {
                ptIndexPrev = count-1;
            }
            else
            {
                ptIndexPrev = 0;
            }
        }
        
        // Compute the normal at this point by looking at this point and
        // the previous one.
        
        normals[ptIndex] = 
            points[ptIndex]-
            points[ptIndexPrev];
        
        ASSERT(
            ptIndexPrev==ptIndex ||
            REALABS(normals[ptIndex].X) > REAL_EPSILON ||
            REALABS(normals[ptIndex].Y) > REAL_EPSILON
        );
            
        normals[ptIndex].Normalize();
        REAL tmp = normals[ptIndex].X;
        normals[ptIndex].X = normals[ptIndex].Y;
        normals[ptIndex].Y = -tmp;
    }
    
    // Apply the pen transform if there is one.
    
    if(!Pen->Xform.IsIdentity())
    {
        Pen->Xform.VectorTransform(normals, count);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the List of non-degenerate points for a single subpath. It reuses
*   the filteredPoints input DynArray's memory allocation for the values.
*
* History:
*
*   10/23/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus GpPathWidener::ComputeNonDegeneratePoints(
    DynArray<GpPointF> *filteredPoints,
    const GpPath::SubpathInfo &subpath,
    const GpPointF *points
)
{
    // parameter validation.
    
    ASSERT(points != NULL);
    ASSERT(filteredPoints != NULL);
    
    // Set the count to zero, but don't free the memory.
    // Then update the count to store enough normals for this subpath, and
    // allocate the memory if required.
    
    filteredPoints->Reset(FALSE);
    
    // nothing to do.
    
    if(subpath.Count == 0)
    {
        return Ok;
    }
    
    // For each point in the subpath decide if we add the point.
    
    const GpPointF *lastPoint = points + subpath.StartIndex;
    if(filteredPoints->Add(points[subpath.StartIndex]) != Ok)
    {
        return OutOfMemory;
    }
    
    INT ptIndex;
    for(ptIndex = subpath.StartIndex+1; 
        ptIndex < subpath.StartIndex+subpath.Count; 
        ptIndex++)
    {
        // !!! we should be using the flattening tolerance for this
        // instead of REAL_EPSILON - it would be much more efficient.
        
        if( REALABS(lastPoint->X-points[ptIndex].X) > REAL_EPSILON ||
            REALABS(lastPoint->Y-points[ptIndex].Y) > REAL_EPSILON )
        {
            if(filteredPoints->Add(points[ptIndex]) != Ok)
            {
                return OutOfMemory;
            }
        }
        
        lastPoint = points + ptIndex;
    }
    
    if(filteredPoints->GetCount() <= 1)
    {
        // If everything degenerated, erase the first point too.
        
        filteredPoints->Reset(FALSE);
    }
    return Ok;
}

/**************************************************************************\
*
* Description:
*
*   Function Pointer to a Join function.
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

typedef VOID (*JoinProc)(
    const GpVector2D &,
    const GpVector2D &,
    const GpPointF &,
    const REAL ,
    GpPath *
);

/**************************************************************************\
*
* Function Description:
*
*   Performs an inside join on the input normals and point. The resulting 
*   join point - if any - is added to the path.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID InsideJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const GpPointF &ptCurr,
    const GpPointF &ptNext,
    GpPath *path
)
{
    // Inside join.
    
    REAL t1, t2;          // parametric line lengths for the intersection.                
    GpPointF ptJoin;
    
    if( IntersectLines(
        ptStart + normalCurr,
        ptCurr + normalCurr,
        ptStart + normalNext,
        ptNext + normalNext,
        &t1, &t2, 
        &ptJoin ))
    {
        if( (t1 > (REAL_EPSILON)) &&
            (t2 > (REAL_EPSILON)) &&
            ((t1-1.0f) < (-REAL_EPSILON)) &&
            ((t2-1.0f) < (-REAL_EPSILON)) )
        {
            path->AddWidenPoint(ptJoin);
        } 
        else
        {
            // intersection outside of legal range of the two edge pieces.
            // Add the icky backward loopy thing. If the caller really needs
            // no loops it needs to call the PathSelfIntersectRemover.
            
            path->AddWidenPoint(ptStart+normalCurr);
            path->AddWidenPoint(ptStart+normalNext);
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a bevel join
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID BevelJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    // Outside Bevel Join. Simply join the end points of the two input normals.
    
    path->AddWidenPoint(ptStart + normalCurr);
    path->AddWidenPoint(ptStart + normalNext);
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a miter join. 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID MiterJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    GpVector2D gradCurr;         // current gradient reversed.
    gradCurr.X = normalCurr.Y;
    gradCurr.Y = -normalCurr.X;
    
    GpVector2D gradNext;         // next gradient.
    gradNext.X = -normalNext.Y;
    gradNext.Y = normalNext.X;
    
    REAL t1, t2;                 // temporary variables.
    GpPointF ptJoin;
    
    // If there is an intersection point and that intersection point is
    // closer to ptStart than the miter limit, then add the miter join
    // point. Otherwise revert to a bevel join.
    
    if( IntersectLines(
        ptStart + normalCurr,
        ptStart + normalCurr + gradCurr,
        ptStart + normalNext,
        ptStart + normalNext + gradNext,
        &t1, &t2, 
        &ptJoin )
        
        &&
    
        // this won't get evaluated if IntersectLines fails.    
        (distance_squared(ptStart, ptJoin) <= (limit*limit))
    )
    {
        path->AddWidenPoint(ptJoin);
    }
    else
    {
        BevelJoin(normalCurr, normalNext, ptStart, limit, path);
    }
}



/**************************************************************************\
*
* Function Description:
*
*   Performs a miter join. 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID RoundJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    // !!! [asecchia] this is a really awful way of adding a round join.
    // we should change this to compute the control points directly or 
    // even better - add a useful 'CurveTo' method on the path.
    
    REAL radius = const_cast<GpVector2D&>(normalCurr).Norm();
    
    GpRectF rect(
        ptStart.X-radius, 
        ptStart.Y-radius, 
        2.0f*radius, 
        2.0f*radius
    );
    
    REAL startAngle = (REAL)atan2(normalCurr.Y, normalCurr.X);
    if(startAngle < 0.0f)
    {
        startAngle += (REAL)(2.0*M_PI);
    }
    
    REAL sweepAngle = (REAL)atan2(normalNext.Y, normalNext.X);
    if(sweepAngle < 0.0f)
    {
        sweepAngle += (REAL)(2.0*M_PI);
    }
    
    sweepAngle -= startAngle;
    
    if(sweepAngle > (REAL)M_PI)
    {
        sweepAngle -= (REAL)(2.0*M_PI);
    }
    
    if(sweepAngle < (REAL)-M_PI)
    {
        sweepAngle += (REAL)(2.0*M_PI);
    }
    
    // Why doesn't this thing use radians??
    
    startAngle = startAngle*180.0f/(REAL)M_PI;
    sweepAngle = sweepAngle*180.0f/(REAL)M_PI;
    
    // This is a really, really inconvenient AddArc interface!
    
    path->AddArc(rect, startAngle, sweepAngle);
}

/**************************************************************************\
*
* Description:
*
*   Function Pointer to a Join function.
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

typedef VOID (*CapProc)(
    const GpPointF &,
    const GpPointF &,
    GpPath *
);

/**************************************************************************\
*
* Function Description:
*
*   Performs a Flat Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID FlatCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
)
{
    // Cap the open segment.
    
    path->AddWidenPoint(ptLeft);
    path->AddWidenPoint(ptRight);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Flat Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID TriangleCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
)
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    // Cap the open segment.
    
    path->AddWidenPoint(ptLeft);
    
    GpVector2D V = ptRight-ptLeft;
    V *= 0.5;
    
    REAL tmp = V.X;
    V.X = V.Y;
    V.Y = -tmp;
    
    path->AddWidenPoint(V+center);
    path->AddWidenPoint(ptRight);
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a Round Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID RoundCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    // Vector from left to right. We scale by 0.5 to optimize the rotation
    // code below.
    
    GpVector2D V = ptRight-ptLeft;
    V *= 0.5f;
    
    // 2 Bezier segments for a half circle with radius 1.

    static const GpPointF capPoints[7] = {
        GpPointF(-1.0f, 0.0f),
        GpPointF(-1.0f, -U_CIR),
        GpPointF(-U_CIR, -1.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(U_CIR, -1.0f),
        GpPointF(1.0f, -U_CIR),
        GpPointF(1.0f, 0.0f)
    };
    
    
    GpPointF points[7];
    
    // Rotate, scale, and translate the original half circle to the actual 
    // end points we passed in.

    for(INT i = 0; i < 7; i++)
    {
        points[i].X = capPoints[i].X*V.X-capPoints[i].Y*V.Y+center.X;
        points[i].Y = capPoints[i].X*V.Y+capPoints[i].Y*V.X+center.Y;
    }
    
    // !!! the performance of this routine sux. We should be able to add
    // the points into the path directly.
    
    path->AddBeziers(points, 7);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Double Round 'B'-shaped Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID DoubleRoundCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    
    RoundCap(ptLeft, center, path);
    RoundCap(center, ptRight, path);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Double Triangle Cap 
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID DoubleTriangleCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    TriangleCap(ptLeft, center, path);
    TriangleCap(center, ptRight, path);
}



/**************************************************************************\
*
* Function Description:
*
*   Return a CapProc function for the given lineCap and DoubleCaps 
*
* History:
*
*   10/23/2000 asecchia
*       Created.
*
\**************************************************************************/

CapProc GetCapProc(GpLineCap lineCap, BOOL DoubleCaps)
{
    switch(lineCap)
    {
        case LineCapFlat:
        return FlatCap;
        
        case LineCapRound:
        if(DoubleCaps)
        {
            return DoubleRoundCap;
        }
        else
        {
            return RoundCap;
        }
        
        case LineCapTriangle:
        if(DoubleCaps)
        {
            return DoubleTriangleCap;
        }
        else
        {
            return TriangleCap;  
        }
        
        default:
    
        // Invalid cap type for the widener. Use Flat. This will happen for
        // Anchor caps and Custom caps which are handled at a higher level.
        // See GpEndCapCreator.
        
        return FlatCap;
    };
}



/**************************************************************************\
*
* Function Description:
*
*   Takes a (usually empty) path and widens the current spine path into it.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus
GpPathWidener::Widen(GpPath *path)
{
    // Can't widen the current path into itself for performance reasons.
    // We'd have to query the path points array every time we added a point.
    
    ASSERT(Path != path);
    
    // Normal array
    
    DynArray<GpVector2D> normalArray;
    DynArray<GpPointF> spinePoints;
    
    // Initialize the subpath information.
    
    DynArray<GpPath::SubpathInfo> *subpathInfo;
    Path->GetSubpathInformation(&subpathInfo);
    
    // Initialize the pointers to the original path data.
    
    const GpPointF *originalPoints = Path->GetPathPoints();
    const BYTE *originalTypes = Path->GetPathTypes();
    
    
    // Initialize the Join function.
    
    JoinProc join;
    
    switch(Pen->Join)
    {
        case LineJoinMiter:
        join = MiterJoin;
        break;
        
        case LineJoinBevel:
        join = BevelJoin;
        break;
        
        case LineJoinRound:
        join = RoundJoin;  
        break;
        
        default:
        // Invalid join type. Use Bevel, but fire an ASSERT to make developers
        // fix this code if they added a Join type.
        
        ONCE(WARNING(("Invalid Join type selected. Defaulting to Bevel")));
        join = BevelJoin;
    };
    
    // Initialize the various cap functions.
    
    CapProc startCap = GetCapProc(Pen->StartCap, DoubleCaps);
    CapProc endCap = GetCapProc(Pen->EndCap, DoubleCaps);
    
    if(Pen->StartCap == LineCapCustom)
    {
        ASSERT(Pen->CustomStartCap);
        GpLineCap tempCap;
        Pen->CustomStartCap->GetBaseCap(&tempCap);
        startCap = GetCapProc(tempCap, DoubleCaps);
    }
    
    if(Pen->EndCap == LineCapCustom)
    {
        ASSERT(Pen->CustomEndCap);
        GpLineCap tempCap;
        Pen->CustomEndCap->GetBaseCap(&tempCap);
        endCap = GetCapProc(tempCap, DoubleCaps);
    }
    
    CapProc dashCap = GetCapProc(Pen->DashCap, DoubleCaps);
    

    // Initialize the compound line data.
        
    ASSERT(Pen->CompoundCount >= 0);
    
    INT compoundCount = Pen->CompoundCount;
    
    if(compoundCount==0)
    {
        compoundCount = 2;
    }
    
    REAL penAlignmentOffset;
    
    switch(Pen->PenAlignment)
    {
        case PenAlignmentLeft:
        penAlignmentOffset = StrokeWidth/2.0f;
        break;
        
        case PenAlignmentRight:
        penAlignmentOffset = -StrokeWidth/2.0f;
        break;
        
        default:
        // Center pen only - handle inset pen at a much higher level.
        
        ASSERT(Pen->PenAlignment == PenAlignmentCenter);
        penAlignmentOffset=0.0f;
    };



    
    // Done initialization, start processing each subpath.
    
    for(INT currentSubpath = 0; 
        currentSubpath < subpathInfo->GetCount(); 
        currentSubpath++)
    {
        // Figure out the subpath record and Normal information.
        
        GpPath::SubpathInfo subpath = (*subpathInfo)[currentSubpath];
        
        // Remove all points that are the same from the subpath.
        // This initializes the spinePoints array.
        
        if( ComputeNonDegeneratePoints(
            &spinePoints, subpath, originalPoints) != Ok)
        {
            return OutOfMemory;
        }
        
        // skip this subpath if there aren't enough points left.
        
        if(spinePoints.GetCount() < 2)
        {
            continue;
        }
        
        // get a convenient pointer to the main spine points - after removing
        // degenerates. Const because we're not going to modify the points.
        
        const GpPointF *spine = spinePoints.GetDataBuffer();
        
        // Calculate the normals to all the points in the spine array.
        // The normals are normal to the edge between two points, so in an open
        // line segment, there is one less normal than there are points in the
        // spine. We handle this by initializing the first normal to (0,0).
        // The normals are all unit vectors and need to be scaled.
        
        ComputeSubpathNormals(
            &normalArray, 
            spinePoints.GetCount(), 
            subpath.IsClosed, 
            spine
        );
        
        GpVector2D *normals = normalArray.GetDataBuffer();
        
        // Loop over all the compound line segments. 
        // If there is no compound line we have set the compoundCount to 2.
        
        for(INT compoundIndex=0; 
            compoundIndex < compoundCount/2; 
            compoundIndex++)
        {
            // Compute the left and right offset.
            
            REAL left;
            REAL right;
            
            if(Pen->CompoundCount != 0)
            {
                // This is a compound line.
                
                ASSERT(Pen->CompoundArray != NULL);
                left = (0.5f-Pen->CompoundArray[compoundIndex*2]) * StrokeWidth;
                right = (0.5f-Pen->CompoundArray[compoundIndex*2+1]) * StrokeWidth;
            }
            else
            {
                // standard non-compound line.
                
                left = StrokeWidth/2.0f;
                right = -left;
            }
            
            left += penAlignmentOffset;
            right += penAlignmentOffset;
            
            INT startIdx = 0;
            INT endIdx = spinePoints.GetCount()-1;
            
            if(!subpath.IsClosed)
            {
                // Adjust the count for the join loop to represent the fact that 
                // we won't join the beginning and end of an open line segment.
                // Note Open line segments skip the first point handling it 
                // in the final cap.
                
                startIdx++;
                endIdx--;
            }
            
            //
            // Widen to the left.
            //
            
            // walk the spine forwards joining each point and emitting the 
            // appropriate set of points for the join.
    
            INT ptIndex;
            for(ptIndex = startIdx; ptIndex <= endIdx; ptIndex++)
            {
                // Modulo arithmetic for the next point.
                
                INT ptIndexNext = ptIndex+1;
                if(ptIndexNext == spinePoints.GetCount())
                {
                    ptIndexNext = 0;
                }
                
                GpVector2D normalCurr = normals[ptIndex]*left;
                GpVector2D normalNext = normals[ptIndexNext]*left;
                
                // Check to see if it's an inside or outside join. If the 
                // determinant of the two normals is negative, it's an outside
                // join - i.e. space between the line segment endpoints that need to 
                // be joined. If it's positive, it's an inside join and the two 
                // line segments overlap.
                
                REAL det = Determinant(normalCurr, normalNext);
                
                if(REALABS(det) < REAL_EPSILON)
                {
                    // This is the case where the angle of curvature for this 
                    // join is so small, we don't care which end point we pick.
                    
                    // REAL_EPSILON is probably too small for this - should 
                    // be about 0.25 of a device pixel or something.
                    
                    path->AddWidenPoint(spine[ptIndex] + normalCurr);
                }
                else
                {
                    // We need to do some work to join the segments.
                    
                    if(det > 0)
                    {
                        // Outside Joins. 
                        
                        join(
                            normalCurr, 
                            normalNext,
                            spine[ptIndex],
                            Pen->MiterLimit*StrokeWidth,
                            path
                        );
                    }
                    else
                    {
                        INT ptIndexPrev = ptIndex-1;
                        if(ptIndexPrev == -1)
                        {
                            ptIndexPrev = spinePoints.GetCount()-1;
                        }
                        
                        InsideJoin(
                            normalCurr,
                            normalNext,
                            spine[ptIndex],
                            spine[ptIndexPrev],
                            spine[ptIndexNext],
                            path
                        );
                    }
                }
            }
            
            // Handle the final point in the spine.
            
            if(subpath.IsClosed)
            {
                // Make a closed subpath out of the left widened points.
                
                path->CloseFigure(); 
            }
            else
            {
                // Cap the open segment.

                CapProc cap = endCap;
                                
                if( IsDashType(
                    originalTypes[subpath.StartIndex+subpath.Count-1]
                    ))
                { 
                    // actually it's a dash cap, not an end cap.
                    
                    cap = dashCap;  
                }
                
                cap(
                    spine[spinePoints.GetCount()-1] + 
                    (normals[spinePoints.GetCount()-1]*left),
                    spine[spinePoints.GetCount()-1] + 
                    (normals[spinePoints.GetCount()-1]*right),
                    path
                );
            }
            
            
            //
            // Widen to the right.
            //
            
            // walk the spine backwards joining each point and emitting the 
            // appropriate set of points for the join.
    
            for(ptIndex = endIdx; ptIndex >= startIdx; ptIndex--)
            {
                // Modulo arithmetic for the next point.
                
                INT ptIndexNext = ptIndex+1;
                if(ptIndexNext == spinePoints.GetCount())
                {
                    ptIndexNext = 0;
                }
                
                GpVector2D normalCurr = normals[ptIndex]*right;
                GpVector2D normalNext = normals[ptIndexNext]*right;
                
                // Check to see if it's an inside or outside join. If the 
                // determinant of the two normals is negative, it's an outside
                // join - i.e. space between the line segment endpoints that need to 
                // be joined. If it's positive, it's an inside join and the two 
                // line segments overlap.
                
                REAL det = Determinant(normalNext, normalCurr);
                
                if(REALABS(det) < REAL_EPSILON)
                {
                    // This is the case where the angle of curvature for this 
                    // join is so small, we don't care which end point we pick.
                    
                    // REAL_EPSILON is probably too small for this - should 
                    // be about 0.25 of a device pixel or something.
                    
                    path->AddWidenPoint(spine[ptIndex] + normalNext);
                }
                else
                {
                    // We need to do some work to join the segments.
                    
                    if(det > 0)
                    {
                        // Outside Joins. 
                        
                        join(
                            normalNext,     // note the order is flipped for  
                            normalCurr,     // the backward traversal.
                            spine[ptIndex],
                            Pen->MiterLimit*StrokeWidth,
                            path
                        );
                    }
                    else
                    {
                        INT ptIndexPrev = ptIndex-1;
                        if(ptIndexPrev == -1)
                        {
                            ptIndexPrev = spinePoints.GetCount()-1;
                        }
                        
                        InsideJoin(
                            normalNext,      // note the order is flipped for 
                            normalCurr,      // the backward traversal.       
                            spine[ptIndex],
                            spine[ptIndexNext],
                            spine[ptIndexPrev],
                            path
                        );
                    }
                }
            }
            
            // Handle the first point in the spine.
            
            if(!subpath.IsClosed)
            {
                // Cap the open segment.
                
                CapProc cap = startCap;
                                
                if(IsDashType(originalTypes[subpath.StartIndex]))
                { 
                    // actually it's a dash cap, not a start cap.
                    
                    cap = dashCap;
                }
                
                cap(
                    spine[0] + (normals[1]*right),
                    spine[0] + (normals[1]*left),
                    path
                );
            }    
            
            // Close the previous contour. For open segments this will close
            // off the widening with the end cap for the first point. For 
            // closed paths, the left widened points have already been closed
            // off, so close off the right widened points.
            
            path->CloseFigure();  
        }
    }
    
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\pathwidener.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.hpp
*
* Abstract:
*
*   Class used for Path widening
*
* Revision History:
*
*   11/24/99 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _PATHWIDENER_HPP
#define _PATHWIDENER_HPP

class GpPathWidener
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathWidener : ObjectTagInvalid;
    }

public:

    GpPathWidener(
        GpPath *path,
        const DpPen* pen,
        GpMatrix *matrix,
        BOOL doubleCaps = FALSE  // used for inset pens.
    );

    ~GpPathWidener()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    GpStatus Widen(GpPath *path);
    GpStatus Widen(DynPointFArray *points, DynByteArray *types);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPathWidener) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PathWidener");
        }
    #endif

        return (Tag == ObjectTagPathWidener);
    }

protected:
    
    VOID GpPathWidener::ComputeSubpathNormals(
        DynArray<GpVector2D> *normalArray,
        const INT count,
        const BOOL isClosed,
        const GpPointF *points
    );
    
    GpStatus GpPathWidener::ComputeNonDegeneratePoints(
        DynArray<GpPointF> *filteredPoints,
        const GpPath::SubpathInfo &subpath,
        const GpPointF *points
    );
    

protected:

    GpPath *Path;
    const DpPen* Pen;
    GpMatrix XForm;
    REAL StrokeWidth;
    BOOL DoubleCaps;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\path.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   path.cpp
*
* Abstract:
*
*   Implementation of the GpPath and DpPath classes
*
* Revision History:
*
*   12/11/1998 davidx
*       Add path functions.
*
*   12/07/1998 davidx
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// ReversePath(), CombinePaths(), CalculateGradientArray(), and
// GetMajorAndMinorAxis(), and GetFastAngle are defined in
// PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

BOOL IsRectanglePoints(const GpPointF* points, INT count);
VOID NormalizeAngle(REAL* angle, REAL width, REAL height);

INT NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    );

// Note that this is different from GpPathData.

class MetaPathData : public ObjectData
{
public:
    UINT32      Count;
    INT32       Flags;
};






/**************************************************************************\
*
* Function Description:
*
*   This reverses the path data.
*
* Arguments:
*
*   [IN] count - the number of points.
*   [IN/OUT] points - the data points to be reversed.
*   [IN/OUT] types - the data types to be reversed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isStartDashMode, isEndDashMode;
    BOOL wasMarkerEnd = FALSE;

    INT i;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
    {
        if((types[startIndex] & PathPointTypeDashMode) != 0)
            isStartDashMode = TRUE;
        else
            isStartDashMode = FALSE;
        if((types[endIndex] & PathPointTypeDashMode) != 0)
            isEndDashMode = TRUE;
        else
            isEndDashMode = FALSE;

        BOOL isMarkerEnd
            = (types[endIndex] & PathPointTypePathMarker) != 0;

        BYTE startType = types[startIndex]; // Save the first type.

        // Shift type points.

        for(i = startIndex + 1; i <= endIndex; i++)
        {
            types[i - 1] = types[i];
        }

        // Clear the close subpapth flag for original type (now at endIndex - 1).

        if(endIndex > 0)
            types[endIndex - 1] &= ~PathPointTypeCloseSubpath;
        
        types[endIndex] = PathPointTypeStart;

        if(isStartDashMode)
            types[startIndex] |= PathPointTypeDashMode;
        else
            types[startIndex] &= ~PathPointTypeDashMode;

        if(isEndDashMode)
            types[endIndex] |= PathPointTypeDashMode;
        else
            types[endIndex] &= ~PathPointTypeDashMode;

        // Add the dash and close flag.

        if(isClosed)
            types[startIndex] |= PathPointTypeCloseSubpath;
        else
            types[startIndex] &= ~PathPointTypeCloseSubpath;

        // Shift the marker flag by 1 from the original position.
        // This means we have to shift by 2 since the types array
        // was shifted by -1.

        for(i = endIndex; i >= startIndex + 2; i--)
        {
            if(types[i - 2] & PathPointTypePathMarker)
                types[i] |= PathPointTypePathMarker;
            else
                types[i] &= ~PathPointTypePathMarker;
        }
        
        // Shift Marker flag from the startIndex.

        if(startType & PathPointTypePathMarker)
            types[startIndex + 1] |= PathPointTypePathMarker;
        else
            types[startIndex + 1] &= ~PathPointTypePathMarker;
        
        // Shift Marker flag from the end of the previous subpath.

        if(wasMarkerEnd)
            types[startIndex] |= PathPointTypePathMarker;
        else
            types[startIndex] &= ~PathPointTypePathMarker;

        wasMarkerEnd = isMarkerEnd;

        // Keep the location of the internal flag.  So we must
        // shift back by 1.

        for(i = endIndex; i >= startIndex + 1; i--)
        {
            if(types[i - 1] & PathPointTypeInternalUse)
                types[i] |= PathPointTypeInternalUse;
            else
                types[i] &= ~PathPointTypeInternalUse;
        }
        if(startType & PathPointTypeInternalUse)
            types[startIndex] |= PathPointTypeInternalUse;
        else
            types[startIndex] &= ~PathPointTypeInternalUse;
    }

    // Reverse the points and types data.

    INT halfCount = count/2;
    for(i = 0; i < halfCount; i++)
    {
        GpPointF tempPt;
        BYTE tempType;

        tempPt = points[count - 1 - i];
        tempType = types[count - 1 - i];
        points[count - 1 - i] = points[i];
        types[count -1 - i] = types[i];
        points[i] = tempPt;
        types[i] = tempType;
    }       
    
#ifdef DEBUG_PATHWIDENER
    DpPathTypeIterator iter2(types, count);

    if(!iter2.IsValid())
    {
        WARNING(("ReversePath: failed."));
        return GenericError;
    }
#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two data points.  This is a general algorithm.
*   The output buffers (points and types) can be the same as the
*   first input buffers (points1 and types1).  In that case, both
*   buffers must be allocated at least to the array size of
*   count1 + count2.
*
* Arguments:
*
*   [IN] count - the allocated number of points (>= count1 + count2).
*   [OUT] points - the combined data points.
*   [OUT] types - the combined data types.
*   [IN] count1 - the number of points of the first path.
*   [IN] points1 - the first path points.
*   [IN] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*   [IN] connect - TRUE if the second line needs to be connected.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    )
{
    if(!points || !types || count < count1 + count2
        || count1 < 0 || !points1 || !types1
        || count2 < 0 || !points2 || !types2)
        return 0;
    
    // Check if the returning buffers are the same as the
    // first input buffers.

    INT resultCount = 0;
    if(points != points1 || types != types1)
    {
        if(points == points1 || types == types1)
        {
            // The both output buffer must be different.
            // If either of them is the same, don't combine
            // the path.

            return 0;
        }

        if(count1 > 0)
        {
            // Copy the first path.

            DpPathIterator iter1(points1, types1, count1);

            if(!iter1.IsValid())
                return 0;

            resultCount = iter1.Enumerate(points, types, count1);

            if(resultCount <= 0)
                return 0;
        }
    }
    else
    {
        // Both output buffers are the same as the first output
        // buffers.

        resultCount = count1;
    }

    GpStatus status = Ok;
    BOOL path1Closed;

    if(!forward1 && resultCount > 0)
    {
        status = ::ReversePath(resultCount, points, types);
        if(status != Ok)
            return 0;
    }

    if(count2 <= 0)
    {
        // No need to add the second path.

        return resultCount;
    }

    // Regard the empty path as a closed path.

    path1Closed = TRUE;

    if(resultCount > 0)
    {
        // Check the last point of path1.

        if((types[resultCount - 1] & PathPointTypeCloseSubpath))
            path1Closed = TRUE;
        else
            path1Closed = FALSE;
    }

    INT totalCount = 0;
    totalCount += resultCount;

    DpPathIterator iter2(points2, types2, count2);

    if(!iter2.IsValid())
        return 0;

    GpPointF* pts2 = points + resultCount;
    BYTE* typs2 = types + resultCount;

    resultCount = iter2.Enumerate(pts2, typs2, count2);

    if(resultCount <= 0)
        return 0;

    if(!forward2)
    {
        status = ::ReversePath(resultCount, pts2, typs2);
        if(status != Ok)
            return 0;
    }

    // Check if the first subpath of path2 is closed or not.

    BOOL path2Closed;

    DpPathTypeIterator iter3(typs2, resultCount);
    if(!iter3.IsValid())
        return 0;

    INT startIndex, endIndex;
    iter3.NextSubpath(&startIndex, &endIndex, &path2Closed);

    BYTE saveType= typs2[0];

    if(path1Closed || path2Closed)
    {
        typs2[0] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);
    }
    else
    {
        // Both paths are opened.

        if(connect)
        {
            typs2[0] = PathPointTypeLine |
                (saveType & ~PathPointTypePathTypeMask);

            // Check if the end point of path1 and the start point of path2
            // are the same.  If so, skip this point.

            if(REALABS(pts2[-1].X - pts2[0].X)
                + REALABS(pts2[-1].Y - pts2[0].Y) < POINTF_EPSILON)
            {
                for(INT i = 0; i < resultCount - 1; i++)
                {
                    pts2[i] = pts2[i + 1];
                    typs2[i] = typs2[i + 1];
                }
                resultCount--;
            }
        }
        else
        {
            typs2[0] = PathPointTypeStart |
                (saveType & ~PathPointTypePathTypeMask);
        }
    }

    totalCount += resultCount;

    return totalCount;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the unit gradient vectors of points as array of
*   (count + 1).  All the memories must be allocated and be checked
*   by the caller.
*
*   The first element of the gradient is from the end point to the
*   the start point.  If the end point is identical to the start point,
*   the previous point is used.
*   The last element of the gradient is from the start point to the end
*   point.  If the start point is identical to the end point, the next
*   point is used.
*   If distances array is not NULL, this returns the distance of each
*   segments.
*
* Arguments:
*
*   [OUT] grad - The gradient array of (count + 1) elements.
*   [OUT] distances - The distance array of (count + 1) elements or NULL.
*   [IN] points - The given points of count elements.
*   [IN] count - The number of given points.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    )
{
    GpPointF* grad1 = grad;
    REAL* distances1 = distances;
    const GpPointF* points1 = points;

    // Go to the starting point of this subpath.

    GpPointF startPt, endPt, lastPt, nextPt;

    startPt = *points1;

    INT i = count - 1;
    BOOL different = FALSE;
    points1 += i;   // Go to the end point.

    while(i > 0 && !different)
    {
        endPt = *points1--;

        if(endPt.X != startPt.X || endPt.Y != startPt.Y)
            different = TRUE;

        i--;
    }

    if(!different)
    {
        // All points are the same.

        WARNING(("Trying to calculate the gradients for degenerate points."));
        return GenericError;
    }

    points1 = points;
    lastPt = endPt;

    i = 0;

    while(i <= count)
    {
        REAL dx, dy, d;

        if(i < count)
            nextPt = *points1++;
        else
            nextPt = startPt;
        
        dx = nextPt.X - lastPt.X;
        dy = nextPt.Y - lastPt.Y;
        d = dx*dx + dy*dy;

        if(d > 0)
        {
            d = REALSQRT(d);
            dx /= d;
            dy /= d;
        }
        grad1->X = dx;
        grad1->Y = dy;

        // Record the distance only when the given distance array is not NULL.

        if(distances)
            *distances1++ = d;

        grad1++;
        lastPt = nextPt;
        i++;
    }

    // Make sure the last gradient is not 0.

    grad1 = grad + count;
    if(grad1->X == 0 && grad1->Y == 0)
    {
        // The start and end point are the same.  Find
        // the next non-zero gradient.

        i = 1;
        grad1 = grad + i;

        while(i < count)
        {
            if(grad1->X != 0 || grad1->Y != 0)
            {
                grad[count] = *grad1;

                if(distances)
                    distances[count] = distances[i];
                break;
            }
            i++;
            grad1++;
        }
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the path data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    INT                 flags      = pointData.GetFlags();

    if (FillMode == FillModeWinding)
    {
        flags |= GDIP_EPRFLAGS_WINDINGFILL;
    }

    MetaPathData    pathData;
    pathData.Count = count;
    pathData.Flags = flags;
    stream->Write(&pathData, sizeof(pathData), NULL);

    stream->Write(pointData.GetData(), pointsSize, NULL);
    stream->Write(Types.GetDataBuffer(), count, NULL);

    // align
    if ((count & 0x03) != 0)
    {
        INT     pad = 0;
        stream->Write(&pad, 4 - (count & 0x03), NULL);
    }

    return Ok;
}

UINT
DpPath::GetDataSize() const
{
    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    UINT                dataSize   = sizeof(MetaPathData) + pointsSize + count;

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the path object from memory.
*
* Arguments:
*
*   [IN] memory - the data that was read from the stream
*   [IN] size   - the size of the memory data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    Points.Reset();
    Types.Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size >= sizeof(MetaPathData))
    {
        const MetaPathData *    pathData = reinterpret_cast<const MetaPathData *>(dataBuffer);

        if (!pathData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        InitDefaultState(::GetFillMode(pathData->Flags));
        SetValid(TRUE);

        INT     count = pathData->Count;

        if (count > 0)
        {
            UINT        pointDataSize;

            if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
            {
                pointDataSize = count * sizeof(GpPoint16);
            }
            else
            {
                pointDataSize = count * sizeof(GpPointF);
            }

            if (size >= sizeof(MetaPathData) + count + pointDataSize)
            {
                GpPointF *      points = Points.AddMultiple(count);
                BYTE *          types  = Types.AddMultiple(count);
                const BYTE *    typeData;
                const BYTE *    pointData = dataBuffer + sizeof(MetaPathData);

                if ((points != NULL) && (types != NULL))
                {
                    if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
                    {
                        BYTE *  tmp = NULL;

                        ::GetPointsForPlayback(
                                pointData,
                                size - (sizeof(MetaPathData) + count),
                                count,
                                pathData->Flags,
                                sizeof(GpPointF) * count,
                                (BYTE *)points,
                                tmp);
                        typeData = pointData + (count * 4);
                    }
                    else
                    {
                        GpMemcpy(points, pointData, count * sizeof(points[0]));
                        typeData = pointData + (count * sizeof(points[0]));
                    }
                    GpMemcpy(types, typeData, count);

                    if (ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
                    {
                        UpdateUid();
                        return Ok;
                    }
                }
            }
            else
            {
                WARNING(("size is too small"));
            }
        }
    }
    else
    {
        WARNING(("size is too small"));
    }

    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a new GpPath object using the specified path data
*
* Arguments:
*
*   [IN] points - Point to an array of path points
*   [IN] types - Specify path point types
*   count - Number of path points
*   fillMode - Path fill mode
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpPath::GpPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    GpFillMode fillMode
    )
{
    SetValid(FALSE);

    // Validate function parameters

    if (count <= 0 ||
        (count > 0 && (!points || !types)) ||
        (fillMode != FillModeAlternate && fillMode != FillModeWinding))
    {
        WARNING(("Invalid path data in GpPath::GpPath"));
        return;
    }

    InitDefaultState(fillMode);

    // Validate path point types

    if (!ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
    {
        WARNING(("Invalid path type information"));
        return;
    }

    // Copy path point and type information

    SetValid(Types.AddMultiple(types, count) == Ok &&
             Points.AddMultiple(points, count) == Ok);

    if(IsValid()) {
        // Make sure the first point is the start type.

        Types.First() = PathPointTypeStart;
    }
}


//--------------------------------
// Constructor for polygon.
//--------------------------------

GpPath::GpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags flags
    ) : DpPath(points, count, stackPoints, stackTypes, stackCount,
            fillMode, flags)
{
    InvalidateCache();
}

//--------------------------------
// Copy constructor.
//--------------------------------

GpPath::GpPath(const GpPath* path) : DpPath(path)
{
    SetValid(path != NULL);

    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Copies the path data.  Points and Types array in pathData
*   must be allocated by the caller.
*
* Arguments:
*
*   [OUT] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::GetPathData(GpPathData* pathData)
{
    if ((!pathData) || (!pathData->Points) || (!pathData->Types) || (pathData->Count < 0))
        return InvalidParameter;

    INT count = GetPointCount();
    const GpPointF* points = GetPathPoints();
    const BYTE* types = GetPathTypes();

    if (pathData->Count >= count)
    {
        if (count > 0)
        {
            GpMemcpy(pathData->Points, points, count*sizeof(GpPointF));
            GpMemcpy(pathData->Types, types, count);
        }

        pathData->Count = count;
        return Ok;
    }
    else
        return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set a marker at the current location.  You cannot set a marker at the
*   first position.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::SetMarker()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    // Don't set a marker at the first point.

    if(count > 1 && types)
    {
        types[count - 1] |= PathPointTypePathMarker;
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Clears all the markers in the path.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::ClearMarkers()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    BOOL modified = FALSE;

    if(count > 0 && types)
    {
        for(INT i = 0; i < count; i++)
        {
            if(types[i] & PathPointTypePathMarker)
            {
                types[i] &= ~PathPointTypePathMarker;
                modified = TRUE;
            }
        }
    }

    if(modified)
    {
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the path data.
*
* Arguments:
*
*   [IN] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::SetPathData(const GpPathData* pathData)
{
    if(!pathData || pathData->Count <= 0)
        return InvalidParameter;

    INT count = pathData->Count;
    DpPathIterator iter(pathData->Points, pathData->Types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    Points.Reset(FALSE);
    Types.Reset(FALSE);

    GpPointF* points = Points.AddMultiple(count);
    BYTE* types = Types.AddMultiple(count);

    if(points && types)
    {
        INT number, startIndex, endIndex;
        BOOL isClosed = FALSE;

        while(number = iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpMemcpy(
                points,
                pathData->Points + startIndex,
                number*sizeof(GpPointF)
                );
            GpMemcpy(
                types,
                pathData->Types + startIndex,
                number
                );

            points += number;
            types += number;
       }

        SetValid(TRUE);
        HasBezier = iter.HasCurve();
        Flags = PossiblyNonConvex;
        SubpathCount = iter.GetSubpathCount();
        IsSubpathActive = !isClosed;
        UpdateUid();
        return Ok;
    }
    else
        return OutOfMemory;
}

BOOL IsRectanglePoints(
    const GpPointF* points,
    INT count
    )
{
    if(count < 4 || count > 5)
        return FALSE;

    if(count == 5)
    {
        if(points[0].X != points[4].X || points[0].Y != points[4].Y)
            return FALSE;
    }

    if(
        ((points[1].X - points[0].X) != (points[2].X - points[3].X)) ||
        ((points[1].Y - points[0].Y) != (points[2].Y - points[3].Y)) ||
        ((points[2].X - points[1].X) != (points[3].X - points[0].X)) ||
        ((points[2].Y - points[1].Y) != (points[3].Y - points[3].Y))
        )
        return FALSE;
    else
        return TRUE;
}

BOOL
GpPath::IsRectangle() const
{
    if((SubpathCount != 1) || HasBezier)
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count);
}


/**************************************************************************\
*
* Function Description:
*
*   Determine if the receiver and path represent the same path
*
* Arguments:
*
*   [IN] path - GpPath to compare
*
* Return Value:
*
*   TRUE if the paths are the same.
*
* Created - 5/27/99 peterost
*
\**************************************************************************/

BOOL GpPath::IsEqual(const GpPath* path) const
{
    if (path == this)
        return TRUE;

    INT    count;

    if (IsValid() == path->IsValid() &&
        (count=GetPointCount()) == path->GetPointCount() &&
        HasBezier == path->HasBezier &&
        FillMode == path->FillMode &&
        Flags == path->Flags &&
        IsSubpathActive == path->IsSubpathActive &&
        SubpathCount == path->SubpathCount)
    {
        BYTE*     types = path->Types.GetDataBuffer();
        BYTE*     mytypes = Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        GpPointF* mypoints = Points.GetDataBuffer();

        for (INT i=0; i<count; i++)
        {
            if (types[i] != mytypes[i] ||
                points[i].X != mypoints[i].X ||
                points[i].Y != mypoints[i].Y)
            {
                return FALSE;
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
GpPath::InitDefaultState(
    GpFillMode fillMode
    )

{
    DpPath::InitDefaultState(fillMode);
    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Validate path point type information
*
* Arguments:
*
*   [IN] types - Point to an array of path point types
*   count - Number of points
*   subpathCount - Return the number of subpaths
*   hasBezier - Return whether the path has Bezier segments
*   [IN] needsFirstPointToBeStartPoint - TRUE if this data needs to start
*                                       with a StartPoint. (Default is TRUE)
*
* Return Value:
*
*   TRUE if the path point type information is valid
*   FALSE otherwise
*
\**************************************************************************/

BOOL
DpPath::ValidatePathTypes(
    const BYTE* types,
    INT count,
    INT* subpathCount,
    BOOL* hasBezier
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
    {
        WARNING(("Invalid path type information"));
        return FALSE;
    }

    *subpathCount = iter.GetSubpathCount();
    *hasBezier = iter.HasCurve();

    return iter.IsValid();
}

/**************************************************************************\
*
* Function Description:
*
*   Private helper function to add points to a path object
*
* Arguments:
*
*   [IN] points - Specify the points to be added
*   count - Number of points to add
*
* Return Value:
*
*   Point to location in the point type data buffer
*   that corresponds to the *SECOND* path point added.
*
*   The first point type is always handled inside this
*   function:
*
*   1. If either the previous subpath is closed, or addClosedFigure
*      parameter is TRUE, the first point type will be StartPoint.
*
*   2. Otherwise, the previous subpath is open and addClosedFigure
*      parameter is FALSE. We have two separate cases to handle:
*
*      2.1 if the first point to be added is the same as the last
*          point of the open subpath, then the first point is ignored.
*
*      2.2 otherwise, the first point type will be LinePoint.
*
*   NULL if there is an error. In this case, existing path
*   data is not affected.
*
* Note:
*
*   We assume the caller has already obtained a lock
*   on the path object.
*
\**************************************************************************/

BYTE*
GpPath::AddPointHelper(
    const GpPointF* points,
    INT count,
    BOOL addClosedFigure
    )
{
    // If we're adding a closed figure, then make sure
    // there is no more currently active subpath.

    if (addClosedFigure)
        StartFigure();

    INT origCount = GetPointCount();

    BOOL isDifferentPoint = TRUE;

    // Check if the first point is the same as the last point.

    if(IsSubpathActive && origCount > 0)
    {
        GpPointF lastPt = Points.Last();
        if ((REALABS(points->X - lastPt.X) < REAL_EPSILON) &&
            (REALABS(points->Y - lastPt.Y) < REAL_EPSILON) )
        {
            if(count == 1)
                return NULL;

            // case 2.1 above
            // Skip the first point and its type.

            count--;
            points++;
            isDifferentPoint = FALSE;
        }
    }

    // Resize Points and Types

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return NULL;
    }

    // Record the type of the first point (Start or Line Point).

    if (!IsSubpathActive)
    {
        // case 1 above

        *typebuf++ = PathPointTypeStart;
        SubpathCount++; // Starting a new subpath.
    }
    else
    {
        // If the first point is different, add a Line type.
        // Otherwise, skip the first point and its type.

        if(isDifferentPoint)
        {
            // case 2.2 above

            *typebuf++ = PathPointTypeLine;
        }
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));

    // Subpath is active if the added figure is not closed.

    if(!addClosedFigure)
        IsSubpathActive = TRUE;

    // Return the starting location for the new point type data
    // From the second point type.

    return typebuf;
}


/**************************************************************************\
*
* Function Description:
*
*   Add a series of line segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify the line points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddLines(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    // Validate function parameters

    if (points == NULL || count < 1)
        return InvalidParameter;

    InvalidateCache();

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, FALSE);

    if (types == NULL)
    {
        if(count > 1)
            return OutOfMemory;
        else
            return Ok;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-1);
//    IsSubpathActive = TRUE;   This is set in AddPointHelper. - ikkof
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Add rectangles to the current path object
*
* Arguments:
*
*   [IN] rects - Specify the rectangles to be added
*   count - Number of rectangles
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddRects(
    const GpRectF* rect,
    INT count
    )
{
    if (count < 1 || rect == NULL)
        return InvalidParameter;

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rect++)
    {
        if (rect->IsEmptyArea())
            continue;

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = rect->GetLeft();      // top-left
        points[0].Y = rect->GetTop();
        points[1].X = rect->GetRight();     // top-right
        points[1].Y = rect->GetTop();
        points[2].X = rect->GetRight();     // bottom-right
        points[2].Y = rect->GetBottom();
        points[3].X = rect->GetLeft();      // bottom-left
        points[3].Y = rect->GetBottom();

        if ((status = AddPolygon(points, 4)) != Ok)
            return status;
    }

    return Ok;
}

GpStatus
GpPath::AddRects(
    const RECT*     rects,
    INT             count
    )
{
    if ((count < 1) || (rects == NULL))
    {
        return InvalidParameter;
    }

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rects++)
    {
        if ((rects->left >= rects->right) || (rects->top >= rects->bottom))
        {
            continue;
        }

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = (REAL)rects->left;        // top-left
        points[0].Y = (REAL)rects->top;
        points[1].X = (REAL)rects->right;       // top-right
        points[1].Y = (REAL)rects->top;
        points[2].X = (REAL)rects->right;       // bottom-right
        points[2].Y = (REAL)rects->bottom;
        points[3].X = (REAL)rects->left;        // bottom-left
        points[3].Y = (REAL)rects->bottom;

        if ((status = AddPolygon(points, 4)) != Ok)
        {
            return status;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a polygon to the current path object
*
* Arguments:
*
*   [IN] Specify the polygon points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPolygon(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    if (count < 3 || points == NULL)
        return InvalidParameter;

    // Check if the last point is the same as the first point.
    // If so, ignore it.

    if (count > 3 &&
        points[0].X == points[count-1].X &&
        points[0].Y == points[count-1].Y)
    {
        count--;
    }

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, TRUE);

    if (types == NULL)
        return OutOfMemory;

    InvalidateCache();

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-2);
    types[count-2] = PathPointTypeLine | PathPointTypeCloseSubpath;

    UpdateUid();

    return Ok;
}


#define PI          TOREAL(3.1415926535897932)
#define HALF_PI     TOREAL(1.5707963267948966)


/**************************************************************************\
*
* Function Description:
*
*   Convert an angle defined in a box with (width, height) to
*   an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angle.
*
* Arguments:
*
*   [IN/OUT] angle - the angle is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   NONE
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
NormalizeAngle(REAL* angle, REAL width, REAL height)
{
    REAL a = *angle;

    // Set the angle between 0 and 360 degrees.

    a = GpModF(a, 360);

    if(a < 0 || a > 360)
    {
        // The input data may have been too large or loo small
        // to calculate the mode.  In that case, set to 0.

        a = 0;
    }

    if(width != height)
    {
        INT plane = 1;
        REAL b = a;

        if(a <= 90)
            plane = 1;
        else if(a <= 180)
        {
            plane = 2;
            b = 180 - a;
        }
        else if(a <= 270)
        {
            plane = 3;
            b = a - 180;
        }
        else
        {
            plane = 4;
            b = 360 - a;
        }

        b = b*PI/180;   // Convert to radian

        // Get the normalized angle in the plane 1.

        a = TOREAL( atan2(width*sin(b), height*cos(b)) );

        // Adjust to the angle in one of 4 planes.

        switch(plane)
        {
            case 1:
            default:
                break;

            case 2:
                a = PI - a;
                break;

            case 3:
                a = PI + a;
                break;

            case 4:
                a = 2*PI - a;
                break;
        }
    }
    else
    {
        a = a*PI/180;   // Convert to radian.
    }

    *angle = a;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert the start and sweep angles defined in a box with (width, height)
*   to an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angles.
*
* Arguments:
*
*   [IN/OUT] startAngle - it is given in degrees and return it in radian.
*   [IN/OUT] sweepAngle - it is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   INT - +1 if sweeping in clockwise and -1 in counterclockwise.
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    )
{
    REAL a0 = *startAngle;  // The start angle.
    REAL dA = *sweepAngle;
    REAL a1 = a0 + dA;      // The end angle.
    INT sweepSign;

    if(dA > 0)
        sweepSign = 1;
    else
    {
        sweepSign = - 1;
        dA = - dA;  // Convert to a positive sweep angle.
    }

    // Normalize the start and end angle.

    NormalizeAngle(&a0, width, height);
    NormalizeAngle(&a1, width, height);

    if(dA < 360)
    {
        if(sweepSign > 0)
        {
            dA = a1 - a0;
        }
        else
        {
            dA = a0 - a1;
        }
        if(dA < 0)
            dA += 2*PI;
    }
    else
        dA = 2*PI;  // Don't sweep more than once.

    *startAngle = a0;
    *sweepAngle = dA;

    return sweepSign;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert an elliptical arc to a series of Bezier curve segments
*
* Arguments:
*
*   points - Specify a point buffer for returning Bezier control points
*       The array should be able to hold 13 elements or more.
*   rect - Specify the bounding box for the ellipse
*   startAngle - Start angle (in elliptical space and degrees)
*   sweepAngle - Sweep angle
*       positive to sweep clockwise
*       negative to sweep counterclockwise
*
* Return Value:
*
*   Number of Bezier control points generated
*   0 if sweep angle is 0
*   -1 if bounding rectangle is empty
*
\**************************************************************************/

INT
GpPath::GetArcPoints(
    GpPointF* points,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    if (rect.IsEmptyArea())
        return -1;
    else if (sweepAngle == 0)
        return 0;

    // Determine which direction we should sweep
    // and clamp sweep angle to a max of 360 degrees
    // Both start and sweep angles are conveted to radian.

    INT sweepSign = NormalizeArcAngles(
        &startAngle,
        &sweepAngle,
        rect.Width,
        rect.Height);

    // Temporary variables

    REAL dx, dy;
    REAL w2, h2;

    w2 = rect.Width / 2;
    h2 = rect.Height / 2;
    dx = rect.X + w2;
    dy = rect.Y + h2;

    // Determine the number of Bezier segments needed

    int segments, count;
    GpMatrix m;

    segments = (INT) (sweepAngle / HALF_PI);

    if (segments*HALF_PI < sweepAngle)
        segments++;

    if (segments == 0)
        segments = 1;
    else if (segments > 4)
        segments = 4;

    count = segments*3 + 1;

    while (segments--)
    {
        // Compute the Bezier control points in unit-circle space

        REAL A, C, S;
        REAL x, y;

        A = (sweepAngle > HALF_PI) ? HALF_PI/2 : sweepAngle/2;
        C = REALCOS(A);
        S = REALSIN(A);

        x = (4 - C) / 3;
        y = (3 - C) * S / (3 + 3*C);

        if (sweepSign > 0)
        {
            // clockwise sweep

            points[0].X = C;
            points[0].Y = -S;
            points[1].X = x;
            points[1].Y = -y;
            points[2].X = x;
            points[2].Y = y;
            points[3].X = C;
            points[3].Y = S;
        }
        else
        {
            // counterclockwise sweep

            points[0].X = C;
            points[0].Y = S;
            points[1].X = x;
            points[1].Y = y;
            points[2].X = x;
            points[2].Y = -y;
            points[3].X = C;
            points[3].Y = -S;
        }

        // Transform the control points to elliptical space

        m.Reset();
        m.Translate(dx, dy);
        m.Scale(w2, h2);
        REAL theta = (startAngle + sweepSign*A)*180/PI;
        m.Rotate(theta);    // Rotate takes degrees.

        if(segments > 0)
            m.Transform(points, 3);
        else
            m.Transform(points, 4); // Include the last point.

        if(sweepSign > 0)
            startAngle += HALF_PI;
        else
            startAngle -= HALF_PI;
        sweepAngle -= HALF_PI;
        points += 3;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical arc to the current path object
*
* Arguments:
*
*   rect - Specify the bounding rectangle for the ellipse
*   startAngle - Starting angle for the arc
*   sweepAngle - Sweep angle for the arc
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddArc(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF points[13];
    INT count;
    BOOL isClosed = FALSE;

    if(sweepAngle >= 360)
    {
        sweepAngle = 360;
        isClosed = TRUE;
    }
    else if(sweepAngle <= - 360)
    {
        sweepAngle = - 360;
        isClosed = TRUE;
    }

    // Convert arc to Bezier curve segments

    count = GetArcPoints(points, rect, startAngle, sweepAngle);

    // Add resulting Bezier curve segment to the path

    GpStatus status = Ok;

    if(count > 0)
    {
        AddBeziers(points, count);
        if(isClosed)
            CloseFigure();
    }
    else if(count < 0)
        status = InvalidParameter;

    InvalidateCache();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an ellipse to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*
* Return Value:
*
*   Status code
*
* History:
*
*   02/22/1999 ikkof
*       Defined an array of a circle with radius 1 and used it.
*
\**************************************************************************/

GpStatus
GpPath::AddEllipse(
    const GpRectF& rect
    )
{
    GpPointF points[13];
    INT count = 13;
    REAL u_cir = 4*(REALSQRT(2.0) - 1)/3;
    GpPointF center;
    REAL    wHalf, hHalf;

    wHalf = rect.Width/2;
    hHalf = rect.Height/2;
    center.X = rect.X + wHalf;
    center.Y = rect.Y + hHalf;

    // 4 Bezier segment of a circle with radius 1.

    points[ 0].X = 1;       points[ 0].Y = 0;
    points[ 1].X = 1;       points[ 1].Y = u_cir;
    points[ 2].X = u_cir;   points[ 2].Y = 1;
    points[ 3].X = 0;       points[ 3].Y = 1;
    points[ 4].X = -u_cir;  points[ 4].Y = 1;
    points[ 5].X = -1;      points[ 5].Y = u_cir;
    points[ 6].X = -1;      points[ 6].Y = 0;
    points[ 7].X = -1;      points[ 7].Y = -u_cir;
    points[ 8].X = -u_cir;  points[ 8].Y = -1;
    points[ 9].X = 0;       points[ 9].Y = -1;
    points[10].X = u_cir;   points[10].Y = -1;
    points[11].X = 1;       points[11].Y = -u_cir;
    points[12].X = 1;       points[12].Y = 0;

    // Scale to the appropriate size.

    for(INT i = 0; i < count; i++)
    {
        points[i].X = points[i].X*wHalf + center.X;
        points[i].Y = points[i].Y*hHalf + center.Y;
    }

    // Add resulting Bezier curve segments to the path

    GpStatus status;

    StartFigure();
    status = AddBeziers(points, count);
    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical pie to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*   startAngle - Specify the starting angle for the pie
*   sweepAngle - Sweep angle for the pie
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPie(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF pt;

    StartFigure();

    // Add the center point.

    pt.X = rect.X + rect.Width/2;
    pt.Y = rect.Y + rect.Height/2;
    GpStatus status = AddLines(&pt, 1);

    // Add the arc points.

    if(status == Ok)
        status = AddArc(rect, startAngle, sweepAngle);

    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add Bezier curve segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify Bezier control points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddBeziers(
    const GpPointF* points,
    INT count
    )
{
    // Number of points must be 3 * N + 1
    if ((!points) || (count < 4) || (count % 3 != 1))
    {
    	return InvalidParameter;
    }

    // Check if the first point is the same as the last point.
    INT firstType;
    INT origCount = GetPointCount();

    if(!IsSubpathActive)
    {
        SubpathCount++; // Starting a new subpath.
        firstType = PathPointTypeStart;
    }
    else
    {
        if(origCount > 0)
        {
            firstType = PathPointTypeLine;
        }
        else
        {
            SubpathCount++;
            firstType = PathPointTypeStart;
        }
    }

    // Resize Points and Types
    GpPointF* pointBuf = Points.AddMultiple(count);
    BYTE* typeBuf = Types.AddMultiple(count);

    if(pointBuf == NULL || typeBuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    GpMemcpy(pointBuf, points, count * sizeof(GpPointF));
    GpMemset(typeBuf, PathPointTypeBezier, count);
    
    if(firstType == PathPointTypeStart)
        typeBuf[0] = PathPointTypeStart;
    else if(firstType == PathPointTypeLine)
        typeBuf[0] = PathPointTypeLine;

    IsSubpathActive = TRUE;
    HasBezier = TRUE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}

GpStatus
GpPath::AddBezier(
    const GpPointF& pt1,
    const GpPointF& pt2,
    const GpPointF& pt3,
    const GpPointF& pt4
    )
{
    GpPointF points[4];

    points[0] = pt1;
    points[1] = pt2;
    points[2] = pt3;
    points[3] = pt4;

    return AddBeziers(points, 4);
}

GpStatus
GpPath::AddBezier(
    REAL x1, REAL y1,
    REAL x2, REAL y2,
    REAL x3, REAL y3,
    REAL x4, REAL y4
    )
{
    GpPointF points[4];

    points[0].X = x1;
    points[0].Y = y1;
    points[1].X = x2;
    points[1].Y = y2;
    points[2].X = x3;
    points[2].Y = y3;
    points[3].X = x4;
    points[3].Y = y4;

    return AddBeziers(points, 4);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a path to the current path object.
*   When connect is TRUE, this combine the end point of the current
*   path and the start point of the given path if both paths are
*   open.
*   If either path is closed, the two paths will not be connected
*   even if connect is set to TRUE.
*
* Arguments:
*
*   [IN] points - Specify a subpath points
*   [IN] types - Specify a subpath control types.
*   [IN] count - Number of points
*   [IN] connect - TRUE if two open paths needs to be connected.
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::AddPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    BOOL connect
    )
{
    GpStatus status = Ok;
    
    if(points == NULL || types == NULL || count <= 0)
    {
        return InvalidParameter;
    }

    INT count1 = GetPointCount();
    INT count2 = count;
    const GpPointF* points2 = points;
    const BYTE* types2 = types;

    INT totalCount = count1 + count2;
    BOOL forward1 = TRUE, forward2 = TRUE;

    status = Points.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    status = Types.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    GpPointF* outPoints = Points.GetDataBuffer();
    BYTE* outTypes = Types.GetDataBuffer();
    const GpPointF* points1 = outPoints;
    const BYTE* types1 = outTypes;

    totalCount = CombinePaths(
        totalCount, 
        outPoints,
        outTypes,
        count1, 
        points1, 
        types1, 
        forward1,
        count2, 
        points2, 
        types2, 
        forward2,
        connect
    );

    if( (totalCount >= count1) &&
        ValidatePathTypes(outTypes, totalCount, &SubpathCount, &HasBezier))
    {
        count2 = totalCount - count1;
        Points.AdjustCount(count2);
        Types.AdjustCount(count2);
        InvalidateCache();
        UpdateUid();

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}

GpStatus
GpPath::AddPath(const GpPath* path, BOOL connect)
{
    if(!path)
    {
        return InvalidParameter;
    }

    INT count2 = path->GetPointCount();
    const GpPointF* points2 = path->GetPathPoints();
    const BYTE* types2 = path->GetPathTypes();

    return AddPath(points2, types2, count2, connect);
}

/**************************************************************************\
*
* Function Description:
*
* Reverse the direction of the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Reverse()
{
    if(!IsValid())
        return InvalidParameter;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();
    BYTE* types = Types.GetDataBuffer();

    GpStatus status = Ok;

    if(count > 1)
        status = ::ReversePath(count, points, types);
    UpdateUid();

    return status;
}

GpStatus
GpPath::GetLastPoint(GpPointF* lastPoint)
{
    INT count = GetPointCount();
    if(count <= 0 || lastPoint == NULL)
        return InvalidParameter;

    GpPointF* points = Points.GetDataBuffer();

    // Return the last point.

    *lastPoint = points[count - 1];

    return Ok;
}

GpPath*
GpPath::GetOpenPath()
{
    BOOL openPath = TRUE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetClosedPath()
{
    BOOL openPath = FALSE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetOpenOrClosedPath(BOOL openPath)
{
    INT startIndex, endIndex;
    BOOL isClosed;
    const GpPointF* points = Points.GetDataBuffer();
    const BYTE* types = Types.GetDataBuffer();

    DpPathIterator iter(points, types, GetPointCount());

    GpPath* path = new GpPath(FillMode);

    if(path)
    {
        INT segmentCount = 0;
        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            if(isClosed != openPath)
            {
//                path->AddSubpath(points + startIndex, types + startIndex,
//                        endIndex - startIndex + 1);

                BOOL connect = FALSE;
                path->AddPath(points + startIndex, types + startIndex,
                        endIndex - startIndex + 1, connect);
                segmentCount++;
            }
        }

        if(segmentCount == 0)
        {
            delete path;
            path = NULL;
        }
    }

    return path;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an open cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*   offset - Index of the first point we're interested in
*   numberOfSegments - Number of curve segments
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define DEFAULT_TENSION 0.5

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    // Verify input parameters

    if (points == NULL ||
        count < 2 ||
        offset < 0 ||
        offset >= count ||
        numberOfSegments < 1 ||
        numberOfSegments >= count-offset)
    {
        return InvalidParameter;
    }

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        offset,
                        numberOfSegments,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments to the current path

    GpStatus status;

    status = AddBeziers(bezierPoints, bezierCount);
    delete[] bezierPoints;

    return status;
}

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddCurve(points,
                    count,
                    DEFAULT_TENSION,
                    0,
                    count-1);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a closed cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count,
    REAL tension
    )
{
    // Verify input parameters

    if (points == NULL || count <= 2)
        return InvalidParameter;

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        0,
                        count,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments as a closed curve

    GpStatus status;

    StartFigure();
    status = AddBeziers(bezierPoints, bezierCount);
    CloseFigure();

    delete[] bezierPoints;

    InvalidateCache();
    UpdateUid();

    return status;
}

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddClosedCurve(points, count, DEFAULT_TENSION);
}


/**************************************************************************\
*
* Function Description:
*
*   Convert cardinal spline curve points to Bezier curve control points
*
* Arguments:
*
*   [IN] points - Array of spline curve points
*   count - Number of points in the "points" array
*   offset - Specify the index of the first control point in
*       the "points" array that the curve should start from
*   numberOfSegments - Specify the number of curve segments to draw
*   tension - Specify the tension parameter
*   bezierCount - Return the number of Bezier control points
*
* Return Value:
*
*   Pointer to an array of Bezier control points
*   NULL if there is an error
*
* Reference:
*
*   Spline Tutorial Notes
*   Technical Memo No. 77
*   Alvy Ray Smith
*   Presented as tutorial notes at the 1983 SIGGRAPH, July 1983
*   and the SIGGRAPH, July 1984
*
* Notes:
*
*   Support for cardinal spline curves
*
*   Cardinal splines are local interpolating splines, i.e. they
*   pass through their control points and they maintain
*   first-order continuity at their control points.
*
*   a cardinal spline is specified by three parameters:
*       a set of control points P1, ..., Pn
*       tension parameter a
*       close flag
*
*   If n is 1, then the spline degenerates into a single point P1.
*   If n > 1 and the close flag is false, the spline consists of
*   n-1 cubic curve segments. The first curve segment starts from
*   P1 and ends at P2. The last segment starts at Pn-1 and ends at Pn.
*
*   The cubic curve segment from Pi to Pi+1 is determined by
*   4 control points:
*       Pi-1 = (xi-1, yi-1)
*       Pi = (xi, yi)
*       Pi+1 = (xi+1, yi+1)
*       Pi+2 = (xi+2, yi+2)
*
*   The parametric equation is defined as:
*
*       [ X(t) Y(t) ] = [t^3 t^2 t 1] * M * [ xi-1 yi-1 ]
*                                           [ xi   yi   ]
*                                           [ xi+1 yi+1 ]
*                                           [ xi+2 yi+2 ]
*
*   where t ranges from 0 to 1 and M is a 4x4 matrix satisfying
*   the following constraints:
*
*       X(0) = xi               interpolating through control points
*       X(1) = xi+1
*       X'(0) = a(xi+1 - xi-1)  first-order continuity
*       X'(1) = a(xi+2 - xi)
*
*   In the case of segments from P1 to P2 and from Pn-1 to Pn,
*   we replicate the first and last control points, i.e. we
*   define P0 = P1 and Pn+1 = Pn.
*
*   If the close flag is true, we have an additional curve segment
*   from Pn to Pn+1 = P1. For the segments near the beginning and
*   the end of the spline, we wrap around the control points, i.e.
*   P0 = Pn, Pn+1 = P1, and Pn+2 = P2.
*
\**************************************************************************/

GpPointF*
GpPath::ConvertSplineToBezierPoints(
    const GpPointF* points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension,
    INT* bezierCount
    )
{
    BOOL closed;
    GpPointF* bezierPoints;

    ASSERT(count > 1 &&
           offset >= 0 &&
           offset < count &&
           numberOfSegments > 0 &&
           numberOfSegments <= count-offset);

    // Curve is closed if the number of segments is equal to
    // the number of curve points

    closed = (numberOfSegments == count);

    // Allocate memory to hold Bezier control points

    *bezierCount = numberOfSegments*3 + 1;
    bezierPoints = new GpPointF[*bezierCount];

    if (bezierPoints == NULL)
        return NULL;

    // Convert each spline segment to a Bezier segment
    // resulting in 3 additional Bezier points

    GpPointF buffer[4], *q;
    const GpPointF* p;
    REAL a3;

    a3 = tension / 3;
    q = bezierPoints;
    *q = points[offset];

    for (INT index=offset; index < offset+numberOfSegments; index++)
    {
        if (index > 1 && index < count-2)
            p = points + (index-1);
        else
        {
            // Points near the beginning and end of the curve
            // require special attention

            if (closed)
            {
                // If the curve is closed, make sure the control points
                // wrap around the beginning and end of the array.

                buffer[0] = points[(index-1+count) % count];
                buffer[1] = points[index];
                buffer[2] = points[(index+1) % count];
                buffer[3] = points[(index+2) % count];
            }
            else
            {
                // If the curve is not closed, replicate the first
                // and last point in the array.

                buffer[0] = points[(index > 0) ? (index-1) : 0];
                buffer[1] = points[index];
                buffer[2] = points[(index+1 < count) ? (index+1) : (count-1)];
                buffer[3] = points[(index+2 < count) ? (index+2) : (count-1)];
            }

            p = buffer;
        }

        q[1].X = -a3*p[0].X + p[1].X + a3*p[2].X;
        q[1].Y = -a3*p[0].Y + p[1].Y + a3*p[2].Y;
        q[2].X =  a3*p[1].X + p[2].X - a3*p[3].X;
        q[2].Y =  a3*p[1].Y + p[2].Y - a3*p[3].Y;
        q[3] = p[2];

        q += 3;
    }

    return bezierPoints;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform all path points by the specified matrix
*
* Arguments:
*
*   matrix - Transform matrix
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpPath::Transform(
    GpMatrix *matrix
    )
{
    ASSERT(IsValid());

    if(matrix)
    {
        INT count = GetPointCount();
        GpPointF* points = Points.GetDataBuffer();

        matrix->Transform(points, count);
        UpdateUid();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   Status
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

// New codes

//#define USE_XBEZIER
//#define USE_WARP

GpStatus
GpPath::Flatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix *matrix
    ) const
{
#ifdef USE_WARP

    GpRectF bounds;

    GetBounds(&bounds);

    GpPointF quad[4];

    quad[0].X = bounds.X;
    quad[0].Y = bounds.Y;
    quad[1].X = bounds.X + bounds.Width;
    quad[1].Y = bounds.Y;
    quad[2].X = bounds.X;
    quad[2].Y = bounds.Y + bounds.Height;
    quad[3].X = bounds.X + bounds.Width;
    quad[3].Y = bounds.Y + bounds.Height;

    // Modify quad.

    quad[0].X += bounds.Width/4;
    quad[1].X -= bounds.Width/4;

    return WarpAndFlatten(matrix, &quad[0], 4,
                bounds, WarpModePerspective);

#else

    ASSERT(matrix);

    FPUStateSaver fpuState;  // Setup the FPU state.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);
    INT count = Points.GetCount();
    INT i = 0;

#ifdef USE_XBEZIER
    GpXBezier bezier;
#else
    GpCubicBezier bezier;
#endif

    GpPointF *pts = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();

    INT tempCount;
    INT tempCount0;
    GpPointF *tempPts;
    BYTE *tempTypes;
    GpStatus status = Ok;

    DpPathIterator iter(pts, types, count);

    INT startIndex, endIndex;
    BOOL isClosed;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed) && status == Ok)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;
        INT lastCount0 = flattenTypes->GetCount();


        while(iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
                && status == Ok)
        {
            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier:
#ifdef USE_XBEZIER
                if(bezier.SetBeziers(
                    3,
                    &pts[typeStartIndex],
                    typeEndIndex - typeStartIndex + 1) == Ok)
#else
                if(bezier.SetBeziers(
                    &pts[typeStartIndex],
                    typeEndIndex - typeStartIndex + 1) == Ok)
#endif
                {
                    // The flattened the bezier.

                    const INT bezierBufferCount = 32;
                    GpPointF bezierBuffer[bezierBufferCount];
                    DynPointFArray bezierFlattenPts(
                                        &bezierBuffer[0],
                                        bezierBufferCount);

                    bezier.Flatten(&bezierFlattenPts, matrix);
                    tempCount = bezierFlattenPts.GetCount();

                    // Check if there is already the first point.
                    if(!isFirstPoint)
                        tempCount--;    // Don't add the first point.

                    if (tempCount > 0)
                    {

                        if((tempTypes = flattenTypes->AddMultiple(tempCount)) != NULL)
                        {
                            tempPts = bezierFlattenPts.GetDataBuffer();

                            if(!isFirstPoint)
                                tempPts++;  // Skip the first point.

                            flattenPoints->AddMultiple(tempPts, tempCount);
                            GpMemset(tempTypes, PathPointTypeLine, tempCount);
                            if(isFirstPoint)
                                tempTypes[0] = PathPointTypeStart;

                            isFirstPoint = FALSE;
                        }
                        else
                            status = OutOfMemory;

                    }

                }
                else
                    status =InvalidParameter;

                break;

            case PathPointTypeLine:
            default:
                tempCount0 = flattenPoints->GetCount();
                tempCount = typeEndIndex - typeStartIndex + 1;

                if(!isFirstPoint)
                    tempCount--;

                if((tempTypes = flattenTypes->AddMultiple(tempCount)) != NULL)
                {
                    tempPts = &pts[typeStartIndex];
                    if(!isFirstPoint)
                        tempPts++;
                    GpMemset(tempTypes, PathPointTypeLine, tempCount);
                    if(isFirstPoint)
                        tempTypes[0] = PathPointTypeStart;

                    flattenPoints->AddMultiple(
                        tempPts,
                        tempCount);

                    tempPts = flattenPoints->GetDataBuffer();

                    matrix->Transform(
                        tempPts + tempCount0,
                        tempCount);

                    isFirstPoint = FALSE;
                }

                break;
            }
        }

        // This is the end of the current subpath.  Close subpath
        // if necessary.

        if(isClosed)
        {
            BYTE* typeBuff = flattenTypes->GetDataBuffer();
            GpPointF* ptBuff = flattenPoints->GetDataBuffer();
            INT lastCount = flattenTypes->GetCount();
            if(lastCount > lastCount0 + 2)
            {
                // First, find the typical dimension of this path.
                // Here, the first non-zero distance of the original edges
                // is set to be a typical dimension.
                // If the bounds is easily available, we can use it.

                REAL maxError = 0;
                INT k = startIndex;
                while(k < endIndex && maxError <= 0)
                {
                    maxError = REALABS(pts[k + 1].X - pts[k].X)
                        + REALABS(pts[k + 1].Y - pts[k].Y);
                    k++;
                }

                if(maxError > 0)
                {
                    // Set the allowable error for this path to be
                    // POINTF_EPSOLON times the typical dimension of this path.

                    maxError *= POINTF_EPSILON;

                    // Check if the first and last point are within the floating point
                    // error range.

                    if(
                        (REALABS(ptBuff[lastCount - 1].X - ptBuff[lastCount0].X)
                            < maxError) &&
                        (REALABS(ptBuff[lastCount - 1].Y - ptBuff[lastCount0].Y)
                            < maxError)
                    )
                    {
                        // Regard the last point as the same as the first point.

                        lastCount--;
                        flattenTypes->SetCount(lastCount);
                        flattenPoints->SetCount(lastCount);
                    }
                }
            }
            typeBuff[lastCount - 1] |= PathPointTypeCloseSubpath;
        }
    }

    return status;

#endif  // End of USE_WARP
}


/**************************************************************************\
*
* Function Description:
*
* Flattens the control points and transform itself to the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   When matrix is NULL, the identity matrix is used.
*
* Return Value:
*
*   Status
*
* Created:
*
*   09/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Flatten(
    GpMatrix *matrix
    )
{
    if(!HasBezier)
    {
        if(matrix)
        {
            GpPointF* points = Points.GetDataBuffer();
            INT count = Points.GetCount();
            matrix->Transform(points, count);
        }
        return Ok;
    }

    const INT bufferSize = 32;
    BYTE typesBuffer[bufferSize];
    GpPointF pointsBuffer[bufferSize];

    DynByteArray flattenTypes(&typesBuffer[0], bufferSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], bufferSize);

    GpStatus status = Ok;
    GpMatrix identity;   // Identity matrix

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    status = Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status != Ok)
        return status;

    INT flattenCount = flattenPoints.GetCount();
    Points.Reset(FALSE);
    Types.Reset(FALSE);
    Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
    Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
    HasBezier = FALSE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Warp and flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    return xpath.Flatten(flattenTypes, flattenPoints, matrix);
}

/**************************************************************************\
*
* Function Description:
*
* Warps and flattens the control points and transform itself to
* the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   The identity matrix is used when matrix is NULL.
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlattenSelf(
    GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpMatrix identity;   // Identity matrix

    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    const INT bufferSize = 32;
    BYTE typesBuffer[bufferSize];
    GpPointF pointsBuffer[bufferSize];

    DynByteArray flattenTypes(&typesBuffer[0], bufferSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], bufferSize);

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    GpStatus status = xpath.Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status == Ok)
    {
        INT flattenCount = flattenPoints.GetCount();
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
        Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
        HasBezier = FALSE;

        UpdateUid();
        InvalidateCache();
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*  
*   convert a 2 segment closed subpath emitted by the region conversion
*   to a correct winding path.
*
* Arguments:
*
*   [IN] p - the path.
*
* Created:
*
*   09/21/2000 asecchia
*       Created it.
*
\**************************************************************************/

struct PathBound
{
    REAL xmin;
    REAL ymin;
    REAL xmax;
    REAL ymax;
    INT count;
    GpPointF *points;
    BYTE *types;
    bool reverse;
    
    void Init(INT c, GpPointF *p, BYTE *t)
    {
        reverse = false;
        points = p;
        types = t;
        count = c;
    }
};

void ComputeBoundingBox(
    GpPathPointIterator &i, 
    PathBound *p
)
{
    GpPointF *point = i.CurrentItem();
    p->xmax = p->xmin = point->X;
    p->ymax = p->ymin = point->Y;
    
    while(!i.IsDone())
    {
        point = i.CurrentItem();
        if(point->X < p->xmin) { p->xmin = point->X; }
        if(point->X > p->xmax) { p->xmax = point->X; }
        if(point->Y < p->ymin) { p->ymin = point->Y; }
        if(point->Y > p->ymax) { p->ymax = point->Y; }
        i.Next();
    }
}

bool Contains(PathBound &pb1, PathBound &pb2)
{
    return ( 
        (pb1.xmin <= pb2.xmin) &&
        (pb1.ymin <= pb2.ymin) &&
        (pb1.xmax >= pb2.xmax) &&
        (pb1.ymax >= pb2.ymax)     
    );
}

void ConvertRegionOutputToWinding(GpPath **p)
{
    GpPathPointIterator iPoints(
        (GpPointF*)(*p)->GetPathPoints(),
        (BYTE*)(*p)->GetPathTypes(),
        (*p)->GetPointCount()
    );
    
    GpSubpathIterator iSubpath(&iPoints);
    
    GpPointF *points;
    BYTE *types;
    INT count;
    GpPath *ret = new GpPath(FillModeWinding);
    
    // if we're out of memory, simply give them back their path.
    
    if(!ret) { return; }
    
    GpPath *sub;
    DynArray<PathBound> bounds;
    PathBound pb;
    
    // Iterate through all the subpaths culling information for the following
    // algorithm. This is O(n) in the number of points. 
    // The information we need is the starting point for each subpath and
    // the bounding box.
    
    while(!iSubpath.IsDone())
    {
        count = -iSubpath.CurrentIndex();
        points = iSubpath.CurrentItem();
        types = iSubpath.CurrentType();
        iSubpath.Next();
        count += iSubpath.CurrentIndex();
        
        GpPathPointIterator iSubpathPoint( points, types, count );
        
        pb.Init(count, points, types);
        ComputeBoundingBox( iSubpathPoint, &pb );
        bounds.Add(pb);
    }
    
    // Double loop through all the subpaths figuring out the containment 
    // relationships.
    // For every level of containment, flip the reverse bit.
    // E.g. for a subpath that's contained by 5 other rectangles, start at
    // false and apply 5x(!)   !!!!!false == true  which means flip this path.
    // this is O(n^2) in the number of subpaths.
    
    count = bounds.GetCount();
    int i, j;
    
    for(i=1; i<count; i++)
    {
        for(j=i-1; j>=0; j--)
        {
            if(Contains(bounds[i], bounds[j]))
            {
                bounds[j].reverse = !bounds[j].reverse;
                continue;
            }
            
            if(Contains(bounds[j], bounds[i]))
            {
                bounds[i].reverse = !bounds[i].reverse;
            }
        }
    }
    
    // Now reverse all the subpaths that need to be reversed.
    // Accumulate the results into the array.
    
    for(i=0; i<count; i++)
    {
        sub = new GpPath(
            bounds[i].points, 
            bounds[i].types, 
            bounds[i].count
        );
        
        if(bounds[i].reverse)
        {
            sub->Reverse();
        }
        
        ret->AddPath(sub, FALSE);
        
        delete sub;
    }
    
    delete *p;
    *p = ret;
}

/**************************************************************************\
*
* Function Description:
*
* Returns the widened path.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   path
*
* Created:
*
*   06/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPath(
    const GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    ) const
{
    return GetWidenedPathWithDpPen(
        (const_cast<GpPen *>(pen))->GetDevicePen(),
        matrix,
        dpiX,
        dpiY,
        widenFlags
    );
}

 
GpPath*
GpPath::GetWidenedPathWithDpPen(
    const DpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    ) const
{
    ASSERT(pen);
    
    BOOL regionToPath = (widenFlags & WidenEmitDoubleInset) == 0;
    
    // Don't pass this flag down to the widener.
    
    widenFlags &= ~WidenEmitDoubleInset;
    
    if ((REALABS(dpiX) < REAL_EPSILON) || 
        (REALABS(dpiY) < REAL_EPSILON)    )
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    if( (pen->PenAlignment != PenAlignmentInset) &&
        (pen->PenAlignment != PenAlignmentOutset)   )
    {
        // Use the standard widening code for non-inset or non-outset pen.

        return GetWidenedPathWithDpPenStandard(
            pen,
            matrix,
            dpiX,
            dpiY,
            widenFlags,
            FALSE          // standard pen
        );
    }
    else
    {
        // Do the Inset Pen.
        
        // Our technique is as follows. See the inset pen spec in the 
        // gdiplus\specs directory.
        // First, inset pen is defined as widening to the inside of the path
        // which only has meaning for closed segments. Behaviour for open 
        // segments is unchanged (center pen).
        // We widen the path at 2x the stroke width using a center pen.
        // For round dash caps, we use a double-round or 'B' cap. We also
        // mirror the compound line pattern across the spine of the path.
        // Then we import the widened path as a region and clip against the
        // original path converted to a region. What's left is a region 
        // which contains the widened inset pen. This is converted to a path
        // and we're done.

        // Copy the pen. Note that this will copy the *pointer* to the Brush
        // but this is ok because the DpPen (insetPen) doesn't have a 
        // destructor and so won't attempt to free any state.
        
        // We will need an insetPen for the closed subpath segments and a
        // centerPen for the open subpath segments.
        
        DpPen insetPen = *pen;
        DpPen centerPen = *pen;
        
        // Use a double width center pen and then clip off the outside creating
        // a single width insetPen.
        
        insetPen.Width *= 2.0f;
        insetPen.PenAlignment = PenAlignmentCenter;
        centerPen.PenAlignment = PenAlignmentCenter;
        
        // Copy the compound array duplicating the compound array in reverse
        // and rescaling back to [0,1] interval (i.e. mirror along the spine).
        
        if( pen->CompoundCount > 0)
        {
            insetPen.CompoundArray = (REAL*)GpMalloc(
               sizeof(REAL)*insetPen.CompoundCount*2
            );
            
            // Check the GpMalloc for out of memory.
            
            if(insetPen.CompoundArray == NULL)
            {
                return NULL;
            }
            
            // Copy the pen->CompoundArray and duplicate it in reverse (mirror).
            // rescale to the interval [0, 1]
            
            for(INT i=0; i<insetPen.CompoundCount; i++)
            {
                // copy and scale range [0, 1] to [0, 0.5]
                
                insetPen.CompoundArray[i] = pen->CompoundArray[i]/2.0f;
                
                // copy and scale range [0, 1] to [0.5, 1] reversed.
                
                insetPen.CompoundArray[insetPen.CompoundCount*2-i-1] = 
                    1.0f - pen->CompoundArray[i]/2.0f;
            }
            
            // we have double the number of entries now.
            
            insetPen.CompoundCount *= 2;
        }

        // This is an optimized codepath used by our strokepath rasterizer in
        // the driver. We simply ask for the double widened inset/outset
        // path and ask the code not to do the region to path clipping because
        // the stroke path code in the driver has a much more efficient way of
        // performing the clipping using the VisibleClip. This saves us from
        // rasterizing the widened path into a region at device resolution.
        
        if(!regionToPath)
        {            
            GpPath *widenedPath = GetWidenedPathWithDpPenStandard(
                &insetPen,
                matrix,
                dpiX,
                dpiY,
                widenFlags,
                TRUE            // Inset/Outset pen?
            );
            
            if(pen->CompoundCount > 0)
            {
                // we allocated a new piece of memory, throw it away.
                // Make sure we're not trying to throw away the original pen
                // CompoundArray - only free the temporary one if we created it.
                
                ASSERT(insetPen.CompoundArray != pen->CompoundArray);
                GpFree(insetPen.CompoundArray);
                insetPen.CompoundArray = NULL;
            }
            
            return widenedPath;
        }


        // Create an iterator to step through each subpath.
        
        GpPathPointIterator pathIterator(
            (GpPointF*)GetPathPoints(),
            (BYTE*)GetPathTypes(),
            GetPointCount()
        );
        
        GpSubpathIterator subPathIterator(
            &pathIterator
        );
        
        // Some temporary variables.
        
        GpPointF *points;
        BYTE *types;
        INT subPathCount;
        GpPath *widenedPath = NULL;
        GpPath *subPath = NULL;
        bool isClosed = false;

        // Accumulate the widened sub paths in this returnPath.
                
        GpPath *returnPath = new GpPath(FillModeWinding);
        
        // loop while there are more subpaths and the returnPath is not NULL
        // This implicitly checks that returnPath was allocated correctly.
        
        while(returnPath && !subPathIterator.IsDone())
        {   
            // Get the data for the current subpath.
                
            points = subPathIterator.CurrentItem();
            types = subPathIterator.CurrentType();
            subPathCount = -subPathIterator.CurrentIndex();
            subPathIterator.Next();
            subPathCount += subPathIterator.CurrentIndex();

            // Create a path object representing the current sub path.
            
            subPath = new GpPath(points, types, subPathCount);
            
            if(!subPath)
            {
                // failed the allocation.
                
                delete returnPath;
                returnPath = NULL;
                break;
            }

            // Is this subpath closed?
            
            isClosed = bool(
                (types[subPathCount-1] & PathPointTypeCloseSubpath) ==
                PathPointTypeCloseSubpath
            );

            // Widen the subPath with the inset pen for closed and
            // center pen for open.
            
            widenedPath = subPath->GetWidenedPathWithDpPenStandard(
                (isClosed) ? &insetPen : &centerPen,
                matrix,
                dpiX,
                dpiY,
                widenFlags,
                isClosed            // Inset/Outset pen?
            );
                    
            // don't need the subPath anymore - we have the widened version.
            
            delete subPath;
            subPath = NULL;
            
            // Check if the widener succeeded.
            
            if(!widenedPath || !widenedPath->IsValid())
            {
                delete widenedPath;
                widenedPath = NULL;
                delete returnPath;
                returnPath = NULL;
                break;
            }
            
            if(isClosed)
            {
                // Region to path.
                
                // The widenedPath has already been transformed by the widener
                // according to the matrix. Use the identity to convert the 
                // widenedPath to a region, but use the matrix to transform the
                // (still untransformed) original matrix to a region.
                
                GpMatrix identityMatrix;
                GpMatrix *scaleMatrix = &identityMatrix;
                
                if(matrix)
                {
                    scaleMatrix = matrix;
                }
                
                DpRegion srcRgn(widenedPath, &identityMatrix);
                DpRegion clipRgn((DpPath*)(this), scaleMatrix);// const and type cast.
        
                // Clip the region
                
                GpStatus clip = Ok;
                
                if(pen->PenAlignment == PenAlignmentInset)
                {
                    // Inset pen is an And operation.
                    
                    clip = srcRgn.And(&clipRgn);
                }
                else
                {
                    ASSERT(pen->PenAlignment == PenAlignmentOutset);
                    
                    // Outset pen is an Exclude operation.
                    
                    clip = srcRgn.Exclude(&clipRgn);
                }
                
                GpPath *clippedPath;
                
                if(clip == Ok)
                {  
                    clippedPath = new GpPath(&srcRgn);
                    
                    ConvertRegionOutputToWinding(&clippedPath);
                    
                    if(!clippedPath)
                    {
                        delete widenedPath;
                        widenedPath = NULL;
                        delete returnPath;
                        returnPath = NULL;
                        break;
                    }
                    
                    // Accumulate the current subpath that we've just clipped
                    // for inset/outset into the final result.
                    
                    returnPath->AddPath(clippedPath, FALSE);
                    
                    delete clippedPath;
                    clippedPath = NULL;
                }
            }
            else
            {
                // Accumulate the center pen widened path for the open
                // subpath segment.
                
                returnPath->AddPath(widenedPath, FALSE);
            }
        
            delete widenedPath;
            widenedPath = NULL;
        }
        
        // clean up.
                
        if(pen->CompoundCount > 0)
        {
            // we allocated a new piece of memory, throw it away.
            // Make sure we're not trying to throw away the original pen
            // CompoundArray - only free the temporary one if we created it.
            
            ASSERT(insetPen.CompoundArray != pen->CompoundArray);
            GpFree(insetPen.CompoundArray);
            insetPen.CompoundArray = NULL;
        }
        
        return returnPath;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The sweep phase of a mark-sweep path point deletion algorithm
*   This will delete all points marked with PathPointTypeInternalUse.
*
*   If it deletes a start marker, it'll make the next valid point a start
*   point.
* 
*   NOTE:
*   If the algorithm encounters a closed subpath marker it will simply 
*   delete it. Because this algorithm is used for trimming the ends of 
*   open subpath segments (during endcapping), this is the desired behaviour, 
*   but may not be strictly correct for other uses.
*   
*   The points to be deleted are marked by oring in the 
*   PathPointTypeInternalUse flag. This flag is used by the widener as an 
*   internal flag and as a deletion mask for this code. These two usages 
*   do not (and should not) overlap.
*
* Created:
*
*   10/07/2000 asecchia
*       created it.
*
\**************************************************************************/

VOID GpPath::EraseMarkedSegments()
{
    // Get pointers to the source buffers.
    
    GpPointF *dstPoints = Points.GetDataBuffer();
    BYTE *dstTypes =  Types.GetDataBuffer();
    INT count = Points.GetCount();
    
    
    INT delete_count = 0;
    INT i=0;
    GpPointF *srcPoints = dstPoints;
    BYTE *srcTypes = dstTypes;
    
    bool deleted_start_marker = false;
    
    while(i<count)
    {
        // Skip all the points marked for deletion.
        
        if((*srcTypes) & PathPointTypeInternalUse)
        {
            delete_count++;
            
            // if we ever encounter a start marker, keep track of that fact.
            
            deleted_start_marker |= 
                (((*srcTypes) & PathPointTypePathTypeMask) == PathPointTypeStart);
        }
        else
        {
            // If we have deleted some stuff, move the data up.
            
            if(srcTypes!=dstTypes)
            {
                *dstPoints = *srcPoints;
                *dstTypes = *srcTypes;
                
                // if we deleted a start marker in the last deletion run, 
                // make the next non-deleted point a start marker.
                // Note: if the whole subpath is marked for deletion and
                // it's the last subpath, then we won't do this code because
                // we'll terminate the while loop first. This protects against
                // overwriting our buffer.
                
                if(deleted_start_marker)
                {
                    *dstTypes &= ~PathPointTypePathTypeMask;
                    *dstTypes |= PathPointTypeStart;
                }
            }
            
            deleted_start_marker = false;
        
            // increment to the next element.
            
            dstPoints++;
            dstTypes++;
        }
        
        // increment these every iteration through the loop.
        
        srcTypes++;
        srcPoints++;
        i++;
    }
    
    // update the DynArrays so that they reflect the new (deleted) count.
    
    Points.AdjustCount(-delete_count);
    Types.AdjustCount(-delete_count);
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a widened version of the path.
*
* Return
* 
*   GpPath - the widened path. NULL if this routine fails.
*
* Arguments:
*
*   [IN]     pen
*   [IN]     matrix
*   [IN]     dpiX     - the X-resolution.
*   [IN]     dpiY     - the Y-resolution.
*   [IN]     widenFlags
*   [IN]     insetPen - flag specifying if inset pen is being used.
*
*
* Created:
*
*   10/05/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPathWithDpPenStandard(
    const DpPen *pen,
    GpMatrix *matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags,
    BOOL insetPen
    ) const
{
    GpStatus status = Ok;
    
    // This is a const function. We cannot modify 'this' so we clone
    // the path in order to flatten it.
    
    GpPath* path = this->Clone();
    if(path == NULL) { return NULL; }
    path->Flatten();
    
    // Fragment the path if requested.
    // This must be done before widening as dashes and compound lines would
    // render differently otherwise.
    
    if(widenFlags & WidenRemoveSelfIntersects)
    {
        path->RemoveSelfIntersections();
        if(!path->IsValid())
        {
            delete path;
            return NULL;
        }
    }

    // Do all the path decorations before widening. This is to ensure that
    // the decorations have all of the original path information to operate
    // on --- the widening/decoration process is lossy so they have to be
    // performed in the right order.
    
    // First apply the end caps. This decoration must be applied before 
    // dashing the path.
    // Need to loop through all the subpaths, apply the end caps and 
    // fix up the path segments so they don't exit the cap incorrectly.
    // put all the caps in a path for later use. We will apply these caps
    // when we're done widening.
    
    GpPath *caps = NULL;
    
    {    
        // Create an instance of the GpEndCapCreator which will create
        // our endcap aggregate path.
        
        GpEndCapCreator ecc(
            path, 
            const_cast<DpPen*>(pen), 
            matrix, 
            dpiX, dpiY,
            (widenFlags & WidenIsAntiAliased) == WidenIsAntiAliased
        );
        
        // CreateCapPath will mark the points in the path for deletion if 
        // it's necessary to trim the path to fit the cap.
        
        status = ecc.CreateCapPath(&caps);
        if(status != Ok) 
        { 
            return NULL; 
        }
        
        // Remove the points marked for deletion in the cap trimming step.
        
        path->EraseMarkedSegments();
    }
    
    // Apply the dash decorations. Note that this will bounce on an empty path.
    
    GpPath* dashPath = NULL;

    if( (pen) && 
        (pen->DashStyle != DashStyleSolid) &&
        (path->GetPointCount() > 0)
    )
    {
        // the width is artificially expanded by 2 if the pen is inset. 
        // we need to factor this into the dash length and scale by 0.5.
        
        dashPath = path->CreateDashedPath(
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            (insetPen) ? 0.5f : 1.0f
        );
        
        // If we successfully got a dashed version of *path, delete
        // the old one and return the new one.
        
        if(dashPath)
        {
            delete path;
            path = dashPath;
        }
    }
    
    // Only do the widening if we have some points left in our 
    // path after trimming
    
    if(path->GetPointCount() > 0)
    {
        // Create a widener object. Note that if path has no points left, this
        // will bounce immediately with an invalid widener.
    
        GpPathWidener widener(
            path,
            pen,
            matrix,
            insetPen
        );
        
        // We're done with this now.
        
        //delete path;
        //path = NULL;
    
        // Check if we have a valid Widener object.
        
        if(!widener.IsValid()) 
        { 
            status = OutOfMemory; 
        }
    
        // Get the widened path.
    
        if(status == Ok) 
        { 
            GpPath *tmpPath = new GpPath(FillModeWinding);
            status = widener.Widen(tmpPath); 
            delete path;
            path = tmpPath;
        }
    }
    else
    {
        delete path;
        path = caps;
        caps = NULL;
    }

    // paranoid checking the return from the widener.
    
    if((status == Ok) && (path != NULL))
    {
        // Add the endcaps to the widened path. AddPath will bounce a NULL 
        // caps pointer with InvalidParameter. For our purposes that is 
        // considered correctly handled and we continue. 
        
        path->AddPath(caps, FALSE);
        
        // Transform the result to device space.
                                    
        if(path)
        {
            if((widenFlags & WidenDontFlatten))
            {
                path->Transform(matrix);
            }
            else
            {
                path->Flatten(matrix);
            }
        }
    }
    
    // Delete the caps before returning. If we had caps, we've copied them
    // into path, otherwise caps is NULL. Or we failed to widen. Either way
    // we must not leak memory.
    
    delete caps;
    caps = NULL;

    return path;
}

/**************************************************************************\
*
* Function Description:
*
* This widenes itself.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   09/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WidenSelf(
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    )
{
    GpMatrix matrix1;  // Identity matrix

    if(matrix)
        matrix1 = *matrix;

    GpPath* widenedPath = GetWidenedPath(
                            pen,
                            &matrix1,
                            dpiX,
                            dpiY,
                            widenFlags);

    if(widenedPath)
    {
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        INT count = widenedPath->GetPointCount();
        Points.AddMultiple(widenedPath->Points.GetDataBuffer(), count);
        Types.AddMultiple(widenedPath->Types.GetDataBuffer(), count);
        SubpathCount = widenedPath->SubpathCount;
        HasBezier = widenedPath->HasBezier;
        Flags = widenedPath->Flags;
        FillMode = FillModeWinding;
        delete widenedPath;

        GpStatus status = Ok;

        InvalidateCache();
        UpdateUid();

        return status;
    }
    else
        return OutOfMemory;
}

// Get the flattened path.

const DpPath *
GpPath::GetFlattenedPath(
    GpMatrix* matrix,
    DpEnumerationType type,
    const DpPen* pen,
    BOOL isAntiAliased,
    REAL dpiX,
    REAL dpiY,
    BOOL regionToPath
    ) const
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    GpPath* flattenedPath = NULL;

    if(type == Flattened)
    {
        const INT bufferCount = 32;
        BYTE flattenTypesBuffer[bufferCount];
        GpPointF flattenPointsBuffer[bufferCount];

        DynByteArray flattenTypes(&flattenTypesBuffer[0], bufferCount);
        DynPointFArray flattenPoints(&flattenPointsBuffer[0], bufferCount);

        GpStatus status = Ok;
        GpMatrix identity;   // Identity matrix

        if(matrix == NULL)
            matrix = &identity;

        status = Flatten(&flattenTypes, &flattenPoints, matrix);

        flattenedPath = new GpPath(
                            flattenPoints.GetDataBuffer(),
                            flattenTypes.GetDataBuffer(),
                            flattenPoints.GetCount(),
                            GetFillMode());
    }
    else if(type == Widened)
    {
        DWORD widenFlags = 0;
        if(isAntiAliased)
        {
            widenFlags |= WidenIsAntiAliased;
        }
        if(!regionToPath)
        {
            widenFlags |= WidenEmitDoubleInset;
        }
        flattenedPath = GetWidenedPathWithDpPen(
            pen,
            matrix,
            dpiX,
            dpiY,
            widenFlags
        );
    }

    return flattenedPath;
}



/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpMatrix* matrix)
{
    GpMatrix m;

    if(matrix)
        m = *matrix;

    GpRegion rgn(this);

    if(rgn.IsValid())
        return rgn.IsVisible(point, &m, isVisible);

    *isVisible = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path outline.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] pen - A pen to draw the outline.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*   [IN] dpiX - x-resolution of the device.
*   [IN] dpiY - y-resolution of the device.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsOutlineVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    )
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    // If the given pen is not a solid line,
    // clone the pen and set its dash type to Solid.
    // We do line hit testing in solid lines.

    GpPen* pen1 = NULL;
    if(pen && pen->GetDashStyle() != DashStyleSolid)
    {
        pen1 = pen->Clone();
        if(pen1)
           pen1->SetDashStyle(DashStyleSolid);
    }
    else
        pen1 = pen;

    if(pen1 == NULL)
    {
        *isVisible = FALSE;
        return Ok;
    }

    // Create a widened path in the transformed coordinates.

    GpPath* widenedPath = GetWidenedPath(
                            pen1,
                            matrix,
                            dpiX,
                            dpiY,
                            0          // Use aliased widening.
                            );

    if(pen1 != pen)
        delete pen1;

    GpStatus status = Ok;

    if(widenedPath)
    {
        // Since the widened path is already transformed, we have to
        // transform the given point.

        GpPointF    transformedPoint = *point;
        if(matrix)
            matrix->Transform(&transformedPoint);

        status = widenedPath->IsVisible(&transformedPoint, isVisible, NULL);
        delete widenedPath;
    }
    else
    {
        *isVisible = FALSE;
    }

    return status;
}

// Is the current dash segment a line segment?
// If false it's a space segment.

inline bool IsLineSegment(GpIterator<REAL> &dashIt)
{
    // line segment starts on even indices.

    return bool( !(dashIt.CurrentIndex() & 0x1) );
}

// Emit a line segment if it is not degenerate.
// Return true if emitted, false if degenerate

bool EmitLineSegment(
    GpPathPointIterator &dstPath,
    GpPointF p0,
    GpPointF p1,
    bool isLineStart
)
{
    GpPointF *currentPoint;
    BYTE *currentType;

    if( (REALABS(p0.X-p1.X) < REAL_EPSILON) &&
        (REALABS(p0.Y-p1.Y) < REAL_EPSILON) )
    {
        // Don't emit a line segment if it has zero length.
        return false;
    }

    // If the last emitted line ends at the same point that this next
    // one starts, we don't need a new start record.

    if(isLineStart)
    {
        // start point.
        currentPoint = dstPath.CurrentItem();
        *currentPoint = p0;
        currentType = dstPath.CurrentType();
        *currentType = PathPointTypeStart | PathPointTypeDashMode;

        dstPath.Next();
    }

    // end point.
    currentPoint = dstPath.CurrentItem();
    *currentPoint = p1;
    currentType = dstPath.CurrentType();
    *currentType = PathPointTypeLine | PathPointTypeDashMode;

    dstPath.Next();

    return true;
}

INT
getDashData(
    BYTE* newTypes,
    GpPointF* newPts,
    INT estimateCount,
    REAL dashOffset,
    const REAL* dashArray,
    INT dashCount,
    const BYTE* types,
    const GpPointF* points,
    INT numOfPoints,
    BOOL isClosed,
    const REAL* distances
    )
{
    ASSERT(estimateCount >= numOfPoints);
    ASSERT(types && points);

    // Code assumes first point != last point for closed paths.  If first
    // point == last point, decrease point count
    if (isClosed && numOfPoints &&
        points[0].X == points[numOfPoints-1].X &&
        points[0].Y == points[numOfPoints-1].Y)
    {
        numOfPoints--;
    }


    if(!newTypes || !newPts)
    {
        return 0;
    }

    // Make the iterators.

    GpArrayIterator<GpPointF> pathIterator(
        const_cast<GpPointF*>(points),
        numOfPoints
    );
    GpArrayIterator<REAL> pathBaseDistance(
        const_cast<REAL*>(distances),
        numOfPoints
    );
    
    GpPathPointIterator dstPath(newPts, newTypes, estimateCount);
    
    GpArrayIterator<REAL> dashBaseIterator(
        const_cast<REAL*>(dashArray),
        dashCount
    );

    // Compute the length of the dash

    REAL dashLength = 0.0f;
    while(!dashBaseIterator.IsDone())
    {
        dashLength += *(dashBaseIterator.CurrentItem());
        dashBaseIterator.Next();
    }
    ASSERT(dashLength > -REAL_EPSILON);


    // Do the offset initialization.

    dashBaseIterator.SeekFirst();

    REAL distance = GpModF(dashOffset, dashLength);
    REAL delta;

    // Compute the position in the dash array corresponding to the
    // specified offset.

    while(!dashBaseIterator.IsDone())
    {
        delta = *(dashBaseIterator.CurrentItem());
        if(distance < delta)
        {
            // set to the remaining piece of the dash.
            distance = delta-distance;
            break;
        }
        distance -= delta;
        dashBaseIterator.Next();
    }

    // The dashIterator is now set to point to the correct
    // dash for the first segment.

    // These are circular arrays to repeat the dash pattern.

    GpCircularIterator<REAL> dashIterator(&dashBaseIterator);


    // This is the distance into the current dash segment that we're going
    // to start at.

    REAL currentDashLength = distance;
    REAL currentSegmentLength;

    GpPointF p0, p1;
    GpVector2D sD;     // segment direction.

    // Used to track if we need to emit a segment start record.

    bool emittedPathSegment = false;

    if(isClosed)
    {
        // set up everything off the last item and then point to
        // the first item to start the process.

        pathBaseDistance.SeekFirst();

        pathIterator.SeekLast();
        p0 = *(pathIterator.CurrentItem());

        pathIterator.SeekFirst();
        p1 = *(pathIterator.CurrentItem());

        // get the distance between the first and last points.

        GpVector2D seg = p1-p0;
        currentSegmentLength = seg.Norm();
    }
    else
    {
        // Get the first point in the array.

        p0 = *(pathIterator.CurrentItem());

        // already initialized to the first point, start on the next one.

        pathIterator.Next();
        pathBaseDistance.Next();

        // distance between point n and point n+1 is stored in
        // distance[n+1]. distance[0] is the distance between the first
        // and last points.

        currentSegmentLength = *(pathBaseDistance.CurrentItem());
    }

    // reference the distances as circular so that we can simplify the
    // internal algorithm by not having to check when we query for the
    // next segment in the last iteration of the loop.

    GpCircularIterator<REAL> pathDistance(&pathBaseDistance);

    while( !pathIterator.IsDone() )
    {
        if(currentDashLength > currentSegmentLength)
        {
            // The remaining dash segment length is longer than the remaining
            // path segment length.
            // Finish the path segment.

            // Note that we've moved along the dash segment.

            currentDashLength -= currentSegmentLength;

            p1 = *(pathIterator.CurrentItem());

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment. If we're emitting a series of path
                // segments to complete one dash, we can't have any start
                // records inbetween the segments otherwise we'll end up with
                // spurious endcaps in the middle of the lines.

                emittedPathSegment = EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }
            else
            {
                emittedPathSegment = false;
            }

            p0 = p1;

            // Keep these two in sync.

            pathDistance.Next();
            pathIterator.Next();

            currentSegmentLength = *(pathDistance.CurrentItem());
        }
        else
        {
            // The remaining path segment length is longer than the remaining
            // dash segment length.
            // Finish the dash segment.

            // Compute position between start and end point of the current
            // path segment where we finish with this dash segment.

            ASSERT(REALABS(currentSegmentLength)>REAL_EPSILON);
            sD = *(pathIterator.CurrentItem());
            sD -= p0;
            sD *= currentDashLength/currentSegmentLength;

            // Move along the path segment by the amount left in the
            // dash segment.

            currentSegmentLength -= currentDashLength;

            p1 = p0 + sD;

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment.

                EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }

            p0 = p1;

            // dashIterator is circular, so this should keep wrapping through
            // the dash array.

            dashIterator.Next();

            // Get the new dash length.

            currentDashLength = *(dashIterator.CurrentItem());
            emittedPathSegment = false;
        }
    }
    
    INT size = dstPath.CurrentIndex();

    if(!isClosed)
    {
        // For open line segments, 
        dstPath.SeekLast();
        
        GpPointF *originalPoint = points + numOfPoints - 1;
        GpPointF *dashPoint = dstPath.CurrentItem();
        BYTE *type = dstPath.CurrentType();
        
        
        if( REALABS(originalPoint->X-dashPoint->X) < REAL_EPSILON &&
            REALABS(originalPoint->Y-dashPoint->Y) < REAL_EPSILON )
        {
            // last point == last dashed point, whack out the dashed mode.
            
            *type &= ~PathPointTypeDashMode;
        }
        
        // repoint to the beginning.

        dstPath.SeekFirst();
        originalPoint = points;
        GpPointF *dashPoint = dstPath.CurrentItem();
        type = dstPath.CurrentType();

        if( REALABS(originalPoint->X-dashPoint->X) < REAL_EPSILON &&
            REALABS(originalPoint->Y-dashPoint->Y) < REAL_EPSILON )
        {
            // last point == last dashed point, whack out the dashed mode.
            
            *type &= ~PathPointTypeDashMode;
        }
    }

    // return the number of entries added to the dstPath array.

    return (size);
}

/**************************************************************************\
*
* Function Description:
*
* Creates a dashed path.
*
* Arguments:
*
*   [IN] pen - This pen contains the dash info.
*   [IN] matrix - The transformation where the dash patterns are calculated.
*                   But the dashed path is transformed back to the World
*                   coordinates.
*   [IN] dpiX - x-resolution.
*   [IN] dpiY - y-resolution.
*
* Return Value:
*
*   returns a dashed path.
*
* Created:
*
*   01/27/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::CreateDashedPath(
    const GpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale
    ) const
{
    if(pen == NULL)
        return NULL;

    DpPen* dpPen = ((GpPen* ) pen)->GetDevicePen();

    return CreateDashedPath(dpPen, matrix, dpiX, dpiY, dashScale);
}

/**************************************************************************\
*
* Function Description:
*
* Returns TRUE if the given points have non-horizontal or non-vertical
*   edges.
*
*
* Created:
*
*   04/07/2000 ikkof
*       Created it.
*
\**************************************************************************/

inline
BOOL
hasDiagonalEdges(
    GpPointF* points,
    INT count
    )
{
    if(!points || count <= 1)
        return FALSE;

    GpPointF *curPt, *nextPt;
    curPt = points;
    nextPt = points + 1;

    BOOL foundDiagonal = FALSE;
    INT i = 1;

    while(!foundDiagonal && i < count)
    {
        if((curPt->X == nextPt->X) || (curPt->Y == nextPt->Y))
        {
            // This is either horizontal or vertical edges.
            // Go to the next edge.

            curPt++;
            nextPt++;
            i++;
        }
        else
            foundDiagonal = TRUE;
    }

    return foundDiagonal;
}

GpPath*
GpPath::CreateDashedPath(
    const DpPen* dpPen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale
    ) const
{
    FPUStateSaver::AssertMode();


    GpPointF* points = Points.GetDataBuffer();
    INT numOfPoints = GetPointCount();

    if(dpPen == NULL)
        return NULL;

    if(
        dpPen->DashStyle == DashStyleSolid ||
        dpPen->DashCount == 0 ||
        dpPen->DashArray == NULL
    )
        return NULL;

    REAL penWidth = dpPen->Width;
    GpUnit unit = dpPen->Unit;
    BOOL isWorldUnit = TRUE;

    REAL dashUnit;
    {
        // The minimum pen width 
        REAL minimumPenWidth = 1.0f;
        
        if(REALABS(dashScale-0.5f) < REAL_EPSILON)
        {
            minimumPenWidth = 4.0f;
        }
        
        if(unit != UnitWorld)
        {
            isWorldUnit = FALSE;
            penWidth = ::GetDeviceWidth(penWidth, unit, dpiX);
    
            // Prevent the extremely thin line and dashes.
    
            dashUnit = max(penWidth, minimumPenWidth);
        }
        else
        {
            REAL majorR, minorR;
    
            // Calculate the device width.
    
            ::GetMajorAndMinorAxis(&majorR, &minorR, matrix);
            REAL maxWidth = penWidth*majorR;
            REAL minWidth = penWidth*minorR;
    
            // If the device width becomes less than 1, stretch the penWidth
            // so that the device width becomes 1.
            // If we're doing the inset pen, then the path is scaled up double
            // in size and we need to scale by the inverse.
            // Also, the minimum pen width needs to be 2 not 1 in this case 
            // because we will remove half the line width. dashScale is 1/2 
            // in this case so we divide by it.
    
            dashUnit = penWidth;
            
            if(maxWidth < minimumPenWidth)
            {
                dashUnit = minimumPenWidth/majorR;
            }
        }
    }

    dashUnit *= dashScale;

    GpMatrix mat, invMat;

    if(matrix)
    {
        mat = *matrix;
        invMat = mat;
    }

    if(invMat.IsInvertible())
    {
        invMat.Invert();
    }
    else
    {
        WARNING(("Inverse matrix does not exist."));

        return NULL;
    }

    INT dashCount = dpPen->DashCount;
    REAL* dashArray = (REAL*) GpMalloc(dashCount*sizeof(REAL));
    if(dashArray)
    {
        GpMemcpy(dashArray, dpPen->DashArray, dashCount*sizeof(REAL));

        // Adjust the dash interval according the stroke width.

        for(INT i = 0; i < dashCount; i++)
        {
            dashArray[i] *= dashUnit;
        }
    }
    else
    {
        return NULL;
    }

    GpPath* newPath = Clone();

    if(newPath && newPath->IsValid())
    {
        // Flatten in the resolution given by the matrix.

        newPath->Flatten(&mat);

        if(isWorldUnit)
        {
            // Transform back to the World Unit.
            // When the pen is in WorldUnit, transform the path
            // before detDashData() is called.

            newPath->Transform(&invMat);
        }

        BYTE *types = newPath->Types.GetDataBuffer();
        points = newPath->Points.GetDataBuffer();
        numOfPoints = newPath->GetPointCount();

        GpPointF* grad = (GpPointF*) GpMalloc((numOfPoints + 1)*sizeof(GpPointF));
        REAL* distances = (REAL*) GpMalloc((numOfPoints + 1)*sizeof(REAL));

        if(grad == NULL || distances == NULL)
        {
            GpFree(grad);
            GpFree(dashArray);
            delete newPath;

            return NULL;
        }

        // Calculate the distance of each segment.

        INT i;

        REAL dashLength = 0;

        for(i = 0; i < dashCount; i++)
            dashLength += dashArray[i];

        // Make sure count is an even number.

        if(dashCount & 0x01)
            dashCount ++;

        DynByteArray dashTypes;
        DynPointFArray dashPoints;

        BYTE* newTypes = NULL;
        GpPointF* newPts = NULL;

        DpPathIterator iter(points, types, numOfPoints);

        INT startIndex, endIndex;
        BOOL isClosed;
        REALD totalLength = 0;
        INT totalCount = 0;
        BOOL isSingleSubpath = iter.GetSubpathCount() == 1;

        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpPointF startPt, lastPt, nextPt;
            REAL dx, dy;
            REALD length;
            startPt = points[startIndex];
            lastPt = startPt;

            totalLength = 0;
            INT k = 0;
            INT segmentCount = endIndex - startIndex + 1;

            CalculateGradientArray(grad, distances,
                points + startIndex, segmentCount);

            for(i = 1; i < segmentCount; i++)
                totalLength += distances[i];

            if(isClosed)
                totalLength += distances[0];

            // Estimate the required points.

            INT estimateCount
                = GpCeiling(TOREAL(totalLength*dashCount/dashLength))
                    + numOfPoints;

            // For extra caution, multiply by 2.

            estimateCount <<= 1;

            // Allocate new types and buffers

            if(newTypes)
            {
                BYTE* newTypes1 = (BYTE*) GpRealloc(
                                            newTypes,
                                            estimateCount*sizeof(BYTE));
                if(newTypes1)
                    newTypes = newTypes1;
                else
                    goto cleanUp;
            }
            else
            {
                newTypes = (BYTE*) GpMalloc(estimateCount*sizeof(BYTE));
                if(!newTypes)
                    goto cleanUp;
            }

            if(newPts)
            {
                GpPointF* newPts1 = (GpPointF*) GpRealloc(
                                                newPts,
                                                estimateCount*sizeof(GpPointF));
                if(newPts1)
                    newPts = newPts1;
                else
                    goto cleanUp;
            }
            else
            {
                newPts = (GpPointF*) GpMalloc(estimateCount*sizeof(GpPointF));
                if(!newPts)
                    goto cleanUp;
            }

            AdjustDashArrayForCaps(
                dpPen->DashCap,
                dashUnit,
                dashArray,
                dashCount
            );
 
            // Fix for Whistler Bug 178774
            // Since dash caps are no longer 'inset' when they are rendered,
            // it is possible that on closed paths, the dash caps on the start
            // and end of a closed path will overlap. This offset will leave
            // sufficient space for the two caps. However, this fix is not
            // bullet-proof. It will *always* work if the Dash Offset is 0.
            // However, if it is non-zero, it is possible that the offset
            // will counter-act the adjustment and there will be some dash
            // overlap at the start/end of closed paths. I believe this is
            // acceptable since VISIO 2000, Office 9 and PhotoDraw 2000 v2
            // also have the collision problem.
            // The real solution is to enforce a minimum spacing between the
            // start and end or merge the start/end segments if they collide.

            REAL dashCapOffsetAdjustment = 0.0f;
            if (isClosed)
            {
                dashCapOffsetAdjustment =
                    2.0f * GetDashCapInsetLength(dpPen->DashCap, dashUnit);
            }

            INT newCount = getDashData(
                newTypes,
                newPts,
                estimateCount,
                // Shouldn't the offset be scaled dashUnit instead of penWidth?
                dpPen->DashOffset * penWidth - dashCapOffsetAdjustment,
                dashArray,
                dashCount,
                types + startIndex,
                points + startIndex,
                endIndex - startIndex + 1,
                isClosed,
                distances
            );

            if(newCount)
            {
                newTypes[0] = PathPointTypeStart;
                if(isClosed)
                {
                    newTypes[0] |= PathPointTypeDashMode;
                    newTypes[newCount - 1] |= PathPointTypeDashMode;
                }
                else
                {
                    newTypes[0] &= ~PathPointTypeDashMode;
                    newTypes[newCount - 1] &= ~PathPointTypeDashMode;
                }
                dashTypes.AddMultiple(newTypes, newCount);
                dashPoints.AddMultiple(newPts, newCount);
            }

        }

        totalCount = dashPoints.GetCount();
        if(totalCount > 0)
        {
            GpPathData pathData;
            pathData.Count = totalCount;
            pathData.Types = dashTypes.GetDataBuffer();
            pathData.Points = dashPoints.GetDataBuffer();

            newPath->SetPathData(&pathData);

            if(!isWorldUnit)
            {
                // Transform back to the World Unit.
                // When the pen is in WorldUnit, it is already transformed
                // before detDashData() is called.

                newPath->Transform(&invMat);
            }

        }
        else
        {
            delete newPath;
            newPath = NULL;
        }

        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);

        return newPath;

cleanUp:
        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);
        delete newPath;

        return NULL;
    }
    else
    {
        GpFree(dashArray);

        if(newPath)
            delete newPath;

        return NULL;
    }
}


/**************************************************************************\
*
* Function Description for RemoveSelfIntersections,
*
*   Removes self intersections from the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   06/16/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::RemoveSelfIntersections()
{
    PathSelfIntersectRemover corrector;
    DynPointFArray newPoints;  // Array that will hold the new points.
    DynIntArray polyCounts;    // Array that will hold the numPoints for each
                               // new polygon.
    INT numPolys;              // count of new polygons created
    INT numPoints;             // count of new points created
    GpStatus status;           // holds return status of commmands

    Flatten();

    INT       pointCount = Points.GetCount();
    GpPointF *pathPts    = Points.GetDataBuffer();
    BYTE     *pathTypes  = Types.GetDataBuffer();

    if (pointCount == 0)
    {
        return Ok;
    }

    // Add the subpaths to the Path corrector
    INT ptIndex=0; // ptIndex tracks the current index in the array of points.
    INT count=0;   // the size of the current subpath.

    // Init the corrector with the number of points we will be adding.
    if ((status = corrector.Init(pointCount)) != Ok)
    {
        return status;
    }

    while (ptIndex < pointCount)
    {
        if (pathTypes[ptIndex] == PathPointTypeStart && ptIndex != 0)
        {
            // Add the next subpath to the PathCorrector. the start index of the subpath is
            // determined using the current index minus the current subPath size.
            if ((status =
                corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
            {
                return status;
            }
            // set count to 1 since this is the first point in the new subpath
            count = 1;
        } else
        {
            count++;
        }
        ptIndex++;
    }
    // Add the last subpath that is implicitly ended by the last point.
    if (ptIndex != 0)
    {
        // Add the next subpath to the PathCorrector. the start index of the subpath is
        // determined using the current index minus the current subPath size.
        if ((status =
            corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
        {
            return status;
        }
    }

    if ((status = corrector.RemoveSelfIntersects()) != Ok)
    {
        return GenericError;
    }

    if ((status = corrector.GetNewPoints(&newPoints, &polyCounts)) != Ok)
    {
        return OutOfMemory;
    }

    // clear out the old path data so we can replace with the newly corrected one.
    Reset();

    // Now that we have the corrected path, add it back.
    GpPointF *curPoints = newPoints.GetDataBuffer();
    for (INT i=0;i<polyCounts.GetCount();i++)
    {
        if ((status = AddPolygon(curPoints,polyCounts[i])) != Ok)
        {
            // We're not stable if AddPolygon fails.
            SetValid(FALSE);
            return status;
        }

        curPoints += polyCounts[i];
    }

    return Ok;
}


VOID DpPath::InitDefaultState(GpFillMode fillMode)
{
    HasBezier = FALSE;
    FillMode = fillMode;
    Flags = PossiblyNonConvex;
    IsSubpathActive = FALSE;
    SubpathCount = 0;

    Types.Reset(FALSE);     // FALSE - don't free the memory
    Points.Reset(FALSE);    // FALSE - don't free the memory

    SetValid(TRUE);
    UpdateUid();
}

DpPath::DpPath(const DpPath* path)
{
    if(path)
    {
        HasBezier = path->HasBezier;
        FillMode = path->FillMode;
        Flags = path->Flags;
        IsSubpathActive = path->IsSubpathActive;
        SubpathCount = path->SubpathCount;

        BYTE *types = path->Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        INT count = path->GetPointCount();

        SetValid((count == 0) || ((Types.AddMultiple(types, count) == Ok) &&
                                  (Points.AddMultiple(points, count) == Ok)));
    }
    else
        SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Offset all path points by the specified amount
*
* Arguments:
*
*   dx, dy - Amount to offset along x- and y- direction
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
DpPath::Offset(
    REAL dx,
    REAL dy
    )
{
    ASSERT(IsValid());

    INT count = GetPointCount();
    GpPointF* pts = Points.GetDataBuffer();

    if (count > 0)
    {
        UpdateUid();
    }
    while (count--)
    {
        pts->X += dx;
        pts->Y += dy;
        pts++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create a driver DpPath class.
*
* Arguments:
*
*   [IN] fillMode - Specify the path fill mode
*
* Return Value:
*
*   IsValid() is FALSE if failure.
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DpPath::DpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags pathFlags
    ) : Types(stackTypes, stackCount), Points(stackPoints, stackCount)
{
    ASSERT((fillMode == FillModeAlternate) ||
           (fillMode == FillModeWinding));

    InitDefaultState(fillMode);
    Flags = pathFlags;

    // We can call this method with no points, just to set up
    // the stackPoints/stackTypes

    if (count > 0)
    {
        BYTE *types;

        if ((types = Types.AddMultiple(count)) != NULL)
        {
            *types++ = PathPointTypeStart;
            GpMemset(types, PathPointTypeLine, count - 1);
            SetValid(Points.AddMultiple(points, count) == Ok);

            if(IsValid()) 
            {
                IsSubpathActive = TRUE;
                SubpathCount = 1;
            }
        }
        else
        {
            SetValid(FALSE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Close the currently active subpath in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigure()
{
    ASSERT(IsValid());

    // Check if there is an active subpath

    if (IsSubpathActive)
    {
        // If so, mark the last point as the end of a subpath

        Types.Last() |= PathPointTypeCloseSubpath;
        StartFigure();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Close all open subpaths in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigures()
{
    ASSERT(IsValid());

    // Go through all path points.
    // Notice that the loop index starts from 1 below.

    INT i, count = GetPointCount();
    BYTE* types = Types.GetDataBuffer();

    for (i=1; i < count; i++)
    {
        if (types[i] == PathPointTypeStart)
            types[i-1] |= PathPointTypeCloseSubpath;
    }

    if (count > 1)
        types[count-1] |= PathPointTypeCloseSubpath;

    StartFigure();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the bounds of a path
*
* Arguments:
*
*   [OUT] bounds - Specify the place to stick the bounds
*   [IN] matrix - Matrix used to transform the bounds
*   [IN] pen - the pen data.
*   [IN] dpiX, dpiY - the resolution of x and y directions.
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::GetBounds(
    GpRect *bounds,
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    GpRectF boundsF;

    FPUStateSaver fpuState;

    GpStatus status = GetBounds(&boundsF, matrix, pen, dpiX, dpiY);

    if(status == Ok)
        status = BoundsFToRect(&boundsF, bounds);

    return status;
}

VOID
GpPath::CalcCacheBounds() const
{

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if(count <= 1)
    {
        ResetCacheBounds();
        return;
    }

    REAL left, right, top, bottom;

    left   = point->X;
    right  = left;
    top    = point->Y;
    bottom = top;

    INT i;
    for (i = 1, point++; i < count; i++, point++)
    {
        if (point->X < left)
        {
            left = point->X;
        }
        else if (point->X > right)
        {
            right = point->X;
        }

        if (point->Y < top)
        {
            top = point->Y;
        }
        else if (point->Y > bottom)
        {
            bottom = point->Y;
        }
    }
    CacheBounds.X = left;
    CacheBounds.Width = right - left;
    CacheBounds.Y = top;
    CacheBounds.Height = bottom - top;

    if(CacheBounds.Width < POINTF_EPSILON && CacheBounds.Height < POINTF_EPSILON)
    {
        ResetCacheBounds();
        return;
    }

    CacheFlags = kCacheBoundsValid;

}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the sharpest angle in a path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/04/2000 asecchia
*       Created it.
*
* Remarks:
*
*   This is an expensive function, if it's ever used in a performance 
*   critical scenario it should be recoded to use the dot product of the
*   segments and perform the angle comparison in the cosine domain.
*   The cost of normalizing the vectors should be cheaper than the 
*   atan algorithm used below.
*
*
\**************************************************************************/

VOID
GpPath::CalcSharpestAngle() const
{
    if(CacheFlags & kSharpestAngleValid)
    {
        return;
    }

    UpdateCacheBounds();

    // Walk the path and find the smallest angle between two 
    // adjacent segments.
    
    GpPathPointIterator pIter(
        (GpPointF*)GetPathPoints(),
        (BYTE*)GetPathTypes(),
        GetPointCount()
    );
    
    GpSubpathIterator pSubpath(&pIter);
    
    GpPointF *points;
    BOOL isClosed;
    
    GpPointF *p0, *p1;
    GpVector2D v;
    REAL lastAngle;
    REAL currAngle;
    REAL minAngle = 2*PI;
    REAL tempAngle;
    bool first = true;
    INT iter, i;
    
    
    while(!pSubpath.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = pSubpath.CurrentIndex();
        points = pSubpath.CurrentItem();
        pSubpath.Next();
        INT elementCount = pSubpath.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pIter.Prev();
        isClosed = (*(pIter.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath;
        pIter.Next();
        
        // Create a GpPointF iterator.
        
        GpArrayIterator<GpPointF> iSubpath(points, elementCount);
        GpCircularIterator<GpPointF> iCirc(&iSubpath);
        
        // Initialize the first point.
        
        p0 = iCirc.CurrentItem();
        iCirc.Next();
        iter = elementCount;
        first = true;
        
        // include the endpoint wrap if it's closed
        
        if(isClosed)
        {
            iter += 2;
        }
        
        for(i = 1; i < iter; i++)
        {
            // Get the current point.
            
            p1 = iCirc.CurrentItem();
            
            // Translate to the origin and compute the angle between this line
            // and the x axis.
            // atan2 returns values in the -PI..PI range.
            
            v = (*p1)-(*p0);
            currAngle = (REAL)atan2(v.Y, v.X);

            // If we have enough data to do an angle computation, work it out.
            // We require two line segments to do a computation (3 end points).
            // If it's closed, we'll loop around the subpath past the beginning
            // again in order to get the right amount of points.
                       
            if( !first )
            {
                // reverse the direction of the last segment by adding PI and
                // compute the difference.
                
                tempAngle = lastAngle + PI;     // range 0 .. 2PI
                
                // Clamp back to the -PI..PI range
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                // Difference
                
                tempAngle = currAngle - tempAngle;
                
                // Clamp back to the -PI..PI range
                // Note that the extremes are tempAngle either -2PI or 2PI
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                if(tempAngle < -PI)
                {
                    tempAngle += 2*PI;
                }
                
                // new minimum angle?
                // We care about angle magnitude - not sign.
                
                if( minAngle > REALABS(tempAngle) )
                {
                    minAngle = REALABS(tempAngle);
                }
                
            }
            
            // iterate
            
            first = false;
            lastAngle = currAngle;
            iCirc.Next();
            p0 = p1;
        }
    }
    
    SharpestAngle = minAngle;
    CacheFlags |= kSharpestAngleValid;
}

GpStatus
GpPath::GetBounds(
    GpRectF *bounds,                // Resulting bounds in device-space
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    ASSERT(IsValid());

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if ((count == 0) || (point == NULL))
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        REAL left, right, top, bottom;

        UpdateCacheBounds();

        left = CacheBounds.X;
        right = left + CacheBounds.Width;
        top = CacheBounds.Y;
        bottom = top + CacheBounds.Height;

        TransformBounds(matrix, left, top, right, bottom, bounds);

        if(pen)
        {
            BOOL needsJoinDelta = TRUE, needsCapDelta = TRUE;

            if(count <= 2)
                needsJoinDelta = FALSE;

            // Make a quick check for closure only when the path has
            // only 1 subpath.  When there are multiple subpaths,
            // simply calclate the cap width although all subpaths may
            // be closed.  But the multiple subpath case will be rarer
            // compared with the one subpath case.

            if(SubpathCount == 1 && count > 2)
            {
                if(Types.Last() & PathPointTypeCloseSubpath)
                {
                    // This is closed.

                    needsCapDelta = FALSE;
                }
            }

            REAL delta = 0;
            GpPen* gpPen = GpPen::GetPen(pen);

            if(needsCapDelta)
                delta = gpPen->GetMaximumCapWidth(matrix, dpiX, dpiY);

            if(needsJoinDelta)
            {
                // Since the join might be a miter type, we need to provide the
                // sharpest angle in the path to see how big the join will be.
                // We have the method GetSharpestAngle() that figues this out.
                // But, this is really expensive since you have to iterate over
                // all the points and do some trig. So, lets assume the worst
                // case, which is a really sharp angle (0 rad).
                const REAL sharpestAngle = 0.0f;
                REAL delta1 = gpPen->GetMaximumJoinWidth(
                            sharpestAngle, matrix, dpiX, dpiY);
                if(delta1 > delta)
                    delta = delta1;
            }

            // Only pad the bounds if there is something non-zero to pad
            if (bounds->Width > REAL_EPSILON ||
                bounds->Height > REAL_EPSILON)
            {
                bounds->X -= delta;
                bounds->Y -= delta;
                bounds->Width += 2*delta;
                bounds->Height += 2*delta;
            }

        }
    }

    return Ok;
}

// This code is not used at present and is contributing to our DLL size, so 
// it's removed from compilation. We're keeping this code because we want to 
// revisit it in V2

#if 0
GpPath*
GpPath::GetCombinedPath(
    const GpPath* path,
    CombineMode combineMode,
    BOOL closeAllSubpaths
    )
{
    if(combineMode == CombineModeReplace)
    {
        ASSERTMSG(0, ("CombineModeReplace mode cannot be used."));
        return NULL;    // Replace mode is not allowed.
    }

    return GpPathReconstructor::GetCombinedPath(
                this, path, (PRMode) combineMode, closeAllSubpaths);
}
#endif

/*************************************************\
* AddGlyphPath
* History:
*
*   Sept/23/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************/
GpStatus
GpPath::AddGlyphPath(
    GpGlyphPath* glyphPath,
    REAL x,
    REAL y,
    const GpMatrix * matrix
)
{
    ASSERT(IsValid());
    ASSERT(glyphPath->IsValid());

    if (!IsValid() || !glyphPath->IsValid())
        return InvalidParameter;

    INT count = glyphPath->pointCount;

    if (count == 0)  // nothing to add
        return Ok;

    GpPointF* points = (GpPointF*) glyphPath->points;
    BYTE* types = glyphPath->types;

    if (glyphPath->hasBezier)
        HasBezier = TRUE;

    INT origCount = GetPointCount();
    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if (!pointbuf || !typebuf)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // apply the font xform

    for (INT i = 0; i < count; i++)
    {
        pointbuf[i] = points[i];
        if (matrix)
            matrix->Transform(pointbuf + i);
        pointbuf[i].X += x;
        pointbuf[i].Y += y;
    }

    GpMemcpy(typebuf, types, count*sizeof(BYTE));
    SubpathCount += glyphPath->curveCount;
    UpdateUid();

    return Ok;
}


/*************************************************\
* AddString()
* History:
*
*   19th Oct 199  dbrown  created
*
\************************************************/
GpStatus
GpPath::AddString(
    const WCHAR          *string,
    INT                   length,
    const GpFontFamily   *family,
    INT                   style,
    REAL                  emSize,
    const RectF          *layoutRect,
    const GpStringFormat *format
)
{
    FPUStateSaver fpuState; // Guarantee initialised FP context
    ASSERT(string && family && layoutRect);

    GpStatus      status;
    GpTextImager *imager;

    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        family,
        style,
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Allow use of simple text imager
    );

    if (status != Ok)
    {
        return status;
    }

    status = imager->AddToPath(this, &PointF(layoutRect->X, layoutRect->Y));
    delete imager;
    UpdateUid();
    return status;
}


// !!! why not convert to a DpRegion and convert it to a path the same way
// as the constructor that takes a DpRegion?
GpPath::GpPath(HRGN hRgn)
{
    ASSERT((hRgn != NULL) && (::GetObjectType(hRgn) == OBJ_REGION));

    InitDefaultState(FillModeWinding);

    ASSERT(IsValid());

    BYTE stackBuffer[1024];

    // If our stack buffer is big enough, get the clipping contents
    // in one gulp:

    RGNDATA *regionBuffer = (RGNDATA*)&stackBuffer[0];
    INT newSize = ::GetRegionData(hRgn, sizeof(stackBuffer), regionBuffer);

    // The spec says that  GetRegionData returns '1' in the event of
    // success, but NT returns the actual number of bytes written if
    // successful, and returns '0' if the buffer wasn't large enough:

    if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
    {
        // Our stack buffer wasn't big enough.  Figure out the required
        // size:

        newSize = ::GetRegionData(hRgn, 0, NULL);
        if (newSize > 1)
        {
            regionBuffer = (RGNDATA*)GpMalloc(newSize);
            if (regionBuffer == NULL)
            {
                SetValid(FALSE);
                return;
            }

            // Initialize to a decent result in the unlikely event of
            // failure of GetRegionData:

            regionBuffer->rdh.nCount = 0;

            ::GetRegionData(hRgn, newSize, regionBuffer);
        }
    }

    // Add the rects from the region to the path

    if(regionBuffer->rdh.nCount > 0)
    {
        if (this->AddRects((RECT*)&(regionBuffer->Buffer[0]),
                           regionBuffer->rdh.nCount) != Ok)
        {
            SetValid(FALSE);
        }
    }

    // Free the temporary buffer if one was allocated:

    if (regionBuffer != (RGNDATA*) &stackBuffer[0])
    {
        GpFree(regionBuffer);
    }
}

// create a path from a GDI+ region
GpPath::GpPath(
    const DpRegion*     region
    )
{
    InitDefaultState(FillModeAlternate);

    if (region == NULL)
    {
        return;
    }

    RegionToPath    convertRegion;
    DynPointArray   pointsArray;

    if (convertRegion.ConvertRegionToPath(region, pointsArray, Types))
    {
        int             count;
        int             i;
        GpPointF *      realPoints;
        GpPoint *       points;

        count  = Types.GetCount();

        if ((count <= 0) || (pointsArray.GetCount() != count) ||
            (!ValidatePathTypes(Types.GetDataBuffer(), count, &SubpathCount, &HasBezier)))
        {
            goto NotValid;
        }
        // else it is valid

        // add all the space for the count in the Points up front
        realPoints = Points.AddMultiple(count);
        if (realPoints == NULL)
        {
            goto NotValid;
        }

        // add the points, converting from int to real
        points = pointsArray.GetDataBuffer();
        i = 0;
        do
        {
            realPoints[i].X = (REAL)points[i].X;
            realPoints[i].Y = (REAL)points[i].Y;
        } while (++i < count);

        SetValid(TRUE);

        // Make sure the first point is the start type.
        ASSERT(Types[0] == PathPointTypeStart);

        return;
    }

NotValid:
    WARNING(("Failed to convert a region to a path"));
    this->Reset();
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Adjust the dash array for dash caps if present.
*
*   Note that unlike line caps, dash caps do not extend the length
*   of the subpath, they are inset. So we shorten the dash segments
*   that draw a line and lengthen the dash segments that are spaces
*   by a factor of 2x the dash unit in order to leave space for the
*   caps that will be added by the widener.
*
*   This fixes Whistler bug #126476.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - dash size - typically the pen width
*   [IN/OUT] dashArray - array containing the dash pattern that is adjusted.
*   [IN] dashCount - count of elements in the dash array
*
* Return Value:
*
*   None.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
\**************************************************************************/

VOID
GpPath::AdjustDashArrayForCaps(
    GpLineCap dashCap,
    REAL dashUnit,
    REAL *dashArray,
    INT dashCount
    ) const
{
    REAL adjustmentLength = 2.0f *
        GetDashCapInsetLength(dashCap, dashUnit);

    if (adjustmentLength > 0.0f)
    {
        const REAL minimumDashValue = dashUnit * 0.001f; // a small number
        for (int i = 0; i < dashCount; i++)
        {
            if (i & 0x1) // index is odd - so this is a space
            {
                // lengthen the spaces
                dashArray[i] += adjustmentLength;
            }
            else // index is even - so this is a line
            {
                // shorten the lines
                dashArray[i] -= adjustmentLength;
                // check if we have made the dash too small
                // (as in the case of 'dots')
                if (dashArray[i] < minimumDashValue)
                {
                    dashArray[i] = minimumDashValue;
                }
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
* Computes the length of the inset required to accomodate a particular
* dash cap type, since dash caps are contained within the dash length.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - pen width
*
* Return Value:
*
*   The amount that a dash needs to be inset on each end in order to
*   accomodate any dash caps.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
\**************************************************************************/

REAL
GpPath::GetDashCapInsetLength(
    GpLineCap dashCap,
    REAL dashUnit
    ) const
{
    REAL insetLength = 0.0f;

	// dash caps can only be flat, round, or triangle
    switch(dashCap)
    {
    case LineCapFlat:
        insetLength = 0.0f;
        break;

    case LineCapRound:
    case LineCapTriangle:
        insetLength = dashUnit * 0.5f;
        break;
   }

   return insetLength;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a const pointer to the internal SubpathInfoCache. This structure
*   holds the data representing the position and size of each subpath in 
*   the path data structures.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID GpPath::GetSubpathInformation(DynArray<SubpathInfo> **info) const
{
    if((CacheFlags & kSubpathInfoValid) == 0)
    {
        ComputeSubpathInformationCache();
        ASSERT((CacheFlags & kSubpathInfoValid) == kSubpathInfoValid)
    }
    
    *info = &SubpathInfoCache;
}


/**************************************************************************\
*
* Function Description:
*
*   Computes the Subpath information cache and marks it as valid.
*   This code walks the entire path and stores the start and count for
*   each subpath. It also notes if the subpath is closed or open.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/
    
VOID GpPath::ComputeSubpathInformationCache() const
{
    // Get the path data:
    
    GpPointF *points = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();
    INT count = Points.GetCount();

    // Clear out any old cached subpath state.
    
    SubpathInfoCache.Reset();

    INT i = 0;  // current position in the path.
    INT c = 0;  // current count of the current subpath.

    // <= so that we can implicitly handle the last subpath without
    // duplicating the code for the inner loop.
    
    while(i <= count)
    {
        // i==count means we hit the end - and potentially need to look at
        // the last subpath. Otherwise look at the most recent subpath if 
        // we find a new start marker.
        
        if( ((i==count) || IsStartType(types[i])) && (i != 0))
        {
            // Found a subpath.
            
            SubpathInfo subpathInfo;
            
            subpathInfo.StartIndex = i-c;
            subpathInfo.Count = c;
            subpathInfo.IsClosed = IsClosedType(types[i-1]);
            
            SubpathInfoCache.Add(subpathInfo);
            
            // We're actually on the first point of the next subpath.
            // (or we're about to terminate the loop)
            
            c = 1;
        } 
        else
        {
            c++;
        }
        i++;
    }
    
    // Mark the subpath information cache as valid.
    
    CacheFlags |= kSubpathInfoValid;
}

/**************************************************************************\
*
* Function Description:
*
*   The widener needs to be able to add points one at a time and have it
*   automatically handle the start point. These points are always line segments.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus GpPath::AddWidenPoint(const GpPointF &points)
{
    INT origCount = GetPointCount();
    GpStatus statusPoint = Ok;
    GpStatus statusType = Ok;
    
    if(IsSubpathActive)
    {
        // Add the line segment.
        
        BYTE type = PathPointTypeLine;
        statusPoint = Points.Add(points);
        statusType = Types.Add(type);
    }
    else
    {
        // Add the first point and mark the flag.
        
        BYTE type = PathPointTypeStart;
        statusPoint = Points.Add(points);
        statusType = Types.Add(type);
        IsSubpathActive = TRUE;
    }
                     
    // Handle errors.
    
    if( (statusPoint != Ok) ||
        (statusType != Ok) )
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);
        return OutOfMemory;
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\ddiplus.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   ddiplus.hpp
*
* Abstract:
*
*   Contains the interface definition for the high-level GDI+ device
*   driver interface.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*                                 
*   03/11/1999 agodfrey
*       Changed the DDI model. For this version, I'm not using COM, and
*       we'll use the result to decide whether we should be using COM.
\**************************************************************************/

#ifndef _DDIPLUS_HPP
#define _DDIPLUS_HPP

// !! shift this to dpflat.hpp ?? 
// !! do we want to bother with namespaces for driver, they may link to
//    other stuff in GDI, and hence name clashes.

class EpPaletteMap;

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>

class DpOutputSpan;
class DpClipRegion;
class DpContext;
struct DpBrush;
struct DpPen;
class DpBitmap;
class DpDriver;
class DpRegion;
class DpDevice;
class EpScan;
class DpPath;
class DpCustomLineCap;
struct DpImageAttributes;
class DpCachedBitmap;

#define WINGDIPAPI __stdcall

// The naming convention is Dpc<function><object> for Driver callbacks
DpPath* WINGDIPAPI 
DpcCreateWidenedPath(
        const DpPath* path, 
        const DpPen* pen,
        DpContext* context,
        BOOL outline
        );
    
VOID WINGDIPAPI 
DpcDeletePath(
        DpPath* path
        );

DpPath* WINGDIPAPI
DpcClonePath(
        DpPath* path
        );

VOID WINGDIPAPI
DpcTransformPath(
        DpPath* path,
        GpMatrix* transform
        );

#include "dpregion.hpp"

// Hack: DpContext depends on GpRegion
#include "..\Entry\object.hpp"
#include "..\Entry\region.hpp"
// EndHack

#include "dpbitmap.hpp"
#include "dpbrush.hpp"
#include "dpcontext.hpp"
#include "dpdriver.hpp"
#include "dppath.hpp"
#include "dpcustomlinecap.hpp"
#include "dppen.hpp"
#include "dpscan.hpp"
#include "dppathiterator.hpp"
#include "dpimageattributes.hpp"
#include "dpcachedbitmap.hpp"

#endif // !_DDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\pen.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpPen class
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
*   01/06/1999 ikkof
*       Added the implementation of GpGeometricPen.
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

/**************************************************************************\
*
* Function Description:
*
* This converts the given width with the given physical unit to
* the device unit.  You cannot use this function when
* unit is WorldUnit.
*
* Arguments:
*
*   [IN] width  - the width in the given unit.
*   [IN] unit   - the unit of the width (must not be WorldUnit).
*   [IN] dpi    - dots per inch of the device.
*
* Return Value:
*
*   The device width.
*
*   04/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID GpPen::Set(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    if(DevicePen.DashArray)
        GpFree(DevicePen.DashArray);

    if(DevicePen.CompoundArray)
        GpFree(DevicePen.CompoundArray);


    InitDefaultState(penWidth, unit);

    if(Brush)
    {
        SetColor((GpColor *) &color);
    }
    else
    {
        Brush = new GpSolidFill(color);
        DevicePen.Brush = Brush->GetDeviceBrush();
    }

    UpdateUid();
}

GpPen::GpPen(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = new GpSolidFill(color);
    DevicePen.Brush = Brush->GetDeviceBrush();
}

GpPen::GpPen(GpBrush* brush, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = brush->Clone();
    DevicePen.Brush = Brush->GetDeviceBrush();
}

GpPen::GpPen(GpLineTexture* lineTexture, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !!! Needs to be implemented.
    // !!! Remember to change GdipCreatePen3 - it currently just returns
    //     NotImplemented.

    RIP(("GpPen with line texture not implemented"));
    SetValid(FALSE);
}

VOID GpPen::InitDefaultState(REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !! Look at DeviceBrush.Type
    DevicePen.Type = PenTypeSolidColor;
    DevicePen.Width = penWidth;
    DevicePen.Unit = unit;
    DevicePen.StartCap = LineCapFlat;
    DevicePen.EndCap = LineCapFlat;
    DevicePen.Join = LineJoinMiter;
    DevicePen.MiterLimit = 10;    // PS's default miter limit.
    DevicePen.PenAlignment = PenAlignmentCenter;

    DevicePen.DashStyle = DashStyleSolid;
    DevicePen.DashCap = LineCapFlat;
    DevicePen.DashCount = 0;
    DevicePen.DashOffset = 0;
    DevicePen.DashArray = NULL;

    DevicePen.CompoundCount = 0;
    DevicePen.CompoundArray = NULL;

    DevicePen.CustomStartCap = NULL;
    DevicePen.CustomEndCap = NULL;

    DevicePen.Xform.Reset();
    
    SetValid(TRUE);
    UpdateUid();
}

GpPen::GpPen(const GpPen* pen)
{
    GpStatus status = Ok;

    if(pen && pen->IsValid())
    {
        // Copy the base state.
        
        DevicePen = pen->DevicePen;
        
        // Don't copy pointer references to other objects.
        
        Brush = NULL;
        DevicePen.Brush = NULL;
        DevicePen.DashArray = NULL;
        DevicePen.CompoundArray = NULL;
        DevicePen.CustomStartCap = NULL;
        DevicePen.CustomEndCap = NULL;
        
        // Explicitly clone the pointer references to other objects.

        if(pen->Brush)
        {
            Brush = pen->Brush->Clone();
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            status = GenericError;
        }

        if( status == Ok )
        {   
            if( (pen->DevicePen.DashArray) && 
                (DevicePen.DashCount > 0)
            )
            {
                DevicePen.DashArray = (REAL*) GpMalloc(DevicePen.DashCount*sizeof(REAL));
                if(DevicePen.DashArray)
                {
                    GpMemcpy(DevicePen.DashArray, pen->DevicePen.DashArray, DevicePen.DashCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                // If there is no dash array data, this must be a solid line.
                
                ASSERT(DevicePen.DashStyle == DashStyleSolid);
    
                DevicePen.DashCount = 0;
                DevicePen.DashArray = NULL;
            }
        }

        // Set the compound array if necessary.

        if( status == Ok )
        {
            if( (pen->DevicePen.CompoundArray) && 
                (DevicePen.CompoundCount > 0)
            )
            {
                DevicePen.CompoundArray = (REAL*) GpMalloc(DevicePen.CompoundCount*sizeof(REAL));
                if(DevicePen.CompoundArray)
                {
                    GpMemcpy(DevicePen.CompoundArray, pen->DevicePen.CompoundArray, DevicePen.CompoundCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                DevicePen.CompoundCount = 0;
                DevicePen.CompoundArray = NULL;
            }
        }
        
        // Copy the start custom cap.

        if( status == Ok )
        {
            if( DevicePen.StartCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomStartCap == NULL)
                {
                    WARNING1("CustomStartCap type with NULL pointer");
                    DevicePen.StartCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomStartCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomStartCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }
        
        // Copy the end custom cap.

        if( status == Ok )
        {
            if( DevicePen.EndCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomEndCap == NULL)
                {
                    WARNING1("CustomEndCap type with NULL pointer");
                    DevicePen.EndCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomEndCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomEndCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }

    }
    else
    {
        // Can't make a valid pen from an invalid input pen.
        
        status = GenericError;    
    }
    
    if(status == Ok)
    {
        SetValid(TRUE);
    }
    else
    {
        // Failed cloning the pen.
        
        // Clean up possible memory allocation so we don't leak even under
        // low memory conditions. Note we rely on GpFree and delete handling
        // NULL pointers here.
        
        delete Brush;
        Brush = NULL;                   // InitializeDefaultState() does not set
        DevicePen.Brush = NULL;         // these fields - clear them explicitly.
        
        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
        
        delete DevicePen.CustomStartCap;
        delete DevicePen.CustomEndCap;
        
        // Clean the pen.
        
        InitDefaultState(1.0f, UnitWorld);
        
        // This is not a valid object.
        
        SetValid(FALSE);
    }
}

// Clone() return NULL if the cloning fails.

GpPen* GpPen::Clone()
{
    GpPen* clonedPen =  new GpPen(this);

    if(clonedPen && clonedPen->IsValid())
        return clonedPen;
    else
    {
        if(clonedPen)
            delete clonedPen;
        return NULL;
    }
}

GpStatus
GpPen::GetMaximumWidth(
        REAL* width,
        const GpMatrix* matrix) const
{
    if(DevicePen.Unit != UnitWorld)
        return InvalidParameter;

    GpMatrix trans;
    if(matrix)
        trans = *matrix;

    if(!DevicePen.Xform.IsTranslate())
        trans.Prepend(DevicePen.Xform);

    REAL majorR, minorR;

    ::GetMajorAndMinorAxis(&majorR, &minorR, &trans);
    majorR *= DevicePen.Width;
    minorR *= DevicePen.Width;

    if(minorR < 1.42f)   // This is a litte bit larger than sqrt(2).
    {
        minorR = 1.42f;
        majorR = 1.42f;
    }

    *width = majorR;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This function takes a join angle and computes the length of the miter
*   based on this angle and a given miter length limit.
*   This can be scaled by the pen width to give the length of an arbitrary
*   pen miter.
*
*   In this picture, 2a is the angle of the join. The pen width is w and the 
*   desired output is the length of the miter join (l).
*
*   Note that the line labled w is perpendecular to the inside and outside 
*   widended lines. Then the formula is derived as follows:
*
*         sin(a) = w/l   [opposite over hypotenuse on right angled triangle]
*    <=>  l = w/sin(a)
*
*
*                     /|\
*                    /a|a\
*                   /  |  \
*                  /   |   \
*                 /    |l   \
*                /     |     \ <-- right angle
*               /--__  |  __--\
*              /   w --|-- w   \
*             /       / \       \
*            /       /   \       \
*        outside     inside     outside
*
* NOTE: 
*
*   This routine returns the miter length (l) for a pen width w==1.0f. 
*   The caller is responsible for scaling length by the pen width.
*
*   If the length of 1/sin(a) is greater than the miterLimit, the miterLimit
*   is returned. (including infinite length joins).
*                        
* Arguments:
*
*   [IN] angle      - join angle in radians
*   [IN] miterLimit - maximum miter length (not scaled by pen width).
*
* Return Value:
*
*   Pen width independent miter length.
*
*   10/02/2000 asecchia
*       Created it.
*
\**************************************************************************/


REAL GpPen::ComputeMiterLength(
    REAL angle,
    REAL miterLimit
    )
{
    // use the simple miter join formula 
    // length = (penwidth)/sin(angle/2)
    // because we're pen independent, use 1.0 for pen width and rely
    // on the caller to scale by the pen width.
    
    REAL length = (REAL)sin(0.5*angle);
    
    // Check for an infinite miter...
    
    if(REALABS(length) < REAL_EPSILON)
    {
        return miterLimit;
    }
    
    length = 1.0f / length;
    
    return min(miterLimit, length);
}



REAL
GpPen::GetMaximumJoinWidth(
        REAL sharpestAngle,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL delta;

    if ((matrix != NULL) && (DevicePen.IsOnePixelWideSolid(matrix, dpiX)))
    {
        delta = 0.5;
    }
    else
    {
        REAL maximumWidth;
        REAL delta0;

        REAL scale = 1.0;

        switch(DevicePen.PenAlignment)
        {
        case PenAlignmentCenter:
            scale = 0.5f;
            break;

        case PenAlignmentLeft:
        case PenAlignmentRight:
            scale = 1.0f;
            break;

        case PenAlignmentInset:
            scale = 0.0f;
            break;

        case PenAlignmentOutset:
            scale = 1.0f;
            break;
        }

        if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
        {
            delta0 = maximumWidth;
        }
        else
        {
            maximumWidth = ::GetDeviceWidth(
                                DevicePen.Width,
                                DevicePen.Unit,
                                dpiX);
            delta0 = maximumWidth;
        }

        if(DevicePen.Join == LineJoinMiter)
        {
            REAL miterLimit = DevicePen.MiterLimit;

            delta = delta0*miterLimit;

            if(delta > 20)
            {
                delta = ComputeMiterLength(
                    sharpestAngle,
                    miterLimit
                );

                // scale by the pen width.
                
                delta *= delta0;
            }
        }
        else
        {
            delta = delta0;
        }

        delta *= scale;
    }

    return delta;
}

REAL
GpPen::GetMaximumCapWidth(
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL maximumWidth;
    REAL delta0;

    if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
    {
        delta0 = maximumWidth;
    }
    else
    {
        maximumWidth = ::GetDeviceWidth(
                            DevicePen.Width,
                            DevicePen.Unit,
                            dpiX);
        delta0 = maximumWidth;
    }

    REAL delta = delta0;

    GpLineCap startCap = DevicePen.StartCap;
    GpLineCap endCap = DevicePen.EndCap;

    REAL delta1;

    GpCustomLineCap* customCap = NULL;

    if(startCap == LineCapCustom && DevicePen.CustomStartCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomStartCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(startCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 1);
    }
    if(delta < delta1)
        delta = delta1;


    if(endCap == LineCapCustom && DevicePen.CustomEndCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomEndCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(endCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 2);
    }
    if(delta < delta1)
        delta = delta1;

    return delta;
}

VOID
GpPen::SetDashCap(GpDashCap dashCap)
{
    // Note: Internally we use a GpLineCap type to store the dash cap type.
    // So we need to convert between GpLineCap and GpDashCap.
    // However, we should change the internal usage to GpDashCap in v2.
    // - JBronsk
    GpLineCap lineCap = LineCapFlat;
    switch (dashCap)
    {
    case DashCapRound:
    	lineCap = LineCapRound;
    	break;
    case DashCapTriangle:
    	lineCap = LineCapTriangle;
    	break;
    // all others map to LineCapFlat
    }
    
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, lineCap);
    if(status == Ok)
    {
        DevicePen.DashCap = lineCap;
    }
}

#ifndef DCR_REMOVE_OLD_197819
VOID
GpPen::SetDashCap(GpLineCap dashCap)
{
    #ifdef DCR_DISABLE_OLD_197819
    WARNING(("DCR: Using disabled functionality 197819"));
    #endif // DCR_DISABLE_OLD_197819
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, dashCap);
    if(status == Ok)
        DevicePen.DashCap = dashCap;
}
#endif // DCR_REMOVE_OLD_197819

GpStatus
GpPen::SetDashStyle(
    GpDashStyle dashStyle
    )
{
    return SetDashStyleWithDashCap(dashStyle, DevicePen.DashCap);
}

GpStatus
GpPen::SetDashStyleWithDashCap(
    GpDashStyle dashStyle,
    GpLineCap dashCap
    )
{
    GpStatus status = Ok;
    REAL    style[6];
    INT     count;

    switch(dashStyle)
    {
    case DashStyleSolid:
        count = 0;
        break;

    case DashStyleDash:
        count = 2;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        break;

    case DashStyleDot:
        count = 2;
        style[0] = 1;   // a dot
        style[1] = 1;   // a space
        break;

    case DashStyleDashDot:
        count = 4;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        break;

    case DashStyleDashDotDot:
        count = 6;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        style[4] = 1;   // a dot
        style[5] = 1;   // a space
        break;
    
    case DashStyleCustom:
        
        // We assume that the custom dash has been set at the API.
        // The remaining code in this routine is for initializing an appropriate
        // dash array, which we already have in this case, so we're done.
        
        DevicePen.DashStyle = dashStyle;
        return Ok;

    default:
        // The dash style must be one of the predefined ones.
        status = InvalidParameter;
    }

    if(status != Ok)
    {
        return status;
    }

    if(DevicePen.DashCount < count)
    {
        REAL* newArray = (REAL*) GpMalloc(count*sizeof(REAL));

        if(newArray)
        {
            GpFree(DevicePen.DashArray);
            DevicePen.DashArray = newArray;
        }
        else
        {
            status = OutOfMemory;
        }
    }

    if(status == Ok)
    {
        // initialize the DashArray.
        GpMemcpy(DevicePen.DashArray, &style[0], count*sizeof(REAL));
        DevicePen.DashStyle = dashStyle;
        DevicePen.DashCount = count;
        UpdateUid();
    }

    return status;
}

GpStatus
GpPen::SetDashArray(
    const REAL* dashArray,
    INT count
    )
{
    ASSERT(dashArray && count > 0);

    // Make sure the all elements are positive.
    INT         i = 0;
    GpStatus    status = Ok;

    while(status == Ok && i < count)
    {
        if(dashArray[i++] <= 0)
            status = InvalidParameter;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.DashArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, dashArray, count*sizeof(REAL));

    DevicePen.DashStyle = DashStyleCustom;
    DevicePen.DashArray = newArray;
    DevicePen.DashCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetDashArray(
    REAL* dashArray,
    INT count
    ) const
{
    ASSERT(dashArray != NULL && count <= DevicePen.DashCount);

    GpStatus status = Ok;

    if(dashArray == NULL || count > DevicePen.DashCount)
        return InvalidParameter;

    if(DevicePen.DashArray)
        GpMemcpy(dashArray, DevicePen.DashArray, count*sizeof(REAL));
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpPen::SetCompoundArray(
    const REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray && count > 0);

    // count must be a positive even number.

    if(compoundArray == NULL || count <= 0 || (count & 0x01))
        return InvalidParameter;

    // Make sure the all elements are monitonically increasing
    // and its values are between 0 and 1.

    GpStatus    status = Ok;
    REAL        lastValue, nextValue;

    lastValue = compoundArray[0];
    if(lastValue < 0.0f || lastValue > 1.0f)
        status = InvalidParameter;

    INT i = 1;

    while(status == Ok && i < count)
    {
        nextValue = compoundArray[i++];
        if(nextValue < lastValue || nextValue > 1.0f)
            status = InvalidParameter;

        lastValue = nextValue;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.CompoundArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, compoundArray, count*sizeof(REAL));

    DevicePen.CompoundArray = newArray;
    DevicePen.CompoundCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetCompoundArray(
    REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray != NULL && count <= DevicePen.CompoundCount);

    if(compoundArray == NULL || count > DevicePen.CompoundCount)
        return InvalidParameter;

    if(DevicePen.CompoundArray && count > 0)
        GpMemcpy(compoundArray, DevicePen.CompoundArray, count*sizeof(REAL));

    return Ok;
}

GpStatus
GpPen::SetCustomStartCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomStartCap = NULL;
    DevicePen.StartCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomStartCap = customCap->Clone();
        DevicePen.StartCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomStartCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomStartCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomStartCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::SetCustomEndCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomEndCap = NULL;
    DevicePen.EndCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomEndCap = customCap->Clone();
        DevicePen.EndCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomEndCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomEndCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomEndCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DevicePen.Xform.Prepend(matrix);
        }
        else
        {
            DevicePen.Xform.Append(matrix);
        }
    }
    else
        status = InvalidParameter;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Answer true if the two pen instances are equivalent, meaning they
*   are indistinguishable when rendering.
*
* Arguments:
*
*   [IN] pen - pen to compare this against

* Return Value:
*
*   TRUE if equivalent.
*
* Created:
*
*   6/14/1999 peterost
*
\**************************************************************************/

BOOL
GpPen::IsEqual(
    const GpPen *  pen
    )
    const
{
    ASSERT(pen != NULL);

    if (pen == this)
        return TRUE;

    BOOL isEqual = TRUE;

    if (DevicePen.IsEqual(&pen->DevicePen) &&
        DevicePen.DashStyle == pen->DevicePen.DashStyle &&
        DevicePen.CompoundCount == pen->DevicePen.CompoundCount &&
        Brush->IsEqual(pen->Brush) &&
        DevicePen.Xform.IsEqual(&pen->DevicePen.Xform))
    {
        // We need to check the equality further if the dash style
        // is not a solid line.

        if (DevicePen.DashStyle != DashStyleSolid)
        {
            if(DevicePen.DashStyle != DashStyleCustom)
            {
                // A case of the preset dash pattern.
                // Check only for the offset difference.

                if(DevicePen.DashOffset != pen->DevicePen.DashOffset)
                    isEqual = FALSE;
            }
            else
            {
                if (DevicePen.DashCount == pen->DevicePen.DashCount &&
                    DevicePen.DashOffset == pen->DevicePen.DashOffset &&
                    DevicePen.DashArray != NULL &&
                    pen->DevicePen.DashArray != NULL)
                {
                    INT i = 0;

                    while(i < DevicePen.DashCount && isEqual)
                    {
                        if (DevicePen.DashArray[i] != pen->DevicePen.DashArray[i])
                        {
                            isEqual = FALSE;
                        }
                        i++;
                    }
                }
                else
                {
                    isEqual = FALSE;
                }
            }
        }

        // Check for the compound lines.

        if(isEqual && DevicePen.CompoundCount > 0)
        {
            if(DevicePen.CompoundArray && pen->DevicePen.CompoundArray)
            {
                INT j = 0;

                while(j < DevicePen.CompoundCount && isEqual)
                {
                    if(DevicePen.CompoundArray[j] != pen->DevicePen.CompoundArray[j])
                    {
                        isEqual = FALSE;
                    }
                    j++;
                }
            }
            else
            {
                isEqual = FALSE;
            }
        }
    }
    else
    {
        isEqual = FALSE;
    }

    return isEqual;
}

// For GetData and SetData methods
#define GDIP_PENFLAGS_TRANSFORM             0x00000001
#define GDIP_PENFLAGS_STARTCAP              0x00000002
#define GDIP_PENFLAGS_ENDCAP                0x00000004
#define GDIP_PENFLAGS_JOIN                  0x00000008
#define GDIP_PENFLAGS_MITERLIMIT            0x00000010
#define GDIP_PENFLAGS_DASHSTYLE             0x00000020
#define GDIP_PENFLAGS_DASHCAP               0x00000040
#define GDIP_PENFLAGS_DASHOFFSET            0x00000080
#define GDIP_PENFLAGS_DASHARRAY             0x00000100
#define GDIP_PENFLAGS_NONCENTER             0x00000200
#define GDIP_PENFLAGS_COMPOUNDARRAY         0x00000400
#define GDIP_PENFLAGS_CUSTOMSTARTCAP        0x00000800
#define GDIP_PENFLAGS_CUSTOMENDCAP          0x00001000

class PenData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Unit;
    REAL        Width;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the pen data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::GetData(
    IStream *   stream
    ) const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return Ok;
    }

    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (!DevicePen.Xform.IsIdentity())
    {
        flags |= GDIP_PENFLAGS_TRANSFORM;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_STARTCAP | GDIP_PENFLAGS_CUSTOMSTARTCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_STARTCAP;
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_ENDCAP | GDIP_PENFLAGS_CUSTOMENDCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_ENDCAP;
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        flags |= GDIP_PENFLAGS_JOIN;
    }

    if (DevicePen.MiterLimit != 10)
    {
        flags |= GDIP_PENFLAGS_MITERLIMIT;
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        flags |= GDIP_PENFLAGS_DASHSTYLE;
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        flags |= GDIP_PENFLAGS_DASHCAP;
    }

    if (DevicePen.DashOffset != 0)
    {
        flags |= GDIP_PENFLAGS_DASHOFFSET;
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        flags |= GDIP_PENFLAGS_DASHARRAY;
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        flags |= GDIP_PENFLAGS_NONCENTER;
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        flags |= GDIP_PENFLAGS_COMPOUNDARRAY;
    }

    PenData     penData;
    penData.Type  = DevicePen.Type;
    penData.Flags = flags;
    penData.Unit  = DevicePen.Unit;
    penData.Width = DevicePen.Width;
    stream->Write(&penData, sizeof(penData), NULL);

    if (flags & GDIP_PENFLAGS_TRANSFORM)
    {
        DevicePen.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_PENFLAGS_STARTCAP)
    {
        stream->Write(&DevicePen.StartCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_ENDCAP)
    {
        stream->Write(&DevicePen.EndCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_JOIN)
    {
        stream->Write(&DevicePen.Join, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        stream->Write(&DevicePen.MiterLimit, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        stream->Write(&DevicePen.DashStyle, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHCAP)
    {
        stream->Write(&DevicePen.DashCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        stream->Write(&DevicePen.DashOffset, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHARRAY)
    {
        stream->Write(&DevicePen.DashCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.DashArray, DevicePen.DashCount * sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_NONCENTER)
    {
        stream->Write(&DevicePen.PenAlignment, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        stream->Write(&DevicePen.CompoundCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.CompoundArray, DevicePen.CompoundCount * sizeof(REAL), NULL);
    }

    GpStatus status;

    if (flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        stream->Write(&customStartCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomStartCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    if (flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        stream->Write(&customEndCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomEndCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    status = Brush->GetData(stream);

    return status;
}

UINT
GpPen::GetDataSize() const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return 0;
    }

    UINT        dataSize = sizeof(PenData);

    if (!DevicePen.Xform.IsIdentity())
    {
        dataSize += GDIP_MATRIX_SIZE;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                // startcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customStartCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                // endcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customEndCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.MiterLimit != 10)
    {
        dataSize += sizeof(REAL);
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashOffset != 0)
    {
        dataSize += sizeof(REAL);
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.DashCount * sizeof(REAL));
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        dataSize += sizeof(INT32);
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.CompoundCount * sizeof(REAL));
    }

    dataSize += Brush->GetDataSize();

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the pen object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PenData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const PenData *     penData = reinterpret_cast<const PenData *>(dataBuffer);

    if (!penData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitDefaultState(penData->Width, static_cast<GpUnit>(penData->Unit));

    dataBuffer += sizeof(PenData);
    size       -= sizeof(PenData);

    if (penData->Flags & GDIP_PENFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (penData->Flags & GDIP_PENFLAGS_STARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.StartCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_ENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.EndCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_JOIN)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Join = (GpLineJoin) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.MiterLimit = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashStyle((GpDashStyle)((INT32 *)dataBuffer)[0]);
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashOffset = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_NONCENTER)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.PenAlignment = (GpPenAlignment) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        this->SetCompoundArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomStartCap == NULL);
        DevicePen.CustomStartCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomStartCap == NULL) ||
            (DevicePen.CustomStartCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomStartCap->IsValid())
        {
            WARNING(("Failure getting CustomStartCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomEndCap == NULL);
        DevicePen.CustomEndCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomEndCap == NULL) ||
            (DevicePen.CustomEndCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomEndCap->IsValid())
        {
            WARNING(("Failure getting CustomEndCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (Brush != NULL)
    {
        Brush->Dispose();
        Brush = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Brush = (GpBrush *)GpObject::Factory(ObjectTypeBrush, (const ObjectData *)dataBuffer, size);
        if (Brush != NULL)
        {
            if ((Brush->SetData(dataBuffer, size) == Ok) && Brush->IsValid())
            {
                DevicePen.Brush = Brush->GetDeviceBrush();
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Brush->Dispose();
            Brush = NULL;
        }
    }
    WARNING(("Failure getting brush"));

ErrorExit:
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpPen::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypePen;
    }

    if (Brush != NULL)
    {
        Brush->ColorAdjust(recolor, type);
    }

    return Ok;
}

GpStatus
GpPen::GetColor(
    ARGB *argb
    ) const
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        *argb = solidBrush->GetColor().GetValue();

        return Ok;
    }

    return InvalidParameter;
}

GpStatus
GpPen::SetColor(
    GpColor *       color
    )
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        if (solidBrush->GetColor().GetValue() == color->GetValue())
        {
            return Ok;
        }

        // !!! bhouse why do we allocate another brush just to change the
        // pen's color !!!!
    }

    GpSolidFill *newBrush = new GpSolidFill(*color);

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }

    return GenericError;

}

GpStatus
GpPen::SetBrush(
    GpBrush *       brush
    )
{
    // Don't set the brush if it is the same color as the current one,
    // because that makes metafiles unnecessarily large.
    if ((Brush->GetBrushType() == BrushTypeSolidColor) &&
        (brush->GetBrushType() == BrushTypeSolidColor))
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;
        GpSolidFill * newSolidBrush = (GpSolidFill *) brush;

        if(solidBrush->GetColor().GetValue() ==
           newSolidBrush->GetColor().GetValue())
        {
            return Ok;
        }
    }

    GpBrush *   newBrush = brush->Clone();

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }
    return GenericError;
}

GpPenType
GpPen::GetPenType(
    )
{
    GpPenType type = PenTypeUnknown;

    if(Brush)
    {
        switch(Brush->GetBrushType())
        {
        case BrushTypeSolidColor:
            type = PenTypeSolidColor;
            break;

        case BrushTypeHatchFill:
            type = PenTypeHatchFill;
            break;

        case BrushTypeTextureFill:
            type = PenTypeTextureFill;
            break;
/*
        case BrushRectGrad:
            type = PenFillRectGrad;
            break;

        case BrushRadialGrad:
            type = PenFillRadialGrad;
            break;

        case BrushTriangleGrad:
            type = PenFillTriangleGrad;
            break;
*/
        case BrushTypePathGradient:
            type = PenTypePathGradient;
            break;

        case BrushTypeLinearGradient:
            type = PenTypeLinearGradient;
            break;

        default:
            break;
        }
    }

    // We must implement LineTexture case.

    return type;
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a solid
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   12/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWideSolid(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    return this->IsOnePixelWide(worldToDevice, dpiX) && this->IsSimple();
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a one
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   10/6/2000 - peterost - factored out fron IsOnePixelWideSolid
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWide(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    BOOL useOnePixelPath = FALSE;

    const REAL minimumPenWidth = 1.5f;

    // !!![andrewgo] This determination of a single pixel wide line is
    //               unbelievably expensive

    // !!![andrewgo] This width check should be done simply using
    //               the world-to-device transform!  It would be
    //               faster and simpler!

    REAL width = this->Width;
    GpUnit unit = this->Unit;

    if(unit == UnitWorld)
    {
        if(worldToDevice == NULL || worldToDevice->IsTranslate())
        {
            if(width <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else if(worldToDevice->IsTranslateScale())
        {
            REAL m11 = worldToDevice->GetM11();
            REAL m22 = worldToDevice->GetM22();
            REAL maxScale = max(REALABS(m11), REALABS(m22));

            if(width*maxScale <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else
        {
            // This is a general transform.

            REAL majorR, minorR;    // Radii for major and minor axis.

            if(::GetMajorAndMinorAxis(
                &majorR,
                &minorR,
                worldToDevice) == Ok)
            {
                if(width*majorR <= minimumPenWidth)
                    useOnePixelPath = TRUE;
            }
        }
    }
    else
    {
        // Since GDI+ only uses the World Uinit, this code is not called
        // any more.

        width = ::GetDeviceWidth(width, unit, dpiX);
        if(width <= minimumPenWidth)
            useOnePixelPath = TRUE;
    }

    return useOnePixelPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpbrush.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpBrush structure which stores all of the
*   state needed by drivers to render with a brush.
*
* Notes:
*
* History:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   12/08/1999 bhouse
*       Major overhaul of DpBrush.  No longer used as base class of GpBrush.
*       Moved all driver required state into DpBrush.  Changed to struct.
*
\**************************************************************************/

#ifndef _DPBRUSH_HPP
#define _DPBRUSH_HPP

//--------------------------------------------------------------------------
// Represent brush information
//--------------------------------------------------------------------------

struct DpBrush
{

    GpBrushType         Type;

    GpColor             SolidColor;          // Set if GpBrushType::SolidBrush

    GpMatrix            Xform;                  // brush transform
    GpWrapMode          Wrap;                   // wrap mode
    GpRectF             Rect;

    DpBitmap *          texture;

    ARGB*               PresetColors;        // NON-Premultiplied colors.
    BOOL                UsesPresetColors;
    BOOL                IsGammaCorrected;    // use gamma correction of 2.2
    BOOL                IsAngleScalable;

    DpPath *            Path;

    mutable GpPointF *  PointsPtr;
    GpColor *           ColorsPtr;
    mutable INT         Count;
    mutable BOOL        OneSurroundColor;
    REAL                FocusScaleX;
    REAL                FocusScaleY;

    GpHatchStyle        Style;

    GpColor             Colors[4];
    REAL                Falloffs[3];
    INT                 BlendCounts[3];
    REAL*               BlendFactors[3];
    REAL*               BlendPositions[3];
    GpPointF            Points[3];
    BYTE                Data[8][8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\archive\widen\solidfill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine solid fill routines.
*
* Revision History:
*
*   12/11/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster as a solid color.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
DpOutputSolidColorSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    INT width = xMax - xMin;

    FillMemoryInt32(Scan->NextBuffer(xMin, y, width), width, Argb);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a path.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    GpStatus status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(path, 
                                   &context->WorldToDevice, 
                                   path->GetFillMode(),
                                   context->AntiAliasMode, 
                                   FALSE,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);
            if (output != NULL)
            {
                status = RasterizePath(path, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                delete output;
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a path.  This distributes to the individual pen draw method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to draw to
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to stroke
*   [IN] pen        - the pen to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    GpStatus status = GenericError;

    const DpBrush *brush = pen->Brush;

    REAL dpiX = (context->GetDpiX() > 0) 
              ? (context->GetDpiX())
              : (Globals::DesktopDpiX);

    BOOL isOnePixelWide = pen->IsOnePixelWide(&context->WorldToDevice, dpiX) &&
                          pen->IsCenterNoAnchor();
    BOOL isOnePixelWideOpaque = isOnePixelWide &&
                                (brush->Type == BrushTypeSolidColor) && 
                                (brush->SolidColor.IsOpaque()) &&
                                !(context->AntiAliasMode);
    BOOL isOnePixelWideSolid = isOnePixelWide && 
                                pen->IsSimple();

    // We have a special fast-path for doing single-pixel-wide, 
    // solid color, opaque, aliased lines:

    if (isOnePixelWideOpaque && isOnePixelWideSolid)
    {
        return SolidStrokePathOnePixel(
            context,
            surface,
            drawBounds,
            path,
            pen,
            TRUE
        ); 
    }

    const DpPath* widenedPath;
    const DpPath* allocatedPath;

    GpMatrix *transform;
    GpMatrix identityTransform;

    if (isOnePixelWideSolid)
    {
        // Our RasterizePath code can directly draw a one-pixel-wide solid 
        // line directly:

        widenedPath = path;
        allocatedPath = NULL;
        transform = &context->WorldToDevice;
    }
    else
    {
        // We have to widen  the path before we can give it to the
        // rasterizer.  Generate new path now:

        REAL dpiX = context->GetDpiX();
        REAL dpiY = context->GetDpiY();

        if ((dpiX <= 0) || (dpiY <= 0))
        {
            dpiX = Globals::DesktopDpiX;
            dpiY = Globals::DesktopDpiY;
        }

        BOOL fInsetOutset = 
            (pen->PenAlignment == PenAlignmentInset) ||
            (pen->PenAlignment == PenAlignmentOutset);
            
        // Pass in false for the region to path conversion parameter if we're
        // doing inset pen or outset pen. This will give us back the double 
        // wide path representing the union of the inset and outset pen 
        // widening.
        
        widenedPath = path->GetFlattenedPath(
            isOnePixelWideOpaque ? NULL : &context->WorldToDevice,
            isOnePixelWideOpaque ? Flattened : Widened,
            pen,
            context->AntiAliasMode,
            dpiX,
            dpiY,
            !fInsetOutset
        );

        allocatedPath = widenedPath;
        transform = &identityTransform;

        if (!widenedPath)
        {
            return OutOfMemory;
        }

        // If this line is aliased, opaque and dashed, dash it now and pass the
        // dashed path to the single pixel stroking code.
        
        if (isOnePixelWideOpaque && pen->DashStyle != DashStyleSolid)
        {
            DpPath *dashPath = NULL;
            
            // Hack up a temporary pen. For single pixel wide lines, we don't
            // actually cap the dash segments so we don't want any code in 
            // CreateDashCap mucking about with a non-zero cap length (e.g. 
            // shortening the dash segments by the cap length and making them
            // dissapear).
            
            DpPen tmpPen = *pen;
            tmpPen.DashCap = LineCapFlat;

            dashPath = ((GpPath*)widenedPath)->CreateDashedPath(
                &tmpPen,
                NULL,
                dpiX,
                dpiY,
                1.0f
            );
            
            if (!dashPath)
            {
                delete widenedPath;
                return OutOfMemory;
            }

            Status status = SolidStrokePathOnePixel(
                context,
                surface,
                drawBounds,
                dashPath,
                pen,
                FALSE
            ); 
            
            delete dashPath;
            delete widenedPath;
            
            return status;
        }
    }

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);
    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(surface->Scan, this, context, surface, noTransparentPixels);

    if (scan.IsValid())
    {
        DpClipRegion clip(context->VisibleClip);
        
        if(pen->PenAlignment == PenAlignmentInset)
        {
            // For inset pen we want the intersection of the visible clip
            // and the spine path.
            
            DpRegion spineRegion(
                const_cast<DpPath*>(path), 
                &context->WorldToDevice
            );
            clip.And(&spineRegion);
        }
        
        if(pen->PenAlignment == PenAlignmentOutset)
        {
            // For outset pen we want the intersection of the visible clip
            // and the complement of the spine path.
            
            DpRegion spineRegion(
                const_cast<DpPath*>(path), 
                &context->WorldToDevice
            );
            clip.Exclude(&spineRegion);
        }
        
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(
                widenedPath, 
                transform, 
                widenedPath->GetFillMode(),
                context->AntiAliasMode, 
                isOnePixelWideSolid,
                &output, 
                &clip,
                drawBounds
            );
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);
            if (output != NULL)
            {
                status = RasterizePath(
                    widenedPath, 
                    transform, 
                    widenedPath->GetFillMode(),
                    context->AntiAliasMode, 
                    isOnePixelWideSolid,
                    output, 
                    &clip, 
                    drawBounds
                );
    
                delete output;
            }
        }
    }

    if (allocatedPath)
    {
        delete allocatedPath;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a region.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] region     - the region to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/

GpStatus
DpDriver::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    GpStatus    status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if (scan.IsValid())
    {
        DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);

        if (output != NULL)
        {
            DpClipRegion *          clipRegion = &(context->VisibleClip);
            GpRect                  clipBounds;
            GpRect *                clipBoundsPointer = NULL;
            DpRegion::Visibility    visibility;
        
            visibility = clipRegion->GetRectVisibility(
                            drawBounds->X,
                            drawBounds->Y,
                            drawBounds->X + drawBounds->Width,
                            drawBounds->Y + drawBounds->Height);

            switch (visibility)
            {
              default:                          // Need to clip
                clipRegion->GetBounds(&clipBounds);
                clipBoundsPointer = &clipBounds;
                clipRegion->InitClipping(output, drawBounds->Y);
                status = region->Fill(clipRegion, clipBoundsPointer);
                break;

              case DpRegion::TotallyVisible:    // No clipping needed
                status = region->Fill(output, clipBoundsPointer);
                break;
            
              case DpRegion::Invisible:
                status = Ok;
                break;
            }

            delete output;
            clipRegion->EndClipping();
        }
    }

    return status;
}

GpStatus
DpDriver::MoveBits(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const GpRect *dstRect,     
    const GpPoint *srcPoint
    )
{
    return(GenericError);
}

GpStatus 
DpDriver::Lock(
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT *stride,                    // [OUT] - Returned stride
    VOID **bits                     // [OUT] - Returned pointer to bits
    )
{
    return(Ok);
}

VOID 
DpDriver::Unlock(
    DpBitmap *surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to fill rectangles.
*   This is not limited to filling solid color.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   01/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

// !!![andrewgo] What is this doing in a file called "solidfill.cpp"?

GpStatus
DpDriver::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects, 
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    GpStatus    status = Ok;
    GpBrushType type   = brush->Type;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);

    if(output == NULL)
        return(GenericError);

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y, 
        drawBounds->GetRight(), drawBounds->GetBottom()) != 
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }
   
    GpMatrix *worldToDevice = &context->WorldToDevice;
    
    const GpRectF * rect = rects;
    INT y;

    for (INT i = numRects; i != 0; i--, rect++)
    {
        // We have to check for empty rectangles in world space (because
        // after the transform they might have flipped):

        if ((rect->Width > 0) && (rect->Height > 0))
        {
            GpPointF points[4];

            points[0].X = rect->X;
            points[0].Y = rect->Y;
            points[1].X = rect->X + rect->Width;
            points[1].Y = rect->Y + rect->Height;

            // FillRects only ever gets called when a scaling transform:
            // !!![ericvan] printing code calls this to render the brush onto a rectangle,
            //              but the transform in effect may not be TranslateScale
            // !!![andrewgo] Yeah but then isn't the printer case completely
            //               broken when there is an arbitrary transform?!?

            ASSERT(context->IsPrinter ||
                   worldToDevice->IsTranslateScale());
            
            worldToDevice->Transform(points, 2);

            INT left;
            INT right;

            // convert to INT the same way the GDI+ rasterizer does
            // so we get the same rounding error in both places.

            if (points[0].X <= points[1].X)
            {
                left  = RasterizerCeiling(points[0].X);
                right = RasterizerCeiling(points[1].X);     // exclusive
            }
            else
            {
                left  = RasterizerCeiling(points[1].X);
                right = RasterizerCeiling(points[0].X);     // exclusive
            }

            // Since right is exclusive, we don't draw anything
            // if left >= right.

            INT width = right - left;
            INT top;
            INT bottom;

            if (points[0].Y <= points[1].Y)
            {
                top    = RasterizerCeiling(points[0].Y);
                bottom = RasterizerCeiling(points[1].Y);    // exclusive
            }
            else
            {
                top    = RasterizerCeiling(points[1].Y);
                bottom = RasterizerCeiling(points[0].Y);    // exclusive
            }
             
            // Since bottom is exclusive, we don't draw anything
            // if top >= bottom.

            if ((width > 0) && (top < bottom))
            {
                GpRect clippedRect;
                
                if(clipRegion)
                {
                    visibility = 
                            clipRegion->GetRectVisibility(
                                left, top, 
                                right, bottom, &clippedRect);
                }

                switch (visibility)
                {
                case DpRegion::ClippedVisible:
                    left   = clippedRect.X;
                    top    = clippedRect.Y;
                    right  = clippedRect.GetRight();
                    bottom = clippedRect.GetBottom();
                    width  = right - left;
                    // FALLTHRU
        
                case DpRegion::TotallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        output->OutputSpan(y, left, right);
                    }
                    break;
        
                case DpRegion::PartiallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        clipRegion->OutputSpan(y, left, right);
                    }
                    break;

                case DpRegion::Invisible:
                    break;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    delete output;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpbitmap.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpBitmap
*
* Notes:
*
* Abstract:
*
*   This is a DDI-level surface. Its name should really be 'surface'. 
*   Unlike many other DDI objects, there isn't a one-to-one mapping between
*   a DpBitmap and a GpBitmap. Rather, this is like a GDI surface - it
*   represents any rectangular area to which one can draw.
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPBITMAP_HPP
#define _DPBITMAP_HPP

// DpTransparency:
//   Characterizes the alpha values in a surface. Perf optimizations can
//   take advantage of this knowledge.

enum DpTransparency
{
    TransparencyUnknown, // We know nothing about the alpha values
    TransparencyComplex, // We have alpha values between 0 and 1
    TransparencySimple,  // All alpha values are either 0 or 1
    TransparencyOpaque,  // All alpha values are 1
    TransparencyNearConstant, // we have near constant alpha
    TransparencyNoAlpha  // All pixels are opaque because the surface doesn't
                         // support alpha.
};

// Define PixelFormatID in terms of the PixelFormat enum

typedef PixelFormat PixelFormatID;

// Passthrough compressed bitmaps to driver
class DpCompressedData
{
public:
    DpCompressedData()
    {
        format = 0;
        bufferSize = 0;
        buffer = NULL;
    }

    ~DpCompressedData()
    {
        ASSERT(buffer == NULL);
    }

public:
   INT   format;
   UINT  bufferSize;
   VOID* buffer;
};
  

//--------------------------------------------------------------------------
// Represent surface information
//--------------------------------------------------------------------------

class EpScanBitmap;
struct ImageInfo;

class DpBitmap
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpBitmap : ObjectTagInvalid;
    }

public:
    enum CreationType
    {
        GDI,
        GDIDIBSECTION,
        GPBITMAP,
        D3D
    };

    INT Width;
    INT Height;
    PixelFormatID PixelFormat;  // bits per pixel, pre/post multiplied alpha, etc.
    INT NumBytes;               // Number of bytes
    REAL DpiX;                  // actual horizontal resolution in dots per inch
    REAL DpiY;                  // actual vertical resolution in dots per inch
    UINT Uniqueness;            // Incremented every time it's drawn on

    DpTransparency SurfaceTransparency;

    BYTE MinAlpha;
    BYTE MaxAlpha;

    // The following is true only for RGB format bitmaps:

    ColorPalette* PaletteTable;
    
    // These masks are no longer used for determining the pixel format
    // Use the PixelFormat member above instead.
    // In fact, there's never been any garantee that these fields were
    // set up correctly anyway. They should be removed soon.
    
    INT RedMask;
    INT GreenMask;
    INT BlueMask;
    INT AlphaMask;

    LPDIRECTDRAWSURFACE     DdrawSurface;
    IDirectDrawSurface7 *   DdrawSurface7;
    
    BOOL IsDisplay;             // Is this bitmap associated with a display?
    CreationType Type;

    // short lived, so don't include statically
    DpCompressedData *CompressedData;

public:
    BOOL IsDesktopSurface() const
    {
        return (this == Globals::DesktopSurface);
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpBitmap) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpBitmap");
        }
    #endif

        return (Tag == ObjectTagDpBitmap);
    }

public: // GDI+ INTERNAL

    VOID *Bits;                 // Points to surface bits
    VOID *CompBits;
    INT Delta;                  // Stride in bytes

    // Private data for the software rasterizer.
    
    EpScan *Scan;

public: // GDI+ INTERNAL

    DpBitmap(HDC hdc = NULL)
    {
        SetValid(TRUE);     // set to valid state

        if ((hdc == NULL) ||
            ((DpiX = (REAL)GetDeviceCaps(hdc, LOGPIXELSX)) <= 0.0f) ||
            ((DpiY = (REAL)GetDeviceCaps(hdc, LOGPIXELSY)) <= 0.0f))
        {
            // Assume this is a display surface with the display DPI for now
            IsDisplay = TRUE;
            DpiX = Globals::DesktopDpiX;
            DpiY = Globals::DesktopDpiY;
        }
        else
        {
            IsDisplay = (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY);
        }

        Scan = NULL;
        DdrawSurface = NULL;
        DdrawSurface7 = NULL;
        PaletteTable = NULL;
        CompressedData = NULL;

        SurfaceTransparency = TransparencyUnknown;
    }
    ~DpBitmap();

    VOID InitializeForMetafile(GpDevice *device)
    {
        InitializeForGdiBitmap(device, 0, 0);
    }

    VOID InitializeForGdiBitmap(
        GpDevice *device, 
        INT width, 
        INT height
        );
    
    VOID InitializeForGdiScreen(
        GpDevice *device, 
        INT width, 
        INT height
        );
    
    BOOL InitializeForD3D(
        HDC hdc, 
        INT *width, 
        INT *height, 
        DpDriver** driver
        );
    
    BOOL InitializeForD3D(
        IDirectDrawSurface7* surface, 
        INT *width, 
        INT *height, 
        DpDriver** driver
        );
    
    BOOL InitializeForDibsection(
        HDC hdc, 
        HBITMAP hbitmap, 
        GpDevice *device, 
        DIBSECTION *dib, 
        INT *width, 
        INT *height, 
        DpDriver **driver
        );
    
    VOID InitializeForGdipBitmap(
        INT             width,
        INT             height,
        ImageInfo *     imageInfo,
        EpScanBitmap *  scanBitmap,
        BOOL            isDisplay
        );

    BOOL InitializeForPrinter(GpPrinterDevice *device, INT width, INT height);

    BOOL StandardFormat();
    PixelFormatID GetPixelFormatFromBitDepth(INT bits);

    // Flush any pending rendering to this surface:

    VOID Flush(GpFlushIntention intention);

    REAL GetDpiX() const { return DpiX; }
    REAL GetDpiY() const { return DpiY; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpcachedbitmap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap driver data structure.
*
* Created:
*
*   04/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _DPCACHEDBITMAP_HPP
#define _DPCACHEDBITMAP_HPP

struct EpScanRecord;

//--------------------------------------------------------------------------
// Represent the CachedBitmap information for the driver.
//--------------------------------------------------------------------------

class DpCachedBitmap
{   
    public:

    INT Width;
    INT Height;

    // pointer to the pixel data.

    void *Bits;                // The start of the memory buffer. It might not
                               // be QWORD aligned, so it's not necessarily
                               // equal to RecordStart.
    EpScanRecord *RecordStart; // The first scan record
    EpScanRecord *RecordEnd;   // Just past the last scan record

    // Store the pixel format for the runs of opaque and semitransparent
    // pixels.

    PixelFormat OpaqueFormat;
    PixelFormat SemiTransparentFormat;

    DpCachedBitmap()
    {
        OpaqueFormat = PixelFormat32bppPARGB;
        SemiTransparentFormat = PixelFormat32bppPARGB;
        Bits = NULL;
        Width = 0;
        Height = 0;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpcontext.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpContext - DDI-level device context
*
* Abstract:
*
*   This is the DDI-level portion of the GpGraphics object.
*
* Notes:
*
*
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved it into a separate file for the preliminary DDI.
*
\**************************************************************************/

#ifndef _DPCONTEXT_HPP
#define _DPCONTEXT_HPP

// This enum specifies what we should do about
// the ICM mode on the destination HDC.

enum HdcIcmMode {
    IcmModeOff,     // must turn it off
    IcmModeOn       // must turn it on
};

//--------------------------------------------------------------------------
// Represent context information for the call
//--------------------------------------------------------------------------

class DpContext
{

public:

    static LONG Uniqueness;                  // Used with Id's

    DpContext *          Prev;               // For save/restore (push/pop)
    DpContext *          Next;
    UINT                 Id;                 // For save/restore
    INT                  AntiAliasMode;
    GpTextRenderingHint  TextRenderHint;     // For AntiAlias Text and
    GpCompositingMode    CompositingMode;
    GpCompositingQuality CompositingQuality;
    INT                  RenderingOriginX;   // Origin for halftone/dither matrices
    INT                  RenderingOriginY;
    UINT                 TextContrast;
    InterpolationMode    FilterType;
    PixelOffsetMode      PixelOffset;
    Unit                 PageUnit;
    REAL                 PageScale;
    REAL                 PageMultiplierX;    // combination of PageUnit and PageScale
    REAL                 PageMultiplierY;    // combination of PageUnit and PageScale
    REAL                 ContainerDpiX;      // The Dpi for the current container
    REAL                 ContainerDpiY;      // The Dpi for the current container
    REAL                 MetafileRasterizationLimitDpi;
    GpMatrix             WorldToPage;
    GpMatrix             WorldToDevice;      // includes container transform
    GpMatrix             ContainerToDevice;  // container transform
    mutable GpMatrix     DeviceToWorld;      // lazy inverse of WorldToDevice
    mutable BOOL         InverseOk;          // if DeviceToWorld is up to date
    DpClipRegion         VisibleClip;        // The combination of all clip regions
    DpRegion             ContainerClip;      // For container clipping. Includes the WindowClip
    GpRegion             AppClip;            // The current logical region that
                                             //   defines the current clipping
    HDC                  Hdc;                // If the Graphics was derived from
                                             //   an 'hdc', this is the DC handle.
                                             //   NOTE: We may have changed the
                                             //   state in it
    HWND                 Hwnd;               // Window handle if we know it
    HdcIcmMode           IcmMode;            // Icm Mode for the DC.
    BOOL                 IsEmfPlusHdc;       // If it is an EMF+ metafile HDC or not
    BOOL                 IsPrinter;          // Represents a printer context
    BOOL                 IsDisplay;          // Is this context associated with a display?
                    
    INT                  SaveDc;             // Represents the SaveDC level if the
                                             //   Hdc had a SaveDC done on it since
                                             //   it was given to us
                    
    ColorPalette *       Palette;            // Context palette or NULL for system palette
    EpPaletteMap *       PaletteMap;         // Mapping to Palette or system palette

    HFONT                CurrentHFont;       // GdiPlus has created an hfont and selected
    HFONT                OriginalHFont;      // it into the DC. Before releasing
                                             // the DC, the original font should be
                                             // reselected, and the current font
                                             // deleted.
    const GpFontFace    *Face;               // Font face of currently selected font
    GpMatrix             FontTransform;      // Transform for currently selected font
    INT                  Style;              // Style for currently selected font

    BOOL                 GdiLayered;         // TRUE if GDI layering is enabled
                                             //   on the target. If so, GDI is
                                             //   rendering to the screen is
                                             //   actually redirected to a backing
                                             //   store inaccessible via DCI.
                                             //   GDI must be used for rendering.

public:

    DpContext(
        BOOL            isDisplay
        );

    DpContext(
        DpContext *     prev    // must not be NULL
        );

    ~DpContext();

    // GetHdc() will automatically initialize (to default values) parts of the
    // DC.  It doesn't reset *all* attributes, though!

    HDC
    GetHdc(         // May return NULL if not originally a GDI surface
        DpBitmap *surface
        );

    VOID
    ReleaseHdc(
        HDC hdc,
        DpBitmap *surface = NULL
        );

    VOID
    CleanTheHdc(
        HDC hdc
        );

    // ResetHdc() restores the HDC to the state in which it was given
    // to us:

    VOID ResetHdc(
        VOID
        );

    VOID UpdateWorldToDeviceMatrix()
    {
        GpMatrix::ScaleMatrix(
            WorldToDevice,
            WorldToPage,
            PageMultiplierX,
            PageMultiplierY);

        // GillesK:
        // PixelOffsetModeDefault and PixelOffsetModeHighSpeed are PixelOffsetNone,

        if (PixelOffset == PixelOffsetModeHalf || PixelOffset == PixelOffsetModeHighQuality)
        {
            WorldToDevice.Translate(-0.5f, -0.5f, MatrixOrderAppend);
        }

        if (!ContainerToDevice.IsIdentity())
        {
            GpMatrix::MultiplyMatrix(
                WorldToDevice,
                WorldToDevice,
                ContainerToDevice);
        }
    }

    GpStatus
    GetDeviceToWorld(
        GpMatrix* deviceToWorld
        ) const;

    VOID
    GetPageMultipliers(
        REAL *              pageMultiplierX,
        REAL *              pageMultiplierY,
        GpPageUnit          unit  = UnitDisplay,
        REAL                scale = 1.0f
        ) const;

    VOID
    GetPageMultipliers()
    {
        GetPageMultipliers(&PageMultiplierX, &PageMultiplierY,
                           PageUnit, PageScale);
    }


    // Text optimisation hdc generation

    GpStatus UpdateCurrentHFont(
            BYTE quality,
            const PointF & scale,
            INT angle,
            HDC hdc,
            BOOL sideway,
            BYTE charSet = 0xFF
    );

private:
    VOID DeleteCurrentHFont();

public:
    // successful call to SelectCurrentHFont or GetTextOutputHdc must have
    // matching ReleaseTextOutputHdc call

    GpStatus SelectCurrentHFont(HDC hdc);

    HDC
    GetTextOutputHdc(
        const GpFaceRealization *faceRealization,   // In  - Font face required
        GpColor                 color,           // In  - Required GdiPlus brush effect
        DpBitmap                *surface,           // In
        INT                     *angle              // Out
    );

    
    VOID ReleaseTextOutputHdc(HDC hdc);

    REAL GetDpiX() const { return ContainerDpiX; }
    REAL GetDpiY() const { return ContainerDpiY; }

    // Used only when recording a EMF or EMF+ through GpMetafile class
    VOID
    SetMetafileDownLevelRasterizationLimit(
        UINT                    metafileRasterizationLimitDpi
        );

    // Used only when recording a EMF or EMF+ through GpMetafile class
    UINT
    GetMetafileDownLevelRasterizationLimit() const
    {
        return GpRound(MetafileRasterizationLimitDpi);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpimageattributes.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpImageAttributes structure which 
*   stores state needed by drivers for DrawImage.
*
* Notes:
*
* History:
*
*   3/9/2000 asecchia
*       Created it.
*
\**************************************************************************/

#ifndef _DPIMAGEATTRIBUTES_HPP
#define _DPIMAGEATTRIBUTES_HPP

//--------------------------------------------------------------------------
// Represent imageAttributes information
//--------------------------------------------------------------------------

struct DpImageAttributes
{    
    WrapMode wrapMode;    // specifies how to handle edge conditions
    ARGB clampColor;      // edge color for use with WrapModeClamp
    BOOL srcRectClamp;    // Do we clamp to the srcRect (true) or srcBitmap (false)
    BOOL ICMMode;         // TRUE = ICM on, FALSE = no ICM

    
    DpImageAttributes(WrapMode wrap = WrapModeClamp, 
                      ARGB color = (ARGB)0x00000000,
                      BOOL clamp = FALSE,
                      BOOL icmMode = FALSE)
    {
        wrapMode = wrap;
        clampColor = color;
        srcRectClamp = clamp;
        ICMMode = icmMode;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dppathiterator.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dppathiterator.hpp
*
* Abstract:
*
*   Path iterator API
*
* Revision History:
*
*   11/13/99 ikkof
*       Created it
*
\**************************************************************************/

#ifndef _DPPATHITERATOR_HPP
#define _DPPATHITERATOR_HPP

class DpPathTypeIterator
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag               Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathIterator : ObjectTagInvalid;
    }

public:
    DpPathTypeIterator()
    {
        Initialize();
    }

    DpPathTypeIterator(const BYTE* types, INT count)
    {
        Initialize();
        SetTypes(types, count);
    }

    ~DpPathTypeIterator()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    VOID SetTypes(const BYTE* types, INT count);

    virtual INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    INT NextPathType(BYTE* pathType, INT* startIndex, INT* endIndex);
    virtual INT NextMarker(INT* startIndex, INT* endIndex);

    virtual INT GetCount() {return Count;}
    virtual INT GetSubpathCount() {return SubpathCount;}

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(DpPathTypeIterator, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagPathIterator) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpPathTypeIterator");
        }
    #endif

        return (Tag == ObjectTagPathIterator);
    }
    BOOL HasCurve() {return HasBezier;}
    BOOL IsDashMode(INT index);
    BOOL IsExtendedPath() {return ExtendedPath;}

    VOID Rewind()
    {
        Index = 0;
        SubpathStartIndex = 0;
        SubpathEndIndex = -1;
        TypeStartIndex = 0;
        TypeEndIndex = -1;
        MarkerStartIndex = 0;
        MarkerEndIndex = -1;
    }

    VOID RewindSubpath()
    {
        // Set the start and end index of type to be the starting index of
        // the current subpath.  NextPathType() will start from the
        // beginning of the current subpath.

        TypeStartIndex = SubpathStartIndex;
        TypeEndIndex = -1;  // Indicate that this is the first type
                            // in the current subpath.
    
        // Set the current index to the start index of the subpath.

        Index = SubpathStartIndex;
    }

protected:
//    DpPathTypeIterator(DpPath* path);

    VOID Initialize()
    {
        Types = NULL;
        Count = 0;
        SubpathCount = 0;
        SetValid(TRUE);
        HasBezier = FALSE;
        ExtendedPath = FALSE;

        Rewind();
    }

    BOOL CheckValid();

protected:
    const BYTE* Types;
    INT Count;
    INT SubpathCount;
    BOOL HasBezier;
    BOOL ExtendedPath;

    INT Index;
    INT SubpathStartIndex;
    INT SubpathEndIndex;
    INT TypeStartIndex;
    INT TypeEndIndex;
    INT MarkerStartIndex;
    INT MarkerEndIndex;
};

class DpPathIterator : public DpPathTypeIterator
{
public:
    DpPathIterator()
    {
        Points = NULL;
    }

    DpPathIterator(const GpPointF* points, const BYTE* types, INT count)
    {
        Points = NULL;
        SetData(points, types, count);
    }

    DpPathIterator(const DpPath* path);

    VOID SetData(const GpPointF* points, const BYTE* types, INT count);
    VOID SetData(const DpPath* path);
    virtual INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    virtual INT NextSubpath(DpPath* path, BOOL* isClosed);
    virtual INT NextMarker(INT* startIndex, INT* endIndex);
    virtual INT NextMarker(DpPath* path);
    INT Enumerate(GpPointF *points, BYTE *types, INT count);
    INT CopyData(GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

protected:
    VOID Initialize()
    {
        DpPathTypeIterator::Initialize();
        Points = NULL;
    }

    INT EnumerateWithinSubpath(GpPointF* points, BYTE* types, INT count);

protected:
    const GpPointF* Points;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dppath.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpPath
*
* Abstract:
*
*   A DDI-level path object. Corresponds to a GpPath object.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPPATH_HPP
#define _DPPATH_HPP

//--------------------------------------------------------------------------
// Represent a path
//--------------------------------------------------------------------------


class DpPath : public GpObject
{
public:

    enum DpPathFlags        // !!! Rename and move?
    {
        PossiblyNonConvex   = 0x00,
        Convex              = 0x01,
        ConvexRectangle     = 0x03      // Used for Rectangle and Oval.
    };

    ~DpPath() {}

    // Start/end a subpath

    virtual VOID StartFigure()
    {
        IsSubpathActive = FALSE;
        UpdateUid();
    }

    virtual GpStatus CloseFigure();
    virtual GpStatus CloseFigures();

    BOOL HasCurve() const
    {
        return HasBezier;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPath);
    }

    BOOL IsConvex() const
    {
        return ((Flags & Convex) != 0);
    }

    INT GetSubpathCount() const
    {
        return SubpathCount;
    }

    virtual GpStatus Flatten(
        DynByteArray *flattenTypes,
        DynPointFArray *flattenPoints,
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    ) const = 0;

    virtual const DpPath*
    GetFlattenedPath(
        const GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    VOID
    Offset(
        REAL dx,
        REAL dy
        );

    GpFillMode GetFillMode() const
    {
        return FillMode;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        if (FillMode != fillMode)
        {
            FillMode = fillMode;
            UpdateUid();
        }
    }

    // Get path data

    INT GetPointCount() const
    {
        return Points.GetCount();
    }

    const GpPointF* GetPathPoints() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Points.GetDataBuffer();
    }

    const BYTE* GetPathTypes() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Types.GetDataBuffer();
    }

    BOOL IsRectangular() const
    {
        const GpPointF *points;
        INT count;

        if (HasCurve() || (GetSubpathCount() != 1)) 
        {
            return FALSE;
        }

        count = GetPointCount();
        points = GetPathPoints();

        if (count > 0 && points != NULL) 
        {
            for (INT i=0; i<count; i++) 
            {
                INT j = (i+1) % count;

                if (REALABS(points[i].X-points[j].X) > REAL_EPSILON &&
                    REALABS(points[i].Y-points[j].Y) > REAL_EPSILON) 
                {
                    // Points are not at 90 degree angles, not rectangular.
                    return FALSE;
                }
            }

            return TRUE;
        }

        return FALSE;
    }
    
    static BOOL
    ValidatePathTypes(
        const BYTE* types,
        INT count,
        INT* subpathCount,
        BOOL* hasBezier
        );

    GpStatus GetPathData(GpPathData* pathData);

    GpStatus SetPathData(const GpPathData* pathData);

    virtual ObjectType GetObjectType() const { return ObjectTypePath; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual DpPath*
    CreateWidenedPath(
        const DpPen* pen,
        DpContext* context,
        BOOL outline = FALSE
        ) const
    {
        return DpcCreateWidenedPath(this, pen, context, outline);
    }

    virtual VOID
    DeletePath()
    {
        DpcDeletePath(this);
    }

    virtual DpPath*
    ClonePath()
    {
        return DpcClonePath(this);
    }

    virtual VOID
    Transform(
        GpMatrix* matrix
    )
    {
        DpcTransformPath(this, matrix);
    }
    
    BOOL
    virtual IsRectangle(
        const GpMatrix * matrix,
        GpRectF * transformedBounds
        ) const;

    // Debug only.
    
    #if DBG
    void DisplayPath();
    #endif
    
    class SubpathInfo
    {
    public:
        INT StartIndex;
        INT Count;
        BOOL IsClosed;
    };

protected: // GDI+ INTERNAL

    DpPath()
    {
        InitDefaultState(FillModeAlternate);
        SetValid(TRUE);
    }

    DpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    DpPath(const DpPath *path);

    virtual VOID InitDefaultState(GpFillMode fillMode);

    virtual DynArray<SubpathInfo> *GetSubpathInformation() const = 0;

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPath : ObjectTagInvalid);
    }

protected:

    BOOL HasBezier;         // does path have Bezier segments?
    DynArrayIA<BYTE, 16> Types;
    DynArrayIA<GpPointF, 16> Points;
    GpFillMode FillMode;
    DpPathFlags Flags;
    BOOL IsSubpathActive;   // whether there is an active subpath
    INT SubpathCount;       // number of subpaths
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpscan.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpScan
*
* Abstract:
*
*   Contains the declarations for the scan-interface methods.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   08/03/2000 asecchia
*       Moved and renamed into the render directory.
*
\**************************************************************************/

#ifndef _DPSCAN_HPP
#define _DPSCAN_HPP

// DpScan moved into the render directory because
// it's specific to the software rasterizer.
// It's also been renamed from DpScan to EpScan.

// If we need to export a scan interface from the drivers
// for access to opaque bitmaps, we should abstract the interface
// from EpScan and place it here - then EpScan should inherit that
// interface from the DDK because the software rasterizer (EpXXX) is 
// a driver.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpcustomlinecap.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.hpp
*
* Abstract:
*
*   Class used for the custom line caps.
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _DPCUSTOMLINECAP_HPP
#define _DPCUSTOMLINECAP_HPP

class DpCustomLineCap : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagCustomLineCap : ObjectTagInvalid);
    }

public:
    DpCustomLineCap() {}

    virtual BOOL IsValid() const
    {
        // If the line cap came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return GpObject::IsValid(ObjectTagCustomLineCap);
    }

    INT GetFillPointCount() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPointCount();
    }

    INT GetStrokePointCount() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPointCount();
    }

    const GpPointF * GetFillPoints() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPathPoints();
    }

    const GpPointF * GetStrokePoints() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPathPoints();
    }

    const BYTE * GetFillTypes() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPathTypes();
    }

    const BYTE * GetStrokeTypes() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPathTypes();
    }

    GpStatus SetStrokeCaps(GpLineCap lineCap)
    {
        ASSERT(IsValid());
        return SetStrokeCaps(lineCap, lineCap);
    }

    GpStatus SetStrokeCaps(GpLineCap startCap, GpLineCap endCap)
    {
        ASSERT(IsValid());

        // Allow only non-anchor types of caps.

        GpStatus status = Ok;

        GpLineCap savedStartCap = StrokeStartCap;
        GpLineCap savedEndCap = StrokeEndCap;

        switch(startCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            StrokeStartCap = startCap;
            break;

        default:
            status = InvalidParameter;
            break;
        }

        if(status == Ok)
        {
            switch(endCap)
            {
            case LineCapFlat:
            case LineCapSquare:
            case LineCapRound:
            case LineCapTriangle:
                StrokeEndCap = endCap;
                break;

            default:
                status = InvalidParameter;
                break;
            }
        }

        if(status != Ok)
        {
            // Go back to the original caps.

            StrokeStartCap = savedStartCap;
            StrokeEndCap = savedEndCap;
        }

        return status;
    }

    GpStatus GetStrokeCaps(GpLineCap* startCap, GpLineCap* endCap) const
    {
        ASSERT(IsValid());

        if(startCap)
            *startCap = StrokeStartCap;

        if(endCap)
            *endCap = StrokeEndCap;

        return Ok;
    }

    GpStatus SetBaseCap(GpLineCap lineCap)
    {
        ASSERT(IsValid());

        // Allow only non-anchor types of caps.

        GpStatus status = Ok;

        switch(lineCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = lineCap;
            break;

        default:
            status = InvalidParameter;
            break;
        }

        return status;
    }

    GpStatus GetBaseCap(GpLineCap* baseCap) const
    {
        ASSERT(IsValid());

        if(baseCap)
            *baseCap = BaseCap;

        return Ok;
    }

    GpStatus SetBaseInset(REAL inset)
    {
        ASSERT(IsValid());

        BaseInset = inset;

        return Ok;
    }

    GpStatus GetBaseInset(REAL* inset) const
    {
        ASSERT(IsValid());

        if(inset)
            *inset = BaseInset;

        return Ok;
    }

    GpStatus SetStrokeJoin(GpLineJoin lineJoin)
    {
        ASSERT(IsValid());

        StrokeJoin = lineJoin;
        return Ok;
    }

    GpStatus GetStrokeJoin(GpLineJoin* lineJoin) const
    {
        ASSERT(IsValid());

        if(lineJoin)
        {
            *lineJoin = StrokeJoin;
            return Ok;
        }
        else
            return InvalidParameter;
    }
        
    GpStatus SetStrokeMiterLimit(REAL miterLimit)
    {
        ASSERT(IsValid());

        if(miterLimit > 1)
        {
            StrokeMiterLimit = miterLimit;
            return Ok;
        }
        else
            return InvalidParameter;
    }

    REAL GetStrokeMiterLimit() const
    {
        ASSERT(IsValid());

        return StrokeMiterLimit;
    }
    
    REAL GetStrokeLength() const
    {
        ASSERT(IsValid());

        return StrokeLength;
    }
    REAL GetFillLength() const
    {
        ASSERT(IsValid());

        return FillLength;
    }

    GpStatus SetWidthScale(REAL widthScale)
    {
        ASSERT(IsValid());

        WidthScale = widthScale;

        return Ok;
    }

    GpStatus GetWidthScale(REAL* widthScale) const
    {
        ASSERT(IsValid());

        if(widthScale)
            *widthScale = WidthScale;

        return Ok;
    }

    GpStatus SetFillHotSpot(const GpPointF& hotSpot)
    {
        ASSERT(IsValid());

        FillHotSpot = hotSpot;
        return Ok;
    }

    GpStatus GetFillHotSpot(GpPointF* hotSpot)
    {
        ASSERT(IsValid());

        if(!hotSpot)
            return InvalidParameter;

        *hotSpot = FillHotSpot;
        return Ok;
    }

    GpStatus SetStrokeHotSpot(const GpPointF& hotSpot)
    {
        ASSERT(IsValid());

        StrokeHotSpot = hotSpot;
        return Ok;
    }

    GpStatus GetStrokeHotSpot(GpPointF* hotSpot)
    {
        ASSERT(IsValid());

        if(!hotSpot)
            return InvalidParameter;

        *hotSpot = StrokeHotSpot;
        return Ok;
    }

    virtual BOOL IsEqual(const DpCustomLineCap* customLineCap) const = 0;

    virtual INT GetTransformedFillCap(
            GpPointF* points,
            BYTE* types,
            INT count,
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL mimimumWidth
            ) const = 0;

    virtual INT GetTransformedStrokeCap(
            INT cCapacity,       // In, initial pPoints & pTypes capacity
            GpPointF ** pPoints,    // In/out, may be reallocated here
            BYTE ** pTypes,         // In/out, may be reallocated here
            INT * pCount,           // In/out, may change here if flattened
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const = 0;

    virtual REAL GetRadius(
            REAL lineWidth,
            REAL minimumWidth
            ) const = 0;

protected:
    GpLineCap           BaseCap;
    REAL                BaseInset;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
    GpLineCap           StrokeStartCap;
    GpLineCap           StrokeEndCap;
    GpLineJoin          StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    REAL                FillLength;   // Length of the FillCap/StrokeCap from 
    REAL                StrokeLength; // zero along the positive y axis.           
                                      // Used for computing the direction of  
                                      // the cap.                             
    DpPath *            FillPath;
    DpPath *            StrokePath;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpregion.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpRegion.hpp
*
* Abstract:
*
*   DpRegion class operates on scan-converted Y spans of rects
*
* Created:
*
*   12/16/1998 DCurtis
*
\**************************************************************************/

#ifndef _DPREGION_HPP
#define _DPREGION_HPP

// Each Y span consists of 4 values
#define YSPAN_SIZE          4

#define YSPAN_YMIN          0   // minimum Y value (inclusive)
#define YSPAN_YMAX          1   // maximum Y value (exclusive)
#define YSPAN_XOFFSET       2   // offset into XCoords for this span
#define YSPAN_XCOUNT        3   // num XCoords for this span (multiple of 2)

#if 0
// The infinite max and min values are set up to be the greatest
// values that will interop with GDI HRGNs on WinNT successfully (divided by 2).
// We divide those values by 2 so that there is a little room to offset
// the GDI region and still have it work correctly.
// Of course, this won't work on Win9x -- we have to handle Win9x as
// a special case in the GetHRGN code.

#define INFINITE_MAX        0x03FFFFC7      // (0x07ffff8f / 2)
#define INFINITE_MIN        0xFC000038      // (0xF8000070 / 2)
#define INFINITE_SIZE       (INFINITE_MAX - INFINITE_MIN)

#else

// Instead of the above, let's use the largest possible integer value
// that is guaranteed to round trip correctly between float and int,
// but as above, let's leave a little head room so we can offset the region.

#include "float.h"

#define INFINITE_MAX        (1 << (FLT_MANT_DIG - 2))
#define INFINITE_MIN        (-INFINITE_MAX)
#define INFINITE_SIZE       (INFINITE_MAX - INFINITE_MIN)

#endif


class DpComplexRegion
{
public:
    INT             XCoordsCapacity;    // num XCoords (INTs) allocated
    INT             XCoordsCount;       // num XCoords (INTs) used

    INT             YSpansCapacity;     // num YSpans allocated
    INT             NumYSpans;          // NumYSpans used

    INT             YSearchIndex;       // search start index in YSpans

    INT *           XCoords;            // pointer to XCoords
    INT *           YSpans;             // pointer to YSpans
                                        // (XCoords + XCoordsCapacity)
public:
    INT * GetYSpan (INT spanIndex)
    {
        return YSpans + (spanIndex * YSPAN_SIZE);
    }

    VOID ResetSearchIndex()
    {
        YSearchIndex = NumYSpans >> 1;
    }

    BOOL YSpanSearch(INT y, INT ** ySpan, INT * spanIndex);
};

class DpRegionBuilder  : public GpOutputYSpan
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpRegionBuilder : ObjectTagInvalid;
    }

public:
    INT                 XMin;
    INT                 YMin;
    INT                 XMax;
    INT                 YMax;
    DpComplexRegion *   ComplexData;

public:
    DpRegionBuilder(INT ySpans)
    {
        SetValid(InitComplexData(ySpans) == Ok);
    }

    ~DpRegionBuilder()
    {
        GpFree(ComplexData);

        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpRegionBuilder) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpRegionBuilder");
        }
    #endif

        return (Tag == ObjectTagDpRegionBuilder);
    }

    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        );

    GpStatus InitComplexData(INT ySpans);
};

// Forward Declaration for friendliness
class DpClipRegion;

// This class was constructed to optimize for space and speed for the common
// case of the region consisting of a single rectangle.  For that case of a
// simple region, we want the region to be as small and as fast as possible so
// that it is not expensive to have a region associated with every window.
class DpRegion
{
private:
    friend DpClipRegion;
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpRegion : ObjectTagInvalid;
    }

protected:
    UINT32              Infinite : 1;
    UINT32              Empty    : 1;
    UINT32              Lazy     : 1;
    UINT32              Pad      : 29;

    INT                 XMin;
    INT                 YMin;
    INT                 XMax;       // exclusive
    INT                 YMax;       // exclusive

    DpComplexRegion *   ComplexData;
    mutable INT         Uniqueness;

public:
    enum Visibility
    {
        Invisible                   = 0,
        PartiallyVisible            = 1,
        ClippedVisible              = 2,
        TotallyVisible              = 3,
    };

public:
    DpRegion(BOOL empty = FALSE);       // default is infinite region
    DpRegion(const GpRect * rect);
    DpRegion(INT x, INT y, INT width, INT height);
    DpRegion(const DpPath * path, const GpMatrix * matrix);
    DpRegion(const DpRegion * region, BOOL lazy = FALSE);
    DpRegion(DpRegion & region);        // copy constructor
    DpRegion(const RECT * rects, INT count);
    ~DpRegion()
    {
        FreeData();

        SetValid(FALSE);    // so we don't use a deleted object
    }

    DpRegion &operator=( DpRegion & region );

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpRegion) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpRegion");
        }
    #endif

        return (Tag == ObjectTagDpRegion);
    }

    VOID     Set(INT x, INT y, INT width, INT height);
    VOID     Set(GpRect * rect)
    {
        ASSERT (rect != NULL);
        Set(rect->X, rect->Y, rect->Width, rect->Height);
    }
    GpStatus Set(const DpPath * path, const GpMatrix * matrix); // path is in world units
    GpStatus Set(const DpRegion * region, BOOL lazy = FALSE);
    GpStatus Set(const RECT * rects, INT count);
    VOID     SetInfinite();
    VOID     SetEmpty();

    GpStatus Offset(INT xOffset, INT yOffset);

    GpStatus And       (const DpRegion * region);
    GpStatus Or        (const DpRegion * region);
    GpStatus Xor       (const DpRegion * region);
    GpStatus Exclude   (const DpRegion * region);
    GpStatus Complement(const DpRegion * region);

    INT      GetXMin() const        { ASSERT(IsValid()); return XMin; }
    INT      GetYMin() const        { ASSERT(IsValid()); return YMin; }
    INT      GetXMax() const        { ASSERT(IsValid()); return XMax; }
    INT      GetYMax() const        { ASSERT(IsValid()); return YMax; }

    INT      GetUniqueness() const
    {   ASSERT(IsValid());
        if (Uniqueness == 0)
        {
            Uniqueness = GenerateUniqueness();
        }
        return Uniqueness;
    }

    VOID UpdateUID()         { ASSERT(IsValid()); Uniqueness = 0; }

    VOID GetBounds(GpRect * bounds) const
    {
        ASSERT(IsValid());
        ASSERT(bounds != NULL);

        bounds->X      = XMin;
        bounds->Y      = YMin;
        bounds->Width  = XMax - XMin;
        bounds->Height = YMax - YMin;
    }

    VOID GetBounds(GpPointF * topLeft, GpPointF * bottomRight) const
    {
        ASSERT(IsValid());
        ASSERT((topLeft != NULL) && (bottomRight != NULL));

        topLeft->X     = (REAL)XMin;
        topLeft->Y     = (REAL)YMin;
        bottomRight->X = (REAL)XMax;
        bottomRight->Y = (REAL)YMax;
    }

    BOOL IsEqual(DpRegion * region);

    BOOL IsEmpty() const
    {
        ASSERT(IsValid());
        return Empty;
    }

    BOOL IsInfinite() const
    {
        ASSERT(IsValid());
        return Infinite;
    }

    // Empty and Infinite regions are always simple as well.
    BOOL IsSimple() const
    {
        ASSERT(IsValid());
        return (ComplexData == NULL);
    }

    BOOL IsComplex() const
    {
        return !IsSimple();
    }

    Visibility GetRectVisibility(
        INT         xMin,
        INT         yMin,
        INT         xMax,
        INT         yMax,
        GpRect *    rectClipped = NULL
        );

    BOOL RegionVisible (DpRegion * region);
    BOOL RectVisible(INT xMin, INT yMin, INT xMax, INT yMax);
    BOOL RectVisible(GpRect * rect)
    {
        return RectVisible(rect->X, rect->Y,
                           rect->X + rect->Width, rect->Y + rect->Height);
    }
    BOOL RectInside (INT xMin, INT yMin, INT xMax, INT yMax);
    BOOL PointInside(INT x, INT y);

    GpStatus Fill(DpOutputSpan * output, GpRect * clipBounds) const;

    HRGN GetHRgn() const;

    BOOL GetOutlinePoints(DynPointArray& points,
                          DynByteArray& types) const;

    // If rects is NULL, return the number of rects in the region.
    // Otherwise, assume rects is big enough to hold all the region rects
    // and fill them in and return the number of rects filled in.
    INT GetRects(GpRect *  rects) const;
    INT GetRects(GpRectF * rects) const;

protected:
    VOID FreeData()
    {
        if (!Lazy)
        {
            GpFree(ComplexData);
        }
        ComplexData = NULL;
        Lazy        = FALSE;
    }

    GpStatus Set(DpRegionBuilder & regionBuilder);

    // If rects is NULL, return the number of rects in the region.
    // Otherwise, assume rects is big enough to hold all the region rects
    // and fill them in and return the number of rects filled in.
    INT GetRects(RECT * rects, BOOL clampToWin9xSize = FALSE) const;

    GpStatus CompactAndOutput(
        INT                     yMin,
        INT                     yMax,
        INT *                   xCoords,
        INT                     numXCoords,
        DpRegionBuilder *       regionBuilder,
        DynIntArray *           combineCoords
        );

    GpStatus Diff(
        DpRegion *      region1,
        DpRegion *      region2,
        BOOL            set1
        );

    GpStatus XSpansAND (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansOR  (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansXOR (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansDIFF(
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

private:
    static INT
    GenerateUniqueness(
        )
    {
        LONG_PTR Uid;
        static LONG_PTR gUniqueness = 0 ;

        // Use InterlockedCompareExchangeFunction instead of
        // InterlockedIncrement, because InterlockedIncrement doesn't work
        // the way we need it to on Win9x.

        do
        {
            Uid = gUniqueness;
        } while (CompareExchangeLong_Ptr(&gUniqueness, (Uid + 1), Uid) != Uid);

        return (INT) (Uid + 1);
    }

};

class DpClipRegion : public DpRegion,
                     public DpOutputSpan
{
public:
    enum Direction
    {
        NotEnumerating,
        TopLeftToBottomRight,
        TopRightToBottomLeft,
        BottomLeftToTopRight,
        BottomRightToTopLeft
    };

protected:
    DpOutputSpan *      OutputClippedSpan;
    DpRegion            OriginalRegion;      // The old Region
    BOOL                ComplexClipDisabled; // Did we disable the complexClip

    // enumeration stuff
    Direction           EnumDirection;
    INT                 EnumSpan;

private:
friend class DriverPrint;

    // This is a special method intended for use only by DriverPrint.
    VOID StartBanding()
    {
        ASSERT(IsValid());
        ASSERT(!Empty);     // if clipping is empty, we shouldn't be banding

        ASSERT(ComplexClipDisabled == FALSE); // Unless we are banding we can't
                                              // have ComplexClip disabled
        ASSERT(OriginalRegion.IsEmpty());

        // Save the current information of the ClipRegion into OriginalRegion
        // this is done by setting the complexData to our current complexData
        ASSERT(OriginalRegion.ComplexData == NULL);
        OriginalRegion.ComplexData = ComplexData;
        OriginalRegion.Lazy = Lazy;
        OriginalRegion.Uniqueness = Uniqueness;
        OriginalRegion.Infinite = Infinite;
        OriginalRegion.Empty = Empty;
        OriginalRegion.XMin = XMin;
        OriginalRegion.YMin = YMin;
        OriginalRegion.XMax = XMax;
        OriginalRegion.YMax = YMax;


        // We don't want to both regions to point to the same data
        ComplexData = NULL;
        Lazy = FALSE;

        // Create a lazy region so that we don't copy unless needed
        Set(&OriginalRegion, TRUE);
    }

    // This is a special method intended for use only by DriverPrint.
    VOID EndBanding()
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT(!ComplexClipDisabled); // Make sure that we don't leave an opened
                                      // DisableComplexClip call

        // Free our Data, we can't be Lazy
        FreeData();
        ASSERT(ComplexData == NULL);
        ComplexData = OriginalRegion.ComplexData;
        Lazy = OriginalRegion.Lazy;
        Uniqueness = OriginalRegion.Uniqueness;
        Infinite = OriginalRegion.Infinite;
        Empty = OriginalRegion.Empty;
        XMin = OriginalRegion.XMin;
        YMin = OriginalRegion.YMin;
        XMax = OriginalRegion.XMax;
        YMax = OriginalRegion.YMax;

        // We don't want to both regions to point to the same data
        OriginalRegion.ComplexData = NULL;
        OriginalRegion.Lazy = FALSE;
		OriginalRegion.SetEmpty();
    }

    // This is a special method intended for use only by DriverPrint.
    // We're relying on DriverPrint to restore the bounds back correctly
    // after it's done with banding (by bracketing the banding with
    // StartBanding and EndBanding calls).

    // This works, even when there is complex clipping, because OutputSpan
    // clips against the bounds before clipping against the complex region.
    VOID SetBandBounds(GpRect & bandBounds, BOOL doIntersect = TRUE)
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT((bandBounds.Width > 0) && (bandBounds.Height > 0));

        GpRect  intersectedBounds;

        if (!doIntersect)
        {
            // We are coming from DisableComplexClipping. We should not have
            // any ComplexData.
            ASSERT(!Lazy);
            ASSERT(ComplexData == NULL);

            // The reason for not doing the intersection is that sometimes
            // printing using a capped DPI which means that the bandBounds is
            // using a different coordinate system than the original region.
            intersectedBounds = bandBounds;
        }
        else 
        {
            GpRect boundsOriginal(OriginalRegion.XMin, OriginalRegion.YMin,
                                  OriginalRegion.XMax - OriginalRegion.XMin,
                                  OriginalRegion.YMax - OriginalRegion.YMin);
            if (!GpRect::IntersectRect(intersectedBounds, bandBounds, boundsOriginal))
            {
                // intersection is empty
                SetEmpty();
                return;
            }
        }

        // Create a region for our band
        DpRegion newRegion(&intersectedBounds);

        // If we haven't disabled the complex clipping, then restore the original
        // complexRegion and intersect with our current region
        if (!ComplexClipDisabled)
        {
            // Get the original Clipping Region
            Set(&OriginalRegion, TRUE);

            // Intersect with our current band
            And(&newRegion);
        }
        else
        {
            // We've disabled the complexClipping, Set the clipping to our band
            Set(&newRegion);
            ASSERT(ComplexData == NULL);
        }
    }

    // This is a special method intended for use only by DriverPrint.
    // We're relying on DriverPrint to re-enable the complex clipping
    // and to restore the bounds back correctly after it's done with banding
    // (by bracketing the banding with StartBanding and EndBanding calls).
    // Typically, when we disable complex clipping, it's because we are
    // using a capped DPI, which means that the bandBounds is in a different
    // resolution than the original clipping region.
    VOID DisableComplexClipping(GpRect & bandBounds, BOOL doIntersect = FALSE)
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());

        // Make sure that we call ourselves twice in a row
        ASSERT(ComplexClipDisabled == FALSE);

        ComplexClipDisabled = TRUE;

        Set(&bandBounds);
        ASSERT(ComplexData == NULL);
        SetBandBounds(bandBounds, doIntersect);
    }

    // This is a special method intended for use only by DriverPrint.
    VOID ReEnableComplexClipping()
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT(ComplexClipDisabled);

        ComplexClipDisabled = FALSE;

        // Set the clipping back to the original state, make in Lazy
        Set(&OriginalRegion, TRUE);
    }

public:
    DpClipRegion(BOOL empty = FALSE) : DpRegion(empty)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const GpRect * rect) : DpRegion(rect)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(INT x, INT y, INT width, INT height) :
                DpRegion(x, y, width, height)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const DpPath * path, const GpMatrix * matrix) : DpRegion (path, matrix)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const DpRegion * region) : DpRegion(region)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(DpClipRegion & region) : DpRegion(region)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }

    VOID StartEnumeration (
        INT         yMin,
        Direction   direction = TopLeftToBottomRight
        );

    // returns FALSE when done enumerating
    // numRects going in is the number of rects in the buffer and going out
    // is the number of rects that we filled.
    BOOL Enumerate (
        GpRect *    rects,
        INT &       numRects
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    VOID InitClipping(DpOutputSpan * outputClippedSpan, INT yMin);

    // EndClipping is here only for debugging (and the Rasterizer doesn't
    // call it):
    VOID EndClipping() {}

    virtual BOOL IsValid() const { return TRUE; }
};

#endif // _DPREGION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dpdriver.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpDriver
*
* Abstract:
*
*   Represents the driver interface that a driver will implement.
*   Unfortunately, in this version, the meaning is a bit confused -
*   the member functions are not pure virtual - rather, they implement
*   the software rasterizer.
*
*   The plan is that the software rasterizer will look just like another
*   driver - DpDriver will be abstract, and the software rasterizer will
*   derive a class from DpDriver.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPDRIVER_HPP
#define _DPDRIVER_HPP

// Private data, used by GDI+.

struct DpDriverInternal;

#define DriverDrawImageFlags DWORD

#define DriverDrawImageCachedBackground  0x00000001
#define DriverDrawImageFirstImageBand    0x00000002
#define DriverDrawImageLastImageBand     0x00000004

//--------------------------------------------------------------------------
// Base driver class
//--------------------------------------------------------------------------

class DpDriver
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag                   Tag;    // Keep this as the 1st value in the object!
    struct DpDriverInternal *   Internal;

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpDriver : ObjectTagInvalid;
    }

public:

    BOOL IsLockable;                // TRUE if any surfaces with this
                                    //   driver interface are opaque, meaning
                                    //   that Lock() may not be called
    GpDevice *Device;               // Associated device

public:

    DpDriver();

    DpDriver(GpDevice *device)
    {
        SetValid(TRUE);     // set to valid state
        IsLockable = TRUE;
        Device = device;
        Internal = NULL;
    }

    virtual ~DpDriver();

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpDriver) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpDriver");
        }
    #endif

        return (Tag == ObjectTagDpDriver);
    }

    virtual VOID
    DesktopChangeNotification()
    {
        // do nothing
    }

    virtual VOID
    UpdateSurfacePixelFormat(DpBitmap *surface)
    {
        // do nothing.
        // used primarily by the multimon driver to update the pixel format
        // for the meta surface.
    }

    virtual VOID
    PaletteChangeNotification()
    {
        // do nothing
    }

    virtual VOID
    Flush(
        GpDevice           *device,
        DpBitmap           *surface,
        GpFlushIntention    intention)
    {
        surface->Flush(intention);
    }

    virtual VOID
    SetupClipping(
        HDC                 hdc,
        DpContext *         context,
        const GpRect *      drawBounds,
        BOOL &              isClip,
        BOOL &              usePathClipping,
        BOOL                forceClipping
        );

    virtual VOID
    RestoreClipping(
        HDC                 hdc,
        BOOL                isClip,
        BOOL                usePathClipping
        );

    virtual GpStatus
    StrokePath(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        const DpPath *      path,
        const DpPen *       pen
        );

    virtual GpStatus
    FillRects(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        INT                 numRects,       // NOTE: You must check for empty
        const GpRectF *     rects,          //       rectangles!
        const DpBrush *     brush
        );

    virtual GpStatus
    FillPath(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        const DpPath *      path,
        const DpBrush *     brush
        );

    virtual GpStatus
    FillRegion(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const DpRegion *region,
        const DpBrush *brush
        );

    virtual GpStatus
    SolidText(
        DpContext* context,
        DpBitmap* surface,
        const GpRect* drawBounds,
        GpColor   color,
        const GpGlyphPos *glyphPos,
        INT     count,
        GpTextRenderingHint textMode,
        BOOL rightToLeft
        );

    virtual GpStatus
    GdiText(
        HDC             hdc,
        INT             angle,          // In tenths of a degree
        const UINT16   *glyphs,
        const PointF   *glyphOrigins,
        INT             glyphCount,
        BOOL            rightToLeft,
        UINT16          blankGlyph = 0
    );


    virtual GpStatus
    BrushText(
        DpContext*        context,
        DpBitmap*         surface,
        const GpRect*     drawBounds,
        const DpBrush*    brush,
        const GpGlyphPos *glyphPos,
        INT               count,
        GpTextRenderingHint textMode
        );


    virtual GpStatus
    DrawGlyphs(
        DrawGlyphData *drawGlyphData
        );

    virtual GpStatus
    DrawImage(
        DpContext *         context,
        DpBitmap *          srcSurface,
        DpBitmap *          dstSurface,
        const GpRect *      drawBounds,
        const DpImageAttributes * imgAttributes,
        INT                 numPoints,
        const GpPointF *    dstPoints,
        const GpRectF *     srcRect,
        DriverDrawImageFlags flags
        );

    // Draw the CachedBitmap on the destination bitmap.

    virtual GpStatus
    DrawCachedBitmap(
        DpContext *context,
        DpCachedBitmap *src,
        DpBitmap *dst,
        INT x, INT y            // where to put it on the destination.
    );

    virtual GpStatus
    MoveBits(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const GpRect *dstRect,          // Device coordinates
        const GpPoint *srcPoint         // Device coordinates
        );


    //--------------------------------------------------------------------------
    // Low-level driver functions
    //--------------------------------------------------------------------------

    // !!! We will inevitably be adding more functions in the next version,
    //     which would mean that they would have to be added to the end
    //     of the VTable?
    // !!! Extend the following to represent low-level D3D token primitives

    //--------------------------------------------------------------------------
    // Direct access functions - Required if IsLockable
    //--------------------------------------------------------------------------

    // Lock can return FALSE only in the case of catastrophic failure
    // !!! What do we do about transitional surfaces?

    virtual GpStatus
    Lock(
        DpBitmap *surface,
        const GpRect *drawBounds,
        INT *stride,                    // [OUT] - Returned stride
        VOID **bits                     // [OUT] - Returned pointer to bits
        );

    virtual VOID
    Unlock(
        DpBitmap *surface
        );

protected:

    GpStatus
    SolidStrokePathOnePixel(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const DpPath *path,
        const DpPen *pen,
        BOOL  drawLast
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\ddkinc\dppen.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpPen structure which stores all of the
*   state needed by drivers to render with a pen.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   12/8/99 bhouse
*       Major overhaul of DpPen.  No longer used as base class of GpPen.
*       Moved all driver required state into DpPen.  Changed to struct.
*
\**************************************************************************/

#ifndef _DPPEN_HPP
#define _DPPEN_HPP

//--------------------------------------------------------------------------
// Represent pen information
//--------------------------------------------------------------------------

struct DpPen
{
    BOOL IsEqual(const DpPen * pen) const
    {
        //!!! what to do about DeviceBrush and DashArray?

        BOOL isEqual =
                Type == pen->Type &&
                Width == pen->Width &&
                Unit == pen->Unit &&
                StartCap == pen->StartCap &&
                EndCap == pen->EndCap &&
                Join == pen->Join &&
                MiterLimit == pen->MiterLimit &&
                PenAlignment == pen->PenAlignment &&
                DashStyle == pen->DashStyle &&
                DashCap == pen->DashCap &&
                DashCount == pen->DashCount &&
                DashOffset == pen->DashOffset;

        if(isEqual)
        {
            if(CustomStartCap || pen->CustomStartCap)
            {
                if(CustomStartCap && pen->CustomStartCap)
                    isEqual = CustomStartCap->IsEqual(pen->CustomStartCap);
                else
                    isEqual = FALSE;    // One of them doesn't have
                                        // a custom cap.
            }
        }

        if(isEqual)
        {
            if(CustomEndCap || pen->CustomEndCap)
            {
                if(CustomEndCap && pen->CustomEndCap)
                    isEqual = CustomEndCap->IsEqual(pen->CustomEndCap);
                else
                    isEqual = FALSE;    // One of them doesn't have
                                        // a custom cap.
            }
        }

        return isEqual;
    }

    // Can the path be rendered using our nominal width pen code?

    BOOL IsOnePixelWideSolid(const GpMatrix *worldToDevice, REAL dpiX) const;
    BOOL IsOnePixelWide(const GpMatrix *worldToDevice, REAL dpiX) const;

    // See if the pen has a non-identity transform.

    BOOL HasTransform() const
    {
        return !Xform.IsIdentity();
    }

    BOOL IsSimple() const
    {
        return (!((DashStyle != DashStyleSolid)  ||
                  (StartCap & LineCapAnchorMask) ||
                  (EndCap & LineCapAnchorMask)   ||
                  (DashCap & LineCapAnchorMask)
                  ));
    }

    BOOL IsCompound() const
    {
        return ((CompoundCount > 0) && (CompoundArray != NULL));
    }

    BOOL IsCenterNoAnchor() const
    {
        return (!((StartCap & LineCapAnchorMask) ||
                  (EndCap & LineCapAnchorMask)   ||
                  (DashCap & LineCapAnchorMask)  
                  ));
    }

    VOID InitDefaults()
    {
        Type           = PenTypeSolidColor;
        Width          = 1;
        Unit           = UnitWorld;
        StartCap       = LineCapFlat;
        EndCap         = LineCapFlat;
        Join           = LineJoinMiter;
        MiterLimit     = 10;    // PS's default miter limit.
        PenAlignment   = PenAlignmentCenter;
        Brush          = NULL;
        DashStyle      = DashStyleSolid;
        DashCap        = LineCapFlat;
        DashCount      = 0;
        DashOffset     = 0;
        DashArray      = NULL;
        CompoundCount  = 0;
        CompoundArray  = NULL;
        CustomStartCap = NULL;
        CustomEndCap   = NULL;
    }

    GpPenType       Type;

    REAL            Width;
    GpUnit          Unit;
    GpLineCap       StartCap;
    GpLineCap       EndCap;
    GpLineJoin      Join;
    REAL            MiterLimit;
    GpPenAlignment  PenAlignment;
    
    const DpBrush * Brush;
    GpMatrix        Xform;

    GpDashStyle     DashStyle;
    GpLineCap       DashCap; // In v2, we should use GpDashCap for this
    INT             DashCount;
    REAL            DashOffset;
    REAL*           DashArray;

    INT             CompoundCount;
    REAL*           CompoundArray;
    DpCustomLineCap* CustomStartCap;
    DpCustomLineCap* CustomEndCap;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\life\life.hpp ===
#ifndef __GDIPSCSAVE_H
#define __GDIPSCSAVE_H

#include <windows.h>
#include <objbase.h>
#include <scrnsave.h>
#include "resource.h"
#include <gdiplus.h>
#include <shlobj.h>

using namespace Gdiplus;

WCHAR szAppName[APPNAMEBUFFERLEN];

#define SPEED_MIN 0
#define SPEED_MAX 100
#define SPEED_DEF 50

#define TILESIZE_MIN 0
#define TILESIZE_MAX 4
#define TILESIZE_DEF 2

VOID DrawLifeIteration(HDC hdc);
VOID InitLifeMatrix();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\life\resource.h ===
#define IDS_DESCRIPTION                 1


#define DLG_SCRNSAVECONFIGURE         2003 


#define idsIniFile                    1001
#define idsAppName                    1007

#define ID_SPEED                      1003
#define IDC_RADIOTYPE1                1054
#define IDC_RADIOTYPE2                1055
#define IDC_RADIOTYPE3                1056
#define IDC_RADIOTYPE4                1057
#define IDC_RADIOTYPE5                1058


#define ID_OK                         1011
#define ID_CANCEL                     1012
#define ID_DIR                        1013
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\life\life.cpp ===
/**************************************************************************
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   life.cpp
*
* Abstract:
*
*   Conway's game of Life using GDI+.
*
* Revision History:
*
*   9/12/2000  asecchia - Created it.
*
***************************************************************************/

#include "life.hpp"
#include <math.h>

// This needs to be set on the command line. See the sources file.
// Turning this switch on causes the screen saver to run in a window from
// the command line, making debuggin a lot easier.

#ifdef STANDALONE_DEBUG
HINSTANCE hMainInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;

TCHAR szIniFile[MAXFILELEN];
#else
extern HINSTANCE hMainInstance; /* screen saver instance handle  */ 
#endif

// ASSERT code.

#if DBG

#define ASSERT(a) if(!(a)) { DebugBreak();}

#else
#define ASSERT(a)
#endif

// explicit unreferenced parameter.

#define UNREF(a) (a);

#define CBSIZE 40

class CachedImageArray
{
    CachedBitmap *cbArray[CBSIZE];
    int num;
    
    public:
    CachedImageArray()
    {
        num = 0;
    }
    
    // Cache an entry.
    
    bool Add(CachedBitmap *cb)
    {
        if(num>=CBSIZE)
        {
            return false;
        }
        
        cbArray[num] = cb;
        num++;
        
        return true;
    }
    
    int Size() {return num;}
    
    CachedBitmap *operator[] (int i)
    {
        if( (i<0) || (i>=num) )
        {
            return NULL;
        }
        
        return cbArray[i];
    }
    // Throw everything away.
    
    void Dispose()
    {
        for(int i=0; i<num; i++)
        {
            delete cbArray[i];
        }
        num = 0;
    }
    
    ~CachedImageArray()
    {
        Dispose();
    }
};


/**********************************************************************
*
*  Handle configuration dialog
*
***********************************************************************/


INT *gLifeMatrix=NULL;
INT *gTempMatrix=NULL;
CachedImageArray *CachedImages;
INT gWidth;
INT gHeight;

DWORD gGenerationColor;
INT gSizeX;
INT gSizeY;
INT gGenerations;
INT gCurrentGeneration;
INT currentImage;
INT maxImage;

INT nTileSize;
INT nSpeed;

INT red, green, blue;
INT ri, gi, bi;

HANDLE ghFile;

WCHAR gDirPath[MAX_PATH];




struct OFFSCREENINFO
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
};

OFFSCREENINFO gOffscreenInfo = { 0 };

const int b_heptomino_x = 29;
const int b_heptomino_y = 11;
const char b_heptomino[320] = 
    "00000000000000000100000000000"
    "11000000000000000110000000011"
    "11000000000000000011000000011"
    "00000000000000000110000000000"
    "00000000000000000000000000000"
    "00000000000000000000000000000"
    "00000000000000000000000000000"
    "00000000000000000110000000000"
    "00000000000000000011000000000"
    "00000000000000000110000000000"
    "00000000000000000100000000000";


INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

void LoadState()
{
    // Retrieve the application name from the RC file.
    
    LoadStringW(
        hMainInstance, 
        idsAppName, 
        szAppName, 
        40
    );
    
    // Retrieve the .ini file name from the RC file.
    
    LoadStringW(
        hMainInstance, 
        idsIniFile, 
        szIniFile, 
        MAXFILELEN
    ); 
    
    // Retrieve any redraw speed data from the registry.
    
    nSpeed = GetPrivateProfileIntW(
        szAppName, 
        L"Redraw Speed", 
        SPEED_DEF, 
        szIniFile
    ); 
    
    // Only allow defined values.
    
    nSpeed = max(nSpeed, SPEED_MIN);
    nSpeed = min(nSpeed, SPEED_MAX);


    // Retrieve any tile size from the registry.
    
    nTileSize = GetPrivateProfileIntW(
        szAppName, 
        L"Tile Size", 
        TILESIZE_DEF, 
        szIniFile
    ); 
    
    // Only allow defined values.
    
    nTileSize = max(nTileSize, TILESIZE_MIN);
    nTileSize = min(nTileSize, TILESIZE_MAX);


    // Get the directory name. NULL if failed.
    
    GetPrivateProfileStringW(
        szAppName, 
        L"Image Path", 
        L"", 
        gDirPath,
        MAX_PATH,
        szIniFile
    ); 
    
}


void SaveState()
{
    WCHAR szTemp[20];
    
    // Write out the registry setting for the speed.
    
    wsprintf(szTemp, L"%ld", nSpeed); 
    
    WritePrivateProfileStringW(
        szAppName, 
        L"Redraw Speed", 
        szTemp, 
        szIniFile
    ); 

    // Write out the registry setting for the tile size.
    
    wsprintf(szTemp, L"%ld", nTileSize); 
    
    WritePrivateProfileStringW(
        szAppName, 
        L"Tile Size", 
        szTemp, 
        szIniFile
    ); 

    // Set the directory name. NULL if failed.

    WritePrivateProfileStringW(
        szAppName, 
        L"Image Path", 
        gDirPath, 
        szIniFile
    ); 
}

void ClearOffscreenDIB()
{
    if (gOffscreenInfo.hdc)
    {
        PatBlt(
            gOffscreenInfo.hdc,
            0,
            0,
            gOffscreenInfo.bmi.bmiHeader.biWidth,
            gOffscreenInfo.bmi.bmiHeader.biHeight,
            BLACKNESS
        );
    }
}

VOID CreateOffscreenDIB(HDC hdc, INT width, INT height)
{
    gOffscreenInfo.bmi.bmiHeader.biSize = sizeof(gOffscreenInfo.bmi.bmiHeader);
    gOffscreenInfo.bmi.bmiHeader.biWidth = width;
    gOffscreenInfo.bmi.bmiHeader.biHeight = height;
    gOffscreenInfo.bmi.bmiHeader.biPlanes = 1;
    gOffscreenInfo.bmi.bmiHeader.biBitCount = 32;
    gOffscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;

    gOffscreenInfo.hbmpOffscreen = CreateDIBSection(
        hdc,
        &gOffscreenInfo.bmi,
        DIB_RGB_COLORS,
        &gOffscreenInfo.pvBits,
        NULL,
        0
    );

    if (gOffscreenInfo.hbmpOffscreen)
    {
        gOffscreenInfo.hdc = CreateCompatibleDC(hdc);

        if (gOffscreenInfo.hdc)
        {
            gOffscreenInfo.hbmpOld = (HBITMAP)SelectObject(
                gOffscreenInfo.hdc, 
                gOffscreenInfo.hbmpOffscreen
            );

            ClearOffscreenDIB();
        }
    }
}

BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HWND hSpeed;  // handle to the speed scrollbar. 
    
    switch(message) 
    { 
        case WM_INITDIALOG: 
        
            // Load the global state.
            
            LoadState();
            
            // Initialize the speed scroll bar
            
            hSpeed = GetDlgItem(hDlg, ID_SPEED); 
            SetScrollRange(hSpeed, SB_CTL, SPEED_MIN, SPEED_MAX, FALSE); 
            SetScrollPos(hSpeed, SB_CTL, nSpeed, TRUE); 
            
            // Initialize the tile size radio buttons
            
            CheckRadioButton(hDlg, IDC_RADIOTYPE1, IDC_RADIOTYPE5, IDC_RADIOTYPE1+(TILESIZE_MAX-nTileSize));

            return TRUE; 
 
        case WM_HSCROLL: 
 
            // Process the speed control scrollbar.
 
            switch (LOWORD(wParam)) 
                { 
                    case SB_PAGEUP: --nSpeed; break; 
                    case SB_LINEUP: --nSpeed; break; 
                    case SB_PAGEDOWN: ++nSpeed; break; 
                    case SB_LINEDOWN: ++nSpeed; break; 
                    case SB_THUMBPOSITION: nSpeed = HIWORD(wParam); break; 
                    case SB_BOTTOM: nSpeed = SPEED_MIN; break; 
                    case SB_TOP: nSpeed = SPEED_MAX; break; 
                    case SB_THUMBTRACK: 
                    case SB_ENDSCROLL: 
                        return TRUE; 
                    break; 
                } 
                
                nSpeed = max(nSpeed, SPEED_MIN);
                nSpeed = min(nSpeed, SPEED_MAX);
                
                SetScrollPos((HWND) lParam, SB_CTL, nSpeed, TRUE); 
            break; 
 
        case WM_COMMAND: 
            switch(LOWORD(wParam)) 
            { 
                case ID_DIR:
                
                    // Do the COM thing for the SHBrowseForFolder dialog.
                    
                    CoInitialize(NULL);
                    
                    IMalloc *piMalloc;
                    if(SUCCEEDED(SHGetMalloc(&piMalloc)))
                    {
                        BROWSEINFOW bi;
                        memset(&bi, 0, sizeof(bi));
                        bi.hwndOwner = hDlg;
                        bi.ulFlags = BIF_NEWDIALOGSTYLE | BIF_EDITBOX;
                        bi.lpszTitle = L"Select image directory:";
                        WCHAR wszPath[MAX_PATH];
                        bi.pszDisplayName = wszPath;
                        LPITEMIDLIST lpiList = SHBrowseForFolderW(&bi);
                        if(lpiList)
                        {
                            if(SHGetPathFromIDListW(lpiList, wszPath))
                            {
                                wcscpy(gDirPath, wszPath);
                            }
                            piMalloc->Free(lpiList);
                        }
                        piMalloc->Release();
                    }
                
                    CoUninitialize();
                
                break;
                
                case ID_OK: 
                    
                    // Tile size radio buttons.
                    
                    if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE1))
                    {
                        nTileSize = 4;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE2))
                    {
                        nTileSize = 3;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE3))
                    {
                        nTileSize = 2;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE4))
                    {
                        nTileSize = 1;
                    }
                    else
                    {
                        nTileSize = 0;  // smallest
                    }
                    
                    SaveState();                   
                     
                    // intentionally fall through to exit.
 
                case ID_CANCEL: 
                    EndDialog(hDlg, LOWORD(wParam) == IDOK); 
                return TRUE; 
            } 
    } 
    return FALSE; 
} 

BOOL WINAPI RegisterDialogClasses(
    HANDLE  hInst
    )
{ 
    return TRUE; 
    UNREF(hInst);
} 

LRESULT WINAPI ScreenSaverProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HDC          hdc;      // device-context handle
    static RECT         rc;       // RECT structure
    static UINT_PTR     uTimer;   // timer identifier
    static bool         GdiplusInitialized = false;
    static ULONG_PTR    gpToken;
    
    GdiplusStartupInput sti;
 
    switch(message) 
    { 
        case WM_CREATE:
            
            // Initialize GDI+
            
            if (GdiplusStartup(&gpToken, &sti, NULL) == Ok)
            {
                GdiplusInitialized = true;
            }
            
            // Only do work if we successfully initialized.
            
            if(GdiplusInitialized)
            {
                // Retrieve the application name from the .rc file. 
                
                LoadString(hMainInstance, idsAppName, szAppName, 40); 
        
                // Initialize the global state.
                
                GetClientRect (hwnd, &rc); 

                LoadState();    

                switch(nTileSize) 
                {
                    // 1x1 pixel
                    
                    case 0:
                        gSizeX = 1;
                        gSizeY = 1;
                    break;
                    
                    // Aspect ratio of 4x3, for pictures.
                    
                    case 1:
                        gSizeX = 16;
                        gSizeY = 12;
                    break;
                    
                    case 2:
                        gSizeX = 32;
                        gSizeY = 24;
                    break;

                    case 3:
                        gSizeX = 64;
                        gSizeY = 48;
                    break;

                    case 4:
                        gSizeX = 96;
                        gSizeY = 72;
                    break;
                    
                }                
                
                ghFile = 0;
                gGenerations = 400;
                gCurrentGeneration = 0;
                
                gWidth = (rc.right - rc.left + 1)/gSizeX;
                gHeight = (rc.bottom - rc.top + 1)/gSizeY;
                
                gLifeMatrix = (INT *)malloc(sizeof(INT)*gWidth*gHeight);
                gTempMatrix = (INT *)malloc(sizeof(INT)*gWidth*gHeight);

                if(nTileSize == 0)
                {
                    // 1x1 tilesize case.
                    
                    CreateOffscreenDIB(
                        hdc, 
                        rc.right - rc.left + 1, 
                        rc.bottom - rc.top + 1
                    );
                    
                    red   = rand() % 255;
                    green = rand() % 255;
                    blue  = min(255, 512 - (red + green));
                    
                    ri = (rand() % 3) - 1;  // 1, 0 or -1
                    bi = (rand() % 3) - 1;  // 1, 0 or -1
                    gi = (rand() % 3) - 1;  // 1, 0 or -1
                }
                else
                {   
                    // Image case.
                                 
                    CachedImages = new CachedImageArray();
                }
                
                maxImage = CBSIZE;
                currentImage = 0; // initial number
    
                // Set a timer for the screen saver window 
                
                uTimer = SetTimer(hwnd, 1, 1000, NULL); 
        
                srand( (unsigned)GetTickCount() );
            }
                
            break; 
 
        case WM_ERASEBKGND: 
            
            // The WM_ERASEBKGND message is issued before the 
            // WM_TIMER message, allowing the screen saver to 
            // paint the background as appropriate. 
 
            break; 
 
        case WM_TIMER: 
            
            // Only do work if we successfully initialized.
             
            if(GdiplusInitialized)
            {
                if (uTimer)
                {
                    KillTimer(hwnd, uTimer);
                }
    
                hdc = GetDC(hwnd); 
                GetClientRect(hwnd, &rc); 
    
                DrawLifeIteration(hdc);
    
                uTimer = SetTimer(hwnd, 1, nSpeed*10, NULL); 
    
                ReleaseDC(hwnd,hdc); 
            }
            break; 
 
        case WM_DESTROY: 
            
            // When the WM_DESTROY message is issued, the screen saver 
            // must destroy any of the timers that were set at WM_CREATE 
            // time. 
            
            // Only do work if we successfully initialized.
            
            if(GdiplusInitialized)
            {
                if (uTimer) 
                {
                    KillTimer(hwnd, uTimer); 
                }
                
                free(gTempMatrix);
                free(gLifeMatrix);
                FindClose(ghFile);
                
                delete CachedImages;
                
                GdiplusShutdown(gpToken);
                GdiplusInitialized = false;
            }
            
            break; 
    } 
 
    // DefScreenSaverProc processes any messages ignored by ScreenSaverProc. 
    
    #ifdef STANDALONE_DEBUG
    return DefWindowProc(hwnd, message, wParam, lParam); 
    #else
    return DefScreenSaverProc(hwnd, message, wParam, lParam); 
    #endif
} 



#define TEMP(x, y) gTempMatrix[ ((x+gWidth) % gWidth) + ((y+gHeight) % gHeight)*gWidth ]
#define LIFE(x, y) gLifeMatrix[ ((x+gWidth) % gWidth) + ((y+gHeight) % gHeight)*gWidth ]


inline bool AliveT(int x, int y)
{
    return (TEMP(x, y) & 0x1);
}

inline bool AliveL(int x, int y)
{
    return (LIFE(x, y) & 0x1);
}

inline INT CountT(int x, int y)
{
    return (TEMP(x, y) >> 1);
}

inline void NewCellL(INT x, INT y)
{
    ASSERT(!AliveL(x, y));
    
    // update current cell
    
    LIFE(x, y) += 1;
    
    // update neighbour counts.
    
    LIFE(x-1, y-1) += 2;
    LIFE(x-1, y  ) += 2;
    LIFE(x-1, y+1) += 2;
    LIFE(x  , y-1) += 2;
    LIFE(x  , y+1) += 2;
    LIFE(x+1, y-1) += 2;
    LIFE(x+1, y  ) += 2;
    LIFE(x+1, y+1) += 2;
}

inline void NewCellL_NoWrap(INT index)
{
    ASSERT(! (gLifeMatrix[index] & 0x1) );
    
    // update current cell
    
    gLifeMatrix[index] += 1;
    
    // update neighbour counts.
    
    gLifeMatrix[index - 1 - gWidth] += 2;
    gLifeMatrix[index - 1         ] += 2;
    gLifeMatrix[index - 1 + gWidth] += 2;

    gLifeMatrix[index     - gWidth] += 2;
    
    gLifeMatrix[index     + gWidth] += 2;
    
    gLifeMatrix[index + 1 - gWidth] += 2;
    gLifeMatrix[index + 1         ] += 2;
    gLifeMatrix[index + 1 + gWidth] += 2;
}

inline void KillCellL(INT x, INT y)
{
    ASSERT(AliveL(x, y));
    
    // update current cell
    
    LIFE(x, y) -= 1;
    
    // update neighbour counts.
    
    LIFE(x-1, y-1) -= 2;
    LIFE(x-1, y  ) -= 2;
    LIFE(x-1, y+1) -= 2;
    LIFE(x  , y-1) -= 2;
    LIFE(x  , y+1) -= 2;
    LIFE(x+1, y-1) -= 2;
    LIFE(x+1, y  ) -= 2;
    LIFE(x+1, y+1) -= 2;
}


inline void KillCellL_NoWrap(INT index)
{
    ASSERT(gLifeMatrix[index] & 0x1);
    
    // update current cell
    
    gLifeMatrix[index] -= 1;
    
    // update neighbour counts.
    
    gLifeMatrix[index - 1 - gWidth] -= 2;
    gLifeMatrix[index - 1         ] -= 2;
    gLifeMatrix[index - 1 + gWidth] -= 2;

    gLifeMatrix[index     - gWidth] -= 2;
    
    gLifeMatrix[index     + gWidth] -= 2;
    
    gLifeMatrix[index + 1 - gWidth] -= 2;
    gLifeMatrix[index + 1         ] -= 2;
    gLifeMatrix[index + 1 + gWidth] -= 2;
}


VOID InitLifeMatrix()
{
    memset(gLifeMatrix, 0, sizeof(INT)*gWidth*gHeight);
    if(nTileSize == 0)
    {
        ClearOffscreenDIB();
    }
    
    if((rand()%2 == 0) ||
       (gWidth<b_heptomino_x) ||
       (gHeight<b_heptomino_y))
    {
        for(int i=1; i<gWidth-1; i++)
        for(int j=1; j<gHeight-1; j++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL_NoWrap(i + j*gWidth);
            }
        }
        
        for(int i=0; i<gWidth; i++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL(i, 0);
            }
            if((rand() % 3) == 0)
            {
                NewCellL(i, gHeight-1);
            }
        }
        
        for(int j=1; j<gHeight-1; j++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL(0, j);
            }
            if((rand() % 3) == 0)
            {
                NewCellL(gWidth-1, j);
            }
        }
    }
    else
    {
        for(int i=0; i<b_heptomino_x; i++)
        for(int j=0; j<b_heptomino_y; j++)
        {
            if(b_heptomino[i+j*b_heptomino_x] != '0')
            {
                NewCellL(i, j);
            }
        }
    }
}


Bitmap *OpenBitmap()
{
    Bitmap *bmp = NULL;
    WIN32_FIND_DATA findData = {0};
    WCHAR filename[1024];
    
    do
    {
        // don't leak if we repeat this loop due to an invalid bitmap.
        
        delete bmp; bmp = NULL;
        
        if(ghFile)
        {
            if(!FindNextFileW(ghFile, &findData))
            {
                // finished going through the list.
                
                FindClose(ghFile);
                ghFile = 0;
                maxImage = currentImage;
                currentImage = 0;
                return NULL;
            }
        }
        
        if(!ghFile)
        {
            currentImage = 0;         // we're about to increment this.
            
            wsprintf(filename, L"%s\\*.*", gDirPath);
            ghFile = FindFirstFileW(filename, &findData);
            
            if(!ghFile)
            {
                return NULL;          // No files.
            }
        }
        
        if((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            wsprintf(
                filename, 
                L"%s\\%s", 
                gDirPath,
                findData.cFileName
            );
            
            bmp = new Bitmap(filename);
        }
        
        // !!! need to prevent infinite loops.
    } while ( 
        ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 
          FILE_ATTRIBUTE_DIRECTORY) ||
        (bmp->GetLastStatus() != Ok)
    );

    return bmp;    
}

VOID InitialPaintPicture(Graphics *g, CachedBitmap *cb)
{
    SolidBrush OffBrush(Color(0xff000000));
    
    for(int x=0; x<gWidth; x++)
    {
        for(int y=0; y<gHeight; y++)
        {
            if(AliveL(x, y))
            {
                g->DrawCachedBitmap(
                    cb, 
                    x*gSizeX, 
                    y*gSizeY
                );
            }
            else
            {
                // we should really use a bitblt for this.
                
                g->FillRectangle(
                    &OffBrush, 
                    x*gSizeX, 
                    y*gSizeY, 
                    gSizeX, 
                    gSizeY
                );
            }
        }
    }
}

VOID InitialPaintPixel()
{
    ASSERT(nTileSize == 0);
    
    DWORD *pixel = (DWORD*)(gOffscreenInfo.pvBits);
    
    ASSERT(pixel != NULL);
    
    for(int x=0; x<gWidth; x++)
    {
        for(int y=0; y<gHeight; y++)
        {
            // we know there's no wrapping, we shouldn't have to do the mod.
            INT index = x+y*gWidth;
            
            if(gLifeMatrix[index] & 0x1)
            {
                pixel[index] = gGenerationColor;
            }
        }
    }
}


CachedBitmap *MakeCachedBitmapEntry(Bitmap *bmp, Graphics *gfxMain)
{
    // Make a tile bitmap and wrap a graphics around it.
    
    Bitmap *tileBmp = new Bitmap(gSizeX, gSizeY, PixelFormat32bppPARGB);
    Graphics *g = new Graphics(tileBmp);
    
    // Shrink the image down to the tile size using the Bicubic filter.
    
    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);
    
    g->DrawImage(
        bmp, 
        Rect(0,0,gSizeX,gSizeY), 
        0, 
        0, 
        bmp->GetWidth(), 
        bmp->GetHeight(), 
        UnitPixel
    );

    // Create the CachedBitmap from the tile.
        
    CachedBitmap *cb = new CachedBitmap(tileBmp, gfxMain);
    
    // clean up.
    
    delete g; 
    delete tileBmp;
    
    return cb;
}

VOID IteratePixelGeneration()
{
    DWORD *pixel = (DWORD*)(gOffscreenInfo.pvBits);
    INT count;
    INT index = 1+gWidth;

    for(int y=1; y<gHeight-1; y++)
    {
        for(int x=1; x<gWidth-1; x++)
        {
            if(gTempMatrix[index] != 0)
            {
                // If the cell is not alive and it's neighbour count
                // is exactly 3, it is born.
                
                if( gTempMatrix[index] == 6 )
                {
                    // A new cell is born into an empty square.
                    
                    NewCellL_NoWrap(index);
                    pixel[index] = gGenerationColor;
                }
                else
                {
                    count = gTempMatrix[index] >> 1;
                    
                    // if the cell is alive and its neighbour count
                    // is not 2 or 3, it dies.
                    
                    if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                    {
                        // Kill the cell - overcrowding or not enough support.
                    
                        KillCellL_NoWrap(index);    
                        pixel[index] = 0;
                    }
                }
                
            }
            index++;
        }
        
        // skip the wrap boundaries.
        index += 2;
    }

    index = 0;
    
    for(int y=0; y<gHeight; y++)
    {
        // left vertical edge.
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(0, y);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(0, y);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        // right vertical edge
        
        index += gWidth-1;
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(gWidth-1, y);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(gWidth-1, y);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        // next scanline.
        
        index++;
    }


    index = 1;
    INT index2 = index + (gHeight-1)*gWidth;
    
    for(int x=1; x<gWidth-1; x++)
    {
        // top edge.
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(x, 0);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(x, 0);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        index++;
        
        // bottom edge
        
        if(gTempMatrix[index2] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index2] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(x, gHeight-1);
                pixel[index2] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index2] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index2] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(x, gHeight-1);    
                    pixel[index2] = 0;
                }
            }
            
        }
        
        // next pixel.
        
        index2++;
    }
}

VOID IteratePictureGeneration(Graphics &g, CachedBitmap *cb)
{
    SolidBrush OffBrush(Color(0xff000000));

    INT count;
    INT *cell = gTempMatrix;
    
    for(int y=0; y<gHeight; y++)
    {
        for(int x=0; x<gWidth; x++)
        {
            if(*cell != 0)
            {
                // If the cell is not alive and it's neighbour count
                // is exactly 3, it is born.
                
                if( *cell == 6 )
                {
                    // A new cell is born into an empty square.
                    
                    NewCellL(x, y);
    
                    g.DrawCachedBitmap(
                        cb, 
                        x*gSizeX, 
                        y*gSizeY
                    );
                }
                else
                {
                    count = *cell >> 1;
                    
                    // if the cell is alive and its neighbour count
                    // is not 2 or 3, it dies.
                    
                    if( (*cell & 0x1) && ((count<2) || (count>3)) )
                    {
                        // Kill the cell - overcrowding or not enough support.
                    
                        KillCellL(x, y);    
                        
                        g.FillRectangle(
                            &OffBrush, 
                            x*gSizeX, 
                            y*gSizeY, 
                            gSizeX, 
                            gSizeY
                        );
                    }
                }
                
            }
            cell++;
        }
    }
}

VOID RandomizeColor()
{
    if(rand() % 200 == 0)
    {
        ri = (rand() % 3) - 1;  // 1, 0 or -1
    }
    if(rand() % 200 == 0)
    {
        gi = (rand() % 3) - 1;  // 1, 0 or -1
    }
    if(rand() % 200 == 0)
    {
        bi = (rand() % 3) - 1;  // 1, 0 or -1
    }

    if((red < 100) && (green < 100) && (blue < 100))
    {
        if(red > green && red > blue)
        { 
            ri = 1;
        }
        else if (green > blue)
        {
            gi = 1;
        }
        else
        {
            bi = 1;
        }
    }        
    // bounce off the extrema.
    
    if(red == 0)
    {
        ri = 1;
    }
    
    if(red == 255)
    {
        ri = -1;
    }

    if(green == 0)
    {
        gi = 1;
    }
    
    if(green == 255)
    {
        gi = -1;
    }

    if(blue == 0)
    {
        bi = 1;
    }
    
    if(blue == 255)
    {
        bi = -1;
    }
    
    red   += ri;
    green += gi;
    blue  += bi;
}


VOID DrawLifeIteration(HDC hdc)
{
    // Are we initialized yet?
    
    if(!gLifeMatrix || !gTempMatrix) { return; }
    
    Graphics g(hdc);
    
    g.SetSmoothingMode(SmoothingModeNone);
    
    Bitmap *bmp = NULL;
    CachedBitmap *cb = NULL;
    
    // currentImage should never be larger than CBSIZE at this point.
    
    ASSERT(currentImage < CBSIZE);
    
    if(nTileSize==0)
    {
        // cycle color.
        
        RandomizeColor();
        gGenerationColor = RGB(red, green, blue);
    }
    else
    {
        // Fetch bitmaps from the image directory.
        
        if(currentImage >= CachedImages->Size()) {
        
            // We haven't filled up the cache yet. Keep opening images.    
        
            bmp = OpenBitmap();
        }
        
        // Did we get a new bitmap? 
        
        if(bmp)
        {
            cb = MakeCachedBitmapEntry(bmp, &g);
            
            if(cb)
            {
                // Put it in the cache.
                
                CachedImages->Add(cb);
                currentImage++;
            }
            
            delete bmp; bmp = NULL;
        }
        else
        {
            cb = (*CachedImages)[currentImage];
            currentImage++;
        }
        
        if( (currentImage >= CBSIZE) ||
            (currentImage >= maxImage)  )
        {
            currentImage = 0;
        }
        
        if(!cb)
        {
            // we failed to get an image tile.
            
            return;
        }
    }
    
    // update the generation and see if we need to do the first generation.
    
    //gCurrentGeneration--;
    if(gCurrentGeneration <= 0)
    {
        //    gCurrentGeneration = gGenerations;
        gCurrentGeneration++;
        InitLifeMatrix();
        if(nTileSize == 0)
        {
            InitialPaintPixel();
        }
        else 
        { 
            InitialPaintPicture(&g, cb);
        }
        goto Done;
    }
    gCurrentGeneration++;
    
    
    // Make a copy of the life matrix.
    
    memcpy(gTempMatrix, gLifeMatrix, sizeof(INT)*gWidth*gHeight);
    
    if(nTileSize==0)
    {
        IteratePixelGeneration();
        
        ASSERT(gSizeX == 1);
        ASSERT(gSizeY == 1);
        
        StretchBlt(
            hdc,
            0, 
            0, 
            gWidth, 
            gHeight,
            gOffscreenInfo.hdc,
            0, 
            0, 
            gWidth, 
            gHeight,
            SRCCOPY
        );
    }
    else
    {
        IteratePictureGeneration(g, cb);
    }
    
    // 5% mutation.
    /*
    if(((float)(rand())/RAND_MAX) < 0.05f)
    {
        int x = rand()*gWidth/RAND_MAX;
        int y = rand()*gHeight/RAND_MAX;
        
        if(AliveL(x, y))
        {
            KillCellL(x, y);
            
            g.FillRectangle(
                &OffBrush, 
                x*gSizeX, 
                y*gSizeY, 
                gSizeX, 
                gSizeY
            );
        }
        else
        {
            NewCellL(x, y);
            
            g.DrawCachedBitmap(
                cb, 
                x*gSizeX, 
                y*gSizeY
            );
        }
    }
    */
    Done:
    ;
}


#ifdef STANDALONE_DEBUG

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch(message)
    {
        // Handle the destroy message.
    
        case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        break;
    }
    
    // Hook into the screen saver windproc.
    
    return(ScreenSaverProcW(hwnd, message, wParam, lParam));
}

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hMainInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = L"MainMenu";
    wc.lpszClassName    = L"TestClass";

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowExW(
        0,
        L"TestClass",
        L"Win32 Test",
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        800,
        600,
        NULL,
        NULL,
        hMainInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}



void _cdecl main(
    INT   argc,
    PCHAR argv[]
)
{
    MSG    msg;

    hMainInstance = GetModuleHandle(NULL);

    if(!bInitApp()) {return;}

    while(GetMessage (&msg, NULL, 0, 0))
    {
        if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
            TranslateMessage(&msg) ;
            DispatchMessage(&msg) ;
        }
    }

    return;
    UNREF(argc);
    UNREF(argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sdktest.rc
//
#define IDC_MYICON                      2
#define IDD_TESTBED_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDM_SETTINGS                    106
#define IDI_SDKTEST                     107
#define IDI_SMALL                       108
#define IDC_SDKTEST                     109
#define IDD_SETTINGS                    110
#define IDR_MAINFRAME                   128

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\sdktest.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#include "gdiplus.h"

using namespace Gdiplus;

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sdk\sdktest.cpp ===
// sdktest.cpp : Defines the entry point for the application.
//

#include "sdktest.h"

#include "..\gpinit.inc"

#include <stdio.h>

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                    // current instance
HWND hWndMain = NULL;
TCHAR szTitle[MAX_LOADSTRING];        // The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];// The title bar text

// Foward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    Settings(HWND, UINT, WPARAM, LPARAM);

UINT_PTR timerID = 0;
int timercount = 0;
BOOL suspend = FALSE;

typedef struct
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
}
OFFSCREENINFO;

OFFSCREENINFO offscreenInfo = { 0 };

void FreeOffscreen()
{
    if (offscreenInfo.hdc)
    {
        SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOld);
        DeleteObject(offscreenInfo.hbmpOffscreen);
        DeleteDC(offscreenInfo.hdc);

        offscreenInfo.hdc = (HDC)NULL;
        offscreenInfo.hbmpOffscreen = (HBITMAP)NULL;
        offscreenInfo.hbmpOld = (HBITMAP)NULL;
        offscreenInfo.bmi.bmiHeader.biWidth = 0;
        offscreenInfo.bmi.bmiHeader.biHeight = 0;
    }
}

void ClearOffscreen()
{
    if (offscreenInfo.hdc)
    {
        PatBlt(
            offscreenInfo.hdc,
            0,
            0,
            offscreenInfo.bmi.bmiHeader.biWidth,
            offscreenInfo.bmi.bmiHeader.biHeight,
            WHITENESS);
    }

    InvalidateRect(hWndMain, NULL, TRUE);
}

HDC GetOffscreen(HDC hDC, int width, int height)
{
    HDC hdcResult = NULL;

    if (width > offscreenInfo.bmi.bmiHeader.biWidth ||
        height > offscreenInfo.bmi.bmiHeader.biHeight ||
        offscreenInfo.hdc == (HDC)NULL)
    {
        FreeOffscreen();

        offscreenInfo.bmi.bmiHeader.biSize = sizeof(offscreenInfo.bmi.bmiHeader);
        offscreenInfo.bmi.bmiHeader.biWidth = width;
        offscreenInfo.bmi.bmiHeader.biHeight = height;
        offscreenInfo.bmi.bmiHeader.biPlanes = 1;
        offscreenInfo.bmi.bmiHeader.biBitCount = 32;
        offscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;
        offscreenInfo.bmi.bmiHeader.biSizeImage = 0;
        offscreenInfo.bmi.bmiHeader.biXPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biYPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biClrUsed = 0;
        offscreenInfo.bmi.bmiHeader.biClrImportant = 0;

        offscreenInfo.hbmpOffscreen = CreateDIBSection(
            hDC,
            &offscreenInfo.bmi,
            DIB_RGB_COLORS,
            &offscreenInfo.pvBits,
            NULL,
            0);

        if (offscreenInfo.hbmpOffscreen)
        {
            offscreenInfo.hdc = CreateCompatibleDC(hDC);

            if (offscreenInfo.hdc)
            {
                offscreenInfo.hbmpOld = (HBITMAP)SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOffscreen);

                ClearOffscreen();
            }
        }
    }

    hdcResult = offscreenInfo.hdc;

    return hdcResult;
}

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    if (!gGdiplusInitHelper.IsValid())
        return 0;

    // Initialize global strings
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadString(hInstance, IDC_SDKTEST, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) 
    {
        return FALSE;
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_SDKTEST);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    FreeOffscreen();

    return (int)msg.wParam;
}


//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style            = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra        = 0;
    wcex.cbWndExtra        = 0;
    wcex.hInstance        = hInstance;
    wcex.hIcon            = LoadIcon(hInstance, (LPCTSTR)IDI_SDKTEST);
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground    = (HBRUSH)NULL;
    wcex.lpszMenuName    = (LPCSTR)IDC_SDKTEST;
    wcex.lpszClassName    = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

    return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT rectDesktop;
    RECT rectWnd;

    HWND hWndDesktop = GetDesktopWindow();

    GetWindowRect(hWndDesktop, &rectDesktop);

    rectWnd = rectDesktop;

    rectWnd.top += 100;
    rectWnd.left += 100;
    rectWnd.right -= 100;
    rectWnd.bottom -= 100;

    hInst = hInstance; // Store instance handle in our global variable

    hWndMain = CreateWindow(
        szWindowClass,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
        NULL,
        NULL,
        hInstance,
        NULL);

    if (!hWndMain)
    {
        return FALSE;
    }

    ShowWindow(hWndMain, nCmdShow);
    UpdateWindow(hWndMain);

    timerID = SetTimer(hWndMain, 1, 10, NULL);

    return TRUE;
}

void DrawGraphics(HWND hWnd, HDC hDC, LPRECT lpRectDraw, LPRECT lpRectBounds)
{
    RECT rectBounds = *lpRectDraw;
    Graphics *gr = NULL;

    gr = new Graphics(hDC);

    gr->ResetTransform();
    gr->SetPageUnit(UnitPixel);

    //===================================================================
    //
    // Insert your SDK code here \|/  \|/  \|/  \|/
    //
    //===================================================================


    //===================================================================
    //
    // Insert your SDK code here /|\  /|\  /|\  /|\
    //
    //===================================================================

    if (lpRectBounds)
    {
        *lpRectBounds = rectBounds;
    }

    delete gr;
}

LRESULT PaintWnd(HWND hWnd, HDC hDC)
{
    RECT rectClient;
    RECT rectDraw;
    
    GetClientRect(hWnd, &rectClient);

    int width  = rectClient.right - rectClient.left;
    int height = rectClient.bottom - rectClient.top;

    // Setup the drawing rectangle relative to the client
    rectDraw.left   = 0;
    rectDraw.top    = 0;
    rectDraw.right  = (rectClient.right - rectClient.left);
    rectDraw.bottom = (rectClient.bottom - rectClient.top);

    // Now draw within this rectangle with GDI+ ...
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HDC hdcOffscreen = NULL;
        int width, height;
        RECT rectOffscreen;

        width = rectDraw.right - rectDraw.left;
        height = rectDraw.bottom - rectDraw.top;

        rectOffscreen.left   = 0;
        rectOffscreen.top    = 0;
        rectOffscreen.right  = width;
        rectOffscreen.bottom = height;

        hdcOffscreen = GetOffscreen(hDC, width, height);

        if (hdcOffscreen)
        {
            DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, NULL);

            StretchBlt(
                hDC,
                rectDraw.left,
                rectDraw.top,
                width,
                height,
                hdcOffscreen,
                0,
                0,
                width,
                height,
                SRCCOPY);
        }

        ReleaseDC(hWnd, hDC);
    }

    return 0;
}

static RECT rectLast = {0, 0, 0, 0};

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND    - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY    - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message) 
    {
        case WM_WINDOWPOSCHANGED:
        {
            timercount = 0;
            ClearOffscreen();
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            timercount = 0;
            ClearOffscreen();
        }
        break;

        case WM_RBUTTONDOWN:
        {
        }
        break;

        case WM_TIMER:
        {
        }
        break;

        case WM_COMMAND:
        {
            int wmId, wmEvent;

            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_SETTINGS:
                {
                    suspend = TRUE;
                    if (DialogBox(hInst, (LPCTSTR)IDD_SETTINGS, hWnd, Settings) == IDOK)
                    {
                        timercount = 0;
                        ClearOffscreen();
                    }

                    InvalidateRect(hWnd, NULL, TRUE);
                    suspend = FALSE;
                }
                break;

                case IDM_ABOUT:
                    DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, About);
                break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                break;

                default:
                    lresult = DefWindowProc(hWnd, message, wParam, lParam);
                break;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hWnd, &ps);

            lresult = PaintWnd(hWnd, hdc);

            EndPaint(hWnd, &ps);
        }
        break;

        case WM_DESTROY:
        {
            PostQuitMessage(0);
        }
        break;

        default:
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
   }

   return lresult;
}

// Mesage handler for about box.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
            lresult = TRUE;
        break;

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                lresult = TRUE;
            }
        }
        break;
    }

    return lresult;
}

// Message handler for settings dlg
INT_PTR CALLBACK Settings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            lresult = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                }
                // break; - fall through so the dialog closes!

                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    lresult = TRUE;
                }
                break;
            }
        }
        break;
    }

    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\cobject.h ===
// CObject.h: interface for the CObject class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __COBJECT_H
#define __COBJECT_H

#include <windows.h>
#include <math.h>
#include <objbase.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include "VMath.h"
#include "resource.h"
#include "scrnsave.h"

extern Bitmap *LoadTGAResource(char *szResource);

class CObject  
{
public:
	CObject();
	virtual ~CObject();

	virtual void Destroy()=0;
	virtual BOOL Init(HWND hWnd)=0;
	virtual BOOL Move(Graphics *g)=0;

	PointF m_vPos;
	PointF m_vVel;
	PointF m_vAcc;
	float m_flVelMax;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\csweeper.cpp ===
// CSweeper.cpp: implementation of the CSweeper class.
//
//////////////////////////////////////////////////////////////////////

#include "CSweeper.h"

extern TextureBrush *g_paBrCleanBkg;
extern Bitmap *g_paBmDirtyBkg;

CSweeper::CSweeper()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	ZeroMemory(&m_vLastPos,sizeof(m_vLastPos));
	m_flStepRadius=0.0f;
	m_flBroomWidth=0.0f;
	m_flSweepLength=0.0f;
	m_paBroomOn=NULL;
	m_paBroomOff=NULL;
	m_paBackground=NULL;
	m_bSweeping=false;
	m_flLastAngle=0.0f;
	m_flDist=0.0f;
}

CSweeper::~CSweeper()
{
	Destroy();
}

void CSweeper::Destroy()
{
	if (m_paBroomOn!=NULL) {
		delete m_paBroomOn;
		m_paBroomOn=NULL;
	}
	if (m_paBroomOff!=NULL) {
		delete m_paBroomOff;
		m_paBroomOff=NULL;
	}
	if (m_paBackground!=NULL) {
		delete m_paBackground;
		m_paBackground=NULL;
	}
}

BOOL CSweeper::Init(HWND hWnd)
{
	int nRand;
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions (top/left can be negative on multimon)
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	m_flVelMax=((float)rand()/(float)RAND_MAX)*20.0f+20.0f;
	m_paBroomOn=LoadTGAResource(MAKEINTRESOURCE(IDR_BROOMON));
	m_paBroomOff=LoadTGAResource(MAKEINTRESOURCE(IDR_BROOMOFF));
	m_nSnapshotSize=(int)sqrt(m_paBroomOn->GetWidth()*m_paBroomOn->GetWidth()+(m_paBroomOn->GetHeight()+m_flVelMax*2.0f)*(m_paBroomOn->GetHeight()+m_flVelMax*2.0f));
	m_paBackground=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppPARGB);

	nRand=rand();
	if (nRand<RAND_MAX/4) {			// Start walking from the left side of desktop
		m_vPos.X=(float)m_rDesktop.left;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<2*RAND_MAX/4) {	// Start walking from the right side of desktop
		m_vPos.X=(float)m_rDesktop.right;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<3*RAND_MAX/4) {	// Start walking from the top side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*5.0f;
	}
	else {							// Start walking from the bottom side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.bottom;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*-5.0f;
	}

	m_vAcc.X=((float)rand()/(float)RAND_MAX)*1.0f-0.5f;
	m_vAcc.Y=((float)rand()/(float)RAND_MAX)*1.0f-0.5f;
	m_flStepRadius=((float)rand()/(float)RAND_MAX)*10.0f+45.0f;
	m_flBroomWidth=m_paBroomOn->GetWidth()-6.0f;
	m_flSweepLength=((float)rand()/(float)RAND_MAX)*50.0f+200.0f;
	m_flStepRadius=m_flSweepLength;
	m_vVel=Normalize(m_vVel);
	m_vVel.X*=m_flVelMax;
	m_vVel.Y*=m_flVelMax;
	m_vLastPos=m_vPos;

	m_bSweeping=false;
	m_flDist=0.0f;
	m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	return true;
}

BOOL CSweeper::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	float flAngle;
	float flAngleDist;

	if (m_bSweeping) {
		m_vPos=m_vPos+m_vVel;
		if ((m_vPos.X<(float)m_rDesktop.left-m_flSweepLength) ||
			(m_vPos.X>(float)m_rDesktop.right+m_flSweepLength) ||
			(m_vPos.Y<(float)m_rDesktop.top-m_flSweepLength) ||
			(m_vPos.Y>(float)m_rDesktop.bottom+m_flSweepLength)) {
			// If sweeper is outside desktop, erase it and remove it
			NoSweep(g);
			return false;
		}

		Sweep(g);
	}
	else {
		NoSweep(g);
	}

	if (!m_bSweeping && (m_flDist==0.0f)) {
		// If not sweeping and broom is back at distance 0, start next sweep
		m_bSweeping=true;
		m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
		m_vPos.X=m_vPos.X-m_vVel.X*(m_flSweepLength/m_flVelMax*0.75f);
		m_vPos.Y=m_vPos.Y-m_vVel.Y*(m_flSweepLength/m_flVelMax*0.75f);
		m_vLastPos=m_vPos;

		flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
		flAngleDist=((float)rand()/(float)RAND_MAX)*40.0f-20.0f;
		flAngle+=flAngleDist;
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*m_flVelMax;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*m_flVelMax;
	}

	return true;
}

void CSweeper::Sweep(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flBroomWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paBroomOn->GetWidth(),(float)m_paBroomOn->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Pen pen(Color(10,0,0,0),2);
	Graphics *gDirty;

	if (m_flDist!=0.0f) {	// If broom has moved already, erase a rect on dirty background
		// Set up the brush transform (opposite from original transform)
		g_paBrCleanBkg->ResetTransform();
		mat.Reset();
		mat.Translate(0.0f,-m_flDist);
		mat.Translate(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()+20.0f);
		mat.Rotate(-m_flLastAngle-270.0f);
		mat.Translate(-m_vLastPos.X+m_rDesktop.left,-m_vLastPos.Y+m_rDesktop.top);
		g_paBrCleanBkg->SetTransform(&mat);

		// Set up original transform and erase from DirtyBkg a rectangle where the broom moved
		gDirty=new Graphics(g_paBmDirtyBkg);
		gDirty->TranslateTransform(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
		gDirty->RotateTransform(m_flLastAngle+270.0f);
		gDirty->TranslateTransform((float)m_paBroomOn->GetWidth()/2.0f,(float)m_paBroomOn->GetHeight()-20.0f);
		gDirty->TranslateTransform(0.0f,m_flDist);
		gDirty->FillRectangle(g_paBrCleanBkg,rect);

		// Draw dirty lines around the broom, to simulate dirty that fell beside the broom
		gDirty->DrawLine(&pen,0.0f,0.0f,0.0f,m_flVelMax+2);
		gDirty->DrawLine(&pen,0.0f,m_flVelMax+2,m_flBroomWidth,m_flVelMax+2);
		gDirty->DrawLine(&pen,m_flBroomWidth,m_flVelMax+2,m_flBroomWidth,0.0f);

		delete gDirty;
	}

	// Get the bounds of the broom after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	mat.Rotate(m_flLastAngle+270.0f);
	mat.Translate(m_flBroomWidth/2.0f,0.0);
	mat.Translate(0.0f,m_flDist);
	Path.GetBounds(&rect,&mat,&pen);

	// Draw on a temp surface whatever was on the dirty background where the broom is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X,(int)rect.Y,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw broom on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+270.0f);
	gBackground->TranslateTransform(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()/2.0f+m_flVelMax/2.0f);
	gBackground->DrawImage(m_paBroomOn,0,0,0,0,m_paBroomOn->GetWidth(),m_paBroomOn->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X,(int)rect.Y,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Update distance, continue the sweep
	m_flDist+=m_flVelMax;
	if (m_flDist>m_flSweepLength) {
		// If sweep is at the end, start moving broom back
		m_flDist-=m_flVelMax;
		m_bSweeping=false;
	}
}

void CSweeper::NoSweep(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flBroomWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paBroomOn->GetWidth(),(float)m_paBroomOn->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Pen pen(Color(20,0,0,0),2);

	// Get the bounds of the broom after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X,m_vLastPos.Y);
	mat.Rotate(m_flLastAngle+270.0f);
	mat.Translate(m_flBroomWidth/2.0f,0.0f);
	mat.Translate(0.0f,m_flDist);
	Path.GetBounds(&rect,&mat,&pen);

	// Draw on a temp surface whatever was on the dirty background where the broom is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw broom on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+270.0f);
	gBackground->TranslateTransform(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()/2.0f-m_flVelMax/2.0f);
	gBackground->DrawImage(m_paBroomOff,0,0,0,0,m_paBroomOn->GetWidth(),m_paBroomOn->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Update distance, continue moving back to start of sweep
	m_flDist-=m_flVelMax;
	if (m_flDist<=(m_flSweepLength/m_flVelMax*0.25f)*Magnitude(m_vVel)) {
		// If all the way back, erase last broom, and get ready for next sweep
		g->DrawImage(g_paBmDirtyBkg,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.Width,(int)rect.Height,UnitPixel);
		m_flDist=0.0f;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\csqueegee.cpp ===
// CSqueegee.cpp: implementation of the CSqueegee class.
//
//////////////////////////////////////////////////////////////////////

#include "CSqueegee.h"

extern TextureBrush *g_paBrCleanBkg;
extern Bitmap *g_paBmDirtyBkg;

CSqueegee::CSqueegee()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	ZeroMemory(&m_vLastPos,sizeof(m_vLastPos));
	m_flSqueegeeWidth=0.0f;
	m_paSqueegee=NULL;
	m_paBackground=NULL;
	m_flLastAngle=0.0f;
}

CSqueegee::~CSqueegee()
{
	Destroy();
}

void CSqueegee::Destroy()
{
	if (m_paSqueegee!=NULL) {
		delete m_paSqueegee;
		m_paSqueegee=NULL;
	}
	if (m_paBackground!=NULL) {
		delete m_paBackground;
		m_paBackground=NULL;
	}
}

BOOL CSqueegee::Init(HWND hWnd)
{
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions (left/top can be negative on multimon)
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	m_flVelMax=((float)rand()/(float)RAND_MAX)*10.0f+35.0f;
	m_paSqueegee=LoadTGAResource(MAKEINTRESOURCE(IDR_SQUEEGEE));
	m_nSnapshotSize=(int)sqrt(m_paSqueegee->GetWidth()*m_paSqueegee->GetWidth()+(m_paSqueegee->GetHeight()+m_flVelMax*2.0f)*(m_paSqueegee->GetHeight()+m_flVelMax*2.0f));
	m_paBackground=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppPARGB);
	m_flSqueegeeWidth=m_paSqueegee->GetWidth()-6.0f;

	// Squeegees start from top left corner
	m_vPos.X=(float)m_rDesktop.left-(float)m_nSnapshotSize/2.0f;
	m_vPos.Y=(float)m_rDesktop.top+m_flSqueegeeWidth/2.0f;
	m_vVel.X=m_flVelMax;
	m_vVel.Y=0.0f;
	m_vAcc.X=0.0f;
	m_vAcc.Y=0.0f;

	m_vLastPos=m_vPos;
	m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	return true;
}

BOOL CSqueegee::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	// Update position and other variables
	m_vLastPos=m_vPos;
	m_vPos=m_vPos+m_vVel;
	if ((m_vPos.X<(float)m_rDesktop.left-(float)m_nSnapshotSize) ||
		(m_vPos.X>(float)m_rDesktop.right+(float)m_nSnapshotSize)) {
		// If past the left/right edge of the screen, turn around and move down a notch
		m_vPos.Y+=m_flSqueegeeWidth-10.0f;
		m_vVel.X*=-1.0f;
		m_flLastAngle+=180.0f;
	}
	else if (m_vPos.Y>(float)m_rDesktop.bottom+(float)m_nSnapshotSize) {
		// If past the bottom of the screen, its done
		return false;
	}

	Wipe(g);

	return true;
}

void CSqueegee::Wipe(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flSqueegeeWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paSqueegee->GetWidth(),(float)m_paSqueegee->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Graphics *gDirty;

	// Set up the brush transform (opposite from original transform)
	g_paBrCleanBkg->ResetTransform();
	mat.Reset();
	mat.Translate((float)m_paSqueegee->GetWidth()/2.0f-5.0f,-(float)m_paSqueegee->GetHeight()+30.0f);
	mat.Rotate(-m_flLastAngle-90.0f);
	mat.Translate(-m_vLastPos.X+m_rDesktop.left,-m_vLastPos.Y+m_rDesktop.top);
	g_paBrCleanBkg->SetTransform(&mat);

	// Set up original transform and erase from DirtyBkg a rectangle where the squeegee moved
	gDirty=new Graphics(g_paBmDirtyBkg);
	gDirty->TranslateTransform(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	gDirty->RotateTransform(m_flLastAngle+90.0f);
	gDirty->TranslateTransform(-(float)m_paSqueegee->GetWidth()/2.0f+5.0f,(float)m_paSqueegee->GetHeight()-30.0f);
	gDirty->FillRectangle(g_paBrCleanBkg,rect);
	delete gDirty;

	// Get the bounds of the squeegee after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	mat.Rotate(m_flLastAngle+90.0f);
	mat.Translate(-m_flSqueegeeWidth/2.0f,0.0);
	Path.GetBounds(&rect,&mat,NULL);

	// Draw on a temp surface whatever was on the dirty background where the squeegee is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X,(int)rect.Y,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw squeegee on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+90.0f);
	gBackground->TranslateTransform(-(float)m_paSqueegee->GetWidth()/2.0f,-(float)m_paSqueegee->GetHeight()/2.0f-m_flVelMax);
	gBackground->DrawImage(m_paSqueegee,0,0,0,0,m_paSqueegee->GetWidth(),m_paSqueegee->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X,(int)rect.Y,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\cperson.cpp ===
// CPerson.cpp: implementation of the CPerson class.
//
//////////////////////////////////////////////////////////////////////

#include "CPerson.h"

extern Bitmap *g_paBmDirtyBkg;

CPerson::CPerson()
{
	m_flStepRadius=0.0f;
	m_flStepWidth=0.0f;
	m_eLastStep=eStepLeft;
	m_paFoot=NULL;
	m_paBlended=NULL;
	m_paIndented=NULL;
	m_nSnapshotSize=0;
	m_nFootWidth=0;
	m_nFootHeight=0;
	ZeroMemory(&m_vLastStep,sizeof(m_vLastStep));
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
}

CPerson::~CPerson()
{
	Destroy();
}

void CPerson::Destroy()
{
	if (m_paFoot!=NULL) {
		delete m_paFoot;
		m_paFoot=NULL;
	}
	if (m_paBlended!=NULL) {
		delete m_paBlended;
		m_paBlended=NULL;
	}
	if (m_paIndented!=NULL) {
		delete m_paIndented;
		m_paIndented=NULL;
	}
}

BOOL CPerson::Init(HWND hWnd)
{
	int nRand;
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions, top/left can be negative on multimon
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	// Randomly pick picture to use as foot
	nRand=rand();
	if (nRand<RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BAREFOOT));
	}
	else if (nRand<2*RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BOOT));
	}
	else if (nRand<3*RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BOOT2));
	}
	else {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_DOG));
	}
	if (m_paFoot==NULL) { return false; }
	m_nFootWidth=m_paFoot->GetWidth();
	m_nFootHeight=m_paFoot->GetHeight();
	m_nSnapshotSize=(int)sqrt(m_nFootWidth*m_nFootWidth+m_nFootHeight*m_nFootHeight);
	m_paBlended=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppARGB);
	m_paIndented=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppARGB);

	nRand=rand();
	// Here we assume m_rDesktop.left<=0, m_rDesktop.top<=0, m_rDesktop.right>=0, m_rDesktop.bottom>=0
	if (nRand<RAND_MAX/4) {			// Start walking from the left side of desktop
		m_vPos.X=(float)m_rDesktop.left;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<2*RAND_MAX/4) {	// Start walking from the right side of desktop
		m_vPos.X=(float)m_rDesktop.right;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<3*RAND_MAX/4) {	// Start walking from the top side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*5.0f;
	}
	else {							// Start walking from the bottom side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.bottom;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*-5.0f;
	}

	m_vAcc.X=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	m_vAcc.Y=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	m_flStepRadius=((float)rand()/(float)RAND_MAX)*10.0f+45.0f;
	m_flStepWidth=((float)rand()/(float)RAND_MAX)*10.0f+35.0f;
	m_flVelMax=((float)rand()/(float)RAND_MAX)*10.0f+20.0f;
	m_vLastStep=m_vPos;

	return true;
}

BOOL CPerson::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	float flAngle;
	float flOldAngle;
	float flAngleDist;
	float flMagnitude;

	flOldAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	// Move position and update variables
	m_vPos=m_vPos+m_vVel;
	m_vVel=m_vVel+m_vAcc;
	if (Magnitude(m_vVel)>m_flVelMax) {
		m_vVel.X=Normalize(m_vVel).X*m_flVelMax;
		m_vVel.Y=Normalize(m_vVel).Y*m_flVelMax;
	}

	// If outside desktop, return false (which will terminate the person)
	if ((m_vPos.X<(float)m_rDesktop.left-m_flStepRadius) ||
		(m_vPos.X>(float)m_rDesktop.right+m_flStepRadius) ||
		(m_vPos.Y<(float)m_rDesktop.top-m_flStepRadius) ||
		(m_vPos.Y>(float)m_rDesktop.bottom+m_flStepRadius)) {
		return false;
	}

	// Make sure we don't step more than 45 degrees away from original direction
	flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
	flAngleDist=flAngle-flOldAngle;
	while (flAngleDist<0.0f) { flAngleDist+=360.0f; }
	while (flAngleDist>=360.0f) { flAngleDist-=360.0f; }
	if ((flAngleDist>45.0f) && (flAngleDist<=180.0f)) {
		flAngle=flOldAngle+45.0f;
		flMagnitude=Magnitude(m_vVel);
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*flMagnitude;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*flMagnitude;
	}
	else if ((flAngleDist<315.0f) && (flAngleDist>=180.0f)) {
		flAngle=flOldAngle-45.0f;
		flMagnitude=Magnitude(m_vVel);
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*flMagnitude;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*flMagnitude;
	}

	// Is it time for another step?
	if (Magnitude(m_vLastStep-m_vPos)>m_flStepRadius) {
		DrawStep(g);
		if (m_eLastStep==eStepLeft) {
			m_eLastStep=eStepRight;
		}
		else {
			m_eLastStep=eStepLeft;
		}

		// Took a step, update acceleration (random)
		m_vLastStep=m_vPos;
		m_vAcc.X=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
		m_vAcc.Y=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	}

	return true;
}

void CPerson::DrawStep(Graphics *g)
{
	Rect rBitmapSize(0,0,m_nSnapshotSize,m_nSnapshotSize);
	Point ptPixel;
	Color Pixel;
	int nAlpha;
	Point ptCenter;
	Point ptOffset;
	float flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
	Graphics *gBlended;
	Graphics *gIndented;
	int i,j;

	// Find out center of where the foot will land
	g->ResetTransform();
	g->TranslateTransform(m_vPos.X,m_vPos.Y);
	g->RotateTransform(flAngle+270.0f);
	if (m_eLastStep==eStepLeft) {
		g->TranslateTransform(-m_flStepWidth,0.0f);
	}
	else {
		g->TranslateTransform(m_flStepWidth,0.0f);
	}
	ptCenter.X=m_nSnapshotSize/2;
	ptCenter.Y=m_nSnapshotSize/2;
	g->TransformPoints(CoordinateSpaceDevice,CoordinateSpaceWorld,&ptCenter,1);

	// Take snapshot of larger area where foot will land
	gBlended=new Graphics(m_paBlended);
	gBlended->DrawImage(g_paBmDirtyBkg,0,0,ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left,ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	// Draw stamp (dirt) of foot on that snapshot
	gBlended->SetSmoothingMode(SmoothingModeAntiAlias);
	gBlended->SetInterpolationMode(InterpolationModeNearestNeighbor);//Bicubic);
	gBlended->TranslateTransform((float)(m_nSnapshotSize/2),(float)(m_nSnapshotSize/2));
	gBlended->RotateTransform(flAngle+270.0f);
	if (m_eLastStep==eStepLeft) {
		gBlended->ScaleTransform(-1,1);
	}
	gBlended->TranslateTransform(-(float)(m_nFootWidth/2),-(float)(m_nFootHeight/2));
	gBlended->DrawImage(m_paFoot,0,0,0,0,m_paFoot->GetWidth(),m_paFoot->GetHeight(),UnitPixel);
	gBlended->ResetTransform();

	// Blit that snapshot to another temporary surface
	gIndented=new Graphics(m_paIndented);
	gIndented->SetCompositingMode(CompositingModeSourceCopy);
	gIndented->DrawImage(m_paBlended,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	delete gBlended;
	delete gIndented;

	// Get the transform from snapshot to foot surface
	g->ResetTransform();
	g->TranslateTransform((float)(m_nFootWidth/2),(float)(m_nFootHeight/2));
	if (m_eLastStep==eStepRight) {
		g->ScaleTransform(-1,1);
	}
	g->RotateTransform(-flAngle-270.0f);
	g->TranslateTransform(-(float)(m_nSnapshotSize/2),-(float)(m_nSnapshotSize/2));

	// Create indent 3D look by bringing pixels closer to center depending on
	//  their distance relative to the alpha
	for (i=0;i<m_nSnapshotSize;i++) {
		for (j=0;j<m_nSnapshotSize;j++) {
			ptPixel.X=i;
			ptPixel.Y=j;
			g->TransformPoints(CoordinateSpaceDevice,CoordinateSpaceWorld,&ptPixel,1);
			// Find out if pixel is on the foot surface
			if ((ptPixel.X>=0) && (ptPixel.X<(int)m_nFootWidth) &&
				(ptPixel.Y>=0) && (ptPixel.Y<(int)m_nFootHeight)) {
				// If it is, find out if the alpha is > 0
				m_paFoot->GetPixel(ptPixel.X,ptPixel.Y,&Pixel);
				nAlpha=Pixel.GetA();
				if (nAlpha>0) {
					// If it is, move that pixel closer to middle of foot depending on the distance and alpha
					m_paBlended->GetPixel(i,j,&Pixel);
					ptOffset.X=(int)((m_nSnapshotSize/2-i)*(1.0f-(float)nAlpha/1024.0f));
					ptOffset.Y=(int)((m_nSnapshotSize/2-j)*(1.0f-(float)nAlpha/1024.0f));
					m_paIndented->SetPixel(m_nSnapshotSize/2-ptOffset.X,m_nSnapshotSize/2-ptOffset.Y,Pixel);
				}
			}
		}
	}

	// Draw the foot print result on the screen
	g->ResetTransform();
	g->TranslateTransform((float)(ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left),(float)(ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top));
	g->DrawImage(m_paIndented,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	// Draw the foot print result on the dirty background as well
	g=new Graphics(g_paBmDirtyBkg);
	g->TranslateTransform((float)(ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left),(float)(ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top));
	g->DrawImage(m_paIndented,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);
	delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\csqueegee.h ===
// CSqueegee.h: interface for the CSqueegee class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CSQUEEGEE_H
#define __CSQUEEGEE_H

#include "CObject.h"

class CSqueegee : public CObject
{
public:
	CSqueegee();
	virtual ~CSqueegee();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void Wipe(Graphics *g);

	Bitmap *m_paSqueegee;
	Bitmap *m_paBackground;
	Bitmap *m_paOriginalBkg;
	int m_nSnapshotSize;
	float m_flSqueegeeWidth;
	PointF m_vLastPos;
	float m_flLastAngle;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\cobject.cpp ===
// CObject.cpp: implementation of the CObject class.
//
//////////////////////////////////////////////////////////////////////

#include "CObject.h"

CObject::CObject()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	m_flVelMax=0.0f;
}

CObject::~CObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\cperson.h ===
// CPerson.h: interface for the CPerson class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CPERSON_H
#define __CPERSON_H

#include "CObject.h"

enum ENUM_PERSONSTEP {
	eStepLeft=0,
	eStepRight
};

class CPerson : public CObject
{
public:
	CPerson();
	virtual ~CPerson();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void DrawStep(Graphics *g);

	Bitmap *m_paFoot;
	Bitmap *m_paBlended;
	Bitmap *m_paIndented;
	int m_nSnapshotSize;
	int m_nFootWidth;
	int m_nFootHeight;
	float m_flStepRadius;
	float m_flStepWidth;
	PointF m_vLastStep;
	ENUM_PERSONSTEP m_eLastStep;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\csweeper.h ===
// CSweeper.h: interface for the CSweeper class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CSWEEPER_H
#define __CSWEEPER_H

#include "CObject.h"

class CSweeper : public CObject
{
public:
	CSweeper();
	virtual ~CSweeper();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void Sweep(Graphics *g);
	void NoSweep(Graphics *g);

	Bitmap *m_paBroomOn;
	Bitmap *m_paBroomOff;
	Bitmap *m_paBackground;
	Bitmap *m_paOriginalBkg;
	int m_nSnapshotSize;
	float m_flBroomWidth;
	float m_flSweepLength;
	float m_flStepRadius;
	PointF m_vLastPos;
	float m_flLastAngle;
	float m_flDist;
	BOOL m_bSweeping;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\vmath.h ===
// Vector Math

#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <gdiplus.h>
using namespace Gdiplus;

extern float DotProduct(PointF v1,PointF v2);
extern float Magnitude(PointF v);
extern PointF Normalize(PointF vPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\loadtga.cpp ===
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>
using namespace Gdiplus;

Bitmap *LoadTGAResource(char *szResource)
// Returns an allocated Bitmap
{
	BYTE Type;
	WORD wWidth;
	WORD wHeight;
	BYTE cBits;
	HGLOBAL hGlobal=NULL;
	BYTE *pData=NULL;

	hGlobal=LoadResource(GetModuleHandle(NULL),FindResource(GetModuleHandle(NULL),szResource,"TGA"));
	pData=(BYTE*)LockResource(hGlobal);
	// There is no Unlock or unload, it will get thrown away once module gets destroyed.

	memcpy(&Type,(pData+2),sizeof(Type));
	memcpy(&wWidth,(pData+12),sizeof(wWidth));
	memcpy(&wHeight,(pData+14),sizeof(wHeight));
	memcpy(&cBits,(pData+16),sizeof(cBits));

	if (cBits!=32) { return NULL; }
	if (Type!=2) { return NULL; }

	return new Bitmap(wWidth,wHeight,wWidth*(32/8),PixelFormat32bppARGB,(pData+18));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\vmath.cpp ===
// Vector Math

#include "VMath.h"

float DotProduct(PointF v1,PointF v2)
{
	return v1.X*v2.X+v1.Y*v2.Y;
}

float Magnitude(PointF v)
{
	return (float)sqrt(DotProduct(v,v));
}

PointF Normalize(PointF vPoint)
{
	float flDenom;
	PointF vResult;

	flDenom=Magnitude(vPoint);
	vResult.X=vPoint.X/flDenom;
	vResult.Y=vPoint.Y/flDenom;

	return vResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\makefile.inc ===
$(O)\sidewalk.scr: $(O)\sidewalk.exe
        copy $(O)\sidewalk.exe $(O)\sidewalk.scr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\main.cpp ===
#include "CPerson.h"
#include "CSweeper.h"
#include "CSqueegee.h"
#include <mmsystem.h>
#include <commctrl.h>
#include <stdio.h>
#include <commdlg.h>

enum ENUM_CLEANER {
    eSweeper=0,
    eSqueegee,
    eRandom
};

#define MAXOBJECTS 100
#define CROWDSPEED_DEFAULT 19
#define RANDOMCLEANINTERVAL_DEFAULT 1
#define CLEANDELAY_DEFAULT 10
#define USEBITMAP_DEFAULT 0
#define FILENAME_DEFAULT "GDI+ Logo"
#define CLEANER_DEFAULT eSweeper
#define CROWDSIZE_DEFAULT 3

char szCrowdSpeed[]="CrowdSpeed";
char szRandomCleanInterval[]="RandomCleanInterval";
char szCleanDelay[]="CleanDelay";
char szUseBitmap[]="UseBitmap";
char szFilename[]="Filename";
char szCleaner[]="Cleaner";
char szCrowdSize[]="CrowdSize";

int g_cObjectMax;
CObject *g_rgpaObject[MAXOBJECTS];
CObject *g_paCleaner;
TextureBrush *g_paBrCleanBkg=NULL;
Bitmap *g_paBmDirtyBkg=NULL;
DWORD g_dwCleanDelay;
DWORD g_dwSimulateDelay;
BOOL g_bRandomCleanInterval;
BOOL g_bUseBitmap;
ENUM_CLEANER g_eCleaner;
char g_szFile[MAX_PATH];

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    return TRUE;
}

void Browse(HWND hDlg)
{
    char szFile[MAX_PATH];
    OPENFILENAME ofn;
    HWND hWnd;

    ZeroMemory(szFile,sizeof(szFile));
    ZeroMemory(&ofn,sizeof(OPENFILENAME));
    ofn.lStructSize=sizeof(OPENFILENAME);
    ofn.hwndOwner=hDlg;
    ofn.lpstrFile=szFile;
    ofn.nMaxFile=sizeof(szFile);
    ofn.lpstrFilter="All Supported\0*.bmp;*.jpg;*.jpeg;*.tif;*.tiff;*.png;*.gif;*.wmf;*.ico;*.emf\0Bitmap\0*.bmp\0JPEG\0*.jpg;*.jpeg\0TIFF\0*.tif;*.tiff\0PNG\0*.png\0GIF\0*.gif\0WMF\0*.wmf\0ICON\0*.ico\0EMF\0*.emf\0";
    ofn.nFilterIndex=1;
    ofn.lpstrFileTitle=NULL;
    ofn.nMaxFileTitle=0;
    ofn.lpstrInitialDir=NULL;
    ofn.Flags=OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST|OFN_EXPLORER;

    if (GetOpenFileName(&ofn)) {
        hWnd=GetDlgItem(hDlg,IDC_FILENAME);
        SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)szFile);
    }
}

BOOL WINAPI ScreenSaverConfigureDialog(HWND hDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
{ 
    HWND hWnd;
    LONG lCrowdSpeed=CROWDSPEED_DEFAULT;
    char szTemp[MAX_PATH];

    switch(Msg) {
        case WM_INITDIALOG:
            InitCommonControls();
            LoadString(hMainInstance,idsAppName,szAppName,40);
            LoadString(hMainInstance,idsIniFile,szIniFile,MAXFILELEN);

            lCrowdSpeed=GetPrivateProfileInt(szAppName,szCrowdSpeed,CROWDSPEED_DEFAULT,szIniFile);
            g_bRandomCleanInterval=GetPrivateProfileInt(szAppName,szRandomCleanInterval,RANDOMCLEANINTERVAL_DEFAULT,szIniFile);
            g_dwCleanDelay=GetPrivateProfileInt(szAppName,szCleanDelay,CLEANDELAY_DEFAULT,szIniFile);
            g_bUseBitmap=GetPrivateProfileInt(szAppName,szUseBitmap,USEBITMAP_DEFAULT,szIniFile);
            GetPrivateProfileString(szAppName,szFilename,FILENAME_DEFAULT,g_szFile,MAX_PATH,szIniFile);
            g_eCleaner=(ENUM_CLEANER)GetPrivateProfileInt(szAppName,szCleaner,CLEANER_DEFAULT,szIniFile);
            g_cObjectMax=GetPrivateProfileInt(szAppName,szCrowdSize,CROWDSIZE_DEFAULT,szIniFile);

            hWnd=GetDlgItem(hDlg,IDC_CROWDSPEED);
            SendMessage(hWnd,TBM_SETRANGE,(WPARAM)true,(LPARAM)MAKELONG(0,20));
            SendMessage(hWnd,TBM_SETPAGESIZE,0,(LPARAM)20/8);
            SendMessage(hWnd,TBM_SETPOS,(WPARAM)true,(LPARAM)lCrowdSpeed);

            hWnd=GetDlgItem(hDlg,IDC_CROWDSIZE);
            SendMessage(hWnd,TBM_SETRANGE,(WPARAM)true,(LPARAM)MAKELONG(1,10));
            SendMessage(hWnd,TBM_SETPAGESIZE,0,(LPARAM)1);
            SendMessage(hWnd,TBM_SETPOS,(WPARAM)true,(LPARAM)g_cObjectMax);

            hWnd=GetDlgItem(hDlg,IDC_FILENAME);
            SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)g_szFile);

            hWnd=GetDlgItem(hDlg,IDC_USEBITMAP);
            if (g_bUseBitmap) {
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_BROWSE);
                EnableWindow(hWnd,false);
                hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                EnableWindow(hWnd,false);
            }

            if (g_bRandomCleanInterval) {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERRANDOMINTERVAL);
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERGIVENINTERVAL);
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }

            hWnd=GetDlgItem(hDlg,IDC_CLEANERGIVENINTERVAL);
            if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                EnableWindow(hWnd,true);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                EnableWindow(hWnd,false);
            }

            switch(g_eCleaner) {
                case eSweeper:
                    hWnd=GetDlgItem(hDlg,IDC_SWEEPER);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
                case eSqueegee:
                    hWnd=GetDlgItem(hDlg,IDC_SQUEEGEE);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
                case eRandom:
                    hWnd=GetDlgItem(hDlg,IDC_RANDOMCLEANER);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
            }

            hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
            _itoa(g_dwCleanDelay,szTemp,10);
            SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)szTemp);

            return TRUE;
        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_USEBITMAP:
                    if (HIWORD(wParam)==BN_CLICKED) {
                        hWnd=GetDlgItem(hDlg,IDC_BROWSE);
                        EnableWindow(hWnd,!IsWindowEnabled(hWnd));
                        hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                        EnableWindow(hWnd,!IsWindowEnabled(hWnd));
                    }
                    break;
                case IDC_CLEANERGIVENINTERVAL:
                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    EnableWindow(hWnd,true);
                    break;
                case IDC_CLEANERRANDOMINTERVAL:
                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    EnableWindow(hWnd,false);
                    break;
                case IDC_BROWSE:
                    Browse(hDlg);
                    break;
                case ID_OK:
                    hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)g_szFile);

                    hWnd=GetDlgItem(hDlg,IDC_CROWDSPEED);
                    lCrowdSpeed=SendMessage(hWnd,TBM_GETPOS,0,0);
                    sprintf(szTemp,"%ld",lCrowdSpeed);
                    WritePrivateProfileString(szAppName,szCrowdSpeed,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CROWDSIZE);
                    g_cObjectMax=SendMessage(hWnd,TBM_GETPOS,0,0);
                    sprintf(szTemp,"%ld",g_cObjectMax);
                    WritePrivateProfileString(szAppName,szCrowdSize,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CLEANERRANDOMINTERVAL);
                    g_bRandomCleanInterval=SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED;
                    sprintf(szTemp,"%ld",g_bRandomCleanInterval);
                    WritePrivateProfileString(szAppName,szRandomCleanInterval,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)szTemp);
                    WritePrivateProfileString(szAppName,szCleanDelay,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_USEBITMAP);
                    g_bUseBitmap=SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED;
                    sprintf(szTemp,"%ld",g_bUseBitmap);
                    WritePrivateProfileString(szAppName,szUseBitmap,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)szTemp);
                    WritePrivateProfileString(szAppName,szFilename,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_SWEEPER);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eSweeper;
                    }
                    hWnd=GetDlgItem(hDlg,IDC_SQUEEGEE);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eSqueegee;
                    }
                    hWnd=GetDlgItem(hDlg,IDC_RANDOMCLEANER);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eRandom;
                    }
                    sprintf(szTemp,"%ld",g_eCleaner);
                    WritePrivateProfileString(szAppName,szCleaner,szTemp,szIniFile);
                case ID_CANCEL:
                    EndDialog(hDlg,LOWORD(wParam)==ID_OK);
                return TRUE;
            }
    }

    return FALSE;
}

LRESULT WINAPI ScreenSaverProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
{
    static bool         GdiplusInitialized = false;
    static ULONG_PTR    gpToken;
        
    const UINT_PTR NEWCLEANER_TIMERID=1;
    const UINT_PTR SIMULATE_TIMERID=2;
    static bFirstRun=true;
    Graphics *g;
    int i;
    int nRand;
    RECT rDesktop;
    HDC hdcBkgBitmap;
    HDC hdcScreen;
    TextureBrush *paBrDirtyBkg=NULL;
    Bitmap *paBmCleanBkg=NULL;
    WCHAR wsFile[MAX_PATH];
    LONG lCrowdSpeed;

    GdiplusStartupInput sti;
        
    switch(Msg) {
        case WM_CREATE:
            // Initialize GDI+

            if (GdiplusStartup(&gpToken, &sti, NULL) == Ok)
            {
                GdiplusInitialized = true;
            }
            else
            {
                break;
            }

            LoadString(hMainInstance,idsAppName,szAppName,10);
            LoadString(hMainInstance,idsIniFile,szIniFile,MAXFILELEN);

            // Load variables
            lCrowdSpeed=GetPrivateProfileInt(szAppName,szCrowdSpeed,CROWDSPEED_DEFAULT,szIniFile);
            g_dwSimulateDelay=(20-lCrowdSpeed)*10;
            g_bRandomCleanInterval=GetPrivateProfileInt(szAppName,szRandomCleanInterval,RANDOMCLEANINTERVAL_DEFAULT,szIniFile);
            g_dwCleanDelay=GetPrivateProfileInt(szAppName,szCleanDelay,CLEANDELAY_DEFAULT,szIniFile)*1000;
            g_bUseBitmap=GetPrivateProfileInt(szAppName,szUseBitmap,USEBITMAP_DEFAULT,szIniFile);
            GetPrivateProfileString(szAppName,szFilename,FILENAME_DEFAULT,g_szFile,MAX_PATH,szIniFile);
            g_eCleaner=(ENUM_CLEANER)GetPrivateProfileInt(szAppName,szCleaner,CLEANER_DEFAULT,szIniFile);
            g_cObjectMax=GetPrivateProfileInt(szAppName,szCrowdSize,CROWDSIZE_DEFAULT,szIniFile);

            srand((unsigned int)timeGetTime());

            // Get desktop dimensions
            GetClientRect(hWnd,&rDesktop);

            g_paBmDirtyBkg=new Bitmap(rDesktop.right,rDesktop.bottom,PixelFormat32bppPARGB);
            if (g_bUseBitmap) {
                mbstowcs(wsFile,g_szFile,sizeof(g_szFile));
                paBmCleanBkg=new Bitmap(wsFile);
                if (paBmCleanBkg->GetLastStatus()!=Ok) {
                    delete paBmCleanBkg;
                    paBmCleanBkg=new Bitmap((HINSTANCE)GetModuleHandle(NULL),(WCHAR*)MAKEINTRESOURCE(IDB_LOGO));
                }

                // Take snapshot of whole desktop for DirtyBkg
                g=new Graphics(g_paBmDirtyBkg);
                hdcBkgBitmap=g->GetHDC();
                hdcScreen=CreateDC("DISPLAY",NULL,NULL,NULL);
                StretchBlt(hdcBkgBitmap,0,0,rDesktop.right,rDesktop.bottom,hdcScreen,GetSystemMetrics(SM_XVIRTUALSCREEN),GetSystemMetrics(SM_YVIRTUALSCREEN),rDesktop.right,rDesktop.bottom,SRCCOPY);
                g->ReleaseHDC(hdcBkgBitmap);
                DeleteDC(hdcScreen);
                delete g;
            }
            else {
                // Take snapshot of whole desktop for CleanBkg
                paBmCleanBkg=new Bitmap(rDesktop.right,rDesktop.bottom,PixelFormat32bppPARGB);
                g=new Graphics(paBmCleanBkg);
                hdcBkgBitmap=g->GetHDC();
                hdcScreen=CreateDC("DISPLAY",NULL,NULL,NULL);
                StretchBlt(hdcBkgBitmap,0,0,rDesktop.right,rDesktop.bottom,hdcScreen,GetSystemMetrics(SM_XVIRTUALSCREEN),GetSystemMetrics(SM_YVIRTUALSCREEN),rDesktop.right,rDesktop.bottom,SRCCOPY);
                g->ReleaseHDC(hdcBkgBitmap);
                DeleteDC(hdcScreen);
                delete g;

                g=new Graphics(g_paBmDirtyBkg);
                g->DrawImage(paBmCleanBkg,0,0,0,0,rDesktop.right,rDesktop.bottom,UnitPixel);
                delete g;
            }

            // Make brush out of clean desktop
            g_paBrCleanBkg=new TextureBrush(paBmCleanBkg,WrapModeTile);
            delete paBmCleanBkg;

            for (i=0;i<g_cObjectMax;i++) {
                g_rgpaObject[i]=new CPerson();
                g_rgpaObject[i]->Init(hWnd);
            }

            SetTimer(hWnd,NEWCLEANER_TIMERID,g_dwCleanDelay,NULL);
            SetTimer(hWnd,SIMULATE_TIMERID,g_dwSimulateDelay,NULL);
            return 0;
        case WM_ERASEBKGND:
            return 0;
        case WM_TIMER:
            if(!GdiplusInitialized)
            {
                break;
            }
            switch (wParam) {
                case NEWCLEANER_TIMERID:
                    if (g_paCleaner==NULL) {
                        switch (g_eCleaner) {
                            case eSweeper:
                                g_paCleaner=new CSweeper();
                                break;
                            case eSqueegee:
                                g_paCleaner=new CSqueegee();
                                break;
                            case eRandom:
                                nRand=rand();
                                if (nRand<RAND_MAX/2) {
                                    g_paCleaner=new CSweeper();
                                }
                                else {
                                    g_paCleaner=new CSqueegee();
                                }
                                break;
                        }
                        g_paCleaner->Init(hWnd);
                    }
                    if (g_bRandomCleanInterval) {
                        nRand=rand();
                        g_dwCleanDelay=(int)(((float)rand()/(float)RAND_MAX)*15000.0f+10000.0f);
                        SetTimer(hWnd,NEWCLEANER_TIMERID,g_dwCleanDelay,NULL);
                    }
                    break;
                case SIMULATE_TIMERID:
                    g=Graphics::FromHWND(hWnd);

                    if (bFirstRun) {
                        // Blit to screen (used inside demo window in the display dialog box)
                        bFirstRun=false;
                        GetClientRect(hWnd,&rDesktop);
                        g->DrawImage(g_paBmDirtyBkg,0,0,0,0,rDesktop.right,rDesktop.bottom,UnitPixel);
                    }

                    g->SetSmoothingMode(SmoothingModeNone);
                    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

                    for (i=0;i<g_cObjectMax;i++) {
                        if (!g_rgpaObject[i]->Move(g)) {
                            // Moved outside desktop, delete it and recreate another
                            delete g_rgpaObject[i];
                            g_rgpaObject[i]=new CPerson();
                            g_rgpaObject[i]->Init(hWnd);
                        }
                    }
                    if (g_paCleaner!=NULL) {
                        if (!g_paCleaner->Move(g)) {
                            // Moved outside desktop, delete it and wait for the next
                            //  NEWCLEANER_TIMERID to hit
                            delete g_paCleaner;
                            g_paCleaner=NULL;
                        }
                    }

                    delete g;
                    break;
            }
            break;
        case WM_DESTROY:
            if (!GdiplusInitialized)
            {
                break;
            }
            
            if (g_paBrCleanBkg!=NULL) {
                delete g_paBrCleanBkg;
                g_paBrCleanBkg=NULL;
            }
            if (g_paBmDirtyBkg!=NULL) {
                delete g_paBmDirtyBkg;
                g_paBmDirtyBkg=NULL;
            }

            for (i=0;i<g_cObjectMax;i++) {
                if (g_rgpaObject[i]!=NULL) {
                    delete g_rgpaObject[i];
                    g_rgpaObject[i]=NULL;
                }
            }
            if (g_paCleaner!=NULL) {
                delete g_paCleaner;
                g_paCleaner=NULL;
            }

            KillTimer(hWnd,NEWCLEANER_TIMERID);
            KillTimer(hWnd,SIMULATE_TIMERID);
            
            GdiplusShutdown(gpToken);
            GdiplusInitialized = false;
            break;
    }

    return DefScreenSaverProc(hWnd, Msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\sidewalk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Sidewalk.rc
//
#define IDS_DESCRIPTION                 1
#define ID_APP                          100
#define IDD_DIALOG1                     101
#define IDR_BOOT                        129
#define IDR_BOOT2                       131
#define IDR_BAREFOOT                    133
#define IDR_DOG                         134
#define IDB_LOGO                        137
#define IDR_BROOMON                     138
#define IDR_BROOMOFF                    139
#define IDR_SQUEEGEE                    146
#define ID_SPEED                        1000
#define idsIniFile                      1001
#define ID_OK                           1002
#define ID_CANCEL                       1003
#define IDC_SWEEPER                     1004
#define IDC_SQUEEGEE                    1005
#define IDC_RANDOMCLEANER               1006
#define idsAppName                      1007
#define IDC_CLEANERGIVENINTERVAL        1008
#define IDC_CLEANERRANDOMINTERVAL       1009
#define IDC_CLEANERINTERVAL             1010
#define IDC_USEBITMAP                   1011
#define IDC_BROWSE                      1012
#define IDC_FILENAME                    1013
#define IDC_CROWDSPEED                  1014
#define IDC_CROWDSIZE                   1015
#define DLG_SCRNSAVECONFIGURE           2003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trialpha.rc
//
#define IDC_MYICON                      2
#define IDD_TESTBED_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDM_SETTINGS                    106
#define IDI_TRIALPHA                    107
#define IDI_SMALL                       108
#define IDC_TRIALPHA                    109
#define IDD_SETTINGS                    110
#define IDR_MAINFRAME                   128
#define IDC_COUNT                       1001
#define IDC_LIFETIME                    1002
#define IDC_DELAY                       1003
#define IDC_LEAVETRAILS                 1004
#define IDC_CLEARSCREEN                 1005
#define IDC_REFLECTVERT                 1006
#define IDC_REFLECTHORZ                 1007
#define IDC_REFLECTDIAG                 1008
#define IDC_ALPHA                       1009
#define IDC_CURVES                      1010
#define IDC_OSCILLATE                   1011
#define IDC_FILLED                      1012
#define IDC_ROTATIONS                   1013
#define IDC_SHAPE                       1014
#define IDS_SHAPE_BASE                  1015
#define IDS_SHAPE_TRIANGLES             1015
#define IDS_SHAPE_CURVES                1016
#define IDS_SHAPE_ELLIPSES              1017
#define IDS_SHAPE_RECTANGLES            1018
#define IDS_SHAPE_TEXT                  1019
#define IDC_THETA                       1020
#define IDC_NULL                        1021

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\trialpha.cpp ===
// trialpha.cpp : Defines the entry point for the application.
//

#include "trialpha.h"

#include "..\gpinit.inc"

#define MAX_LOADSTRING 100

// #define STANDALONE_DEBUG 1

#ifdef STANDALONE_DEBUG

// Global Variables:
HINSTANCE hMainInstance = (HINSTANCE)NULL;
HWND ghwndMain = (HWND)NULL;
#else // !STANDALONE_DEBUG
extern HINSTANCE hMainInstance;
#endif // !STANDALONE_DEBUG

TCHAR szTitle[MAX_LOADSTRING];        // The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];// The title bar text

UINT_PTR timerID = 0;
int timercount = 0;
BOOL suspend = FALSE;
BOOL showconfig = FALSE;
BOOL screensaver = FALSE;
BOOL silent = FALSE;
HWND hwndParent = (HWND)NULL;

// Foward declarations of functions included in this code module:
ATOM MyRegisterClass(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE, int);

#ifdef STANDALONE_DEBUG
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);
#else // !STANDALONE_DEBUG

BOOL WINAPI RegisterDialogClasses(HANDLE hInst);
LRESULT WINAPI ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif // !STANDALONE_DEBUG

INT_PTR CALLBACK ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

//===========================================================================

typedef enum
{
    dtTriangles = 0,
    dtCurves = 1,
    dtEllipses = 2,
    dtRectangles = 3,
    dtText = 4
}
SHAPE;

typedef struct
{
    BYTE alpha;    // Alpha value
    int  count;    // Number of simultaneous triangles
    int  lifetime; // Number of displayed cycles
    int  delay;    // Number of cycles to delay before clearing
    BOOL leaveTrails;
    BOOL reflectVertical;
    BOOL reflectHorizontal;
    BOOL reflectDiagonal;
    BOOL clearScreen;
    BOOL oscillate;
    BOOL filled;
    int  rotations;
    float theta;   // Additional rotation applied per iteration
    SHAPE shape;
    WCHAR wchString[256];
    WCHAR wchFont[256];
    REAL textHeight;
}
LINESETTINGS;


typedef struct
{
    float x1;
    float y1;
    float x2;
    float y2;
    float x3;
    float y3;
    float dx1;
    float dy1;
    float dx2;
    float dy2;
    float dx3;
    float dy3;
    float r;
    float g;
    float b;
    float dr;
    float dg;
    float db;
}
LINEINFO;

typedef struct
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
}
OFFSCREENINFO;

//===========================================================================

LINESETTINGS currentSettings =
{
    20,          // Alpha value
    1,           // number of simultaneous shapes
    1500,        // number of displayed cycles
    250,         // number if cycles to pause
    TRUE,        // leave trails
    FALSE,       // reflect Vertical
    TRUE,        // reflect Horizontal
    FALSE,       // reflect Diagonal
    TRUE,        // clear screen
    FALSE,       // oscillate
    FALSE,       // filled
    3,           // Count of rotations
    0.0f,        // theta
    dtTriangles, // shape
    L"Animated", // string for dtText
    L"Tahoma",   // font for dtText
    120.0f       // text height for dtText
};

#define MAX_LINES 256

LINESETTINGS dialogSettings;
LINEINFO rgLineInfo[MAX_LINES];
OFFSCREENINFO offscreenInfo = { 0 };

//===========================================================================

int GetIntValue(char *name, int value)
{
    return GetPrivateProfileInt("Settings", name, value, "Trialpha.ini");
}

void SetIntValue(char *name, int value)
{
    char szValue[80];

    wsprintf(szValue, "%d", value);

    WritePrivateProfileString("Settings", name, szValue, "Trialpha.ini");
}

void LoadState()
{
    currentSettings.alpha             = (BYTE)GetIntValue("Alpha",    20);
    currentSettings.count             = GetIntValue("Count",           1);
    currentSettings.lifetime          = GetIntValue("Lifetime",     1500);
    currentSettings.delay             = GetIntValue("Delay",         250);
    currentSettings.leaveTrails       = GetIntValue("LeaveTrails",     1);
    currentSettings.reflectVertical   = GetIntValue("ReflectV",        0);
    currentSettings.reflectHorizontal = GetIntValue("ReflectH",        1);
    currentSettings.reflectDiagonal   = GetIntValue("ReflectD",        0);
    currentSettings.clearScreen       = GetIntValue("ClearScreen",     0);
    currentSettings.oscillate         = GetIntValue("Oscillate",       0);
    currentSettings.filled            = GetIntValue("Filled",          0);
    currentSettings.rotations         = GetIntValue("Rotations",       3);
    currentSettings.theta             = GetIntValue("Theta",           0) / 10.0f;
    currentSettings.shape             = (SHAPE)GetIntValue("Shape",           0);
}

void SaveState()
{
    SetIntValue("Alpha",       currentSettings.alpha             );
    SetIntValue("Count",       currentSettings.count             );
    SetIntValue("Lifetime",    currentSettings.lifetime          );
    SetIntValue("Delay",       currentSettings.delay             );
    SetIntValue("LeaveTrails", currentSettings.leaveTrails       );
    SetIntValue("ReflectV",    currentSettings.reflectVertical   );
    SetIntValue("ReflectH",    currentSettings.reflectHorizontal );
    SetIntValue("ReflectD",    currentSettings.reflectDiagonal   );
    SetIntValue("ClearScreen", currentSettings.clearScreen       );
    SetIntValue("Oscillate",   currentSettings.oscillate         );
    SetIntValue("Filled",      currentSettings.filled            );
    SetIntValue("Rotations",   currentSettings.rotations         );
    SetIntValue("Theta",       (int)(currentSettings.theta*10.0f));
    SetIntValue("Shape",       (int)currentSettings.shape        );
}

//===========================================================================

void randomizelocations()
{
    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int i=0;i<currentSettings.count;i++)
    {
        rgLineInfo[i].x1 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y1 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].x2 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y2 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].x3 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y3 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;

        rgLineInfo[i].dx1 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy1 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dx2 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy2 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dx3 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy3 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx1 = -rgLineInfo[i].dx1;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx2 = -rgLineInfo[i].dx2;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx3 = -rgLineInfo[i].dx3;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy1 = -rgLineInfo[i].dy1;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy2 = -rgLineInfo[i].dy2;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy3 = -rgLineInfo[i].dy3;

        rgLineInfo[i].dx1 /= 3.0f;
        rgLineInfo[i].dy1 /= 3.0f;
        rgLineInfo[i].dx2 /= 3.0f;
        rgLineInfo[i].dy2 /= 3.0f;
        rgLineInfo[i].dx3 /= 3.0f;
        rgLineInfo[i].dy3 /= 3.0f;
    }
}

void randomizecolors(int index)
{
    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int i=0;i<currentSettings.count;i++)
    {
        rgLineInfo[i].r = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].g = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].b = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;

        rgLineInfo[i].dr = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dg = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].db = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dr = -rgLineInfo[i].dr;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dg = -rgLineInfo[i].dg;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].db = -rgLineInfo[i].db;
    }
}

void FreeOffscreen()
{
    if (offscreenInfo.hdc)
    {
        SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOld);
        DeleteObject(offscreenInfo.hbmpOffscreen);
        DeleteDC(offscreenInfo.hdc);

        offscreenInfo.hdc = (HDC)NULL;
        offscreenInfo.hbmpOffscreen = (HBITMAP)NULL;
        offscreenInfo.hbmpOld = (HBITMAP)NULL;
        offscreenInfo.bmi.bmiHeader.biWidth = 0;
        offscreenInfo.bmi.bmiHeader.biHeight = 0;
    }
}

void ClearOffscreen()
{
    if (offscreenInfo.hdc)
    {
        PatBlt(
            offscreenInfo.hdc,
            0,
            0,
            offscreenInfo.bmi.bmiHeader.biWidth,
            offscreenInfo.bmi.bmiHeader.biHeight,
            BLACKNESS);
    }

#ifdef STANDALONE_DEBUG
    InvalidateRect(ghwndMain, NULL, TRUE);
#endif // STANDALONE_DEBUG
}

HDC GetOffscreen(HDC hDC, int width, int height)
{
    HDC hdcResult = NULL;

    if (width > offscreenInfo.bmi.bmiHeader.biWidth ||
        height > offscreenInfo.bmi.bmiHeader.biHeight ||
        offscreenInfo.hdc == (HDC)NULL)
    {
        FreeOffscreen();

        offscreenInfo.bmi.bmiHeader.biSize = sizeof(offscreenInfo.bmi.bmiHeader);
        offscreenInfo.bmi.bmiHeader.biWidth = width;
        offscreenInfo.bmi.bmiHeader.biHeight = height;
        offscreenInfo.bmi.bmiHeader.biPlanes = 1;
        offscreenInfo.bmi.bmiHeader.biBitCount = 32;
        offscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;
        offscreenInfo.bmi.bmiHeader.biSizeImage = 0;
        offscreenInfo.bmi.bmiHeader.biXPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biYPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biClrUsed = 0;
        offscreenInfo.bmi.bmiHeader.biClrImportant = 0;

        offscreenInfo.hbmpOffscreen = CreateDIBSection(
            hDC,
            &offscreenInfo.bmi,
            DIB_RGB_COLORS,
            &offscreenInfo.pvBits,
            NULL,
            0);

        if (offscreenInfo.hbmpOffscreen)
        {
            offscreenInfo.hdc = CreateCompatibleDC(hDC);

            if (offscreenInfo.hdc)
            {
                offscreenInfo.hbmpOld = (HBITMAP)SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOffscreen);

                ClearOffscreen();
            }
        }
    }

    hdcResult = offscreenInfo.hdc;

    return hdcResult;
}

void DrawGraphics(HWND hWnd, HDC hDC, LPRECT lpRectDraw, LPRECT lpRectBounds)
{
    RECT rectBounds;
    Graphics *gr = NULL;

    gr = new Graphics(hDC);

    gr->ResetTransform();
    gr->SetPageUnit(UnitPixel);
    gr->SetSmoothingMode(SmoothingModeHighQuality);
    gr->TranslateTransform(REAL(-0.5), REAL(-0.5));

    SolidBrush whiteBrush(Color(0xFF, 0xFF, 0xFF));
    SolidBrush blackBrush(Color(0x00, 0x00, 0x00));
    Pen blackPen(Color(0x00, 0x00, 0x00));
    Pen whitePen(Color(0xFF, 0xFF, 0xFF));

    FontFamily fontFamily(currentSettings.wchFont);
    StringFormat stringFormat(StringFormatFlagsDirectionRightToLeft);

    stringFormat.SetAlignment(StringAlignmentCenter);
    stringFormat.SetLineAlignment(StringAlignmentCenter);

    RectF rfDraw(REAL(lpRectDraw->left), REAL(lpRectDraw->top), REAL(lpRectDraw->right-lpRectDraw->left), REAL(lpRectDraw->bottom-lpRectDraw->top));

    RectF rect(-500.0f, -(currentSettings.textHeight/2.0f), 1000.0f, currentSettings.textHeight);
    GraphicsPath textPath;
    textPath.AddString(currentSettings.wchString, -1, &fontFamily, FontStyleRegular, currentSettings.textHeight, rect, &stringFormat);

    // This paints the background using GDI+...
    if (!currentSettings.leaveTrails)
        gr->FillRectangle(&blackBrush, rfDraw);

    REAL width  = REAL(lpRectDraw->right - lpRectDraw->left) / REAL(100.0);
    REAL height = REAL(lpRectDraw->bottom - lpRectDraw->top) / REAL(100.0);

    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int index=0;index<currentSettings.count;index++)
    {
        int i = index;
        
        BYTE r = (BYTE)(rgLineInfo[i].r * 255.0 / 100.0);
        BYTE g = (BYTE)(rgLineInfo[i].g * 255.0 / 100.0);
        BYTE b = (BYTE)(rgLineInfo[i].b * 255.0 / 100.0);

        SolidBrush brush(Color(currentSettings.leaveTrails ? currentSettings.alpha : 0xC0, r, g, b));
        Pen pen(Color(currentSettings.leaveTrails ? currentSettings.alpha : 0xC0, r, g, b), 0);
        BOOL fHitWall = FALSE;
        Rect bounds;
        GraphicsPath path;
        PointF rgPoints[4];
        float offsetx = 0.0f;
        float offsety = 0.0f;
        float scalex  = (float)width;
        float scaley  = (float)height;

        if (currentSettings.oscillate)
        {
            float ratiox = (((timercount+(index*5)) % 200) / 100.0f) - 1.0f;
            float ratioy = (((timercount+(index*9)) % 160) /  80.0f) - 1.0f;

            if (ratiox < 0.0)
                ratiox = -ratiox;

            if (ratioy < 0.0)
                ratioy = -ratioy;

            offsetx = (width  * ratiox) * 50.0f;
            offsety = (height * ratioy) * 50.0f;
            scalex  = (width  * (1.0f - ratiox));
            scaley  = (height * (1.0f - ratioy));
        }

        // Setup the array of points...
        rgPoints[0].X = offsetx + rgLineInfo[i].x1 * scalex;
        rgPoints[0].Y = offsety + rgLineInfo[i].y1 * scaley;

        rgPoints[1].X = offsetx + rgLineInfo[i].x2 * scalex;
        rgPoints[1].Y = offsety + rgLineInfo[i].y2 * scaley;

        rgPoints[2].X = offsetx + rgLineInfo[i].x3 * scalex;
        rgPoints[2].Y = offsety + rgLineInfo[i].y3 * scaley;

        rgPoints[3].X = offsetx + rgLineInfo[i].x1 * scalex;
        rgPoints[3].Y = offsety + rgLineInfo[i].y1 * scaley;

        path.Reset();

        switch(currentSettings.shape)
        {
            case dtCurves :
            {
                // Add 3 curve points...
                path.AddClosedCurve(rgPoints, 3);
            }
            break;

            case dtTriangles :
            {
                // Add 4 line points...
                path.AddLines(rgPoints, 4);
            }
            break;

            case dtEllipses :
            {
                // Draw an ellipse at x1, y1
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL dx = rgLineInfo[i].x3 * width / 4.0f;
                REAL dy = rgLineInfo[i].y3 * height / 4.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                RectF rect(x-dx/2.0f, y-dy/2.0f, dx, dy);

                path.AddEllipse(rect);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Translate(-x, -y);

                path.Transform(&matrix);
            }
            break;

            case dtRectangles :
            {
                // Draw a rectangle at x1, y1
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL dx = rgLineInfo[i].x3 * width / 4.0f;
                REAL dy = rgLineInfo[i].y3 * height / 4.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                RectF rect(x-dx/2.0f, y-dy/2.0f, dx, dy);

                path.AddRectangle(rect);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Translate(-x, -y);

                path.Transform(&matrix);
            }
            break;

            case dtText:
            {
                // Draw text in a rectangle bounded by x1, y1, x2, y2:
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL scale = (rgLineInfo[i].x3+rgLineInfo[i].y3) / 200.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                path.AddPath(&textPath, FALSE);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Scale(scale, scale);

                path.Transform(&matrix);
            }
            break;
        }

        for(int k=0;k<currentSettings.rotations;k++)
        {
            Matrix rotation;

            rotation.Translate(width * 50.0f, height * 50.0f);
            rotation.Rotate((currentSettings.theta * timercount) + (k * 360.0f) / currentSettings.rotations);
            rotation.Translate(width * -50.0f, height * -50.0f);

            path.Transform(&rotation);

            rotation.Invert();

            if (currentSettings.filled)
                gr->FillPath(&brush, &path);
            else
                gr->DrawPath(&pen, &path);

            path.GetBounds(&bounds);

            if ((k == 0) && (i == 0))
            {
                rectBounds.left   = bounds.X;
                rectBounds.right  = bounds.X + bounds.Width;
                rectBounds.top    = bounds.Y;
                rectBounds.bottom = bounds.Y + bounds.Height;
            }
            else
            {
                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);
            }

            if (currentSettings.reflectVertical)
            {
                Matrix matrix;

                matrix.Translate(0.0f, height * 100.0f);
                matrix.Scale(1.0f, -1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            if (currentSettings.reflectHorizontal)
            {
                Matrix matrix;

                matrix.Translate(width*100.0f, 0.0f);
                matrix.Scale(-1.0f, 1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            if (currentSettings.reflectDiagonal)
            {
                Matrix matrix;

                matrix.Translate(width*100.0f, height*100.0f);
                matrix.Scale(-1.0f, -1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            path.Transform(&rotation);
        }

        if (!suspend)
        {
            rgLineInfo[i].x1 += rgLineInfo[i].dx1;
            rgLineInfo[i].y1 += rgLineInfo[i].dy1;
            rgLineInfo[i].x2 += rgLineInfo[i].dx2;
            rgLineInfo[i].y2 += rgLineInfo[i].dy2;
            rgLineInfo[i].x3 += rgLineInfo[i].dx3;
            rgLineInfo[i].y3 += rgLineInfo[i].dy3;
            rgLineInfo[i].r  += rgLineInfo[i].dr;
            rgLineInfo[i].g  += rgLineInfo[i].dg;
            rgLineInfo[i].b  += rgLineInfo[i].db;

            if (rgLineInfo[i].x1 < 5.0 || rgLineInfo[i].x1 > 95.0)
            {
                rgLineInfo[i].dx1 = -rgLineInfo[i].dx1;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y1 < 5.0 || rgLineInfo[i].y1 > 95.0)
            {
                rgLineInfo[i].dy1 = -rgLineInfo[i].dy1;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].x2 < 5.0 || rgLineInfo[i].x2 > 95.0)
            {
                rgLineInfo[i].dx2 = -rgLineInfo[i].dx2;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y2 < 5.0 || rgLineInfo[i].y2 > 95.0)
            {
                rgLineInfo[i].dy2 = -rgLineInfo[i].dy2;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].x3 < 5.0 || rgLineInfo[i].x3 > 95.0)
            {
                rgLineInfo[i].dx3 = -rgLineInfo[i].dx3;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y3 < 5.0 || rgLineInfo[i].y3 > 95.0)
            {
                rgLineInfo[i].dy3 = -rgLineInfo[i].dy3;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].r < 5.0 || rgLineInfo[i].r > 95.0)
                rgLineInfo[i].dr = -rgLineInfo[i].dr;

            if (rgLineInfo[i].g < 5.0 || rgLineInfo[i].g > 95.0)
                rgLineInfo[i].dg = -rgLineInfo[i].dg;

            if (rgLineInfo[i].b < 5.0 || rgLineInfo[i].b > 95.0)
                rgLineInfo[i].db = -rgLineInfo[i].db;
        }
    }

    if (lpRectBounds)
    {
        *lpRectBounds = rectBounds;
    }

    delete gr;
}

LRESULT PaintWnd(HWND hWnd, HDC hDC)
{
    HBRUSH hBrush, hBrushOld;
    HPEN hPen, hPenOld;
    RECT rectClient;
    RECT rectDraw;
    
    hBrush    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    hPen      = (HPEN)GetStockObject(BLACK_PEN);

    hBrushOld = (HBRUSH)SelectObject(hDC, hBrush);
    hPenOld   = (HPEN)SelectObject(hDC, hPen);

    GetClientRect(hWnd, &rectClient);

    int width  = rectClient.right - rectClient.left;
    int height = rectClient.bottom - rectClient.top;

    // Setup the drawing rectangle relative to the client (inset 5 pixels)
    rectDraw.left   = 0;
    rectDraw.top    = 0;
    rectDraw.right  = (rectClient.right - rectClient.left);
    rectDraw.bottom = (rectClient.bottom - rectClient.top);

    // Now draw within this rectangle with GDI+ ...
    if (currentSettings.clearScreen)
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HDC hdcOffscreen = NULL;
        int width, height;
        RECT rectOffscreen;

        width = rectDraw.right - rectDraw.left;
        height = rectDraw.bottom - rectDraw.top;

        rectOffscreen.left   = 0;
        rectOffscreen.top    = 0;
        rectOffscreen.right  = width;
        rectOffscreen.bottom = height;

        hdcOffscreen = GetOffscreen(hDC, width, height);

        if (hdcOffscreen)
        {
            if (!currentSettings.leaveTrails)
            {
                PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
            }

            DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, NULL);

            StretchBlt(
                hDC,
                rectDraw.left,
                rectDraw.top,
                width,
                height,
                hdcOffscreen,
                0,
                0,
                width,
                height,
                SRCCOPY);
        }

        ReleaseDC(hWnd, hDC);
    }

    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);

    return 0;
}

static RECT rectLast = {0, 0, 0, 0};

#ifdef STANDALONE_DEBUG

int cmpi(char *s1, char *s2)
{
    int result = 0;

    if (s1 && s2)
    {
        while((*s1 == *s2) && *s1)
        {
            s1++;
            s2++;
        }

        if (*s1 && *s2)
            result = *s1 - *s2;
        else
            result = *(s1-1) - *(s2-1);
    }

    return result;
}

void ParseCommandLine(LPSTR lpCmdLine)
{
    if (!cmpi(lpCmdLine,"/s") ||
        !cmpi(lpCmdLine,"-s") ||
        !cmpi(lpCmdLine,"s"))
    {
        screensaver = TRUE;
    }

    if (!cmpi(lpCmdLine,"/c") ||
        !cmpi(lpCmdLine,"-c") || 
        !cmpi(lpCmdLine,"c"))
    {
        // Run config with current window as parent.
        showconfig = TRUE;
        screensaver = TRUE;
    }

    // In-Place preview
    if (!cmpi(lpCmdLine, "/p") ||
        !cmpi(lpCmdLine, "-p") ||
        !cmpi(lpCmdLine, "p"))
    {
        char *p = lpCmdLine;
        int handle = 0;

        while(*p)
        {
            switch(*p)
            {
                case '0' :
                case '1' :
                case '2' :
                case '3' :
                case '4' :
                case '5' :
                case '6' :
                case '7' :
                case '8' :
                case '9' :
                    handle *= 10;
                    handle += *p-'0';
                break;
            }

            p++;
        }

        screensaver = TRUE;
        silent = TRUE;
        hwndParent = (HWND)handle;
    }

    if (!cmpi(lpCmdLine,"/t") ||
        !cmpi(lpCmdLine,"-t") ||
        !cmpi(lpCmdLine,"t"))
    {
        screensaver = FALSE;
    }
}

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    // Parse the command line...
    ParseCommandLine(lpCmdLine);

    if (!gGdiplusInitHelper.IsValid())
        return 0;

    srand(GetTickCount());

    randomizelocations();
    randomizecolors(-1);

    // Initialize global strings
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadString(hInstance, IDC_TRIALPHA, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) 
    {
        return FALSE;
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_TRIALPHA);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    FreeOffscreen();

    return (int)msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style            = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc      = WndProc;
    wcex.cbClsExtra       = 0;
    wcex.cbWndExtra       = 0;
    wcex.hInstance        = hInstance;
    wcex.hIcon            = LoadIcon(hInstance, (LPCTSTR)IDI_TRIALPHA);

    if (screensaver)
        wcex.hCursor      = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_NULL));
    else
        wcex.hCursor      = LoadCursor(NULL, IDC_ARROW);

    wcex.hbrBackground    = (HBRUSH)NULL;

    if (screensaver)
        wcex.lpszMenuName = (LPCSTR)NULL;
    else
        wcex.lpszMenuName = (LPCSTR)IDC_TRIALPHA;

    wcex.lpszClassName    = szWindowClass;
    wcex.hIconSm          = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

    return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT rectDesktop;
    RECT rectWnd;

    HWND hWndDesktop = GetDesktopWindow();

    hMainInstance = hInstance; // Store instance handle in our global variable

    if (screensaver)
    {
        if (silent)
        {
            GetWindowRect(hwndParent, &rectWnd);
        }
        else
        {
            rectWnd.left   = 0;
            rectWnd.top    = 0;
            rectWnd.right  = GetSystemMetrics(SM_CXSCREEN);
            rectWnd.bottom = GetSystemMetrics(SM_CYSCREEN);
        }

        ghwndMain = CreateWindowEx(
            WS_EX_TOPMOST,
            szWindowClass,
            NULL,
            WS_POPUP,
            rectWnd.left, rectWnd.top,
            rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
            NULL,
            NULL,
            hInstance,
            NULL);
    }
    else
    {
        GetWindowRect(hWndDesktop, &rectDesktop);

        rectWnd = rectDesktop;

        rectWnd.top += 100;
        rectWnd.left += 100;
        rectWnd.right -= 100;
        rectWnd.bottom -= 100;

        ghwndMain = CreateWindow(
            szWindowClass,
            szTitle,
            WS_OVERLAPPEDWINDOW,
            rectWnd.left, rectWnd.top,
            rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
            NULL,
            NULL,
            hInstance,
            NULL);
    }

    if (!ghwndMain)
    {
        return FALSE;
    }

    if (!showconfig)
    {
        ShowWindow(ghwndMain, nCmdShow);
        UpdateWindow(ghwndMain);
    }

    timerID = SetTimer(ghwndMain, 1, 10, NULL);

    return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND    - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY    - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message) 
    {
        case WM_WINDOWPOSCHANGED:
        {
            timercount = 0;
            ClearOffscreen();
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            timercount = 0;
            currentSettings.leaveTrails = !currentSettings.leaveTrails;
            ClearOffscreen();
        }
        break;

        case WM_RBUTTONDOWN:
        {
            randomizecolors(-1);
        }
        break;

        case WM_TIMER:
        {
            if (!suspend)
            {
                if (timercount >= currentSettings.lifetime && currentSettings.leaveTrails)
                {
                    if ((timercount - currentSettings.lifetime) > currentSettings.delay)
                    {
                        timercount = 0;
                        InvalidateRect(hWnd, NULL, TRUE);
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }
                }
                else
                {
                    // Render everything to an offscreen buffer instead of
                    // directly to the display surface...
                    HDC hdcOffscreen = NULL;
                    int width, height;

                    HDC hDC = GetDC(hWnd);
                    RECT rectClient;
                    RECT rectOffscreen;

                    GetClientRect(hWnd, &rectClient);

                    width = rectClient.right - rectClient.left;
                    height = rectClient.bottom - rectClient.top;

                    rectOffscreen.left   = 0;
                    rectOffscreen.top    = 0;
                    rectOffscreen.right  = width;
                    rectOffscreen.bottom = height;

                    hdcOffscreen = GetOffscreen(hDC, width, height);

                    if (hdcOffscreen)
                    {
                        RECT rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
                        }

                        DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, &rectBounds);

                        RECT rectBlt = rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            rectBlt.left   = min(rectBlt.left,   rectLast.left);
                            rectBlt.top    = min(rectBlt.top,    rectLast.top);
                            rectBlt.right  = max(rectBlt.right,  rectLast.right);
                            rectBlt.bottom = max(rectBlt.bottom, rectLast.bottom);
                        }

                        StretchBlt(
                            hDC,
                            rectClient.left + rectBlt.left,
                            rectClient.top + rectBlt.top,
                            rectBlt.right - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            hdcOffscreen,
                            rectBlt.left,
                            rectBlt.top,
                            rectBlt.right  - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            SRCCOPY);

                        rectLast = rectBounds;
                    }

                    ReleaseDC(hWnd, hDC);
                }

                timercount++;
            }
        }
        break;

        case WM_COMMAND:
        {
            int wmId, wmEvent;

            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_SETTINGS:
                {
                    suspend = TRUE;
                    if (DialogBox(hMainInstance, (LPCTSTR)DLG_SCRNSAVECONFIGURE, hWnd, ScreenSaverConfigureDialog) == IDOK)
                    {
                        timercount = 0;
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }

                    InvalidateRect(hWnd, NULL, TRUE);
                    suspend = FALSE;

                    if (showconfig)
                        PostQuitMessage(0);
                }
                break;

                case IDM_ABOUT:
                    DialogBox(hMainInstance, (LPCTSTR)IDD_ABOUTBOX, hWnd, About);
                break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                break;

                default:
                    lresult = DefWindowProc(hWnd, message, wParam, lParam);
                break;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hWnd, &ps);

            lresult = PaintWnd(hWnd, hdc);

            EndPaint(hWnd, &ps);

            return lresult;
        }
        break;

        case WM_DESTROY:
        {
            PostQuitMessage(0);
        }
        break;

        default:
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
   }

   return lresult;
}

// Message handler for about box.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
            lresult = TRUE;
        break;

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                lresult = TRUE;
            }
        }
        break;
    }

    return lresult;
}

#else // !STANDALONE_DEBUG

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{ 
    return TRUE; 
} 

LRESULT WINAPI ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    LRESULT lresult = 0;

    switch(message) 
    { 
        case WM_CREATE:
        {
            if (!gGdiplusInitHelper.IsValid())
                return 0;

            srand(GetTickCount());

            LoadState();

            randomizelocations();
            randomizecolors(-1);

            timerID = SetTimer(hwnd, 1, 10, NULL);
        }
        break;

        case WM_TIMER:
        {
            if (!suspend)
            {
                if (timercount >= currentSettings.lifetime && currentSettings.leaveTrails)
                {
                    if ((timercount - currentSettings.lifetime) > currentSettings.delay)
                    {
                        timercount = 0;
                        InvalidateRect(hwnd, NULL, TRUE);
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }
                }
                else
                {
                    // Render everything to an offscreen buffer instead of
                    // directly to the display surface...
                    HDC hdcOffscreen = NULL;
                    int width, height;

                    HDC hDC = GetDC(hwnd);
                    RECT rectClient;
                    RECT rectOffscreen;

                    GetClientRect(hwnd, &rectClient);

                    width = rectClient.right - rectClient.left;
                    height = rectClient.bottom - rectClient.top;

                    rectOffscreen.left   = 0;
                    rectOffscreen.top    = 0;
                    rectOffscreen.right  = width;
                    rectOffscreen.bottom = height;

                    hdcOffscreen = GetOffscreen(hDC, width, height);

                    if (hdcOffscreen)
                    {
                        RECT rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
                        }

                        DrawGraphics(hwnd, hdcOffscreen, &rectOffscreen, &rectBounds);

                        RECT rectBlt = rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            rectBlt.left   = min(rectBlt.left,   rectLast.left);
                            rectBlt.top    = min(rectBlt.top,    rectLast.top);
                            rectBlt.right  = max(rectBlt.right,  rectLast.right);
                            rectBlt.bottom = max(rectBlt.bottom, rectLast.bottom);
                        }

                        StretchBlt(
                            hDC,
                            rectClient.left + rectBlt.left,
                            rectClient.top + rectBlt.top,
                            rectBlt.right - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            hdcOffscreen,
                            rectBlt.left,
                            rectBlt.top,
                            rectBlt.right  - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            SRCCOPY);

                        rectLast = rectBounds;
                    }

                    ReleaseDC(hwnd, hDC);
                }

                timercount++;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hwnd, &ps);

            lresult = PaintWnd(hwnd, hdc);

            EndPaint(hwnd, &ps);

            return lresult;
        }
        break;

        case WM_DESTROY:
            KillTimer(hwnd, timerID);
            FreeOffscreen();
        break;
    }

    lresult = DefScreenSaverProc(hwnd, message, wParam, lParam);

    return lresult;
}

#endif // !STANDALONE_DEBUG

// Message handler for settings dlg
INT_PTR CALLBACK ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            LoadState();

            // Set the current values into the dialog controls...
            dialogSettings = currentSettings;

            SetDlgItemInt(hDlg, IDC_COUNT,    dialogSettings.count, FALSE);
            SetDlgItemInt(hDlg, IDC_ALPHA,    dialogSettings.alpha, FALSE);
            SetDlgItemInt(hDlg, IDC_LIFETIME, dialogSettings.lifetime, FALSE);
            SetDlgItemInt(hDlg, IDC_DELAY,    dialogSettings.delay, FALSE);
            SetDlgItemInt(hDlg, IDC_ROTATIONS,dialogSettings.rotations, FALSE);
            SetDlgItemInt(hDlg, IDC_THETA,    (int)(dialogSettings.theta * 10), TRUE);

            for(int i=dtTriangles;i<=dtText;i++)
            {
                char szShape[256];

                LoadString(hMainInstance, IDS_SHAPE_BASE + i, szShape, sizeof(szShape));
                SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_ADDSTRING, 0, (LPARAM)szShape);
            }

            SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_SETCURSEL, (WPARAM)dialogSettings.shape, 0);

            SendMessage(GetDlgItem(hDlg, IDC_LEAVETRAILS), BM_SETCHECK, dialogSettings.leaveTrails ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_CLEARSCREEN), BM_SETCHECK, dialogSettings.clearScreen ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTVERT), BM_SETCHECK, dialogSettings.reflectVertical ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTHORZ), BM_SETCHECK, dialogSettings.reflectHorizontal ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTDIAG), BM_SETCHECK, dialogSettings.reflectDiagonal ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_OSCILLATE),   BM_SETCHECK, dialogSettings.oscillate ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_FILLED),      BM_SETCHECK, dialogSettings.filled ? BST_CHECKED : BST_UNCHECKED, 0);


            lresult = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_COUNT :
                    dialogSettings.count = GetDlgItemInt(hDlg, IDC_COUNT, NULL, FALSE);

                    if (dialogSettings.count > MAX_LINES)
                        dialogSettings.count = MAX_LINES;
                break;

                case IDC_ALPHA :
                    dialogSettings.alpha = (BYTE)GetDlgItemInt(hDlg, IDC_ALPHA, NULL, FALSE);
                break;

                case IDC_LIFETIME:
                    dialogSettings.lifetime = GetDlgItemInt(hDlg, IDC_LIFETIME, NULL, FALSE);
                    if (dialogSettings.lifetime > 10000)
                        dialogSettings.lifetime = 10000;
                break;

                case IDC_DELAY :
                    dialogSettings.delay = GetDlgItemInt(hDlg, IDC_DELAY, NULL, FALSE);
                    if (dialogSettings.delay > 10000)
                        dialogSettings.delay = 10000;
                break;

                case IDC_ROTATIONS :
                    dialogSettings.rotations = GetDlgItemInt(hDlg, IDC_ROTATIONS, NULL, FALSE);
                    if (dialogSettings.rotations > 90)
                        dialogSettings.rotations = 90;
                break;

                case IDC_THETA :
                    dialogSettings.theta = GetDlgItemInt(hDlg, IDC_THETA, NULL, FALSE) / 10.0f;
                    while(dialogSettings.theta >= 360.0f)
                        dialogSettings.theta -= 360.0f;

                    while(dialogSettings.theta <= -360.0f)
                        dialogSettings.theta += 360.0f;
                break;

                case IDC_LEAVETRAILS :
                    dialogSettings.leaveTrails = SendMessage(GetDlgItem(hDlg, IDC_LEAVETRAILS), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_CLEARSCREEN :
                    dialogSettings.clearScreen = SendMessage(GetDlgItem(hDlg, IDC_CLEARSCREEN), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTVERT :
                    dialogSettings.reflectVertical = SendMessage(GetDlgItem(hDlg, IDC_REFLECTVERT), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTHORZ :
                    dialogSettings.reflectHorizontal = SendMessage(GetDlgItem(hDlg, IDC_REFLECTHORZ), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTDIAG :
                    dialogSettings.reflectDiagonal = SendMessage(GetDlgItem(hDlg, IDC_REFLECTDIAG), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_OSCILLATE :
                    dialogSettings.oscillate = SendMessage(GetDlgItem(hDlg, IDC_OSCILLATE), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_FILLED :
                    dialogSettings.filled = SendMessage(GetDlgItem(hDlg, IDC_FILLED), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_SHAPE:
                    dialogSettings.shape = (SHAPE)SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_GETCURSEL, 0, 0);
                break;

                case IDOK:
                {
                    // copy the dialog control values to our currentSettings:
                    currentSettings = dialogSettings;
                    SaveState();
                }
                // break; - fall through so the dialog closes!

                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    lresult = TRUE;
                }
                break;
            }
        }
        break;
    }

    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\common.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Common code
*
* Abstract:
*
*   This is code which is used by multiple modules of GDI+.
*
* Created:
*
*   4/27/1999 agodfrey
*
\**************************************************************************/

#ifndef _COMMON_HPP
#define _COMMON_HPP

/* Define offsetof macro */
#ifndef offsetof
#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif
#endif

// ddraw.h is needed by globals.hpp

#include <ddraw.h>
#include <d3d.h>
#include <dciman.h>

// Internally, we want to initialize FilterType values using
// InterpolationModeDefaultInternal so that the FilterType
// is set to a on-aliased enumeration value.

#define InterpolationModeDefaultInternal InterpolationModeBilinear

/*class GpPointD;
class GpPoint;
class GpRect;
class GpColor64;
class GpString;
class GpGlyphPos;
*/

class GpFontFamily;
class GpFontCollection;
class GpInstalledFontCollection;
class GpCacheFaceRealizationList;
class GpPrivateFontCollection;

class GpMatrix;
class GpGraphics;
class GpSurface;
class GpRegion;
class GpPen;
class GpBrush;
class GpFaceRealization;
class GpFontFace;
class GpFont;
class GpTextItem;
class GpStringFormat;
class GpPath;
class GpImage;
class GpBitmap;
class GpGraphics;

class GpRegionData;
class GpLineTexture;

struct DrawGlyphData;

typedef RectF GpRectF;
typedef SizeF GpSizeF;
typedef PointF GpPointF;
typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef CompositingMode GpCompositingMode;
typedef CompositingQuality GpCompositingQuality;
typedef TextRenderingHint GpTextRenderingHint;
typedef Unit GpUnit;
typedef Unit GpPageUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef WrapMode GpWrapMode;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;
typedef DashCap GpDashCap;
typedef LineJoin GpLineJoin;
typedef PathPointType GpPathPointType;
typedef CombineMode GpCombineMode;
typedef ImageType GpImageType;
typedef PenType GpPenType;
typedef PenAlignment GpPenAlignment;
typedef StringFormatFlags      GpStringFormatflags;
typedef StringAlignment        GpStringAlignment;
typedef StringTrimming         GpStringTrimming;
typedef StringDigitSubstitute  GpStringDigitSubstitute;
typedef StringTrimming         GpStringTrimming;
typedef HotkeyPrefix           GpHotkeyPrefix;
typedef BrushType GpBrushType;
typedef EnumerationType DpEnumerationType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;

// This structure should coincide with PathData, the difference being we
// don't do automatic deletion of PathData contents.
class GpPathData
{
public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

inline
REAL VectorLength(const PointF & point)
{
    return (REAL)sqrt(point.X * point.X + point.Y * point.Y);
}

#include "..\entry\intmap.hpp"
#include"..\text\inc\unidir.hxx"
#include "..\text\imager\DigitSubstitution.hpp"
#include "globals.hpp"
#include "dynarray.hpp"
#include "matrix.hpp"
#include "engine.hpp"
#include "rasterizer.hpp"
#include "stackbuffer.hpp"
#include "monitors.hpp"
#include "testcontrol.hpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\demos\trialpha\trialpha.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <scrnsave.h>

#include "gdiplus.h"

using namespace Gdiplus;

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*
*  8/16/2000 bhouse
*  + Changed to growth mechanics to be exponential
*
\**************************************************************************/

// 
// There are some routines for sorting and positional add and delete that
// are being removed. This #define is to make that process easier. When 
// DynSortArray is removed, the code protected by this #define should be
// removed too.
//
// See pathselfintersectremover.hpp for the definition of DynSortArray.
//

#define USE_OBSOLETE_DYNSORTARRAY


class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - initial number of elements

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT count = 0);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements
    // exactSize         - no exponential growth

    GpStatus Grow(UINT eltSize, UINT newElements, BOOL exactSize = FALSE);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Detach the data buffer from the dynamic array.
    // Allocates the buffer to detatch if it is the initial allocation.

    GpStatus DetachData(UINT eltSize, void **buffer);
    
    
    #ifdef USE_OBSOLETE_DYNSORTARRAY
    
    // 
    // NOTE: These functions are used only by DynSortArray and it is being
    // discontinued. Do not use. These routines have horrible performance
    // characteristics.
    // 
    
    
    // Add new, uninitialized elements, and return a pointer to them.
    // All data from index on is shift towards the end of the array to make room.
    // index       - index from which to insert the new elements.
    // eltSize     - size of each element
    // newElements - number of new elements
    // CAUTION! could cause a big performance hit if the array is large!

    void *AddMultipleAt(UINT eltSize, UINT index, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // All data from index on is shift towards the end of the array to make room.
    // eltSize     - size of each element
    // index       - index from which to insert the new elements.
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus AddMultipleAt(UINT eltSize, UINT index, UINT newElements, const void *newData);

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(UINT eltSize, UINT index, UINT numElements);
    
    #endif
    
    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    enum {
        kMinCapacityGrowth = 16,
        kMaxCapacityGrowth = 8092
    };

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
*   06/10/1999 t-wehunt
*       Added AddXXAt, DeletXXAt, and InsertAt methods.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
*   06/10/1999 t-wehunt
*   + AddXXAt, DeletXXAt, and InsertAt methods shift elements around in memory 
*     to keep the array contiguous.
*   + CAUTION: This could cause a big performance hit if the array is very large. 
*     Use care when calling these methods!!!
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

#include "dynArrayImpl.hpp"

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - the initial count
    //

    DynArray(
        T *initialAllocation, 
        UINT allocSize,
        UINT count = 0):
        DynArrayImpl(initialAllocation, allocSize, count)
    {
    }

    // Constructor (no initial allocation)
    //

    DynArray(void):
        DynArrayImpl(NULL, 0, 0)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    UINT GetCapacity() const
    {
        return Capacity;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }
    
    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Detach the data buffer from the dynamic array
    // Allocates the buffer to detatch if it is the initial allocation.

    GpStatus DetachData(T **buffer)
    {
        return DynArrayImpl::DetachData(sizeof(T), (void **)buffer);
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    GpStatus ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        
        GpStatus status = dynarr->DetachData((T**)(&DataBuffer));
        
        if(Ok != status)
        {
            Count = 0;
            Capacity = 0;
        }
        
        return status;
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
        
        ASSERT(Count <= Capacity);
    }

    VOID SetCount(UINT count)
    {
        ASSERT(Count <= Capacity);
        
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements, BOOL exact = FALSE)
    {
        return Grow(sizeof(T), newElements, exact);
    }
};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array;
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements. Such a declaration can be used on the stack or in another
// object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //

    DynArrayIA(void):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, 0)
    {
    }

    DynArrayIA(T * initialAllocationBuffer, UINT initialAllocationSize, UINT count = 0) :
        DynArray<T>(initialAllocationBuffer, initialAllocationSize, count)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\engine.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains simple engine-wide prototypes and helper functions and
*   compile time flags.
*
* History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _ENGINE_HPP
#define _ENGINE_HPP

//--------------------------------------------------------------------------
// GDI+ internal prototypes
//--------------------------------------------------------------------------

class GpDevice;
struct DpPen;

USHORT 
GetLanguageID();

BOOL 
InitSystemFontsDirs(VOID);  //WCHAR **system_dir, WCHAR **fonts_dir);

UINT32
Crc32(
    IN const VOID*  buf,
    IN UINT         size,
    IN UINT32       checksum
    );

// Get the ceiling the same way the rasterizer does
inline INT
RasterizerCeiling(
    REAL    value
    )
{
    return GpFix4Ceiling(GpRealToFix4(value));
}

GpStatus
BoundsFToRect(
    const GpRectF *rectF,
    GpRect * rect
    );

/*
REAL
GetPenDelta(
    const DpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    );
*/

REAL GetDeviceWidth(
    REAL width,
    GpUnit unit,
    REAL dpi);

VOID
TransformBounds(
    const GpMatrix *matrix,
    REAL x0,
    REAL y0,
    REAL x1,
    REAL y1,
    GpRectF *bounds
    );

LONG
WINAPI
InterlockedCompareExchangeWin95(
    IN OUT PLONG destination,
    IN LONG exchange,
    IN LONG comperand
    );

LONG
WINAPI
InterlockedIncrementWin95(
    IN LPLONG lpAddend
    );

LONG
WINAPI
InterlockedDecrementWin95(
    IN LPLONG lpAddend
    );

BOOL
APIENTRY
GdiIsMetaPrintDCWin9x(
    HDC hdc
    );

//--------------------------------------------------------------------------
// The following macro is useful for checking if the creation of an 
// internal object succeeds.  
//
// We don't want to use exceptions to allow a constructor to indicate failure, 
// so the object has to contain an 'IsValid()' member that returns TRUE if 
// the object was successfully allocated.  But then the caller has to write
// the following code:
//
//      p = new Object();
//      if (!p  || !p->IsValid())
//      {
//          delete p;
//          ...
//
// The following macro can be used to replace this with:
//
//      p = new Object();
//      if (!CheckValid(p))
//      {
//          ...
//
// !!!
//  Note that CheckValid sets the input parameter to NULL
//  when the return value is FALSE.
//
//--------------------------------------------------------------------------

template <class T>
inline BOOL
CheckValid(
    T*& p
    )
{
    if (p && p->IsValid())
    {
        return TRUE;
    }
    else
    {
        delete p;
        p = NULL;
        return FALSE;
    }
}

//--------------------------------------------------------------------------
// Name dynamic array types
//--------------------------------------------------------------------------

typedef DynArray<GpPointF> DynPointFArray;
typedef DynArray<GpPoint> DynPointArray;
typedef DynArray<BYTE> DynByteArray;
typedef DynArray<INT> DynIntArray;
typedef DynArray<REAL> DynRealArray;
typedef DynArray<VOID*> DynPointerArray;

//--------------------------------------------------------------------------
// Raw critical section object
// The Initialize function can throw.
//--------------------------------------------------------------------------

class GpSemaphore
{
private:
    CRITICAL_SECTION CriticalSection;
    BOOL             Initialized;

public:

    GpSemaphore()
    {
        Initialized = FALSE;
    }

    VOID 
    Initialize(
        VOID
        )
    {
        if (!Initialized)
        {
            // The caller has to have a Try_Except around us.
            __try
            {
                InitializeCriticalSection(&CriticalSection); 
            }
            __except(EXCEPTION_CONTINUE_SEARCH)
            {
            }
            Initialized = TRUE;
        }
    }

    VOID 
    Uninitialize(
        VOID
        );

    VOID 
    Lock(
        VOID
        )
    {
        ASSERT(Initialized);
        EnterCriticalSection(&CriticalSection); 
    }

    VOID 
    Unlock(
        VOID
        )
    {
        ASSERT(Initialized);
        LeaveCriticalSection(&CriticalSection); 
    }

    BOOL 
    IsLocked(
        VOID
        );

    BOOL
    IsLockedByCurrentThread(
        VOID
        );
};


//------------------------------------------------------------------------
// FillMemoryInt32 - Fill an INT32 array with the specified value
// CopyMemoryInt32 - Copy INT32 values from one array to another
//------------------------------------------------------------------------

inline VOID
FillMemoryInt32(
    VOID* buf,
    INT count,
    INT32 val
    )
{
    INT32* p = (INT32*) buf;

    while (count-- > 0)
        *p++ = val;
}

inline VOID
CopyMemoryInt32(
    VOID* dst,
    const VOID* src,
    INT count
    )
{
    INT32* d = (INT32*) dst;
    const INT32* s = (const INT32*) src;

    while (count-- > 0)
        *d++ = *s++;
}

//------------------------------------------------------------------------
// CompareExchangeLong_Ptr - Perform an interlocked compare-exchange
//      on a LONG_PTR.  Unfortunately, Win95 does not export
//      InterlockedCompareExchange, so on that platform we have
//      to create our own.  But on NT, we CANNOT roll our own, because
//      of MP and NT64 issues.
//
//      This method should be called instead of calling through the 
//      Globals::InterlockedCompareExchangeFunction directly, because
//      on Alpha machines, Globals::InterlockedCompareExchangeFunction does
//      NOT get initialized.
//------------------------------------------------------------------------
inline LONG_PTR
CompareExchangeLong_Ptr(
    LONG_PTR *destination,
    LONG_PTR  exchange,
    LONG_PTR  comperand
    )
{
    #if defined(_X86_)
        return InterlockedCompareExchange(destination,
                                          exchange,
                                          comperand);
    #else
        return (LONG_PTR)InterlockedCompareExchangePointer(
                               (PVOID *)destination, 
                               (PVOID)exchange, 
                               (PVOID)comperand);
    #endif
}

//------------------------------------------------------------------------
// CompareExchangePointer - Perform an interlocked compare-exchange
//      on a pointer.  Unfortunately, Win95 does not export
//      InterlockedCompareExchangePointer, so on that platform we have
//      to create our own.  But on NT, we CANNOT roll our own, because
//      of MP and NT64 issues.
//------------------------------------------------------------------------

inline VOID*
CompareExchangePointer(
    VOID** destination,
    VOID* exchange,
    VOID* comperand
    )
{
    #if defined(_X86_)
        return((VOID*) InterlockedCompareExchange((LONG*) destination,
                                                  (LONG) exchange,
                                                  (LONG) comperand));
    #else
        return(InterlockedCompareExchangePointer(destination, 
                                                 exchange, 
                                                 comperand));
    #endif
}

//--------------------------------------------------------------------------
// This routine retrieves a quick, pre-allocated region from a one-deep
// cache.  Note that the contents will be random.  This call is intended 
// largely for GDI API calls such as GetRandomRgn that require a pre-created 
// region.
//
// NOTE: This can return a NULL region handle.
//--------------------------------------------------------------------------

inline
HRGN GetCachedGdiRegion(
    VOID
    )
{
    HRGN regionHandle = Globals::CachedGdiRegion;
    
    // If the Globals::CachedGdiRegion is NULL, that means that someone
    // else has the cached region, so we create a new one.
    // It is possible during multi thread access for us to create a region
    // when it's not strictly necessary --- i.e. a thread releases the cached
    // region when this thread is between the above assignment and the next
    // if statement, but that's only non-optimal and we'll work correctly 
    // under those circumstances.
    
    if ((regionHandle == NULL) ||
        (CompareExchangePointer(
            (VOID**) &Globals::CachedGdiRegion,
            NULL,
            (VOID*) regionHandle) != regionHandle
        )
       )
    {
        regionHandle = CreateRectRgn(0, 0, 1, 1);
    }
    return(regionHandle);
}

//--------------------------------------------------------------------------
// This routine releases a region to the one-deep cache.
//--------------------------------------------------------------------------

inline
VOID ReleaseCachedGdiRegion(
   HRGN regionHandle
   )
{
    // Note that 'regionHandle' may be NULL at this point if the 
    // CreateRectRgn failed, but that's okay:

    if (CompareExchangePointer((VOID**) &Globals::CachedGdiRegion,
                               (VOID*) regionHandle,
                               NULL) != NULL)
    {
        DeleteObject(regionHandle);
    }
}

inline
HDC GetCleanHdc(
    HWND    hwnd
    )
{
    // Use GetDCEx(DCX_CACHE) to get a nice clean DC (not a CS_OWNDC).  
    // Note that with GetDCEx we have to explicitly respect the window's
    // clipping styles. We stole this little bit of logic straight from 
    // ntuser\kernel\dc.c for the DCX_USESTYLE case:

    DWORD getDcFlags = DCX_CACHE;
    LONG classStyle = GetClassLongA(hwnd, GCL_STYLE);
    LONG windowStyle = GetWindowLongA(hwnd, GWL_STYLE);

    if (classStyle & CS_PARENTDC)
        getDcFlags |= DCX_PARENTCLIP;

    if (windowStyle & WS_CLIPCHILDREN)
        getDcFlags |= DCX_CLIPCHILDREN;

    if (windowStyle & WS_CLIPSIBLINGS)
        getDcFlags |= DCX_CLIPSIBLINGS;

    // Minimized windows never exclude their children.

    if (windowStyle & WS_MINIMIZE)
        getDcFlags &= ~DCX_CLIPCHILDREN;

    return GetDCEx(hwnd, NULL, getDcFlags);
}

inline INT
GetIntDistance(
    POINT &         p1,
    POINT &         p2
    )
{
    double      dx = (double)(p2.x - p1.x);
    double      dy = (double)(p2.y - p1.y);

    REAL        distance = (REAL)sqrt((dx * dx) + (dy * dy));
    
    return GpRound(distance);
}

inline REAL
GetDistance(
    GpPointF &      p1,
    GpPointF &      p2
    )
{
    double      dx = (double)p2.X - p1.X;
    double      dy = (double)p2.Y - p1.Y;

    return (REAL)sqrt((dx * dx) + (dy * dy));
}

inline REAL
GetDegreesFromRadians(double radians)
{
    return (REAL)(radians*180.0/3.1415926535897932);
}

// return angle in degrees from 2 points
inline REAL
GetAngleFromPoints(
    const GpPointF &    p1,
    const GpPointF &    p2
    )
{
    // Compute the angle of the line formed by p1 and p2.
    // Note atan2 is only undefined if dP.Y == 0.0 and dP.X == 0.0
    // and then it returns 0 radians. 
    // Also, atan2 correctly computes the quadrant from the two input points.
    
    GpPointF    dP = p2 - p1;
    double      radians = atan2((double)(dP.Y), (double)(dP.X));
    return GetDegreesFromRadians(radians);
}

#define DEFAULT_RESOLUTION  96  // most display screens are set to 96 dpi

//--------------------------------------------------------------------------
// The following 3 functions should be used in place of GetObjectType due
// to a bug on Windows 9x where an OBJ_METAFILE and another type of object
// may share the same handle!
//
// GetObjectTypeInternal: Call this to determine any object type except
//                        when expecting OBJ_METAFILE or OBJ_*DC.
//
// GetDCType: Use this when the object should be a DC,and just the type of
//            DC is required.
//
// IsValidMetaFile: OBJ_METAFILE is the special case. Use this function to
//                  validate when OBJ_METAFILE is expected. This only means
//                  there is a metafile with this handle. There could also
//                  be an "aliased" object which the caller intended to be
//                  used, so this should not be used to handle multiple
//                  object types.
//--------------------------------------------------------------------------

DWORD
GetObjectTypeInternal(
    IN HGDIOBJ handle
    );

DWORD
GetDCType(
    IN HDC hdc
    );

inline
BOOL
IsValidMetaFile(
    HMETAFILE handle
    )
{
    return (GetObjectType(handle) == OBJ_METAFILE);
};

#endif // !_ENGINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\engine.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains miscellaneous engine helper functions.
*
* Revision History:
*
*   12/13/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   The kernel32.dll function InterlockedCompareExchange does not exist 
*   on Win95, so we use this one instead when running on that platform.  
*   Unfortunately, Win95 can run on 386 machines, which don't have the
*   cmpxchg instruction, so we have to roll it ourselves.
*
* Arguments:
*
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedCompareExchangeWin95(
    IN OUT PLONG destination,
    IN LONG exchange,
    IN LONG comperand
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    LONG initialValue = *destination;
    
    if (initialValue == comperand)
    {
        *destination = exchange;
    }

    _asm sti            // Re-enable interrupts

    return(initialValue);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   The InterlockedIncrement function in Win95 returns only a positive
*   result if the value is positive, but not necessarily the resulting value.
*   This differs from WinNT semantics which always returns the incremented
*   value.
*
* Arguments:
*
*   [IN] lpAddend - Pointer to value to increment
*
* Return Value:
*
*   NONE
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedIncrementWin95(
    IN LPLONG lpAddend
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    *lpAddend += 1;
    
    LONG value = *lpAddend;

    _asm sti            // Re-enable interrupts

    return(value);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   The InterlockedDecrement function in Win95 returns only a positive
*   result if the value is positive, but not necessarily the resulting value.
*   This differs from WinNT semantics which always returns the incremented
*   value.
*
* Arguments:
*
*   [IN] lpAddend - Pointer to value to increment
*
* Return Value:
*
*   NONE
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedDecrementWin95(
    IN LPLONG lpAddend
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    *lpAddend -= 1;
    
    LONG value = *lpAddend;

    _asm sti            // Re-enable interrupts

    return(value);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*   
*   Given a DC to an enhanced metafile, this function determines whether
*   the DC is actually a printer DC or a true metafile DC.  
*
*   After spending a day pouring over the Win9x GDI code, I could find
*   no fool-proof API accessible method of determining whether a metafile 
*   DC is a printer DC or not.  We could potentially crack the DC handle 
*   to get the DCTYPE structure and look at flPrinting to see if 
*   PR_EMF_SPOOL is set, but the various flavors of Win9x have different 
*   DCTYPE structures (including Far East differences).
*
*   The only exploitable difference is the fact that Win9x doesn't allow 
*   escapes down to the associated device for true metafile DCs, but does 
*   for metafile print DCs.  We check for the support of QUERYESCSUPPORT, 
*   which according to the DDK all drivers are required to support, but
*   theoretically there are some that might not (so this method isn't
*   foolproof).
*
*   Note that this function works only on Win9x, as on NT escapes are
*   allowed down to the printer at record time even for true metafile DCs.
*
* Arguments:
*
*   [IN] hdc - Handle to an EMF DC
*
* Return Value:
*
*   TRUE - The DC is guaranteed to be a printer DC
*   FALSE - The DC is 99% likely to be a true metafile (there's about a 1%
*           change that the DC is a true printer DC
*
* History:
*
*   10/6/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
APIENTRY
GdiIsMetaPrintDCWin9x(
    HDC hdc
    )
{
    BOOL isPrint = FALSE;

    // Our check won't work for OBJ_DC or OBJ_MEMDC types:

    ASSERT(GetDCType(hdc) == OBJ_ENHMETADC);
    
    // Make sure we don't get any false positives from metafiles associated
    // with a display:
    
    int deviceCaps = GetDeviceCaps(hdc, TECHNOLOGY);
    if ((deviceCaps == DT_RASPRINTER) || (deviceCaps == DT_PLOTTER))
    {
        // Check to see if QUERYESCSUPPORT is supported by the driver
        // (if it is, that tells us everything we need to know!)
    
        DWORD queryEscape = QUERYESCSUPPORT;
        isPrint = (ExtEscape(hdc, 
                             QUERYESCSUPPORT, 
                             sizeof(queryEscape), 
                             (CHAR*) &queryEscape, 
                             0, 
                             NULL) > 0);
        if (!isPrint)
        {
            // SETCOPYCOUNT is the most commonly supported printer escape, 
            // which we check in addition to QUERYESCSUPPORT because I'm a 
            // little paranoid that drivers might forget to say they support 
            // the QUERYESCSUPPORT function when called by QUERYESCSUPPORT.
        
            DWORD setCopyCount = SETCOPYCOUNT;
            isPrint = (ExtEscape(hdc,
                                 QUERYESCSUPPORT,
                                 sizeof(setCopyCount),
                                 (CHAR*) &setCopyCount,
                                 0,
                                 NULL) > 0);
        }
    }
    
    return(isPrint);
}

//
// 32 bit ANSI X3.66 CRC checksum table - polynomial 0xedb88320
//
// Copyright (C) 1986 Gary S. Brown.  You may use this program, or
// code or tables extracted from it, as desired without restriction.
//

static const UINT32 Crc32Table[] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


/**************************************************************************\
*
* Function Description:
*
*   Compute the 32-bit CRC checksum on a buffer of data
*
* Arguments:
*
*   buf - Points to the data buffer to be checksumed
*   size - Size of the data buffer, in bytes
*   checksum - Initial checksum value
*
* Return Value:
*
*   Resulting checksum value
*
\**************************************************************************/

UINT32
Crc32(
    IN const VOID*  buf,
    IN UINT         size,
    IN UINT32       checksum
    )
{
    const BYTE* p = (const BYTE*) buf;

    while (size--)
    {
        checksum = Crc32Table[(checksum ^ *p++) & 0xff] ^ (checksum >> 8);
    }

    return checksum;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a floating-point coordinate bounds to an integer pixel bounds.
*
*   Since we're converting bounds from float to int, we have to make sure
*   that the bounds are still encompassing of the object.  So we have to take
*   the floor of the left and top values, even though the rasterizer takes
*   the ceiling.  The reason for this is that the rasterizer uses 28.4 fixed
*   point.  So a number like 52.001 converts to 52.0 in 28.4, so the ceiling
*   in the rasterizer would be 52, whereas the ceiling of the original number
*   is 53, but if we return 53 here, then we would be incorrect.  It's better
*   to be too big here sometimes and still have all-encompassing bounds, than
*   to be right most of the time, but have too small a bounds the other times.
*
*   The other caveat is that we need to calculate the bounds assuming the
*   result will be used for antialiasing (the bounds antialiased fills are
*   bigger than the bounds for aliased fills).
*
*   NOTE: This conversion implicitly assumes that a fill is done on the
*         figure vertices.  Nominal-width lines REQUIRE the caller to
*         have increased all the dimensions by 1/2 before calling!
*
* Arguments:
*
* Return Value:
*
*   Ok for success, ValueOverflow if the boundsF would overflow the
*   integer size. rect is always initialized - for ValueOverflow, its
*   set to zero.
*
\**************************************************************************/

#define INT_BOUNDS_MAX   1073741823
#define INT_BOUNDS_MIN  -1073741824

GpStatus
BoundsFToRect(
    const GpRectF *boundsF,
    GpRect *rect                // Lower-right exclusive
    )
{
    // If you're wondering what the "+1" is doing below, read the 
    // above comment and remember that we're calculating the  bounds 
    // assuming antialiased fills.
    //
    // The tightest bound for an antialiased fill would truly be:
    //
    //      [round(min - epsilon), round(max + epsilon) + 1)
    //
    // Where 'epsilon' is the epsilon for rounding to our internal
    // 28.4 rasterization precision, which is 1/32 of a pixel,
    // and [left, right) is exclusive of the right pixel.
    //
    // We skip the 'round' and 'epsilon' business by using 'floor'
    // and 'ceiling':

    GpStatus status = Ok;

    if(boundsF->X >= INT_BOUNDS_MIN && boundsF->X <= INT_BOUNDS_MAX)
    {
        rect->X = GpFloor(boundsF->X);
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Y >= INT_BOUNDS_MIN) &&
        (boundsF->Y <= INT_BOUNDS_MAX))
    {
        rect->Y = GpFloor(boundsF->Y);
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Width >= 0) &&
        (boundsF->Width <= INT_BOUNDS_MAX))
    {
        rect->Width  = GpCeiling(boundsF->GetRight())  - rect->X + 1;
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Height >= 0) &&
        (boundsF->Height <= INT_BOUNDS_MAX))
    {
        rect->Height = GpCeiling(boundsF->GetBottom()) - rect->Y + 1;
    }
    else
    {
        status = ValueOverflow;
    }
    
    if(status != Ok)
    {
        // Make sure the rect is always initialized.
        // Also this makes the ASSERT below valid.
        
        rect->Width = 0;
        rect->Height = 0;
        rect->X = 0;
        rect->Y = 0;
    }

    // Don't forget that 'Width' and 'Height' are effectively 
    // lower-right exclusive.  That is, if (x, y) are (1, 1) and
    // (width, height) are (2, 2), then the object is 2 pixels by
    // 2 pixels in size, and does not touch any pixels in column
    // 3 or row 3:

    ASSERT((rect->Width >= 0) && (rect->Height >= 0));

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   This seems to be some sort of unit conversion function.  
*
* Arguments:
*
* Return Value:
*
\**************************************************************************/

REAL GetDeviceWidth(REAL width, GpUnit unit, REAL dpi)
{
    // UnitWorld cannot be used for this method.
    // UnitDisplay is device-dependent and cannot be used as a pen width unit

    ASSERT((unit != UnitWorld) && (unit != UnitDisplay));

    REAL deviceWidth = width;

    switch (unit)
    {
      case UnitPoint:       // Each unit represents 1/72 inch.
        deviceWidth *= dpi / 72.0f;
        break;

      case UnitInch:        // Each unit represents 1 inch.
        deviceWidth *= dpi;
        break;

      case UnitDocument:    // Each unit represents 1/300 inch.
        deviceWidth *= dpi / 300.0f;
        break;

      case UnitMillimeter:  // Each unit represents 1 millimeter.
                            // One Millimeter is 0.03937 inches
                            // One Inch is 25.4 millimeters
        deviceWidth *= dpi / 25.4f;
        break;

      default:              // this should not happen, if it does assume
                            // UnitPixel.
        ASSERT(0);
        // FALLTHRU

      case UnitPixel:       // Each unit represents one device pixel.
        break;

    }

    return deviceWidth;
}

/**************************************************************************\
*
* Function Description:
*
*   Given two coordinates defining opposite corners of a rectangle, this
*   routine transforms the rectangle according to the specified transform
*   and computes the resulting integer bounds, taking into account the
*   possibility of non-scaling transforms.
*
*   Note that it operates entirely in floating point, and as such takes
*   no account of rasterization rules, pen width, etc.
*
* Arguments:
*
*   [IN] matrix - Transform to be applied (or NULL)
*   [IN] x0, y0, x1, y1 - 2 points defining the bounds (they don't have
*                         to be well ordered)
*   [OUT] bounds - Resulting (apparently floating point) bounds
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
TransformBounds(
    const GpMatrix *matrix,
    REAL left,
    REAL top,
    REAL right,
    REAL bottom,
    GpRectF *bounds
    )
{
    // Note that we don't have to order the points before the transform
    // (in part because the transform may flip the points anyways):

    if (matrix && !matrix->IsIdentity())
    {
        GpPointF vertex[4];

        vertex[0].X = left;
        vertex[0].Y = top;
        vertex[1].X = right;
        vertex[1].Y = bottom;

        // If the transform is a simple scaling transform, life is a little
        // easier:

        if (matrix->IsTranslateScale())
        {
            matrix->Transform(vertex, 2);
    
            // We arrange the code here a little so that we don't take a
            // jump on the common case, where the transform is non-flipping:

            left = vertex[1].X;
            right = vertex[0].X;
            if (left > right)
            {
                left = vertex[0].X;
                right = vertex[1].X;
            }
    
            top = vertex[1].Y;
            bottom = vertex[0].Y;
            if (top > bottom)
            {
                top = vertex[0].Y;
                bottom = vertex[1].Y;
            }
        }
        else
        {
            // Ugh, the result is not a rectangle in device space (it might be
            // a parallelogram, for example).  Consequently, we have to look at
            // the bounds of all the vertices:

            vertex[2].X = left;
            vertex[2].Y = bottom;
            vertex[3].X = right;
            vertex[3].Y = top;

            matrix->Transform(vertex, 4);

            left = right = vertex[0].X;
            top = bottom = vertex[0].Y;

            for (INT i = 1; i < 4; i++)
            {
                if (left > vertex[i].X)
                    left = vertex[i].X;

                if (right < vertex[i].X)
                    right = vertex[i].X;

                if (top > vertex[i].Y)
                    top = vertex[i].Y;

                if (bottom < vertex[i].Y)
                    bottom = vertex[i].Y;
            }

            ASSERT((left <= right) && (top <= bottom));
        }
    }
    
    bounds->X      = left;
    bounds->Y      = top;
    
    //!!! Watch out for underflow.

    if(right - left > CPLX_EPSILON)
        bounds->Width  = right - left;
    else
        bounds->Width = 0;
    if(bottom - top > CPLX_EPSILON)
        bounds->Height = bottom - top;
    else
        bounds->Height = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Checks if the current semaphore object is locked.  This is moved into
*   a C++ file because of the dependency on globals.hpp.  On Win9x this
*   function always returns TRUE.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

BOOL 
GpSemaphore::IsLocked(
        VOID
        )
{ 
    ASSERT(Initialized);
    if (Globals::IsNt)
    {
        return(((RTL_CRITICAL_SECTION*) &CriticalSection)->LockCount != -1); 
    }
    else
    {
        return TRUE;    // No way to do this on Win95
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*   Checks if the current semaphore object is locked by current thread.  
*   This is moved into a C++ file because of the dependency on globals.hpp.
*   On Win9x this function always returns TRUE.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

BOOL
GpSemaphore::IsLockedByCurrentThread(
        VOID
        )
{
    ASSERT(Initialized);
    if (Globals::IsNt) 
    {
        return(((RTL_CRITICAL_SECTION*) &CriticalSection)->OwningThread ==
               (HANDLE) (DWORD_PTR) GetCurrentThreadId());
    }
    else
    {
        return TRUE;    // No way to do this on Win9x
    }
}

   
/**************************************************************************\
*
* Function Description:
*
*   Uninitializes the critical section object.  
*   This is moved into a C++ file because of the dependency on globals.hpp.
*   On Win9x this function skips the IsLocked() check.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

VOID 
GpSemaphore::Uninitialize(
    VOID
    )
{
#ifdef DBG
    if (Globals::IsNt) 
    {
        ASSERTMSG(!IsLocked(), ("Semaphore can't be locked when deleted"));
    }
#endif

    if (Initialized)
    {
        DeleteCriticalSection(&CriticalSection); 
        Initialized = FALSE;
    }
}

#if defined(_X86_)

/**************************************************************************\
*
* Function Description:
*
*   This is a common function used by GetObjectTypeInternal and GetDCType.
*   It should not be called elsewhere.
*
*   NOTE: On Windows 9x, two GDI objects may have the same handle value, if
*         one is OBJ_METAFILE and the other is anything else. In this case
*         of colliding object handles, GetObjectType will always return
*         OBJ_METAFILE. This function temporarily invalidates the metafile
*         so GetObjectType will skip that check and return the type of the
*         colliding object. If no colliding object is found, or if OBJ_*DC
*         is returned, this function returns 0. OBJ_*DC objects may not be
*         "present" (available in 16-bit) sometimes, and so the wrong value
*         can be returned since GetObjectType does not make such a DC
*         "present".
*
* Arguments:
*
*   [IN] handle - GDI object handle (not when expecting OBJ_METAFILE)
*
* Return Value:
*
*   GDI object type identifier on success or 0 on failure
*
* History:
*
*   01/25/2001 johnstep
*       Created it.
*
\**************************************************************************/

static
DWORD
GetObjectTypeWin9x(
    IN HGDIOBJ handle
    )
{
    // Disable interrupts around this code to prevent other threads from
    // attempting to access this object, in case this is a collision, which
    // means we must modify the metafile object directly via the selector.

    __asm cli

    DWORD type = GetObjectType(handle);

    // If there are 2 objects with the same handle, one being an OBJ_METAFILE
    // and the other not, OBJ_METAFILE is always returned. Since the caller
    // is not interested in a metafile, do a hack here to skip the metafile
    // check and find the type of the colliding object, if any.

    if (type == OBJ_METAFILE)
    {
        // The first WORD of a metafile must contain 1 or 2, and we wouldn't
        // be here if it didn't. This macro will toggle a higher bit in the
        // first word to defeat the metafile check, allowing us to proceed to
        // the normal object check.

        #define XOR_METAFILE_BIT(selector)\
            __asm push gs\
            __asm mov gs, word ptr selector\
            __asm xor word ptr gs:[0], 8\
            __asm pop gs

        XOR_METAFILE_BIT(handle);

        type = GetObjectType(handle);

        XOR_METAFILE_BIT(handle);
    }

    // Make sure to reenable interrupts before returning.

    __asm sti

    return type;
}

#endif

/**************************************************************************\
*
* Function Description:
*
*   This is a workaround for a serious bug in Windows 9x GetObjectType
*   implementation. This function correctly returns the object type for the
*   given handle, unless it's an OBJ_*DC or OBJ_METAFILE. For those types,
*   it shouldn't crash, but it will intermittently return 0 instead of the
*   correct type.
*
*   For OBJ_*DC types, use GetDCType. You can validate an OBJ_METAFILE with
*   IsValidMetaFile, but you need to expect it to be a metafile handle. If
*   you don't know which of the 3 classes your handle falls into, you'll
*   need to expand on these workaround functions.
*
*   NOTE: On Windows 9x, two GDI objects may have the same handle value, if
*         one is OBJ_METAFILE and the other is anything else. In this case
*         of colliding object handles, GetObjectType will always return
*         OBJ_METAFILE. This function temporarily invalidates the metafile
*         so GetObjectType will skip that check and return the type of the
*         colliding object. If no colliding object is found, or if OBJ_*DC
*         is returned, this function returns 0. OBJ_*DC objects may not be
*         "present" (available in 16-bit) sometimes, and so the wrong value
*         can be returned since GetObjectType does not make such a DC
*         "present".
*
* Arguments:
*
*   [IN] handle - GDI object handle (not to verify for OBJ_METAFILE)
*
* Return Value:
*
*   GDI object type identifier on success or 0 on failure
*
* History:
*
*   01/25/2001 johnstep
*       Created it.
*
\**************************************************************************/

DWORD
GetObjectTypeInternal(
    IN HGDIOBJ handle
    )
{
#if defined(_X86_)
    if (!Globals::IsNt)
    {
        DWORD type = GetObjectTypeWin9x(handle);

        switch (type)
        {
            case OBJ_DC:
            case OBJ_METADC:
            case OBJ_MEMDC:
            case OBJ_ENHMETADC:
                type = 0;
                break;
        }
            
        return type;
    }
#else
    // We assume that this issue only matters on x86.

    ASSERT(Globals::IsNt);
#endif

    return GetObjectType(handle);
}

/**************************************************************************\
*
* Function Description:
*
*   GetObjectType on Win9x is unreliable when dealing with DC objects. It
*   is possible to get a bogus value (or potentially even lead to
*   instability in GDI) when a DC is not "present", which means its 16-bit
*   data has been "swapped out" into 32-bit. Most GDI functions handle
*   this, but GetObjectType does not. We call GetPixel to attempt to make
*   the DC present before calling GetObjectType.
*
* Arguments:
*
*   [IN] hdc - DC handle
*
* Return Value:
*
*   DC object type identifier on success or 0 on failure
*
* History:
*
*   01/31/2001 johnstep
*       Created it.
*
\**************************************************************************/

DWORD
GetDCType(
    IN HDC hdc
    )
{
#if defined(_X86_)
    if (!Globals::IsNt)
    {
        // Force the DC present here before attempting to inquire the type.

        GetPixel(hdc, 0, 0);

        DWORD type = GetObjectTypeWin9x(hdc);

        switch (type)
        {
            case OBJ_DC:
            case OBJ_METADC:
            case OBJ_MEMDC:
            case OBJ_ENHMETADC:
                break;

            default:
                // We got an unexpected object type, so return 0 to indicate
                // failure.

                type = 0;
        }

        return type;
    }
#else
    // We assume that this issue only matters on x86.

    ASSERT(Globals::IsNt);
#endif

    return GetObjectType(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*  + Fixed a problem in ShrinkToSize that caused elements to potentially
*    be lost.
*  8/16/2000 bhouse
*  + Changed cpacity growth to be exponential
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   count             - initial count
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize,
    UINT count
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));
    ASSERT(count <= allocSize);

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = count;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpMemcpy(InitialAllocation,DataBuffer,Count * eltSize);
        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*   exactSize   - no exponential growth, just add required amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements, BOOL exactSize)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    UINT capacityIncrement = newCount - Capacity;
    
    if (!exactSize)
    {
        capacityIncrement = max(capacityIncrement,
                                min(max(Capacity, kMinCapacityGrowth),
                                    kMaxCapacityGrowth));
    };

    UINT newCapacity = Capacity + capacityIncrement;

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(newCapacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, newCapacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed"));

        // Aid in tracking down memory failure cases not handled properly
#if 0
        ASSERT(FALSE);
#endif
        return OutOfMemory;
    }

    Capacity = newCapacity;
    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Allocates the buffer to detatch if it is the initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*   12/19/2000 asecchia - handle initial allocation by returning a copy.
*
\**************************************************************************/
    
GpStatus DynArrayImpl::DetachData(UINT eltSize, void **buffer)
{
    void *data = DataBuffer;

    // Copy the initial allocation if there is one - 
    // otherwise we simply use the DataBuffer.
    
    if (DataBuffer == InitialAllocation)
    {
        data = GpMalloc(Capacity*eltSize);

        if (NULL == data)
        {
            *buffer = NULL;
            return OutOfMemory;
        }
        
        if (Count)
        {
            GpMemcpy(data, DataBuffer, Count*eltSize);
        }
    }

    DataBuffer = NULL;
    Count = Capacity = 0;

    *buffer = data;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}



#ifdef USE_OBSOLETE_DYNSORTARRAY

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements
    )
{
    ASSERT(newElements>0 && index<=Count);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    // NOTE: assume T is a shallow data type, i.e.
    //  it doesn't contain nested references.
    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        (Count - index) * eltSize
        );

    void *newSpace = static_cast<BYTE *>(DataBuffer) + index * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0 && index<=Count);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemmove(
            static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
            static_cast<BYTE *>(DataBuffer) + index * eltSize,
            (Count - index) * eltSize
            );
        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + index * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Deletes multiple items from the array starting at the index'th position.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to delete the elements.
*   numElements - number of elements to delete
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    

GpStatus DynArrayImpl::DeleteMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT numElements
    )
{
    ASSERT(numElements>0 && (index+numElements)<=Count);

    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        static_cast<BYTE *>(DataBuffer) + (index + numElements) * eltSize,
        (Count - (index + numElements)) * eltSize
        );
    Count -= numElements;

    ShrinkToSize(eltSize);

    return Ok;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by GDI+ components are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\matrix.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Matrix.hpp
*
* Abstract:
*
*   Matrix used by GDI+ implementation
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef __MATRIX_HPP
#define __MATRIX_HPP

// Common constants used for conversions.

#define DEGREESPERRADIAN       57.2957795130823

//--------------------------------------------------------------------------
// Represents a 2D affine transformation matrix
//--------------------------------------------------------------------------

enum MatrixRotate
{
    MatrixRotateBy0,
    MatrixRotateBy90,
    MatrixRotateBy180,
    MatrixRotateBy270,
    MatrixRotateByOther
};

class GpMatrix
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagMatrix : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:

    // Default constructor - set to identity matrix

    GpMatrix()
    {
        Reset();
    }

    ~GpMatrix()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    // Reset the matrix object to identity

    VOID Reset()
    {
        M11 = M22 = 1;
        M12 = M21 = Dx = Dy = 0;
        Complexity = IdentityMask;
        SetValid(TRUE);
    }

    // Construct a GpMatrix object with the specified elements

    GpMatrix(REAL m11, REAL m12,
             REAL m21, REAL m22,
             REAL dx,  REAL dy)
    {
        SetValid(TRUE);

        M11 = m11;
        M12 = m12;
        M21 = m21;
        M22 = m22;
        Dx  = dx;
        Dy  = dy;

        Complexity = ComputeComplexity();
    }

    GpMatrix(REAL *elems)
    {
        SetValid(TRUE);

        M11 = elems[0];
        M12 = elems[1];
        M21 = elems[2];
        M22 = elems[3];
        Dx  = elems[4];
        Dy  = elems[5];

        Complexity = ComputeComplexity();
    }

    GpMatrix(const GpMatrix &matrix)
    {
        SetValid(TRUE);

        M11 = matrix.M11;
        M12 = matrix.M12;
        M21 = matrix.M21;
        M22 = matrix.M22;
        Dx  = matrix.Dx;
        Dy  = matrix.Dy;

        Complexity = matrix.Complexity;
    }

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // If the matrix came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpMatrix, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagMatrix) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Matrix");
        }
    #endif

        return (Tag == ObjectTagMatrix);
    }

    // Construct a GpMatrix object by inferring from a rectangle-to-
    // parallelogram mapping:

    GpMatrix(const GpPointF* destPoints, const GpRectF& srcRect);

    GpStatus InferAffineMatrix(const GpPointF* destPoints, const GpRectF& srcRect);

    GpStatus InferAffineMatrix(const GpRectF& destRect, const GpRectF& srcRect);

    GpMatrix* Clone()
    {
        return new GpMatrix(*this);
    }

    // Transform an array of points using the matrix v' = v M:
    //
    //                                  ( M11 M12 0 )
    //      (vx', vy', 1) = (vx, vy, 1) ( M21 M22 0 )
    //                                  ( dx  dy  1 )

    VOID Transform(GpPointF* points, INT count = 1) const;

    VOID Transform(
        const GpPointF*     srcPoints,
        GpPointF*           destPoints,
        INT                 count = 1
        ) const;

    VOID Transform(
        const GpPointF*     srcPoints,
        POINT *             destPoints,
        INT                 count = 1
        ) const;

    VOID TransformRect(GpRectF & rect) const;

    VOID VectorTransform(GpPointF* points, INT count = 1) const;

    // XTransform returns only the x-component result of a vector 
    // transformation:

    REAL XTransform(REAL x, REAL y)
    {
        return(x*M11 + y*M21 + Dx);
    }

    BOOL IsEqual(const GpMatrix * m) const
    {
        // Note that we can't assert here that the two cached
        // complexity's are equal, since it's perfectly legal to
        // have a cache complexity that indicates more complexity
        // than is actually there (such as the case of a sequence
        // of rotations that ends up back in an identity transform):

        // !!![andrewgo] This should probably be using an epsilon compare

        return((M11 == m->M11) &&
               (M12 == m->M12) &&
               (M21 == m->M21) &&
               (M22 == m->M22) &&
               (Dx  == m->Dx)  &&
               (Dy  == m->Dy));
    }

    REAL GetDeterminant() const
    {
        return (M11*M22 - M12*M21);
    }

    // Compare to a scaled value of epsilon used for matrix complexity
    // calculations.  Must scale maximum value of matrix members to be
    // in the right range for comparison.
    BOOL IsInvertible() const
    {
        return !IsCloseReal(0.0f, GetDeterminant());
    }

    GpStatus Invert();

    VOID Scale(REAL scaleX, REAL scaleY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Rotate(REAL angle, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Translate(REAL offsetX, REAL offsetY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Shear(REAL shearX, REAL shearY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID AppendScale(REAL scaleX, REAL scaleY)
    {
        M11 *= scaleX;
        M21 *= scaleX;
        M12 *= scaleY;
        M22 *= scaleY;
        Dx *= scaleX;
        Dy *= scaleY;

        Complexity = ComputeComplexity();
    }

    VOID AppendTranslate(REAL offsetX, REAL offsetY)
    {
        Dx += offsetX;
        Dy += offsetY;

        Complexity |= TranslationMask;
        AssertComplexity();
    }

    // Scale the entire matrix by the scale value

    static VOID ScaleMatrix(GpMatrix& m, const GpMatrix& m1,
                            REAL scaleX, REAL scaleY);

    static VOID MultiplyMatrix(GpMatrix& m, const GpMatrix& m1, const GpMatrix& m2);

    VOID Append(const GpMatrix& m)
    {
        MultiplyMatrix(*this, *this, m);
    }

    VOID Prepend(const GpMatrix& m)
    {
        MultiplyMatrix(*this, m, *this);
    }

    // Get/set matrix elements

    VOID GetMatrix(REAL* m) const
    {
        m[0] = M11;
        m[1] = M12;
        m[2] = M21;
        m[3] = M22;
        m[4] = Dx;
        m[5] = Dy;
    }

    // This is for metafiles -- we don't save the complexity in the metafile
    VOID WriteMatrix(IStream * stream) const
    {
        REAL    m[6];
        GetMatrix(m);
        stream->Write(m, 6 * sizeof(REAL), NULL);
    }

    VOID SetMatrix(const REAL* m)
    {
        M11 = m[0];
        M12 = m[1];
        M21 = m[2];
        M22 = m[3];
        Dx  = m[4];
        Dy  = m[5];

        Complexity = ComputeComplexity();
    }

    VOID SetMatrix(REAL m11, REAL m12,
             REAL m21, REAL m22,
             REAL dx,  REAL dy)
    {
        M11 = m11;
        M12 = m12;
        M21 = m21;
        M22 = m22;
        Dx  = dx;
        Dy  = dy;

        Complexity = ComputeComplexity();
    }
    
    VOID RemoveTranslation()
    {
        Dx = 0;
        Dy = 0;

        Complexity &= ~TranslationMask;
        AssertComplexity();
    }

    // Determine matrix complexity

    enum
    {
        IdentityMask        = 0x0000,
        TranslationMask     = 0x0001,
        ScaleMask           = 0x0002,
        RotationMask        = 0x0004,
        ShearMask           = 0x0008,
        ComplexMask         = 0x000f
    };

    INT GetComplexity() const
    {
        return Complexity;
    }

    MatrixRotate GetRotation() const;
    RotateFlipType AnalyzeRotateFlip() const;

    // Returns TRUE if the matrix does not have anything other than
    // translation and/or scale (and/or identity).  i.e. there is no rotation
    // or shear in the matrix.  Returns FALSE if there is a rotation or shear.

    BOOL IsTranslateScale() const
    {
        return (!(Complexity &
                  ~(GpMatrix::TranslationMask | GpMatrix::ScaleMask)));
    }

    BOOL IsIdentity() const
    {
        return (Complexity == IdentityMask);
    }

    BOOL IsTranslate() const
    {
        return ((Complexity & ~TranslationMask) == 0);
    }
    
    // Returns true if the matrix is a translate-only transform by an 
    // integer number of pixels.

    BOOL IsIntegerTranslate() const
    {
        return (IsTranslate() &&
                (REALABS(static_cast<REAL>(GpRound(Dx)) - Dx) <= PIXEL_EPSILON) &&
                (REALABS(static_cast<REAL>(GpRound(Dy)) - Dy) <= PIXEL_EPSILON));
    }

    BOOL IsMinification() const
    {
        return (IsTranslateScale() &&
                ((M11-1.0f < -REAL_EPSILON) || 
                 (M22-1.0f < -REAL_EPSILON)));    
    }
    // Returns true if there is any minification or if the transform involves
    // rotation/shear.
    
    BOOL IsRotateOrMinification() const
    {
        return ( ((Complexity & ~(ScaleMask | TranslationMask))!= 0) || 
                 IsMinification() );
    }

    BOOL IsRotateOrShear() const
    {
        return ( (Complexity & ~(ScaleMask | TranslationMask))!= 0);
    }

    BOOL IsShear() const
    {
        return ((Complexity & ShearMask) != 0);
    }
    
    REAL GetM11() const { return M11; }
    REAL GetM12() const { return M12; }
    REAL GetM21() const { return M21; }
    REAL GetM22() const { return M22; }
    REAL GetDx() const { return Dx; }
    REAL GetDy() const { return Dy; }

    // On checked builds, verify that the Matrix flags are correct.

#if DBG
    VOID AssertComplexity() const;
#else
    VOID AssertComplexity() const {}
#endif

protected:

    mutable GpLockable Lockable;

    REAL M11;
    REAL M12;
    REAL M21;
    REAL M22;
    REAL Dx;
    REAL Dy;
    INT Complexity;             // Bit-mask short-cut

    INT ComputeComplexity() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\matrix.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Matrix.cpp
*
* Abstract:
*
*   Implementation of matrix class
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it. 
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Infer an affine transformation matrix
*   from a rectangle-to-rectangle mapping
*
* Arguments:
*
*   [IN] destRect - Specifies the destination rectangle
*   [IN] srcRect  - Specifies the source rectangle
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/10/1999 DCurtis
*
\**************************************************************************/

GpStatus
GpMatrix::InferAffineMatrix(
    const GpRectF &     destRect,
    const GpRectF &     srcRect
    )
{
    REAL    srcLeft    = srcRect.X;
    REAL    srcRight   = srcRect.GetRight();
    REAL    srcTop     = srcRect.Y;
    REAL    srcBottom  = srcRect.GetBottom();
    
    REAL    destLeft   = destRect.X;
    REAL    destRight  = destRect.GetRight();
    REAL    destTop    = destRect.Y;
    REAL    destBottom = destRect.GetBottom();

    if ((srcLeft == srcRight) || (srcTop == srcBottom))
    {
        return InvalidParameter;
    }

    M12 = 0;
    M21 = 0;
    M11 = (destRight - destLeft) / (srcRight - srcLeft);
    M22 = (destBottom - destTop) / (srcBottom - srcTop);
    Dx  = destRight  - (M11 * srcRight);
    Dy  = destBottom - (M22 * srcBottom);

    Complexity = ComputeComplexity();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Infer an affine transformation matrix
*   from a rectangle-to-parallelogram mapping
*
* Arguments:
*
*   [IN] rect - Specifies the source rectangle
*   [IN] destPoints - Specifies the destination parallelogram
*       The array must contain at least 3 points.
*       destPoints[0] <=> top-left corner of the source rectangle
*       destPoints[1] <=> top-right corner
*       destPoints[2] <=> bottom-left corner
*
* Return Value:
*
*   Status code (error when 3 points for the destination
*   parallelogram is colinear).
*
* Reference:
*
*   Digital Image Warping
*   by George Wolberg
*   pp. 50-51
*
\**************************************************************************/

GpStatus
GpMatrix::InferAffineMatrix(
    const GpPointF* destPoints,
    const GpRectF& srcRect
    )
{
    REAL x0, y0, x1, y1, x2, y2;
    REAL u0, v0, u1, v1, u2, v2;
    REAL d;

    x0 = destPoints[0].X;
    y0 = destPoints[0].Y;
    x1 = destPoints[1].X;
    y1 = destPoints[1].Y;
    x2 = destPoints[2].X;
    y2 = destPoints[2].Y;

    u0 = srcRect.X;
    v0 = srcRect.Y;
    u1 = u0 + srcRect.Width;
    v1 = v0;
    u2 = u0;
    v2 = v0 + srcRect.Height;

    d = u0*(v1-v2) - v0*(u1-u2) + (u1*v2-u2*v1);

    if (REALABS(d) < REAL_EPSILON)
    {
        WARNING(("Colinear points in inferAffineMatrix"));
        return InvalidParameter;
    }
    
    d = TOREAL(1.0) / d;

    REAL t0, t1, t2;

    t0 = v1-v2;
    t1 = v2-v0;
    t2 = v0-v1;
    M11 = d * (x0*t0 + x1*t1 + x2*t2);
    M12 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u2-u1;
    t1 = u0-u2;
    t2 = u1-u0;
    M21 = d * (x0*t0 + x1*t1 + x2*t2);
    M22 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u1*v2-u2*v1;
    t1 = u2*v0-u0*v2;
    t2 = u2*v1-u1*v0;
    Dx  = d * (x0*t0 + x1*t1 + x2*t2);
    Dy  = d * (y0*t0 + y1*t1 + y2*t2);

    Complexity = ComputeComplexity();
    return Ok;
}

GpMatrix::GpMatrix(
    const GpPointF* destPoints,
    const GpRectF& srcRect
    )
{
    // !!!
    //  Should we throw an exception if inferAffineMatrix fails?

    SetValid(InferAffineMatrix(destPoints, srcRect) == Ok);
}

/**************************************************************************\
*
* Function Description:
* 
*   Invert the matrix (in place)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code (error if the matrix is not invertible)
*
* Reference:
*
*   Digital Image Warping
*   by George Wolberg
*   pp. 52-53
*
\**************************************************************************/

GpStatus
GpMatrix::Invert()
{
    if(IsIdentity())
    {
        // Invert the identity matrix - this is easy.
        return Ok;
    }
    
    if (!IsInvertible())
    {
        WARNING(("Matrix is non-invertible"));
        return InvalidParameter;
    }

    REAL t11, t12, t21, t22, tx, ty;
    REAL d = (M11*M22 - M12*M21);
    
    d = TOREAL(1.0) / d;

    t11 = M22;
    t12 = -M12;
    t21 = -M21;
    t22 = M11;
    tx  = M21*Dy - M22*Dx;
    ty  = M12*Dx - M11*Dy;

    M11 = d*t11;
    M12 = d*t12;
    M21 = d*t21;
    M22 = d*t22;
    Dx  = d*tx;
    Dy  = d*ty;

    Complexity = ComputeComplexity();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a scale matrix to the current matrix, i.e.
*
*         | scaleX   0    0 |
*     m = |   0    scaleY 0 |
*         |   0      0    1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   scaleX - scale factor along x-axis
*   scaleY - scale factor along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Scale(
    REAL scaleX,
    REAL scaleY,
    GpMatrixOrder order
    )
{
    if (order == MatrixOrderPrepend)
    {
        M11 *= scaleX;
        M12 *= scaleX;
        M21 *= scaleY;
        M22 *= scaleY;
    }
    else // Append
    {
        M11 *= scaleX;
        M21 *= scaleX;
        M12 *= scaleY;
        M22 *= scaleY;
        Dx *= scaleX;
        Dy *= scaleY;
    }

    // Scaling can magnify the error of other components.
    // So it is safest to always recompute the complexity always.

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a rotation matrix to the current matrix, i.e.
*
*         |  cos(angle) sin(angle) 0 |
*     m = | -sin(angle) cos(angle) 0 |
*         |      0           0     1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   angle - Specify the rotation angle
*   order - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define PI                  3.1415926535897932384626433832795
#define DEGREES_TO_RADIANS  (PI / 180.0)

VOID
GpMatrix::Rotate(
    REAL angle,
    GpMatrixOrder order
    )
{
    REAL s, c;
    REAL t11, t12, t21, t22;

    angle *= (REAL)DEGREES_TO_RADIANS;

    s = REALSIN(angle);
    c = REALCOS(angle);

    if (order == MatrixOrderPrepend) 
    {
        t11 = c*M11 + s*M21;
        t12 = c*M12 + s*M22;
        t21 = c*M21 - s*M11;
        t22 = c*M22 - s*M12;
    } 
    else // Append
    {
        t11 = c*M11 - s*M12;
        t12 = s*M11 + c*M12;
        t21 = c*M21 - s*M22;
        t22 = s*M21 + c*M22;

        REAL tx, ty;
        tx = c*Dx - s*Dy;
        ty = s*Dx + c*Dy;
        Dx = tx;
        Dy = ty;
    }

    M11 = t11; 
    M12 = t12; 
    M21 = t21;
    M22 = t22;

    // Rotation is very complex; we choose to simply recalculate the
    // complexity:

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a translation matrix to the current matrix, i.e.
*
*         |    1       0    0 |
*     m = |    0       1    0 |
*         | offsetX offsetY 1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   offsetX - offset along x-axis
*   offsetY - offset along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Translate(
    REAL offsetX,
    REAL offsetY,
    GpMatrixOrder order
    )
{
    if (order == MatrixOrderPrepend) 
    {
        Dx += (offsetX * M11) + (offsetY * M21);
        Dy += (offsetX * M12) + (offsetY * M22);
    }
    else // Append
    {
        Dx += offsetX;
        Dy += offsetY;
    }

    Complexity |= TranslationMask;
    AssertComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a shear matrix to the current matrix, i.e.
*
*         |   1    shearY 0 |
*     m = | shearX    1   0 |
*         |   0       0   1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   shearX - Amount to shear along x-axis
*   shearY - Amount to shear along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Shear(
    REAL shearX,
    REAL shearY,
    GpMatrixOrder order
    )
{
    REAL t;
    
    if (order == MatrixOrderPrepend) 
    {
        t = M11;
        M11 += shearY*M21;
        M21 += shearX*t;

        t = M12;
        M12 += shearY*M22;
        M22 += shearX*t;
    }
    else    // Append
    {
        t = M11;
        M11 += shearX*M12;
        M12 += shearY*t;

        t = M21;
        M21 += shearX*M22;
        M22 += shearY*t;

        t= Dx;
        Dx += shearX*Dy;
        Dy += shearY*t;
    }

    // Shear is very complex; we choose to simply recalculate the
    // complexity:

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Multiply two matrices and place the result in the 3rd one:
*       m = m1 * m2
*
* Arguments:
*
*   m - Destination matrix
*   m1, m2 - Source matrices
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   m can be the same matrix as m1 and/or m2.
*
\**************************************************************************/

VOID
GpMatrix::MultiplyMatrix(
    GpMatrix& m,
    const GpMatrix& m1,
    const GpMatrix& m2
    )
{
    REAL t11, t12, t21, t22, tx, ty;

    t11 = m1.M11 * m2.M11 + m1.M12 * m2.M21;
    t12 = m1.M11 * m2.M12 + m1.M12 * m2.M22;
    t21 = m1.M21 * m2.M11 + m1.M22 * m2.M21;
    t22 = m1.M21 * m2.M12 + m1.M22 * m2.M22;
    tx  = m1.Dx  * m2.M11 + m1.Dy  * m2.M21 + m2.Dx;
    ty  = m1.Dx  * m2.M12 + m1.Dy  * m2.M22 + m2.Dy;

    m.M11 = t11;
    m.M12 = t12;
    m.M21 = t21;
    m.M22 = t22;
    m.Dx  = tx;
    m.Dy  = ty;

    // Multiply can be very complex; we choose to simply recalculate the
    // complexity:

    m.Complexity = m.ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Scale the entire matrix by the scale value.
*
*   +--         --+      +--       --+
*   | M11  M12  0 |      | Sx  0   0 |
*   | M21  M22  0 |  x   | 0   Sy  0 |   => dest matrix
*   | Dx   Dy   1 |      | 0   0   1 |
*   +--         --+      +--       --+
*
* Arguments:
*
*   [OUT] m          - destination matrix
*   [IN]  m1         - source matrix
*   [IN]  scaleX     - dest = source * scaleValue
*   [IN]  scaleY     - dest = source * scaleValue
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/1/1999 DCurtis
*
\**************************************************************************/
VOID 
GpMatrix::ScaleMatrix(
    GpMatrix&           m, 
    const GpMatrix&     m1, 
    REAL                scaleX,
    REAL                scaleY
    )
{
    // !!! some kind of epsilon checking maybe?
    if ((scaleX != 1) || (scaleY != 1))
    {
        m.M11 = scaleX * m1.M11;
        m.M12 = scaleY * m1.M12;
        m.M21 = scaleX * m1.M21;
        m.M22 = scaleY * m1.M22;
        m.Dx  = scaleX * m1.Dx;
        m.Dy  = scaleY * m1.Dy;

        //!!! Since the scaling can magnify the other component,
        // it is safer to recompute the complexity.

        m.Complexity = m.ComputeComplexity();
/*
        if(m1.IsTranslateScale())
        {
            m.Complexity = m1.Complexity | ScaleMask;
        }
        else
        {
            // Scaling a rotation by different scale factors in x and y
            // results in a shear. Instead of working out the correct 
            // optimized complexity, we just recompute - this is a rotation
            // or shear already anyway.
            m.Complexity = m.ComputeComplexity();
        }
        m.AssertComplexity();
*/
    }
    else
    {
        m = m1;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Query for special types of transformation matrices
*
* Arguments:
*
* Return Value:
*
*   MatrixRotate enum indicating type of rotation
*
\**************************************************************************/

MatrixRotate 
GpMatrix::GetRotation() const
{
    // Check for no rotate.
    
    if(IsTranslateScale())
    {
        return MatrixRotateBy0;
    }
    
    // Check for Rotate by 90 degrees
    
    if (REALABS(M12) < REAL_EPSILON &&
        REALABS(M21) < REAL_EPSILON &&
        (M11 < 0.0f) && (M22 < 0.0f) )
    {
        return MatrixRotateBy180;
    }
    else if (REALABS(M11) < REAL_EPSILON &&
             REALABS(M22) < REAL_EPSILON)
    {
        if (M12 > 0.0f) 
        {
            return MatrixRotateBy90;
        }
        else
        {
            return MatrixRotateBy270;
        }
    }

    return MatrixRotateByOther;
}

/**************************************************************************\
*
* Function Description:
*
*   Query for special types of transformation matrices.
*   This will return a RotateFlipType for the rotation. If the rotation
*   is Identity or an arbitrary non supported format, return value is
*   RotateNoneFlipNone
*
\**************************************************************************/

RotateFlipType GpMatrix::AnalyzeRotateFlip() const 
{
    // Early out the identity case because we have a flag for it in the matrix.
    
    if(IsIntegerTranslate())
    {
        return RotateNoneFlipNone;
    }
    
    // Main Diagonal is zero.
    
    if( (REALABS(M11) < REAL_EPSILON) &&             // M11 == 0.0
        (REALABS(M22) < REAL_EPSILON) )              // M22 == 0.0
    {
        // Rotate 270 or Rotate 90 + Flip X
        
        if( REALABS(M21-1) < REAL_EPSILON )          // M21 == 1.0
        {
            if( REALABS(M12-1) < REAL_EPSILON )      // M12 == 1.0
            {
                return Rotate90FlipX;
            }
            if( REALABS(M12+1) < REAL_EPSILON )      // M21 == -1.0
            {
                return Rotate270FlipNone;
            }
        }
        
        // Rotate 90 or Rotate 270 + Flip X
        
        if( REALABS(M21+1) < REAL_EPSILON )          // M21 == -1.0
        {
            if( REALABS(M12-1) < REAL_EPSILON )      // M12 == 1.0
            {
                return Rotate90FlipNone;
            }
            if( REALABS(M12+1) < REAL_EPSILON )      // M12 == -1.0
            {
                return Rotate270FlipX;
            }
        }
    }
    
    // Main Diagonal matrix (non zero).
    
    if( (REALABS(M12) < REAL_EPSILON) &&             // M12 == 0.0
        (REALABS(M21) < REAL_EPSILON) )              // M21 == 0.0
    {
        // Identity or Flip Y
        
        if( REALABS(M11-1) < REAL_EPSILON )          // M11 == 1.0
        {
            // Identity is handled already.
            // if( REALABS(M22-1) < REAL_EPSILON )   // M22 == 1.0
            
            if( REALABS(M22+1) < REAL_EPSILON )      // M22 == -1.0
            {
                return RotateNoneFlipY;
            }
        }
        
        // Flip X or Rotate 180
        
        if( REALABS(M11+1) < REAL_EPSILON )          // M11 == -1.0
        {
            if( REALABS(M22-1) < REAL_EPSILON )      // M22 == 1.0
            {
                return RotateNoneFlipX;
            }
            if( REALABS(M22+1) < REAL_EPSILON )      // M22 == -1.0
            {
                return Rotate180FlipNone;
            }
        }
    }
    
    // We couldn't find a rotate/flip type.
    
    return RotateNoneFlipNone;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix
*
* Arguments:
*
*   points - Array of points to be transformed
*       The resulting points are stored back into the same array
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    GpPointF* points,
    INT count
    ) const
{
    if (count <= 0)
        return;

    ASSERT(points != NULL);

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();

    if(IsIdentity())
    {
        return;
    }
    else if(IsTranslate())
    {
        do {
            points->X += Dx;
            points->Y += Dy;

        } while (points++, --count != 0);
    }
    else if(IsTranslateScale())
    {
        do {
            points->X = points->X * M11 + Dx;
            points->Y = points->Y * M22 + Dy;

        } while (points++, --count != 0);
    }
    else 
    {
        do {
            REAL x = points->X;
            REAL y = points->Y;

            points->X = (M11 * x) + (M21 * y) + Dx;
            points->Y = (M12 * x) + (M22 * y) + Dy;

        } while (points++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   with the destination an array of integer POINTS.
*
* Arguments:
*
*   srcPoints - Array of REAL points to be transformed
*
*   destPoints - Array of REAL points to store the results
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    const GpPointF*     srcPoints,
    GpPointF*           destPoints,
    INT                 count
    ) const
{
    if (count <= 0)
        return;

    ASSERT((srcPoints != NULL) && (destPoints != NULL));

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();
    
    if(IsIdentity())
    {
        GpMemcpy(destPoints, srcPoints, count*sizeof(GpPointF));
    }
    else if (IsTranslate())
    {
        do {
            destPoints->X = srcPoints->X + Dx;
            destPoints->Y = srcPoints->Y + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else if (IsTranslateScale())
    {
        do {
            destPoints->X = srcPoints->X * M11 + Dx;
            destPoints->Y = srcPoints->Y * M22 + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else 
    {
        do {
            REAL x = srcPoints->X;
            REAL y = srcPoints->Y;

            destPoints->X = (M11 * x) + (M21 * y) + Dx;
            destPoints->Y = (M12 * x) + (M22 * y) + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   with the destination an array of integer POINTS.
*
* Arguments:
*
*   srcPoints - Array of REAL points to be transformed
*
*   destPoints - Array of INT points to store the results
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    const GpPointF*     srcPoints,
    POINT *             destPoints,
    INT                 count
    ) const
{
    if (count <= 0)
        return;

    ASSERT((srcPoints != NULL) && (destPoints != NULL));

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();
    
    // NOTE: This code should call RasterizeCeiling() to be consistent
    // with our aliased line drawing rasterizer.  

    if (IsTranslate())
    {
        do {
            destPoints->x = RasterizerCeiling(srcPoints->X + Dx);
            destPoints->y = RasterizerCeiling(srcPoints->Y + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else if (IsTranslateScale())
    {
        do {
            destPoints->x = RasterizerCeiling(srcPoints->X * M11 + Dx);
            destPoints->y = RasterizerCeiling(srcPoints->Y * M22 + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else 
    {
        do {
            REAL x = srcPoints->X;
            REAL y = srcPoints->Y;

            destPoints->x = RasterizerCeiling((M11 * x) + (M21 * y) + Dx);
            destPoints->y = RasterizerCeiling((M12 * x) + (M22 * y) + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a rect and return the resulting rect.
*   This only works if the matrix is a translate-scale matrix, but we're
*   assuming here that you've already checked for that.
*
* Arguments:
*
*   [IN/OUT]  rect - the rect to transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/5/1999 DCurtis
*
\**************************************************************************/

VOID
GpMatrix::TransformRect(
    GpRectF &   rect
    ) const
{
    if (IsIdentity())
        return;

    // NTRAID#NTBUG9-407211-2001-05-31-gillessk "Bad assert triggers when it shouldn't" 
    // loose the condition to allow rotation by multiple of 90 degrees
    ASSERT(IsTranslateScale() || (GetRotation()==MatrixRotateBy90) || (GetRotation()==MatrixRotateBy270));

    REAL    xMin = rect.X;
    REAL    yMin = rect.Y;
    REAL    xMax = xMin + rect.Width;
    REAL    yMax = yMin + rect.Height;
    REAL    x;
    
    x = xMin;
    xMin = (M11 * x) + (M21 * yMin) + Dx;
    yMin = (M12 * x) + (M22 * yMin) + Dy;

    x = xMax;
    xMax = (M11 * x) + (M21 * yMax) + Dx;
    yMax = (M12 * x) + (M22 * yMax) + Dy;

    if (xMin > xMax)
    {
        x    = xMin;
        xMin = xMax;
        xMax = x;
    }

    if (yMin > yMax)
    {
        x    = yMin;
        yMin = yMax;
        yMax = x;
    }

    rect.X      = xMin;
    rect.Y      = yMin;
    rect.Width  = xMax - xMin;
    rect.Height = yMax - yMin;    
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   ignoring translation.
*
* Arguments:
*
*   points - Array of points to be transformed
*       The resulting points are stored back into the same array
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::VectorTransform(
    GpPointF* points,
    INT count
    ) const
{
    if (IsIdentity())
        return;

    REAL x;

    for (INT i=0; i < count; i++)
    {
        x = points[i].X;
        points[i].X = M11*x + M21*points[i].Y;
        points[i].Y = M12*x + M22*points[i].Y;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine matrix complexity.  
*
*   NOTE: This function is fairly expensive.  It shouldn't be called
*         after every matrix operation.  (If it was, I would argue
*         that's a good reason to get rid of 'Complexity' entirely,
*         which is intended as a short-cut and should not be expensive
*         to keep updated.)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Returns a bitmask representing the matrix complexity.
*
\**************************************************************************/

INT
GpMatrix::ComputeComplexity() const
{
    INT complexity = ComplexMask;

    REAL maxM = max(
        max(REALABS(M11), REALABS(M22)),
        max(REALABS(M12), REALABS(M21)));
    REAL epsilon = CPLX_EPSILON*maxM;

    // M12==0 && M21==0

    if ((REALABS(M12) < epsilon) && (REALABS(M21) < epsilon))
    {
        complexity &= ~(ShearMask | RotationMask);

        // M11==1 && M22==1

        if ((REALABS(M11 - 1.0f) < CPLX_EPSILON) && 
            (REALABS(M22 - 1.0f) < CPLX_EPSILON))
        {
            complexity &= ~ScaleMask;
        }
    }
    else
    {
        // Check if this is a pure rotation

        // M11==M22 && M12==-M21

        if((REALABS(M11 - M22) < epsilon) && 
           (REALABS(M12 + M21) < epsilon))
        {
            complexity &= ~ShearMask;
        
            // M11*M11+M12*M12==1

            if (REALABS(M11*M11 + M12*M12 - 1.0f) < CPLX_EPSILON)
            {
                complexity &= ~ScaleMask;
            }
        }
    }

    // Dx==0 && Dy==0

    // We don't know the real scaling of the translational part.
    // So we use the exact value.

    //    if ((REALABS(Dx) < CPLX_EPSILON) && (REALABS(Dy) < CPLX_EPSILON))
    if(Dx == 0 && Dy == 0)
    {
        complexity &= ~TranslationMask;
    }

    return(complexity);
}

/**************************************************************************\
*
* Function Description:
*
*   Verify the matrix complexity.
*
\**************************************************************************/

#if DBG

VOID 
GpMatrix::AssertComplexity() const
{
    INT computed = ComputeComplexity();

    // The new complexity can be less complex than the old 
    // (a sequence or rotations may end up with an identity
    // transform, for example), but that's okay - complexity
    // is intended as a short cut, and as such keeping it
    // updated sholud be light weight.
    //
    // But the calculated complexity SHOULD NOT be more complex
    // than the old - if it is, we have a bug someplace -
    // we're updating the matrix but not the complexity...
    //
    // Note: under certain circumstances - such as excessive 
    // repeated matrix appending or scaling up by very large 
    // factors - we could end up with a more complex computed
    // complexity just due to rounding errors.
    // Under these circumstances, the cause should be determined
    // and most likely the algorithm re-evaluated because when
    // rounding errors are propagated to such large proportions,
    // no operations are going to have predictable results anyway.

    ASSERTMSG((Complexity & computed) == computed, 
        (("Matrix more complex than cached Complexity indicates")));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\monitors.inc ===
//
// This file is used to generate both the monitor enumeration and
// the set of strings that correspond to each enumeration.
//
// This file is included in both monitors.cpp and monitors.hpp.  In
// monitors.cpp, we define the strings in the strin array gStaticMonitorNames.
// In monitors.hpp, we define the enumerations.
//
// This file should contain a line for each enumeration in the form:
//      MONITOR(monitor_name),
//
//


#ifndef __MONITORS_CPP__ 
#define MONITOR(x) k##x##Monitor
#else
#define MONITOR(x) #x

// Flatapi 

#endif
#include "..\flat\flatapi.inc"

MONITOR(FlatApiSentinel),

// Internal

MONITOR(GpJpegDecoder_Decode),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\globals.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains all the globals used by GDI+.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef __GLOBALS_HPP
#define __GLOBALS_HPP

class GpDevice;
class GpPrinterDevice;
class DpBitmap;
class DpDriver;
class DriverMulti;
class GpFontTable;
class GpFontLink;
class GpFontFile;
class GpDeviceList;

// Private DirectDraw export:

typedef HRESULT (WINAPI *DIRECTDRAWCREATEEXFUNCTION)(GUID*,
                                             VOID*,
                                             REFIID,
                                             IUnknown*);

typedef HRESULT (WINAPI *GETDDRAWSURFACEFROMDCFUNCTION)(HDC,
                                                        LPDIRECTDRAWSURFACE*,
                                                        HDC*);


typedef HRESULT (WINAPI *DIRECTDRAWENUMERATEEXFUNCTION)(LPDDENUMCALLBACKEXA,
                                                        LPVOID,
                                                        DWORD);

// GDI exports

typedef BOOL  (WINAPI *EXTTEXTOUTFUNCTION) (    HDC,
                                                int,
                                                int,
                                                UINT,
                                                CONST RECT *,
                                                LPCWSTR,
                                                UINT,
                                                CONST INT *);
// Private NT GDI export:

typedef BOOL (APIENTRY *GDIISMETAPRINTDCFUNCTION)(HDC);

// Win98/NT5 only stuff:

typedef WINUSERAPI BOOL (WINAPI *GETMONITORINFOFUNCTION)(HMONITOR,
                                                         LPMONITORINFOEXA);


typedef WINUSERAPI BOOL (WINAPI *ENUMDISPLAYMONITORSFUNCTION)(HDC,
                                                              LPCRECT,
                                                              MONITORENUMPROC,
                                                              LPARAM);

typedef WINUSERAPI BOOL (WINAPI *ENUMDISPLAYDEVICESFUNCTION)(LPCSTR,
                                                             DWORD,
                                                             PDISPLAY_DEVICEA,
                                                             DWORD);

typedef WINUSERAPI HWINEVENTHOOK (WINAPI *SETWINEVENTHOOKFUNCTION)(DWORD,
                                                                   DWORD,
                                                                   HMODULE,
                                                                   WINEVENTPROC,
                                                                   DWORD,
                                                                   DWORD,
                                                                   DWORD);

typedef WINUSERAPI BOOL (WINAPI *UNHOOKWINEVENTFUNCTION)(HWINEVENTHOOK);

typedef WINUSERAPI BOOL (WINAPI *GETWINDOWINFOFUNCTION)(HWND, PWINDOWINFO);

typedef WINUSERAPI HWND (WINAPI *GETANCESTORFUNCTION)(HWND, UINT);



typedef USHORT (*CAPTURESTACKBACKTRACEFUNCTION)(ULONG, ULONG, PVOID *, PULONG);


// Lazy load of DCI:

typedef int (WINAPI *DCICREATEPRIMARYFUNCTION)(HDC, LPDCISURFACEINFO FAR *);

typedef void (WINAPI *DCIDESTROYFUNCTION)(LPDCISURFACEINFO);

typedef DCIRVAL (WINAPI *DCIBEGINACCESSFUNCTION)(LPDCISURFACEINFO, int, int, int, int);

typedef void (WINAPI *DCIENDACCESSFUNCTION)(LPDCISURFACEINFO);


// Winspool.drv export ('A' version only)

typedef BOOL (WINAPI *WINSPOOLGETPRINTERDRIVERFUNCTION)(HANDLE hPrinter,
                                                        LPSTR pEnvironment,
                                                        DWORD Level,
                                                        LPBYTE pDriverInfo,
                                                        DWORD vbBuf,
                                                        LPDWORD pcbNeeded);

// Most of our globals.
// There are additions to the Globals namespace in engine\entry\initialize.cpp
// See also, globals.cpp.

namespace Globals
{
    extern BOOL IsNt;                   // Are we running on any version of NT?

    extern BOOL IsWin95;                // Neither NT nor Win98?
    extern BOOL VersionInfoInitialized; // Wheter the version info has been
                                        //   initialized or not.
    extern OSVERSIONINFOA OsVer;        // More specific OS Version info
    extern UINT ACP;                    // Active Code Page
    extern GpDevice *DesktopDevice;     // The device representing the entire
                                        //   desktop
    extern GpDeviceList *DeviceList;    // List of devices that we know about
    extern DpBitmap *DesktopSurface;    // A surface representing the desktop
    extern DpDriver *DesktopDriver;     // The driver representing desktop
                                        //   drawing
    extern DpDriver *EngineDriver;      // The virtual driver representing only
                                        //   GDI+ Eng drawing functionality
    extern DpDriver *GdiDriver;         // The virtual driver that draws using
                                        //   only GDI routines
    extern DpDriver *D3DDriver;         // The virtual driver that draws using
                                        //   only D3D/DD routines
    extern DpDriver *InfoDriver;        // The virtual driver that doesn't draw
                                        //   anything -- used for metafiles
    extern DpDriver *MetaDriver;        // The virtual driver that draws using
                                        //   only GDI routines for Metafiles

    extern BOOL DirectDrawInitialized;  // Flag indicating whether diret draw
                                        //   and direct 3D related globals have
                                        //   been initialized.
    extern BOOL DirectDrawInitAttempted;// Flag indicating whether we have tried
                                        //   to initialized direct draw and
                                        //   direct 3d globals
    extern HINSTANCE DdrawHandle;       // DirectDraw DLL handle
    extern IDirectDraw7 * DirectDraw;   // Pointer to the direct draw interface
                                        //   for the desktop
    extern IDirect3D7 * Direct3D;       // Pointer to the direct 3D interface
                                        //   for the desktop
    extern DIRECTDRAWCREATEEXFUNCTION DirectDrawCreateExFunction;
                                        // Pointer to the direct draw static
                                        //   function used for creation of the
                                        //   direct draw interface
    extern DIRECTDRAWENUMERATEEXFUNCTION DirectDrawEnumerateExFunction;
                                        // Pointer to the direct draw
                                        //   enumeration function
    extern GETDDRAWSURFACEFROMDCFUNCTION GetDdrawSurfaceFromDcFunction;
                                        // Pointer to private DirectDraw
                                        //   function for getting a DDraw
                                        //   surface from an HDC
    extern EXTTEXTOUTFUNCTION ExtTextOutFunction;
                                        // Pointer to either ExtTextOutA
                                        // or ExtTextOutW. depends on IsNt
    extern GDIISMETAPRINTDCFUNCTION GdiIsMetaPrintDCFunction;
                                        // Pointer to appropriate function for
                                        //   determining if a metafile DC is
                                        //   actually a metafiled printer DC
                                        //   (Points to an internal GDI
                                        //   function on NT, and to our own
                                        //   routine on Win9x)
    extern GETMONITORINFOFUNCTION GetMonitorInfoFunction;
                                        // Pointer to GetMonitorInfo used
                                        //   used for getting information
                                        //   for a monitor identified by a
                                        //   HMONITOR.
    extern ENUMDISPLAYMONITORSFUNCTION EnumDisplayMonitorsFunction;
                                        // Pointer to EnumDisplayMonitors
                                        //   function used for enumerating all
                                        //   of the monitors of a multi-mon
                                        //   capable Win32 platform.
    extern ENUMDISPLAYDEVICESFUNCTION EnumDisplayDevicesFunction;
                                        // Pointer to EnumDisplayDevices
                                        //   function used for enumerating all
                                        //   of the display devices of a
                                        //   multi-mon capable Win32 platform.
    extern HMODULE DcimanHandle;
    extern DCICREATEPRIMARYFUNCTION DciCreatePrimaryFunction;
    extern DCIDESTROYFUNCTION DciDestroyFunction;
    extern DCIBEGINACCESSFUNCTION DciBeginAccessFunction;
    extern DCIENDACCESSFUNCTION DciEndAccessFunction;
                                        // Pointer to all functions imported
                                        //   from DCI, so that we can
                                        //   delay load DCIMAN32.DLL for perf
                                        //   reasons
    extern CAPTURESTACKBACKTRACEFUNCTION CaptureStackBackTraceFunction;
                                        // Pointer to RtlCaptureStackBackTrace
                                        //   function (if available)
    
    extern GETWINDOWINFOFUNCTION GetWindowInfoFunction;
                                        // Pointer to User32's GetWindowInfo
                                        //   function (if available)
    extern GETANCESTORFUNCTION GetAncestorFunction;
                                        // Pointer to User32's GetAncestor
                                        //   function (if available)
    extern SETWINEVENTHOOKFUNCTION SetWinEventHookFunction;
                                        // Pointer to User32's SetWinEventHook
                                        //   function (if available)
    extern UNHOOKWINEVENTFUNCTION UnhookWinEventFunction;
                                        // Pointer to User32's UnhookWinEvent
                                        //   function (if available)
    extern BOOL IsMoveSizeActive;       // TRUE if we're running on NT and our
                                        //   window event hook has indicated
                                        //   that the user is currently dragging
                                        //   windows around
    extern HRGN CachedGdiRegion;        // Cached region for random calls that
                                        //   require a region.  The contents
                                        //   aren't important; rather its
                                        //   existence is.  This handle must
                                        //   always be non-NULL
    
    // On the NT codebase, the CreateDC(DISPLAY, NULL, NULL, NULL) call has
    // thread affinity. This means that the desktop DC would go away if the
    // thread which called GdiplusStartup terminated even if we were still 
    // using it.
    // On NT we create an Info DC which has process affinity. Rendering onto
    // an Info DC is not supported but that's ok because we always create
    // DriverMulti on NT - and therefore always render on a monitor specific
    // DC instead.
    // Win9x does not have the thread affinity problem and we'd use an IC
    // if it weren't for the fact that win95 doesn't have EnumDisplayMonitors
    // and hence uses DriverGdi instead of DriverMulti - rendering directly
    // on the DesktopIc
    // see RAID:
    // 301407 GDI+ Globals::DesktopDC has thread affinity
    // 312342 CreateDC("Display", NULL, NULL, NULL) has thread affinity.
    // and gdiplus/test/multithread for a test app that exposes this problem.
    
    // I.e. Don't render on this DC - it won't work. It's for informational 
    // purposes only.
    
    extern HDC DesktopIc;               // Handle to the global desktop DC
    
    
    extern REAL DesktopDpiX;            // DpiX of desktop HDC (from GetDeviceCaps)
    extern REAL DesktopDpiY;            // DpiY of desktop HDC (from GetDeviceCaps)

    extern GpInstalledFontCollection *FontCollection;   // Table of loaded fonts
    extern GpFontLink *FontLinkTable ;  // Linked fonts Table
    extern GpFontFamily **SurrogateFontsTable;         // Surrogate font fallback family table

    extern GpCacheFaceRealizationList *FontCacheLastRecentlyUsedList; // list of last recently used CacheFaceRealization

    extern WCHAR* FontsDirW;            // Fonts dir needed by addfontresource (Nt)
    extern CHAR*  FontsDirA;            // Fonts dir needed by addfontresource (Win9x)

    extern WCHAR* FontsKeyW;            // Registry key for fonts (Nt)
    extern CHAR*  FontsKeyA;            // Registry key for fonts (Win9x)
    extern BOOL   TextCriticalSectionInitialized;  // has the text critical section been initialized
    extern CRITICAL_SECTION TextCriticalSection;  // global critical section that protect all the text calls
                                        // claudebe 4/5/00 at this time we want to protect globally as opposed
                                        // to protect separately font cache, font realization access like in GDI
                                        // the idea is that we don't expect to have a huge amount of threads in parallel as in GDI
                                        // so performance is considered as acceptable for GDI+
                                        // if we want to change it the other way, look for commented code with
                                        // FontFileCacheCritSection, FontFamilyCritSection, FaceRealizationCritSection, g_cstb, csCache and ghsemTTFD
    extern TextRenderingHint CurrentSystemRenderingHint;   // current system text rendering mode, used to implement the TextRenderingHintSystemDefault mode
    extern BOOL CurrentSystemRenderingHintInvalid;  // Should we re-read CurrentSystemRenderingHint user settings?


    extern USHORT LanguageID;           // LangID needed by ttfd, for US = 0x0409

    extern LONG_PTR LookAsideCount;
    extern BYTE* LookAsideBuffer;
    extern INT LookAsideBufferSize;

    extern UINT PaletteChangeCount;
    extern COLORREF SystemColors[];

    extern HANDLE hCachedPrinter;       // for postscript cache printer handle
    extern INT CachedPSLevel;           //   + level
            // !!![ericvan] We should use: CHAR CachedPrinterName[CCHDEVICENAME];

    extern HINSTANCE WinspoolHandle;
    extern WINSPOOLGETPRINTERDRIVERFUNCTION GetPrinterDriverFunction;

    extern HMODULE UniscribeDllModule;      // Loaded Uniscribe (usp10.dll) module

    extern IntMap<BYTE> *NationalDigitCache; // National Digit Substitution cache
    extern BOOL UserDigitSubstituteInvalid;  // Should we re-read digit sub user settings?

    // clear type lookup tables

    // filtered counts of RGB
    struct F_RGB
    {
        BYTE kR;
        BYTE kG;
        BYTE kB;
        BYTE kPadding;
    };

    extern const F_RGB * gaOutTable;
    extern const BYTE FilteredCTLut[];
    extern const BYTE TextContrastTableIdentity[256];
    typedef const BYTE TEXT_CONTRAST_TABLES[12][256];
    extern TEXT_CONTRAST_TABLES TextContrastTablesDir; // 1.1 ... 2.2
    extern TEXT_CONTRAST_TABLES TextContrastTablesInv; // 1.1 ... 2.2

    extern GpPath * PathLookAside;
    extern GpMatrix * MatrixLookAside;
    extern GpPen * PenLookAside;

    // Is this instance of gdiplus running in terminal server session space.

    extern BOOL IsTerminalServer;

    // For an explanation of GDIPLUS_MIRROR_DRIVER_NO_DCI, see
    // pdrivers\drivermulti.cpp or bug #92982.
    // TRUE if any mirror driver is active on the system.   
    extern BOOL IsMirrorDriverActive;

    // User-supplied debug event reporting callback
    extern DebugEventProc UserDebugEventProc;

    //// START Synchronized under GdiplusStartupCriticalSection
        extern HANDLE ThreadNotify;         // Thread handle for hidden window notify
        extern DWORD ThreadId;              // Thread ID for hidden window notify

        // These two are used by GdiplusStartup and GdiplusShutdown
        extern ULONG_PTR LibraryInitToken;
        extern INT LibraryInitRefCount;

        // This is used by NotificationStartup and NotificationShutdown.

        extern ULONG_PTR NotificationInitToken;

        // The token of the module which owns the hidden window. 
        // See "NotificationModuleToken" below.

        extern ULONG_PTR HiddenWindowOwnerToken;
    //// END Synchronized under GdiplusStartupCriticalSection (on GDIPLUS.DLL)

    //// START Synchronized under BackgroundThreadCriticalSection:
        extern HANDLE ThreadQuitEvent;      // Event object for killing the background thread
        
        extern HWND HwndNotify;             // HWND for hidden window notify
        extern ATOM WindowClassAtom;        // Atom for our "notification window" class
        extern HWINEVENTHOOK WinEventHandle;// Handle to our window event hook
    //// END Synchronized under BackgroundThreadCriticalSection:
        
        extern BOOL g_fAccessibilityPresent;
        extern UINT g_nAccessibilityMessage;// Window message to disable accessibility messages.
};

// For the variable HiddenWindowOwnerToken, we have 2 values with special
// meanings:
//
// NotificationModuleTokenNobody: No module currently owns the hidden window.
//     i.e. we're waiting for the first initializer to call NotificationStartup.
// NotificationModuleTokenGdiplus: GDI+ itself owns the hidden window - i.e.
//     the background thread is running.
 
enum NotificationModuleToken
{
    NotificationModuleTokenNobody,
    NotificationModuleTokenGdiplus,
    NotificationModuleTokenMax = NotificationModuleTokenGdiplus
};

BOOL InitializeDirectDrawGlobals(void);

#endif // __GLOBALS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\globals.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   This is where all the global variables in the Globals namespace
*   are actually declared.
*
* Created:
*
*   11/25/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Data Description:
*
*   This namespace contains all (most?) of the GDI+ global state.
*   See the header file 'globals.hpp' for comments.
*
*   Note that all global data are initialized automatically to zero.
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

namespace Globals
{
    BOOL IsNt;
    BOOL RuntimeInitialized;

    GpPath *    PathLookAside;
    GpMatrix *  MatrixLookAside;
    GpPen *     PenLookAside;

    BOOL IsWin95;
    BOOL VersionInfoInitialized;
    OSVERSIONINFOA OsVer;
    UINT ACP;
    GpDevice *DesktopDevice;
    GpDeviceList *DeviceList;
    DpBitmap *DesktopSurface;
    DpDriver *DesktopDriver;
    DpDriver *EngineDriver;
    DpDriver *GdiDriver;
    DpDriver *D3DDriver;
    DpDriver *InfoDriver;
    DpDriver *MetaDriver;
    BOOL DirectDrawInitialized;
    BOOL DirectDrawInitAttempted;
    HINSTANCE DdrawHandle;
    IDirectDraw7 *DirectDraw;
    IDirect3D7 *Direct3D;
    DIRECTDRAWCREATEEXFUNCTION DirectDrawCreateExFunction;
    DIRECTDRAWENUMERATEEXFUNCTION DirectDrawEnumerateExFunction;
    EXTTEXTOUTFUNCTION ExtTextOutFunction;
    GETDDRAWSURFACEFROMDCFUNCTION GetDdrawSurfaceFromDcFunction;
    GDIISMETAPRINTDCFUNCTION GdiIsMetaPrintDCFunction;
    GETMONITORINFOFUNCTION GetMonitorInfoFunction;
    ENUMDISPLAYMONITORSFUNCTION EnumDisplayMonitorsFunction;
    ENUMDISPLAYDEVICESFUNCTION EnumDisplayDevicesFunction;
    HMODULE DcimanHandle;
    DCICREATEPRIMARYFUNCTION DciCreatePrimaryFunction;
    DCIDESTROYFUNCTION DciDestroyFunction;
    DCIBEGINACCESSFUNCTION DciBeginAccessFunction;
    DCIENDACCESSFUNCTION DciEndAccessFunction;
    GETWINDOWINFOFUNCTION GetWindowInfoFunction;
    GETANCESTORFUNCTION GetAncestorFunction;
    SETWINEVENTHOOKFUNCTION SetWinEventHookFunction;
    UNHOOKWINEVENTFUNCTION UnhookWinEventFunction;
    HWINEVENTHOOK WinEventHandle;
    CAPTURESTACKBACKTRACEFUNCTION CaptureStackBackTraceFunction;
    BOOL IsMoveSizeActive;
    HRGN CachedGdiRegion;
    HDC DesktopIc;
    REAL DesktopDpiX;
    REAL DesktopDpiY;
    GpInstalledFontCollection *FontCollection;
    GpCacheFaceRealizationList *FontCacheLastRecentlyUsedList;
    GpFontLink *FontLinkTable = NULL;
    GpFontFamily **SurrogateFontsTable = (GpFontFamily **) -1;
    WCHAR *FontsDirW;
    CHAR *FontsDirA;
    USHORT LanguageID;
    HWND HwndNotify;
    HANDLE ThreadNotify = NULL;
    DWORD ThreadId;
    ATOM WindowClassAtom;
    BOOL InitializeOleSuccess;
    LONG_PTR LookAsideCount;
    BYTE* LookAsideBuffer;
    INT LookAsideBufferSize = 0x7FFFFFFF;
    UINT PaletteChangeCount = 1;
    COLORREF SystemColors[20];
    HINSTANCE WinspoolHandle;
    WINSPOOLGETPRINTERDRIVERFUNCTION GetPrinterDriverFunction;
    HANDLE hCachedPrinter;
    INT CachedPSLevel = -1;
    WCHAR *FontsKeyW = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    CHAR  *FontsKeyA =  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts";
    
    BOOL TextCriticalSectionInitialized = FALSE;
    CRITICAL_SECTION TextCriticalSection;
    TextRenderingHint CurrentSystemRenderingHint;

    HMODULE UniscribeDllModule;

    IntMap<BYTE> *NationalDigitCache;
    BOOL UserDigitSubstituteInvalid;
    BOOL CurrentSystemRenderingHintInvalid;

    BOOL IsTerminalServer = FALSE;
    
    // GillesK: See bug NTBUG9 #409304
    // We cannot use DCI on Mirror Drivers since that doesn't get remoted.
    BOOL IsMirrorDriverActive = FALSE;

    ULONG_PTR LibraryInitToken = 0;
    INT LibraryInitRefCount = 0;
    ULONG_PTR HiddenWindowOwnerToken = NotificationModuleTokenNobody;
    ULONG_PTR NotificationInitToken = 0;
    HANDLE ThreadQuitEvent = NULL;

    BOOL g_fAccessibilityPresent = FALSE;
    UINT g_nAccessibilityMessage = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\monitors.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definition for the GpMonitor class.
*
* WARNINGS:
*
*   This code should not use anything which is initialized in GdiplusStartup,
*   because it may be called before GdiplusStartup, or after GdiplusShutdown.
*   This includes ::new and ::delete.
*
*   This code is not thread-safe. It doesn't even detect itself being used
*   in multiple threads. It shouldn't crash, but the timing results could be
*   incorrect.
*
* Revision History:
*
*   09/30/2000 bhouse
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"


#undef MONITOR
#define __MONITORS_CPP__
const char * gStaticMonitorNames[kNumStaticMonitors+1] = {
#include "monitors.inc"
    ""
};

namespace Globals
{
    GpMonitors * Monitors;
};

void GpMonitors::Clear(void)
{
    for(int i = 0; i < kNumStaticMonitors; i++)
    {
        staticMonitors[i].Clear();
    }
}

GpStatus GpMonitors::Control(GpMonitorControlEnum control, void * param)
{
    GpStatus result = Ok;

    switch(control)
    {
    
    case MonitorControlClearAll:
        {
            Clear();
        }
        break;

    
    case MonitorControlDumpAll:
        {
            result = Dump((char *) param);
        }
        break;
    
    default:
        result = InvalidParameter;
    }             
    
    return result;
}

GpStatus GpMonitors::Dump(char * path)
{
    HANDLE  fileHandle;

    fileHandle = CreateFileA(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if(INVALID_HANDLE_VALUE != fileHandle)
    {
    
        GpMonitor * monitor = staticMonitors;
        ULONG       totalTime = 0;
        char        lineBuf[80];
        DWORD       bytesToWrite;
        DWORD       bytesWritten;
        double      ticksToMicroseconds = GpIntervalMonitor::TicksToMicroseconds();
        ULONG       microseconds;
    

        bytesToWrite = wsprintfA(lineBuf, "     Num    Total      Avg Api\n");
        WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);

        for(int i = 0; i < kNumStaticMonitors; i++, monitor++)
        {

            if(monitor->GetCount() > 0)
            {
                
                microseconds = (ULONG) ((double) monitor->GetTicks() * ticksToMicroseconds);

                bytesToWrite = wsprintfA(
                    lineBuf, 
                    "%8d %8d %8d %s\n", 
                    (ULONG) monitor->GetCount(),
                    (ULONG) microseconds,
                    ((ULONG) microseconds / (ULONG) monitor->GetCount()),
                    gStaticMonitorNames[i]
                );

                WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);
                    
                
                if(i < kFlatApiSentinelMonitor)
                {
                    totalTime += microseconds;
                }
            }
        }
        
        bytesToWrite = wsprintfA(lineBuf, "\nTotal time %d\n", totalTime);
        WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);

        CloseHandle(fileHandle);

        return Ok;
    
    }
    else
    {
        return InvalidParameter;
    }
}

void GpIntervalMonitor::ReadTicks(ULONGLONG * ticks)
{
#if defined(_X86_)
    __asm
    {
        rdtsc
        push    edi
        mov     edi, ticks
        mov     [edi], eax
        mov     [edi+4], edx
        pop     edi
    }
#else
    QueryPerformanceCounter((LARGE_INTEGER *) ticks);
#endif
}

double GpIntervalMonitor::TicksToMicroseconds(void)
{
    ULONGLONG  freq;
    QueryPerformanceFrequency((LARGE_INTEGER *) &freq);

#if defined(_X86_)
    ULONGLONG   counterStart;
    ULONGLONG   ticksStart;
    ULONGLONG   counterEnd;
    ULONGLONG   ticksEnd;

    QueryPerformanceCounter((LARGE_INTEGER *) &counterStart);
    ReadTicks(&ticksStart);
    Sleep(10);
    QueryPerformanceCounter((LARGE_INTEGER *) &counterEnd);
    ReadTicks(&ticksEnd);

    return ((double) ((counterEnd - counterStart) * 1000000) / (double) freq) / (double) (ticksEnd - ticksStart);
#else
    return (double) 1000000 / (double) freq;
#endif

}

void GpIntervalMonitor::Enter(GpMonitorEnum monitorEnum)
{
    if(Globals::Monitors != NULL)
    {
        monitor = Globals::Monitors->GetMonitor(monitorEnum);
        ReadTicks(&startTicks);
    }
    else
    {
        monitor = NULL;
    }
}

void GpIntervalMonitor::Exit(void)
{
    if(monitor != NULL)
    {
        ULONGLONG   endTicks;
        ReadTicks(&endTicks);
        monitor->Record(endTicks - startTicks);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\monitors.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definitions for a timing 'Monitor' used to measure
*   the runtime of isolated pieces of code.
*
* WARNINGS:
*
*   This code should not use anything which is initialized in GdiplusStartup,
*   because it may be called before GdiplusStartup, or after GdiplusShutdown.
*   This includes ::new and ::delete.
*
*   This code is not thread-safe. It doesn't even detect itself being used
*   in multiple threads. It shouldn't crash, but the timing results could be
*   incorrect.
*
* Notes:
* 
*   'Monitor' in this context has nothing to do with the Display.
*
* History:
*
*   09/30/2000 bhouse
*       Created it.
*
\**************************************************************************/

#ifndef __MONITORS_HPP__
#define __MONITORS_HPP__

typedef enum GpMonitorEnum {
#include "monitors.inc"
    kNumStaticMonitors
};

extern const char * gStaticMonitorNames[];

typedef Status GpStatus;

class GpMonitors;

namespace Globals
{
    extern GpMonitors * Monitors;
};

class GpMonitor
{
public:

    GpMonitor(void)
    {
        Clear();
    }

    void Clear(void)
    {
        count = 0;
        ticks = 0;
    }

    void Record(void)
    {
        count++;
    }

    void Record(ULONGLONG inTicks)
    {
        ticks += inTicks;
        count++;
    }

    ULONGLONG GetCount()
    {
        return count;
    }

    ULONGLONG GetTicks()
    {
        return ticks;
    }

private:

    ULONGLONG   count;
    ULONGLONG   ticks;
};

enum GpMonitorControlEnum
{
   MonitorControlClearAll = 0,
   MonitorControlDumpAll
};

class GpMonitors
{
public:

    GpMonitors(void)
    {
        Clear();
    }

    void Clear(void);
    
    GpStatus Dump(char * path);
    
    GpStatus Control(GpMonitorControlEnum control, void * param);

    GpMonitor * GetMonitor(GpMonitorEnum monitor)
    {
        return &staticMonitors[monitor];
    }
    
    // Define new and delete operators which don't depend on globals.
    // This way we can use the monitors around GdiplusStartup and
    // GdiplusShutdown.
    //
    // In truth, delete() will probably never be called, because we don't want
    // to destroy GpMonitors in GdiplusShutdown.
    
    void *operator new( size_t s)
    {
        return HeapAlloc(GetProcessHeap(), 0, s);
    }
    void operator delete( void *p)
    {
        if (p)
        {
            HeapFree(GetProcessHeap(), 0, p);
        }
    }

private:

    GpMonitor staticMonitors[kNumStaticMonitors];

};

class GpIntervalMonitor
{
public:

    void Enter(GpMonitorEnum monitorEnum);
    void Exit(void);

    static void ReadTicks(ULONGLONG * ticks);
    static double TicksToMicroseconds(void);

private:

    GpMonitor * monitor;
    ULONGLONG   startTicks;

};

class GpBlockMonitor : GpIntervalMonitor
{
public:

    GpBlockMonitor(GpMonitorEnum monitorEnum)
    {
        Enter(monitorEnum);
    }

    ~GpBlockMonitor(void)
    {
        Exit();
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\precomp.hpp ===
#include "..\Runtime\runtime.hpp"

#include "common.hpp"

// We shouldn't need this, but some of the files do.
// I think this is because they don't belong in the Common directory.

#include "..\..\ddkinc\ddiplus.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\testcontrol.cpp ===
#include "precomp.hpp"

namespace Globals
{
    BOOL ForceBilinear;
    BOOL NoICM;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\testcontrol.hpp ===
#ifndef _TESTCONTROL_HPP
#define _TESTCONTROL_HPP

namespace Globals
{
    extern BOOL ForceBilinear;
    extern BOOL NoICM;
};

// an instance of this class should be constructed in all Text+ calls
// to protect our global structures and cache
class GlobalTextLock
{
public:
    GlobalTextLock()
    {
        ::EnterCriticalSection(&Globals::TextCriticalSection);
    }
    ~GlobalTextLock()
    {
        ::LeaveCriticalSection(&Globals::TextCriticalSection);
    }
}; // GlobalTextLock

class GlobalTextLockConditional
{
public:
    GlobalTextLockConditional(bool bDoLock)
    {
        _bDoLock = bDoLock;
        if (_bDoLock)
        ::EnterCriticalSection(&Globals::TextCriticalSection);
    }
    ~GlobalTextLockConditional()
    {
        if (_bDoLock)
        ::LeaveCriticalSection(&Globals::TextCriticalSection);
    }
private:
    bool _bDoLock;
}; // GlobalTextLockConditional


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\rasterizer.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Rasterizer.hpp
*
* Abstract:
*
*   GpRasterizer class definition (and supporting classes)
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

#ifndef _RASTERIZER_HPP
#define _RASTERIZER_HPP

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.
//
// QUOTIENT_REMAINDER_64_32 takes a 64-bit numerator and produces 32-bit 
// results.

#if defined(_USE_X86_ASSEMBLY)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#define QUOTIENT_REMAINDER_64_32(ullNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                                            \
    ULONG ulNumeratorLow = *((ULONG*) &ullNumerator);                        \
    ULONG ulNumeratorHigh = *((ULONG*) &ullNumerator + 1);                   \
    __asm mov eax, ulNumeratorLow                                            \
    __asm mov edx, ulNumeratorHigh                                           \
    __asm div ulDenominator                                                  \
    __asm mov ulQuotient, eax                                                \
    __asm mov ulRemainder, edx                                               \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#define QUOTIENT_REMAINDER_64_32(ullNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                                            \
    ulQuotient = (ULONG) ((ULONGLONG) ullNumerator / (ULONG) ulDenominator); \
    ulRemainder = (ULONG) ((ULONGLONG) ullNumerator % (ULONG) ulDenominator);\
}

#endif

enum GpVectorDirection
{
    VectorGoingDown = -1,
    VectorHorizontal = 0,
    VectorGoingUp   =  1,
};

// This class does a y (vertical) DDA from (x1,y1) to (x2,y2), where y1 < y2.
// Horizontal lines are not handled.
//
// It is up to the caller to keep track of the current y value.  This class
// advances and keeps track of the current x value.  The Advance method should
// be called once for each increment of y.
//
// For fill algorithms (such as a winding fill), this class will also keep
// track of the original direction of the vector, if desired.

class GpYDda
{
protected:
    INT                 Error;      // DDA cumulative error
    INT                 ErrorUp;    // DDA constant 1
    INT                 YDelta;     // DDA constant 2
    INT                 YMax;       // greatest y value (last scan line)
    INT                 XInc;       // DDA X Increment
    INT                 XCur;       // current position
    GpVectorDirection   Direction;  // VectorGoingUp or VectorGoingDown

public:
    GpYDda() { /* we need a constructor with no params */ }
    GpYDda(
        FIX4                x1,
        FIX4                y1,
        FIX4                x2,
        FIX4                y2,
        GpVectorDirection   direction = VectorGoingDown
        )
    {
        Init(x1, y1, x2, y2, direction);
    }
    virtual ~GpYDda() {}

    virtual VOID
    Init(
        FIX4                x1,
        FIX4                y1,
        FIX4                x2,
        FIX4                y2,
        GpVectorDirection   direction = VectorGoingDown
        );

    virtual VOID Advance();

    BOOL DoneWithVector (INT y)
    {
        if (y < this->YMax)
        {
            Advance();
            return FALSE;
        }
        return TRUE;
    }

    INT GetX()
    {
        return this->XCur;
    }

    GpVectorDirection GetDirection()
    {
        return Direction;
    }

    virtual GpYDda * CreateYDda()
    {
        return new GpYDda();
    }
};

// Interface class for outputing a single span of a single raster at a time.
// When all the spans on a raster have been output, the EndRaster method
// is invoked.  When all rasterization for all rasters is complete, the
// End method is invoked.

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>


struct DpBrush;
class DpContext;

// [agodfrey]
//   * "Dp" should be "Ep" in this hierarchy.
//
//   There are two types of class which use this interface - 
//   "leaf" classes which actually produce the colors from the brush,
//   and "forwarding" ones which modify the input somehow, then forward it
//   down to an object of another DpOutputSpan class. The "leaf" ones
//   call Scan->NextBuffer, the "forwarding" ones can't. So my suggestion:
//
//   * Make just two subclasses of DpOutputSpan, one for each type.
//     Derive the rest of them from one of those two, instead of directly
//     from DpOutputSpan.

class DpOutputSpan
{
public:
    virtual ~DpOutputSpan() {}

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        ) = 0;

    virtual GpStatus EndRaster()   // no more spans on this raster
    {
        return Ok;
    }

    virtual GpStatus End()      // all done rasterizing everything
    {
        return Ok;
    }

    // !!! PERF [agodfrey]: I don't think this needs to be virtual.
    //     All the implementations seem to return "Scan" - just move the Scan
    //     pointer into the base class. DpClipRegion can just leave it NULL.

    virtual DpScanBuffer* GetScanBuffer()
    {
        return NULL;
    }

    virtual BOOL IsValid() const = 0;

    static DpOutputSpan * Create(
        const DpBrush * brush,
        DpScanBuffer * scan,
        DpContext * context,
        const GpRect * drawBounds=NULL);
};

typedef GpStatus (DpOutputSpan::*DpOutputSpanFunction)(INT, INT&, INT&);

// Interface class for outputing a series of rects within a Y Span.
class GpOutputYSpan
{
public:
    virtual ~GpOutputYSpan() {}
    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        ) = 0;
};

//#define USE_YSPAN_BUILDER
#ifndef USE_YSPAN_BUILDER
// Interface class for outputing a rect at a time.  Used by GpRectBuilder class.
class GpOutputRect
{
public:
    virtual ~GpOutputRect() {}
    virtual GpStatus OutputRect(
        INT             xMin,
        INT             yMin,
        INT             xMax,
        INT             yMax
        ) = 0;
};

// Builds up and outputs Y Span rects from single span inputs
class GpRectBuilder : public DpOutputSpan,  // input
                      public GpOutputYSpan  // output
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag       Tag;            // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpRectBuilder : ObjectTagInvalid;
    }

protected:
    DynIntArray     RectXCoords;    // currently built rects
    DynIntArray     RasterXCoords;  // x coords of current raster so far
    INT             RasterY;        // y value of current raster
    INT             RectYMin;       // starting y value of current rects
    INT             RectHeight;     // height of current rects
    GpOutputYSpan * FlushRects;     // Used to output the RectXCoords buffer
    GpOutputRect  * RenderRect;     // Used by FlushRects to ouput each rect

protected:
    GpStatus InitArrays();

public:
    // You can choose to output a single rect at a time with this constructor,
    // or if you use the other constructor it will output an entire Y Span
    // at a time.
    GpRectBuilder(GpOutputRect * renderRect);
    GpRectBuilder(GpOutputYSpan * flushRects);
    virtual ~GpRectBuilder()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpRectBuilder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpRectBuilder");
        }
    #endif

        return (Tag == ObjectTagGpRectBuilder);
    }

    // This method is the input of spans to this class
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual GpStatus EndRaster();
    virtual GpStatus End();

    // Default version to output 1 rect at a time
    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        );
};
#else
// Builds up and outputs Y Span rects from single span inputs
class GpYSpanBuilder : public DpOutputSpan  // input
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag       Tag;            // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpYSpanBuilder : ObjectTagInvalid;
    }

protected:
    DynIntArray     XCoords;        // x coords of current raster so far
    INT             Y;              // y value of current raster
    GpOutputYSpan * Output;

public:
    GpYSpanBuilder(GpOutputYSpan * output);
    virtual ~GpYSpanBuilder()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpYSpanBuilder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpYSpanBuilder");
        }
    #endif

        return (Tag == ObjectTagGpYSpanBuilder);
    }

    // This method is the input of spans to this class
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual GpStatus EndRaster();
};
#endif

class DpPath;
class DpClipRegion;
struct DpPen;
class RasterizeVector;

GpStatus
ConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            dda1,
    GpYDda *            dda2,
    DpOutputSpan *      output,
    const GpRect *      clipBounds
    );

GpStatus
NonConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            left,
    GpYDda *            right,
    DpOutputSpan *      output,
    const GpRect *      clipBounds,
    BOOL                useAlternate
    );

GpStatus
Rasterizer(
    const DpPath *      path,
    const GpMatrix *    matrix,
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    REAL                dpiX        = 0,
    REAL                dpiY        = 0,
    const GpRect *      clipBounds  = NULL,
    GpYDda *            yDda        = NULL,
    DpEnumerationType   type        = Flattened,
    const DpPen *       pen         = NULL
    );

GpStatus
Rasterize(
    const DpPath *      path,
    GpMatrix *          matrix,
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    DpClipRegion *      clipRegion,
    const GpRect *      drawBounds,
    REAL                dpiX,
    REAL                dpiY,
    GpYDda *            yDda        = NULL,
    DpEnumerationType   type        = Flattened,
    const DpPen *       pen         = NULL
    );

#endif // _RASTERIZER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\stackbuffer.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation of StackBuffer class
*
* Abstract:
*
*   This class provides a simple allocation scheme for a fixed size buffer.
*
*   First case.  Reserve of 128 bytes on the stack.
*   Second case.  Lookaside buffer, size equal to first usage of it.
*   Third case.  Allocate size on heap.
*
*   This is much less flexible than the DynamicArray class, the break up of
*   cost is basically as follows:
*
*     First case.  1 assignment + 2 compare (no allocation)
*     Second case. 1 assignment + 5 compare + 2 InterlockExchange's (pot. alloc)
*     Third case.  1 assignment + 4 compare + GpMalloc + GpFree
*
*   The cost is cheap for case one.  For case two, Lock + Unlock is small
*   and fast whereas case three is O(size of heap) in time.  There is also
*   the benefit of less fragmentation from fewer allocations.
*
*   If you are considering using this code elsewhere, please contact Andrew
*   Godfrey or Eric VandenBerg.  It is important this class be used properly
*   to ensure the performance benefit isn't adversely effected.
*
*   The initialization and clean up of lookaside buffer is done in 
*   InitializeGdiplus() and UninitializeGdiplus().
*
*   We provide the source here so it can be inlined easily.
*
\**************************************************************************/

#define INIT_SIZE       128         // 16 pairs of GpPoint types

class StackBuffer
{
private:
    BYTE buffer[INIT_SIZE];

    BYTE* allocBuffer;

public:
    StackBuffer()
    {
    }

    BYTE* GetBuffer(INT size)
    {
        if (size < 0)
        {
            return (allocBuffer = NULL);
        }
        else if (size<INIT_SIZE)
        {
            allocBuffer = NULL;
            return &buffer[0];
        }
        else if (size>Globals::LookAsideBufferSize)
        {
            return (allocBuffer = (BYTE*)GpMalloc(size));
        }
        else
        {
            if ((CompareExchangeLong_Ptr(&Globals::LookAsideCount, 1, 0) == 0)
                && Globals::LookAsideCount == 1)
            {
       
                if (Globals::LookAsideBuffer == NULL)
                {
                    Globals::LookAsideBufferSize = size + 128;
             
                    Globals::LookAsideBuffer = (BYTE*)GpMalloc(Globals::LookAsideBufferSize);
                }
       
                return (allocBuffer = Globals::LookAsideBuffer);
                // we have exclusive access to lookaside
            }
            else
            {
                return (allocBuffer = (BYTE*)GpMalloc(size));
            }
        }
       
    }
    
    ~StackBuffer()
    {
        if (allocBuffer != NULL)
        {    
             if (allocBuffer == Globals::LookAsideBuffer)
             {
                 ASSERT(Globals::LookAsideCount == 1);      // should be true

                 CompareExchangeLong_Ptr(&Globals::LookAsideCount, 0, 1);
             }
             else
             {    
                 GpFree(allocBuffer);
             }
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\common\rasterizer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Rasterizer.cpp
*
* Abstract:
*
*   GpRasterizer class implementation (and supporting classes)
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Initialize the vector's DDA info.
*   Assumes y1 < y2.
*
* Arguments:
*
*   [IN] x1        - starting fixed-point x coordinate of vector
*   [IN] y1        - starting fixed-point y coordinate of vector
*   [IN] x2        - ending   fixed-point x coordinate of vector
*   [IN] y2        - ending   fixed-point y coordinate of vector
*   [IN] direction - VectorGoingUp or VectorGoingDown
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
VOID 
GpYDda::Init(
    FIX4                x1, 
    FIX4                y1, 
    FIX4                x2, 
    FIX4                y2,
    GpVectorDirection   direction
    )
{
    ASSERT ((direction == VectorGoingUp) || (direction == VectorGoingDown));

    FIX4        xDelta = x2 - x1;
    FIX4        yDelta = y2 - y1;

    ASSERT (yDelta > 0);

    YDelta = yDelta;

    // Set up x increment
    INT     quotient;
    INT     remainder;

    // Error is initially 0, but we add yDelta - 1 for the ceiling,
    // but then subtract off yDelta so that we can check the sign
    // instead of comparing to yDelta.
    Error = -1;

    if (xDelta < 0)
    {
        xDelta = -xDelta;
        if (xDelta < yDelta)  // y-major
        {
            XInc    = -1;
            ErrorUp = yDelta - xDelta;
        }
        else                    // x-major
        {
            QUOTIENT_REMAINDER (xDelta, yDelta, quotient, remainder);

            XInc    = -quotient;
            ErrorUp = remainder;
            if (remainder != 0)
            {
                XInc--;
                ErrorUp = yDelta - remainder;
            }
        }
    }
    else
    {
        if (xDelta < yDelta)  // y-major
        {
            XInc    = 0;
            ErrorUp = xDelta;
        }
        else                    // x-major
        {
            QUOTIENT_REMAINDER (xDelta, yDelta, quotient, remainder);

            XInc    = quotient;
            ErrorUp = remainder;
        }
    }
    // See if we need to advance to an integer coordinate
    if ((y1 & FIX4_MASK) != 0)
    {
        INT     i;

        for (i = FIX4_ONE - (y1 & FIX4_MASK); i > 0; i--)
        {
            x1 += XInc;
            Error += ErrorUp;
            if (Error >= 0)
            {
                Error -= yDelta;
                x1++;
            }
        }
        // y1 += FIX4_MASK;
    }
    if ((x1 & FIX4_MASK) != 0)
    {
        Error -= yDelta * (FIX4_ONE - (x1 & FIX4_MASK));
        x1 += FIX4_MASK;      // to get the ceiling
    }
    Error   >>= FIX4_PRECISION;
    Direction = direction;
    XCur      = x1 >> FIX4_PRECISION;
    YMax      = GpFix4Ceiling (y2) - 1;

} // End of GpYDda::Init()

/**************************************************************************\
*
* Function Description:
*
*   Advance the DDA to the next raster.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
VOID
GpYDda::Advance()
{
    XCur  += XInc;
    Error += ErrorUp;

    if (Error >= 0)
    {
        Error -= YDelta;
        XCur++;
    }
}

#ifndef USE_YSPAN_BUILDER
/**************************************************************************\
*
* Function Description:
*
*   Construct a GpRectBuilder object that will output 1 rect at a time
*
* Arguments:
*
*   [IN] renderRect - a class that outputs a single rect at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpRectBuilder::GpRectBuilder(
    GpOutputRect * renderRect
    )
{
    ASSERT(renderRect);
    SetValid(FALSE);
    if ((renderRect != NULL) && (InitArrays() == Ok))
    {
        SetValid(TRUE);
        FlushRects = this;
        RenderRect = renderRect;
        RectYMin   = 0x7FFFFFFF;
        RectHeight = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a GpRectBuilder object that will output a set of rects in a
*   YSpan (YMin to YMax) at a time.
*
* Arguments:
*
*   [IN] flushRects - a class that outputs a Y span at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpRectBuilder::GpRectBuilder(
    GpOutputYSpan * flushRects
    )
{
    ASSERT(flushRects);
    SetValid(FALSE);
    if ((flushRects != NULL) && (InitArrays() == Ok))
    {
        SetValid(TRUE);
        FlushRects = flushRects;
        RenderRect = NULL;
        RectYMin   = 0x7FFFFFFF;
        RectHeight = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the Rect and Raster arrays that will build up a set of
*   X Coordinates within a Y span.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::InitArrays()
{

    GpStatus    status;
    
    status = RectXCoords.ReserveSpace(16);
    if (status == Ok)
    {
        status = RasterXCoords.ReserveSpace(16);
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster.  Is called by the rasterizer.
*   These spans provide the input for the rect builder.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::OutputSpan(
    INT y,
    INT xMin,
    INT xMax     // xMax is exclusive
    )
{
    ASSERT (xMin < xMax);

    INT *       xCoords;
    
    RasterY = y;
    
    // Test here if xMin == previous xMax and combine spans.
    // Some polygons (like the letter W) could benefit from such a check.
    // NT4 doesn't handle regions with adjacent spans that aren't combined.
    if ((RasterXCoords.GetCount() == 0) || (RasterXCoords.Last() != xMin))
    {
        if ((xCoords = RasterXCoords.AddMultiple(2)) != NULL)
        {
            xCoords[0] = xMin;
            xCoords[1] = xMax;
            return Ok;
        }
        return OutOfMemory;
    }
    else
    {
        RasterXCoords.Last() = xMax;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of a raster (Y value)
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::EndRaster()
{
    INT         rectXCount    = RectXCoords.GetCount();
    INT         rasterXCount  = RasterXCoords.GetCount();
    INT *       rasterXCoords = RasterXCoords.GetDataBuffer();
    GpStatus    status        = Ok;
    
    if (rectXCount != 0)
    {
        INT *       rectXCoords = RectXCoords.GetDataBuffer();

        if ((RasterY == (RectYMin + RectHeight)) &&
            (rasterXCount == rectXCount))
        {
            if (rasterXCount == 2)
            {
                if ((rasterXCoords[0] == rectXCoords[0]) &&
                    (rasterXCoords[1] == rectXCoords[1]))
                {
FoundRectMatch:
                    RasterXCoords.Reset(FALSE);
                    RectHeight++;
                    return Ok;
                }
            }
            else if (GpMemcmp(rasterXCoords, rectXCoords, 
                              rectXCount * sizeof(INT)) == 0)
            {
                goto FoundRectMatch;
            }
        }
        status = FlushRects->OutputYSpan(
                    RectYMin, 
                    RectYMin + RectHeight,
                    rectXCoords,
                    rectXCount);
    }
                        
    // if we get here, either the RectXCoords is empty or 
    // it has just been flushed
    RectXCoords.Reset(FALSE);
    if (rasterXCount > 0)
    {
        status = static_cast<GpStatus>
            (status | RectXCoords.AddMultiple(rasterXCoords, rasterXCount));
        RasterXCoords.Reset(FALSE);
        RectHeight = 1;
        RectYMin   = RasterY;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of all the rasters
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::End()
{
    INT         rectXCount = RectXCoords.GetCount();

    if (rectXCount != 0)
    {
        return FlushRects->OutputYSpan(
                    RectYMin, 
                    RectYMin + RectHeight,
                    RectXCoords.GetDataBuffer(),
                    rectXCount);
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   If the rect builder was constructed to output 1 rect at a time, then
*   this method is called to do that after a Y span is completed.
*
* Arguments:
*
*   [IN] yMin       - top of the Y span
*   [IN] yMax       - bottom of the Y span
*   [IN] xCoords    - array of x coordinates
*   [IN] numXCoords - number of x coordinates (>= 2, multiple of 2)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::OutputYSpan(
    INT             yMin, 
    INT             yMax, 
    INT *           xCoords,    // even number of X coordinates
    INT             numXCoords  // must be a multiple of 2
    )
{
    ASSERT (yMin < yMax);
    ASSERT (xCoords);
    ASSERT ((numXCoords >= 2) && ((numXCoords & 0x00000001) == 0))

    GpStatus        status;
    INT             i = 0;

    do
    {
        status = RenderRect->OutputRect(
                        xCoords[i], 
                        yMin, 
                        xCoords[i+1], 
                        yMax);
        i += 2;
    } while ((i < numXCoords) && (status == Ok));

    return status;
}
#else
/**************************************************************************\
*
* Function Description:
*
*   Construct a GpYSpanBuilder object that will output one YSpan 
*   (YMin to YMax) at a time.
*
* Arguments:
*
*   [IN] output - a class that outputs a Y span at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpYSpanBuilder::GpYSpanBuilder(
    GpOutputYSpan *     output
    )
{
    ASSERT(output);
    SetValid(FALSE);
    if (output != NULL)
    {
        Output = output;
        SetValid(XCoords.ReserveSpace(16) == Ok);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster.  Is called by the rasterizer.
*   These spans provide the input for the rect builder.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpYSpanBuilder::OutputSpan(
    INT y,
    INT xMin,
    INT xMax    // xMax is exclusive
    )
{
    ASSERT (xMin < xMax);

    INT *       xCoords;
    
    Y = y;
    
    if ((xCoords = XCoords.AddMultiple(2)) != NULL)
    {
        xCoords[0] = xMin;
        xCoords[1] = xMax;
        return Ok;
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of a raster (Y value)
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpYSpanBuilder::EndRaster()
{
    INT         count = XCoords.GetCount();
    
    // count can be 0
    if (count >= 2)
    {
        INT         y = Y;
        GpStatus    status = Output->OutputYSpan(y, y + 1, 
                                       XCoords.GetDataBuffer(), count);

        XCoords.Reset(FALSE);
        return status;
    }
    return Ok;
}
#endif // USE_YSPAN_BUILDER

/**************************************************************************\
*
* Macro Description:
*
*   Add a newly identified vector to the VectorList.  Keep track of the
*   direction of the vector, in case we're using the winding rule.  Put
*   the min y value in y1, so we can sort the vectors by min y.  Keep track
*   of the min and max y values for the entire list of vectors.
*
*   Don't add the vector if this is a horizontal (or near-horizontal) line.
*   We don't scan-convert horizontal lines.  Note that this check will also
*   fail if the two points are identical.
*
* Arguments:
*
*   [IN] x1 - starting fixed-point x coordinate of vector
*   [IN] y1 - starting fixed-point y coordinate of vector
*   [IN] x2 - ending   fixed-point x coordinate of vector
*   [IN] y2 - ending   fixed-point y coordinate of vector
*
*   [OUT] yMin       - set to min of yMin and least y of y1, y2
*   [OUT] yMax       - set to max of yMax and greatest y of y1, y2
*   [OUT] numVectors - incremented by 1
*   [OUT] vector     - incremented by 1
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
#define ADDVECTOR_SETYBOUNDS(x1,y1,x2,y2,yMin,yMax,numVectors,vector,dir) \
    if (GpFix4Ceiling(y1) != GpFix4Ceiling(y2))                           \
    {                                                                     \
        if ((y1) <= (y2))                                                 \
        {                                                                 \
            if ((y2) > (yMax))                                            \
            {                                                             \
                (yMax) = (y2);                                            \
            }                                                             \
            if ((y1) < (yMin))                                            \
            {                                                             \
                (yMin) = (y1);                                            \
            }                                                             \
            dir = VectorGoingDown;                                        \
            vector->Set((x1),(y1),(x2),(y2),VectorGoingDown);             \
        }                                                                 \
        else                                                              \
        {                                                                 \
            if ((y1) > (yMax))                                            \
            {                                                             \
                (yMax) = (y1);                                            \
            }                                                             \
            if ((y2) < (yMin))                                            \
            {                                                             \
                (yMin) = (y2);                                            \
            }                                                             \
            dir = VectorGoingUp;                                          \
            vector->Set((x2),(y2),(x1),(y1),VectorGoingUp);               \
        }                                                                 \
        (numVectors)++;                                                   \
        (vector)++;                                                       \
    }

// Used by Rasterizer to keep track of each vector in a path.
class RasterizeVector
{
public:
    FIX4                X1;
    FIX4                Y1;             // Min Y
    FIX4                X2;
    FIX4                Y2;             // Max Y
    GpVectorDirection   Direction;      // VectorGoingUp or VectorGoingDown
    
    VOID Set(FIX4 x1, FIX4 y1, FIX4 x2, FIX4 y2, GpVectorDirection direction)
    {
        X1 = x1;
        Y1 = y1;
        X2 = x2;
        Y2 = y2;
        Direction = direction;
    }
};

typedef DynArray<RasterizeVector> DynVectorArray;

/**************************************************************************\
*
* Function Description:
*
*   Rasterizer for non-convex polygons.
*
*   Rasterize a path into a set of spans on each raster (Y value) that the
*   path intersects.  The specified output object is used to output the spans.
*   The Y values of the specified clip bounds (if any) are used to speed the 
*   rasterization process by avoiding the processing of vectors that are 
*   outside those bounds.  However, it is assumed that at least part of the
*   path is visible in the vertical span of the clip bounds.
*
*   This algorithm is based on the one documented in 
*   Foley & Van Dam, Version 1, pp. 456 - 460.
*
*   Starting with the min y value and ending with the max y value, each
*   raster (Y value) is rasterized (output) one at a time.
*
*   (1) On each raster, check to see if new vectors need to be added to
*       the ActiveVectorList.  When an vector is added, DDA information about
*       that vector is computed so that the intersection of that vector with
*       each raster can be computed.
*
*   (2) Sort the ActiveVectorList in order of increasing x.
*
*   (3) Using either the alternate rule or the winding rule, output the span
*       between the appropriate vectors.
*
*   (4) Remove any vectors from the ActiveVectorList for which the current
*       raster is the max y of the vector.
*
*   (5) Calculate the intersection of the next raster with all the vectors
*       that are still in the ActiveVectorList (i.e. advance their DDAs).
*
* Arguments:
*
*   [IN] yMin                - the min y value of the set of vectors
*   [IN] yMax                - the max y value of the set of vectors
*   [IN] numVectors          - the number of vectors in the vector list
*   [IN] vectorList          - the list of vectors to rasterize
*   [IN] sortedVectorIndices - vector list sorted by increasing y
*   [IN] left                - a dda object to use
*   [IN] right               - a dda object to use
*   [IN] output              - used to output the spans of the rasterization
*   [IN] clipBounds          - clipbounds (if any) to use to speed the process
*   [IN] useAlternate        - whether or not to use the alternate rule
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

GpStatus
NonConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            left,
    GpYDda *            right,
    DpOutputSpan *      output,
    const GpRect *      clipBounds,
    BOOL                useAlternate
    )
{
    GpStatus                    status = Ok;
    INT                         yMinClipped = yMin;     // used for clipping
    INT                         yMaxClipped = yMax;     // used for clipping
    INT                         y;
    INT                         xMin;
    INT                         xMax;
    INT                         sortedVectorIndex = 0;  // idx to sortedVectorIndices
    RasterizeVector *           vector;
    INT                         i;
    INT                         count;
    INT                         numActiveVectors = 0;   // num used in ActiveVectorList
    DynArrayIA<GpYDda *, 16>    activeVectorList;       // active GpYDda vectors
    GpYDda **                   activeVectors;
    GpYDda *                    activeVector;
        
    activeVectors = reinterpret_cast<GpYDda **>
                            (activeVectorList.AddMultiple(2));
                                            
    if (activeVectors == NULL)
    {
        delete left;
        delete right;
        return OutOfMemory;
    }
            
    activeVectors[0] = left;
    activeVectors[1] = right;
    
    if (clipBounds != NULL)
    {
        yMinClipped = clipBounds->Y;
        yMaxClipped = clipBounds->GetBottom();

        // There are a few cases where this can happen legitimately.
        // For example, the transformed bounds of an object could be
        // partially in the clip area although the object isn't. 
        // Also, a Bezier control point might be in the clip area while
        // the actual curve isn't.
        if ((yMin > yMaxClipped) || (yMax < yMinClipped))
        {
            goto DoneNotConvex;
        }

        if (yMaxClipped > yMax)
        {
            yMaxClipped = yMax;
        }

        if (yMinClipped > yMin)
        {
            while (sortedVectorIndex < numVectors)
            {
                vector = vectorList + sortedVectorIndices[sortedVectorIndex];

                if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
                {
                    yMin = GpFix4Ceiling(vector->Y1);
                    break;
                }
                sortedVectorIndex++;
            }
        }
    }

    for (y = yMin; (y <= yMaxClipped); y++)
    {
        // Add any appropriate new vectors to the active vector list
        while (sortedVectorIndex < numVectors)
        {
            vector = vectorList + sortedVectorIndices[sortedVectorIndex];

            if (GpFix4Ceiling(vector->Y1) != y)
            {
                break;
            }

            // Clip the vector (but only against Y or 
            // we wouldn't get the right number of runs)
            if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
            {
                if (numActiveVectors < activeVectorList.GetCount())
                {
                    activeVector = activeVectors[numActiveVectors];
                }
                else
                {
                    activeVector = left->CreateYDda();
            
                    if ((activeVector == NULL) || 
                        (activeVectorList.Add(activeVector) != Ok))
                    {
                        delete activeVector;
                        status = OutOfMemory;
                        goto DoneNotConvex;
                    }
                    // adding the vector could change the data buffer
                    activeVectors = reinterpret_cast<GpYDda **>
                                        (activeVectorList.GetDataBuffer());
                }

                activeVector->Init(
                    vector->X1, 
                    vector->Y1, 
                    vector->X2, 
                    vector->Y2, 
                    vector->Direction);

                numActiveVectors++;
            }
            sortedVectorIndex++;
        }

        if (y >= yMinClipped)
        {
            // Make sure the activeVectorList is sorted in order of 
            // increasing x.  We have to do this every time, even if
            // we haven't added any new active vectors, because the
            // slopes of the lines can be different, which means they
            // could cross.
            for (count = 1; count < numActiveVectors; count++)
            {
                i = count;
                do
                {
                    if (activeVectors[i]->GetX() >= 
                        activeVectors[i-1]->GetX())
                    {
                        break;
                    }

                    activeVector       = activeVectors[i-1];
                    activeVectors[i-1] = activeVectors[i];
                    activeVectors[i]   = activeVector;
            
                } while (--i > 0);
            }

            // fill the appropriate pixels on the current scan line
            if (useAlternate)
            {
                // Use the alternating rule (also known as even/odd rule)
                // to output the spans of a raster between the intersections
                // of the vectors with the current scan line.
                //
                // The alternating rule means that a raster pattern is drawn 
                // between the 1st and 2nd points and between the 3rd and 
                // 4th points, etc., but not between the 2nd and 3rd points
                // or between the 4th and 5th points, etc.
                //
                // There could be an odd number of points; for example:
                //
                //      9       /\
                //      8      /  \
                //      7     /    \
                //      6    /      \
                //      5   /        \
                //      4  /----------\--------/
                //      3              \      /
                //      2               \    /
                //      1                \  /
                //      0                 \/
                //
                // On raster y==4, there are 3 points, so the 2nd half of 
                // the raster does not get output.

                for (i = 1; (i < numActiveVectors); i += 2)
                {
                    xMin = activeVectors[i-1]->GetX();
                    xMax = activeVectors[i]->GetX();
        
                    // Make sure the X's aren't equal
                    if (xMin < xMax)
                    {
                        if (output->OutputSpan(y, xMin, xMax) != Ok)
                        {
                            status = GenericError;
                            goto DoneNotConvex;
                        }
                    }
                }
            }
            else    // Winding
            {
                GpYDda *    leftEdge;
                GpYDda *    rightEdge;
                INT         j;
                INT         direction = 0;  // num times going up and down
    
                // There's got to be the same number of lines
                // going up as going down before drawing the
                // scan line.
                for (count = 1; (count < numActiveVectors); count = j + 2)
                {
                    leftEdge = activeVectors[count - 1];

                    direction += static_cast<INT>(leftEdge->GetDirection());

                    for (j = count; (j < numActiveVectors); j++)
                    {
                        rightEdge = activeVectors[j];

                        direction += static_cast<INT>
                                        (rightEdge->GetDirection());

                        if (direction == 0)
                        {
                            xMin = leftEdge->GetX();
                            xMax = rightEdge->GetX();
                
                            // Make sure the X's aren't equal
                            if (xMin < xMax)
                            {
                                if (output->OutputSpan(y, xMin, xMax) != Ok)
                                {
                                    status = GenericError;
                                    goto DoneNotConvex;
                                }
                            }
                            break;
                        }
                    }
                }
            }
            if (output->EndRaster() != Ok)
            {
                status = GenericError;
                goto DoneNotConvex;
            }
        }

        // remove any appropriate vectors from the active vector list
        // and advance all the DDAs
        {
            INT         activeIndex = 0;
            VOID *      removedActiveVector;

            while (activeIndex < numActiveVectors)
            {
                activeVector = activeVectors[activeIndex];

                if (activeVector->DoneWithVector(y))
                {
                    numActiveVectors--;

                    if (numActiveVectors > activeIndex)
                    {
                        GpMemmove(
                            &(activeVectors[activeIndex]), 
                            &(activeVectors[activeIndex + 1]), 
                            (numActiveVectors - activeIndex) * 
                            sizeof(activeVectors[0]));
                    }
                    activeVectors[numActiveVectors] = activeVector;
                }
                else
                {
                    activeIndex++;
                }
            }
        }
    }
    status = output->End();

DoneNotConvex:
    numActiveVectors = activeVectorList.GetCount();
        
    ASSERT(numActiveVectors > 0);
    activeVectors = reinterpret_cast<GpYDda **>
                            (activeVectorList.GetDataBuffer());

    do
    {
        delete activeVectors[--numActiveVectors];
    } while (numActiveVectors > 0);
    
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rasterizer for convex polygons.
*
*   Uses basically the same algorithm to rasterize, but has a few optimizations
*   for when we know the polygon is convex.  We know there will only be 2
*   active vectors at a time (and only 2).  Even though they may cross each
*   other, we don't bother sorting them.  We just check the X values instead.
*   These optimizations provide about a 15% increase in performance.
*
* Arguments:
*
*   [IN] yMin                - the min y value of the set of vectors
*   [IN] yMax                - the max y value of the set of vectors
*   [IN] numVectors          - the number of vectors in the vector list
*   [IN] vectorList          - the list of vectors to rasterize
*   [IN] sortedVectorIndices - vector list sorted by increasing y
*   [IN] left                - a dda object to use
*   [IN] right               - a dda object to use
*   [IN] output              - used to output the spans of the rasterization
*   [IN] clipBounds          - clipbounds (if any) to use to speed the process
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/24/1999 DCurtis
*
\**************************************************************************/
GpStatus
ConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            dda1,
    GpYDda *            dda2,
    DpOutputSpan *      output,
    const GpRect *      clipBounds
    )
{
    GpStatus            status = Ok;
    INT                 yMinClipped = yMin;     // used for clipping
    INT                 yMaxClipped = yMax;     // used for clipping
    INT                 y;
    INT                 x1;
    INT                 x2;
    INT                 sortedVectorIndex = 0;  // idx to sortedVectorIndices
    RasterizeVector *   vector1;
    RasterizeVector *   vector2;

    if (clipBounds != NULL)
    {
        yMinClipped = clipBounds->Y;
        yMaxClipped = clipBounds->GetBottom();

        // There are a few cases where this can happen legitimately.
        // For example, the transformed bounds of an object could be
        // partially in the clip area although the object isn't. 
        // Also, a Bezier control point might be in the clip area while
        // the actual curve isn't.
        if ((yMin > yMaxClipped) || (yMax < yMinClipped))
        {
            goto DoneConvex;
        }

        if (yMaxClipped > yMax)
        {
            yMaxClipped = yMax;
        }

        if (yMinClipped > yMin)
        {
            RasterizeVector *   vector;

            vector1 = NULL;
            while (sortedVectorIndex < numVectors)
            {
                vector = vectorList+sortedVectorIndices[sortedVectorIndex++];

                if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
                {
                    if (vector1 == NULL)
                    {
                        vector1 = vector;
                    }
                    else
                    {
                        vector2 = vector;
                        goto HaveVectors;
                    }
                }
            }
            ASSERT(0);
            status = InvalidParameter;  // either not convex or clipped out
            goto DoneConvex;
        }
    }
    vector1 = vectorList + sortedVectorIndices[0];
    vector2 = vectorList + sortedVectorIndices[1];
    sortedVectorIndex = 2;

HaveVectors:
    dda1->Init(vector1->X1, vector1->Y1, 
               vector1->X2, vector1->Y2, 
               VectorGoingUp);

    dda2->Init(vector2->X1, vector2->Y1, 
               vector2->X2, vector2->Y2, 
               VectorGoingUp);

    // For clipping case, we have to advance the first vector to catch up
    // to the start of the 2nd vector.
    {
        yMin = GpFix4Ceiling(vector2->Y1);
        for (INT yMinVector1 = GpFix4Ceiling(vector1->Y1);
             yMinVector1 < yMin; yMinVector1++)
        {
            dda1->Advance();
        }
    }

    for (y = yMin; (y <= yMaxClipped); y++)
    {
        if (y >= yMinClipped)
        {
            // fill the appropriate pixels on the current scan line
            x1 = dda1->GetX();
            x2 = dda2->GetX();

            // Make sure the X's aren't equal before outputting span
            if (x1 < x2)
            {
                if (output->OutputSpan(y, x1, x2) == Ok)
                {
                    if (output->EndRaster() == Ok)
                    {
                        goto DoneCheck;
                    }
                }
                status = GenericError;
                goto DoneConvex;
            }
            else if (x1 > x2)
            {
                if (output->OutputSpan(y, x2, x1) == Ok)
                {
                    if (output->EndRaster() == Ok)
                    {
                        goto DoneCheck;
                    }
                }
                status = GenericError;
                goto DoneConvex;
            }
        }

DoneCheck:
        if (dda1->DoneWithVector(y))
        {
            if (sortedVectorIndex >= numVectors)
            {
                break;
            }
            vector1 = vectorList + sortedVectorIndices[sortedVectorIndex++];
            ASSERT(GpFix4Ceiling(vector1->Y1) == (y + 1));

            dda1->Init(vector1->X1, vector1->Y1, 
                       vector1->X2, vector1->Y2, 
                       VectorGoingUp);
        }
        if (dda2->DoneWithVector(y))
        {
            if (sortedVectorIndex >= numVectors)
            {
                ASSERT(0);
                break;
            }
            vector2 = vectorList + sortedVectorIndices[sortedVectorIndex++];
            ASSERT(GpFix4Ceiling(vector2->Y1) == (y + 1));

            dda2->Init(vector2->X1, vector2->Y1, 
                       vector2->X2, vector2->Y2, 
                       VectorGoingUp);
        }
    }
    status = output->End();

DoneConvex:
    delete dda1;
    delete dda2;
    return status;
}

#define NUM_ENUMERATE_POINTS    32


/**************************************************************************\
*
* Function Description:
*
*   Perform a simple partition sort on a list indexing into the vector list.
*   The result is a sorted index array keyed on the vertex array Y1 coordinate.
*   The index array is sorted in place and in ascending order.
*
* Arguments:
*
*   v is the vertex list.
*   F, L - First and Last pointer in the index array.
*
* Created:
*
*  09/16/2000 asecchia
*
\**************************************************************************/

void QuickSortIndex(
    RasterizeVector *v,
    int *F,
    int *L
)
{
    if(F < L)
    {
        // Find the median position.
        
        int median = *(F + (L-F)/2);
        
        int *i = F;
        int *j = L;
        
        while(i<j)
        {
            // seek for elements in the wrong partition.
            
            while(v[*i].Y1 < v[median].Y1) {i++;}
            while(v[*j].Y1 > v[median].Y1) {j--;}
            
            if(i>=j) { break; }
            
            // Swap.
            
            int temp = *i;
            *i = *j;
            *j = temp;
            
            // tie breaker - handle the case where [*i] == [*j] == [median], but
            // i != j. Only possible with multiple copies of the same entry.
            
            if(v[*i].Y1 == v[*j].Y1) { i++; }
        }
        
        // Call recursively for the two sub-partitions. The partitions don't 
        // include position i because it is correctly positioned.
        
        QuickSortIndex(v, F, i-1);
        QuickSortIndex(v, i+1, L);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the data needed for the rasterization and invoke the
*   appropriate rasterizer (convex or non-convex).
*
* Arguments:
*
*   [IN] path        - the path to rasterize
*   [IN] matrix      - the matrix to transform the path points by
*   [IN] fillMode    - the fill mode to use (Alternate or Winding)
*   [IN] output      - used to output the spans of the rasterization
*   [IN] clipBounds  - clipbounds (if any) to use to speed the process
*   [IN] yDda        - instance of DDA class to use
*   [IN] type        - type of enumeration
*   [IN] strokeWidth - for wide line rasterizing
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
Rasterizer(
    const DpPath *      path, 
    const GpMatrix *    matrix, 
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    REAL                dpiX,
    REAL                dpiY,
    const GpRect *      clipBounds,
    GpYDda *            yDda,
    DpEnumerationType   type,
    const DpPen *       pen
    )
{
    ASSERT ((path != NULL) && (matrix != NULL) && (output != NULL));

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    GpStatus            status = Ok;
    FIX4                yMin;                   // min y of all vectors
    FIX4                yMax;                   // max y of all vectors
    INT                 numVectors;             // num vectors in VectorList
    RasterizeVector *   vectorList = NULL;      // list of all vectors of path
    INT *               sortedVectorIndices;    // sorted list of vector indices
    GpYDda *            left;
    GpYDda *            right;
    GpPointF            pointsF[NUM_ENUMERATE_POINTS];
    BYTE                types[NUM_ENUMERATE_POINTS];
    INT                 count;
    INT                 estimateVectors;
    GpPathPointType     pointType;
    FIX4                xFirst;     // first point in sub-path
    FIX4                yFirst;
    FIX4                xStart;     // start point of a vector
    FIX4                yStart;
    FIX4                xEnd;       // end point of a vector
    FIX4                yEnd;
    RasterizeVector *   vector;
    INT                 i;
    GpVectorDirection   direction; 
    GpVectorDirection   newDirection;
    INT                 numDirections;
    BOOL                multipleSubPaths;

    BOOL isAntiAliased = FALSE;
    const DpPath* flattenedPath = path->GetFlattenedPath(
        matrix,
        type,
        pen
    );

    if(!flattenedPath)
        return OutOfMemory;

    DpPathIterator enumerator(flattenedPath->GetPathPoints(),
                        flattenedPath->GetPathTypes(),
                        flattenedPath->GetPointCount());

    if(!enumerator.IsValid())
    {
        // No need to rasterize.  Exit gracefully.

        goto Done;
    }

    estimateVectors = enumerator.GetCount() + 
                        enumerator.GetSubpathCount() - 1;

    // The estimate must be >= the actual number of points
    if (estimateVectors < 2)
    {
        goto Done;
    }

    // Allocate vectorList and sortedVectorIndices together
    vectorList = static_cast<RasterizeVector *>
                    (GpMalloc((estimateVectors * sizeof(RasterizeVector)) +
                            (estimateVectors * sizeof(INT))));
    if (vectorList == NULL)
    {
        status = OutOfMemory;
        goto Done;
    }
    sortedVectorIndices = reinterpret_cast<INT*>
                                (vectorList + estimateVectors);

    // enumerate the first set of points from the path
    count = enumerator.Enumerate(pointsF, types, NUM_ENUMERATE_POINTS);
    
    ASSERT (count <= NUM_ENUMERATE_POINTS);
        
    // We know we are done enumerating when we get back a 0 count
    if (count <= 0)
    {
        goto Done;
    }

    // Keep track of direction changes as a way to know if we can use
    // the convex rasterizer or not.  As long as there is only 1 sub-path
    // and there are at most 3 directions (e.g. down, up, down), 
    // we can use the convex rasterizer.
    direction           = VectorHorizontal;  
    newDirection        = VectorHorizontal;  
    numDirections       = 0; 
    multipleSubPaths    = FALSE;

    vector     = vectorList;
    numVectors = 0;

    xFirst = GpRealToFix4(pointsF[0].X);
    yFirst = GpRealToFix4(pointsF[0].Y);
            
    xStart = xEnd = xFirst;
    yStart = yEnd = yFirst;

    yMin = yMax = yFirst;

    // Add all the vectors to the vector list.  The vector list keeps
    // the coordinates as fixed point values (28.4).  As each one is
    // added, YMin and YMax are updated.

    // Each sub-path is automatically closed, even if it was not
    // specifically asked to be closed.
    for (i = 1;; i++)
    {
        if (i == count)
        {
            count = enumerator.Enumerate(pointsF, types, 32);
            ASSERT (count <= 32);
                    
            if (count <= 0)
            {
                // Close the last subpath, if necessary
                ADDVECTOR_SETYBOUNDS(xEnd, yEnd, xFirst, yFirst, yMin, yMax, 
                                     numVectors, vector, newDirection);
                ASSERT (numVectors <= estimateVectors);
                if(newDirection != direction)   // for convex test
                {
                    numDirections++;
                    direction = newDirection;
                }
                break;
            }
            i = 0;
        }
        pointType = static_cast<GpPathPointType>
                        (types[i] & PathPointTypePathTypeMask);

        if (pointType != PathPointTypeStart)
        {
            ASSERT(pointType == PathPointTypeLine);

            xEnd = GpRealToFix4(pointsF[i].X);
            yEnd = GpRealToFix4(pointsF[i].Y);

            ADDVECTOR_SETYBOUNDS (xStart, yStart, xEnd, yEnd, yMin, yMax, 
                                  numVectors, vector, newDirection);
            ASSERT (numVectors <= estimateVectors);
            if(newDirection != direction)   // for convex test
            {
                numDirections++;
                direction = newDirection;
            }
        }
        else    // it is a start point
        {
            // Close the previous subpath, if necessary
            ADDVECTOR_SETYBOUNDS(xEnd, yEnd, xFirst, yFirst, yMin, yMax, 
                                 numVectors, vector, newDirection);
            ASSERT (numVectors <= estimateVectors);

            xFirst = GpRealToFix4(pointsF[i].X);
            yFirst = GpRealToFix4(pointsF[i].Y);

            xEnd = xFirst;
            yEnd = yFirst;

            // Can't use convex rasterizer for more than one sub-path
            // unless we've specifically been told it's Ok to do so.
            multipleSubPaths = TRUE;
        }
        xStart = xEnd;
        yStart = yEnd;
    }

    if (numVectors < 2)
    {
        goto Done;
    }

    yMin = GpFix4Ceiling (yMin);       // convert to int
    yMax = GpFix4Ceiling (yMax) - 1;   // convert to int

    //  Initialize and sort the vector indices in order of 
    //  increasing yMin values.

    //  All the vectors must be set up first in the VectorList.
    
    // Initialize the index list.
    
    for(INT count = 0; count < numVectors; count++)
    {
        sortedVectorIndices[count] = count;
    }
    
    // Sort the index list.
    
    QuickSortIndex(
        vectorList, 
        &sortedVectorIndices[0], 
        &sortedVectorIndices[numVectors-1]
    );
    
    left = yDda;
    if (left == NULL)
    {
        left = new GpYDda();
                
        if (left == NULL)
        {
            status = OutOfMemory;
            goto Done;
        }
    }

    right = left->CreateYDda();
    if (right == NULL)
    {
        status = OutOfMemory;
        delete left;
        goto Done;
    }

    if ((flattenedPath->IsConvex()) ||
        ((!multipleSubPaths) && (numDirections <= 3)))
    {
        status = ConvexRasterizer(yMin, yMax, numVectors, vectorList,
                                  sortedVectorIndices, left, right,
                                  output, clipBounds);
    }
    else
    {
        status = NonConvexRasterizer(yMin, yMax, numVectors, vectorList,
                                     sortedVectorIndices, left, right,
                                     output, clipBounds, 
                                     (fillMode == FillModeAlternate));
    }

Done:
    GpFree(vectorList);
    delete flattenedPath;
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rasterize a path into a set of spans on each raster (Y value) that the
*   path intersects.  The specified output object is used to output the spans.
*
*   First the clipping is looked at to determine if the path is visible.
*   If not, we're done.  If totally visible, no clipping needed.  Otherwise,
*   set up the clip region to handle the clipping of this path.  The output
*   method of the rasterizer is the clip region which then clips the span
*   before calling the real output method.
*
* Arguments:
*
*   [IN] path        - the path to rasterize
*   [IN] matrix      - the matrix to transform the path points by
*   [IN] fillMode    - the fill mode to use (Alternate or Winding)
*   [IN] output      - the object used to output the spans of the rasterization
*   [IN] clipRegion  - clip region to clip against (or NULL)
*   [IN] drawBounds  - bounds of the path in device units
*   [IN] yDda        - instance of DDA class to use
*   [IN] type        - type of enumeration
*   [IN] strokeWidth - for wide line rasterizing
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
GpStatus
Rasterize(
    const DpPath *      path, 
    GpMatrix *          matrix, 
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    DpClipRegion *      clipRegion,
    const GpRect *      drawBounds,
    REAL                dpiX,
    REAL                dpiY,
    GpYDda *            yDda,
    DpEnumerationType   type,
    const DpPen *       pen
    )
{
    ASSERT ((path != NULL) && (matrix != NULL) && (output != NULL));
    ASSERT ((clipRegion != NULL) && (drawBounds != NULL));
    
    GpRect      clipBounds;
    GpRect *    clipBoundsPointer = NULL;

    DpRegion::Visibility    visibility;
        
    visibility = clipRegion->GetRectVisibility(
                    drawBounds->X,
                    drawBounds->Y,
                    drawBounds->X + drawBounds->Width,
                    drawBounds->Y + drawBounds->Height);
                        
    switch (visibility)
    {
      case DpRegion::Invisible:
        return Ok;
            
      case DpRegion::TotallyVisible:    // No clipping needed
        break;
            
      default:                          // Need to clip
        clipRegion->GetBounds(&clipBounds);
        clipBoundsPointer = &clipBounds;
        clipRegion->InitClipping(output, drawBounds->Y);
        output = clipRegion;
        break;
    }
    
    GpStatus status = Rasterizer(path, matrix, fillMode, output, dpiX, dpiY,
                                 clipBoundsPointer, yDda, type, pen);

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dpdriverdata.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Driver-specific data
*
* Abstract:
*
*   This module gives drivers a way to attach private data to GDI+
*   objects. 
*
* Created:
*
*   3/18/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

DpDriverDataList::~DpDriverDataList()
{
    DpDriverData *p=head;
    while (p)
    {
        DpDriverData *tmp = p->next;
        delete p;
        p = tmp;
    }
}

void DpDriverDataList::Add(DpDriverData *dd, DpDriver *owner)
{
    dd->owner = owner;
    dd->next = head;
    head = dd;
}
    
DpDriverData *DpDriverDataList::GetData(DpDriver *owner)
{
    DpDriverData *p=head;
    while (p)
    {
        if (p->owner == owner)
        {
            return p;
        }
        p = p->next;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dpdriverinternal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   
*
* Abstract:
*
*   
*
* Notes:
*
*   
*
* Created:
*
*   //1999 agodfrey
*
\**************************************************************************/

#ifndef _DPDRIVERINTERNAL_HPP
#define _DPDRIVERINTERNAL_HPP

struct DpDriverInternal
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dpdriverdata.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Driver-specific data
*
* Abstract:
*
*   This module gives drivers a way to attach private data to GDI+
*   objects. 
*
* Created:
*
*   3/18/1999 agodfrey
*
\**************************************************************************/

#ifndef _DPDRIVERDATA_HPP
#define _DPDRIVERDATA_HPP

class DpDriverData
{
public:
    virtual ~DpDriverData()=0;

private:
    DpDriverData *next;
    DpDriver *owner;
    friend class DpDriverDataList;
};

class DpDriverDataList
{
public:
    DpDriverDataList() { head = NULL; }
    ~DpDriverDataList();
    void Add(DpDriverData *dd, DpDriver *owner);
    
    DpDriverData *GetData(DpDriver *owner);

private:
    DpDriverData *head;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\context.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Handles the driver viewable Context class.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

LONG DpContext::Uniqueness = 0xfdbc;   // Used with save/restore Id's

DpContext::DpContext(
    DpContext *     prev
    )
{
    ASSERT(prev != NULL);

    Id   = InterlockedDecrement(&Uniqueness) << 16;
    Next = NULL;
    Prev = prev;

    // Save bit 15 for a container flag
    Id             |= ((prev->Id + 1) & 0x00007FFF);
    if (Id == 0)    // 0 is not a valid ID
    {
        Id = 0x0dbc0001;
    }
    AntiAliasMode      = prev->AntiAliasMode;
    TextRenderHint     = prev->TextRenderHint;
    TextContrast       = prev->TextContrast;
    CompositingMode    = prev->CompositingMode;
    CompositingQuality = prev->CompositingQuality;
    FilterType         = prev->FilterType;
    PixelOffset        = prev->PixelOffset;
    Hwnd               = prev->Hwnd;
    Hdc                = prev->Hdc;
    IsEmfPlusHdc       = prev->IsEmfPlusHdc;
    IsPrinter          = prev->IsPrinter;
    IsDisplay          = prev->IsDisplay;
    SaveDc             = prev->SaveDc;
    Palette            = prev->Palette;
    PaletteMap         = prev->PaletteMap;
    OriginalHFont      = NULL;
    CurrentHFont       = NULL;
    Face               = NULL;
    ContainerDpiX      = prev->ContainerDpiX;
    ContainerDpiY      = prev->ContainerDpiY;
    MetafileRasterizationLimitDpi = prev->MetafileRasterizationLimitDpi;

    RenderingOriginX   = prev->RenderingOriginX;
    RenderingOriginY   = prev->RenderingOriginY;
    GdiLayered         = FALSE;
                    
    // Does this need to be prev->IcmMode?

    IcmMode            = IcmModeOff;
    
    // Clipping and Transforms handled elsewhere
}

DpContext::DpContext(
    BOOL            isDisplay
    )
{
    Id   = InterlockedDecrement(&Uniqueness) << 16;
    Next = NULL;
    Prev = NULL;

    Id                |= 0x0dbc;
    AntiAliasMode      = 0;
    TextRenderHint     = TextRenderingHintSystemDefault;
    TextContrast       = DEFAULT_TEXT_CONTRAST;
    CompositingMode    = CompositingModeSourceOver;
    CompositingQuality = CompositingQualityDefault;
    FilterType         = InterpolationModeDefaultInternal;
    PixelOffset        = PixelOffsetModeDefault;
    Hwnd               = NULL;
    Hdc                = NULL;
    IsEmfPlusHdc       = FALSE;
    IsPrinter          = FALSE;
    IsDisplay          = isDisplay;
    SaveDc             = 0;
    PageUnit           = UnitDisplay;
    PageScale          = 1.0f;
    Palette            = NULL;
    PaletteMap         = NULL;
    OriginalHFont      = NULL;
    CurrentHFont       = NULL;
    Face               = NULL;
    ContainerDpiX      = Globals::DesktopDpiX;
    ContainerDpiY      = Globals::DesktopDpiY;
    GdiLayered         = FALSE;
    MetafileRasterizationLimitDpi = max(ContainerDpiX, ContainerDpiY);
    ASSERT(MetafileRasterizationLimitDpi > 0.0f);

    // Set the default rendering origin to the top left corner of the Graphics.

    RenderingOriginX   = 0;
    RenderingOriginY   = 0;
                    
    // Set the default ICM mode == ICM off.

    IcmMode            = IcmModeOff;

    // Clipping and Transforms handled elsewhere
}

DpContext::~DpContext()
{
    delete Next;
    Next = NULL;
    
    DeleteCurrentHFont();
    
    if (Prev == NULL)
    {
        if (PaletteMap != NULL)
        {
            delete PaletteMap;
            PaletteMap = NULL;
        }

        if (Palette != NULL)
        {
            GpFree(Palette);
            Palette = NULL;
        }
    }
} // DpContext::~DpContext

/**************************************************************************\
*
* Function Description:
*
*   Internal function that retrieves a clean HDC for the specified
*   context (if there is one).  This is intended to be used for
*   internal functions that require a DC (such as when we leverage
*   GDI accelerations for rendering).
*
*   The DC is cleaned for the minimum amount that we can.  That is,
*   the caller can expect an MM_TEXT transform, copy ROP, etc.
*
*   We explicitly DO NOT clean attributes that we expect any callers
*   to change, such as brush color, text color, etc.  (And consequently,
*   callers are not expected to preserve those values.)
*
*   Reset: Transform, ROP mode
*
*   NOT reset: Application clipping, stretch blt mode, current brush/pen,
*              foreground color, etc.
*
* Return Value:
*
*   NULL if no HDC can be retrieved.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

HDC
DpContext::GetHdc(
    DpBitmap *surface
    )
{
    HDC hdc = NULL;

    // Callers MUST pass in the surface:

    ASSERT(surface != NULL);

    // The first thing we have to do is flush any of our pending drawing
    // (because GDI certainly doesn't know how to flush it!)

    surface->Flush(FlushIntentionFlush);

    if (Hwnd)
    {
        // The Graphics was derived off an Hwnd.  Use GetCleanHdc
        // to get a nice clean DC (not a CS_OWNDC).

        hdc = ::GetCleanHdc(Hwnd);

        if(hdc)
        {
            // Set the appropriate ICM mode according to the context. 
            
            if(IcmMode == IcmModeOn)
            {
                // Force the ICM mode on.

                ::SetICMMode(hdc, ICM_ON);
            } 
            else
            {                
                // There are only 2 IcmMode flags possible. If you've added 
                // more you need to recode the logic that sets the IcmMode on
                // the DC.

                ASSERT(IcmMode==IcmModeOff);

                ::SetICMMode(hdc, ICM_OFF);
            }
        }

        return hdc;
    }
    else if (Hdc)
    {
        // The Graphics was derived from a bitmap, printer, or metafile Hdc.

        // First, save the application's HDC state and reset all the state

        hdc = Hdc;

        if (!SaveDc)
        {
            SaveDc = ::SaveDC(hdc);
            if (!SaveDc)
            {
                return(NULL);
            }

            this->CleanTheHdc(hdc);
        }
    }
    else if (surface->Type == DpBitmap::CreationType::GPBITMAP)
    {
        // The GpBitmap is accessible from the EpScanBitmap.  It will
        // create an HDC and GDI bitmap appropriate for interop.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(surface->Scan);
        hdc = scan->GetBitmap()->GetHdc();
        
        // !!! For some reason, this hdc is NOT clean.  So in metaplay.cpp
        // !!! I have to call CleanTheHdc on this hdc.  I don't think I should
        // !!! have to do that, but without it, there is bug #121666.
    }

    return(hdc);
}

/**************************************************************************\
*
* Function Description:
*
*   Internal function that cleans the given HDC.
*
*   Reset: Transform, ROP mode
*
*   NOT reset: Application clipping, stretch blt mode, current brush/pen,
*              foreground color, etc.
*
* Notes:
*
*   Application clipping IS reset, contrary to the above - this is bug #99338.
*
* Arguments:
*
*   hdc               - the HDC to clean
*
* History:
*
*   ??/??/???? andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpContext::CleanTheHdc(
    HDC hdc
    )
{
    // Reset the minimum number of DC attributes possible
    //
    // DON'T GRATUITOUSLY ADD RESETS HERE.  Read the function
    // comment above, and consider resetting any additional
    // DC attributes in the function that calls GetHdc().
    //
    // NOTE: A possible optimization for bitmap surfaces would
    //       be to CreateCompatibleDC a new DC, and select
    //       the bitmap into that.
    
    
    // Set the appropriate ICM mode. 
    
    if(IcmMode == IcmModeOn)
    {
        // Force the ICM mode on.

        ::SetICMMode(hdc, ICM_ON);
    } 
    else
    {                
        // There are only 2 IcmMode flags possible. If you've added 
        // more you need to recode the logic that sets the IcmMode on
        // the DC.

        ASSERT(IcmMode==IcmModeOff);

        // Force the ICM mode off.

        ::SetICMMode(hdc, ICM_OFF);
    }
    

    if (!IsEmfPlusHdc)
    {
        SetMapMode(hdc, MM_TEXT);
        SetViewportOrgEx(hdc, 0, 0, NULL);
        SetWindowOrgEx(hdc, 0, 0, NULL);
        SetROP2(hdc, R2_COPYPEN);
        
        ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);

        // If someone does a GpGraphics::GetHdc and sets the clipping,
        // we have to be sure to unset it before using the hdc again.

        SelectClipRgn(hdc, NULL);

        // Do we have to do an EndPath?
    }
    else    // it is an EMF+ HDC
    {
        // record a minimum of commands in the EMF+ file (if any at all)
        BOOL setMapMode = (::GetMapMode(hdc) != MM_TEXT);

        POINT   point;
        point.x = 0;
        point.y = 0;
        ::GetViewportOrgEx(hdc, &point);
        BOOL setViewportOrg = ((point.x != 0) || (point.y != 0));

        point.x = 0;
        point.y = 0;
        ::GetWindowOrgEx(hdc, &point);
        BOOL setWindowOrg = ((point.x != 0) || (point.y != 0));

        BOOL setROP2 = (::GetROP2(hdc) != R2_COPYPEN);

#if 0   // do NOT turn this on -- see comments below

        BOOL setWorldTransform = FALSE;

        // The graphics mode is never GM_ADVANCED on Win9x.

        // On WinNT it gets set to GM_ADVANCED when we are playing an EMF
        // into the hdc.  In that case, we don't want to set the transform
        // to the identity, because it will override the srcRect->destRect
        // transform of the command to play the metafile, which will mess
        // up GDI's transform.
        
        // The only other way we could be in GM_ADVANCED mode is if the
        // application created the EMF hdc themselves and set it to GM_ADVANCED
        // before creating a graphics from the metafile HDC.  That case is
        // currently NOT supported, and the app shouldn't do that!
        // Perhaps we should add code in the constructor to block that case.

        // This test always returns FALSE on Win9x.
        if (::GetGraphicsMode(hdc) == GM_ADVANCED)
        {
            XFORM xformIdentity;
            xformIdentity.eM11 = 1.0f;
            xformIdentity.eM12 = 0.0f;
            xformIdentity.eM21 = 0.0f;
            xformIdentity.eM22 = 1.0f;
            xformIdentity.eDx  = 0.0f;
            xformIdentity.eDy  = 0.0f;

            XFORM xform;
            xform.eM11 = 0.0;

            if (::GetWorldTransform(hdc, &xform))
            {
                setWorldTransform = (GpMemcmp(&xform, &xformIdentity, sizeof(xform)) != 0);
            }
            else
            {
                setWorldTransform = TRUE;
                WARNING1("GetWorldTransform failed");
            }
        }
#endif

        RECT clipRect;
        HRGN hRgnTmp = ::CreateRectRgn(0, 0, 0, 0);
        BOOL setClipping = ((hRgnTmp == NULL) ||
                            (::GetClipRgn(hdc, hRgnTmp) != 0));
        ::DeleteObject(hRgnTmp);

        if (setMapMode)
        {
            ::SetMapMode(hdc, MM_TEXT);
        }
        if (setViewportOrg)
        {
            ::SetViewportOrgEx(hdc, 0, 0, NULL);
        }
        if (setWindowOrg)
        {
            ::SetWindowOrgEx(hdc, 0, 0, NULL);
        }
        if (setROP2)
        {
            ::SetROP2(hdc, R2_COPYPEN);
        }
#if 0   // do NOT turn this on -- see comments above
        if (setWorldTransform)
        {
            ::ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
        }
#endif
        if (setClipping)
        {
            ::SelectClipRgn(hdc, NULL);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Releases the HDC if necessary.
*
* Return Value:
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpContext::ReleaseHdc(
    HDC hdc,
    DpBitmap *surface
    )
{
    if (Hwnd)
    {
        ReleaseDC(Hwnd, hdc);
    }
    else if (!Hdc && surface &&
             (surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(surface->Scan);
        scan->GetBitmap()->ReleaseHdc(hdc);
    }
}

// ResetHdc() restores the HDC to the state in which it was given to us.

VOID DpContext::ResetHdc(VOID)
{
    if (SaveDc)
    {
        RestoreDC(Hdc, SaveDc);
        SaveDc = 0;
    }
} // DpContext::ResetHdc

/**************************************************************************\
*
* Function Description:
*
*   Retrieves the appropriate transform.  Implemented as a routine so that
*   we can do lazy evaluation.
*
* Arguments:
*
*   [OUT] worldToDevice: world to device matrix.
*
* Return Value:
*
*   Ok if the device to world matrix is invertible.  If this is not Ok,
*   the returned matrix is the identity matrix.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
DpContext::GetDeviceToWorld(
    GpMatrix* deviceToWorld
    ) const
{
    GpStatus status = Ok;

    if(!InverseOk)
    {
        if(WorldToDevice.IsInvertible())
        {
            DeviceToWorld = WorldToDevice;
            DeviceToWorld.Invert();
            InverseOk = TRUE;
        }
        else
        {
            DeviceToWorld.Reset();  // reset to identity matrix
            status = GenericError;
        }
    }

    *deviceToWorld = DeviceToWorld;

    return status;
}


// The units we use for the page transform with UnitDisplay depend
// on whether the graphics is associated with a display screen.  If
// it is, then we just use the dpi of the display (which is why we
// call it display units).  Otherwise (e.g. a printer), we use
// 100 dpi for display units.

#define GDIP_DISPLAY_DPI    100.0f

/**************************************************************************\
*
* Function Description:
*
*   Calculate the page multiplier for going from page units to device units.
*   Used to concatenate the page transform with the WorldToPage transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
VOID
DpContext::GetPageMultipliers(
    REAL *              pageMultiplierX,
    REAL *              pageMultiplierY,
    GpPageUnit          unit,
    REAL                scale
    ) const
{
    if ((unit == UnitDisplay) && IsDisplay)
    {
        // The page transform is always the identity if
        // we are rendering to a display, and the unit
        // is UnitDisplay.
        *pageMultiplierX = 1.0f;
        *pageMultiplierY = 1.0f;
        return;
    }

    REAL    multiplierX;
    REAL    multiplierY;

    switch (unit)
    {
      default:
        ASSERT(0);
        // FALLTHRU

        // The units we use for the page transform with UnitDisplay depend
        // on whether the graphics is associated with a display screen.  If
        // it is, then we just use the dpi of the display (which is why we
        // call it display units).  Otherwise (e.g. a printer), we use
        // 100 dpi for display units.

      case UnitDisplay:     // Variable
        // since it's not a display, use the default display dpi of 100
        multiplierX = ContainerDpiX * scale / GDIP_DISPLAY_DPI;
        multiplierY = ContainerDpiY * scale / GDIP_DISPLAY_DPI;
        break;

      case UnitPixel:       // Each unit represents one device pixel.
        multiplierX = scale;
        multiplierY = scale;
        break;

      case UnitPoint:          // Each unit represents a printer's point,
                                // or 1/72 inch.
        multiplierX = ContainerDpiX * scale / 72.0f;
        multiplierY = ContainerDpiY * scale / 72.0f;
        break;

      case UnitInch:        // Each unit represents 1 inch.
        multiplierX = ContainerDpiX * scale;
        multiplierY = ContainerDpiY * scale;
        break;

      case UnitDocument:    // Each unit represents 1/300 inch.
        multiplierX = ContainerDpiX * scale / 300.0f;
        multiplierY = ContainerDpiY * scale / 300.0f;
        break;

      case UnitMillimeter:  // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        multiplierX = ContainerDpiX * scale / 25.4f;
        multiplierY = ContainerDpiY * scale / 25.4f;
        break;
    }
    *pageMultiplierX = multiplierX;
    *pageMultiplierY = multiplierY;
}


/**************************************************************************\
*
* Function Description:
*
*   Prepares the contexts DC for use in an ExtTextOut call for a given
*   font face realization and brush.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   non-NULL   - prepared hdc
*   NULL       - faceRealization or brush could not be represented in a DC
*
* Created:
*
*   3/7/2000 DBrown
*
\**************************************************************************/

const DOUBLE PI = 3.1415926535897932384626433832795;

HDC
DpContext::GetTextOutputHdc(
    const GpFaceRealization *faceRealization,   // In  - Font face required
    GpColor                 color,              // In  - Required GdiPlus brush effect
    DpBitmap                *surface,           // In
    INT                     *angle              // Out
)
{
    ASSERT(angle);

    if (Hwnd)
    {
        // Since GetHdc will create a new DC each time for Graphics created
        // from an hWnd, we can't track the currently selected font, and
        // the overhead of selecting the font and reselecting the original
        // font everytime would be inefficent. Therefore don't optimise text in
        // Graphics created from Hwnds.

        return NULL;
    }


    // GDI can't handle clearTtype or our sort of anti-aliasing

    if (faceRealization->RealizationMethod() != TextRenderingHintSingleBitPerPixelGridFit)
    {
        return NULL;
    }

    // If it is a private font, then we need to go through with GDI+
    if (faceRealization->IsPrivate())
        return NULL;

    // Check whether GDI can handle the brush and font size

    if (!color.IsOpaque())
    {
        return NULL;  // GDI can only handle solid color brushes
    }

    if (faceRealization->GetFontFace()->IsSymbol())
    {
        return NULL;
    }
    
    // GDI can't handle the simulation.
    if (faceRealization->Getprface()->fobj.flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS)) 
    {
        return NULL;  
    }

    if (surface && (surface->Type == DpBitmap::CreationType::GPBITMAP))
        return NULL;
        
    // Check whether GDI can handle the glyph transform

    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;

    SplitTransform(
        faceRealization->Getprface()->mxForDDI,
        scale,
        rotateRadians,
        shear,
        translate);

    if (    scale.X / scale.Y < 0.999
        ||  scale.X / scale.Y > 1.0001)
    {
        return NULL;  // Don't pass non 1:1 aspect ratios to GDI
    }

    if (    shear < -0.0001
        ||  shear > 0.0001)
    {
        return NULL;  // GDI cannot handle shearing
    }


    // Translate rotation from radians in x-up to tenths of a degree in x-down.

    *angle = GpRound(float(3600.0 - (rotateRadians * 1800.0 / PI)));
    if (*angle >= 3600)
    {
        *angle -= 3600;
    }

    // under platform before NT 5.1 if there is a rotation, we need to render through GDI+
    // the main reason is a bug in the TrueType rasterizer that was causing in certain fonts
    // text to be rendered unhinted under 90, 180 and 270 degree rotations
    if ((*angle != 0) && 
        (!Globals::IsNt ||
             (Globals::OsVer.dwMajorVersion < 5) ||
             ((Globals::OsVer.dwMajorVersion == 5) && (Globals::OsVer.dwMinorVersion < 1)) ) )
        return NULL;

    // Prepare hdc for ExtTextOut

    HDC hdc = GetHdc(surface);

    if (!hdc)
        return NULL;

    INT style = faceRealization->Getprface()->Face->GetFaceStyle();

    // Select the font if not already selected by a previous caller

    GpStatus status = Ok;
    if (CurrentHFont == 0 || Face != faceRealization->Getprface()->Face
        ||  !FontTransform.IsEqual(&faceRealization->Getprface()->mxForDDI)
        ||  Style != style)
    {
        Face          = faceRealization->Getprface()->Face;
        FontTransform = faceRealization->Getprface()->mxForDDI;
        Style         = style;
        
        status = UpdateCurrentHFont(
                    NONANTIALIASED_QUALITY,
                    scale, 
                    *angle, 
                    hdc,
                    FALSE); // Sideway
    }

    if (status == Ok)
        status = SelectCurrentHFont(hdc);

    if (status != Ok)
    {
        ReleaseHdc(hdc);
        return NULL;
    }

    if (GetBkMode(hdc) != TRANSPARENT)
        SetBkMode(hdc, TRANSPARENT);

    COLORREF colorRef = color.ToCOLORREF();

    SetTextColor(hdc, colorRef);

    if (GetTextAlign(hdc) != TA_BASELINE)    
        SetTextAlign(hdc, TA_BASELINE);  // !!! may need VTA_BASELINE or VTA_CENTRE for vertical?
    return hdc;
}

VOID DpContext::ReleaseTextOutputHdc(HDC hdc)
{
    ::SelectObject(hdc, OriginalHFont);
    OriginalHFont = NULL;
    ReleaseHdc(hdc);
} // DpContext::ReleaseTextOutputHdc

VOID DpContext::DeleteCurrentHFont()
{
    ASSERT(OriginalHFont == 0);
    if (CurrentHFont)
    {
        ::DeleteObject(CurrentHFont);
        CurrentHFont = 0;
    }
} // DpContext::DeleteCurrentHFont

GpStatus DpContext::UpdateCurrentHFont(
        BYTE quality,
        const PointF & scale,
        INT angle,
        HDC hdc,
        BOOL sideway,
        BYTE charSet
)
{
    if (charSet == 0xFF)
        charSet = Face->GetCharset(hdc);
    DeleteCurrentHFont();
    const LONG emHeight = GpRound(Face->GetDesignEmHeight() * scale.Y);
    const LONG emWidth = 0;
    LONG rotateDeciDegrees = angle;
    const LONG weight = (Style & FontStyleBold) ? 700 : 400;
    const BYTE fItalic = (Style & FontStyleItalic) ? TRUE : FALSE;

    if (sideway)
    {
        rotateDeciDegrees -= 900;
        if (rotateDeciDegrees < 0)
        {
            rotateDeciDegrees += 3600;
        }
    }

    // the GP_IFIMETRICS* Face->pifi is internally created structure
    // so we trust it is honestly null-terminated
    const WCHAR* pwszFamilyName = (const WCHAR*)( (BYTE*)Face->pifi + Face->pifi->dpwszFamilyName );
    int sizeFamilyName = wcslen(pwszFamilyName) + 1;  // including terminating null

    if (Globals::IsNt) {

        LOGFONTW lfw = {
            -emHeight,
            emWidth,
            rotateDeciDegrees,
            rotateDeciDegrees,
            weight,
            fItalic,
            0,
            0,
            charSet,     // charset
            OUT_TT_ONLY_PRECIS,
            0,
            quality,
            0,
            L""};

        if (sideway)
        {
            if (sizeFamilyName + 1 > LF_FACESIZE)
                return GenericError;

            lfw.lfFaceName[0] = 0x0040;  // @
            memcpy(&lfw.lfFaceName[1], pwszFamilyName, sizeFamilyName*sizeof(WCHAR));
        }
        else
        {
            if (sizeFamilyName > LF_FACESIZE)
                return GenericError;

            memcpy(&lfw.lfFaceName[0], pwszFamilyName, sizeFamilyName*sizeof(WCHAR));
        }
        CurrentHFont = CreateFontIndirectW(&lfw);
    }
    else
    {
        // ANSI version for Win9X

        LOGFONTA lfa = {
            -emHeight,
            emWidth,
            rotateDeciDegrees,
            rotateDeciDegrees,
            weight,
            fItalic,
            0,
            0,
            charSet,       // charset
            OUT_TT_ONLY_PRECIS,
            0,
            quality,
            0,
            ""};

        if (sideway)
        {
            if (sizeFamilyName + 1 > LF_FACESIZE)
                return GenericError;

            lfa.lfFaceName[0] = 0x40;  // @
            
            UnicodeToAnsiStr(
                pwszFamilyName,
                &lfa.lfFaceName[1],
                LF_FACESIZE-1
            );
        }
        else
        {
            if (sizeFamilyName > LF_FACESIZE)
                return GenericError;

            UnicodeToAnsiStr(
                pwszFamilyName,
                lfa.lfFaceName,
                LF_FACESIZE
            );
        }
        CurrentHFont = CreateFontIndirectA(&lfa);
    }
    if (CurrentHFont == NULL)
    {
        return GenericError;
    }
    return Ok;
} // DpContext::UpdateCurrentHFont

GpStatus DpContext::SelectCurrentHFont(HDC hdc)
{
    ASSERT(CurrentHFont != 0 && OriginalHFont == 0);
    OriginalHFont = (HFONT)::SelectObject(hdc, CurrentHFont);
    if (OriginalHFont == 0)
        return GenericError;
    return Ok;
} // DpContext::SelectCurrentHFont


// Used only when recording a EMF or EMF+ through GpMetafile class
VOID
DpContext::SetMetafileDownLevelRasterizationLimit(
    UINT                    metafileRasterizationLimitDpi
    )
{
    if (metafileRasterizationLimitDpi > 0)
    {
        ASSERT(metafileRasterizationLimitDpi >= 10);
        MetafileRasterizationLimitDpi = (REAL)metafileRasterizationLimitDpi;
    }
    else
    {
        MetafileRasterizationLimitDpi = max(ContainerDpiX, ContainerDpiY);
        ASSERT(MetafileRasterizationLimitDpi >= 10);
    }
    DpContext *          prev = Prev;
    
    // The MetafileRasterizationLimitDpi cannot be different in any
    // other saved context of the graphics.  Update them all.
    while (prev != NULL)
    {
        prev->MetafileRasterizationLimitDpi = MetafileRasterizationLimitDpi;
        prev = prev->Prev;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dpdriver.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*
*
* Abstract:
*
*
*
* Notes:
*
*
*
* Created:
*
*   //1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

DpDriver::DpDriver()
{
    Internal = new DpDriverInternal;
    Device = NULL;

}

DpDriver::~DpDriver()
{
    delete Internal;

    SetValid(FALSE);    // so we don't use a deleted object
}

// If we let the clipping region height get too large, then GDI will allocate
// tons of memory when we select the clip path in.
#define GDI_MAX_REGION_HEIGHT_FOR_GDI   65536

// Returns TRUE if we succeed in setting the clipping using
// path clipping.
static BOOL
SetupPathClipping(
    HDC                 hdc,
    const DpContext *   context,
    BOOL                doSaveDC,
    const GpRect *      drawBounds
    )
{
    // We can use the actual clip path to set up the clipping
    // under the following circumstances:
    //      1) the application clipping has only one path
    //      2) the container clip is simple (a single rect)
    //         which either fully encompasses the application clipping
    //         or else the application clipping is also a single rect
    //         and the intersection of the 2 rects can be used.
    // We could expand this criteria to include more cases, but for
    // now, this is sufficient.

    const GpRegion *    appClip       = &(context->AppClip);
    const DpRegion *    containerClip = &(context->ContainerClip);

    if (appClip->IsOnePath() && containerClip->IsSimple())
    {
        // ContainerClip is a single rect
        // It may be inifinte, but it shouldn't be empty at this point.
        GpRect      pathRect;
        GpRect      containerBounds;
        GpRect      appBounds;
        GpMatrix    identityMatrix;

        containerClip->GetBounds(&containerBounds);
        appClip->GetBounds(&identityMatrix, &appBounds);
        if (appClip->IsRect())
        {
            GpRect::IntersectRect(pathRect, appBounds, containerBounds);
            if (doSaveDC)
            {
                ::SaveDC(hdc);
            }

            // Use IntersectClipRect (not BeginPath, Rectangle, EndPath),
            // because mf3216.dll assumes that
            // path clipping means do XOR, black, XOR technique, and
            // we don't want that if we are playing a metafile into
            // another metafile.

            ::IntersectClipRect(hdc,
                                pathRect.GetLeft(),
                                pathRect.GetTop(),
                                pathRect.GetRight(),
                                pathRect.GetBottom());
            return TRUE;
        }
        else  // use the AppClip as the clip path
        {
            ConvertPathToGdi gdiPath(appClip->GetPath(), &identityMatrix, ForFill);
            if (gdiPath.IsValid())
            {
                if (doSaveDC)
                {
                    ::SaveDC(hdc);
                }
                gdiPath.AndClip(hdc);
                if ((appBounds.GetLeft()   < containerBounds.GetLeft())  ||
                    (appBounds.GetRight()  > containerBounds.GetRight()) ||
                    (appBounds.GetTop()    < containerBounds.GetTop())   ||
                    (appBounds.GetBottom() > containerBounds.GetBottom()))
                {
                    ::IntersectClipRect(hdc,
                                        containerBounds.GetLeft(),
                                        containerBounds.GetTop(),
                                        containerBounds.GetRight(),
                                        containerBounds.GetBottom());
                }
                return TRUE;
            }
        }
    }
    else
    {
        const DpClipRegion *    clipRegion = &(context->VisibleClip);
        DpClipRegion            intersectClip(drawBounds);
        GpRect                  clipBounds;

        if (intersectClip.IsValid())
        {
            clipRegion->GetBounds(&clipBounds);

            // GDI doesn't handle large clip regions very well -- it uses
            // the height of the region to decide how much memory to allocate,
            // so can end up allocating huge amounts of memory.  An example
            // of this is to take an infinite region and exclude a rect from
            // it and then clip to that region.  To solve this problem,
            // intersect the clip region with the drawBounds (which are hopefully
            // a reasonable size).

            if (clipBounds.Height >= GDI_MAX_REGION_HEIGHT_FOR_GDI)
            {
                intersectClip.And(clipRegion);
                if (intersectClip.IsValid())
                {
                    clipRegion = &intersectClip;
                }
            }

            GpPath      path(clipRegion);

            if (path.IsValid())
            {
                GpMatrix         identityMatrix;
                ConvertPathToGdi gdiPath(&path, &identityMatrix, ForFill);
                if (gdiPath.IsValid())
                {
                    if (doSaveDC)
                    {
                        ::SaveDC(hdc);
                    }
                    gdiPath.AndClip(hdc);
                    return TRUE;
                }
            }
        }

    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Set up the clipping in the HDC for the GDI primitive
*
* Arguments:
*
*   [IN]  hdc        - The device to set the clipping in
*   [IN]  clipRegion - The region to clip to
*   [IN]  drawBounds - The bounds of the object being drawn
*   [OUT] isClip     - Whether or not we are clipping the object
*
* Return Value:
*
*   N/A
*
* Created:
*
*   9/15/1999 DCurtis
*
\**************************************************************************/
VOID
DpDriver::SetupClipping(
    HDC                 hdc,
    DpContext *         context,
    const GpRect *      drawBounds,
    BOOL &              isClip,
    BOOL &              usePathClipping,
    BOOL                forceClipping
    )
{
    // VisibleClip is the combination of the AppClip and the ContainerClip.
    // The ContainerClip is always intersected with the WindowClip.
    DpClipRegion *      clipRegion = &(context->VisibleClip);

    // We set wantPathClipping to be what the user wants to do. This way
    // when we return usePathClipping is true only if we did indeed setup a
    // path clipping
    BOOL wantPathClipping = usePathClipping;
    usePathClipping = FALSE;
    isClip = FALSE;

    if (forceClipping ||
        (clipRegion->GetRectVisibility(
                    drawBounds->X, drawBounds->Y,
                    drawBounds->GetRight(),
                    drawBounds->GetBottom()) != DpRegion::TotallyVisible))
    {
        if (clipRegion->IsSimple())
        {
            isClip = TRUE;
            GpRect clipRect;
            clipRegion->GetBounds(&clipRect);
            ::SaveDC(hdc);

            // If we have an infinite region don't intersect
            if (!clipRegion->IsInfinite())
            {
                ::IntersectClipRect(hdc, clipRect.X, clipRect.Y,
                                    clipRect.GetRight(), clipRect.GetBottom());
            }
            return;
        }

        // I'm assuming that by now we've already decided that the
        // drawBounds is at least partially visible.  Otherwise, we're
        // going to a lot of trouble here for nothing.

        // When writing a metafile, we always want to use path clipping
        // so that the clipping scales properly when being played back.
        if (wantPathClipping)
        {
            if (SetupPathClipping(hdc, context, TRUE, drawBounds))
            {
                isClip = TRUE;
                usePathClipping = TRUE;
                return;
            }
        }

        // Either we're not supposed to use path clipping, or else
        // path clipping failed for some reason, so use the region
        // to clip.
        // Since this might get saved out to a metafile, we need
        // to Save the DC, and restore it once the clipping is back
        // so that we don't overwrite the application's clipping
        HRGN        hRgn = clipRegion->GetHRgn();
        if (hRgn != (HRGN)0)
        {
            ::SaveDC(hdc);
            ::ExtSelectClipRgn(hdc, hRgn, RGN_AND);
            ::DeleteObject(hRgn);
            isClip = TRUE;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore the clipping state in the HDC
*
* Arguments:
*
*   [IN]  hdc        - The device to set the clipping in
*   [IN]  isClip     - If clipping was turned on or not
*
* Return Value:
*
*   N/A
*
* Created:
*
*   9/15/1999 DCurtis
*
\**************************************************************************/
VOID
DpDriver::RestoreClipping(
    HDC                 hdc,
    BOOL                isClip,
    BOOL                usePathClipping
    )
{
    if (isClip)
    {
        // Restore the DC in both cases for PathClipping or
        // for region clipping
        ::RestoreDC(hdc, -1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\pathiterator.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathIterator.cpp
*
* Abstract:
*
*   Implementation of the DpPathTypeIterator and DpPathIterator classes
*
* Revision History:
*
*   11/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

VOID
DpPathTypeIterator::SetTypes(const BYTE* types, INT count)
{
    if(types && count > 0)
    {
        Types = types;
        Count = count;

        // Set Valid flag to TRUE so that CheckValid()
        // can call NextSubpath() and NextPathType().

        SetValid(TRUE);
        SetValid(CheckValid());
    }
    else
        Initialize();
}

// !!! bhouse CheckValid should not be required
//
// When we create an iterator, we should be able to provide
// data that is consistent and that does not need to be
// checked.
// Also, CheckValid actually has side effects like determining
// whether the path has beziers and calculating sub-path count.
// These should be provided at iterator creation time or taken
// out of the source path for which the iterator is created.
// The reasoning is that this data should persist beyond the
// lifespan of the iterator so that we do not have to keep
// re-calculating information that can be calculated once and
// stored with the path.


BOOL
DpPathTypeIterator::CheckValid()
{
    if(Count < 0)
        return FALSE;
    else if(Count == 0) // Allow an empty path.
        return TRUE;
    else
    {
        // If Count > 0 and Types = NULL, the path is not valid.

        if(Types == NULL)
        return FALSE;
    }

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isValid = TRUE;

    Rewind();

    INT subpathCount = 0;

    HasBezier = FALSE;
    ExtendedPath = FALSE;

    while(
        NextSubpath(&startIndex, &endIndex, &isClosed)
        && isValid
        )
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType = PathPointTypeStart;

        if(endIndex == startIndex && Count > 1)
        {
            // This is a case when the next subpath has only one point.

            isValid = FALSE;
        }

        while(
            NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && isValid
            )
        {
            INT count = typeEndIndex - typeStartIndex + 1;
            INT order = (INT) pathType;

            switch(pathType)
            {
            case PathPointTypeStart:
                // This happens when there is only one point
                // in a path.

                if(count == 1)
                    isValid;
                else
                {
                    ASSERT(("Invalid path type."));
                    isValid = FALSE;
                }
                break;

            // The number of the Bezier points must be in the form of
            // n*order + 1.

            case PathPointTypeBezier3:
                if(count % order != 1)
                    isValid = FALSE;
                if(!HasBezier)
                    HasBezier = TRUE;
                if(order != 3 && !ExtendedPath)
                    ExtendedPath = TRUE;
                break;           
            
            case PathPointTypeLine:
                break;

            default:            
                // Undefined path type.

                WARNING(("Undefined path type."));
                isValid = FALSE;
                break;
            }
        }

        subpathCount++;
    }

    Rewind();

    SubpathCount = subpathCount;

    return isValid;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the index range of the next subpah.
*
* Arguments:
*
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*   [OUT] isClosed   - TRUE is the next subpath is closed.
*
* Return Value:
*
*   Retuns the sumber of points in the next subpath.
*   Returns 0 if there is no more subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextSubpath(
    INT* startIndex,
    INT* endIndex,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = Count;

    if(SubpathEndIndex >= count - 1)
        return 0;

    INT i;

    // Set the starting index of the current subpath.

    if(SubpathEndIndex <= 0)
    {
        SubpathStartIndex = 0;
        i = 1;
    }
    else
    {
        SubpathStartIndex = SubpathEndIndex + 1;
        SubpathEndIndex = SubpathStartIndex;
        i = SubpathStartIndex + 1;
    }

    BOOL hasData = FALSE;
    INT segmentCount = 0;

    const BYTE* types = Types + i;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            segmentCount++;
            if(hasData)
            {
                break;
            }
            else
            {
                // Skip the consequtive move segments in the beginning of a subpath.

                SubpathStartIndex = i;
                SubpathEndIndex = SubpathStartIndex;
                i++;
                types++;
            }
        }
        if(segmentCount > 0 && hasData)
        {
            SubpathEndIndex = i - 1;
            break;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;

        while(i < count && (*types & PathPointTypePathTypeMask) != PathPointTypeStart)
        {
            i++;
            types++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            hasData = TRUE;
        }
    }

    *startIndex = SubpathStartIndex;
    if(i >= count)
        SubpathEndIndex = count - 1;    // The last subpath.
    *endIndex = SubpathEndIndex;
    segmentCount = SubpathEndIndex - SubpathStartIndex + 1;

    if(segmentCount > 1)
    {
        // If there is the close flag this subpath is closed.

        if((Types[SubpathEndIndex] & PathPointTypeCloseSubpath))
        {
            *isClosed = TRUE;
        }
        else
            *isClosed = FALSE;
    }
    else
        *isClosed = FALSE;
    
    // Set the start and end index of type to be the starting index of
    // the current subpath.  NextPathType() will start from the
    // beginning of the current subpath.

    TypeStartIndex = SubpathStartIndex;
    TypeEndIndex = -1;  // Indicate that this is the first type
                        // in the current subpath.
    
    // Set the current index to the start index of the subpath.

    Index = SubpathStartIndex;

    return segmentCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the path type, and the index range of the next segment.
*   This must be used after NextSubpath() is called.  This returns only
*   the next segment within the current subpath.
*
* Arguments:
*
*   [OUT] pathType   - the type of the next segment ignoring the closed
*                       and other flags.
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*
* Return Value:
*
*   Retuns the sumber of points in the next segment.
*   Returns 0 if there is no more segment in the current subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextPathType(
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    if(TypeEndIndex >= SubpathEndIndex)
        return 0;   // There is no more segment in the current subpath.

    INT count = SubpathEndIndex + 1;    // Limit for the ending index.

    if(TypeEndIndex <= 0)
        TypeEndIndex = SubpathStartIndex;   // This is the first type.

    TypeStartIndex = TypeEndIndex;
    INT i = TypeStartIndex;
    INT segmentCount = 0;

    i++;    // Go to the next point.

    const BYTE* types = Types + i;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            // Move the start and end index.

            TypeStartIndex = i;
            TypeEndIndex = TypeStartIndex;
            i++;
            types++;
            segmentCount++;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = *types & PathPointTypePathTypeMask;
        while(i < count && (*types & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            types++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            TypeEndIndex = TypeStartIndex + segmentCount;
            *pathType = nextType;
            break;
        }
    }

    *startIndex = TypeStartIndex;
    *endIndex = TypeEndIndex;
    segmentCount = TypeEndIndex - TypeStartIndex + 1;

    return segmentCount;   
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the index range of the next subpah.
*
* Arguments:
*
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*   [OUT] isClosed   - TRUE is the next subpath is closed.
*
* Return Value:
*
*   Retuns the sumber of points in the next subpath.
*   Returns 0 if there is no more subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextMarker(
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = Count;

    if(MarkerEndIndex >= count - 1)
        return 0;

    INT i;

    // Set the starting index of the current subpath.

    if(MarkerEndIndex <= 0)
    {
        MarkerStartIndex = 0;
        i = 1;
    }
    else
    {
        MarkerStartIndex = MarkerEndIndex + 1;
        MarkerEndIndex = MarkerStartIndex;
        i = MarkerStartIndex + 1;
    }

    const BYTE* types = Types + i;
    BOOL hasData = FALSE;

    while(i < count && (*types & PathPointTypePathMarker) == 0)
    {
        i++;
        types++;
    }

    if(i < count)
        MarkerEndIndex = i;
    else
        MarkerEndIndex = count - 1;

    *startIndex = MarkerStartIndex;
    *endIndex = MarkerEndIndex;
    INT segmentCount = MarkerEndIndex - MarkerStartIndex + 1;
    
    // Set the start and end index of type to be the starting index of
    // the current marker.  NextSubpath() and NextPathType() will
    // start from the beginning of the current current marked path.

    SubpathStartIndex = SubpathEndIndex = MarkerStartIndex;
    TypeStartIndex = TypeEndIndex = MarkerStartIndex;
    
    // Set the current index to the start index of the subpath.

    Index = MarkerStartIndex;

    return segmentCount;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the control type in the given index is in dash mode.
*   Otherwise this returns FALSE.  If the given index is outside of
*   the range this returns FALSE.  A user must know the range of the
*   index beforehand to find the correct information.
*
\**************************************************************************/
BOOL DpPathTypeIterator::IsDashMode(INT index)
{
    if(!IsValid() || Count == 0 || index < 0 || index >= Count)
        return FALSE;

    return (Types[index] & PathPointTypeDashMode);
}

DpPathIterator::DpPathIterator(
    const DpPath* path
    )
{
    Initialize();

    if(path)
    {
        const BYTE* types = path->GetPathTypes();
        const GpPointF* points = path->GetPathPoints();
        INT count = path->GetPointCount();
        SetData(points, types, count);
    }
}

VOID
DpPathIterator::SetData(
    const GpPointF* points,
    const BYTE* types,
    INT count
    )
{
    if(points && types && count > 0)
    {
        Points = points;
        Types = types;
        Count = count;

        // Set Valid flag to TRUE so that CheckValid()
        // can call NextSubpath() and NextPathType().

        SetValid(TRUE);
        SetValid(CheckValid());
    }
    else
        Initialize();
}

VOID
DpPathIterator::SetData(
    const DpPath* path
    )
{
    if(path)
    {
        const BYTE* types = path->GetPathTypes();
        const GpPointF* points = path->GetPathPoints();
        INT count = path->GetPointCount();
        SetData(points, types, count);
    }
    else
        Initialize();
}

INT
DpPathIterator::NextSubpath(
    INT* startIndex,
    INT* endIndex,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0)
    {
        return 0;
    }

    BOOL closed = TRUE;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextSubpath(&start, &end, &closed);

    *startIndex = start;
    *endIndex = end;
    *isClosed = closed;

    return count;
}

INT
DpPathIterator::NextSubpath(
    DpPath* path,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0 || !path)
    {
        return 0;
    }

    BOOL closed = TRUE;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextSubpath(&start, &end, &closed);

    GpPathData pathData;
    pathData.Count = count;
    pathData.Points = (GpPointF*) &Points[start];
    pathData.Types = (BYTE*) &Types[start];

    path->SetPathData(&pathData);

    *isClosed = closed;

    return count;
}

INT
DpPathIterator::NextMarker(
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = DpPathTypeIterator::NextMarker(startIndex, endIndex);

    return count;
}

INT
DpPathIterator::NextMarker(
    DpPath* path
    )
{
    if(!IsValid() || Count == 0 || !path)
        return 0;

    BOOL closed;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextMarker(&start, &end);

    GpPathData pathData;
    pathData.Count = count;
    pathData.Points = (GpPointF*) &Points[start];
    pathData.Types = (BYTE*) &Types[start];

    path->SetPathData(&pathData);

    return count;
}

/**************************************************************************\
*
* Function Description:
*
* This retrieves the next points and types up to the number count.
* This does not copy the unnecessary (consequetive) move points.
* This fills up the data until the count number is reached.  This fills
* data beyond the current subpath.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] count - the number of points to be copied (request).
*
* Retrun Value:
*   Returns the total number of the retrieved points.
*
\**************************************************************************/

INT
DpPathIterator::Enumerate(
    GpPointF* points,
    BYTE* types,
    INT count
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT totalNumber = 0;
    INT number = EnumerateWithinSubpath(points, types, count);

    while(number > 0)
    {
        totalNumber += number;
        count -= number;

        if(count > 0)
        {
            points += number;
            types += number;
            number = EnumerateWithinSubpath(points, types, count);
        }
        else
            number = 0;
    }

    return totalNumber;
}


/**************************************************************************\
*
* Function Description:
*
* This retrieves the next points and types up to the number count.
* This does not copy the unnecessary (consequetive) move points.
* This fills up the data until the count number is reached or the
* end of the current subopath is reached.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] count - the number of points to be copied (request).
*
* Retrun Value:
*   Returns the total number of the retrieved points.
*
\**************************************************************************/

INT
DpPathIterator::EnumerateWithinSubpath(
    GpPointF* points,
    BYTE* types,
    INT count
    )
{
    if(!IsValid() || Count == 0 || count <= 0 || !points || !types)
        return 0;

    INT startIndex, endIndex;
    BOOL isClosed;
    INT segmentCount;

    if(Index == 0)
        segmentCount = NextSubpath(&startIndex, &endIndex, &isClosed);

    if(Index > SubpathEndIndex)
        segmentCount = NextSubpath(&startIndex, &endIndex, &isClosed);
    else
        segmentCount = SubpathEndIndex - SubpathStartIndex + 1;

    if(segmentCount == 0)
        return 0;   // No more segment.

    count = min(count, SubpathEndIndex - Index + 1);
    
    if(count > 0)
    {
        GpMemcpy(points, Points + Index, count*sizeof(GpPointF));
        GpMemcpy(types, Types + Index, count);
        Index += count;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
* This copies the data stored in Points and Types arrays
* in the index range between startIndex and endIndex.
* This may copy unnecessary (consequetive) move points.
* startIndex and endIndex must be within the index range of
* the original data.  Otherwise, this does not copy the data
* and returns 0.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] startIndex - start index of the origianl data
* [IN] endIndex - end index of the origianl data.
*
* Retrun Value:
*   Returns the total number of the copied points.
*
\**************************************************************************/

INT
DpPathIterator::CopyData(
    GpPointF* points,
    BYTE* types,
    INT startIndex,
    INT endIndex
    )
{
    if(!IsValid() || Count == 0 || startIndex < 0 || endIndex >= Count
        || startIndex > endIndex || !points || !types)
        return 0;

    INT count = endIndex - startIndex + 1;

    ASSERT(count > 0);

    GpMemcpy(points, Points + startIndex, count*sizeof(GpPointF));
    GpMemcpy(types, Types + startIndex, count);
    Index += count;

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dpregion.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpRegion.cpp
*
* Abstract:
*
*   DpRegion class operates on scan-converted Y spans of rects
*
* Created:
*
*   12/17/1998 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

//#define DEBUG_REGION 1

/**************************************************************************\
*
* Function Description:
*
*   Do a binary search of the horizontal tessellation structure to find
*   the Y Span containing y.  If y is inside a Y Span, that span will be
*   returned.  If y is inside the region extent but not inside a Y Span,
*   the span whose yMin > y will be returned.  If y is less than the region
*   extent, the first Y span will be returned.  If y is greater than the
*   region extent, the last Y Span will be returned.
*
* Arguments:
*
*   [IN]  y              - y value to search for
*   [OUT] ySpanFound     - y span pointer found by the search
*   [OUT] spanIndexFound - y span index found by the search
*
* Return Value:
*
*   TRUE  - found a y span that includes the y value
*   FALSE - the y span does not include the y value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpComplexRegion::YSpanSearch(
    INT     y,
    INT **  ySpanFound,
    INT *   spanIndexFound
    )
{
    INT     indexMin    = 0;
    INT     indexMax    = NumYSpans - 1;
    INT     indexMiddle = YSearchIndex;
    INT *   ySpan       = GetYSpan (indexMiddle);

    ASSERT((indexMiddle >= indexMin) && (indexMiddle <= indexMax));

    for (;;)
    {
        if (y >= ySpan[YSPAN_YMIN])
        {
            if (y < ySpan[YSPAN_YMAX])
            {
                *ySpanFound     = ySpan;
                *spanIndexFound = indexMiddle;
                return TRUE;
            }
            else
            {
                // If only 1 span, this could go past the indexMax
                indexMin = indexMiddle + 1;
            }
        }
        else
        {
            indexMax = indexMiddle;
        }

        if (indexMin >= indexMax)
        {
            ySpan           = GetYSpan (indexMax);
            *ySpanFound     = ySpan;
            *spanIndexFound = indexMax;
            return  (y >= ySpan[YSPAN_YMIN]) && (y < ySpan[YSPAN_YMAX]);
        }

        // If there are only 2 elements left to check, then
        // indexMiddle is set to indexMin.

        indexMiddle = (indexMin + indexMax) >> 1;
        ySpan       = GetYSpan (indexMiddle);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is inside this region.
*
* Arguments:
*
*   [IN]  x - x coordinate of point
*   [IN]  y - y coordinate of point
*
* Return Value:
*
*   TRUE  - point is inside the region
*   FALSE - point is not inside the region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::PointInside(
    INT     x,
    INT     y
    )
{
    ASSERT(IsValid());

    if (ComplexData == NULL)
    {
#if 0
        if (Infinite)
        {
            return TRUE;
        }
        if (Empty)
        {
            return FALSE;
        }
#endif
        return ((x >= XMin) && (x < XMax) &&
                (y >= YMin) && (y < YMax));
    }
    else
    {
        INT *       ySpan;
        INT         ySpanIndex;

        ComplexData->ResetSearchIndex();
        if (ComplexData->YSpanSearch (y, &ySpan, &ySpanIndex))
        {
            INT *   xSpan;
            INT     numXCoords;

            xSpan      = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
            numXCoords = ySpan[YSPAN_XCOUNT];

            for (;;)
            {
                if (x < xSpan[1])
                {
                    if (x >= xSpan[0])
                    {
                        return TRUE;
                    }
                    break;
                }
                if ((numXCoords -= 2) <= 0)
                {
                    break;
                }
                xSpan += 2;
            }
        }
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine the visibility of the specified rectangle.
*
*   Note that some rects that could return ClippedVisible end up returning
*   PartiallyVisible (for performance reasons).
*
* Arguments:
*
*   [IN]  xMin        - minimum x of rect
*   [IN]  yMin        - minimum y of rect
*   [IN]  xMax        - maximum x of rect (exclusive)
*   [IN]  yMax        - maximum y of rect (exclusive)
*   [OUT] rectClipped - used when ClippedVisible is returned (can be NULL)
*
* Return Value:
*
*   Visibility
*       Invisible        - rect is completely outside all region rects
*       TotallyVisible   - rect is completely inside a region rect
*       ClippedVisible   - rect intersects 1 and only 1 region rect
*       PartiallyVisible - rect partially intersects at least 1 region rect
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::Visibility
DpRegion::GetRectVisibility(
    INT         xMin,
    INT         yMin,
    INT         xMax,       // exclusive
    INT         yMax,       // exclusive
    GpRect *    rectClipped
    )
{
    ASSERT(IsValid());
    ASSERT((xMin < xMax) && (yMin < yMax));

    Visibility  visibility = ClippedVisible;

    if (Infinite)
    {
IsTotallyVisible:
        if (rectClipped != NULL)
        {
            rectClipped->X      = xMin;
            rectClipped->Y      = yMin;
            rectClipped->Width  = xMax - xMin;
            rectClipped->Height = yMax - yMin;
        }
        return TotallyVisible;
    }

    BOOL    simpleRegion = (ComplexData == NULL);

    if (!Empty)
    {
        // If it is a simple region (only 1 rect) and the specified rect is
        // completely inside the region, then trivially accept it
        if (simpleRegion &&
            (xMin >= XMin) && (yMin >= YMin) &&
            (xMax <= XMax) && (yMax <= YMax))
        {
            goto IsTotallyVisible;
        }

        // Try to trivially reject rectangle.
        if ((xMax > XMin) && (xMin < XMax) &&
            (yMax > YMin) && (yMin < YMax))
        {
            // Couldn't trivially reject
            // If simple region, clip it against the region
            if (simpleRegion)
            {
ClipToRgnExtent:
                if (rectClipped)
                {
                    INT     xMinTmp = (xMin > XMin) ? xMin : XMin;
                    INT     xMaxTmp = (xMax < XMax) ? xMax : XMax;
                    INT     yMinTmp = (yMin > YMin) ? yMin : YMin;
                    INT     yMaxTmp = (yMax < YMax) ? yMax : YMax;

                    rectClipped->X      = xMinTmp;
                    rectClipped->Y      = yMinTmp;
                    rectClipped->Width  = xMaxTmp - xMinTmp;
                    rectClipped->Height = yMaxTmp - yMinTmp;
                }
                return visibility;
            }

            // else not a simple region -- see if the rect falls
            // within one of the region rects

            INT *           ySpanYMin;
            INT *           ySpanYMax;
            INT *           xSpan;
            INT             numXCoords;
            INT             ySpanIndex;
            BOOL            yMinInside;
            BOOL            yMaxInside;

            // Don't resetSearchIndex() here cause if we're calling this
            // from regionOverlaps, we want to search from where we left off
            // the last time.
            yMinInside = ComplexData->YSpanSearch(
                                    yMin,
                                    &ySpanYMin,
                                    &ySpanIndex);

            ComplexData->YSearchIndex = ySpanIndex;
            yMaxInside = ComplexData->YSpanSearch(
                                    yMax - 1,
                                    &ySpanYMax,
                                    &ySpanIndex);

            // See if both values are inside the same Y span
            // so that we are totally visible in Y
            if (yMinInside && yMaxInside && (ySpanYMin == ySpanYMax))
            {
                xSpan      = ComplexData->XCoords + ySpanYMin[YSPAN_XOFFSET];
                numXCoords = ySpanYMin[YSPAN_XCOUNT];

                for (;;)
                {
                    if (xMax <= xSpan[0])
                    {
                        goto IsInvisible;
                    }
                    if (xMin < xSpan[1])
                    {
                        // we found an intersection!
                        if (xMax <= xSpan[1])
                        {
                            if (xMin >= xSpan[0])
                            {
                                goto IsTotallyVisible;
                            }
                            if (rectClipped != NULL)
                            {
                                rectClipped->X      = xSpan[0];
                                rectClipped->Width  = xMax - xSpan[0];
                                rectClipped->Y      = yMin;
                                rectClipped->Height = yMax - yMin;
                            }
                            return ClippedVisible;
                        }
                        // we could look ahead to see if we are clipped visible
                        visibility = PartiallyVisible;
                        goto ClipToRgnExtent;
                    }
                    // continue on with loop through x spans

                    if ((numXCoords -= 2) <= 0)
                    {
                        break;
                    }
                    xSpan += 2;
                }
                goto IsInvisible;
            }

            // See if the rect intersects with at least one X Span
            // within the set of Y Spans it crosses

            // If yMax was not inside a span, ySpanYMax could be
            // one span too far
            if (yMax <= ySpanYMax[YSPAN_YMIN])
            {
                ySpanYMax -= YSPAN_SIZE;
            }
            INT *   ySpan = ySpanYMin;

            for (;;)
            {
                xSpan      = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
                numXCoords = ySpan[YSPAN_XCOUNT];

                for (;;)
                {
                    if (xMax <= xSpan[0])
                    {
                        break;
                    }
                    if (xMin < xSpan[1])
                    {
                        visibility = PartiallyVisible;
                        goto ClipToRgnExtent;
                    }
                    // continue on with loop through x spans

                    if ((numXCoords -= 2) <= 0)
                    {
                        break;
                    }
                    xSpan += 2;
                }

                if (ySpan >= ySpanYMax)
                {
                    break;
                }
                ySpan += YSPAN_SIZE;
            }
        }
    }

IsInvisible:
    // couldn't find a span that it intersected
    if (rectClipped)
    {
        rectClipped->X      = 0;
        rectClipped->Y      = 0;
        rectClipped->Width  = 0;
        rectClipped->Height = 0;
    }
    return Invisible;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region overlaps (intersects) this
*   region at all.
*
* Arguments:
*
*   [IN]  region - region to test visibility of
*
* Return Value:
*
*   BOOL - whether region is at least partially visible or not
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RegionVisible(
    DpRegion *  region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || region->Empty)
    {
        return FALSE;
    }
    if (Infinite || region->Infinite)
    {
        return TRUE;
    }
    else // neither is empty or infinite
    {
        Visibility      visibility = GetRectVisibility(
                                            region->XMin,
                                            region->YMin,
                                            region->XMax,
                                            region->YMax);

        if (visibility == TotallyVisible)
        {
            return TRUE;
        }
        if (visibility == Invisible)
        {
            return FALSE;
        }
        if ((ComplexData == NULL) && (region->ComplexData == NULL))
        {
            return TRUE;
        }
        else
        {
            INT *           ySpan;
            INT *           ySpanLast;
            INT *           xSpan;
            INT *           xCoords;
            INT             numXCoords;
            INT             yMin;
            INT             yMax;
            INT             ySpanTmp[YSPAN_SIZE];
            INT             xCoordsTmp[2];

            if (region->ComplexData == NULL)
            {
                ySpan                = ySpanTmp;
                ySpanLast            = ySpanTmp;

                ySpan[YSPAN_YMIN]    = region->YMin;
                ySpan[YSPAN_YMAX]    = region->YMax;
                ySpan[YSPAN_XOFFSET] = 0;
                ySpan[YSPAN_XCOUNT]  = 2;

                xCoords              = xCoordsTmp;
                xCoords[0]           = region->XMin;
                xCoords[1]           = region->XMax;
            }
            else
            {
                DpComplexRegion *   complexData = region->ComplexData;
                ySpan     = complexData->YSpans;
                ySpanLast = ySpan + ((complexData->NumYSpans - 1) * YSPAN_SIZE);
                xCoords   = complexData->XCoords;
            }

            if (ComplexData != NULL)
            {
                ComplexData->ResetSearchIndex();
            }

            do
            {
                yMin = ySpan[YSPAN_YMIN];
                yMax = ySpan[YSPAN_YMAX];

                if (yMin >= YMax)
                {
                    break;  // doesn't overlap
                }
                if (yMax > YMin)
                {
                    xSpan      = xCoords + ySpan[YSPAN_XOFFSET];
                    numXCoords = ySpan[YSPAN_XCOUNT];

                    for (;;)
                    {
                        if (GetRectVisibility(xSpan[0], yMin, xSpan[1], yMax) !=
                                Invisible)
                        {
                            return TRUE;
                        }
                        if ((numXCoords -= 2) <= 0)
                        {
                            break;
                        }
                        xSpan += 2;
                    }
                }

            } while ((ySpan += YSPAN_SIZE) <= ySpanLast);
        }
    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect intersects this region.
*
* Arguments:
*
*   [IN]  xMin - minimum x coordinate of rect
*   [IN]  yMin - minimum y coordinate of rect
*   [IN]  xMax - maximum x coordinate of rect
*   [IN]  yMax - maximum y coordinate of rect
*
* Return Value:
*
*   BOOL
*       TRUE  - rect intersects this region
*       FALSE - rect does not intersect this region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RectVisible(
    INT     xMin,
    INT     yMin,
    INT     xMax,
    INT     yMax
    )
{
    ASSERT(IsValid());

    // Do Trivial Rejection Test
    if ((xMin >= XMax) || (xMax <= XMin) ||
        (yMin >= YMax) || (yMax <= YMin) ||
        (xMin >= xMax) || (yMin >= yMax)) // must test for empty rect too
    {
        return FALSE;
    }

    if (ComplexData == NULL)
    {
        return TRUE;
    }

    ComplexData->ResetSearchIndex();

    return (GetRectVisibility(xMin, yMin, xMax, yMax) != Invisible);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect intersects this region.
*
* Arguments:
*
*   [IN]  xMin - minimum x coordinate of rect
*   [IN]  yMin - minimum y coordinate of rect
*   [IN]  xMax - maximum x coordinate of rect
*   [IN]  yMax - maximum y coordinate of rect
*
* Return Value:
*
*   BOOL
*       TRUE  - rect intersects this region
*       FALSE - rect does not intersect this region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RectInside(
    INT     xMin,
    INT     yMin,
    INT     xMax,
    INT     yMax
    )
{
    ASSERT(IsValid());

    // Do Trivial Rejection Test
    if ((xMin < XMin) || (xMax > XMax) ||
        (yMin < YMin) || (yMax > YMax))
    {
        return FALSE;
    }

    if (ComplexData == NULL)
    {
        return TRUE;
    }

    ComplexData->ResetSearchIndex();

    return (GetRectVisibility(xMin, yMin, xMax, yMax) == TotallyVisible);
}

#define YSPAN_INC   16

GpStatus
DpRegionBuilder::InitComplexData(
    INT     ySpans  // estimate of number of y spans required for region
    )
{
    if (ySpans < YSPAN_INC)
    {
        ySpans = YSPAN_INC;
    }

    INT     xCoordsCapacity;

    for (;;)
    {
        xCoordsCapacity = ySpans * 4;

        ComplexData = static_cast<DpComplexRegion *>(
                GpMalloc(sizeof(DpComplexRegion) +
                (ySpans * (YSPAN_SIZE * sizeof(*(ComplexData->YSpans)))) +
                (xCoordsCapacity * sizeof(*(ComplexData->XCoords)))));
        if (ComplexData != NULL)
        {
            break;
        }
        ySpans >>= 1;
        if (ySpans <= (YSPAN_INC / 2))
        {
            return OutOfMemory;
        }
    }

    DpComplexRegion *   complexData = ComplexData;

    complexData->XCoordsCapacity = xCoordsCapacity;
    complexData->XCoordsCount    = 0;
    complexData->YSpansCapacity  = ySpans;
    complexData->NumYSpans       = 0;
    complexData->YSearchIndex    = 0;
    complexData->XCoords         = reinterpret_cast<INT *>(complexData + 1);
    complexData->YSpans          = complexData->XCoords + xCoordsCapacity;
    XMin = XMax = YMin = YMax = 0;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Traverse through the region, clipping as you go, doing a fill using
*   the specified output object.
*
* Arguments:
*
*   [IN] output     - the object used to output the region spans
*   [IN] clipBounds - the bounds to clip to (if any)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Fill(
    DpOutputSpan *      output,
    GpRect *            clipBounds
    ) const
{
    GpStatus        status = Ok;

    if (!Empty)
    {
        INT     y;
        INT     xMin;
        INT     yMin;
        INT     xMax;
        INT     yMax;

        if (Infinite)
        {
            ASSERT(clipBounds != NULL);
            if (clipBounds != NULL)
            {
                xMin = clipBounds->X;
                xMax = clipBounds->GetRight();
                yMax = clipBounds->GetBottom();

                for (y = clipBounds->Y; (y < yMax) && (status == Ok); y++)
                {
                    status = output->OutputSpan(y, xMin, xMax);
                }
            }
        }
        else if (ComplexData == NULL)
        {
            xMin = XMin;
            yMin = YMin;
            xMax = XMax;
            yMax = YMax;

            if (clipBounds != NULL)
            {
                if (xMin < clipBounds->X)
                {
                    xMin = clipBounds->X;
                }
                if (yMin < clipBounds->Y)
                {
                    yMin = clipBounds->Y;
                }
                if (xMax > clipBounds->GetRight())
                {
                    xMax = clipBounds->GetRight();
                }
                if (yMax > clipBounds->GetBottom())
                {
                    yMax = clipBounds->GetBottom();
                }
            }
            for (y = yMin; (y < yMax) && (status == Ok); y++)
            {
                status = output->OutputSpan(y, xMin, xMax);
            }
        }
        else // complex region
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                    ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT *               xCoords;
            INT *               xSpan;
            INT                 numXCoords;
            INT                 numXSpan;

            if (clipBounds != NULL)
            {
                INT     ySpanIndex;

                complexData->ResetSearchIndex();
                if (YMin < clipBounds->Y)
                {
                    complexData->YSpanSearch(clipBounds->Y,
                                             &ySpan, &ySpanIndex);
                }
                if (YMax > clipBounds->GetBottom())
                {
                    complexData->YSpanSearch(clipBounds->GetBottom(),
                                             &ySpanLast, &ySpanIndex);
                }
            }
            xCoords = complexData->XCoords + ySpan[YSPAN_XOFFSET];
            for (;;)
            {
                yMin       = ySpan[YSPAN_YMIN];
                yMax       = ySpan[YSPAN_YMAX];
                numXCoords = ySpan[YSPAN_XCOUNT];

                // [agodfrey] We must clip our output range to the clip region.
                // Bug #122789 showed that, otherwise, we can take inordinately
                // long to execute. In the bug's specific case, the loop below
                // executed 67 million iterations before getting to the
                // first unclipped scan.

                if (clipBounds != NULL)
                {
                    if (yMin < clipBounds->Y)
                    {
                        yMin = clipBounds->Y;
                    }

                    if (yMax > clipBounds->GetBottom())
                    {
                        yMax = clipBounds->GetBottom();
                    }
                }

                // The code below assumes that yMax > yMin. We think this should
                // be satisfied because the clipBounds and yspan should both
                // be non-empty, and yMax >= clipBounds->Y since the code
                // above searched for a yspan which intersects the clip bounds.

                // NTRAID#NTBUG9-393985-2001/05/16-asecchia
                // This ASSERT is overactive and fires when there is no real
                // crash problem, however there is a performance issue that
                // should be addressed - see RAID bug.
                
                // ASSERT(yMax > yMin);

                if (numXCoords == 2)
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;
                    do
                    {
                        status = output->OutputSpan(yMin, xMin, xMax);

                    } while ((++yMin < yMax) && (status == Ok));
                }
                else
                {
                    do
                    {
                        for (xSpan = xCoords, numXSpan = numXCoords;;)
                        {
                            numXSpan -= 2;
                            status = output->OutputSpan(yMin,xSpan[0],xSpan[1]);
                            if (status != Ok)
                            {
                                goto Done;
                            }
                            if (numXSpan < 2)
                            {
                                break;
                            }
                            xSpan += 2;
                        }

                    } while (++yMin < yMax);

                    xCoords += numXCoords;
                }
                if (ySpan >= ySpanLast)
                {
                    break;
                }
                ySpan += YSPAN_SIZE;
            }
        }
    }
Done:
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Impelement GpOutputYSpan interface to create the region
*   data from the path data, using the rasterizer.
*   Exclusive in yMax and in the xMax'es.
*
* Arguments:
*
*   [IN] yMin       - min y of this span
*   [IN] yMax       - max y of this span
*   [IN] xCoords    - array of x coordinates (in pairs of x min, x max)
*   [IN] numXCoords - number of x coordinates in xCoords array
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegionBuilder::OutputYSpan(
    INT             yMin,
    INT             yMax,
    INT *           xCoords,    // even number of X coordinates
    INT             numXCoords  // must be a multiple of 2
    )
{
    ASSERT(IsValid());

    DpComplexRegion *   complexData = ComplexData;
    INT                 numYSpans   = complexData->NumYSpans;

#ifdef USE_YSPAN_BUILDER
    if (numYSpans > 0)
    {
        // Try to add this row to the previous row,
        // if the scans are the same and the y's match up
        INT *       ySpanPrev;
        INT *       xSpanPrev;
        INT         numXCoordsPrev;

        ySpanPrev = complexData->GetYSpan(numYSpans - 1);
        xSpanPrev = complexData->XCoords + ySpanPrev[YSPAN_XOFFSET];
        numXCoordsPrev = ySpanPrev[YSPAN_XCOUNT];

        if ((numXCoordsPrev == numXCoords) &&
            (ySpanPrev[YSPAN_YMAX] >= yMin)  &&
            (GpMemcmp (xSpanPrev, xCoords, numXCoords * sizeof(INT)) == 0))
        {
            // Yes, it did match -- just set the new yMax and return
            YMax = yMax;
            ySpanPrev[YSPAN_YMAX] = yMax;
            return Ok;
        }
    }

    // no previous spans or doesn't match previous spans
#endif

    INT                 xCount = complexData->XCoordsCount;
    INT *               ySpan;
    INT *               xArray;

    if ((complexData->YSpansCapacity > numYSpans) &&
        (complexData->XCoordsCapacity >= (xCount + numXCoords)))
    {
        complexData->NumYSpans++;
        complexData->XCoordsCount += numXCoords;
    }
    else // need more capacity
    {
        // We want to have YSPAN_INC Y spans available and
        // to have YSPAN_INC * 4 X coords available after we
        // add this data.
        INT     newYSpansCapacity  = numYSpans + (YSPAN_INC + 1);
        INT     newXCoordsCapacity = xCount + numXCoords + (YSPAN_INC * 4);
        DpComplexRegion *  oldData = complexData;

        complexData = static_cast<DpComplexRegion *>(
          GpMalloc(sizeof(DpComplexRegion) +
          (newYSpansCapacity * (YSPAN_SIZE * sizeof(*(oldData->YSpans)))) +
          (newXCoordsCapacity * sizeof(*(oldData->XCoords)))));

        if (complexData == NULL)
        {
            return OutOfMemory;
        }
        ComplexData = complexData;

        complexData->XCoordsCapacity = newXCoordsCapacity;
        complexData->XCoordsCount    = xCount + numXCoords;
        complexData->YSpansCapacity  = newYSpansCapacity;
        complexData->NumYSpans       = numYSpans + 1;
        complexData->YSearchIndex    = 0;
        complexData->XCoords         = reinterpret_cast<INT *>(complexData + 1);
        complexData->YSpans          = complexData->XCoords +
                                            newXCoordsCapacity;

        GpMemcpy(complexData->XCoords, oldData->XCoords,
                    xCount * sizeof(*(complexData->XCoords)));

        GpMemcpy(complexData->YSpans, oldData->YSpans,
                    numYSpans * (YSPAN_SIZE * sizeof(*(complexData->YSpans))));

        GpFree (oldData);
    }
    xArray = complexData->XCoords +  xCount;
    ySpan  = complexData->YSpans  + (numYSpans * YSPAN_SIZE);

    ySpan[YSPAN_YMIN]    = yMin;            // y Start (Min)
    ySpan[YSPAN_YMAX]    = yMax;            // y End   (Max)
    ySpan[YSPAN_XOFFSET] = xCount;          // XCoords index
    ySpan[YSPAN_XCOUNT]  = numXCoords;      // number of X's

    GpMemcpy (xArray, xCoords, numXCoords * sizeof(xArray[0]));

    if (numYSpans == 0)
    {
        YMin = yMin;
        XMin = xCoords[0];
        XMax = xCoords[numXCoords - 1];
    }
    else
    {
        if (XMin > xCoords[0])
        {
            XMin = xCoords[0];
        }
        if (XMax < xCoords[numXCoords - 1])
        {
            XMax = xCoords[numXCoords - 1];
        }
    }

    YMax = yMax;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to either empty or to infinite, depending on the value of empty.
*
* Arguments:
*
*   [IN] empty - if non-zero, initialize to empty else to infinite
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    BOOL    empty
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;

    if (!empty)
    {
        // set to infinite
        Infinite = TRUE;
        Empty    = FALSE;

        XMin     = INFINITE_MIN;
        YMin     = INFINITE_MIN;
        XMax     = INFINITE_MAX;
        YMax     = INFINITE_MAX;
    }
    else
    {
        // set to empty
        Infinite = FALSE;
        Empty    = TRUE;

        XMin     = 0;
        YMin     = 0;
        XMax     = 0;
        YMax     = 0;
    }

    SetValid(TRUE);
    UpdateUID();
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to the specified rect.
*
* Arguments:
*
*   [IN] rect - rect to use for the region coverage area
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const GpRect *  rect
    )
{
    ASSERT (rect != NULL);

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    Set(rect->X, rect->Y, rect->Width, rect->Height);
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to the specified list of rects, which must be in the same order
*   as our YSpan data.
*
* Arguments:
*
*   [IN] rects - rects to use for the region coverage area
*   [IN] count - number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/04/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const RECT *    rects,
    INT             count
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(rects, count) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Set to the specified list of rects, which must be in the same order
*   as our YSpan data.
*
* Arguments:
*
*   [IN] rects - rects to use for the region coverage area
*   [IN] count - number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/04/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const RECT *    rects,
    INT             count
    )
{
    if ((rects == NULL) || (count <= 0))
    {
        SetEmpty();
        return Ok;
    }

    if (count == 1)
    {
OneRect:
        Set(rects->left, rects->top,
            rects->right - rects->left,
            rects->bottom - rects->top);
        return Ok;
    }

    // Verify the first rect(s) to make sure they're not empty
    for (;;)
    {
        // Ignore any empty rects at the beginning of the list
        if ((rects->top  < rects->bottom) &&
            (rects->left < rects->right))
        {
            break;
        }

        WARNING1("Empty or Invalid Rect");
        rects++;
        if (--count == 1)
        {
            goto OneRect;
        }
    }

    {
        DpRegionBuilder     regionBuilder(count);

        if (regionBuilder.IsValid())
        {
            INT     yMin = rects->top;
            INT     yMax = rects->bottom;
            BOOL    failed = FALSE;

            DynArrayIA<INT,32>  xCoords;

            if(xCoords.ReserveSpace(count * 2) != Ok)
                goto ErrorExit;

            xCoords.Add(rects->left);
            xCoords.Add(rects->right);

            for (INT i = 1; i < count; i++)
            {
                // Ignore empty rects
                if ((rects[i].top  < rects[i].bottom) &&
                    (rects[i].left < rects[i].right))
                {
                    if (rects[i].top != yMin)
                    {
                        if (regionBuilder.OutputYSpan(yMin, yMax,
                                xCoords.GetDataBuffer(), xCoords.GetCount()) != Ok)
                        {
                            goto ErrorExit;
                        }

                        ASSERT(rects[i].top >= yMax);

                        xCoords.SetCount(0);
                        yMin = rects[i].top;
                        yMax = rects[i].bottom;
                    }

                    xCoords.Add(rects[i].left);
                    xCoords.Add(rects[i].right);
                }
                else
                {
                    WARNING1("Empty or Invalid Rect");
                }
            }

            if (xCoords.GetCount() > 0)
            {
                if (regionBuilder.OutputYSpan(yMin, yMax,
                        xCoords.GetDataBuffer(), xCoords.GetCount()) != Ok)
                {
                    goto ErrorExit;
                }
            }

            return Set(regionBuilder);
        }
    }

ErrorExit:
    SetEmpty();
    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Make this region be the specified rect.
*
* Arguments:
*
*   [IN] x       - starting x coordinate of rect
*   [IN] y       - starting y coordinate of rect
*   [IN] width   - width of rect
*   [IN] height  - height of rect
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    INT     x,
    INT     y,
    INT     width,
    INT     height
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    Set(x, y, width, height);
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region be the specified rect.
*
* Arguments:
*
*   [IN] x       - starting x coordinate of rect
*   [IN] y       - starting y coordinate of rect
*   [IN] width   - width of rect
*   [IN] height  - height of rect
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::Set(
    INT     x,
    INT     y,
    INT     width,
    INT     height
    )
{
    ASSERT(IsValid());
    ASSERT((width >= 0) && (height >= 0));

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    if ((width  > 0) && (width  < INFINITE_SIZE) &&
        (height > 0) && (height < INFINITE_SIZE))
    {
        FreeData();

        SetValid(TRUE);
        Infinite  = FALSE;
        Empty     = FALSE;
        UpdateUID();

        XMin     = x;
        YMin     = y;
        XMax     = x + width;
        YMax     = y + height;
    }
    else if ((width <= 0) || (height <= 0))
    {
        SetEmpty();
    }
    else
    {
        SetInfinite();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the region to a cleared state with an empty coverage area.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::SetEmpty()
{
    ASSERT(IsValid());

    FreeData();

    SetValid(TRUE);
    Infinite   = FALSE;
    Empty      = TRUE;
    UpdateUID();


    XMin     = 0;
    YMin     = 0;
    XMax     = 0;
    YMax     = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the region to contain an infinite coverage area.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::SetInfinite()
{
    ASSERT(IsValid());

    FreeData();

    SetValid(TRUE);
    Infinite  = TRUE;
    Empty     = FALSE;
    UpdateUID();

    XMin     = INFINITE_MIN;
    YMin     = INFINITE_MIN;
    XMax     = INFINITE_MAX;
    YMax     = INFINITE_MAX;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.
*   Make this region cover the area specified by the path.
*
* Arguments:
*
*   [IN] path   - specifies the coverage area in world units
*   [IN] matrix - matrix to apply to the path
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const DpPath *      path,
    const GpMatrix *    matrix
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(path, matrix) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region cover the area specified by the path.
*
* Arguments:
*
*   [IN] path   - specifies the coverage area in world units
*   [IN] matrix - matrix to apply to the path
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const DpPath *      path,
    const GpMatrix *    matrix
    )
{
    ASSERT(IsValid());
    ASSERT ((path != NULL) && (matrix != NULL));

    GpRect  bounds;

    path->GetBounds(&bounds, matrix);

    DpRegionBuilder     regionBuilder(bounds.Height);

    if (regionBuilder.IsValid())
    {
#ifndef USE_YSPAN_BUILDER

        GpRectBuilder   rectBuilder(&regionBuilder);

        if (rectBuilder.IsValid() &&
            (Rasterizer(path, matrix, path->GetFillMode(), &rectBuilder) == Ok))
        {
            return Set(regionBuilder);
        }
#else
        GpYSpanBuilder   ySpanBuilder(&regionBuilder);

        if (ySpanBuilder.IsValid() &&
            (Rasterizer(path, matrix, path->GetFillMode(), &ySpanBuilder) ==Ok))
        {
            return Set(regionBuilder);
        }
#endif // USE_YSPAN_BUILDER
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region be a copy of the data in the specified region builder.
*
* Arguments:
*
*   [IN] regionBuilder - contains the simple or complex region data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    DpRegionBuilder &   regionBuilder
    )
{
    ASSERT(IsValid());

    DpComplexRegion *   srcComplexData = regionBuilder.ComplexData;

    if (srcComplexData != NULL)
    {
        if ((srcComplexData->NumYSpans == 1) &&
            (srcComplexData->XCoordsCount == 2))
        {
            Set(regionBuilder.XMin, regionBuilder.YMin,
                regionBuilder.XMax - regionBuilder.XMin,
                regionBuilder.YMax - regionBuilder.YMin);
            return Ok;
        }
        if (srcComplexData->NumYSpans >= 1)
        {
            ASSERT(srcComplexData->XCoordsCount >= 2);

            DpComplexRegion *   destComplexData = NULL;

            FreeData();

            SetValid(TRUE);
            Infinite   = FALSE;
            Empty      = FALSE;
            UpdateUID();


            XMin     = regionBuilder.XMin;
            YMin     = regionBuilder.YMin;
            XMax     = regionBuilder.XMax;
            YMax     = regionBuilder.YMax;

            if ((srcComplexData->YSpansCapacity - srcComplexData->NumYSpans) >=
                YSPAN_INC)
            {
                destComplexData = static_cast<DpComplexRegion *>(
                    GpMalloc(sizeof(DpComplexRegion) +
                            (srcComplexData->NumYSpans *
                            (YSPAN_SIZE * sizeof(*(srcComplexData->YSpans)))) +
                            (srcComplexData->XCoordsCount *
                            sizeof(*(srcComplexData->XCoords)))));
            }

            if (destComplexData != NULL)
            {
                destComplexData->XCoordsCapacity = srcComplexData->XCoordsCount;
                destComplexData->XCoordsCount    = srcComplexData->XCoordsCount;

                destComplexData->YSpansCapacity  = srcComplexData->NumYSpans;
                destComplexData->NumYSpans       = srcComplexData->NumYSpans;

                destComplexData->XCoords =
                                reinterpret_cast<INT*>(destComplexData + 1);
                destComplexData->YSpans  = destComplexData->XCoords +
                                           destComplexData->XCoordsCapacity;

                GpMemcpy (destComplexData->XCoords,
                          srcComplexData->XCoords,
                          srcComplexData->XCoordsCount *
                          sizeof(*(destComplexData->XCoords)));

                GpMemcpy (destComplexData->YSpans,
                          srcComplexData->YSpans,
                          srcComplexData->NumYSpans *
                          (YSPAN_SIZE * sizeof(*(destComplexData->YSpans))));
            }
            else
            {
                destComplexData = srcComplexData;
                regionBuilder.ComplexData = NULL;
            }
            destComplexData->ResetSearchIndex();
            ComplexData = destComplexData;
            return Ok;
        }
    }

    // else empty
    SetEmpty();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor - makes a copy of the specified region
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const DpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT((region != NULL) && region->IsValid());

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(region, lazy) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Copy constructor
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    DpRegion &  region
    )
{
    ASSERT(region.IsValid());

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(&region) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Makes this region be a copy of another source region.
*
* Arguments:
*
*   [IN] region - region to copy.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const DpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region != NULL)
    {
        GpStatus            status = Ok;
        DpComplexRegion *   srcComplexData = region->ComplexData;

        if (srcComplexData == NULL)
        {
            Set (region->XMin, region->YMin,
                 region->XMax - region->XMin,
                 region->YMax - region->YMin);
            return Ok;
        }

        if ((region == this) && !Lazy)
        {
            return Ok;
        }

        FreeData();

        if (!lazy)
        {
            ComplexData = static_cast<DpComplexRegion*>(
                GpMalloc(sizeof(DpComplexRegion) +
                    (srcComplexData->NumYSpans *
                    (YSPAN_SIZE * sizeof(*(ComplexData->YSpans)))) +
                    (srcComplexData->XCoordsCount *
                    sizeof(*(ComplexData->XCoords)))));

            if (ComplexData == NULL)
            {
                ASSERT(0);
                SetValid(FALSE);
                return OutOfMemory;
            }

            DpComplexRegion *   destComplexData = ComplexData;

            destComplexData->XCoordsCapacity = srcComplexData->XCoordsCount;
            destComplexData->XCoordsCount    = srcComplexData->XCoordsCount;

            destComplexData->YSpansCapacity  = srcComplexData->NumYSpans;
            destComplexData->NumYSpans       = srcComplexData->NumYSpans;

            destComplexData->ResetSearchIndex();

            destComplexData->XCoords= reinterpret_cast<INT*>(destComplexData+1);
            destComplexData->YSpans = destComplexData->XCoords +
                                      destComplexData->XCoordsCapacity;

            GpMemcpy (destComplexData->XCoords,
                    srcComplexData->XCoords,
                    srcComplexData->XCoordsCount *
                    sizeof(*(destComplexData->XCoords)));

            GpMemcpy (destComplexData->YSpans,
                    srcComplexData->YSpans,
                    srcComplexData->NumYSpans *
                    (YSPAN_SIZE * sizeof(*(destComplexData->YSpans))));
        }
        else
        {
            ComplexData = srcComplexData;
            Lazy        = TRUE;
        }

        SetValid(TRUE);
        Empty    = FALSE;
        Infinite = FALSE;
        UpdateUID();

        XMin     = region->XMin;
        YMin     = region->YMin;
        XMax     = region->XMax;
        YMax     = region->YMax;

        return Ok;
    }

    return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
*   assignment operator.
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion &
DpRegion::operator=(
    DpRegion & region
    )
{
    ASSERT(IsValid());
    ASSERT(region.IsValid());

    Set (&region);  // what do we do if this fails?
    return *this;   // Assignment operator returns left side.
}

/**************************************************************************\
*
* Function Description:
*
*   Offset (translate) the region by the specified offset values
*
* Arguments:
*
*   [IN] xOffset - x offset (delta) value
*   [IN] yOffset - y offset (delta) value
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Offset(
    INT     xOffset,
    INT     yOffset
    )
{
    ASSERT(IsValid());

    if ((xOffset | yOffset) != 0)
    {
        // copy the data, so it's not a lazy copy
        if (Lazy && (Set(this) != Ok))
        {
            return GenericError;
        }

        if (Infinite || Empty)
        {
            return Ok;
        }

        if (xOffset != 0)
        {
            XMin += xOffset;
            XMax += xOffset;

            // !!! Handle this for non-debug case
            ASSERT((XMin >= INFINITE_MIN) && (XMin <= INFINITE_MAX));
            ASSERT((XMax >= INFINITE_MIN) && (XMax <= INFINITE_MAX));

            if (ComplexData != NULL)
            {
                INT *   xCoords = ComplexData->XCoords;
                INT     count   = ComplexData->XCoordsCount;

                while (count >= 2)
                {
                    xCoords[0] += xOffset;
                    xCoords[1] += xOffset;
                    xCoords += 2;
                    count -= 2;
                }
            }
        }
        if (yOffset != 0)
        {
            YMin += yOffset;
            YMax += yOffset;

            // !!! Handle this for non-debug case
            ASSERT((YMin >= INFINITE_MIN) && (YMin <= INFINITE_MAX));
            ASSERT((YMax >= INFINITE_MIN) && (YMax <= INFINITE_MAX));

            if (ComplexData != NULL)
            {
                INT *   ySpans = ComplexData->YSpans;
                INT     count  = ComplexData->NumYSpans;

                while (count > 0)
                {
                    ySpans[YSPAN_YMIN] += yOffset;
                    ySpans[YSPAN_YMAX] += yOffset;
                    ySpans += YSPAN_SIZE;
                    count--;
                }
            }
        }
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   See if another region is identical in coverage to this one.
*   For this to work, infinite regions must all have the same data.
*
* Arguments:
*
*   [IN] region - region to compare with
*
* Return Value:
*
*   TRUE    - regions cover the same area
*   FALSE   - regions not identical
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::IsEqual(
    DpRegion *  region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (!Empty)
    {
        if ((XMin == region->XMin) &&
            (YMin == region->YMin) &&
            (XMax == region->XMax) &&
            (YMax == region->YMax))
        {
            if (ComplexData == NULL)
            {
                return (region->ComplexData == NULL);
            }
            if (region->ComplexData == NULL)
            {
                return FALSE;
            }
            if (ComplexData->NumYSpans == region->ComplexData->NumYSpans)
            {
                // If the ySpans are the same, then the size of the
                // xCoords buffers should also be the same.
                return ((GpMemcmp (ComplexData->YSpans,
                                   region->ComplexData->YSpans,
                                   ComplexData->NumYSpans *
                                   YSPAN_SIZE * sizeof(INT)) == 0) &&
                        (GpMemcmp (ComplexData->XCoords,
                                   region->ComplexData->XCoords,
                                   ComplexData->XCoordsCount *
                                   sizeof(INT)) == 0));
            }
        }
        return FALSE;
    }
    return region->Empty;
}

/**************************************************************************\
*
* Function Description:
*
*   Add Y Span data to a regionBuilder, compacting the data as we go.
*   Used by the region combine methods.
*
* Arguments:
*
*   [IN] yMin          - min y of this span
*   [IN] yMax          - max y of this span
*   [IN] xCoords       - array of x coordinates (in pairs of x min, x max)
*   [IN] numXCoords    - number of x coordinates in xCoords array
*   [IN] regionBuilder - the region builder that stores the data
*   [IN] combineCoords - used to compact the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::CompactAndOutput(
    INT                 yMin,
    INT                 yMax,
    INT *               xCoords,
    INT                 numXCoords,
    DpRegionBuilder *   regionBuilder,
    DynIntArray *       combineCoords
    )
{
    // numEdgeCoords could be 0 when this is called from the combine code
    if (numXCoords > 0)
    {
        if (numXCoords > 2)
        {
            // Try to compact the X Span data.
            // First, make a copy of the data if we need to
            // so we can compact it in place.
            if (combineCoords != NULL)
            {
                combineCoords->Reset(FALSE);
                if (combineCoords->AddMultiple(xCoords, numXCoords) != Ok)
                {
                    return OutOfMemory;
                }
                xCoords = combineCoords->GetDataBuffer();
            }

            INT         indexDest = 0;
            INT         index     = 2;
            INT         indexLast = numXCoords - 2;

            numXCoords = 2;
            do
            {
                if ((xCoords[indexDest + 1]) >= xCoords[index])
                {
                    xCoords[indexDest + 1] = xCoords[index + 1];
                    index += 2;
                }
                else
                {
                    indexDest  += 2;
                                        if (indexDest != index)
                                        {
                                                xCoords[indexDest]   = xCoords[index];
                                                xCoords[indexDest+1] = xCoords[index+1];
                                        }
                    index      += 2;
                    numXCoords += 2;
                }
            } while (index <= indexLast);
        }

#ifndef USE_YSPAN_BUILDER
        DpComplexRegion *   complexData = regionBuilder->ComplexData;

        if (complexData->NumYSpans > 0)
        {
            // Try to add this row to the previous row,
            // if the scans are the same and the y's match up
            INT *       ySpanPrev;
            INT *       xSpanPrev;
            INT         numXCoordsPrev;

            ySpanPrev = complexData->GetYSpan(complexData->NumYSpans - 1);
            xSpanPrev = complexData->XCoords + ySpanPrev[YSPAN_XOFFSET];
            numXCoordsPrev = ySpanPrev[YSPAN_XCOUNT];

            if ((numXCoordsPrev == numXCoords) &&
                (ySpanPrev[YSPAN_YMAX] >= yMin)  &&
                (GpMemcmp (xSpanPrev, xCoords, numXCoords * sizeof(INT)) == 0))
            {
                // Yes, it did match -- just set the new yMax and return
                regionBuilder->YMax = yMax;
                ySpanPrev[YSPAN_YMAX] = yMax;
                return Ok;
            }
        }
#endif // USE_YSPAN_BUILDER

        return regionBuilder->OutputYSpan(yMin, yMax, xCoords, numXCoords);
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the AND operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::And(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || (region->Infinite) || (region == this))
    {
        return Ok;
    }
    if (Infinite)
    {
        return Set(region);
    }
    if (region->Empty)
    {
        SetEmpty();
        return Ok;
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        return Ok;
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        return Set(region);
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        SetEmpty();
        return Ok;
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(numYSpans1 + numYSpans2);

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 <= yMin2)
            {
                if (yMax1 > yMin2)
                {
                    if (XSpansAND(
                            &combineCoords,
                            xCoords1 + ySpan1[YSPAN_XOFFSET],
                            ySpan1[YSPAN_XCOUNT],
                            xCoords2 + ySpan2[YSPAN_XOFFSET],
                            ySpan2[YSPAN_XCOUNT]) == Ok)
                    {
                        if (yMax1 <= yMax2)
                        {
                            if (CompactAndOutput(
                                    yMin2,
                                    yMax1,
                                    combineCoords.GetDataBuffer(),
                                    combineCoords.GetCount(),
                                    &regionBuilder, NULL) == Ok)
                            {
                                goto AndIncYSpan1;
                            }
                        }
                        else
                        {
                            if (CompactAndOutput(
                                    yMin2,
                                    yMax2,
                                    combineCoords.GetDataBuffer(),
                                    combineCoords.GetCount(),
                                    &regionBuilder, NULL) == Ok)
                            {
                                goto AndIncYSpan2;
                            }
                        }
                    }
                    return GenericError;
                }
                goto AndIncYSpan1;
            }
            if (yMax2 > yMin1)
            {
                if (XSpansAND(
                        &combineCoords,
                        xCoords1 + ySpan1[YSPAN_XOFFSET],
                        ySpan1[YSPAN_XCOUNT],
                        xCoords2 + ySpan2[YSPAN_XOFFSET],
                        ySpan2[YSPAN_XCOUNT]) == Ok)
                {
                    if (yMax2 <= yMax1)
                    {
                        if (CompactAndOutput(
                                yMin1,
                                yMax2,
                                combineCoords.GetDataBuffer(),
                                combineCoords.GetCount(),
                                &regionBuilder, NULL) == Ok)
                        {
                            goto AndIncYSpan2;
                        }
                    }
                    else
                    {
                        if (CompactAndOutput(
                                yMin1,
                                yMax1,
                                combineCoords.GetDataBuffer(),
                                combineCoords.GetCount(),
                                &regionBuilder, NULL) == Ok)
                        {
                            goto AndIncYSpan1;
                        }
                    }
                }
                return GenericError;
            }
            // else goto AndIncYSpan2

AndIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

AndIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                break;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the AND operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansAND(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];

        for (;;)
        {
            if (xMin1 <= xMin2)
            {
                if (xMax1 > xMin2)
                {
                    XCoords[count++] = xMin2;       // left
                    if (xMax1 <= xMax2)
                    {
                        XCoords[count++] = xMax1;   // right
                        goto AndIncXSpan1;
                    }
                    XCoords[count++] = xMax2;       // right
                    goto AndIncXSpan2;
                }
                goto AndIncXSpan1;
            }
            if (xMax2 > xMin1)
            {
                XCoords[count++] = xMin1;           // left
                if (xMax2 <= xMax1)
                {
                    XCoords[count++] = xMax2;       // right
                    goto AndIncXSpan2;
                }
                XCoords[count++] = xMax1;           // right
                goto AndIncXSpan1;
            }
            // else goto AndIncXSpan2;

AndIncXSpan2:
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xSpan2 += 2;
            xMin2    = xSpan2[0];
            xMax2    = xSpan2[1];
            continue;

AndIncXSpan1:
            if ((numXCoords1 -= 2) < 2)
            {
                break;
            }
            xSpan1 += 2;
            xMin1    = xSpan1[0];
            xMax1    = xSpan1[1];
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the OR operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Or(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Infinite || region->Empty || (region == this))
    {
        return Ok;
    }
    if (region->Infinite)
    {
        SetInfinite();
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        Set(region->XMin, region->YMin,
            region->XMax - region->XMin,
            region->YMax - region->YMin);
        return Ok;
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        return Ok;
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(numYSpans1 + numYSpans2);
        BOOL            done = FALSE;
        INT             numXCoords;
        INT *           xSpan;

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 < yMin2)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (yMax1 <= yMin2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto OrIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMin2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin1 = yMin2;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            else if (yMin1 > yMin2)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (yMax2 <= yMin1)
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMax2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto OrIncYSpan2;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMin1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin2 = yMin1;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            // else if (yMin1 == yMin2)
            if (XSpansOR (
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 < yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin2 = yMax1;
                        goto OrIncYSpan1;
                    }
                }
                else if (yMax1 > yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto OrIncYSpan2;
                    }
                }
                else // if (yMax1 == yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto OrIncYSpanBoth;
                    }
                }
            }
            return GenericError;

OrIncYSpanBoth:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                done = TRUE;
            }
            else
            {
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }

            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto OrCheckMoreY2Spans;
            }
            else
            {
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }

            if (done)
            {
                break;
            }
            continue;

OrIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

OrIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto OrCheckMoreY2Spans;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }

        if (ySpan1 <= ySpan1Last)
        {
            for (;;)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan1 += YSPAN_SIZE;
                if (ySpan1 > ySpan1Last)
                {
                    break;
                }
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }
        }

OrCheckMoreY2Spans:

        if (ySpan2 <= ySpan2Last)
        {
            for (;;)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin2,
                        yMax2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan2 += YSPAN_SIZE;
                if (ySpan2 > ySpan2Last)
                {
                    break;
                }
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the OR operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansOR (
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];
        BOOL         done = FALSE;

        for (;;)
        {
            if (xMin1 <= xMin2)
            {
                XCoords[count++] = xMin1;
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;
                    goto OrIncXSpan1;
                }
                XCoords[count++] = (xMax1 <= xMax2) ? xMax2 : xMax1;
                goto OrIncXSpanBoth;
            }
            XCoords[count++] = xMin2;
            if (xMax2 <= xMin1)
            {
                XCoords[count++] = xMax2;
                goto OrIncXSpan2;
            }
            XCoords[count++] = (xMax2 <= xMax1) ? xMax1 : xMax2;
            // goto OrIncXSpanBoth;

OrIncXSpanBoth:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                done = TRUE;
            }
            else
            {
                xMin2 = xSpan2[0];
                xMax2 = xSpan2[1];
            }

            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto OrCheckMoreX2Spans;
            }
            else
            {
                xMin1 = xSpan1[0];
                xMax1 = xSpan1[1];
            }

            if (done)
            {
                break;
            }
            continue;

OrIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2 = xSpan2[0];
            xMax2 = xSpan2[1];
            continue;

OrIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto OrCheckMoreX2Spans;
            }
            xMin1 = xSpan1[0];
            xMax1 = xSpan1[1];
        }

        while (numXCoords1 >= 2)
        {
            XCoords[count++] = xSpan1[0];
            XCoords[count++] = xSpan1[1];

            numXCoords1 -= 2;
            xSpan1     += 2;
        }

OrCheckMoreX2Spans:

        while (numXCoords2 >= 2)
        {
            XCoords[count++] = xSpan2[0];
            XCoords[count++] = xSpan2[1];

            numXCoords2 -= 2;
            xSpan2     += 2;
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the XOR operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Xor(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region == this)
    {
        SetEmpty();
        return Ok;
    }
    if (region->Empty)
    {
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    if (Infinite)
    {
        if (region->Infinite)
        {
            SetEmpty();
            return Ok;
        }
        return Exclude(region);
    }
    if (region->Infinite)
    {
        return Complement(region);
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(2 * (numYSpans1 + numYSpans2));
        BOOL            done = FALSE;
        INT             numXCoords;
        INT *           xSpan;

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 < yMin2)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (yMax1 <= yMin2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto XorIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMin2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin1 = yMin2;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            else if (yMin1 > yMin2)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (yMax2 <= yMin1)
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMax2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto XorIncYSpan2;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMin1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin2 = yMin1;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            // else if (yMin1 == yMin2)
            if (XSpansXOR (
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 < yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin2 = yMax1;
                        goto XorIncYSpan1;
                    }
                }
                else if (yMax1 > yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto XorIncYSpan2;
                    }
                }
                else // if (yMax1 == yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto XorIncYSpanBoth;
                    }
                }
            }
            return GenericError;

XorIncYSpanBoth:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                done = TRUE;
            }
            else
            {
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }

            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto XorCheckMoreY2Spans;
            }
            else
            {
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }

            if (done)
            {
                break;
            }
            continue;

XorIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

XorIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto XorCheckMoreY2Spans;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }

        if (ySpan1 <= ySpan1Last)
        {
            for (;;)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan1 += YSPAN_SIZE;
                if (ySpan1 > ySpan1Last)
                {
                    break;
                }
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }
        }

XorCheckMoreY2Spans:

        if (ySpan2 <= ySpan2Last)
        {
            for (;;)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin2,
                        yMax2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan2 += YSPAN_SIZE;
                if (ySpan2 > ySpan2Last)
                {
                    break;
                }
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the XOR operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansXOR(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT        xMin1 = xSpan1[0];
        INT        xMax1 = xSpan1[1];
        INT        xMin2 = xSpan2[0];
        INT        xMax2 = xSpan2[1];
        BOOL       done  = FALSE;

        for (;;)
        {
            if (xMin1 < xMin2)
            {
                XCoords[count++] = xMin1;       // left
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;   // right
                    goto XorIncXSpan1;
                }
                XCoords[count++] = xMin2;       // right
                if (xMax1 < xMax2)
                {
                    xMin2 = xMax1;
                    goto XorIncXSpan1;
                }
                else if (xMax1 > xMax2)
                {
                    xMin1 = xMax2;
                    goto XorIncXSpan2;
                }
                // else if (xMax1 == xMax2)
                goto XorIncXSpanBoth;
            }
            else if (xMin1 > xMin2)
            {
                XCoords[count++] = xMin2;       // left
                if (xMax2 <= xMin1)
                {
                    XCoords[count++] = xMax2;   // right
                    goto XorIncXSpan2;
                }
                XCoords[count++] = xMin1;       // right
                if (xMax1 < xMax2)
                {
                    xMin2 = xMax1;
                    goto XorIncXSpan1;
                }
                else if (xMax1 > xMax2)
                {
                    xMin1 = xMax2;
                    goto XorIncXSpan2;
                }
                // else if (xMax1 == xMax2)
                goto XorIncXSpanBoth;
            }
            // else if (xMin1 == xMin2)
            if (xMax1 < xMax2)
            {
                xMin2 = xMax1;
                goto XorIncXSpan1;
            }
            else if (xMax1 > xMax2)
            {
                xMin1 = xMax2;
                goto XorIncXSpan2;
            }
            // else if (xMax1 == xMax2)
            // goto XorIncXSpanBoth;

XorIncXSpanBoth:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                done = TRUE;
            }
            else
            {
                xMin2 = xSpan2[0];
                xMax2 = xSpan2[1];
            }

            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto XorCheckMoreX2Spans;
            }
            else
            {
                xMin1 = xSpan1[0];
                xMax1 = xSpan1[1];
            }

            if (done)
            {
                break;
            }
            continue;

XorIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2    = xSpan2[0];
            xMax2    = xSpan2[1];
            continue;

XorIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto XorCheckMoreX2Spans;
            }
            xMin1    = xSpan1[0];
            xMax1    = xSpan1[1];
        }

        if (numXCoords1 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin1;
                XCoords[count++] = xMax1;

                numXCoords1 -= 2;
                if (numXCoords1 < 2)
                {
                    break;
                }
                xSpan1 += 2;
                xMin1    = xSpan1[0];
                xMax1    = xSpan1[1];
            }
        }

XorCheckMoreX2Spans:

        if (numXCoords2 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin2;
                XCoords[count++] = xMax2;

                numXCoords2 -= 2;
                if (numXCoords2 < 2)
                {
                    break;
                }
                xSpan2 += 2;
                xMin2    = xSpan2[0];
                xMax2    = xSpan2[1];
            }
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the Complement operator.
*   i.e. this = region - this
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Complement(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region->Empty || (region == this) || Infinite)
    {
        SetEmpty();
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        SetEmpty();
        return Ok;
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        return Set(region);
    }
    return Diff(const_cast<DpRegion *>(region), this, FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the Exclude operator.
*   i.e. this = this - region
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Exclude(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || region->Empty)
    {
        return Ok;
    }
    if ((region == this) || region->Infinite)
    {
        SetEmpty();
        return Ok;
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        SetEmpty();
        return Ok;
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        return Ok;
    }
    return Diff(this, const_cast<DpRegion *>(region), TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Subtract region2 from region1.  If set1, then region1 gets the result;
*   otherwise region2 gets the result.
*
* Arguments:
*
*   [IN] region1 - the 1st region
*   [IN] region2 - the 2nd region
*   [IN] set1    - if TRUE, region1 gets result, else region2 does
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Diff(
    DpRegion *      region1,
    DpRegion *      region2,
    BOOL            set1
    )
{
    INT *           ySpan1;
    INT *           ySpan2;
    INT *           ySpan1Last;
    INT *           ySpan2Last;
    INT *           xCoords1;
    INT *           xCoords2;
    INT             ySpan1Tmp[YSPAN_SIZE];
    INT             ySpan2Tmp[YSPAN_SIZE];
    INT             xCoords1Tmp[2];
    INT             xCoords2Tmp[2];
    INT             yMin1 = region1->YMin;
    INT             yMax1;
    INT             yMin2 = region2->YMin;
    INT             yMax2;
    INT             numYSpans1;
    INT             numYSpans2;
    INT             combineTmp[4];
    DynIntArray     combineCoords(combineTmp, 4);

    if (region1->ComplexData == NULL)
    {
        numYSpans1            = 1;
        ySpan1                = ySpan1Tmp;
        ySpan1Last            = ySpan1Tmp;
        yMax1                 = region1->YMax;

        ySpan1[YSPAN_YMIN]    = yMin1;
        ySpan1[YSPAN_YMAX]    = yMax1;
        ySpan1[YSPAN_XOFFSET] = 0;
        ySpan1[YSPAN_XCOUNT]  = 2;

        xCoords1              = xCoords1Tmp;
        xCoords1[0]           = region1->XMin;
        xCoords1[1]           = region1->XMax;
    }
    else
    {
        numYSpans1 = region1->ComplexData->NumYSpans;
        ySpan1     = region1->ComplexData->YSpans;
        ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
        yMax1      = ySpan1[YSPAN_YMAX];
        xCoords1   = region1->ComplexData->XCoords;
    }
    if (region2->ComplexData == NULL)
    {
        numYSpans2            = 1;
        ySpan2                = ySpan2Tmp;
        ySpan2Last            = ySpan2Tmp;
        yMax2                 = region2->YMax;

        ySpan2[YSPAN_YMIN]    = yMin2;
        ySpan2[YSPAN_YMAX]    = yMax2;
        ySpan2[YSPAN_XOFFSET] = 0;
        ySpan2[YSPAN_XCOUNT]  = 2;

        xCoords2              = xCoords2Tmp;
        xCoords2[0]           = region2->XMin;
        xCoords2[1]           = region2->XMax;
    }
    else
    {
        numYSpans2 = region2->ComplexData->NumYSpans;
        ySpan2     = region2->ComplexData->YSpans;
        ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
        yMax2      = ySpan2[YSPAN_YMAX];
        xCoords2   = region2->ComplexData->XCoords;
    }

    DpRegionBuilder regionBuilder(numYSpans1 + (2 * numYSpans2));
    INT             numXCoords;
    INT *           xSpan;

    if (!regionBuilder.IsValid())
    {
        return OutOfMemory;
    }

    for (;;)
    {
        if (yMin1 < yMin2)
        {
            xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
            numXCoords = ySpan1[YSPAN_XCOUNT];

            if (yMax1 <= yMin2)
            {
                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) == Ok)
                {
                    goto DiffIncYSpan1;
                }
            }
            else
            {
                if (CompactAndOutput(
                        yMin1,
                        yMin2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) == Ok)
                {
                    yMin1 = yMin2;
                    continue;   // no increment
                }
            }
            return GenericError;
        }
        else if (yMin1 < yMax2)
        {
            if (XSpansDIFF(
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 <= yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto DiffIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto DiffIncYSpan2;
                    }
                }
            }
            return GenericError;
        }
        // else goto DiffIncYSpan2;

DiffIncYSpan2:
        if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
        {
            break;
        }
        yMin2 = ySpan2[YSPAN_YMIN];
        yMax2 = ySpan2[YSPAN_YMAX];
        continue;

DiffIncYSpan1:
        if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
        {
            goto DiffDone;
        }
        yMin1 = ySpan1[YSPAN_YMIN];
        yMax1 = ySpan1[YSPAN_YMAX];
    }

    if (ySpan1 <= ySpan1Last)
    {
        for (;;)
        {
            xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
            numXCoords = ySpan1[YSPAN_XCOUNT];

            if (CompactAndOutput(
                    yMin1,
                    yMax1,
                    xSpan,
                    numXCoords,
                    &regionBuilder,
                    &combineCoords) != Ok)
            {
                return GenericError;
            }

            ySpan1 += YSPAN_SIZE;
            if (ySpan1 > ySpan1Last)
            {
                break;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }
    }
DiffDone:
    if (set1)
    {
        return region1->Set(regionBuilder);
    }
    return region2->Set(regionBuilder);
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the DIFF operator.
*   i.e. xSpan1 - xSpan2
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansDIFF(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];

        for (;;)
        {
            if (xMin1 < xMin2)
            {
                XCoords[count++] = xMin1;       // left
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;   // right
                    goto DiffIncXSpan1;
                }
                XCoords[count++] = xMin2;       // right
                xMin1 = xMin2;
                continue;   // no increment
            }
            else if (xMin1 < xMax2)
            {
                if (xMax1 <= xMax2)
                {
                    goto DiffIncXSpan1;
                }
                xMin1 = xMax2;
                // goto DiffIncXSpan2;
            }
            // else goto DiffIncXSpan2;

// DiffIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2 = xSpan2[0];
            xMax2 = xSpan2[1];
            continue;

DiffIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto DiffDone;
            }
            xMin1 = xSpan1[0];
            xMax1 = xSpan1[1];
        }

        if (numXCoords1 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin1;
                XCoords[count++] = xMax1;

                numXCoords1 -= 2;
                if (numXCoords1 < 2)
                {
                    break;
                }
                xSpan1 += 2;
                xMin1    = xSpan1[0];
                xMax1    = xSpan1[1];
            }
        }
DiffDone:
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the clipper by setting the output method and setting the
*   starting y span search index.
*
* Arguments:
*
*   [IN] outputClippedSpan - The output class for clipped spans
*   [IN] yMin              - The starting y value of the object to clip
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
VOID
DpClipRegion::InitClipping(
    DpOutputSpan *  outputClippedSpan,
    INT             yMin
    )
{
    OutputClippedSpan = outputClippedSpan;

    // init search index if appropriate
    if (ComplexData != NULL)
    {
        INT *       ySpan;
        INT         ySpanIndex;

        ComplexData->ResetSearchIndex();
        ComplexData->YSpanSearch (yMin, &ySpan, &ySpanIndex);
        ComplexData->YSearchIndex = ySpanIndex;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The method called from the rasterizer during the rasterization when a
*   horizontal span has been identified.  We clip it and if not clipped out,
*   we send the clipped data to the output method.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpClipRegion::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax    // xMax is exclusive
    )
{
    ASSERT(!Empty && !Infinite);
    ASSERT(OutputClippedSpan != NULL);
    INT  xMinCur = xMin;
    INT  xMaxCur = xMax;

    // do simple clip test to bounding rectangle
    if ((xMin <  XMax) && (xMax > XMin) &&
        (y    >= YMin) && (y    < YMax))
    {
        if (xMin < XMin)
        {
            xMinCur = XMin;
        }
        if (xMax > XMax)
        {
            xMaxCur = XMax;
        }
    }
    else
        return Ok;

    if (ComplexData == NULL)
    {
       return OutputClippedSpan->OutputSpan(y, xMinCur, xMaxCur);
    }
    else // not a simple region
    {
        // find the Y span that includes the line (if any)
        INT         ySpanIndex = ComplexData->YSearchIndex;
        INT *       ySpan      = ComplexData->GetYSpan (ySpanIndex);

        if (y >= ySpan[YSPAN_YMIN])
        {
            if (y >= ySpan[YSPAN_YMAX])
            {
                // do forward linear search from previous point
                for (;;)
                {
                    // see if we're past the end of the tessellation
                    if (++ySpanIndex >= ComplexData->NumYSpans)
                    {
                        ComplexData->YSearchIndex = ComplexData->NumYSpans - 1;
                        return Ok;      // nothing to draw
                    }
                    ySpan += YSPAN_SIZE;
                    if (y < ySpan[YSPAN_YMAX])
                    {
                        ComplexData->YSearchIndex = ySpanIndex;
                        if (y >= ySpan[YSPAN_YMIN])
                        {
                            break;
                        }
                        return Ok;      // nothing to draw
                    }
                }
            }
            // else yMin is inside this ySpan
        }
        else // need to search backward (shouldn't happen when rasterizing)
        {
            for (;;)
            {
                if (ySpanIndex == 0)
                {
                    ComplexData->YSearchIndex = 0;
                    return Ok;          // nothing to draw
                }
                ySpanIndex--;
                ySpan -= YSPAN_SIZE;

                if (y >= ySpan[YSPAN_YMIN])
                {
                    ComplexData->YSearchIndex = ySpanIndex;
                    if (y < ySpan[YSPAN_YMAX])
                    {
                        break;
                    }
                    return Ok;          // nothing to draw
                }
            }
        }

        // If we get here, we know there y is within a Y span and that
        // ySpan points to the correct Y span

        GpStatus        status = Ok;
        INT *           xSpan;
        INT             numXCoords;

        xSpan = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
        numXCoords = ySpan[YSPAN_XCOUNT];

        for (;;)
        {
            if (xMax <= xSpan[0])
            {
                break;
            }
            if (xMin < xSpan[1])
            {
                xMinCur = (xMin < xSpan[0]) ? xSpan[0] : xMin;
                xMaxCur = (xMax > xSpan[1]) ? xSpan[1] : xMax;
                status = OutputClippedSpan->OutputSpan(y, xMinCur, xMaxCur);
            }
            // continue on with loop through x spans

            if (((numXCoords -= 2) <= 0) || (status != Ok))
            {
                break;
            }
            xSpan += 2;
        }

        return status;
    }
}

INT
DpRegion::GetRects(
    GpRect *    rects
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            rects->X      = INFINITE_MIN;
            rects->Y      = INFINITE_MIN;
            rects->Width  = INFINITE_SIZE;
            rects->Height = INFINITE_SIZE;
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->X      = XMin;
            rects->Y      = YMin;
            rects->Width  = XMax - XMin;
            rects->Height = YMax - YMin;
        }
        return 1;
    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->X      = xMin;
                    rects->Y      = yMin;
                    rects->Width  = xMax - xMin;
                    rects->Height = height;

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

INT
DpRegion::GetRects(
    GpRectF *   rects
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            rects->X      = (REAL)INFINITE_MIN;
            rects->Y      = (REAL)INFINITE_MIN;
            rects->Width  = (REAL)INFINITE_SIZE;
            rects->Height = (REAL)INFINITE_SIZE;
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->X      = (REAL)XMin;
            rects->Y      = (REAL)YMin;
            rects->Width  = (REAL)(XMax - XMin);
            rects->Height = (REAL)(YMax - YMin);
        }
        return 1;
    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->X      = (REAL)xMin;
                    rects->Y      = (REAL)yMin;
                    rects->Width  = (REAL)(xMax - xMin);
                    rects->Height = (REAL)height;

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

// The WIN9x infinite max and min values are set up to be the greatest
// values that will interop with GDI HRGNs on Win9x successfully.
#define INFINITE_MIN_WIN9X  -16384
#define INFINITE_MAX_WIN9X  16383

INT
DpRegion::GetRects(
    RECT *      rects,
    BOOL        clampToWin9xSize
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            if (!clampToWin9xSize)
            {
                rects->left   = INFINITE_MIN;
                rects->top    = INFINITE_MIN;
                rects->right  = INFINITE_MAX;
                rects->bottom = INFINITE_MAX;
            }
            else
            {
                rects->left   = INFINITE_MIN_WIN9X;
                rects->top    = INFINITE_MIN_WIN9X;
                rects->right  = INFINITE_MAX_WIN9X;
                rects->bottom = INFINITE_MAX_WIN9X;
            }
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->left   = XMin;
            rects->top    = YMin;
            rects->right  = XMax;
            rects->bottom = YMax;

            if (clampToWin9xSize)
            {
                if (rects->left < INFINITE_MIN_WIN9X)
                {
                    rects->left = INFINITE_MIN_WIN9X;
                }
                if (rects->top < INFINITE_MIN_WIN9X)
                {
                    rects->top = INFINITE_MIN_WIN9X;
                }
                if (rects->right > INFINITE_MAX_WIN9X)
                {
                    rects->right = INFINITE_MAX_WIN9X;
                }
                if (rects->bottom > INFINITE_MAX_WIN9X)
                {
                    rects->bottom = INFINITE_MAX_WIN9X;
                }
            }
        }
        return 1;

    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->left   = xMin;
                    rects->top    = yMin;
                    rects->right  = xMax;
                    rects->bottom = yMin + height;

                    if (clampToWin9xSize)
                    {
                        // In this case, this could invalidate the region,
                        // but hopefully ExtCreateRegion will catch this.
                        if (rects->left < INFINITE_MIN_WIN9X)
                        {
                            rects->left = INFINITE_MIN_WIN9X;
                        }
                        if (rects->top < INFINITE_MIN_WIN9X)
                        {
                            rects->top = INFINITE_MIN_WIN9X;
                        }
                        if (rects->right > INFINITE_MAX_WIN9X)
                        {
                            rects->right = INFINITE_MAX_WIN9X;
                        }
                        if (rects->bottom > INFINITE_MAX_WIN9X)
                        {
                            rects->bottom = INFINITE_MAX_WIN9X;
                        }
                    }

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

// If error, returns INVALID_HANDLE_VALUE
HRGN
DpRegion::GetHRgn() const
{
    HRGN    hRgn = NULL;

    if (Infinite)
    {
        return NULL;
    }
    else if (Empty)
    {
        hRgn = CreateRectRgn(0, 0, 0, 0);
    }
    else if (ComplexData == NULL)
    {
        hRgn = CreateRectRgn(XMin, YMin, XMax, YMax);
    }
    else
    {
        INT     numRects = GetRects((RECT *)NULL);

        ASSERT(numRects > 1);

        // Allocate memory to hold RGNDATA structure

        INT         rgnDataSize = numRects * sizeof(RECT);
        RGNDATA *   rgnData = (RGNDATA*)GpMalloc(sizeof(RGNDATAHEADER) +
                                                 rgnDataSize);

        if (rgnData != NULL)
        {
            RECT*   rects = (RECT*)rgnData->Buffer;
            RECT    bounds;

            bounds.left   = XMin;
            bounds.top    = YMin;
            bounds.right  = XMax;
            bounds.bottom = YMax;

            rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
            rgnData->rdh.iType    = RDH_RECTANGLES;
            rgnData->rdh.nCount   = numRects;
            rgnData->rdh.nRgnSize = rgnDataSize;
            rgnData->rdh.rcBound  = bounds;

            GetRects(rects, !Globals::IsNt);

            hRgn = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + rgnDataSize,
                                   rgnData);
            GpFree(rgnData);
        }
    }
    if (hRgn != NULL)
    {
        return hRgn;
    }

    WARNING(("Couldn't create win32 HRGN"));
    return (HRGN)INVALID_HANDLE_VALUE;
}

VOID
DpClipRegion::StartEnumeration (
    INT         yMin,
    Direction   direction
    )
{
    INT *               ySpan;
    EnumDirection = direction;

    if (ComplexData != NULL)
    {
        DpComplexRegion *   complexData = ComplexData;
        INT                 ySpanIndex;

        complexData->ResetSearchIndex();
        complexData->YSpanSearch (yMin, &ySpan, &ySpanIndex);
        complexData->YSearchIndex = ySpanIndex;

        if(EnumDirection == TopLeftToBottomRight ||
           EnumDirection == BottomLeftToTopRight )
        {
            EnumSpan = 0;
        }
        else
        {
            EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
        }

        if(EnumDirection == BottomLeftToTopRight ||
           EnumDirection == BottomRightToTopLeft)
        {
            //If the enumeration is from bottom to top,
            //and the suplied y is not inside a span, we
            //want to return the span with the next smaller
            //y, instead of the one with the next largest y.
            //Or better, the next span in the enumeration order.

            if(yMin < ySpan[YSPAN_YMIN])
            {
                //Get the previous span
                complexData->YSearchIndex--;

                if(complexData->YSearchIndex < 0)
                {
                    complexData->YSearchIndex = 0;
                    EnumDirection = NotEnumerating;
                }
            }

        }
        else
        {
            if(yMin > ySpan[YSPAN_YMAX])
            {
                // This situation can only happen if there
                // are no more spans.
                EnumDirection = NotEnumerating;
            }

        }
    }
}


BOOL
DpClipRegion::Enumerate (
    GpRect *    rects,
    INT &       numRects
    )
{
    INT numOut = 0;

    INT *ySpan = ComplexData->YSpans +
                    ComplexData->YSearchIndex*YSPAN_SIZE;

    if(EnumDirection == NotEnumerating)
    {
        numRects = 0;
        return FALSE;
    }

    while(numOut < numRects)
    {
        // Return the current rectangle

        INT *xCoords = ComplexData->XCoords + ySpan[YSPAN_XOFFSET] + EnumSpan;

        INT xMin = *xCoords++;
        INT xMax = *xCoords;

        rects->X      = xMin;
        rects->Y      = ySpan[YSPAN_YMIN];
        rects->Width  = xMax - xMin;
        rects->Height = ySpan[YSPAN_YMAX] - rects->Y;

        rects++;

        numOut++;

        // Update the indices

        switch(EnumDirection)
        {
        case TopLeftToBottomRight:
            EnumSpan += 2;
            if(EnumSpan == ySpan[YSPAN_XCOUNT])
            {
                if(ComplexData->YSearchIndex == ComplexData->NumYSpans - 1)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex++;
                ySpan += YSPAN_SIZE;
                EnumSpan = 0;
            }
            break;
        case BottomLeftToTopRight:
            EnumSpan += 2;
            if(EnumSpan == ySpan[YSPAN_XCOUNT])
            {
                if(ComplexData->YSearchIndex == 0)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex--;
                ySpan -= YSPAN_SIZE;
                EnumSpan = 0;
            }
            break;
        case TopRightToBottomLeft:
            EnumSpan -= 2;
            if(EnumSpan < 0)
            {
                if(ComplexData->YSearchIndex == ComplexData->NumYSpans - 1)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex++;
                ySpan += YSPAN_SIZE;
                EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
            }
            break;
        case BottomRightToTopLeft:
            EnumSpan -= 2;
            if(EnumSpan < 0)
            {
                if(ComplexData->YSearchIndex == 0)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex--;
                ySpan -= YSPAN_SIZE;
                EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
            }
            break;
        }
    }

    numRects = numOut;
    return TRUE;

enumeration_finished:

    EnumDirection = NotEnumerating;
    numRects = numOut;
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   The method called to convert the region scans to an outline path.  The
*   path can be quite large and contains only points at righ angles with
*   each other.
*
* Arguments:
*
*   [IN,OUT] points - array of points to output
*   [IN,OUT] types - array of types for output
*
*   We do not return a path because we work on GpPoint's not GpPointF's.
*
*   NOTE: This alorithm was copied from GDI's RGNOBJ::bOutline by
*         J. Andrew Goossen.
*
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/

// Because the XCoords may be negative, the high bit is reserved.  Instead we
// use a bit in the Types byte array since we know the
// Types.Count >= XCoordsCount.  We also know that points generated by this
// code aren't in dash mode, so we reuse the dash mode bit for marking a
// visited wall.  We clear all bits on exit.

const UINT MarkWallBit = PathPointTypeDashMode; // 0x10, currently in dash mode.

#define XOFFSET(span,index) (INT)(XCoords[*(span + YSPAN_XOFFSET) + index])

#define XCOUNT(span) *(span + YSPAN_XCOUNT)

#define MARKXOFFSET(span,index) MarkWallPtr[*(span + YSPAN_XOFFSET) + index] \
                                    |= MarkWallBit

// This macro adds a type to the type array.  If the current count exceeds
// the capacity, then we grow the structure by 256 bytes.  Then we continue
// adding the new type to array.
#define ADDTYPE(pointtype) if ((UINT)types.GetCount() >= types.GetCapacity()) { \
                              if (types.ReserveSpace(512) == Ok) \
                              { \
                                  Types = (INT)(Types - MarkWallPtr) + types.GetDataBuffer(); \
                                  GpMemset(Types, 0, types.GetCapacity() - types.GetCount()); \
                                  MarkWallPtr = types.GetDataBuffer(); \
                              } else { \
                                  return FALSE; \
                              } \
                           } \
                           types.AdjustCount(1); \
                           *Types++ |= pointtype;

DpRegion::GetOutlinePoints(DynPointArray& points,
                           DynByteArray& types) const
{
    if (IsSimple())
    {
        GpRect rect;

        GpPoint newPoints[4];
        BYTE newTypes[4];

        GetBounds(&rect);

        newPoints[0] = GpPoint(rect.X, rect.Y);
        newPoints[1] = GpPoint(rect.X + rect.Width, rect.Y);
        newPoints[2] = GpPoint(rect.X + rect.Width, rect.Y + rect.Height);
        newPoints[3] = GpPoint(rect.X, rect.Y + rect.Height);

        newTypes[0] = PathPointTypeStart;
        newTypes[1] = PathPointTypeLine;
        newTypes[2] = PathPointTypeLine;
        newTypes[3] = PathPointTypeLine | PathPointTypeCloseSubpath;

        points.AddMultiple(&newPoints[0], 4);
        types.AddMultiple(&newTypes[0], 4);

        return TRUE;
    }

    // to avoid too many reallocations, we grow the array by the total number
    // or x,y pairs in the reigon.

    points.ReserveSpace(ComplexData->XCoordsCount+10);
    types.ReserveSpace(ComplexData->XCoordsCount+10);

    BYTE* MarkWallPtr = types.GetDataBuffer();
    BYTE* Types = types.GetDataBuffer();

    // Clear all bits in the Types array
    GpMemset(MarkWallPtr, 0, types.GetCapacity());

    // complicated case.

    GpPoint pt[2];
    INT     NumYScans;

    INT*    CurYScan;
    INT*    XCoords;
    INT*    LastYScan;
    INT*    FirstYScan;

    INT     XOffset;
    INT     XIndex;
    INT     XCount;

// Now compute the outline:

    CurYScan    = ComplexData->YSpans;
    NumYScans   = ComplexData->NumYSpans;
    XCoords     = ComplexData->XCoords;
    LastYScan   = CurYScan + NumYScans * YSPAN_SIZE;
    FirstYScan  = CurYScan;

    while (NumYScans--)
    {
        XCount = *(CurYScan + YSPAN_XCOUNT);
        XOffset = *(CurYScan + YSPAN_XOFFSET);

        for (XIndex = 0; XIndex < XCount; XIndex++)
        {
            // Only start at unvisited walls:

            if ((MarkWallPtr[XOffset + XIndex] & MarkWallBit) == 0)
            {

                INT*  YScan     = CurYScan;
                INT   IndexWall = XIndex;
                LONG  Turn;

                pt[0].X = XCoords[XOffset + XIndex];
                pt[0].Y = *(CurYScan + YSPAN_YMIN);

                points.Add(pt[0]);

                ADDTYPE(PathPointTypeStart);
#ifdef DEBUG_REGION
                DbgPrint("Point: (%d,%d)\n",pt[0].X, pt[0].Y);
#endif
                INT* YSearch = CurYScan + YSPAN_SIZE;
                BOOL Inside = (BOOL) (XIndex & 1);

            // Mark that we've visited this wall:

                MarkWallPtr[XOffset + IndexWall] |= MarkWallBit;

            // Loop until the path closes on itself:

            GoDown:
                // YSPAN_YMAX is exclusive, YSPAN_YMIN is inclusive so 
                // vertically adjacent spans have YSPAN_YMIN==YSPAN_YMAX
                Turn = +1;
                while (
                    (YSearch >= CurYScan) && 
                    (YSearch < LastYScan) &&
                    (YScan[YSPAN_YMAX] == YSearch[YSPAN_YMIN])
                      )
                {
                    INT Wall = XOFFSET(YScan, IndexWall);
                    INT IndexNewWall;
                    INT NewWall;

                    INT Left  = Inside;
                    INT Right = XCOUNT(YSearch) - 1 - Inside;

                // It would be nice if the first wall in the region structure
                // was minus infinity, but it isn't, so we do this check:

                    if (XOFFSET(YSearch, Left) > Wall)
                        IndexNewWall = Left;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // minimum x-value > xWall:

                        if (XOFFSET(YSearch, Right) <= Wall)
                            break;                  // =====>

                    // Do a binary search to find it:

                        while (TRUE)
                        {
                            INT IndexSearch = (Left + Right) >> 1;
                            if (IndexSearch == Left)
                                break;              // =====>

                            INT Search = XOFFSET(YSearch, IndexSearch);

                            if (Search > Wall)
                                Right = IndexSearch;
                            else
                                Left = IndexSearch;
                        }

                        IndexNewWall = Right;
                    }

                    if ((IndexNewWall & 1) != Inside)
                    {
                    // There is a region directly below xWall.  We can't
                    // move down if its left side is < the left
                    // side of our space:

                        if (IndexWall > 0 &&
                            XOFFSET(YSearch, IndexNewWall - 1) <
                            XOFFSET(YScan, IndexWall - 1))
                        {
                            Turn = -1;
                            break;                      // =====>
                        }

                        IndexNewWall--;
                    }
                    else
                    {
                    // There is a space directly below xWall.  We can't
                    // move down if its right side is more than the
                    // right side of our region:

                        if (XOFFSET(YSearch, IndexNewWall) >=
                            XOFFSET(YScan, IndexWall + 1))
                            break;                      // =====>
                    }

                    NewWall  = XOFFSET(YSearch, IndexNewWall);

                // Don't bother outputing multiple in-line straight lines:

                    if (Wall != NewWall                               ||
                        XOFFSET(YScan, IndexWall) != NewWall          ||
                        XOFFSET(YSearch, IndexNewWall) != NewWall)
                    {
                        pt[0].X = Wall;
                        pt[0].Y = *(YScan + YSPAN_YMAX);
                        pt[1].Y = *(YScan + YSPAN_YMAX);
                        pt[1].X = NewWall;

                        points.Add(pt[0]);
                        points.Add(pt[1]);

                        ADDTYPE(PathPointTypeLine);
                        ADDTYPE(PathPointTypeLine);

#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    }

                    YScan      = YSearch;
                    IndexWall  = IndexNewWall;
                    YSearch    = YScan + YSPAN_SIZE;

                    MARKXOFFSET(YScan, IndexWall);
                }

            // Setup to go up other side:

                pt[0].X = XOFFSET(YScan, IndexWall);
                pt[0].Y = *(YScan + YSPAN_YMAX);
                pt[1].Y = *(YScan + YSPAN_YMAX);
                pt[1].X = XOFFSET(YScan, IndexWall + Turn);

                points.Add(pt[0]);
                points.Add(pt[1]);

                ADDTYPE(PathPointTypeLine);
                ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif

                YSearch = YScan - YSPAN_SIZE;
                IndexWall += Turn;
                MARKXOFFSET(YScan, IndexWall);

            // Go up:

                // YSPAN_YMAX is exclusive, YSPAN_YMIN is inclusive so 
                // vertically adjacent spans have YSPAN_YMIN==YSPAN_YMAX
                Turn = -1;
                while (
                    (YSearch >= CurYScan) && 
                    (YSearch < LastYScan) &&
                    (YScan[YSPAN_YMIN] == YSearch[YSPAN_YMAX])
                      )
                {
                    INT  Wall = XOFFSET(YScan, IndexWall);
                    INT  IndexNewWall;
                    INT  NewWall;

                    INT Left  = Inside;
                    INT Right = XCOUNT(YSearch) - 1 - Inside;

                // It would be nice if the last wall in the region structure
                // was plus infinity, but it isn't, so we do this check:

                    if (XOFFSET(YSearch, Right) < Wall)
                        IndexNewWall = Right;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // maximum x-value < xWall:

                        if (XOFFSET(YSearch, Left) >= Wall)
                            break;                  // =====>

                    // Binary search to find it:

                        while (TRUE)
                        {
                            INT IndexSearch = (Left + Right) >> 1;
                            if (IndexSearch == Left)
                                break;              // =====>

                            INT Search = XOFFSET(YSearch, IndexSearch);

                            if (Search >= Wall)
                                Right = IndexSearch;
                            else
                                Left = IndexSearch;
                        }

                        IndexNewWall = Left;
                    }

                    if ((IndexNewWall & 1) == Inside)
                    {
                    // There is a region directly above xWall.  We can't
                    // move up if its right side is more than the right
                    // side of our space:

                        if ((IndexWall < (XCOUNT(YScan) - 1)) &&
                            (XOFFSET(YSearch, IndexNewWall + 1) >
                             XOFFSET(YScan, IndexWall + 1)) )
                        {
                            Turn = +1;
                            break;                          // =====>
                        }

                        IndexNewWall++;
                    }
                    else
                    {
                    // There is a space directly above xWall.  We can't
                    // move up if its left side is <= the left side
                    // of our region:

                        if (XOFFSET(YSearch, IndexNewWall) <=
                            XOFFSET(YScan, IndexWall - 1))
                            break;                          // =====>
                    }

                    NewWall = XOFFSET(YSearch, IndexNewWall);

                // Don't bother outputing multiple in-line straight lines:

                    if (Wall != NewWall                                 ||
                        XOFFSET(YScan, IndexWall) != NewWall            ||
                        XOFFSET(YSearch, IndexNewWall) != NewWall)
                    {
                       pt[0].X = Wall;
                       pt[0].Y = *(YScan + YSPAN_YMIN);
                       pt[1].Y = *(YScan + YSPAN_YMIN);
                       pt[1].X = NewWall;

                       points.Add(pt[0]);
                       points.Add(pt[1]);

                       ADDTYPE(PathPointTypeLine);
                       ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    }

                    YScan      = YSearch;
                    IndexWall  = IndexNewWall;
                    YSearch    = YScan - YSPAN_SIZE;

                    MARKXOFFSET(YScan, IndexWall);
                }

            // Check if we've returned to where we started from:

                if ((CurYScan != YScan) || (XIndex != IndexWall - 1))
                {
                // Setup to go down other side:

                    pt[0].X = XOFFSET(YScan, IndexWall);
                    pt[0].Y = *(YScan + YSPAN_YMIN);
                    pt[1].Y = *(YScan + YSPAN_YMIN);
                    pt[1].X = XOFFSET(YScan, IndexWall + Turn);

                    points.Add(pt[0]);
                    points.Add(pt[1]);

                    ADDTYPE(PathPointTypeLine);
                    ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    YSearch = YScan + YSPAN_SIZE;

                    IndexWall += Turn;
                    MARKXOFFSET(YScan, IndexWall);

                    goto GoDown;                    // =====>
                }

            // We're all done with this outline!

                pt[0].X = XOFFSET(YScan, IndexWall);
                pt[0].Y = *(YScan + YSPAN_YMIN);

                points.Add(pt[0]);

                ADDTYPE(PathPointTypeLine | PathPointTypeCloseSubpath);
#ifdef DEBUG_REGION
                DbgPrint("Point: (%d,%d)\n", pt[0].X, pt[0].Y);
#endif

            }
        }

        CurYScan  = CurYScan + YSPAN_SIZE;
    }

    // we must untrash the region by removing our MarkWallBits

    BYTE* TypesPtr = types.GetDataBuffer();
    INT  XCnt = ComplexData->XCoordsCount;

    while (XCnt--)
    {
        *TypesPtr++ &= ~MarkWallBit;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\dppath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpPath.cpp
*
* Abstract:
*
*   DpPath engine function implementation
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a widen path from an existing path, pen and context.  The context
*   provides the world to transform matrix, and surface dpiX, dpiY
*
* Arguments:
*
*   path, context, pen
*
* Return Value:
*
*   DpPath* - widened path
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/
DpPath*
GpPath::DriverCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen,
    DpContext* context,
    BOOL outline
    )
{
    const GpPath* gpPath = GpPath::GetPath(path);
    const GpPen* gpPen = GpPen::GetPen(pen);
    
    ASSERT(gpPath->IsValid());
    ASSERT(gpPen->IsValid());
    
    GpPath* widenPath;
    GpMatrix identityMatrix;   // default initialized to identity matrix.
    
    widenPath = gpPath->GetWidenedPath(
        gpPen,
        context ? 
          &(context->WorldToDevice) : 
          &identityMatrix,
        FlatnessDefault
    );
    
    if(outline && (widenPath!=NULL))
    {
        // pass in identity matrix because GetWidenedPath has already 
        // transformed into the device space.
        // Note: We explicitly ignore the return code here because we want
        // to draw witht he widened path if the ComputeWindingModeOutline
        // fails.
        
        widenPath->ComputeWindingModeOutline(&identityMatrix, FlatnessDefault);
    }
    
    // Returns NULL on failure.
    
    return (DpPath*) widenPath;
}

VOID
GpPath::DriverDeletePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    delete gpPath;
}

DpPath*
GpPath::DriverClonePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    return (DpPath*)(gpPath->Clone());
}

VOID
GpPath::DriverTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    gpPath->Transform(matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\precomp.hpp ===
#include "..\Runtime\runtime.hpp"
#include "common.hpp"

#include "..\..\privinc\imaging.h"
#include "..\..\ddkinc\ddiplus.hpp"

#include "..\render\Scan.hpp"
#include "..\render\scandib.hpp"


// Hack: These dependencies on 'Entry' should be fixed
#include "..\Entry\device.hpp"
#include "..\Entry\ImageAttr.hpp"
#include "..\Entry\gpbitmap.hpp"
#include "..\Entry\brush.hpp"
#include "..\Entry\pen.hpp"
#include "..\Entry\intmap.hpp"
#include "..\fondrv\tt\ttfd\fontddi.h"
#include "..\Entry\fontFace.hpp"
#include "..\Entry\facerealization.hpp"
#include "..\Entry\family.hpp"
#include "..\Entry\font.hpp"
#include "..\Entry\fontcollection.hpp"
#include "..\Entry\stringFormat.hpp"
#include "..\Entry\path.hpp"
#include "..\Entry\metafile.hpp"
#include "..\Entry\path.hpp"
#include "..\Entry\DrawGlyphData.hpp"
#include "..\Entry\graphics.hpp"
#include "..\Entry\textImager.hpp"
// EndHack

#include "DpDriverInternal.hpp"
#include "DpDriverData.hpp"

#include "..\imaging\api\ColorPal.hpp"
#include "..\imaging\api\ImgUtils.hpp"

#include "..\Pdrivers\ConvertToGdi.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\aatext.hpp ===
#ifndef __AATEXT_HPP_
#define __AATEXT_HPP_

#define CT_LOOKUP 115

// the max number of foreground virt pixels in a subpixel,  2x X 1y , no filtering

#define CT_SAMPLE_NF  2

// the number of distinct nonfiltered states in a whole pixel = 3 x 3 x 3 = 27
// The indices coming from the rasterizer are in [0,26] range

#define CT_MAX_NF ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// the max number of foreground virt pixels in a subpixel AFTER filtering, 6

#define CT_SAMPLE_F   6

// size of the storage table, basically 3^5 = 243.
// The table does filtering and index computation (vector quantization) in one step.


#define CT_STORAGE ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

class TextColorGammaTable
{
public:
    ARGB            argb[256];
    ULONG           gammaValue;

public:
    TextColorGammaTable() {};
    void CreateTextColorGammaTable(const GpColor * color, ULONG gammaValue, ULONG gsLevel);
    BYTE GetGammaTableIndexValue(BYTE grayscaleValue, ULONG gsLevel);

    inline ARGB GetGammaColorCorrection(BYTE grayscaleValue)
    {
        return argb[grayscaleValue];
    }

};

class DpOutputAntiAliasSolidColorSpan : public DpOutputSolidColorSpan
{
public:
    TextColorGammaTable textColorGammaTable;

public:

    DpOutputAntiAliasSolidColorSpan(GpColor &color, DpScanBuffer * scan, ULONG gammaValue, ULONG gsLevel);

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        )
    {
       return DpOutputSolidColorSpan::OutputSpan(y, xMin, xMax);
    }

    BOOL IsValid() const { return TRUE; }
    DpScanBuffer* GetScanBuffer(){ return DpOutputSolidColorSpan::Scan; }

    inline ARGB GetAASolidColor(ULONG grayscaleValue)
    {
        return DpOutputSolidColorSpan::Argb = textColorGammaTable.argb[grayscaleValue];
    }
};

// This class implements antialiasing for Text brush

class DpOutputAntiAliasBrushOutputSpan : public DpOutputSpan
{
public:
    DpOutputSpan *  Output;
    BYTE            alphaCoverage;

public:

    DpOutputAntiAliasBrushOutputSpan()
    {
        // Now we have nothing to do but we should have something to add
        // when we start to optimize the code
    }

    void Init(DpOutputSpan *output)
    {
        Output = output;
        alphaCoverage = 255;
    }

    void SetCoverage(BYTE coverage)
    {
        alphaCoverage = coverage;
    }
    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax);

    virtual ~DpOutputAntiAliasBrushOutputSpan() {};

    virtual BOOL IsValid() const {return TRUE;}
    virtual GpStatus End() { return Ok; }
};

void UpdateLCDOrientation();

#endif // __AATEXT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\ddi\transform.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   transform.cpp
*
* Abstract:
*
*   Implement functions related to transforms
*   inside the graphics context.
*
* Revision History:
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Get the inverse of the world to device matrix.
*   We try to keep the world to device matrix invertible all the time,
*   so this should always succeed.
*
* Arguments:
*
*   [OUT] matrix - the device to world transformation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::GetDeviceToWorldTransform(GpMatrix * matrix) const
{
    ASSERT(matrix != NULL);
    
    if (!Context->InverseOk)
    {
        Context->DeviceToWorld = Context->WorldToDevice;
        if (Context->DeviceToWorld.Invert() == Ok)
        {
            Context->InverseOk = TRUE;
            goto InverseOk;
        }
        ASSERT(0);  // somehow we got a non-invertible matrix
        return GenericError;
    }

InverseOk:
    *matrix = Context->DeviceToWorld;
    return Ok;
}

inline REAL myabs(REAL x)
{
    return (x >= 0.0f) ? x : -x;
}

VOID 
GpGraphics::GetWorldPixelSize(
    REAL &      xSize, 
    REAL &      ySize
    )
{
    GpMatrix    matrix;
    if (this->GetDeviceToWorldTransform(&matrix) == Ok)
    {
        PointF      pnt(1.0f,1.0f);
        matrix.VectorTransform(&pnt);
        xSize = myabs(pnt.X);
        ySize = myabs(pnt.Y);
    }
    else
    {
        xSize = 1.0f;
        ySize = 1.0f;
    }
}

GpStatus
GpGraphics::SetWorldTransform(const GpMatrix& matrix)
{
    GpStatus    status = Ok;
    
    // Keep the WorldToPage transform invertible
    if (matrix.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordSetWorldTransform(matrix);
        }
        Context->WorldToPage = matrix;
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::ResetWorldTransform()
{
    GpStatus    status = Ok;
    
    if (IsRecording())
    {
        status = Metafile->RecordResetWorldTransform();
    }
    Context->WorldToPage.Reset();
    Context->InverseOk = FALSE;
    Context->UpdateWorldToDeviceMatrix();
    return status;
}

GpStatus
GpGraphics::MultiplyWorldTransform(const GpMatrix& matrix, 
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;
   
    if (order == MatrixOrderPrepend)
    { 
        Context->WorldToPage.Prepend(matrix);
    }
    else
    {
        Context->WorldToPage.Append(matrix);
    }

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordMultiplyWorldTransform(matrix, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::TranslateWorldTransform(REAL dx, REAL dy, 
                                    GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordTranslateWorldTransform(dx, dy, order);
    }
    Context->WorldToPage.Translate(dx, dy, order);
    Context->InverseOk = FALSE;
    Context->UpdateWorldToDeviceMatrix();
    return status;
}

GpStatus
GpGraphics::ScaleWorldTransform(REAL sx, REAL sy, 
                                GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;

    Context->WorldToPage.Scale(sx, sy, order);

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordScaleWorldTransform(sx, sy, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::RotateWorldTransform(REAL angle, GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;

    Context->WorldToPage.Rotate(angle, order);

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordRotateWorldTransform(angle, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the page transformation using the specified units and scale.
*
* Arguments:
*
*   [IN] unit  - the type of units to use
*   [IN] scale - any additional scale to use.  For example, if you wanted
*                the page to be described in terms of feet, you'd set the
*                units to be inches and set the scale to be 12.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::SetPageTransform(
    GpPageUnit  unit, 
    REAL        scale
    )
{
    GpStatus    status = Ok;
    
    if ((scale < 0.000000001) || (scale > 1000000000))
    {
        status = InvalidParameter;
    }
    else
    {
        switch (unit)
        {
        case UnitDisplay:       // Variable
        case UnitPixel:         // Each unit is one device pixel. 
        case UnitPoint:         // Each unit is a printer's point, or 1/72 inch.
        case UnitInch:          // Each unit is 1 inch.
        case UnitDocument:      // Each unit is 1/300 inch.
        case UnitMillimeter:    // Each unit is 1 millimeter.
            if (IsRecording() &&
                ((unit != Context->PageUnit) || (scale != Context->PageScale)))
            {
                status = Metafile->RecordSetPageTransform(unit, scale);
            }
            Context->PageUnit  = unit;
            Context->PageScale = scale;
            Context->GetPageMultipliers();
            Context->UpdateWorldToDeviceMatrix();
            break;
        default:
            ASSERT(0);
            status = InvalidParameter;
            break;
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert the points from one coordinate space to another.
*
* Arguments:
*
*   [IN]     source - the coordinate space of the source points
*   [IN]     dest   - the coordinate space to convert the points to
*   [IN/OUT] points - the points to convert
*   [IN]     count  - the number of points to convert
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::TransformPoints(
    GpPointF *          points,
    INT                 count,
    GpCoordinateSpace   source, 
    GpCoordinateSpace   dest
    )
{
    if (source != dest)
    {
        GpMatrix    m;
        GpMatrix *  matrix;
        
        switch (source)
        {
          case CoordinateSpaceWorld:
            switch (dest)
            {
              case CoordinateSpacePage:
                matrix = &(Context->WorldToPage);
                break;

              case CoordinateSpaceDevice:
                matrix = &(Context->WorldToDevice);
                break;

              default:
                return InvalidParameter;
            }
            break;

          case CoordinateSpacePage:
            matrix = &m;
            switch (dest)
            {
              case CoordinateSpaceWorld:
                m = Context->WorldToPage;
                m.Invert();
                break;

              case CoordinateSpaceDevice:
                m.Scale(Context->PageMultiplierX, Context->PageMultiplierY);
                break;

              default:
                return InvalidParameter;
            }
            break;

          case CoordinateSpaceDevice:
            matrix = &m;
            switch (dest)
            {
              case CoordinateSpaceWorld:
                GetDeviceToWorldTransform(&m);
                break;

              case CoordinateSpacePage:
                {
                    REAL    scaleX = 1 / Context->PageMultiplierX;
                    REAL    scaleY = 1 / Context->PageMultiplierY;
                    m.Scale (scaleX, scaleY);
                }
                break;

              default:
                return InvalidParameter;
            }
            break;

          default:
            return InvalidParameter;
        }
        matrix->Transform(points, count);
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\aatext.cpp ===
#include "precomp.hpp"

namespace Globals
{

const BYTE TextContrastTableIdentity[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 
0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 
0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 
0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

TEXT_CONTRAST_TABLES TextContrastTablesDir =
{
{ // 1.1
0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 
0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x10, 0x11, 0x12, 
0x13, 0x14, 0x15, 0x16, 0x16, 0x17, 0x18, 0x19, 
0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
0x29, 0x2A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 
0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 
0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 
0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 
0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xBA, 
0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 
0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE3, 0xE4, 0xE5, 
0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 
0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
0xF7, 0xF8, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
},

{ // 1.2
 0x00,   0x00,   0x01,   0x01,   0x02,   0x02,   0x03,   0x03,
 0x04,   0x05,   0x05,   0x06,   0x07,   0x07,   0x08,   0x09,
 0x09,   0x0A,   0x0B,   0x0B,   0x0C,   0x0D,   0x0D,   0x0E,
 0x0F,   0x10,   0x10,   0x11,   0x12,   0x13,   0x14,   0x14,
 0x15,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,   0x1B,
 0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x20,   0x21,   0x22,
 0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x28,
 0x29,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,
 0x31,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3E,
 0x3F,   0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,
 0x47,   0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,
 0x4F,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,
 0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
 0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,
 0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
 0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,
 0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,
 0xAC,   0xAD,   0xAF,   0xB0,   0xB1,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBD,
 0xBF,   0xC0,   0xC1,   0xC2,   0xC3,   0xC4,   0xC5,   0xC7,
 0xC8,   0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCF,   0xD0,
 0xD1,   0xD2,   0xD3,   0xD4,   0xD6,   0xD7,   0xD8,   0xD9,
 0xDA,   0xDB,   0xDD,   0xDE,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE4,   0xE5,   0xE6,   0xE7,   0xE8,   0xEA,   0xEB,   0xEC,
 0xED,   0xEE,   0xEF,   0xF1,   0xF2,   0xF3,   0xF4,   0xF5,
 0xF7,   0xF8,   0xF9,   0xFA,   0xFB,   0xFD,   0xFE,   0xFF
},

{ // 1.3
0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0B, 0x0B, 
0x0C, 0x0C, 0x0D, 0x0E, 0x0E, 0x0F, 0x10, 0x10, 
0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1C, 
0x1D, 0x1E, 0x1F, 0x1F, 0x20, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 
0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x2F, 0x30, 
0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
0x39, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x91, 0x92, 0x93, 
0x94, 0x95, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 0xB9, 
0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD4, 0xD5, 0xD6, 
0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDE, 0xDF, 0xE0, 
0xE2, 0xE3, 0xE4, 0xE5, 0xE7, 0xE8, 0xE9, 0xEA, 
0xEC, 0xED, 0xEE, 0xF0, 0xF1, 0xF2, 0xF3, 0xF5, 
0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFE, 0xFF
},

 { // 1.4
 0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x04,   0x04,   0x04,   0x05,
 0x05,   0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0C,   0x0C,   0x0D,   0x0D,
 0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,   0x12,   0x12,
 0x13,   0x14,   0x14,   0x15,   0x16,   0x16,   0x17,   0x18,
 0x19,   0x19,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1F,   0x1F,   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,
 0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2B,
 0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31,
 0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,
 0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x67,   0x68,   0x69,
 0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,   0x71,
 0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,
 0x7C,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x84,
 0x85,   0x86,   0x87,   0x88,   0x89,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x94,   0x95,   0x97,
 0x98,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA0,
 0xA1,   0xA3,   0xA4,   0xA5,   0xA6,   0xA8,   0xA9,   0xAA,
 0xAB,   0xAD,   0xAE,   0xAF,   0xB0,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBB,   0xBC,   0xBD,   0xBE,
 0xC0,   0xC1,   0xC2,   0xC4,   0xC5,   0xC6,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCD,   0xCE,   0xCF,   0xD1,   0xD2,   0xD3,
 0xD5,   0xD6,   0xD7,   0xD9,   0xDA,   0xDB,   0xDD,   0xDE,
 0xDF,   0xE1,   0xE2,   0xE3,   0xE5,   0xE6,   0xE8,   0xE9,
 0xEA,   0xEC,   0xED,   0xEE,   0xF0,   0xF1,   0xF2,   0xF4,
 0xF5,   0xF7,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
},

{ // 1.5
   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
   0x01,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x04,
   0x04,   0x04,   0x05,   0x05,   0x06,   0x06,   0x06,   0x07,
   0x07,   0x08,   0x08,   0x09,   0x09,   0x0A,   0x0A,   0x0B,
   0x0B,   0x0C,   0x0C,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,
   0x10,   0x10,   0x11,   0x12,   0x12,   0x13,   0x14,   0x14,
   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x19,   0x1A,
   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x1F,
   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,   0x25,   0x25,
   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,   0x2C,
   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,
   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,
   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,   0x41,
   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
   0x52,   0x53,   0x54,   0x55,   0x56,   0x58,   0x59,   0x5A,
   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,
   0x63,   0x64,   0x66,   0x67,   0x68,   0x69,   0x6A,   0x6B,
   0x6C,   0x6D,   0x6E,   0x70,   0x71,   0x72,   0x73,   0x74,
   0x75,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7E,
   0x7F,   0x80,   0x81,   0x82,   0x84,   0x85,   0x86,   0x87,
   0x88,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
   0x92,   0x93,   0x95,   0x96,   0x97,   0x98,   0x9A,   0x9B,
   0x9C,   0x9E,   0x9F,   0xA0,   0xA1,   0xA3,   0xA4,   0xA5,
   0xA7,   0xA8,   0xA9,   0xAB,   0xAC,   0xAD,   0xAE,   0xB0,
   0xB1,   0xB2,   0xB4,   0xB5,   0xB6,   0xB8,   0xB9,   0xBB,
   0xBC,   0xBD,   0xBF,   0xC0,   0xC1,   0xC3,   0xC4,   0xC5,
   0xC7,   0xC8,   0xCA,   0xCB,   0xCC,   0xCE,   0xCF,   0xD1,
   0xD2,   0xD3,   0xD5,   0xD6,   0xD8,   0xD9,   0xDA,   0xDC,
   0xDD,   0xDF,   0xE0,   0xE2,   0xE3,   0xE4,   0xE6,   0xE7,
   0xE9,   0xEA,   0xEC,   0xED,   0xEF,   0xF0,   0xF2,   0xF3,
   0xF5,   0xF6,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
},

{ // 1.6
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,   0x03,
 0x03,   0x03,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,
 0x06,   0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D,
 0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,
 0x12,   0x12,   0x13,   0x13,   0x14,   0x15,   0x15,   0x16,
 0x17,   0x17,   0x18,   0x19,   0x19,   0x1A,   0x1B,   0x1B,
 0x1C,   0x1D,   0x1D,   0x1E,   0x1F,   0x1F,   0x20,   0x21,
 0x22,   0x22,   0x23,   0x24,   0x25,   0x26,   0x26,   0x27,
 0x28,   0x29,   0x2A,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,
 0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,   0x3B,   0x3C,
 0x3D,   0x3E,   0x3F,   0x40,   0x40,   0x41,   0x42,   0x43,
 0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A,   0x4B,
 0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54,
 0x55,   0x56,   0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,
 0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,   0x64,   0x65,
 0x66,   0x67,   0x68,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x71,   0x72,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7D,   0x7E,   0x7F,   0x80,   0x82,
 0x83,   0x84,   0x85,   0x87,   0x88,   0x89,   0x8A,   0x8C,
 0x8D,   0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,
 0x97,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA1,
 0xA2,   0xA3,   0xA5,   0xA6,   0xA7,   0xA9,   0xAA,   0xAB,
 0xAD,   0xAE,   0xB0,   0xB1,   0xB2,   0xB4,   0xB5,   0xB7,
 0xB8,   0xB9,   0xBB,   0xBC,   0xBE,   0xBF,   0xC1,   0xC2,
 0xC4,   0xC5,   0xC6,   0xC8,   0xC9,   0xCB,   0xCC,   0xCE,
 0xCF,   0xD1,   0xD2,   0xD4,   0xD5,   0xD7,   0xD8,   0xDA,
 0xDB,   0xDD,   0xDE,   0xE0,   0xE1,   0xE3,   0xE4,   0xE6,
 0xE7,   0xE9,   0xEB,   0xEC,   0xEE,   0xEF,   0xF1,   0xF2,
 0xF4,   0xF5,   0xF7,   0xF9,   0xFA,   0xFC,   0xFD,   0xFF
},

{ // 1.7
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 0x0E, 
0x0F, 0x0F, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 
0x13, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 
0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6F, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x78, 0x7A, 0x7B, 0x7C, 
0x7D, 0x7F, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 
0x88, 0x89, 0x8A, 0x8C, 0x8D, 0x8E, 0x90, 0x91, 
0x92, 0x94, 0x95, 0x97, 0x98, 0x99, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA2, 0xA3, 0xA4, 0xA6, 0xA7, 
0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xB0, 0xB1, 0xB3, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBA, 0xBC, 0xBD, 0xBF, 
0xC0, 0xC2, 0xC3, 0xC5, 0xC6, 0xC8, 0xC9, 0xCB, 
0xCD, 0xCE, 0xD0, 0xD1, 0xD3, 0xD4, 0xD6, 0xD8, 
0xD9, 0xDB, 0xDC, 0xDE, 0xE0, 0xE1, 0xE3, 0xE4, 
0xE6, 0xE8, 0xE9, 0xEB, 0xED, 0xEE, 0xF0, 0xF2, 
0xF3, 0xF5, 0xF7, 0xF8, 0xFA, 0xFC, 0xFD, 0xFF
},

{ // 1.8
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03,
 0x04,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,   0x06,
 0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,
 0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,
 0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x15,
 0x15,   0x16,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,
 0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E,   0x1F,
 0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24,   0x25,
 0x26,   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,
 0x2C,   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,
 0x33,   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,
 0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
 0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
 0x52,   0x53,   0x54,   0x56,   0x57,   0x58,   0x59,   0x5A,
 0x5B,   0x5C,   0x5D,   0x5F,   0x60,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x71,   0x72,   0x73,   0x74,   0x76,   0x77,
 0x78,   0x7A,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x81,
 0x83,   0x84,   0x86,   0x87,   0x88,   0x8A,   0x8B,   0x8C,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,   0x98,
 0x99,   0x9A,   0x9C,   0x9D,   0x9F,   0xA0,   0xA2,   0xA3,
 0xA5,   0xA6,   0xA8,   0xA9,   0xAB,   0xAC,   0xAE,   0xAF,
 0xB1,   0xB2,   0xB4,   0xB5,   0xB7,   0xB8,   0xBA,   0xBC,
 0xBD,   0xBF,   0xC0,   0xC2,   0xC3,   0xC5,   0xC7,   0xC8,
 0xCA,   0xCC,   0xCD,   0xCF,   0xD0,   0xD2,   0xD4,   0xD5,
 0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,   0xE1,   0xE3,
 0xE5,   0xE6,   0xE8,   0xEA,   0xEC,   0xED,   0xEF,   0xF1,
 0xF3,   0xF4,   0xF6,   0xF8,   0xFA,   0xFB,   0xFD,   0xFF
},

{ // 1.9
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 
0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 0x12, 
0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 
0x1C, 0x1D, 0x1E, 0x1E, 0x1F, 0x20, 0x20, 0x21, 
0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27, 
0x28, 0x29, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 
0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68, 
0x69, 0x6A, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x79, 0x7A, 0x7B, 0x7D, 
0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x86, 0x88, 
0x89, 0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x92, 0x93, 
0x95, 0x96, 0x98, 0x99, 0x9B, 0x9C, 0x9E, 0x9F, 
0xA1, 0xA2, 0xA4, 0xA5, 0xA7, 0xA8, 0xAA, 0xAC, 
0xAD, 0xAF, 0xB0, 0xB2, 0xB4, 0xB5, 0xB7, 0xB8, 
0xBA, 0xBC, 0xBD, 0xBF, 0xC1, 0xC2, 0xC4, 0xC6, 
0xC7, 0xC9, 0xCB, 0xCC, 0xCE, 0xD0, 0xD2, 0xD3, 
0xD5, 0xD7, 0xD9, 0xDA, 0xDC, 0xDE, 0xE0, 0xE1, 
0xE3, 0xE5, 0xE7, 0xE9, 0xEB, 0xEC, 0xEE, 0xF0, 
0xF2, 0xF4, 0xF6, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
},

 { // 2.0
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x03,   0x03,   0x04,   0x04,
 0x04,   0x04,   0x05,   0x05,   0x05,   0x05,   0x06,   0x06,
 0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,
 0x0C,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,
 0x10,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,
 0x14,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,
 0x19,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1E,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,
 0x24,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,
 0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x2F,   0x30,
 0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,
 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,
 0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x82,   0x83,
 0x85,   0x86,   0x88,   0x89,   0x8B,   0x8C,   0x8E,   0x8F,
 0x91,   0x92,   0x94,   0x95,   0x97,   0x98,   0x9A,   0x9B,
 0x9D,   0x9E,   0xA0,   0xA2,   0xA3,   0xA5,   0xA6,   0xA8,
 0xAA,   0xAB,   0xAD,   0xAF,   0xB0,   0xB2,   0xB4,   0xB5,
 0xB7,   0xB9,   0xBA,   0xBC,   0xBE,   0xC0,   0xC1,   0xC3,
 0xC5,   0xC7,   0xC8,   0xCA,   0xCC,   0xCE,   0xCF,   0xD1,
 0xD3,   0xD5,   0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,
 0xE2,   0xE4,   0xE6,   0xE8,   0xE9,   0xEB,   0xED,   0xEF,
 0xF1,   0xF3,   0xF5,   0xF7,   0xF9,   0xFB,   0xFD,   0xFF
},

{ // 2.1
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 
0x12, 0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 
0x16, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x1B, 
0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x21, 0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 
0x27, 0x28, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2C, 
0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x33, 
0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 
0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 
0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5F, 
0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6D, 0x6E, 0x70, 0x71, 0x72, 0x74, 
0x75, 0x76, 0x78, 0x79, 0x7B, 0x7C, 0x7E, 0x7F, 
0x81, 0x82, 0x83, 0x85, 0x86, 0x88, 0x89, 0x8B, 
0x8D, 0x8E, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97, 
0x99, 0x9B, 0x9C, 0x9E, 0xA0, 0xA1, 0xA3, 0xA5, 
0xA6, 0xA8, 0xAA, 0xAB, 0xAD, 0xAF, 0xB0, 0xB2, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBB, 0xBD, 0xBF, 0xC0, 
0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCB, 0xCD, 0xCF, 
0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 
0xE1, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 
0xF1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
},

 { // 2.2
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 
0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0C, 
0x0C, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0F, 0x0F, 
0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 
0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 
0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x51, 
0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5A, 
0x5B, 0x5D, 0x5E, 0x5F, 0x61, 0x62, 0x63, 0x64, 
0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 0x6E, 0x6F, 
0x71, 0x72, 0x74, 0x75, 0x77, 0x78, 0x79, 0x7B, 
0x7C, 0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x87, 
0x89, 0x8A, 0x8C, 0x8D, 0x8F, 0x91, 0x92, 0x94, 
0x95, 0x97, 0x99, 0x9A, 0x9C, 0x9E, 0x9F, 0xA1, 
0xA3, 0xA5, 0xA6, 0xA8, 0xAA, 0xAC, 0xAD, 0xAF, 
0xB1, 0xB3, 0xB5, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 
0xC0, 0xC2, 0xC4, 0xC5, 0xC7, 0xC9, 0xCB, 0xCD, 
0xCF, 0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 
0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xEA, 0xEC, 0xEE, 
0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFB, 0xFD, 0xFF 
}
}; // g_GammaTableDir

TEXT_CONTRAST_TABLES TextContrastTablesInv =
{
{ // 1.1
0x00, 0x02, 0x03, 0x04, 0x06, 0x07, 0x08, 0x0A,
0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x12, 0x13,
0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1D,
0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26,
0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E,
0x2F, 0x30, 0x31, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48,
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80,
0x81, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 0x9D, 0x9E,
0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE,
0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD,
0xBE, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4,
0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC,
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3,
0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA,
0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2,
0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9,
0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xEF, 0xF0,
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
},

{ // 1.2
 0x00,   0x03,   0x04,   0x06,   0x08,   0x0A,   0x0B,   0x0D,
 0x0E,   0x10,   0x11,   0x13,   0x14,   0x15,   0x17,   0x18,
 0x19,   0x1B,   0x1C,   0x1D,   0x1F,   0x20,   0x21,   0x22,
 0x24,   0x25,   0x26,   0x27,   0x28,   0x2A,   0x2B,   0x2C,
 0x2D,   0x2E,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x36,   0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,
 0x3F,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,
 0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,
 0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,   0x80,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,
 0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,
 0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9D,
 0x9E,   0x9F,   0xA0,   0xA1,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA8,   0xA8,   0xA9,   0xAA,   0xAB,   0xAC,
 0xAD,   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
 0xBB,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC1,   0xC1,
 0xC2,   0xC3,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,
 0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,
 0xD7,   0xD8,   0xD9,   0xDA,   0xDB,   0xDB,   0xDC,   0xDD,
 0xDE,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
 0xE5,   0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xEA,   0xEB,
 0xEC,   0xED,   0xED,   0xEE,   0xEF,   0xF0,   0xF1,   0xF2,
 0xF2,   0xF3,   0xF4,   0xF5,   0xF6,   0xF7,   0xF7,   0xF8,
 0xF9,   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFF
},

{ // 1.3
0x00, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10,
0x12, 0x13, 0x15, 0x17, 0x18, 0x1A, 0x1B, 0x1D,
0x1E, 0x20, 0x21, 0x23, 0x24, 0x25, 0x27, 0x28,
0x29, 0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x32,
0x34, 0x35, 0x36, 0x37, 0x39, 0x3A, 0x3B, 0x3C,
0x3D, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x86,
0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
0x8F, 0x90, 0x91, 0x92, 0x92, 0x93, 0x94, 0x95,
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9B, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA3,
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAA,
0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB0, 0xB1,
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 0xB8,
0xB9, 0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC,
0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3,
0xD4, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9,
0xDA, 0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE4, 0xE5, 0xE6,
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xEC,
0xED, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
0xF3, 0xF4, 0xF5, 0xF6, 0xF6, 0xF7, 0xF8, 0xF9,
0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFF
},

{ // 1.4
 0x00,   0x05,   0x08,   0x0B,   0x0D,   0x0F,   0x12,   0x14,
 0x16,   0x17,   0x19,   0x1B,   0x1D,   0x1E,   0x20,   0x22,
 0x23,   0x25,   0x26,   0x28,   0x29,   0x2B,   0x2C,   0x2E,
 0x2F,   0x31,   0x32,   0x33,   0x35,   0x36,   0x37,   0x39,
 0x3A,   0x3B,   0x3C,   0x3E,   0x3F,   0x40,   0x41,   0x43,
 0x44,   0x45,   0x46,   0x48,   0x49,   0x4A,   0x4B,   0x4C,
 0x4D,   0x4E,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,
 0x56,   0x57,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,
 0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x8F,   0x90,   0x91,   0x92,   0x93,   0x94,
 0x95,   0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,
 0x9C,   0x9D,   0x9E,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,
 0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAE,   0xAF,   0xAF,
 0xB0,   0xB1,   0xB2,   0xB3,   0xB4,   0xB4,   0xB5,   0xB6,
 0xB7,   0xB8,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,
 0xBD,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC2,   0xC3,
 0xC4,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,   0xD6,
 0xD6,   0xD7,   0xD8,   0xD9,   0xD9,   0xDA,   0xDB,   0xDC,
 0xDC,   0xDD,   0xDE,   0xDF,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE2,   0xE3,   0xE4,   0xE5,   0xE5,   0xE6,   0xE7,   0xE8,
 0xE8,   0xE9,   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xEE,
 0xEE,   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF3,
 0xF4,   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF9,   0xF9,
 0xFA,   0xFB,   0xFB,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 1.5
   0x00,   0x06,   0x0A,   0x0D,   0x10,   0x13,   0x15,   0x17,
   0x19,   0x1B,   0x1D,   0x1F,   0x21,   0x23,   0x25,   0x27,
   0x28,   0x2A,   0x2C,   0x2D,   0x2F,   0x30,   0x32,   0x33,
   0x35,   0x36,   0x38,   0x39,   0x3A,   0x3C,   0x3D,   0x3F,
   0x40,   0x41,   0x43,   0x44,   0x45,   0x46,   0x48,   0x49,
   0x4A,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,
   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5B,   0x5C,
   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,
   0x65,   0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,
   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8A,   0x8B,
   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,
   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x99,
   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0x9F,   0xA0,
   0xA1,   0xA2,   0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,
   0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,
   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,   0xB4,
   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC0,
   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,   0xC5,   0xC6,   0xC6,
   0xC7,   0xC8,   0xC9,   0xC9,   0xCA,   0xCB,   0xCC,   0xCC,
   0xCD,   0xCE,   0xCF,   0xCF,   0xD0,   0xD1,   0xD2,   0xD2,
   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,
   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,
   0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE8,   0xE8,   0xE9,
   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xED,   0xEE,   0xEF,
   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF4,   0xF4,
   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF8,   0xF9,   0xFA,
   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},

 { // 1.6
 0x00,   0x08,   0x0C,   0x10,   0x13,   0x16,   0x18,   0x1B,
 0x1D,   0x20,   0x22,   0x24,   0x26,   0x28,   0x2A,   0x2B,
 0x2D,   0x2F,   0x31,   0x32,   0x34,   0x36,   0x37,   0x39,
 0x3A,   0x3C,   0x3D,   0x3F,   0x40,   0x42,   0x43,   0x44,
 0x46,   0x47,   0x48,   0x4A,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x51,   0x53,   0x54,   0x55,   0x56,   0x57,   0x59,
 0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,
 0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6A,
 0x6B,   0x6D,   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,
 0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,
 0x7C,   0x7D,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,
 0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,
 0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,
 0x92,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,
 0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9E,
 0x9F,   0xA0,   0xA1,   0xA2,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,
 0xAC,   0xAD,   0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,
 0xB2,   0xB3,   0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,
 0xB9,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,
 0xBF,   0xBF,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,
 0xC4,   0xC5,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,
 0xD6,   0xD6,   0xD7,   0xD8,   0xD8,   0xD9,   0xDA,   0xDA,
 0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,   0xDF,   0xE0,
 0xE1,   0xE1,   0xE2,   0xE3,   0xE3,   0xE4,   0xE5,   0xE5,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEB,
 0xEB,   0xEC,   0xEC,   0xED,   0xEE,   0xEE,   0xEF,   0xF0,
 0xF0,   0xF1,   0xF2,   0xF2,   0xF3,   0xF4,   0xF4,   0xF5,
 0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF9,   0xF9,   0xFA,
 0xFB,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 1.7
0x00, 0x0A, 0x0F, 0x13, 0x16, 0x19, 0x1C, 0x1F,
0x21, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30,
0x32, 0x34, 0x36, 0x37, 0x39, 0x3B, 0x3C, 0x3E,
0x40, 0x41, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4A,
0x4B, 0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54,
0x56, 0x57, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 0x5E,
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80,
0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3,
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9,
0xAA, 0xAB, 0xAC, 0xAC, 0xAD, 0xAE, 0xAF, 0xAF,
0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB5, 0xB5,
0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 0xBB, 0xBB,
0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1,
0xC2, 0xC3, 0xC3, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7,
0xC7, 0xC8, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCC,
0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2,
0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 0xD7,
0xD8, 0xD8, 0xD9, 0xDA, 0xDA, 0xDB, 0xDC, 0xDC,
0xDD, 0xDE, 0xDE, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2,
0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE5, 0xE6, 0xE7,
0xE7, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEC,
0xEC, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1,
0xF1, 0xF2, 0xF2, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5,
0xF6, 0xF7, 0xF7, 0xF8, 0xF8, 0xF9, 0xFA, 0xFA,
0xFB, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
},

{ // 1.8
 0x00,   0x0C,   0x11,   0x16,   0x19,   0x1D,   0x20,   0x23,
 0x25,   0x28,   0x2A,   0x2C,   0x2F,   0x31,   0x33,   0x35,
 0x37,   0x39,   0x3A,   0x3C,   0x3E,   0x40,   0x41,   0x43,
 0x45,   0x46,   0x48,   0x49,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x52,   0x53,   0x55,   0x56,   0x57,   0x59,   0x5A,
 0x5B,   0x5C,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
 0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
 0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8B,   0x8C,
 0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,   0x93,
 0x94,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,
 0x9B,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,
 0xA1,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,
 0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAC,   0xAD,
 0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,
 0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,
 0xBF,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,   0xCF,
 0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,
 0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,   0xD9,   0xD9,
 0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,
 0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE2,   0xE3,
 0xE4,   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,
 0xE9,   0xE9,   0xEA,   0xEA,   0xEB,   0xEC,   0xEC,   0xED,
 0xED,   0xEE,   0xEE,   0xEF,   0xF0,   0xF0,   0xF1,   0xF1,
 0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,
 0xF7,   0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
},

{  // 1.9
0x00, 0x0E, 0x14, 0x19, 0x1D, 0x20, 0x23, 0x26,
0x29, 0x2C, 0x2E, 0x31, 0x33, 0x35, 0x37, 0x39,
0x3B, 0x3D, 0x3F, 0x41, 0x43, 0x45, 0x46, 0x48,
0x4A, 0x4B, 0x4D, 0x4E, 0x50, 0x51, 0x53, 0x54,
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5E, 0x5F,
0x60, 0x61, 0x63, 0x64, 0x65, 0x66, 0x68, 0x69,
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72,
0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82,
0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
0x8B, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91,
0x92, 0x93, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9D, 0x9E,
0x9F, 0xA0, 0xA1, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5,
0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 0xAA, 0xAB,
0xAB, 0xAC, 0xAD, 0xAE, 0xAE, 0xAF, 0xB0, 0xB1,
0xB1, 0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6,
0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBB, 0xBC,
0xBD, 0xBD, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2,
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC6, 0xC6, 0xC7,
0xC8, 0xC8, 0xC9, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC,
0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1,
0xD2, 0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6,
0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB,
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0,
0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 0xE4,
0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 0xE9,
0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 0xEC, 0xED, 0xEE,
0xEE, 0xEF, 0xEF, 0xF0, 0xF0, 0xF1, 0xF2, 0xF2,
0xF3, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6,
0xF7, 0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB,
0xFB, 0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
},

{ // 2.0
 0x00,   0x10,   0x17,   0x1C,   0x20,   0x24,   0x27,   0x2A,
 0x2D,   0x30,   0x32,   0x35,   0x37,   0x3A,   0x3C,   0x3E,
 0x40,   0x42,   0x44,   0x46,   0x47,   0x49,   0x4B,   0x4D,
 0x4E,   0x50,   0x51,   0x53,   0x54,   0x56,   0x57,   0x59,
 0x5A,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,
 0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,
 0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,
 0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA7,   0xA8,
 0xA9,   0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,   0xAE,
 0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB3,   0xB3,   0xB4,
 0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,   0xBA,
 0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBE,   0xBF,
 0xC0,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xC9,
 0xCA,   0xCB,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,
 0xCF,   0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,
 0xD4,   0xD4,   0xD5,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,
 0xD9,   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,
 0xDD,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,
 0xE2,   0xE2,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE6,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEA,
 0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED,   0xEE,   0xEE,
 0xEF,   0xF0,   0xF0,   0xF1,   0xF1,   0xF2,   0xF2,   0xF3,
 0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,
 0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 2.1
0x00, 0x12, 0x19, 0x1F, 0x23, 0x27, 0x2B, 0x2E,
0x31, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42,
0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x4F, 0x51,
0x53, 0x54, 0x56, 0x58, 0x59, 0x5B, 0x5C, 0x5D,
0x5F, 0x60, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68,
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72,
0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7A, 0x7B,
0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B,
0x8C, 0x8D, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92,
0x93, 0x94, 0x95, 0x95, 0x96, 0x97, 0x98, 0x99,
0x9A, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 0xA4, 0xA5, 0xA6,
0xA6, 0xA7, 0xA8, 0xA9, 0xA9, 0xAA, 0xAB, 0xAC,
0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 0xB0, 0xB1, 0xB1,
0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7,
0xB8, 0xB8, 0xB9, 0xBA, 0xBA, 0xBB, 0xBC, 0xBC,
0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2,
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7,
0xC7, 0xC8, 0xC9, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC,
0xCC, 0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD0,
0xD1, 0xD2, 0xD2, 0xD3, 0xD3, 0xD4, 0xD5, 0xD5,
0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA,
0xDA, 0xDB, 0xDB, 0xDC, 0xDD, 0xDD, 0xDE, 0xDE,
0xDF, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 0xE2, 0xE3,
0xE3, 0xE4, 0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7,
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB,
0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF,
0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3,
0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7,
0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB,
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
},
{ // 2.2
0x00, 0x15, 0x1C, 0x22, 0x27, 0x2B, 0x2E, 0x32,
0x35, 0x38, 0x3B, 0x3D, 0x40, 0x42, 0x44, 0x46,
0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x55,
0x57, 0x59, 0x5A, 0x5C, 0x5D, 0x5F, 0x60, 0x62,
0x63, 0x65, 0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D,
0x6E, 0x6F, 0x70, 0x72, 0x73, 0x74, 0x75, 0x76,
0x77, 0x78, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
0x97, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3,
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA7, 0xA8, 0xA9,
0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAD, 0xAE, 0xAF,
0xAF, 0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB4,
0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA,
0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF,
0xC0, 0xC0, 0xC1, 0xC2, 0xC2, 0xC3, 0xC3, 0xC4,
0xC5, 0xC5, 0xC6, 0xC7, 0xC7, 0xC8, 0xC8, 0xC9,
0xCA, 0xCA, 0xCB, 0xCB, 0xCC, 0xCD, 0xCD, 0xCE,
0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 0xD2, 0xD2,
0xD3, 0xD4, 0xD4, 0xD5, 0xD5, 0xD6, 0xD6, 0xD7,
0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 0xDB,
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0,
0xE0, 0xE1, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4,
0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8,
0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 0xEC,
0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0,
0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 0xF4,
0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 0xF8,
0xF8, 0xF9, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB,
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
}
};

// The codebook: 115 entries stored as sequential triples of unsigned char

static const F_RGB gaOutTableRGB[CT_LOOKUP] = {
0,0,0,0,
0,0,1,0,
0,0,2,0,
0,1,1,0,
0,1,2,0,
0,1,3,0,
0,2,2,0,
0,2,3,0,
0,2,4,0,
1,0,0,0,
1,0,1,0,
1,0,2,0,
1,1,0,0,
1,1,1,0,
1,1,2,0,
1,1,3,0,
1,2,1,0,
1,2,2,0,
1,2,3,0,
1,2,4,0,
1,3,2,0,
1,3,3,0,
1,3,4,0,
1,3,5,0,
2,0,0,0,
2,0,1,0,
2,0,2,0,
2,1,0,0,
2,1,1,0,
2,1,2,0,
2,1,3,0,
2,2,0,0,
2,2,1,0,
2,2,2,0,
2,2,3,0,
2,2,4,0,
2,3,1,0,
2,3,2,0,
2,3,3,0,
2,3,4,0,
2,3,5,0,
2,4,2,0,
2,4,3,0,
2,4,4,0,
2,4,5,0,
2,4,6,0,
3,1,0,0,
3,1,1,0,
3,1,2,0,
3,1,3,0,
3,2,0,0,
3,2,1,0,
3,2,2,0,
3,2,3,0,
3,2,4,0,
3,3,1,0,
3,3,2,0,
3,3,3,0,
3,3,4,0,
3,3,5,0,
3,4,2,0,
3,4,3,0,
3,4,4,0,
3,4,5,0,
3,4,6,0,
3,5,3,0,
3,5,4,0,
3,5,5,0,
3,5,6,0,
4,2,0,0,
4,2,1,0,
4,2,2,0,
4,2,3,0,
4,2,4,0,
4,3,1,0,
4,3,2,0,
4,3,3,0,
4,3,4,0,
4,3,5,0,
4,4,2,0,
4,4,3,0,
4,4,4,0,
4,4,5,0,
4,4,6,0,
4,5,3,0,
4,5,4,0,
4,5,5,0,
4,5,6,0,
4,6,4,0,
4,6,5,0,
4,6,6,0,
5,3,1,0,
5,3,2,0,
5,3,3,0,
5,3,4,0,
5,4,2,0,
5,4,3,0,
5,4,4,0,
5,4,5,0,
5,5,3,0,
5,5,4,0,
5,5,5,0,
5,5,6,0,
5,6,4,0,
5,6,5,0,
5,6,6,0,
6,4,2,0,
6,4,3,0,
6,4,4,0,
6,5,3,0,
6,5,4,0,
6,5,5,0,
6,6,4,0,
6,6,5,0,
6,6,6,0
};

static const F_RGB gaOutTableBGR[CT_LOOKUP] = {
0,0,0,0,
1,0,0,0,
2,0,0,0,
1,1,0,0,
2,1,0,0,
3,1,0,0,
2,2,0,0,
3,2,0,0,
4,2,0,0,
0,0,1,0,
1,0,1,0,
2,0,1,0,
0,1,1,0,
1,1,1,0,
2,1,1,0,
3,1,1,0,
1,2,1,0,
2,2,1,0,
3,2,1,0,
4,2,1,0,
2,3,1,0,
3,3,1,0,
4,3,1,0,
5,3,1,0,
0,0,2,0,
1,0,2,0,
2,0,2,0,
0,1,2,0,
1,1,2,0,
2,1,2,0,
3,1,2,0,
0,2,2,0,
1,2,2,0,
2,2,2,0,
3,2,2,0,
4,2,2,0,
1,3,2,0,
2,3,2,0,
3,3,2,0,
4,3,2,0,
5,3,2,0,
2,4,2,0,
3,4,2,0,
4,4,2,0,
5,4,2,0,
6,4,2,0,
0,1,3,0,
1,1,3,0,
2,1,3,0,
3,1,3,0,
0,2,3,0,
1,2,3,0,
2,2,3,0,
3,2,3,0,
4,2,3,0,
1,3,3,0,
2,3,3,0,
3,3,3,0,
4,3,3,0,
5,3,3,0,
2,4,3,0,
3,4,3,0,
4,4,3,0,
5,4,3,0,
6,4,3,0,
3,5,3,0,
4,5,3,0,
5,5,3,0,
6,5,3,0,
0,2,4,0,
1,2,4,0,
2,2,4,0,
3,2,4,0,
4,2,4,0,
1,3,4,0,
2,3,4,0,
3,3,4,0,
4,3,4,0,
5,3,4,0,
2,4,4,0,
3,4,4,0,
4,4,4,0,
5,4,4,0,
6,4,4,0,
3,5,4,0,
4,5,4,0,
5,5,4,0,
6,5,4,0,
4,6,4,0,
5,6,4,0,
6,6,4,0,
1,3,5,0,
2,3,5,0,
3,3,5,0,
4,3,5,0,
2,4,5,0,
3,4,5,0,
4,4,5,0,
5,4,5,0,
3,5,5,0,
4,5,5,0,
5,5,5,0,
6,5,5,0,
4,6,5,0,
5,6,5,0,
6,6,5,0,
2,4,6,0,
3,4,6,0,
4,4,6,0,
3,5,6,0,
4,5,6,0,
5,5,6,0,
4,6,6,0,
5,6,6,0,
6,6,6,0
};

const F_RGB * gaOutTable = gaOutTableRGB;

const BYTE FilteredCTLut[7*7*7] =
{
0x00,0x01,0x02,0x02,0x05,0x05,0x08,0x00,0x03,0x04,0x05,0x05,0x08,0x08,0x03,0x03,
0x06,0x07,0x08,0x08,0x17,0x10,0x06,0x06,0x07,0x08,0x17,0x17,0x10,0x14,0x14,0x15,
0x16,0x17,0x17,0x14,0x14,0x14,0x15,0x16,0x17,0x2d,0x29,0x29,0x29,0x2a,0x2b,0x2c,
0x2d,0x09,0x0a,0x0b,0x0b,0x0f,0x0f,0x13,0x0c,0x0d,0x0e,0x0f,0x0f,0x13,0x13,0x0c,
0x10,0x11,0x12,0x13,0x13,0x17,0x10,0x10,0x14,0x15,0x16,0x17,0x17,0x24,0x14,0x14,
0x15,0x16,0x17,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x29,0x2a,0x2b,
0x2c,0x2d,0x18,0x19,0x1a,0x1a,0x1e,0x1e,0x23,0x1b,0x1c,0x1d,0x1e,0x1e,0x23,0x23,
0x1f,0x20,0x21,0x22,0x23,0x23,0x28,0x1f,0x24,0x25,0x26,0x27,0x28,0x28,0x24,0x24,
0x29,0x2a,0x2b,0x2c,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x41,0x41,
0x42,0x43,0x44,0x18,0x19,0x1a,0x31,0x31,0x31,0x36,0x2e,0x2f,0x30,0x31,0x31,0x36,
0x36,0x32,0x33,0x34,0x35,0x36,0x36,0x3b,0x32,0x37,0x38,0x39,0x3a,0x3b,0x3b,0x37,
0x37,0x3c,0x3d,0x3e,0x3f,0x40,0x37,0x3c,0x3c,0x41,0x42,0x43,0x44,0x3c,0x3c,0x41,
0x41,0x42,0x43,0x44,0x2e,0x2f,0x30,0x31,0x31,0x49,0x49,0x2e,0x2f,0x30,0x31,0x49,
0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x45,0x4a,0x4b,0x4c,0x4d,0x4e,0x4e,
0x4a,0x4a,0x4f,0x50,0x51,0x52,0x53,0x4a,0x4f,0x4f,0x54,0x55,0x56,0x57,0x4f,0x4f,
0x54,0x54,0x58,0x59,0x5a,0x2e,0x2f,0x30,0x31,0x49,0x49,0x49,0x45,0x46,0x47,0x48,
0x49,0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,0x4e,
0x4e,0x5b,0x5b,0x5f,0x60,0x61,0x62,0x53,0x5b,0x5f,0x5f,0x63,0x64,0x65,0x66,0x5f,
0x5f,0x63,0x63,0x67,0x68,0x69,0x45,0x46,0x47,0x48,0x49,0x49,0x49,0x45,0x46,0x47,
0x48,0x49,0x49,0x49,0x5b,0x5b,0x5c,0x5d,0x5e,0x5e,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,
0x5e,0x62,0x5b,0x6a,0x6a,0x6b,0x6c,0x62,0x62,0x6a,0x6a,0x6a,0x6d,0x6e,0x6f,0x66,
0x6a,0x6a,0x6d,0x6d,0x70,0x71,0x72};

} // namespace Globals


// The encoding lookup table. There are 3^5 possible entries corresponding to
// 5 emmiters: BP, RT, GT, BT, RN

const BYTE gajStorageTable[CT_STORAGE] = {
  0,  1,  2,  3,  4,  5,  6,  7,  8,
 13, 14, 15, 17, 18, 19, 21, 22, 23,
 33, 34, 35, 38, 39, 40, 43, 44, 45,
 12, 13, 14, 16, 17, 18, 20, 21, 22,
 32, 33, 34, 37, 38, 39, 42, 43, 44,
 56, 57, 58, 61, 62, 63, 66, 67, 68,
 31, 32, 33, 36, 37, 38, 41, 42, 43,
 55, 56, 57, 60, 61, 62, 65, 66, 67,
 79, 80, 81, 84, 85, 86, 88, 89, 90,
  9, 10, 11, 13, 14, 15, 17, 18, 19,
 28, 29, 30, 33, 34, 35, 38, 39, 40,
 52, 53, 54, 57, 58, 59, 62, 63, 64,
 27, 28, 29, 32, 33, 34, 37, 38, 39,
 51, 52, 53, 56, 57, 58, 61, 62, 63,
 75, 76, 77, 80, 81, 82, 85, 86, 87,
 50, 51, 52, 55, 56, 57, 60, 61, 62,
 74, 75, 76, 79, 80, 81, 84, 85, 86,
 95, 96, 97, 99,100,101,103,104,105,
 24, 25, 26, 28, 29, 30, 33, 34, 35,
 47, 48, 49, 52, 53, 54, 57, 58, 59,
 71, 72, 73, 76, 77, 78, 81, 82, 83,
 46, 47, 48, 51, 52, 53, 56, 57, 58,
 70, 71, 72, 75, 76, 77, 80, 81, 82,
 92, 93, 94, 96, 97, 98,100,101,102,
 69, 70, 71, 74, 75, 76, 79, 80, 81,
 91, 92, 93, 95, 96, 97, 99,100,101,
106,107,108,109,110,111,112,113,114
};

const BYTE gajStorageTableBloated[CT_STORAGE] = {
  0,  2,  5,  6,  8,  8, 22, 23, 23,
 33, 35, 40, 43, 45, 45, 44, 45, 45,
 61, 63, 63, 66, 68, 68, 67, 68, 68,
 31, 33, 38, 41, 43, 43, 66, 67, 67,
 79, 81, 86, 88, 90, 90, 89, 90, 90,
 84, 86, 86, 88, 90, 90, 89, 90, 90,
 74, 76, 81, 84, 86, 86, 85, 86, 86,
 95, 97,101,103,105,105,104,105,105,
 99,101,101,103,105,105,104,105,105,
 24, 26, 30, 33, 35, 35, 58, 59, 59,
 71, 73, 78, 81, 83, 83, 82, 83, 83,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 46, 48, 53, 56, 58, 58, 81, 82, 82,
 92, 94, 98,100,102,102,101,102,102,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114
};

// rasterizer returns unfiltered data in 2,2,2 format for r,g,b

#define GETRED(j)  (((j) >> 4) & 3)
#define GETGRE(j)  (((j) >> 2) & 3)
#define GETBLU(j)  (((j) >> 0) & 3)

#define R_SET(j)   ((j) & 0X30)
#define B_SET(j)   ((j) & 0X03)

#define FL_LEFT_LEAK   1
#define FL_RIGHT_LEAK  2

// because of the color filtering we may need to expand the original bitmap
// by one column of zero pixels on the left and on the right.
// After we perform the color filtering the column of left edge will pick up
// a non-trivial Blue component (color "leak" from the leftmost pixel in the
// original bitmap) while the column on the right edge will pick up the
// nontrivial Red component from the "leakage" of the rightmost pixel in the
// original bitmap. [BodinD]

ULONG ulClearTypeFilter(GLYPHBITS *pgb, ULONG cjBits, CacheFaceRealization *prface)
{
    const ULONG cx = pgb->sizlBitmap.cx;
    const ULONG cy = pgb->sizlBitmap.cy;
    const BYTE * pCurrentStorageTable = gajStorageTable;

    if (prface->Face->pifi->flInfo & (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH) /* the font is fixed pitch */
        /* we need find some way for horizontal transform */
        && (prface->Face->pifi->usWinWeight <= FW_NORMAL) /* normal or thin weight */
        && (!UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Courier New")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Rod")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Rod Transparent")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Fixed Miriam Transparent")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Miriam Fixed")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Simplified Arabic Fixed")
          )
        )
    {
        /* Courier New look too thin with ClearType standard filter, let's use a bloated filter : */
        pCurrentStorageTable = gajStorageTableBloated;
    }


    FLONG flCTBits = 0;
    ULONG cyT = cy;

    for (BYTE *pjScan = pgb->aj; cyT; cyT--, pjScan += cx)
    {
        if (R_SET(pjScan[0]))
            flCTBits |= FL_LEFT_LEAK;

        if (B_SET(pjScan[cx - 1]))
            flCTBits |= FL_RIGHT_LEAK;

        if ((flCTBits & (FL_LEFT_LEAK | FL_RIGHT_LEAK)) == (FL_LEFT_LEAK | FL_RIGHT_LEAK))
            break;
    }

// we need to copy and filter in the same pass for performance reasons,
// we traverse the source backwards, so that we do not overwrite it

    ULONG cxD = cx;

    if (flCTBits & FL_LEFT_LEAK)
        cxD += 1;

    if (flCTBits & FL_RIGHT_LEAK)
        cxD += 1;

    BYTE jP, jT, jN;

    ULONG kBP;          // unfiltered blue count from the previous pixel
    ULONG kRN;          // unfiltered red count from the next pixel
    ULONG kRT, kGT, kBT;   // unfiltered counts from this pixel

    BYTE * pjSrcScanEnd = pgb->aj + (cx * cy) - 1;
    BYTE * pjDstScanEnd = pgb->aj + (cxD * cy) - 1;

    for ( ; pjDstScanEnd > pgb->aj; pjDstScanEnd -= cxD, pjSrcScanEnd -= cx)
    {
        BYTE *pjD1, *pjS1, *pjS0;

        pjD1 = pjDstScanEnd;
        pjS1 = pjSrcScanEnd;
        pjS0 = pjS1 - cx;

    // for the right border pixel jN = 0; jT = 0; jP = *pjS1;
    // therefore:
    //
    // kBP = GETBLU(*pjS1);  // GETBLU(jP);
    // kRN = 0; // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));

        if (flCTBits & FL_RIGHT_LEAK)
        {
            *pjD1-- = pCurrentStorageTable[3 * 3 * 3 * 3 * GETBLU(*pjS1)];
        }

    // initialize the loop in the middle

        for (jN = 0, jT = *pjS1; pjS1 > pjS0; pjS1--, pjD1--, jN = jT, jT = jP)
        {
            jP = (pjS1 == &pjS0[1]) ? 0 : pjS1[-1];

            kBP = GETBLU(jP);
            kRN = GETRED(jN);

            if (kBP || jT || kRN) // must compute, else optimize
            {
                kRT = GETRED(jT);
                kGT = GETGRE(jT);
                kBT = GETBLU(jT);

            // now convert this to a filtered index in the lookup table range
            // this is the trick, filtering and storing is done in one step

                ULONG iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
                *pjD1 = pCurrentStorageTable[iStorage];
            }
            else
            {
                *pjD1 = 0;
            }
        }

    // for the left border pixel jP = 0; jT = 0; jN = pjS0[1];
    // therefore:
    //
    // kBP = 0; // GETBLU(jP);
    // kRN = GETRED(pjS0[1]); // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
    // i.e. iStorage = kRN, which implies:

        if (flCTBits & FL_LEFT_LEAK)
        {
            *pjD1 = pCurrentStorageTable[ GETRED(pjS0[1]) ];
        }
    }

// fix the size and the origin

    pgb->sizlBitmap.cx = cxD;
    if (flCTBits & FL_LEFT_LEAK)
    {
        pgb->ptlUprightOrigin.x -= 1;
        pgb->ptlSidewaysOrigin.x -= 1;
    }

    return CJ_CTGD(cxD, cy);
}

void TextColorGammaTable::CreateTextColorGammaTable(const GpColor * color, ULONG value, ULONG gsLevel)
{
    gammaValue = value;

    if (color)
    {
        ULONG i;
        ULONG k = gsLevel - 1;

        if (gammaValue)
        {
            ULONG k = gammaValue - 1;

            for (i = 0; i < gsLevel; i++)
            {
                ULONG j;
                j = (ULONG) 255-(((ULONG) 255 * (ULONG) i) / (gsLevel - 1));

                argb[i] = color->PremultiplyWithCoverage(color->GetValue(), 255 - Globals::TextContrastTablesInv[k][j]);
            }
        }
        else
        {
            for (i = 0; i < gsLevel; i++)
            {
                ULONG j;
                argb[i] = color->PremultiplyWithCoverage(color->GetValue(),  (BYTE)((255 * i) / (gsLevel - 1)));
            }
        }
    }
}

BYTE TextColorGammaTable::GetGammaTableIndexValue(BYTE grayscaleValue, ULONG gsLevel)
{
    if (gammaValue)
    {
        ULONG k = gammaValue - 1;

        ULONG j;
        j = (ULONG) 255-(((ULONG) 255 * (ULONG) grayscaleValue) / (gsLevel - 1));

       return ((BYTE)255 - Globals::TextContrastTablesInv[k][j]);
    }
    else
    {
       return (BYTE)(((ULONG) 255 * (ULONG) grayscaleValue) / (gsLevel - 1));
    }
}

DpOutputAntiAliasSolidColorSpan::DpOutputAntiAliasSolidColorSpan(GpColor &color, DpScanBuffer * scan, ULONG gammaValue, ULONG gsLevel)
                                : DpOutputSolidColorSpan( 0, scan)
{
    textColorGammaTable.CreateTextColorGammaTable(&color, gammaValue, gsLevel);
}

GpStatus DpOutputAntiAliasBrushOutputSpan::OutputSpan(INT y, INT xMin, INT xMax)
{
    Output->OutputSpan(y, xMin, xMax);

    ARGB *buffer;

    buffer = Output->GetScanBuffer()->GetCurrentBuffer();

    for (INT j = xMin; j < xMax; j++)
    {
        *buffer++ = GpColor::MultiplyCoverage(*buffer, alphaCoverage);
    }

    return Ok;
}

void UpdateLCDOrientation()
{
    DWORD dwOrientation = FE_FONTSMOOTHINGORIENTATIONRGB;
    BOOL ret = SystemParametersInfoA(SPI_GETFONTSMOOTHINGORIENTATION, 0, &dwOrientation, 0);
    if (!ret)
        dwOrientation = FE_FONTSMOOTHINGORIENTATIONRGB;

    if ((dwOrientation & FE_FONTSMOOTHINGORIENTATIONRGB) != 0)
    {
        Globals::gaOutTable = Globals::gaOutTableRGB;
    }
    else
    {
        Globals::gaOutTable = Globals::gaOutTableBGR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\cachedbitmap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************
*
* Function Description:
*
*   This function renders the GpCachedBitmap on the GpGraphics.
*
* Arguments:
*  
*   inputCachedBitmap - the input data.
*   x, y              - destination offset.
*
* Return Value:
*
*   Returns Ok if successful
*   Returs WrongState if the GpGraphics and GpCachedBitmap have
*   different pixel formats.
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/
GpStatus 
GpGraphics::DrvDrawCachedBitmap(
    GpCachedBitmap *inputCachedBitmap,
    INT x, 
    INT y
)
{
    // Internally we must be called with a valid object.
    
    ASSERT(inputCachedBitmap->IsValid());
    
    // Don't attempt to record a cached bitmap to a metafile
    if (IsRecording())
        return WrongState;

    // First grab the device lock so that we can protect all the
    // non-reentrant code in the DpScanBuffer class.

    Devlock devlock(Device);

    // Check the world transform
    
    if(!(Context->WorldToDevice.IsTranslate()))
    {
        // There is a complex transform selected into the graphics.
        // fail the call.
        return WrongState;
    }

    // Can't check the pixel format here because of the possibility of
    // MultiMon - we'd be checking against the meta device surface
    // -- although maybe that's the correct behaviour.    
    
    // Set up the world to device translation offset.
    
    INT xOffset = x+GpRound(Context->WorldToDevice.GetDx());
    INT yOffset = y+GpRound(Context->WorldToDevice.GetDy());

    // Store the rendering origin so we can restore it later.
    
    INT renderX, renderY;
    GetRenderingOrigin(&renderX, &renderY);
    
    // Set the rendering origin to the origin of the CachedBitmap drawing
    // so that the dither matrix offset of the semi-transparent pixels 
    // matches that of the already dithered (stored) native pixels.

    SetRenderingOrigin(xOffset, yOffset);

    // Call the driver to draw the cached bitmap.
    // Note: the driver does not respect the world to device transform
    // it expects device coordinates for this API.

    GpStatus status = Driver->DrawCachedBitmap(
        Context,
        &inputCachedBitmap->DeviceCachedBitmap,
        Surface,
        xOffset, 
        yOffset
    );

    // Restore the rendering origin.

    SetRenderingOrigin(renderX, renderY);

    return status;    
}

/**************************************************************************
*
* Function Description:
*
*   Constructs the GpCachedBitmap based on the pixel format and
*   rendering quality derived from the GpGraphics and the bits
*   from the GpBitmap.
*
* Arguments:
*
*   graphics - input graphics to be compatible with
*   bitmap   - data to be cached.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/


enum TransparencyState {
    Transparent,
    SemiTransparent,
    Opaque
};

inline TransparencyState GetTransparency(ARGB pixel)
{
    if((pixel & 0xff000000) == 0xff000000) {return Opaque;}
    if((pixel & 0xff000000) == 0x00000000) {return Transparent;}
    return SemiTransparent;
}

// Intermetiate record used to parse the transparency information
// in the bitmap.

struct ScanRecordTemp
{
    // Pointer to the start and end of the run.
    
    ARGB *pStart;
    ARGB *pEnd;    // exclusive end.

    // Transparency

    TransparencyState tsTransparent;

    // Position

    INT x, y;        
    INT width;    // in pixels
};

// Simple macro to make the failure cases easier to read.

#define FAIL() \
        SetValid(FALSE); \
        return

GpCachedBitmap::GpCachedBitmap(GpBitmap *bitmap, GpGraphics *graphics)
{
    BitmapData bmpDataSrc;

    // Lock the bits.
    // we need to convert the bits to the appropriate format.

    // Note - we're assuming that the knowledgeable user will be
    // initializing their CachedBitmap with a 32bppPARGB surface.
    // This is important for performance at creation time, because
    // the LockBits below can avoid a costly clone & convert format.

    if (bitmap == NULL ||
        !bitmap->IsValid() ||
        bitmap->LockBits(
            NULL,
            IMGLOCK_READ,
            PIXFMT_32BPP_PARGB,
            &bmpDataSrc
        ) 
        != Ok)
    {
        FAIL();
    }

    // copy the dimensions.

    DeviceCachedBitmap.Width = bmpDataSrc.Width;
    DeviceCachedBitmap.Height = bmpDataSrc.Height;

    // Create a dynamic array to store the transparency transition points.
    // The initial allocation size is based on an estimate of 3 
    // transition events per scanline. Overestimate.
    
    DynArray<ScanRecordTemp> RunData;

    RunData.ReserveSpace(4*DeviceCachedBitmap.Height);

    // Scan through the bits adding an item to the dynamic list every
    // time a new run would be required in the output - i.e. when the
    // transparency changes to one of opaque or semi-transparent.
    // Before the beginning of a scanline is considered to be transparent.
    // While scanning through the bits, keep a running total of the 
    // size of the final RLE bitmap - so we know how much space to allocate.

    // Size of the final RLE bitmap in bytes;
    
    // This is not actually a pointer to an EpScanRecord - it is simply
    // a mechanism to work out how big to allocate the buffer
       
    EpScanRecord *RLESize = (EpScanRecord *)0;

    // Pointer to the current position in the source.

    ARGB *src;
    ARGB *runStart;

    // Temporary ScanRecord used to accumulate the runs.

    ScanRecordTemp sctTmp;

    TransparencyState tsThisPixel;
    TransparencyState tsCurrentRun;


    DpBitmap *Surface = graphics->GetSurface();
    void *Buffers[5];

    // Create the blending buffers for the alpha blender.
    
    // !!! [asecchia] While we don't currently depend on this behaviour,
    // it seems like a bug that a graphics wrapped around a bitmap uses
    // the desktop display device and driver. This leads to weirdness 
    // if we try use GetScanBuffers to derive the pixel format of the 
    // destination. For example a graphics around a PixelFormat24bppRGB 
    // bitmap would return PixelFormat16bppRGB565 if the screen is in
    // 16bpp mode !?
    // However, the Buffers[] returned will be allocated as 64bpp buffers
    // and therefore will have the correct properties under all circumstances.
        
    if (!graphics->GetDriver()->Device->GetScanBuffers(
        Surface->Width, 
        NULL, 
        NULL, 
        NULL, 
        Buffers)
       )
    {
        FAIL();
    }

    // Compute the destination pixel format.
    
    PixelFormatID dstFormat = Surface->PixelFormat;
        
    if(dstFormat == PixelFormatUndefined) { FAIL(); }

    // The following destination formats are not supported.
    // In particular, no palettized modes are supported because
    // tracking the cached opaque data in native format across
    // palette changes would be a nightmare.
    // Instead we set the opaque format to be 32bppRGB and force
    // the EpAlphaBlender to do the work at render time - slower
    // but it will work.
    
    if( !EpAlphaBlender::IsSupportedPixelFormat(dstFormat) ||
        IsIndexedPixelFormat(dstFormat) ||
        
        // If the graphics is for a multi format device such as 
        // a multimon meta-screen.
        
        dstFormat == PixelFormatMulti
    )
    {
        // We don't want to silently fail if the input
        // is undefined.
        
        ASSERT(dstFormat != PixelFormatUndefined);
        
        // Opaque pixels - we don't support palettized modes
        // and some of the other weird ones

        dstFormat = PixelFormat32bppRGB;
    }

    // Size of a destination pixel in bytes.

    INT dstFormatSize = GetPixelFormatSize(dstFormat) >> 3;


    // Run through each scanline.

    for(INT y = 0; y < DeviceCachedBitmap.Height; y++)
    {
        // Point to the beginning of this scanline.

        src = reinterpret_cast<ARGB*>(
            reinterpret_cast<BYTE*>(bmpDataSrc.Scan0) + y * bmpDataSrc.Stride
        );

        // Start the run off with transparency.

        tsCurrentRun = Transparent;
        runStart = src;

        // Run through all the pixels in this scanline.

        for(INT x = 0; x < DeviceCachedBitmap.Width; x++)
        {

            // Compute the transparency state for the current pixel.

            tsThisPixel = GetTransparency(*src);

            // If a transparency transition occurs, 

            if(tsThisPixel != tsCurrentRun)
            {
                // Close off the last transition and store a record if it wasn't
                // a transparent run.

                if(tsCurrentRun != Transparent)
                {
                    sctTmp.pStart = runStart;
                    sctTmp.pEnd = src;
                    sctTmp.tsTransparent = tsCurrentRun;
                    sctTmp.y = y;
                    
                    // src is in PixelFormat32bppPARGB so we can divide the 
                    // pointer difference by 4 to figure out the number of 
                    // pixels in this run.
                    
                    sctTmp.width = (INT)(((INT_PTR)src - (INT_PTR)runStart)/sizeof(ARGB));
                    sctTmp.x = x - sctTmp.width;

                    if(RunData.Add(sctTmp) != Ok) { FAIL(); }

                    // Add the size of the record

                    if (tsCurrentRun == SemiTransparent) 
                    {
                        // This is the semi-transparent case.

                        RLESize = EpScanRecord::CalculateNextScanRecord(
                            RLESize,
                            EpScanTypeBlend,
                            sctTmp.width,
                            sizeof(ARGB)
                        );
                    } 
                    else 
                    {
                        // This is the opaque case.
                        
                        ASSERT(tsCurrentRun == Opaque);

                        RLESize = EpScanRecord::CalculateNextScanRecord(
                            RLESize,
                            EpScanTypeOpaque,
                            sctTmp.width,
                            dstFormatSize
                        );
                    }
                }

                // Update the run tracking variables.

                runStart = src;
                tsCurrentRun = tsThisPixel;
            }

            // Look at the next pixel.

            src++;
        }

        // Close off the last run for this scanline (if it's not transparent).

        if(tsCurrentRun != Transparent)
        {
            sctTmp.pStart = runStart;
            sctTmp.pEnd = src;
            sctTmp.tsTransparent = tsCurrentRun;
            sctTmp.y = y;
            
            // Size of the source is 32bits (PARGB).
            
            sctTmp.width = (INT)(((INT_PTR)src - (INT_PTR)runStart)/sizeof(ARGB));
            sctTmp.x = x - sctTmp.width;
            if(RunData.Add(sctTmp)!=Ok) { FAIL(); }
            
            // Add the size of the record

            if (tsCurrentRun == SemiTransparent) 
            {
                // This is the semi-transparent case.

                RLESize = EpScanRecord::CalculateNextScanRecord(
                    RLESize,
                    EpScanTypeBlend,
                    sctTmp.width,
                    sizeof(ARGB)
                );
            } 
            else 
            {
                // This is the opaque case.
                
                ASSERT(tsCurrentRun == Opaque);

                RLESize = EpScanRecord::CalculateNextScanRecord(
                    RLESize,
                    EpScanTypeOpaque,
                    sctTmp.width,
                    dstFormatSize
                );
            }
        }        
    }

    ASSERT(RLESize >= 0);

    // Allocate space for the RLE bitmap.
    // This should be the exact size required for the RLE bitmap.
    // Add 8 bytes to handle the fact that GpMalloc may not return
    // a 64bit aligned allocation.

    void *RLEBits = GpMalloc((INT)(INT_PTR)(RLESize)+8);
    if(RLEBits == NULL) { FAIL(); }       // Out of memory.
    
    // QWORD-align the result
    
    EpScanRecord *recordStart = MAKE_QWORD_ALIGNED(EpScanRecord *, RLEBits);
    
    // Scan through the dynamic array and add each record to the RLE bitmap
    // followed by its bits (pixels).
    // For native format pixels (opaque) use the EpAlphaBlender to 
    // convert to native format.

    // Query for the number of records in the RunData

    INT nRecords = RunData.GetCount();

    EpScanRecord *rec = recordStart;
    ScanRecordTemp *pscTmp;

    // Store the rendering origin so we can modify it.
    // The graphics must be locked at the API.

    INT renderX, renderY;
    graphics->GetRenderingOrigin(&renderX, &renderY);

    // Set the rendering origin to the top left corner of the CachedBitmap
    // so that the dither pattern for the native pixels will match
    // the dither pattern for the semi-transparent pixels (rendered later
    // in DrawCachedBitmap).

    graphics->SetRenderingOrigin(0,0);


    // Make a 32bppPARGB->Native conversion blender.
    // This will be used for converting the 32bppPARGB
    // source data into the native pixel format (dstFormat)
    // of the destination.
    // For palettized modes, dstFormat is 32bppRGB

    EpAlphaBlender alphaBlender;
  
    alphaBlender.Initialize(
        EpScanTypeOpaque,
        dstFormat,
        PixelFormat32bppPARGB,
        graphics->Context,
        NULL,        
        Buffers,
        TRUE,
        FALSE,
        0
    );

    // For each record ...

    for(INT i=0; i<nRecords; i++)
    {
        // Make sure we don't overrun our buffer...

        ASSERT((INT_PTR)rec < (INT_PTR)recordStart + (INT_PTR)RLESize);

        // Copy the data into the destination record.

        pscTmp = &RunData[i];
        rec->X = pscTmp->x;
        rec->Y = pscTmp->y;
        rec->Width = rec->OrgWidth = pscTmp->width;
        
        // We should never store a transparent run.

        ASSERT(pscTmp->tsTransparent != Transparent);
        
        if(pscTmp->tsTransparent == Opaque)
        {
            // Use the native pixel format for the destination.

            rec->BlenderNum = 1;
            rec->ScanType = EpScanTypeOpaque;
            
            // Find the start of the new pixel run.
    
            VOID *dst = rec->GetColorBuffer(); 

            // Compute the number of bytes per pixel.

            INT pixelFormatSize = GetPixelFormatSize(dstFormat) >> 3;

            // This should perform a source over blend from 32bppPARGB
            // to the native format into the destination.

            // For CachedBitmaps, the dither origin is always the top 
            // left corner of the CachedBitmap (i.e. 0, 0).
            // In 8bpp we dither down while rendering and get the correct
            // origin at that time.

            alphaBlender.Blend(
                dst, 
                pscTmp->pStart, 
                pscTmp->width, 
                pscTmp->x, 
                pscTmp->y,
                NULL
            );
            
            // Increment position to the next record.

            rec = rec->NextScanRecord(pixelFormatSize);
        }
        else
        {
            rec->BlenderNum = 0;
            rec->ScanType = EpScanTypeBlend;

            // Find the start of the new pixel run.
    
            VOID *dst = rec->GetColorBuffer(); 
            
            // Semi-Transparent pixels are stored in 32bpp PARGB, so
            // we can simply copy the pixels.

            GpMemcpy(dst, pscTmp->pStart, pscTmp->width*sizeof(ARGB));
            
            // Increment position to the next record.

            rec = rec->NextScanRecord(sizeof(ARGB));
        }

    }

    // Restore the rendering origin.

    graphics->SetRenderingOrigin(renderX, renderY);

    // Finally store the pointer to the RLE bits in the DeviceCachedBitmap

    DeviceCachedBitmap.Bits = RLEBits;
    DeviceCachedBitmap.RecordStart = recordStart;
    DeviceCachedBitmap.RecordEnd = rec;
    DeviceCachedBitmap.OpaqueFormat = dstFormat;
    DeviceCachedBitmap.SemiTransparentFormat = PixelFormat32bppPARGB;

    bitmap->UnlockBits(&bmpDataSrc);
    
    // Everything is golden - set Valid to TRUE
    // all the error paths early out with Valid set to FALSE

    SetValid(TRUE);
}

#undef FAIL

GpCachedBitmap::~GpCachedBitmap()
{
    // throw away the cached bitmap storage.

    GpFree(DeviceCachedBitmap.Bits);
    
    SetValid(FALSE);    // so we don't use a deleted object
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\compatibledib.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*    Compatible DIBSections
*
* Abstract:
*
*    Create a DIB section with an optimal format w.r.t. the specified hdc.
*    If the hdc format is <8bpp, returns an 8bpp DIBSection.
*    If the hdc format is not recognized, returns a 32bpp DIBSection.
*
* Notes:
*
* History:
*
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Added it to GDI+ (from Gilman's 'fastdib.c'), and morphed it into 
*     'CreateSemiCompatibleDIB'.
*  08/10/2000 agodfrey
*     Hacked it further so that if we don't understand the format, we make
*     a 32bpp section. Bug #96879. 
*
\**************************************************************************/

#include "precomp.hpp"
#include "compatibleDIB.hpp"


const DWORD AlphaMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x00000000, // PixelFormat16bppRGB555
    0x00000000, // PixelFormat16bppRGB565
    0x00008000, // PixelFormat16bppARGB1555
    0x00000000, // PixelFormat24bppRGB
    0x00000000, // PixelFormat32bppRGB
    0xff000000, // PixelFormat32bppARGB
    0xff000000, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x00000000  // PixelFormat24bppBGR
};

const DWORD RedMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x00007c00, // PixelFormat16bppRGB555
    0x0000f800, // PixelFormat16bppRGB565
    0x00007c00, // PixelFormat16bppARGB1555
    0x00ff0000, // PixelFormat24bppRGB
    0x00ff0000, // PixelFormat32bppRGB
    0x00ff0000, // PixelFormat32bppARGB
    0x00ff0000, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x000000ff  // PixelFormat24bppBGR
};

const DWORD GreenMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x000003e0, // PixelFormat16bppRGB555
    0x000007e0, // PixelFormat16bppRGB565
    0x000003e0, // PixelFormat16bppARGB1555
    0x0000ff00, // PixelFormat24bppRGB
    0x0000ff00, // PixelFormat32bppRGB
    0x0000ff00, // PixelFormat32bppARGB
    0x0000ff00, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x0000ff00  // PixelFormat24bppBGR
};

const DWORD BlueMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x0000001f, // PixelFormat16bppRGB555
    0x0000001f, // PixelFormat16bppRGB565
    0x0000001f, // PixelFormat16bppARGB1555
    0x000000ff, // PixelFormat24bppRGB
    0x000000ff, // PixelFormat32bppRGB
    0x000000ff, // PixelFormat32bppARGB
    0x000000ff, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x00ff0000  // PixelFormat24bppBGR
};


/**************************************************************************\
* CreatePBMIFromPixelFormat
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by analyzing the pixelFormat
*
* Arguments:
*    OUT pbmi : this must point to a valid BITMAPINFO structure
*               which has enough space for the palette (RGBQUAD array)
*               and MUST be zero initialized.
*    palette  : Input palette that will be copied into the BITMAPINFO
*               if it's a palettized mode.
*    pixelFormat : Input pixel format.
*  
*
* History:
*  06/07/1995 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Munged it for GDI+'s needs.
*  08/11/2000 asecchia
*     Extracted the pixel format detection into a separate routine.
*     It now analyzes the pixelformat for all its data.
*
\**************************************************************************/

static VOID
CreatePBMIFromPixelFormat(
    OUT BITMAPINFO *pbmi,
    IN ColorPalette *palette, 
    IN PixelFormatID pixelFormat
    )
{
    // NOTE: Contents of pbmi should be zero initialized by the caller.
    
    ASSERT(pbmi != NULL);    
    if(pixelFormat == PixelFormatUndefined) { return; }
    
    // GDI can't handle the following formats: 
    
    ASSERT(
        pixelFormat != PixelFormatUndefined &&
        pixelFormat != PixelFormat16bppGrayScale &&
        pixelFormat != PixelFormat16bppARGB1555 &&
        pixelFormat != PixelFormat48bppRGB &&
        pixelFormat != PixelFormat64bppARGB &&
        pixelFormat != PixelFormat64bppPARGB
    );
 
    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 0;
    pbmi->bmiHeader.biHeight = 0;
    pbmi->bmiHeader.biPlanes = 1;    
    pbmi->bmiHeader.biBitCount = (WORD)GetPixelFormatSize(pixelFormat);
        
    pbmi->bmiHeader.biCompression = BI_RGB;
    
    if (IsIndexedPixelFormat(pixelFormat))
    {        
        // Fill the color table

        // If there's no palette, assume the caller is going to 
        // set it up.
                
        if(palette)
        {
            RGBQUAD *rgb = pbmi->bmiColors;
            UINT         i;
            
            for (i=0; i<palette->Count; i++, rgb++)
            {
               GpColor color(palette->Entries[i]);
            
               rgb->rgbRed    = color.GetRed();
               rgb->rgbGreen  = color.GetGreen();
               rgb->rgbBlue   = color.GetBlue();
            }
        }
    }
    else
    {
        INT pfSize = GetPixelFormatSize(pixelFormat);
        
        if( (pfSize==16) || (pfSize==32) )
        {
            // BI_BITFIELDS is only valid on 16- and 32-bpp formats.
            
            pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        }
        
        // Get the masks from the 16bpp, 24bpp and 32bpp formats.
        DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);
        INT formatIndex = GetPixelFormatIndex(pixelFormat);
        
        masks[0] = RedMaskFromPixelFormatIndex[formatIndex];
        masks[1] = GreenMaskFromPixelFormatIndex[formatIndex];
        masks[2] = BlueMaskFromPixelFormatIndex[formatIndex];
    }
}

/**************************************************************************\
* CreateSemiCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DC format <= 8bpp, creates an 8bpp section using the specified palette.
* If the palette handle is NULL, then the system palette is used.
*
* Otherwise, if the DC format is not natively supported, creates a 32bpp
* section.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Arguments:
*
*   hdc                 - The reference hdc
*   ulWidth             - The width of the desired DIBSection
*   ulHeight            - The height of the desired DIBSection
*   palette             - The palette for <=8bpp modes
*   [OUT] ppvBits       - A pointer to the DIBSection's bits
*   [OUT] pixelFormat   - The pixel format of the returned DIBSection
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Munged it for GDI+'s needs.
*  08/11/2000 asecchia
*     Call more general pixel format determination code.
\**************************************************************************/

HBITMAP 
CreateSemiCompatibleDIB(
    HDC hdc,
    ULONG ulWidth, 
    ULONG ulHeight,
    ColorPalette *palette,
    PVOID *ppvBits,
    PixelFormatID *pixelFormat
    )
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    ASSERT(GetDCType(hdc) == OBJ_DC);
    ASSERT(pixelFormat && ppvBits);

    // Zero initialize the pbmi. This is a requirement for 
    // CreatePBMIFromPixelFormat()
    
    GpMemset(aj, 0, sizeof(aj));

    *pixelFormat = ExtractPixelFormatFromHDC(hdc);
    
    if(IsIndexedPixelFormat(*pixelFormat))
    {
        // For indexed modes, we only support 8bpp. Lower bit-depths
        // are supported via 8bpp mode, if at all.
        
        *pixelFormat = PixelFormat8bppIndexed;
    }

    // Not all printer HDC's have queriable palettes, the GpDevice()
    // constructor doesn't support it.  Fake 32bpp in this case.
    
    // Also, if the format is undefined, use 32bpp, and the caller will use
    // GDI to do the conversion.
    
    if (   (   (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER)
            && (IsIndexedPixelFormat(*pixelFormat))
           )
        || (*pixelFormat == PixelFormatUndefined)
       )
    {
        *pixelFormat = PixelFormat32bppRGB;
    }
    
    CreatePBMIFromPixelFormat(pbmi, palette, *pixelFormat);
    
    // Change bitmap size to match specified dimensions.

    pbmi->bmiHeader.biWidth = ulWidth;
    pbmi->bmiHeader.biHeight = ulHeight;
    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        pbmi->bmiHeader.biSizeImage = 0;
    }
    else
    {
        if ( pbmi->bmiHeader.biBitCount == 16 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
        else if ( pbmi->bmiHeader.biBitCount == 32 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
        else
            pbmi->bmiHeader.biSizeImage = 0;
    }
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    // Create the DIB section.  Let Win32 allocate the memory and return
    // a pointer to the bitmap surface.

    hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

    if ( !hbmRet )
    {
        ONCE(WARNING(("CreateSemiCompatibleDIB: CreateDIBSection failed")));
    }

    return hbmRet;
}

/**************************************************************************\
* ExtractPixelFormatFromHDC
* 
* Returns:
*   PixelFormatID if successful, PixelFormatUndefined if not.
*
* History:
*  08/11/2000 asecchia
*     Created it.
\**************************************************************************/

PixelFormatID
ExtractPixelFormatFromHDC(
    HDC hdc
    )
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;
    PixelFormatID pixelFormat = PixelFormatUndefined;
    
    BYTE bmi_buf[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) bmi_buf;
    
    GpMemset(bmi_buf, 0, sizeof(bmi_buf));
    
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        // First handle the 'simple' case of indexed formats.
        
        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            switch(pbmi->bmiHeader.biBitCount)
            {
            case 1: pixelFormat = PixelFormat1bppIndexed; break;
            case 4: pixelFormat = PixelFormat4bppIndexed; break;
            case 8: pixelFormat = PixelFormat8bppIndexed; break;
            
            // Fallthrough on default - the pixelFormat is already
            // initialized to PixelFormatUndefined.
            default: 
                WARNING((
                    "BitDepth %d from GetDIBits is not supported.", 
                    pbmi->bmiHeader.biBitCount
                ));                
            }
        }
        else
        {
            DWORD redMask = 0;
            DWORD greenMask = 0;
            DWORD blueMask = 0;
            
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".

                GetDIBits(
                    hdc, 
                    hbm, 
                    0, 
                    pbmi->bmiHeader.biHeight, 
                    NULL, 
                    pbmi,
                    DIB_RGB_COLORS
                );
                          
                DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);

                redMask = masks[0];
                greenMask = masks[1];
                blueMask = masks[2];          
            }
            else if (pbmi->bmiHeader.biCompression == BI_RGB)
            {
               redMask   = 0x00ff0000;
               greenMask = 0x0000ff00;
               blueMask  = 0x000000ff;
            }
            
            if ((redMask   == 0x00ff0000) &&
                (greenMask == 0x0000ff00) &&
                (blueMask  == 0x000000ff))
            {
                if (pbmi->bmiHeader.biBitCount == 24)
                {
                    pixelFormat = PixelFormat24bppRGB;
                }
                else if (pbmi->bmiHeader.biBitCount == 32)
                {
                    pixelFormat = PixelFormat32bppRGB;
                }
            }
            else if ((redMask   == 0x000000ff) &&
                     (greenMask == 0x0000ff00) &&
                     (blueMask  == 0x00ff0000) &&
                     (pbmi->bmiHeader.biBitCount == 24))
            {
                pixelFormat = PIXFMT_24BPP_BGR;
            }            
            else if ((redMask   == 0x00007c00) &&
                     (greenMask == 0x000003e0) &&
                     (blueMask  == 0x0000001f) &&
                     (pbmi->bmiHeader.biBitCount == 16))
            {
                pixelFormat = PixelFormat16bppRGB555;
            }
            else if ((redMask   == 0x0000f800) &&
                     (greenMask == 0x000007e0) &&
                     (blueMask  == 0x0000001f) &&
                     (pbmi->bmiHeader.biBitCount == 16))
            {
                pixelFormat = PixelFormat16bppRGB565;
            }
        }

        if (pixelFormat == PixelFormatUndefined)
        {
            ONCE(WARNING(("(once) ExtractPixelFormatFromHDC: Unrecognized pixel format")));
        }

        DeleteObject(hbm);
    }
    else
    {
        WARNING(("ExtractPixelFormatFromHDC: CreateCompatibleBitmap failed"));
    }

    return pixelFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\brush.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Brush API related declarations
*
* Revision History:
*
*   12/09/1998 davidx
*       Flesh out Brush interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _BRUSH_HPP
#define _BRUSH_HPP

#define HatchBrush HatchFillBrush

#include "path.hpp" // GpPathGradient needs GpPath.
#include <stddef.h>
#include "..\..\sdkinc\GdiplusColor.h"  // IsOpaque needs AlphaMask.

COLORREF
ToCOLORREF(
    const DpBrush *     deviceBrush
    );

enum GpSpecialGradientType
{
    GradientTypeNotSpecial,
    GradientTypeHorizontal,
    GradientTypeVertical,
    GradientTypeDiagonal,
    GradientTypePathTwoStep,
    GradientTypePathComplex
};

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class GpBrush : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagBrush : ObjectTagInvalid);
    }

public:

    // Make a copy of the Brush object

    virtual GpBrush* Clone() const = 0;

    // Virtual destructor

    virtual ~GpBrush() {}

    // Determine if brushes are equivalent
    virtual BOOL IsEqual(const GpBrush * brush) const
    {
        return DeviceBrush.Type == brush->DeviceBrush.Type;
    }

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    GpBrushType GetBrushType() const
    {
        return DeviceBrush.Type;
    }

    const DpBrush * GetDeviceBrush() const
    {
        return & DeviceBrush;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagBrush);
    }

    virtual const DpPath * GetOutlinePath() const
    {
        return NULL;
    }

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    //IsSolid currently means that the entire fill has the same ARGB color.
    //v2: Think about changing this to mean same RGB color instead.
    virtual BOOL IsSolid() const = 0;

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const = 0;

    // return Horizontal, Vertical, or (in future path)
    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const = 0;

    virtual ObjectType GetObjectType() const { return ObjectTypeBrush; }

    static GpBrush * GetBrush(const DpBrush * brush)
    {
        return (GpBrush *) ((BYTE *) brush - offsetof(GpBrush, DeviceBrush));
    }

    COLORREF ToCOLORREF() const
    {
        return ::ToCOLORREF(&DeviceBrush);
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds = NULL) = 0;

    void SetGammaCorrection(BOOL useGamma)
    {
        DeviceBrush.IsGammaCorrected = useGamma;
    }
    
    BOOL GetGammaCorrection() const
    {
        return DeviceBrush.IsGammaCorrected;
    }
    

protected:  // GDI+ Internal

    DpBrush DeviceBrush;

    mutable GpLockable Lockable;
};


//--------------------------------------------------------------------------
// Represent solid fill brush object
//--------------------------------------------------------------------------

class GpSolidFill : public GpBrush
{
public:

    GpSolidFill(VOID)
    {
        DefaultBrush();
    }

    GpSolidFill(const GpColor& color)
        : Color(color)
    {
        DeviceBrush.Type = BrushTypeSolidColor;
        DeviceBrush.SolidColor.SetColor(color.GetValue());
        SetValid(TRUE);
    }

    ~GpSolidFill() {}

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    GpColor GetColor() const
    {
        return Color;
    }

    VOID SetColor(const GpColor& color)
    {
        Color = color;
        DeviceBrush.SolidColor.SetColor(color.GetValue());
    }

    GpBrush* Clone() const
    {
        return new GpSolidFill(Color);
    }

    virtual BOOL IsEqual(const GpSolidFill * brush) const
    {
        return Color.IsEqual(brush->Color);
    }

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        return DeviceBrush.SolidColor.IsOpaque();
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return TRUE;
    }

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = Color.GetAlpha();
        *MaxAlpha = *MinAlpha;
        return TRUE;
    }
    
    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    //bhouse: why do we have store a GpColor here?
    GpColor         Color;

    VOID DefaultBrush()
    {
        Color.SetValue(Color::Black);
        DeviceBrush.Type = BrushTypeSolidColor;
        DeviceBrush.SolidColor.SetColor(Color.GetValue());
        SetValid(TRUE);
    }
};

//--------------------------------------------------------------------------
// Abstract brush which is made of an elementary object.
//--------------------------------------------------------------------------

class GpElementaryBrush : public GpBrush
{
public:

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    // Set/get brush transform

    GpStatus SetTransform(const GpMatrix& matrix)
    {
        GpStatus    status = Ok;

        // Keep the transform invertible

        if (matrix.IsInvertible())
        {
            DeviceBrush.Xform = matrix;
            UpdateUid();
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus GetTransform(GpMatrix* matrix) const
    {
        *matrix = DeviceBrush.Xform;

        return Ok;
    }

    GpStatus ResetTransform()
    {
        DeviceBrush.Xform.Reset();
        UpdateUid();

        return Ok;
    }

    GpStatus MultiplyTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateTransform(REAL dx, REAL dy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Translate(dx, dy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScaleTransform(REAL sx, REAL sy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Scale(sx, sy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScalePath(REAL sx, REAL sy)
    {
        DeviceBrush.Rect.X *= sx;
        DeviceBrush.Rect.Y *= sy;
        DeviceBrush.Rect.Height *= sy;
        DeviceBrush.Rect.Width *= sx;
        DeviceBrush.Points[0].X = DeviceBrush.Points[0].X * sx;
        DeviceBrush.Points[0].Y = DeviceBrush.Points[0].Y * sy;

        if (DeviceBrush.Path != NULL)
        {
            GpMatrix matrix(sx, 0.0f, 0.0f, sy, 0.0f, 0.0f); 
            DeviceBrush.Path->Transform(&matrix);
        }
        else if (DeviceBrush.PointsPtr && DeviceBrush.Count > 0)
        {
            for (INT i = 0; i < DeviceBrush.Count; i++)
            {
                DeviceBrush.PointsPtr[i].X *= sx;
                DeviceBrush.PointsPtr[i].Y *= sy;
            }
        }
        
        UpdateUid();

        return Ok;
    }
    
    GpStatus RotateTransform(REAL angle,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Rotate(angle, order);
        UpdateUid();

        return Ok;
    }

    // Set/get brush wrapping mode

    VOID SetWrapMode(GpWrapMode wrapMode)
    {
       if (!WrapModeIsValid(wrapMode))
          return;

       DeviceBrush.Wrap = wrapMode;
       UpdateUid();
    }

    GpWrapMode GetWrapMode() const
    {
        return DeviceBrush.Wrap;
    }

    // Get source rectangle

    VOID GetRect(GpRectF& rect) const
    {
        rect = DeviceBrush.Rect;
    }

    // Determine if the brushes are equivalent.  Only compare for equivalence
    // if both brushes are valid.

    virtual BOOL isEqual(const GpBrush * brush) const
    {
        if (GpBrush::IsEqual(brush))
        {
            const GpElementaryBrush * ebrush;

            ebrush = static_cast<const GpElementaryBrush *>(brush);
            return IsValid() &&
                   ebrush->IsValid() &&
                   ebrush->DeviceBrush.Wrap == DeviceBrush.Wrap &&
                   ebrush->DeviceBrush.Xform.IsEqual(&DeviceBrush.Xform);
        }
        else
        {
            return FALSE;
        }
    }

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

protected:  // GDI+ Internal

    GpElementaryBrush()
    {
        SetValid(FALSE);
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.IsGammaCorrected = FALSE;
    }

    GpElementaryBrush(const GpElementaryBrush* brush);

};

//--------------------------------------------------------------------------
// Represent texture brush object
//
// A rectangel returned by GetRect() is given by the pixel unit in case of
// GpBitmap and by the inch unit in case of GpMetafile.
//--------------------------------------------------------------------------

class GpTexture : public GpElementaryBrush
{
public:

    // Constructors

    GpTexture() {
        DefaultBrush();
    }

    GpTexture(GpImage* image, GpWrapMode wrapMode = WrapModeTile)
    {
        InitializeBrush(image, wrapMode, NULL);
    }

    GpTexture(GpImage* image, GpWrapMode wrapMode, const GpRectF& rect)
    {
        InitializeBrush(image, wrapMode, &rect);
    }

    GpTexture(GpImage *image, const GpRectF& rect, const GpImageAttributes *imageAttributes)
    {
        GpWrapMode wrapMode = WrapModeTile;
        if (imageAttributes)
        {
            wrapMode = imageAttributes->DeviceImageAttributes.wrapMode;
            if (!imageAttributes->HasRecoloring())
            {
                imageAttributes = NULL;
            }
        }
        InitializeBrush(image, wrapMode, &rect, imageAttributes);
    }

    GpBrush* Clone() const
    {
        return new GpTexture(this);
    }

    ~GpTexture() {
        if(Image)
            Image->Dispose();
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get texture brush attributes

    GpImage* GetImage()
    {
        // !!!
        //  Notice that we're returning a pointer
        //  to our internal bitmap object here.

        return Image;
    }

    GpImageType GetImageType() const
    {
        return ImageType;
    }

    GpBitmap* GetBitmap() const
    {
        // !!!
        //  Notice that we're returning a pointer
        //  to our internal bitmap object here.

        if(ImageType == ImageTypeBitmap)
            return static_cast<GpBitmap*>(Image);
        else
            return NULL;
    }

    GpStatus GetBitmapSize(Size * size) const
    {
        GpBitmap *  brushBitmap = this->GetBitmap();

        if (brushBitmap != NULL)
        {
            brushBitmap->GetSize(size);
            return Ok;
        }
        size->Width = size->Height = 0;
        return InvalidParameter;
    }


    // Check the opacity of bitmap.

    BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        DpTransparency transparency;

        GpBitmap *bitmap = GetBitmap();

        if (bitmap == NULL) 
        {
            return FALSE;
        }

        ASSERT(bitmap->IsValid());

        if (ColorsOnly)     // get real transparency, not cached
        {
            if (bitmap->GetTransparencyFlags(&transparency,
                                             PixelFormat32bppPARGB) != Ok)
            {
                transparency = TransparencyUnknown;
            }
        }
        else
        {
            if (bitmap->GetTransparencyHint(&transparency) != Ok)
            {
                transparency = TransparencyUnknown;
            }
        }

        switch (transparency)
        {
        case TransparencyUnknown:
        case TransparencySimple:
        case TransparencyComplex:
        case TransparencyNearConstant:
            return FALSE;

        case TransparencyOpaque:
        case TransparencyNoAlpha:
            return TRUE;
        }

        ASSERT(FALSE);

        return FALSE;
    }

    BOOL Is01Bitmap() const
    {
       DpTransparency transparency;
       GpBitmap *bitmap = GetBitmap();

       if (bitmap == NULL)
       {
           return FALSE;
       }

       ASSERT(bitmap->IsValid());

       if (bitmap->GetTransparencyHint(&transparency) != Ok)
           return FALSE;

       switch (transparency)
       {
       case TransparencyUnknown:
       case TransparencyOpaque:
       case TransparencyNoAlpha:
       case TransparencyComplex:
       case TransparencyNearConstant:
           return FALSE;

       case TransparencySimple:
           return TRUE;
       }

       ASSERT(FALSE);

       return FALSE;
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const
    {
        DpTransparency transparency;
        GpBitmap *bitmap = GetBitmap();
 
        if (bitmap == NULL)
        {
            return FALSE;
        }
 
        ASSERT(bitmap->IsValid());
 
        return (bitmap->GetTransparencyFlags(&transparency,
                                             PixelFormat32bppPARGB,
                                             MinAlpha,
                                             MaxAlpha) == Ok) &&
                transparency == TransparencyNearConstant;
    }
    
    // See if this texture fill is really a picture fill
    BOOL IsPictureFill(
        const GpMatrix *    worldToDevice,
        const GpRect *      drawBounds
        ) const;

    // Determine if the brushes are equivalent

    virtual BOOL isEqual(const GpBrush * brush) const
    {
       // HACKHACK - To avoid a potentially large bitmap comparison,
       // treat all texture brushes as different...
       return FALSE;
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    GpTexture(const GpTexture *brush);

    VOID InitializeBrush(
        GpImage* image,
        GpWrapMode wrapMode,
        const GpRectF* rect,
        const GpImageAttributes *imageAttributes=NULL);
    VOID InitializeBrushBitmap(
        GpBitmap* bitmap,
        GpWrapMode wrapMode,
        const GpRectF* rect,
        const GpImageAttributes *imageAttributes,
        BOOL useBitmap = FALSE  // use the bitmap instead of cloning it?
        );
    VOID DefaultBrush()
    {
        InitializeBrushBitmap(NULL, WrapModeTile, NULL, NULL);
    }

private:

    GpImageType     ImageType;
    GpImage *       Image;      // brush image
};


class GpGradientBrush : public GpElementaryBrush
{
public:
    virtual VOID GetColors(GpColor* colors) const = 0;
    virtual INT GetNumberOfColors()         const = 0;
    virtual BOOL UsesDefaultColorArray()    const = 0;
    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    virtual GpStatus SetBlend(
                const REAL* blendFactors,
                const REAL* blendPositions,
                INT count)
            {
                return NotImplemented;
            }

    // Determine if the brushes are equivalent
    virtual BOOL isEqual(const GpBrush * brush) const
    {
        if (GpElementaryBrush::IsEqual(brush))
        {
            const DpBrush * deviceBrush = brush->GetDeviceBrush();

            return deviceBrush->Rect.Equals(DeviceBrush.Rect);
        }
        else
        {
            return FALSE;
        }
    }

    virtual GpStatus BlendWithWhite()
    {
        return NotImplemented;
    }

    GpStatus SetSigmaBlend(REAL focus, REAL scale = 1.0f);

    GpStatus SetLinearBlend(REAL focus, REAL scale = 1.0f);

protected:

    GpGradientBrush()
    {
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    }

    GpGradientBrush(
        const GpGradientBrush* brush
        ) : GpElementaryBrush(brush)
    {
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    }

    GpStatus GetSigmaBlendArray(
        REAL focus,
        REAL scale,
        INT* count,
        REAL* blendFactors,
        REAL* blendPositions);

    GpStatus GetLinearBlendArray(
        REAL focus,
        REAL scale,
        INT* count,
        REAL* blendFactors,
        REAL* blendPositions);
};

//--------------------------------------------------------------------------
// Represent rectangular gradient brush object
//--------------------------------------------------------------------------

class GpRectGradient : public GpGradientBrush
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;
friend class DpOutputLinearGradientSpan;

public:

    // Constructors

    GpRectGradient(VOID)
    {
        DefaultBrush();
    }

    GpRectGradient(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeTile)
    {
        InitializeBrush(rect, colors, wrapMode);
    }

    virtual GpBrush* Clone() const
    {
        return new GpRectGradient(this);
    }

    ~GpRectGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendFactors[1]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.BlendPositions[1]);
        GpFree(DeviceBrush.PresetColors);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual GpStatus BlendWithWhite();
   
    // Get/set colors

    VOID GetColors(GpColor* colors) const
    {
        ASSERT(colors);

        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
        colors[2] = DeviceBrush.Colors[2];
        colors[3] = DeviceBrush.Colors[3];
    }

    VOID SetColors(const GpColor* colors)
    {
        ASSERT(colors);

        DeviceBrush.Colors[0] = colors[0];
        DeviceBrush.Colors[1] = colors[1];
        DeviceBrush.Colors[2] = colors[2];
        DeviceBrush.Colors[3] = colors[3];
        UpdateUid();
    }

    INT GetNumberOfColors() const {return 4;}
    BOOL UsesDefaultColorArray() const {return TRUE;}
    
    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    INT GetHorizontalBlendCount()
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetHorizontalBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count
        );

    GpStatus SetHorizontalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        );

    INT GetVerticalBlendCount()
    {
        return DeviceBrush.BlendCounts[1];
    }

    GpStatus GetVerticalBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count
        );

    virtual GpStatus SetVerticalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        );

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    // Check the opacity of this brush element.  It is opaque only if
    // ALL of the colors are opaque.

    BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        BOOL opaque =  ColorsOnly || DeviceBrush.Wrap != WrapModeClamp;

        if (HasPresetColors()) 
        {      
            INT i=0;
            while (opaque && (i < DeviceBrush.BlendCounts[0]))
            {
                opaque = opaque && GpColor(DeviceBrush.PresetColors[i]).IsOpaque();
                i++;
            }
        }
        else
        {
            opaque = opaque && 
                     DeviceBrush.Colors[0].IsOpaque() &&
                     DeviceBrush.Colors[1].IsOpaque() &&
                     DeviceBrush.Colors[2].IsOpaque() &&
                     DeviceBrush.Colors[3].IsOpaque();
        }

        return opaque;
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        if (HasPresetColors()) 
        {
            *MaxAlpha = GpColor(DeviceBrush.PresetColors[0]).GetAlpha();
            *MinAlpha = *MaxAlpha;
            
            for (INT i=1; i<DeviceBrush.BlendCounts[0]; i++)
            {
                *MaxAlpha = max(*MaxAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
                *MinAlpha = min(*MinAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
            }
        }
        else
        {
            *MinAlpha = min(min(DeviceBrush.Colors[0].GetAlpha(),
                               DeviceBrush.Colors[1].GetAlpha()),
                           min(DeviceBrush.Colors[2].GetAlpha(),
                               DeviceBrush.Colors[3].GetAlpha()));
            *MaxAlpha = max(max(DeviceBrush.Colors[0].GetAlpha(),
                               DeviceBrush.Colors[1].GetAlpha()),
                           max(DeviceBrush.Colors[2].GetAlpha(),
                               DeviceBrush.Colors[3].GetAlpha()));
        }
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

protected:

    GpRectGradient(const GpRectGradient* brush);

    VOID InitializeBrush(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType) BrushTypeLinearGradient; // BrushRectGrad;
        DeviceBrush.Wrap = wrapMode;
        DeviceBrush.Rect = rect;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.PresetColors = NULL;

        if(!WrapModeIsValid(wrapMode) || rect.Width <= 0 || rect.Height <= 0)
        {
            SetValid(FALSE);
            return;
        }

        SetValid(TRUE);
        SetColors(colors);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = (BrushType) BrushTypeLinearGradient; //BrushRectGrad;
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.UsesPresetColors = FALSE;
        GpMemset(&DeviceBrush.Rect, 0, sizeof(Rect));

        GpColor color;   // NULL brush

        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.Colors[2] = color;
        DeviceBrush.Colors[3] = color;

        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.PresetColors = NULL;

        // Defaults used for GpLineGradient
        DeviceBrush.IsAngleScalable = FALSE;
        DeviceBrush.Points[0].X = DeviceBrush.Points[0].Y = 0;
        DeviceBrush.Points[1].X = DeviceBrush.Points[1].Y = 0;

        SetValid(FALSE);
    }

protected:

};


class GpLineGradient : public GpRectGradient
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;

public:

    // Constructors

    GpLineGradient(VOID)
    {
        DefaultBrush();
    }

    GpLineGradient(
        const GpPointF& point1,
        const GpPointF& point2,
        const GpColor& color1,
        const GpColor& color2,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        LinearGradientMode mode,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        REAL angle,
        BOOL isAngleScalable = FALSE,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeTile)
        :GpRectGradient(rect, colors, wrapMode)
    {
    }

    GpBrush* Clone() const
    {
        return new GpLineGradient(this);
    }

    virtual GpStatus BlendWithWhite();

    // Note: ChangeLinePoints works dramatically differently than SetLinePoints.
    //       ChangeLinePoints is more like the constructor that takes points.
    GpStatus
    GpLineGradient::ChangeLinePoints(
        const GpPointF&     point1,
        const GpPointF&     point2,
        BOOL                isAngleScalable
        );

    GpStatus SetLinePoints(const GpPointF& point1, const GpPointF& point2);
    GpStatus GetLinePoints(GpPointF* points);

    VOID SetLineColors(const GpColor& color1, const GpColor& color2)
    {
        DeviceBrush.Colors[0] = color1;
        DeviceBrush.Colors[1] = color2;
        DeviceBrush.Colors[2] = color1;
        DeviceBrush.Colors[3] = color2;
        UpdateUid();
    }

    VOID GetLineColors(GpColor* colors)
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    INT GetBlendCount()
    {
        return GetHorizontalBlendCount();
    }

    GpStatus GetBlend(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return GetHorizontalBlend(blendFactors, blendPositions, count);
    }

    GpStatus SetBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        )
    {
        return SetHorizontalBlend(blendFactors, blendPositions, count);
    }

    // Setting Vertical Blend factor is not allowed.

    GpStatus SetVerticalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        )
    {
        ASSERT(0);
        return GenericError;
    }

    // Get/set preset blend-factors

    INT GetPresetBlendCount();

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count);

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        GpMatrix m;

        GpMatrix::MultiplyMatrix(m, DeviceBrush.Xform, *matrix);

        if (m.IsTranslateScale())
        {
            return GradientTypeVertical;
        }
        else if (REALABS(m.GetM11()) < CPLX_EPSILON &&
                 REALABS(m.GetM12()) >= CPLX_EPSILON &&
                 REALABS(m.GetM21()) >= CPLX_EPSILON &&
                 REALABS(m.GetM22()) < CPLX_EPSILON)
        {
            return GradientTypeHorizontal;
        }
        else
        {
            return GradientTypeDiagonal;
        }
    }

protected:

    GpLineGradient(const GpLineGradient* brush);

    GpStatus SetLineGradient(
        const GpPointF& point1,
        const GpPointF& point2,
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        REAL angle,
        BOOL isAngleScalable = FALSE,
        GpWrapMode wrapMode = WrapModeTile
        );
};

//--------------------------------------------------------------------------
// Represent radial gradient brush object
//--------------------------------------------------------------------------
#if 0

class GpRadialGradient : public GpGradientBrush
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;

public:

    // Constructors

    GpRadialGradient(VOID)
    {
        DefaultBrush();
    }

    GpRadialGradient(
        const GpRectF& rect,
        const GpColor& centerColor,
        const GpColor& boundaryColor,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(rect, centerColor, boundaryColor, wrapMode);
    }

    GpBrush* Clone() const
    {
        return new GpRadialGradient(this);
    }

    ~GpRadialGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.PresetColors);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get/set color attributes

    VOID SetCenterColor(const GpColor& color)
    {
        DeviceBrush.Colors[0] = color;
        UpdateUid();
    }

    VOID SetBoundaryColor(const GpColor& color)
    {
        DeviceBrush.Colors[1] = color;
        UpdateUid();
    }

    GpColor GetCenterColor() const
    {
        return DeviceBrush.Colors[0];
    }

    GpColor GetBoundaryColor() const
    {
        return DeviceBrush.Colors[1];
    }

    VOID GetColors(GpColor* colors) const
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
    }

    INT GetNumberOfColors() const {return 2;}
    BOOL UsesDefaultColorArray() const {return TRUE;}

    // Get/set falloff / blend-factors

    INT GetBlendCount()
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend(
        const REAL* blendFactors,
        const REAL* blendPosition,
        INT count
        );

    // Get/set preset blend-factors

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    INT GetPresetBlendCount() const;

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count) const;

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque and wrap mode is not WrapModeClamp.
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the oval.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque() &&
                (ColorsOnly || DeviceBrush.Wrap != WrapModeClamp));
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    GpRadialGradient(const GpRadialGradient *brush);

    VOID
    InitializeBrush(
        const GpRectF& rect,
        const GpColor& centerColor,
        const GpColor& boundaryColor,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType)-1; //BrushRadialGrad;
        DeviceBrush.Wrap = wrapMode;
        DeviceBrush.Rect = rect;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.Colors[0] = centerColor;
        DeviceBrush.Colors[1] = boundaryColor;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.PresetColors = NULL;

        SetValid(WrapModeIsValid(wrapMode) && rect.Width > 0 && rect.Height > 0);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = (BrushType)-1; //BrushRadialGrad;
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.UsesPresetColors = FALSE;
        GpColor color(255, 255, 255);   // Opaque white
        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.PresetColors = NULL;
        SetValid(FALSE);
    }

};
#endif

//--------------------------------------------------------------------------
// Represent triangle gradient brush object
//--------------------------------------------------------------------------
#if 0
class GpTriangleGradient : public GpGradientBrush
{
friend class DpOutputTriangleGradientSpan;

public:

    // Constructors

    GpTriangleGradient(VOID)
    {
        DefaultBrush();
    }

    GpTriangleGradient(
        const GpPointF* points,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(
            points,
            colors,
            wrapMode);
    }

    GpBrush* Clone() const
    {
        return new GpTriangleGradient(this);
    }

    ~GpTriangleGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendFactors[1]);
        GpFree(DeviceBrush.BlendFactors[2]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.BlendPositions[1]);
        GpFree(DeviceBrush.BlendPositions[2]);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get/set colors

    VOID GetColors(GpColor* colors) const
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
        colors[2] = DeviceBrush.Colors[2];
    }

    VOID SetColors(const GpColor* colors)
    {
        DeviceBrush.Colors[0] = colors[0];
        DeviceBrush.Colors[1] = colors[1];
        DeviceBrush.Colors[2] = colors[2];
        UpdateUid();
    }

    // Get/set triangle

    VOID GetTriangle(GpPointF* points) const
    {
        points[0] = DeviceBrush.Points[0];
        points[1] = DeviceBrush.Points[1];
        points[2] = DeviceBrush.Points[2];
    }

    VOID SetTriangle(const GpPointF* points)
    {
        DeviceBrush.Points[0] = points[0];
        DeviceBrush.Points[1] = points[1];
        DeviceBrush.Points[2] = points[2];
        UpdateUid();
    }

    INT GetNumberOfColors() const {return 3;}
    BOOL UsesDefaultColorArray() const {return TRUE;}

    // Get/set falloff / blend-factors

    INT GetBlendCount0() const
    {
        return DeviceBrush.BlendCounts[0];
    }

    INT GetBlendCount1() const
    {
        return DeviceBrush.BlendCounts[1];
    }

    INT GetBlendCount2() const
    {
        return DeviceBrush.BlendCounts[2];
    }

    //!!! bhouse We really don't need all of these GetBlendX methods.  We
    //    should just implement a single GetBlend() which takes an index.
    //    With the change to the data layout, the argument for this method
    //    is stronger.  This should remove a bunch of redundant code.

    GpStatus GetBlend0(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend0(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    GpStatus GetBlend1(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend1(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    GpStatus GetBlend2(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend2(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque.
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the triangle.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque() &&
                DeviceBrush.Colors[2].IsOpaque() &&
                (ColorsOnly || DeviceBrush.Wrap != WrapModeClamp));
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MinAlpha = min(*MinAlpha,
                        DeviceBrush.Colors[2].GetAlpha());

        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = min(*MaxAlpha,
                        DeviceBrush.Colors[2].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const pRect *drawBounds=NULL);


protected:  // GDI+ Internal

    GpTriangleGradient(const GpTriangleGradient* brush);

    VOID
    InitializeBrush(
        const GpPointF* points,
        const GpColor* colors,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType)-1; //BrushTriangleGrad;
        DeviceBrush.Wrap = wrapMode;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.Falloffs[2] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendCounts[2] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendFactors[2] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.BlendPositions[2] = NULL;

        GpMemcpy(&DeviceBrush.Points[0],
                 points,
                 3*sizeof(GpPointF));

        GpMemcpy(&DeviceBrush.Colors[0],
                 colors,
                 3*sizeof(GpColor));

        // Get the boundary rectangle.

        REAL xmin, xmax, ymin, ymax;

        xmin = min(DeviceBrush.Points[0].X,
                   DeviceBrush.Points[1].X);
        xmax = max(DeviceBrush.Points[0].X,
                   DeviceBrush.Points[1].X);
        ymin = min(DeviceBrush.Points[0].Y,
                   DeviceBrush.Points[1].Y);
        ymax = max(DeviceBrush.Points[0].Y,
                   DeviceBrush.Points[1].Y);
        xmin = min(xmin, DeviceBrush.Points[2].X);
        xmax = max(xmax, DeviceBrush.Points[2].X);
        ymin = min(ymin, DeviceBrush.Points[2].Y);
        ymax = max(ymax, DeviceBrush.Points[2].Y);
        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(!WrapModeIsValid(wrapMode) ||
           DeviceBrush.Rect.Width <= 0 ||
           DeviceBrush.Rect.Height <= 0)
        {
            SetValid(FALSE);
            return;
        }
        SetValid(TRUE);
    }

    VOID DefaultBrush()
    {
        DeviceBrush.Type =  (BrushType)-1; //BrushTriangleGrad;
        GpMemset(&DeviceBrush.Points, 0, 3*sizeof(GpPointF));
        DeviceBrush.Wrap = WrapModeClamp;

        GpColor color(255, 255, 255);   // Opaque white
        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.Colors[2] = color;

        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.Falloffs[2] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendCounts[2] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendFactors[2] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.BlendPositions[2] = NULL;

        SetValid(FALSE);
    }


};
#endif

//--------------------------------------------------------------------------
// Represent polygon gradient brush object
//--------------------------------------------------------------------------

class GpPathGradient : public GpGradientBrush
{
friend class DpOutputPathGradientSpan;
friend class DpOutputOneDPathGradientSpan;

public:

    // Constructors

    GpPathGradient()
    {
        DefaultBrush();
    }

    GpPathGradient(
        const GpPointF* points,
        INT count,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(
            points,
            count,
            wrapMode);
    }

    GpPathGradient(
        const GpPath* path,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        DefaultBrush();
        DeviceBrush.Wrap = wrapMode;
        if(path)
        {
            DeviceBrush.Path = new GpPath((GpPath*) path);
            PrepareBrush();
        }
        else
            DeviceBrush.Path = NULL;
    }

    BOOL IsRectangle() const;

    GpBrush* Clone() const
    {
        return new GpPathGradient(this);
    }

    ~GpPathGradient()
    {
        if(DeviceBrush.Path)
            delete DeviceBrush.Path;
        else
            GpFree(DeviceBrush.PointsPtr);

        GpFree(DeviceBrush.ColorsPtr);
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.PresetColors);

        if(MorphedBrush)
            delete MorphedBrush;
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual GpStatus BlendWithW